{"sha": "5211e37b1dd6b7fc26d919941e958bce8f5815a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMTFlMzdiMWRkNmI3ZmMyNmQ5MTk5NDFlOTU4YmNlOGY1ODE1YTA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-14T21:40:53Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: don't pass Namespace explicitly, but rather track it in FmtPrinter.", "tree": {"sha": "9f6a65fc59cf6aac45d26e542b0c228308a783aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f6a65fc59cf6aac45d26e542b0c228308a783aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5211e37b1dd6b7fc26d919941e958bce8f5815a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5211e37b1dd6b7fc26d919941e958bce8f5815a0", "html_url": "https://github.com/rust-lang/rust/commit/5211e37b1dd6b7fc26d919941e958bce8f5815a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5211e37b1dd6b7fc26d919941e958bce8f5815a0/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab26b26d3471e5a26e38d9100a272b1c9d013112", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab26b26d3471e5a26e38d9100a272b1c9d013112", "html_url": "https://github.com/rust-lang/rust/commit/ab26b26d3471e5a26e38d9100a272b1c9d013112"}], "stats": {"total": 258, "additions": 102, "deletions": 156}, "files": [{"sha": "ad24e15b45a5158f01999c337ee4975fa60bdf8e", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5211e37b1dd6b7fc26d919941e958bce8f5815a0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5211e37b1dd6b7fc26d919941e958bce8f5815a0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=5211e37b1dd6b7fc26d919941e958bce8f5815a0", "patch": "@@ -444,7 +444,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         terr: &TypeError<'tcx>,\n         sp: Span,\n     ) {\n-        use hir::def::Namespace;\n         use hir::def_id::CrateNum;\n         use ty::print::{PrintCx, Printer};\n         use ty::subst::SubstsRef;\n@@ -484,7 +483,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 self: PrintCx<'_, '_, 'tcx, Self>,\n                 _self_ty: Ty<'tcx>,\n                 _trait_ref: Option<ty::TraitRef<'tcx>>,\n-                _ns: Namespace,\n             ) -> Result<Self::Path, Self::Error> {\n                 Err(NonTrivialPath)\n             }\n@@ -517,7 +515,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ) -> Result<Self::Path, Self::Error>,\n                 _params: &[ty::GenericParamDef],\n                 _substs: SubstsRef<'tcx>,\n-                _ns: Namespace,\n                 _projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n             ) -> Result<Self::Path, Self::Error> {\n                 print_prefix(self)\n@@ -530,7 +527,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             if !(did1.is_local() || did2.is_local()) && did1.krate != did2.krate {\n                 let abs_path = |def_id| {\n                     PrintCx::with(self.tcx, AbsolutePathPrinter, |cx| {\n-                        cx.print_def_path(def_id, None, Namespace::TypeNS, iter::empty())\n+                        cx.print_def_path(def_id, None, iter::empty())\n                     })\n                 };\n "}, {"sha": "2fabbbeadbd9c3ef0bc73c3b8e554ebb4ef1315f", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5211e37b1dd6b7fc26d919941e958bce8f5815a0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5211e37b1dd6b7fc26d919941e958bce8f5815a0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=5211e37b1dd6b7fc26d919941e958bce8f5815a0", "patch": "@@ -1,9 +1,10 @@\n+use crate::hir::def::Namespace;\n use crate::hir::{self, Local, Pat, Body, HirId};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::infer::InferCtxt;\n use crate::infer::type_variable::TypeVariableOrigin;\n use crate::ty::{self, Ty, Infer, TyVar};\n-use ty::print::Print;\n+use crate::ty::print::Print;\n use syntax::source_map::CompilerDesugaringKind;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n@@ -79,7 +80,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let mut s = String::new();\n-        let mut printer = ty::print::FmtPrinter::new(&mut s);\n+        let mut printer = ty::print::FmtPrinter::new(&mut s, Namespace::TypeNS);\n         if let Some(highlight) = highlight {\n             printer.region_highlight_mode = highlight;\n         }"}, {"sha": "39ab244dae1c572d7c04a825fae5ca018fdb0b31", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5211e37b1dd6b7fc26d919941e958bce8f5815a0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5211e37b1dd6b7fc26d919941e958bce8f5815a0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=5211e37b1dd6b7fc26d919941e958bce8f5815a0", "patch": "@@ -1,4 +1,5 @@\n use errors::DiagnosticBuilder;\n+use crate::hir::def::Namespace;\n use crate::hir::def_id::DefId;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n@@ -343,7 +344,7 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n             >,\n         {\n             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                let mut printer = ty::print::FmtPrinter::new(f);\n+                let mut printer = ty::print::FmtPrinter::new(f, Namespace::TypeNS);\n                 printer.region_highlight_mode = self.highlight;\n \n                 ty::print::PrintCx::with(self.tcx, printer, |cx| {"}, {"sha": "c2cafac2d5580ca9e52d2ae0747db9e283c40d94", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5211e37b1dd6b7fc26d919941e958bce8f5815a0/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5211e37b1dd6b7fc26d919941e958bce8f5815a0/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=5211e37b1dd6b7fc26d919941e958bce8f5815a0", "patch": "@@ -2369,7 +2369,8 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                 };\n \n                 // When printing regions, add trailing space if necessary.\n-                ty::print::PrintCx::with_tls_tcx(ty::print::FmtPrinter::new(fmt), |cx| {\n+                let ns = Namespace::ValueNS;\n+                ty::print::PrintCx::with_tls_tcx(ty::print::FmtPrinter::new(fmt, ns), |cx| {\n                     let region = if cx.config.is_verbose || cx.config.identify_regions {\n                         let mut region = region.to_string();\n                         if region.len() > 0 {"}, {"sha": "a94ae0123d85d87905253c4faadd56f910daeaa4", "filename": "src/librustc/ty/print.rs", "status": "modified", "additions": 67, "deletions": 56, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/5211e37b1dd6b7fc26d919941e958bce8f5815a0/src%2Flibrustc%2Fty%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5211e37b1dd6b7fc26d919941e958bce8f5815a0/src%2Flibrustc%2Fty%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint.rs?ref=5211e37b1dd6b7fc26d919941e958bce8f5815a0", "patch": "@@ -258,20 +258,18 @@ pub trait Printer: Sized {\n         self: PrintCx<'_, '_, 'tcx, Self>,\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n-        ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n-        self.default_print_def_path(def_id, substs, ns, projections)\n+        self.default_print_def_path(def_id, substs, projections)\n     }\n     fn print_impl_path(\n         self: PrintCx<'_, '_, 'tcx, Self>,\n         impl_def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n-        ns: Namespace,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n-        self.default_print_impl_path(impl_def_id, substs, ns, self_ty, trait_ref)\n+        self.default_print_impl_path(impl_def_id, substs, self_ty, trait_ref)\n     }\n \n     fn print_region(\n@@ -292,7 +290,6 @@ pub trait Printer: Sized {\n         self: PrintCx<'_, '_, 'tcx, Self>,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n-        ns: Namespace,\n     ) -> Result<Self::Path, Self::Error>;\n \n     fn path_append_impl<'gcx, 'tcx>(\n@@ -317,7 +314,6 @@ pub trait Printer: Sized {\n         ) -> Result<Self::Path, Self::Error>,\n         params: &[ty::GenericParamDef],\n         substs: SubstsRef<'tcx>,\n-        ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     ) -> Result<Self::Path, Self::Error>;\n }\n@@ -350,16 +346,20 @@ pub trait PrettyPrinter:\n         })\n     }\n \n+    /// Like `print_def_path` but for value paths.\n+    fn print_value_path(\n+        self: PrintCx<'_, '_, 'tcx, Self>,\n+        def_id: DefId,\n+        substs: Option<SubstsRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.print_def_path(def_id, substs, iter::empty())\n+    }\n+\n     /// Print `<...>` around what `f` prints.\n     fn generic_delimiters<'gcx, 'tcx>(\n-        mut self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n         f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, Self::Error>,\n-    ) -> Result<Self, Self::Error> {\n-        write!(self.printer, \"<\")?;\n-        let mut printer = f(self)?;\n-        write!(printer, \">\")?;\n-        Ok(printer)\n-    }\n+    ) -> Result<Self, Self::Error>;\n \n     /// Return `true` if the region should be printed in path generic args\n     /// even when it's `'_`, such as in e.g. `Foo<'_, '_, '_>`.\n@@ -414,8 +414,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let ns = self.guess_def_namespace(def_id);\n         debug!(\"def_path_str: def_id={:?}, ns={:?}\", def_id, ns);\n         let mut s = String::new();\n-        let _ = PrintCx::with(self, FmtPrinter::new(&mut s), |cx| {\n-            cx.print_def_path(def_id, None, ns, iter::empty())\n+        let _ = PrintCx::with(self, FmtPrinter::new(&mut s, ns), |cx| {\n+            cx.print_def_path(def_id, None, iter::empty())\n         });\n         s\n     }\n@@ -426,10 +426,9 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n         self,\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n-        ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     ) -> Result<P::Path, P::Error> {\n-        debug!(\"default_print_def_path: def_id={:?}, substs={:?}, ns={:?}\", def_id, substs, ns);\n+        debug!(\"default_print_def_path: def_id={:?}, substs={:?}\", def_id, substs);\n         let key = self.tcx.def_key(def_id);\n         debug!(\"default_print_def_path: key={:?}\", key);\n \n@@ -449,7 +448,7 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n                 if let Some(substs) = substs {\n                     impl_trait_ref = impl_trait_ref.subst(self.tcx, substs);\n                 }\n-                self.print_impl_path(def_id, substs, ns, self_ty, impl_trait_ref)\n+                self.print_impl_path(def_id, substs, self_ty, impl_trait_ref)\n             }\n \n             _ => {\n@@ -467,12 +466,12 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n                             parent_generics.has_self && parent_generics.parent_count == 0;\n                         if let (Some(substs), true) = (substs, parent_has_own_self) {\n                             let trait_ref = ty::TraitRef::new(parent_def_id, substs);\n-                            cx.path_qualified(trait_ref.self_ty(), Some(trait_ref), ns)\n+                            cx.path_qualified(trait_ref.self_ty(), Some(trait_ref))\n                         } else {\n-                            cx.print_def_path(parent_def_id, substs, ns, iter::empty())\n+                            cx.print_def_path(parent_def_id, substs, iter::empty())\n                         }\n                     } else {\n-                        cx.print_def_path(parent_def_id, None, ns, iter::empty())\n+                        cx.print_def_path(parent_def_id, None, iter::empty())\n                     }\n                 };\n                 let print_path = |cx: PrintCx<'_, 'gcx, 'tcx, P>| {\n@@ -492,7 +491,7 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n                 if let (Some(generics), Some(substs)) = (generics, substs) {\n                     let has_own_self = generics.has_self && generics.parent_count == 0;\n                     let params = &generics.params[has_own_self as usize..];\n-                    self.path_generic_args(print_path, params, substs, ns, projections)\n+                    self.path_generic_args(print_path, params, substs, projections)\n                 } else {\n                     print_path(self)\n                 }\n@@ -504,7 +503,6 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n         self,\n         impl_def_id: DefId,\n         _substs: Option<SubstsRef<'tcx>>,\n-        ns: Namespace,\n         self_ty: Ty<'tcx>,\n         impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<P::Path, P::Error> {\n@@ -531,14 +529,14 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n             // trait-type, then fallback to a format that identifies\n             // the module more clearly.\n             self.path_append_impl(\n-                |cx| cx.print_def_path(parent_def_id, None, ns, iter::empty()),\n+                |cx| cx.print_def_path(parent_def_id, None, iter::empty()),\n                 self_ty,\n                 impl_trait_ref,\n             )\n         } else {\n             // Otherwise, try to give a good form that would be valid language\n             // syntax. Preferably using associated item notation.\n-            self.path_qualified(self_ty, impl_trait_ref, ns)\n+            self.path_qualified(self_ty, impl_trait_ref)\n         }\n     }\n }\n@@ -594,14 +592,16 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n pub struct FmtPrinter<F: fmt::Write> {\n     pub(crate) fmt: F,\n     empty: bool,\n+    in_value: bool,\n     pub region_highlight_mode: RegionHighlightMode,\n }\n \n impl<F: fmt::Write> FmtPrinter<F> {\n-    pub fn new(fmt: F) -> Self {\n+    pub fn new(fmt: F, ns: Namespace) -> Self {\n         FmtPrinter {\n             fmt,\n             empty: true,\n+            in_value: ns == Namespace::ValueNS,\n             region_highlight_mode: RegionHighlightMode::default(),\n         }\n     }\n@@ -645,7 +645,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                 }) => {\n                     debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n                     return Ok((if !span.is_dummy() {\n-                        self.print_def_path(def_id, None, Namespace::TypeNS, iter::empty())?\n+                        self.print_def_path(def_id, None, iter::empty())?\n                     } else {\n                         self.path_crate(cnum)?\n                     }, true));\n@@ -760,20 +760,13 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n         self,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n-        ns: Namespace,\n     ) -> Result<P::Path, P::Error> {\n         if trait_ref.is_none() {\n             // Inherent impls. Try to print `Foo::bar` for an inherent\n             // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n             // anything other than a simple path.\n             match self_ty.sty {\n-                ty::Adt(adt_def, substs) => {\n-                    return self.print_def_path(adt_def.did, Some(substs), ns, iter::empty());\n-                }\n-                ty::Foreign(did) => {\n-                    return self.print_def_path(did, None, ns, iter::empty());\n-                }\n-\n+                ty::Adt(..) | ty::Foreign(_) |\n                 ty::Bool | ty::Char | ty::Str |\n                 ty::Int(_) | ty::Uint(_) | ty::Float(_) => {\n                     return self_ty.print_display(self);\n@@ -787,12 +780,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             nest!(cx, |cx| self_ty.print_display(cx));\n             if let Some(trait_ref) = trait_ref {\n                 write!(cx.printer, \" as \")?;\n-                nest!(cx, |cx| cx.print_def_path(\n-                    trait_ref.def_id,\n-                    Some(trait_ref.substs),\n-                    Namespace::TypeNS,\n-                    iter::empty(),\n-                ));\n+                nest!(cx, |cx| trait_ref.print_display(cx));\n             }\n             Ok(cx.printer)\n         })\n@@ -827,7 +815,6 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n         ) -> Result<P::Path, P::Error>,\n         params: &[ty::GenericParamDef],\n         substs: SubstsRef<'tcx>,\n-        ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     ) -> Result<P::Path, P::Error> {\n         nest!(self, |cx| print_prefix(cx));\n@@ -878,11 +865,6 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             return Ok(self.printer);\n         }\n \n-        // FIXME(eddyb) move this into `generic_delimiters`.\n-        if ns == Namespace::ValueNS {\n-            write!(self.printer, \"::\")?;\n-        }\n-\n         self.generic_delimiters(|mut cx| {\n             let mut empty = true;\n             let mut maybe_comma = |cx: &mut Self| {\n@@ -950,7 +932,6 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         mut self: PrintCx<'_, '_, 'tcx, Self>,\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n-        ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n         // FIXME(eddyb) avoid querying `tcx.generics_of` and `tcx.def_key`\n@@ -967,7 +948,7 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n                 return if let (Some(generics), Some(substs)) = (generics, substs) {\n                     let has_own_self = generics.has_self && generics.parent_count == 0;\n                     let params = &generics.params[has_own_self as usize..];\n-                    self.path_generic_args(|cx| Ok(cx.printer), params, substs, ns, projections)\n+                    self.path_generic_args(|cx| Ok(cx.printer), params, substs, projections)\n                 } else {\n                     Ok(self.printer)\n                 };\n@@ -992,13 +973,13 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n                 let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n                 let span = self.tcx.def_span(def_id);\n                 return self.path_append(\n-                    |cx| cx.print_def_path(parent_def_id, None, ns, iter::empty()),\n+                    |cx| cx.print_def_path(parent_def_id, None, iter::empty()),\n                     &format!(\"<impl at {:?}>\", span),\n                 );\n             }\n         }\n \n-        self.default_print_def_path(def_id, substs, ns, projections)\n+        self.default_print_def_path(def_id, substs, projections)\n     }\n \n     fn print_region(\n@@ -1103,9 +1084,8 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         self: PrintCx<'_, '_, 'tcx, Self>,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n-        ns: Namespace,\n     ) -> Result<Self::Path, Self::Error> {\n-        self.pretty_path_qualified(self_ty, trait_ref, ns)\n+        self.pretty_path_qualified(self_ty, trait_ref)\n     }\n \n     fn path_append_impl<'gcx, 'tcx>(\n@@ -1119,7 +1099,9 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         self.pretty_path_append_impl(|cx| {\n             let mut printer = print_prefix(cx)?;\n \n-            if !printer.empty {\n+            // HACK(eddyb) this accounts for `generic_delimiters`\n+            // printing `::<` instead of `<` if `in_value` is set.\n+            if !printer.empty && !printer.in_value {\n                 write!(printer, \"::\")?;\n             }\n \n@@ -1153,10 +1135,9 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         ) -> Result<Self::Path, Self::Error>,\n         params: &[ty::GenericParamDef],\n         substs: SubstsRef<'tcx>,\n-        ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n-        self.pretty_path_generic_args(print_prefix, params, substs, ns, projections)\n+        self.pretty_path_generic_args(print_prefix, params, substs, projections)\n     }\n }\n \n@@ -1179,6 +1160,36 @@ impl<F: fmt::Write> PrettyPrinter for FmtPrinter<F> {\n         })\n     }\n \n+    fn print_value_path(\n+        mut self: PrintCx<'_, '_, 'tcx, Self>,\n+        def_id: DefId,\n+        substs: Option<SubstsRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        let was_in_value = std::mem::replace(&mut self.printer.in_value, true);\n+        let mut printer = self.print_def_path(def_id, substs, iter::empty())?;\n+        printer.in_value = was_in_value;\n+\n+        Ok(printer)\n+    }\n+\n+    fn generic_delimiters<'gcx, 'tcx>(\n+        mut self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, Self::Error>,\n+    ) -> Result<Self, Self::Error> {\n+        if !self.printer.empty && self.printer.in_value {\n+            write!(self.printer, \"::<\")?;\n+        } else {\n+            write!(self.printer, \"<\")?;\n+        }\n+\n+        let was_in_value = std::mem::replace(&mut self.printer.in_value, false);\n+        let mut printer = f(self)?;\n+        printer.in_value = was_in_value;\n+\n+        write!(printer, \">\")?;\n+        Ok(printer)\n+    }\n+\n     fn always_print_region_in_paths(\n         self: &PrintCx<'_, '_, '_, Self>,\n         region: ty::Region<'_>,"}, {"sha": "204a9574a64f0506aa92c066a52f3be3701a0f9b", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 19, "deletions": 80, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/5211e37b1dd6b7fc26d919941e958bce8f5815a0/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5211e37b1dd6b7fc26d919941e958bce8f5815a0/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5211e37b1dd6b7fc26d919941e958bce8f5815a0", "patch": "@@ -17,7 +17,7 @@ use crate::hir;\n macro_rules! gen_display_debug_body {\n     ( $with:path ) => {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            PrintCx::with_tls_tcx(FmtPrinter::new(f), |cx| {\n+            PrintCx::with_tls_tcx(FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n                 $with(&cx.tcx.lift(self).expect(\"could not lift for printing\"), cx)?;\n                 Ok(())\n             })\n@@ -262,9 +262,9 @@ pub fn parameterized<F: fmt::Write>(\n     substs: SubstsRef<'_>,\n     ns: Namespace,\n ) -> fmt::Result {\n-    PrintCx::with_tls_tcx(FmtPrinter::new(f), |cx| {\n+    PrintCx::with_tls_tcx(FmtPrinter::new(f, ns), |cx| {\n         let substs = cx.tcx.lift(&substs).expect(\"could not lift for printing\");\n-        cx.print_def_path(did, Some(substs), ns, iter::empty())?;\n+        cx.print_def_path(did, Some(substs), iter::empty())?;\n         Ok(())\n     })\n }\n@@ -284,12 +284,7 @@ define_print! {\n                     if let ty::Tuple(ref args) = principal.substs.type_at(0).sty {\n                         let mut projections = self.projection_bounds();\n                         if let (Some(proj), None) = (projections.next(), projections.next()) {\n-                            nest!(|cx| cx.print_def_path(\n-                                principal.def_id,\n-                                None,\n-                                Namespace::TypeNS,\n-                                iter::empty(),\n-                            ));\n+                            nest!(|cx| cx.print_def_path(principal.def_id, None, iter::empty()));\n                             nest!(|cx| cx.fn_sig(args, false, proj.ty));\n                             resugared_principal = true;\n                         }\n@@ -303,7 +298,6 @@ define_print! {\n                     nest!(|cx| cx.print_def_path(\n                         principal.def_id,\n                         Some(principal.substs),\n-                        Namespace::TypeNS,\n                         self.projection_bounds(),\n                     ));\n                 }\n@@ -332,12 +326,7 @@ define_print! {\n                 }\n                 first = false;\n \n-                nest!(|cx| cx.print_def_path(\n-                    def_id,\n-                    None,\n-                    Namespace::TypeNS,\n-                    iter::empty(),\n-                ));\n+                nest!(|cx| cx.print_def_path(def_id, None, iter::empty()));\n             }\n         }\n     }\n@@ -360,27 +349,17 @@ impl fmt::Debug for ty::GenericParamDef {\n \n impl fmt::Debug for ty::TraitDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        PrintCx::with_tls_tcx(FmtPrinter::new(f), |cx| {\n-            cx.print_def_path(\n-                self.def_id,\n-                None,\n-                Namespace::TypeNS,\n-                iter::empty(),\n-            )?;\n+        PrintCx::with_tls_tcx(FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n+            cx.print_def_path(self.def_id, None, iter::empty())?;\n             Ok(())\n         })\n     }\n }\n \n impl fmt::Debug for ty::AdtDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        PrintCx::with_tls_tcx(FmtPrinter::new(f), |cx| {\n-            cx.print_def_path(\n-                self.did,\n-                None,\n-                Namespace::TypeNS,\n-                iter::empty(),\n-            )?;\n+        PrintCx::with_tls_tcx(FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n+            cx.print_def_path(self.did, None, iter::empty())?;\n             Ok(())\n         })\n     }\n@@ -396,7 +375,7 @@ impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n \n impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        PrintCx::with_tls_tcx(FmtPrinter::new(f), |mut cx| {\n+        PrintCx::with_tls_tcx(FmtPrinter::new(f, Namespace::ValueNS), |mut cx| {\n             define_scoped_cx!(cx);\n             p!(write(\"UpvarId({:?};`{}`;{:?})\",\n                 self.var_path.hir_id,\n@@ -671,15 +650,10 @@ define_print_multi! {\n define_print! {\n     ('tcx) ty::TraitRef<'tcx>, (self, cx) {\n         display {\n-            nest!(|cx| cx.print_def_path(\n-                self.def_id,\n-                Some(self.substs),\n-                Namespace::TypeNS,\n-                iter::empty(),\n-            ));\n+            nest!(|cx| cx.print_def_path(self.def_id, Some(self.substs), iter::empty()));\n         }\n         debug {\n-            nest!(|cx| cx.path_qualified(self.self_ty(), Some(*self), Namespace::TypeNS));\n+            nest!(|cx| cx.path_qualified(self.self_ty(), Some(*self)));\n         }\n     }\n }\n@@ -730,12 +704,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             ty::FnDef(def_id, substs) => {\n                 let sig = self.tcx.fn_sig(def_id).subst(self.tcx, substs);\n                 p!(print(sig), write(\" {{\"));\n-                nest!(|cx| cx.print_def_path(\n-                    def_id,\n-                    Some(substs),\n-                    Namespace::ValueNS,\n-                    iter::empty(),\n-                ));\n+                nest!(|cx| cx.print_value_path(def_id, Some(substs)));\n                 p!(write(\"}}\"))\n             }\n             ty::FnPtr(ref bare_fn) => {\n@@ -758,12 +727,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                 }\n             }\n             ty::Adt(def, substs) => {\n-                nest!(|cx| cx.print_def_path(\n-                    def.did,\n-                    Some(substs),\n-                    Namespace::TypeNS,\n-                    iter::empty(),\n-                ));\n+                nest!(|cx| cx.print_def_path(def.did, Some(substs), iter::empty()));\n             }\n             ty::Dynamic(data, r) => {\n                 let print_r = self.print_region_outputs_anything(r);\n@@ -776,12 +740,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                 }\n             }\n             ty::Foreign(def_id) => {\n-                nest!(|cx| cx.print_def_path(\n-                    def_id,\n-                    None,\n-                    Namespace::TypeNS,\n-                    iter::empty(),\n-                ));\n+                nest!(|cx| cx.print_def_path(def_id, None, iter::empty()));\n             }\n             ty::Projection(ref data) => p!(print(data)),\n             ty::UnnormalizedProjection(ref data) => {\n@@ -1074,12 +1033,7 @@ define_print! {\n define_print! {\n     ('tcx) ty::ProjectionTy<'tcx>, (self, cx) {\n         display {\n-            nest!(|cx| cx.print_def_path(\n-                self.item_def_id,\n-                Some(self.substs),\n-                Namespace::TypeNS,\n-                iter::empty(),\n-            ));\n+            nest!(|cx| cx.print_def_path(self.item_def_id, Some(self.substs), iter::empty()));\n         }\n     }\n }\n@@ -1108,32 +1062,17 @@ define_print! {\n                 ty::Predicate::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n                 ty::Predicate::ObjectSafe(trait_def_id) => {\n                     p!(write(\"the trait `\"));\n-                    nest!(|cx| cx.print_def_path(\n-                        trait_def_id,\n-                        None,\n-                        Namespace::TypeNS,\n-                        iter::empty(),\n-                    ));\n+                    nest!(|cx| cx.print_def_path(trait_def_id, None, iter::empty()));\n                     p!(write(\"` is object-safe\"))\n                 }\n                 ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) => {\n                     p!(write(\"the closure `\"));\n-                    nest!(|cx| cx.print_def_path(\n-                        closure_def_id,\n-                        None,\n-                        Namespace::ValueNS,\n-                        iter::empty(),\n-                    ));\n+                    nest!(|cx| cx.print_value_path(closure_def_id, None));\n                     p!(write(\"` implements the trait `{}`\", kind))\n                 }\n                 ty::Predicate::ConstEvaluatable(def_id, substs) => {\n                     p!(write(\"the constant `\"));\n-                    nest!(|cx| cx.print_def_path(\n-                        def_id,\n-                        Some(substs),\n-                        Namespace::ValueNS,\n-                        iter::empty(),\n-                    ));\n+                    nest!(|cx| cx.print_value_path(def_id, Some(substs)));\n                     p!(write(\"` can be evaluated\"))\n                 }\n             }"}, {"sha": "3c8bd0dd01b47477185d85f3b126afaeeec230e8", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5211e37b1dd6b7fc26d919941e958bce8f5815a0/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5211e37b1dd6b7fc26d919941e958bce8f5815a0/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=5211e37b1dd6b7fc26d919941e958bce8f5815a0", "patch": "@@ -87,7 +87,6 @@\n //! virtually impossible. Thus, symbol hash generation exclusively relies on\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n-use rustc::hir::def::Namespace;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::Node;\n use rustc::hir::CodegenFnAttrFlags;\n@@ -226,7 +225,7 @@ fn get_symbol_hash<'a, 'tcx>(\n \n fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n     PrintCx::with(tcx, SymbolPath::new(tcx), |cx| {\n-        cx.print_def_path(def_id, None, Namespace::ValueNS, iter::empty())\n+        cx.print_def_path(def_id, None, iter::empty())\n             .unwrap()\n             .into_interned()\n     })\n@@ -437,9 +436,8 @@ impl Printer for SymbolPath {\n         self: PrintCx<'_, '_, 'tcx, Self>,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n-        ns: Namespace,\n     ) -> Result<Self::Path, Self::Error> {\n-        self.pretty_path_qualified(self_ty, trait_ref, ns)\n+        self.pretty_path_qualified(self_ty, trait_ref)\n     }\n \n     fn path_append_impl<'gcx, 'tcx>(\n@@ -482,10 +480,9 @@ impl Printer for SymbolPath {\n         ) -> Result<Self::Path, Self::Error>,\n         params: &[ty::GenericParamDef],\n         substs: SubstsRef<'tcx>,\n-        ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     )  -> Result<Self::Path, Self::Error> {\n-        self.pretty_path_generic_args(print_prefix, params, substs, ns, projections)\n+        self.pretty_path_generic_args(print_prefix, params, substs, projections)\n     }\n }\n "}, {"sha": "7a92a507ec160c0198cdf88e284d3f731dd49fbd", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5211e37b1dd6b7fc26d919941e958bce8f5815a0/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5211e37b1dd6b7fc26d919941e958bce8f5815a0/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=5211e37b1dd6b7fc26d919941e958bce8f5815a0", "patch": "@@ -3,6 +3,7 @@ use crate::borrow_check::nll::region_infer::{RegionName, RegionNameSource};\n use crate::borrow_check::prefixes::IsPrefixOf;\n use crate::borrow_check::WriteKind;\n use rustc::hir;\n+use rustc::hir::def::Namespace;\n use rustc::hir::def_id::DefId;\n use rustc::middle::region::ScopeTree;\n use rustc::mir::{\n@@ -2325,7 +2326,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// name where required.\n     fn get_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n         let mut s = String::new();\n-        let mut printer = ty::print::FmtPrinter::new(&mut s);\n+        let mut printer = ty::print::FmtPrinter::new(&mut s, Namespace::TypeNS);\n \n         // We need to add synthesized lifetimes where appropriate. We do\n         // this by hooking into the pretty printer and telling it to label the\n@@ -2350,7 +2351,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// synthesized lifetime name where required.\n     fn get_region_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n         let mut s = String::new();\n-        let mut printer = ty::print::FmtPrinter::new(&mut s);\n+        let mut printer = ty::print::FmtPrinter::new(&mut s, Namespace::TypeNS);\n \n         let region = match ty.sty {\n             ty::TyKind::Ref(region, _, _) => {"}, {"sha": "02b8291369d9d82c72eab61b4d47be5ed85fc0cf", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5211e37b1dd6b7fc26d919941e958bce8f5815a0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5211e37b1dd6b7fc26d919941e958bce8f5815a0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5211e37b1dd6b7fc26d919941e958bce8f5815a0", "patch": "@@ -18,7 +18,7 @@ use rustc::middle::lang_items;\n use rustc::middle::stability;\n use rustc::mir::interpret::GlobalId;\n use rustc::hir::{self, GenericArg, HirVec};\n-use rustc::hir::def::{self, Def, CtorKind, Namespace};\n+use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::ty::{self, DefIdTree, TyCtxt, Region, RegionVid, Ty, AdtKind};\n@@ -4260,7 +4260,6 @@ where F: Fn(DefId) -> Def {\n             self: PrintCx<'_, '_, 'tcx, Self>,\n             self_ty: Ty<'tcx>,\n             trait_ref: Option<ty::TraitRef<'tcx>>,\n-            _ns: Namespace,\n         ) -> Result<Self::Path, Self::Error> {\n             // This shouldn't ever be needed, but just in case:\n             Ok(vec![match trait_ref {\n@@ -4307,15 +4306,14 @@ where F: Fn(DefId) -> Def {\n             ) -> Result<Self::Path, Self::Error>,\n             _params: &[ty::GenericParamDef],\n             _substs: SubstsRef<'tcx>,\n-            _ns: Namespace,\n             _projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n         ) -> Result<Self::Path, Self::Error> {\n             print_prefix(self)\n         }\n     }\n \n     let names = PrintCx::with(tcx, AbsolutePathPrinter, |cx| {\n-        cx.print_def_path(def_id, None, Namespace::TypeNS, iter::empty()).unwrap()\n+        cx.print_def_path(def_id, None, iter::empty()).unwrap()\n     });\n \n     hir::Path {"}]}