{"sha": "32bf7af83e3d6f201ebea87006f9c33bbc211f7b", "node_id": "C_kwDOAAsO6NoAKDMyYmY3YWY4M2UzZDZmMjAxZWJlYTg3MDA2ZjljMzNiYmMyMTFmN2I", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-04T18:49:08Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-04T18:49:08Z"}, "message": "Support locals with multiple declaration sites", "tree": {"sha": "bb006fd34a8707261dfb57249387cb7ef129130b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb006fd34a8707261dfb57249387cb7ef129130b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32bf7af83e3d6f201ebea87006f9c33bbc211f7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32bf7af83e3d6f201ebea87006f9c33bbc211f7b", "html_url": "https://github.com/rust-lang/rust/commit/32bf7af83e3d6f201ebea87006f9c33bbc211f7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32bf7af83e3d6f201ebea87006f9c33bbc211f7b/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8329ba98731a939fe2c6eb878778a6399274ff0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8329ba98731a939fe2c6eb878778a6399274ff0", "html_url": "https://github.com/rust-lang/rust/commit/f8329ba98731a939fe2c6eb878778a6399274ff0"}], "stats": {"total": 427, "additions": 346, "deletions": 81}, "files": [{"sha": "60e3548d495db5de0ba605771cf5776740a5c288", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/32bf7af83e3d6f201ebea87006f9c33bbc211f7b/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32bf7af83e3d6f201ebea87006f9c33bbc211f7b/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=32bf7af83e3d6f201ebea87006f9c33bbc211f7b", "patch": "@@ -2036,6 +2036,11 @@ impl GenericDef {\n     }\n }\n \n+/// A single local definition.\n+///\n+/// If the definition of this is part of a \"MultiLocal\", that is a local that has multiple declarations due to or-patterns\n+/// then this only references a single one of those.\n+/// To retrieve the other locals you should use [`Local::associated_locals`]\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct Local {\n     pub(crate) parent: DefWithBodyId,\n@@ -2107,12 +2112,28 @@ impl Local {\n         Type::new(db, krate, def, ty)\n     }\n \n+    pub fn associated_locals(self, db: &dyn HirDatabase) -> Box<[Local]> {\n+        let body = db.body(self.parent);\n+        body.ident_patterns_for(&self.pat_id)\n+            .iter()\n+            .map(|&pat_id| Local { parent: self.parent, pat_id })\n+            .collect()\n+    }\n+\n+    /// If this local is part of a multi-local, retrieve the representative local.\n+    /// That is the local that references are being resolved to.\n+    pub fn representative(self, db: &dyn HirDatabase) -> Local {\n+        let body = db.body(self.parent);\n+        Local { pat_id: body.pattern_representative(self.pat_id), ..self }\n+    }\n+\n     pub fn source(self, db: &dyn HirDatabase) -> InFile<Either<ast::IdentPat, ast::SelfParam>> {\n         let (_body, source_map) = db.body_with_source_map(self.parent);\n         let src = source_map.pat_syntax(self.pat_id).unwrap(); // Hmm...\n         let root = src.file_syntax(db.upcast());\n-        src.map(|ast| {\n-            ast.map_left(|it| it.cast().unwrap().to_node(&root)).map_right(|it| it.to_node(&root))\n+        src.map(|ast| match ast {\n+            Either::Left(it) => Either::Left(it.cast().unwrap().to_node(&root)),\n+            Either::Right(it) => Either::Right(it.to_node(&root)),\n         })\n     }\n }"}, {"sha": "1f5e45eb2d7c22063edd0e0b0521f4a526bf146a", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/32bf7af83e3d6f201ebea87006f9c33bbc211f7b/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32bf7af83e3d6f201ebea87006f9c33bbc211f7b/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=32bf7af83e3d6f201ebea87006f9c33bbc211f7b", "patch": "@@ -237,10 +237,11 @@ pub struct Mark {\n }\n \n /// The body of an item (function, const etc.).\n-#[derive(Debug, Eq, PartialEq)]\n+#[derive(Debug, PartialEq, Eq)]\n pub struct Body {\n     pub exprs: Arena<Expr>,\n     pub pats: Arena<Pat>,\n+    pub or_pats: FxHashMap<PatId, Arc<[PatId]>>,\n     pub labels: Arena<Label>,\n     /// The patterns for the function's parameters. While the parameter types are\n     /// part of the function signature, the patterns are not (they don't change\n@@ -355,6 +356,18 @@ impl Body {\n             .map(move |block| (*block, db.block_def_map(*block).expect(\"block ID without DefMap\")))\n     }\n \n+    pub fn pattern_representative(&self, pat: PatId) -> PatId {\n+        self.or_pats.get(&pat).and_then(|pats| pats.first().copied()).unwrap_or(pat)\n+    }\n+\n+    /// Retrieves all ident patterns this pattern shares the ident with.\n+    pub fn ident_patterns_for<'slf>(&'slf self, pat: &'slf PatId) -> &'slf [PatId] {\n+        match self.or_pats.get(pat) {\n+            Some(pats) => &**pats,\n+            None => std::slice::from_ref(pat),\n+        }\n+    }\n+\n     fn new(\n         db: &dyn DefDatabase,\n         expander: Expander,\n@@ -365,8 +378,9 @@ impl Body {\n     }\n \n     fn shrink_to_fit(&mut self) {\n-        let Self { _c: _, body_expr: _, block_scopes, exprs, labels, params, pats } = self;\n+        let Self { _c: _, body_expr: _, block_scopes, or_pats, exprs, labels, params, pats } = self;\n         block_scopes.shrink_to_fit();\n+        or_pats.shrink_to_fit();\n         exprs.shrink_to_fit();\n         labels.shrink_to_fit();\n         params.shrink_to_fit();"}, {"sha": "873ae285ca28d5b33bbd9d2a46f8982b384efa8e", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 68, "deletions": 16, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/32bf7af83e3d6f201ebea87006f9c33bbc211f7b/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32bf7af83e3d6f201ebea87006f9c33bbc211f7b/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=32bf7af83e3d6f201ebea87006f9c33bbc211f7b", "patch": "@@ -12,6 +12,7 @@ use hir_expand::{\n };\n use la_arena::Arena;\n use profile::Count;\n+use rustc_hash::FxHashMap;\n use syntax::{\n     ast::{\n         self, ArrayExprKind, AstChildren, HasArgList, HasLoopBody, HasName, LiteralKind,\n@@ -92,6 +93,7 @@ pub(super) fn lower(\n             body_expr: dummy_expr_id(),\n             block_scopes: Vec::new(),\n             _c: Count::new(),\n+            or_pats: Default::default(),\n         },\n         expander,\n         statements_in_scope: Vec::new(),\n@@ -704,13 +706,40 @@ impl ExprCollector<'_> {\n     }\n \n     fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n+        let mut name_to_pat = FxHashMap::default();\n+        let pat_id = self.collect_pat_(&mut name_to_pat, false, pat);\n+        for pats in name_to_pat.into_values() {\n+            let pats = Arc::<[_]>::from(pats);\n+            for &pat in &*pats {\n+                self.body.or_pats.insert(pat, pats.clone());\n+            }\n+        }\n+        pat_id\n+    }\n+\n+    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n+        match pat {\n+            Some(pat) => self.collect_pat(pat),\n+            None => self.missing_pat(),\n+        }\n+    }\n+\n+    fn collect_pat_(\n+        &mut self,\n+        name_to_pat: &mut FxHashMap<Name, Vec<PatId>>,\n+        in_or_pat: bool,\n+        pat: ast::Pat,\n+    ) -> PatId {\n         let pattern = match &pat {\n             ast::Pat::IdentPat(bp) => {\n                 let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n+\n+                let key = in_or_pat.then(|| name.clone());\n                 let annotation =\n                     BindingAnnotation::new(bp.mut_token().is_some(), bp.ref_token().is_some());\n-                let subpat = bp.pat().map(|subpat| self.collect_pat(subpat));\n-                if annotation == BindingAnnotation::Unannotated && subpat.is_none() {\n+                let subpat =\n+                    bp.pat().map(|subpat| self.collect_pat_(name_to_pat, in_or_pat, subpat));\n+                let pattern = if annotation == BindingAnnotation::Unannotated && subpat.is_none() {\n                     // This could also be a single-segment path pattern. To\n                     // decide that, we need to try resolving the name.\n                     let (resolved, _) = self.expander.def_map.resolve_path(\n@@ -740,12 +769,19 @@ impl ExprCollector<'_> {\n                     }\n                 } else {\n                     Pat::Bind { name, mode: annotation, subpat }\n+                };\n+\n+                let ptr = AstPtr::new(&pat);\n+                let pat = self.alloc_pat(pattern, Either::Left(ptr));\n+                if let Some(key) = key {\n+                    name_to_pat.entry(key).or_default().push(pat);\n                 }\n+                return pat;\n             }\n             ast::Pat::TupleStructPat(p) => {\n                 let path =\n                     p.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n-                let (args, ellipsis) = self.collect_tuple_pat(p.fields());\n+                let (args, ellipsis) = self.collect_tuple_pat(name_to_pat, in_or_pat, p.fields());\n                 Pat::TupleStruct { path, args, ellipsis }\n             }\n             ast::Pat::RefPat(p) => {\n@@ -759,12 +795,12 @@ impl ExprCollector<'_> {\n                 path.map(Pat::Path).unwrap_or(Pat::Missing)\n             }\n             ast::Pat::OrPat(p) => {\n-                let pats = p.pats().map(|p| self.collect_pat(p)).collect();\n+                let pats = p.pats().map(|p| self.collect_pat_(name_to_pat, true, p)).collect();\n                 Pat::Or(pats)\n             }\n-            ast::Pat::ParenPat(p) => return self.collect_pat_opt(p.pat()),\n+            ast::Pat::ParenPat(p) => return self.collect_pat_opt_(name_to_pat, in_or_pat, p.pat()),\n             ast::Pat::TuplePat(p) => {\n-                let (args, ellipsis) = self.collect_tuple_pat(p.fields());\n+                let (args, ellipsis) = self.collect_tuple_pat(name_to_pat, in_or_pat, p.fields());\n                 Pat::Tuple { args, ellipsis }\n             }\n             ast::Pat::WildcardPat(_) => Pat::Wild,\n@@ -777,7 +813,7 @@ impl ExprCollector<'_> {\n                     .fields()\n                     .filter_map(|f| {\n                         let ast_pat = f.pat()?;\n-                        let pat = self.collect_pat(ast_pat);\n+                        let pat = self.collect_pat_(name_to_pat, in_or_pat, ast_pat);\n                         let name = f.field_name()?.as_name();\n                         Some(RecordFieldPat { name, pat })\n                     })\n@@ -796,9 +832,15 @@ impl ExprCollector<'_> {\n \n                 // FIXME properly handle `RestPat`\n                 Pat::Slice {\n-                    prefix: prefix.into_iter().map(|p| self.collect_pat(p)).collect(),\n-                    slice: slice.map(|p| self.collect_pat(p)),\n-                    suffix: suffix.into_iter().map(|p| self.collect_pat(p)).collect(),\n+                    prefix: prefix\n+                        .into_iter()\n+                        .map(|p| self.collect_pat_(name_to_pat, in_or_pat, p))\n+                        .collect(),\n+                    slice: slice.map(|p| self.collect_pat_(name_to_pat, in_or_pat, p)),\n+                    suffix: suffix\n+                        .into_iter()\n+                        .map(|p| self.collect_pat_(name_to_pat, in_or_pat, p))\n+                        .collect(),\n                 }\n             }\n             ast::Pat::LiteralPat(lit) => {\n@@ -821,7 +863,7 @@ impl ExprCollector<'_> {\n                 Pat::Missing\n             }\n             ast::Pat::BoxPat(boxpat) => {\n-                let inner = self.collect_pat_opt(boxpat.pat());\n+                let inner = self.collect_pat_opt_(name_to_pat, in_or_pat, boxpat.pat());\n                 Pat::Box { inner }\n             }\n             ast::Pat::ConstBlockPat(const_block_pat) => {\n@@ -837,7 +879,7 @@ impl ExprCollector<'_> {\n                     let macro_ptr = AstPtr::new(&call);\n                     let mut pat = None;\n                     self.collect_macro_call(call, macro_ptr, true, |this, expanded_pat| {\n-                        pat = Some(this.collect_pat_opt(expanded_pat));\n+                        pat = Some(this.collect_pat_opt_(name_to_pat, in_or_pat, expanded_pat));\n                     });\n \n                     match pat {\n@@ -854,21 +896,31 @@ impl ExprCollector<'_> {\n         self.alloc_pat(pattern, Either::Left(ptr))\n     }\n \n-    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n+    fn collect_pat_opt_(\n+        &mut self,\n+        name_to_pat: &mut FxHashMap<Name, Vec<PatId>>,\n+        in_or_pat: bool,\n+        pat: Option<ast::Pat>,\n+    ) -> PatId {\n         match pat {\n-            Some(pat) => self.collect_pat(pat),\n+            Some(pat) => self.collect_pat_(name_to_pat, in_or_pat, pat),\n             None => self.missing_pat(),\n         }\n     }\n \n-    fn collect_tuple_pat(&mut self, args: AstChildren<ast::Pat>) -> (Box<[PatId]>, Option<usize>) {\n+    fn collect_tuple_pat(\n+        &mut self,\n+        name_to_pat: &mut FxHashMap<Name, Vec<PatId>>,\n+        in_or_pat: bool,\n+        args: AstChildren<ast::Pat>,\n+    ) -> (Box<[PatId]>, Option<usize>) {\n         // Find the location of the `..`, if there is one. Note that we do not\n         // consider the possibility of there being multiple `..` here.\n         let ellipsis = args.clone().position(|p| matches!(p, ast::Pat::RestPat(_)));\n         // We want to skip the `..` pattern here, since we account for it above.\n         let args = args\n             .filter(|p| !matches!(p, ast::Pat::RestPat(_)))\n-            .map(|p| self.collect_pat(p))\n+            .map(|p| self.collect_pat_(name_to_pat, in_or_pat, p))\n             .collect();\n \n         (args, ellipsis)"}, {"sha": "3690fe11d0fcffa33512a622041fe19f3910aafe", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 143, "deletions": 58, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/32bf7af83e3d6f201ebea87006f9c33bbc211f7b/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32bf7af83e3d6f201ebea87006f9c33bbc211f7b/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=32bf7af83e3d6f201ebea87006f9c33bbc211f7b", "patch": "@@ -98,24 +98,37 @@ fn highlight_references(\n             range,\n             category: access,\n         });\n+    let mut res = FxHashSet::default();\n \n-    let declarations = defs.iter().flat_map(|def| {\n-        match def {\n-            &Definition::Module(module) => {\n+    let mut def_to_hl_range = |def| {\n+        let hl_range = match def {\n+            Definition::Module(module) => {\n                 Some(NavigationTarget::from_module_to_decl(sema.db, module))\n             }\n             def => def.try_to_nav(sema.db),\n         }\n         .filter(|decl| decl.file_id == file_id)\n-        .and_then(|decl| {\n-            let range = decl.focus_range?;\n+        .and_then(|decl| decl.focus_range)\n+        .map(|range| {\n             let category =\n                 references::decl_mutability(&def, node, range).then(|| ReferenceCategory::Write);\n-            Some(HighlightedRange { range, category })\n-        })\n-    });\n+            HighlightedRange { range, category }\n+        });\n+        if let Some(hl_range) = hl_range {\n+            res.insert(hl_range);\n+        }\n+    };\n+    for &def in &defs {\n+        match def {\n+            Definition::Local(local) => local\n+                .associated_locals(sema.db)\n+                .iter()\n+                .for_each(|&local| def_to_hl_range(Definition::Local(local))),\n+            def => def_to_hl_range(def),\n+        }\n+    }\n \n-    let res: FxHashSet<_> = declarations.chain(usages).collect();\n+    res.extend(usages);\n     if res.is_empty() {\n         None\n     } else {\n@@ -332,6 +345,7 @@ mod tests {\n \n     use super::*;\n \n+    #[track_caller]\n     fn check(ra_fixture: &str) {\n         let config = HighlightRelatedConfig {\n             break_points: true,\n@@ -343,6 +357,7 @@ mod tests {\n         check_with_config(ra_fixture, config);\n     }\n \n+    #[track_caller]\n     fn check_with_config(ra_fixture: &str, config: HighlightRelatedConfig) {\n         let (analysis, pos, annotations) = fixture::annotations(ra_fixture);\n \n@@ -1053,13 +1068,15 @@ fn function(field: u32) {\n             yield_points: true,\n         };\n \n-        let ra_fixture = r#\"\n+        check_with_config(\n+            r#\"\n fn foo() {\n-    let x$0 = 5;\n+    let x = 5;\n     let y = x * 2;\n-}\"#;\n-\n-        check_with_config(ra_fixture, config);\n+}\n+\"#,\n+            config,\n+        );\n     }\n \n     #[test]\n@@ -1071,31 +1088,35 @@ fn foo() {\n             yield_points: true,\n         };\n \n-        let ra_fixture = r#\"\n+        check_with_config(\n+            r#\"\n fn foo() {\n-    let x$0 = 5;\n+    let x = 5;\n     let y = x * 2;\n \n     loop {\n         break;\n     }\n-}\"#;\n-\n-        check_with_config(ra_fixture, config.clone());\n+}\n+\"#,\n+            config.clone(),\n+        );\n \n-        let ra_fixture = r#\"\n+        check_with_config(\n+            r#\"\n fn foo() {\n     let x = 5;\n     let y = x * 2;\n \n-    loop$0 {\n+    loop {\n //  ^^^^\n         break;\n //      ^^^^^\n     }\n-}\"#;\n-\n-        check_with_config(ra_fixture, config);\n+}\n+\"#,\n+            config,\n+        );\n     }\n \n     #[test]\n@@ -1107,27 +1128,31 @@ fn foo() {\n             yield_points: true,\n         };\n \n-        let ra_fixture = r#\"\n+        check_with_config(\n+            r#\"\n async fn foo() {\n-    let x$0 = 5;\n+    let x = 5;\n     let y = x * 2;\n \n     0.await;\n-}\"#;\n-\n-        check_with_config(ra_fixture, config.clone());\n+}\n+\"#,\n+            config.clone(),\n+        );\n \n-        let ra_fixture = r#\"\n+        check_with_config(\n+            r#\"\n     async fn foo() {\n //  ^^^^^\n         let x = 5;\n         let y = x * 2;\n \n-        0.await$0;\n+        0.await;\n //        ^^^^^\n-}\"#;\n-\n-        check_with_config(ra_fixture, config);\n+}\n+\"#,\n+            config,\n+        );\n     }\n \n     #[test]\n@@ -1139,22 +1164,25 @@ async fn foo() {\n             yield_points: true,\n         };\n \n-        let ra_fixture = r#\"\n+        check_with_config(\n+            r#\"\n fn foo() -> i32 {\n-    let x$0 = 5;\n+    let x = 5;\n     let y = x * 2;\n \n     if true {\n         return y;\n     }\n \n     0?\n-}\"#;\n-\n-        check_with_config(ra_fixture, config.clone());\n+}\n+\"#,\n+            config.clone(),\n+        );\n \n-        let ra_fixture = r#\"\n-fn foo() ->$0 i32 {\n+        check_with_config(\n+            r#\"\n+fn foo() -> i32 {\n     let x = 5;\n     let y = x * 2;\n \n@@ -1165,9 +1193,9 @@ fn foo() ->$0 i32 {\n \n     0?\n //   ^\n-\"#;\n-\n-        check_with_config(ra_fixture, config);\n+\"#,\n+            config,\n+        );\n     }\n \n     #[test]\n@@ -1179,14 +1207,16 @@ fn foo() ->$0 i32 {\n             yield_points: true,\n         };\n \n-        let ra_fixture = r#\"\n+        check_with_config(\n+            r#\"\n fn foo() {\n     loop {\n-        break$0;\n+        break;\n     }\n-}\"#;\n-\n-        check_with_config(ra_fixture, config);\n+}\n+\"#,\n+            config,\n+        );\n     }\n \n     #[test]\n@@ -1198,12 +1228,14 @@ fn foo() {\n             yield_points: false,\n         };\n \n-        let ra_fixture = r#\"\n-async$0 fn foo() {\n+        check_with_config(\n+            r#\"\n+async fn foo() {\n     0.await;\n-}\"#;\n-\n-        check_with_config(ra_fixture, config);\n+}\n+\"#,\n+            config,\n+        );\n     }\n \n     #[test]\n@@ -1215,15 +1247,68 @@ async$0 fn foo() {\n             yield_points: true,\n         };\n \n-        let ra_fixture = r#\"\n-fn foo() ->$0 i32 {\n+        check_with_config(\n+            r#\"\n+fn foo() -> i32 {\n     if true {\n         return -1;\n     }\n \n     42\n-}\"#;\n+}\"#,\n+            config,\n+        );\n+    }\n \n-        check_with_config(ra_fixture, config);\n+    #[test]\n+    fn test_hl_multi_local() {\n+        check(\n+            r#\"\n+fn foo((\n+    foo$0\n+  //^^^\n+    | foo\n+    //^^^\n+    | foo\n+    //^^^\n+): ()) {\n+    foo;\n+  //^^^read\n+    let foo;\n+}\n+\"#,\n+        );\n+        check(\n+            r#\"\n+fn foo((\n+    foo\n+  //^^^\n+    | foo$0\n+    //^^^\n+    | foo\n+    //^^^\n+): ()) {\n+    foo;\n+  //^^^read\n+    let foo;\n+}\n+\"#,\n+        );\n+        check(\n+            r#\"\n+fn foo((\n+    foo\n+  //^^^\n+    | foo\n+    //^^^\n+    | foo\n+    //^^^\n+): ()) {\n+    foo$0;\n+  //^^^read\n+    let foo;\n+}\n+\"#,\n+        );\n     }\n }"}, {"sha": "83bc299adcce7a0b79bfad99eb9f8e9b61117837", "filename": "crates/ide/src/rename.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/32bf7af83e3d6f201ebea87006f9c33bbc211f7b/crates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32bf7af83e3d6f201ebea87006f9c33bbc211f7b/crates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frename.rs?ref=32bf7af83e3d6f201ebea87006f9c33bbc211f7b", "patch": "@@ -2084,4 +2084,53 @@ fn foo() {\n \"#,\n         )\n     }\n+\n+    #[test]\n+    fn rename_multi_local() {\n+        check(\n+            \"bar\",\n+            r#\"\n+fn foo((foo$0 | foo | foo): ()) {\n+    foo;\n+    let foo;\n+}\n+\"#,\n+            r#\"\n+fn foo((bar | bar | bar): ()) {\n+    bar;\n+    let foo;\n+}\n+\"#,\n+        );\n+        check(\n+            \"bar\",\n+            r#\"\n+fn foo((foo | foo$0 | foo): ()) {\n+    foo;\n+    let foo;\n+}\n+\"#,\n+            r#\"\n+fn foo((bar | bar | bar): ()) {\n+    bar;\n+    let foo;\n+}\n+\"#,\n+        );\n+        check(\n+            \"bar\",\n+            r#\"\n+fn foo((foo | foo | foo): ()) {\n+    foo$0;\n+    let foo;\n+}\n+\"#,\n+            r#\"\n+fn foo((bar | bar | bar): ()) {\n+    bar;\n+    let foo;\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "0b4f46caf41f484ea42faf748f474dbc1b4656e4", "filename": "crates/ide_assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32bf7af83e3d6f201ebea87006f9c33bbc211f7b/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32bf7af83e3d6f201ebea87006f9c33bbc211f7b/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=32bf7af83e3d6f201ebea87006f9c33bbc211f7b", "patch": "@@ -206,6 +206,7 @@ fn inline_usage(\n         return None;\n     }\n \n+    // FIXME: Handle multiple local definitions\n     let bind_pat = match local.source(sema.db).value {\n         Either::Left(ident) => ident,\n         _ => return None,"}, {"sha": "a44fe04e748ee359644a97ce38f943df23299ae9", "filename": "crates/ide_db/src/rename.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/32bf7af83e3d6f201ebea87006f9c33bbc211f7b/crates%2Fide_db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32bf7af83e3d6f201ebea87006f9c33bbc211f7b/crates%2Fide_db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Frename.rs?ref=32bf7af83e3d6f201ebea87006f9c33bbc211f7b", "patch": "@@ -293,8 +293,18 @@ fn rename_reference(\n         (file_id, source_edit_from_references(references, def, new_name))\n     }));\n \n-    let (file_id, edit) = source_edit_from_def(sema, def, new_name)?;\n-    source_change.insert_source_edit(file_id, edit);\n+    let mut insert_def_edit = |def| {\n+        let (file_id, edit) = source_edit_from_def(sema, def, new_name)?;\n+        source_change.insert_source_edit(file_id, edit);\n+        Ok(())\n+    };\n+    match def {\n+        Definition::Local(l) => l\n+            .associated_locals(sema.db)\n+            .iter()\n+            .try_for_each(|&local| insert_def_edit(Definition::Local(local))),\n+        def => insert_def_edit(def),\n+    }?;\n     Ok(source_change)\n }\n "}, {"sha": "3ff48520f497bdc397d55920bfc7b2e06482be5f", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/32bf7af83e3d6f201ebea87006f9c33bbc211f7b/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32bf7af83e3d6f201ebea87006f9c33bbc211f7b/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=32bf7af83e3d6f201ebea87006f9c33bbc211f7b", "patch": "@@ -310,6 +310,10 @@ impl Definition {\n \n     pub fn usages<'a>(self, sema: &'a Semantics<RootDatabase>) -> FindUsages<'a> {\n         FindUsages {\n+            local_repr: match self {\n+                Definition::Local(local) => Some(local.representative(sema.db)),\n+                _ => None,\n+            },\n             def: self,\n             sema,\n             scope: None,\n@@ -325,6 +329,7 @@ pub struct FindUsages<'a> {\n     sema: &'a Semantics<'a, RootDatabase>,\n     scope: Option<SearchScope>,\n     include_self_kw_refs: Option<hir::Type>,\n+    local_repr: Option<hir::Local>,\n     search_self_mod: bool,\n }\n \n@@ -593,6 +598,19 @@ impl<'a> FindUsages<'a> {\n         sink: &mut dyn FnMut(FileId, FileReference) -> bool,\n     ) -> bool {\n         match NameRefClass::classify(self.sema, name_ref) {\n+            Some(NameRefClass::Definition(def @ Definition::Local(local)))\n+                if matches!(\n+                    self.local_repr, Some(repr) if repr == local.representative(self.sema.db)\n+                ) =>\n+            {\n+                let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n+                let reference = FileReference {\n+                    range,\n+                    name: ast::NameLike::NameRef(name_ref.clone()),\n+                    category: ReferenceCategory::new(&def, name_ref),\n+                };\n+                sink(file_id, reference)\n+            }\n             Some(NameRefClass::Definition(def)) if def == self.def => {\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n                 let reference = FileReference {\n@@ -622,7 +640,7 @@ impl<'a> FindUsages<'a> {\n                     Definition::Field(_) if field == self.def => {\n                         ReferenceCategory::new(&field, name_ref)\n                     }\n-                    Definition::Local(l) if local == l => {\n+                    Definition::Local(_) if matches!(self.local_repr, Some(repr) if repr == local.representative(self.sema.db)) => {\n                         ReferenceCategory::new(&Definition::Local(local), name_ref)\n                     }\n                     _ => return false,\n@@ -667,6 +685,21 @@ impl<'a> FindUsages<'a> {\n                 };\n                 sink(file_id, reference)\n             }\n+            Some(NameClass::Definition(def @ Definition::Local(local))) if def != self.def => {\n+                if matches!(\n+                    self.local_repr,\n+                    Some(repr) if local.representative(self.sema.db) == repr\n+                ) {\n+                    let FileRange { file_id, range } = self.sema.original_range(name.syntax());\n+                    let reference = FileReference {\n+                        range,\n+                        name: ast::NameLike::Name(name.clone()),\n+                        category: None,\n+                    };\n+                    return sink(file_id, reference);\n+                }\n+                false\n+            }\n             // Resolve trait impl function definitions to the trait definition's version if self.def is the trait definition's\n             Some(NameClass::Definition(def)) if def != self.def => {\n                 /* poor man's try block */"}]}