{"sha": "773a640303db0995868f8739857b0df16afa1969", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3M2E2NDAzMDNkYjA5OTU4NjhmODczOTg1N2IwZGYxNmFmYTE5Njk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-20T03:36:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-20T03:46:48Z"}, "message": "support autoderef on method calls", "tree": {"sha": "b6cef607db972ad2e450cd400ea9be4bb473b94a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6cef607db972ad2e450cd400ea9be4bb473b94a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/773a640303db0995868f8739857b0df16afa1969", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/773a640303db0995868f8739857b0df16afa1969", "html_url": "https://github.com/rust-lang/rust/commit/773a640303db0995868f8739857b0df16afa1969", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/773a640303db0995868f8739857b0df16afa1969/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "514e8ded2fc4666365d99d959626130bab6e6b6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/514e8ded2fc4666365d99d959626130bab6e6b6e", "html_url": "https://github.com/rust-lang/rust/commit/514e8ded2fc4666365d99d959626130bab6e6b6e"}], "stats": {"total": 411, "additions": 241, "deletions": 170}, "files": [{"sha": "87d51b33420aa44e72b38f6f2f70fc6a062d72bc", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/773a640303db0995868f8739857b0df16afa1969/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773a640303db0995868f8739857b0df16afa1969/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=773a640303db0995868f8739857b0df16afa1969", "patch": "@@ -68,7 +68,6 @@ type parameter).\n \n import astconv::{ast_conv, ast_ty_to_ty};\n import collect::{methods}; // ccx.to_ty()\n-import method::{methods};  // methods for method::lookup\n import middle::ty::{tv_vid, vid};\n import regionmanip::{replace_bound_regions_in_fn_ty, region_of};\n import rscope::{anon_rscope, binding_rscope, empty_rscope, in_anon_rscope};\n@@ -905,15 +904,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                         opname: str, args: [option<@ast::expr>])\n         -> option<(ty::t, bool)> {\n         let callee_id = ast_util::op_expr_callee_id(op_ex);\n-        let lkup = method::lookup({fcx: fcx,\n-                                   expr: op_ex,\n-                                   self_expr: self_ex,\n-                                   borrow_scope: op_ex.id,\n-                                   node_id: callee_id,\n-                                   m_name: @opname,\n-                                   self_ty: self_t,\n-                                   supplied_tps: [],\n-                                   include_private: false});\n+        let lkup = method::lookup(fcx, op_ex, self_ex, op_ex.id,\n+                                  callee_id, @opname, self_t, [], false);\n         alt lkup.method() {\n           some(origin) {\n             let {fty: method_ty, bot: bot} = {\n@@ -1629,15 +1621,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             // encloses the method call\n             let borrow_scope = fcx.tcx().region_map.get(expr.id);\n \n-            let lkup = method::lookup({fcx: fcx,\n-                                       expr: expr,\n-                                       self_expr: base,\n-                                       borrow_scope: borrow_scope,\n-                                       node_id: expr.id,\n-                                       m_name: field,\n-                                       self_ty: expr_t,\n-                                       supplied_tps: tps,\n-                                       include_private: is_self_ref});\n+            let lkup = method::lookup(fcx, expr, base, borrow_scope,\n+                                      expr.id, field, expr_t, tps,\n+                                      is_self_ref);\n             alt lkup.method() {\n               some(entry) {\n                 fcx.ccx.method_map.insert(id, entry);\n@@ -1686,15 +1672,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         let p_ty = fcx.expr_ty(p);\n \n-        let lkup = method::lookup({fcx: fcx,\n-                                   expr: p,\n-                                   self_expr: p,\n-                                   borrow_scope: expr.id,\n-                                   node_id: alloc_id,\n-                                   m_name: @\"alloc\",\n-                                   self_ty: p_ty,\n-                                   supplied_tps: [],\n-                                   include_private: false});\n+        let lkup = method::lookup(fcx, p, p, expr.id, alloc_id,\n+                                  @\"alloc\", p_ty, [], false);\n         alt lkup.method() {\n           some(entry) {\n             fcx.ccx.method_map.insert(alloc_id, entry);"}, {"sha": "4af075e8b7944114d9e7ef2dfd6bf677290dd585", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 204, "deletions": 142, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/773a640303db0995868f8739857b0df16afa1969/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773a640303db0995868f8739857b0df16afa1969/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=773a640303db0995868f8739857b0df16afa1969", "patch": "@@ -2,56 +2,162 @@\n \n import syntax::ast_map;\n import middle::typeck::infer::methods; // next_ty_vars\n-\n-enum lookup = {\n-    fcx: @fn_ctxt,\n-    expr: @ast::expr, // expr for a.b in a.b()\n-    self_expr: @ast::expr, // a in a.b(...)\n-    borrow_scope: ast::node_id, // if we have to borrow the expr, what scope?\n-    node_id: ast::node_id, // node id of call (not always expr.id)\n-    m_name: ast::ident, // b in a.b(...)\n-    self_ty: ty::t, // type of a in a.b(...)\n-    supplied_tps: [ty::t], // Xs in a.b::<Xs>(...)\n-    include_private: bool\n+import dvec::{dvec, extensions};\n+\n+type candidate = {\n+    self_ty: ty::t,          // type of a in a.b()\n+    self_substs: ty::substs, // values for any tvars def'd on the class\n+    rcvr_ty: ty::t,          // type of receiver in the method def\n+    n_tps_m: uint,           // number of tvars defined on the method\n+    fty: ty::t,              // type of the method\n+    entry: method_map_entry\n };\n \n-impl methods for lookup {\n+class lookup {\n+    let fcx: @fn_ctxt;\n+    let expr: @ast::expr;\n+    let self_expr: @ast::expr;\n+    let borrow_scope: ast::node_id;\n+    let node_id: ast::node_id;\n+    let m_name: ast::ident;\n+    let mut self_ty: ty::t;\n+    let mut derefs: uint;\n+    let candidates: dvec<candidate>;\n+    let supplied_tps: [ty::t];\n+    let include_private: bool;\n+\n+    new(fcx: @fn_ctxt,\n+        expr: @ast::expr,           //expr for a.b in a.b()\n+        self_expr: @ast::expr,      //a in a.b(...)\n+        borrow_scope: ast::node_id, //scope to borrow the expr for\n+        node_id: ast::node_id,      //node id where to store type of fn\n+        m_name: ast::ident,         //b in a.b(...)\n+        self_ty: ty::t,             //type of a in a.b(...)\n+        supplied_tps: [ty::t],      //Xs in a.b::<Xs>(...)\n+        include_private: bool) {\n+\n+        self.fcx = fcx;\n+        self.expr = expr;\n+        self.self_expr = self_expr;\n+        self.borrow_scope = borrow_scope;\n+        self.node_id = node_id;\n+        self.m_name = m_name;\n+        self.self_ty = self_ty;\n+        self.derefs = 0u;\n+        self.candidates = dvec();\n+        self.supplied_tps = supplied_tps;\n+        self.include_private = include_private;\n+    }\n+\n     // Entrypoint:\n     fn method() -> option<method_map_entry> {\n         #debug[\"method lookup(m_name=%s, self_ty=%s)\",\n                *self.m_name, self.fcx.infcx.ty_to_str(self.self_ty)];\n \n-        // First, see whether this is an interface-bounded parameter\n-        let pass1 = alt ty::get(self.self_ty).struct {\n-          ty::ty_param(n, did) {\n-            self.method_from_param(n, did)\n-          }\n-          ty::ty_iface(did, substs) {\n-            self.method_from_iface(did, substs)\n-          }\n-          ty::ty_class(did, substs) {\n-            self.method_from_class(did, substs)\n-          }\n-          _ {\n-            none\n-          }\n-        };\n+        loop {\n+            // First, see whether this is an interface-bounded parameter\n+            alt ty::get(self.self_ty).struct {\n+              ty::ty_param(n, did) {\n+                self.add_candidates_from_param(n, did);\n+              }\n+              ty::ty_iface(did, substs) {\n+                self.add_candidates_from_iface(did, substs);\n+              }\n+              ty::ty_class(did, substs) {\n+                self.add_candidates_from_class(did, substs);\n+              }\n+              _ { }\n+            }\n+\n+            // if we found anything, stop now.  otherwise continue to\n+            // loop for impls in scope.  Note: I don't love these\n+            // semantics, but that's what we had so I am preserving\n+            // it.\n+            if self.candidates.len() > 0u {\n+                break;\n+            }\n+\n+            self.add_candidates_from_scope();\n+\n+            // if we found anything, stop before attempting auto-deref.\n+            if self.candidates.len() > 0u {\n+                break;\n+            }\n \n-        alt pass1 {\n-          some(r) { some(r) }\n-          none { self.method_from_scope() }\n+            // check whether we can autoderef and if so loop around again.\n+            alt ty::deref(self.tcx(), self.self_ty, false) {\n+              none { break; }\n+              some(mt) {\n+                self.self_ty = mt.ty;\n+                self.derefs += 1u;\n+              }\n+            }\n         }\n+\n+        if self.candidates.len() == 0u { ret none; }\n+\n+        if self.candidates.len() > 1u {\n+            self.tcx().sess.span_err(\n+                self.expr.span,\n+                \"multiple applicable methods in scope\");\n+\n+            for self.candidates.eachi { |i, candidate|\n+                alt candidate.entry.origin {\n+                  method_static(did) {\n+                    self.report_static_candidate(i, did);\n+                  }\n+                  method_param(p) {\n+                    self.report_param_candidate(i, p.iface_id);\n+                  }\n+                  method_iface(did, _) {\n+                    self.report_iface_candidate(i, did);\n+                  }\n+                }\n+            }\n+        }\n+\n+        some(self.write_mty_from_candidate(self.candidates[0u]))\n     }\n \n     fn tcx() -> ty::ctxt { self.fcx.ccx.tcx }\n \n-    fn method_from_param(n: uint, did: ast::def_id)\n-        -> option<method_map_entry> {\n+    fn report_static_candidate(idx: uint, did: ast::def_id) {\n+        let span = if did.crate == ast::local_crate {\n+            alt check self.tcx().items.get(did.node) {\n+              ast_map::node_method(m, _, _) { m.span }\n+            }\n+        } else {\n+            self.expr.span\n+        };\n+        self.tcx().sess.span_note(\n+            span,\n+            #fmt[\"candidate #%u is `%s`\",\n+                 (idx+1u),\n+                 ty::item_path_str(self.tcx(), did)]);\n+    }\n+\n+    fn report_param_candidate(idx: uint, did: ast::def_id) {\n+        self.tcx().sess.span_note(\n+            self.expr.span,\n+            #fmt[\"candidate #%u derives from the bound `%s`\",\n+                 (idx+1u),\n+                 ty::item_path_str(self.tcx(), did)]);\n+    }\n+\n+    fn report_iface_candidate(idx: uint, did: ast::def_id) {\n+        self.tcx().sess.span_note(\n+            self.expr.span,\n+            #fmt[\"candidate #%u derives from the type of the receiver, \\\n+                  which is the iface `%s`\",\n+                 (idx+1u),\n+                 ty::item_path_str(self.tcx(), did)]);\n+    }\n+\n+    fn add_candidates_from_param(n: uint, did: ast::def_id) {\n \n         let tcx = self.tcx();\n         let mut iface_bnd_idx = 0u; // count only iface bounds\n         let bounds = tcx.ty_param_bounds.get(did.node);\n-        let mut candidates = [];\n         for vec::each(*bounds) {|bound|\n             let (iid, bound_substs) = alt bound {\n               ty::bound_copy | ty::bound_send | ty::bound_const {\n@@ -81,41 +187,20 @@ impl methods for lookup {\n                 // permitted).\n                 let substs = {self_ty: some(self.self_ty)\n                               with bound_substs};\n-                candidates += [(substs, ifce_methods[pos],\n-                                iid, pos, n, iface_bnd_idx)];\n-              }\n-            }\n-        }\n-\n-        if candidates.len() == 0u {\n-            ret none;\n-        }\n-\n-        if candidates.len() > 1u {\n-            self.tcx().sess.span_err(\n-                self.expr.span,\n-                \"multiple applicable methods in scope\");\n \n-            for candidates.eachi { |i, candidate|\n-                let (_, _, iid, _, _, _) = candidate;\n-                self.tcx().sess.span_note(\n-                    self.expr.span,\n-                    #fmt[\"candidate #%u derives from the bound `%s`\",\n-                         (i+1u), ty::item_path_str(self.tcx(), iid)]);\n+                self.add_candidates_from_m(\n+                    substs, ifce_methods[pos],\n+                    method_param({iface_id:iid,\n+                                  method_num:pos,\n+                                  param_num:n,\n+                                  bound_num:iface_bnd_idx}));\n+              }\n             }\n         }\n \n-        let (substs, mty, iid, pos, n, iface_bnd_idx) = candidates[0u];\n-        ret some(self.write_mty_from_m(\n-            substs, mty, method_param({iface_id:iid,\n-                                       method_num:pos,\n-                                       param_num:n,\n-                                       bound_num:iface_bnd_idx})));\n     }\n \n-    fn method_from_iface(\n-        did: ast::def_id, iface_substs: ty::substs)\n-        -> option<method_map_entry> {\n+    fn add_candidates_from_iface(did: ast::def_id, iface_substs: ty::substs) {\n \n         let ms = *ty::iface_methods(self.tcx(), did);\n         for ms.eachi {|i, m|\n@@ -143,15 +228,12 @@ impl methods for lookup {\n             let substs = {self_ty: some(self.self_ty)\n                           with iface_substs};\n \n-            ret some(self.write_mty_from_m(\n-                substs, m, method_iface(did, i)));\n+            self.add_candidates_from_m(\n+                substs, m, method_iface(did, i));\n         }\n-\n-        ret none;\n     }\n \n-    fn method_from_class(did: ast::def_id, class_substs: ty::substs)\n-        -> option<method_map_entry> {\n+    fn add_candidates_from_class(did: ast::def_id, class_substs: ty::substs) {\n \n         let ms = *ty::iface_methods(self.tcx(), did);\n \n@@ -169,12 +251,9 @@ impl methods for lookup {\n             let m_declared = ty::lookup_class_method_by_name(\n                 self.tcx(), did, self.m_name, self.expr.span);\n \n-            ret some(self.write_mty_from_m(\n-                class_substs, m,\n-                method_static(m_declared)));\n+            self.add_candidates_from_m(\n+                class_substs, m, method_static(m_declared));\n         }\n-\n-        ret none;\n     }\n \n     fn ty_from_did(did: ast::def_id) -> ty::t {\n@@ -202,11 +281,11 @@ impl methods for lookup {\n         */\n     }\n \n-    fn method_from_scope() -> option<method_map_entry> {\n+    fn add_candidates_from_scope() {\n         let impls_vecs = self.fcx.ccx.impl_map.get(self.expr.id);\n+        let mut added_any = false;\n \n         for list::each(impls_vecs) {|impls|\n-            let mut results = [];\n             for vec::each(*impls) {|im|\n                 // Check whether this impl has a method with the right name.\n                 for im.methods.find({|m| m.ident == self.m_name}).each {|m|\n@@ -223,89 +302,72 @@ impl methods for lookup {\n                         self.self_ty, impl_ty) {\n                       result::err(_) { /* keep looking */ }\n                       result::ok(_) {\n-                        results += [(impl_ty, impl_substs, m.n_tps, m.did)];\n+                        let fty = self.ty_from_did(m.did);\n+                        self.candidates.push(\n+                            {self_ty: self.self_ty,\n+                             self_substs: impl_substs,\n+                             rcvr_ty: impl_ty,\n+                             n_tps_m: m.n_tps,\n+                             fty: fty,\n+                             entry: {derefs: self.derefs,\n+                                     origin: method_static(m.did)}});\n+                        added_any = true;\n                       }\n                     }\n                 }\n             }\n \n-            if results.len() >= 1u {\n-                if results.len() > 1u {\n-                    self.tcx().sess.span_err(\n-                        self.expr.span,\n-                        \"multiple applicable methods in scope\");\n-\n-                    // I would like to print out how each impl was imported,\n-                    // but I cannot for the life of me figure out how to\n-                    // annotate resolve to preserve this information.\n-                    for results.eachi { |i, result|\n-                        let (_, _, _, did) = result;\n-                        let span = if did.crate == ast::local_crate {\n-                            alt check self.tcx().items.get(did.node) {\n-                              ast_map::node_method(m, _, _) { m.span }\n-                            }\n-                        } else {\n-                            self.expr.span\n-                        };\n-                        self.tcx().sess.span_note(\n-                            span,\n-                            #fmt[\"candidate #%u is `%s`\",\n-                                 (i+1u),\n-                                 ty::item_path_str(self.tcx(), did)]);\n-                    }\n-                }\n-\n-                let (impl_ty, impl_substs, n_tps, did) = results[0];\n-                alt self.fcx.mk_assignty(self.self_expr, self.borrow_scope,\n-                                         self.self_ty, impl_ty) {\n-                  result::ok(_) {}\n-                  result::err(_) {\n-                    self.tcx().sess.span_bug(\n-                        self.expr.span,\n-                        #fmt[\"%s was assignable to %s but now is not?\",\n-                             self.fcx.infcx.ty_to_str(self.self_ty),\n-                             self.fcx.infcx.ty_to_str(impl_ty)]);\n-                  }\n-                }\n-                let fty = self.ty_from_did(did);\n-                ret some(self.write_mty_from_fty(\n-                    impl_substs, n_tps, fty,\n-                    method_static(did)));\n-            }\n+            // we want to find the innermost scope that has any\n+            // matches and then ignore outer scopes\n+            if added_any {ret;}\n         }\n-\n-        ret none;\n     }\n \n-    fn write_mty_from_m(self_substs: ty::substs,\n-                        m: ty::method,\n-                        origin: method_origin) -> method_map_entry {\n+    fn add_candidates_from_m(self_substs: ty::substs,\n+                             m: ty::method,\n+                             origin: method_origin) {\n         let tcx = self.fcx.ccx.tcx;\n \n         // a bit hokey, but the method unbound has a bare protocol, whereas\n         // a.b has a protocol like fn@() (perhaps eventually fn&()):\n         let fty = ty::mk_fn(tcx, {proto: ast::proto_box with m.fty});\n \n-        ret self.write_mty_from_fty(self_substs, (*m.tps).len(),\n-                                    fty, origin);\n+        self.candidates.push(\n+            {self_ty: self.self_ty,\n+             self_substs: self_substs,\n+             rcvr_ty: self.self_ty,\n+             n_tps_m: (*m.tps).len(),\n+             fty: fty,\n+             entry: {derefs: self.derefs, origin: origin}});\n     }\n \n-    fn write_mty_from_fty(self_substs: ty::substs,\n-                          n_tps_m: uint,\n-                          fty: ty::t,\n-                          origin: method_origin) -> method_map_entry {\n-\n+    fn write_mty_from_candidate(cand: candidate) -> method_map_entry {\n         let tcx = self.fcx.ccx.tcx;\n \n-        #debug[\"write_mty_from_fty(n_tps_m=%u, fty=%s, origin=%?)\",\n-               n_tps_m,\n-               self.fcx.infcx.ty_to_str(fty),\n-               origin];\n-\n-        // Here I will use the \"c_\" prefix to refer to the method's\n-        // owner.  You can read it as class, but it may also be an iface.\n+        #debug[\"write_mty_from_candidate(n_tps_m=%u, fty=%s, entry=%?)\",\n+               cand.n_tps_m,\n+               self.fcx.infcx.ty_to_str(cand.fty),\n+               cand.entry];\n+\n+        // Make the actual receiver type (cand.self_ty) assignable to the\n+        // required receiver type (cand.rcvr_ty).  If this method is not\n+        // from an impl, this'll basically be a no-nop.\n+        alt self.fcx.mk_assignty(self.self_expr, self.borrow_scope,\n+                                 cand.self_ty, cand.rcvr_ty) {\n+          result::ok(_) {}\n+          result::err(_) {\n+            self.tcx().sess.span_bug(\n+                self.expr.span,\n+                #fmt[\"%s was assignable to %s but now is not?\",\n+                     self.fcx.infcx.ty_to_str(cand.self_ty),\n+                     self.fcx.infcx.ty_to_str(cand.rcvr_ty)]);\n+          }\n+        }\n \n+        // Construct the full set of type parameters for the method,\n+        // which is equal to the class tps + the method tps.\n         let n_tps_supplied = self.supplied_tps.len();\n+        let n_tps_m = cand.n_tps_m;\n         let m_substs = {\n             if n_tps_supplied == 0u {\n                 self.fcx.infcx.next_ty_vars(n_tps_m)\n@@ -325,12 +387,12 @@ impl methods for lookup {\n             }\n         };\n \n-        let all_substs = {tps: self_substs.tps + m_substs\n-                          with self_substs};\n+        let all_substs = {tps: cand.self_substs.tps + m_substs\n+                          with cand.self_substs};\n \n-        self.fcx.write_ty_substs(self.node_id, fty, all_substs);\n+        self.fcx.write_ty_substs(self.node_id, cand.fty, all_substs);\n \n-        ret {derefs:0u, origin:origin};\n+        ret cand.entry;\n     }\n }\n "}, {"sha": "6d1d44283483b556e10c3e4f3dac5365a44043e2", "filename": "src/test/run-pass/autoderef-method-newtype.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/773a640303db0995868f8739857b0df16afa1969/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773a640303db0995868f8739857b0df16afa1969/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs?ref=773a640303db0995868f8739857b0df16afa1969", "patch": "@@ -0,0 +1,10 @@\n+impl methods for uint {\n+    fn double() -> uint { self * 2u }\n+}\n+\n+enum foo = uint;\n+\n+fn main() {\n+    let x = foo(3u);\n+    assert x.double() == 6u;\n+}"}, {"sha": "4f9dd19abbd831854bfc51ce06d606d7ad07c447", "filename": "src/test/run-pass/autoderef-method-priority.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/773a640303db0995868f8739857b0df16afa1969/src%2Ftest%2Frun-pass%2Fautoderef-method-priority.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773a640303db0995868f8739857b0df16afa1969/src%2Ftest%2Frun-pass%2Fautoderef-method-priority.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-priority.rs?ref=773a640303db0995868f8739857b0df16afa1969", "patch": "@@ -0,0 +1,12 @@\n+impl methods for uint {\n+    fn double() -> uint { self }\n+}\n+\n+impl methods for @uint {\n+    fn double() -> uint { *self * 2u }\n+}\n+\n+fn main() {\n+    let x = @3u;\n+    assert x.double() == 6u;\n+}"}, {"sha": "7ea03d0d7e4efbb703e5f6f9084f996bcb698d9d", "filename": "src/test/run-pass/autoderef-method.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/773a640303db0995868f8739857b0df16afa1969/src%2Ftest%2Frun-pass%2Fautoderef-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773a640303db0995868f8739857b0df16afa1969/src%2Ftest%2Frun-pass%2Fautoderef-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method.rs?ref=773a640303db0995868f8739857b0df16afa1969", "patch": "@@ -0,0 +1,8 @@\n+impl methods for uint {\n+    fn double() -> uint { self * 2u }\n+}\n+\n+fn main() {\n+    let x = @3u;\n+    assert x.double() == 6u;\n+}"}]}