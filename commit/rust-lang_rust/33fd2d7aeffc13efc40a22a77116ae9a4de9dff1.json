{"sha": "33fd2d7aeffc13efc40a22a77116ae9a4de9dff1", "node_id": "C_kwDOAAsO6NoAKDMzZmQyZDdhZWZmYzEzZWZjNDBhMjJhNzcxMTZhZTlhNGRlOWRmZjE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-02T15:01:46Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-03T14:52:03Z"}, "message": "Cleanup PathCompletionContext qualifier handling", "tree": {"sha": "617cf6debdffc5372a462514fbdc1d3876424e52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/617cf6debdffc5372a462514fbdc1d3876424e52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1", "html_url": "https://github.com/rust-lang/rust/commit/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3ad99649ff8c3f1d10a6f3cd822d15b985c10df", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3ad99649ff8c3f1d10a6f3cd822d15b985c10df", "html_url": "https://github.com/rust-lang/rust/commit/a3ad99649ff8c3f1d10a6f3cd822d15b985c10df"}], "stats": {"total": 180, "additions": 89, "deletions": 91}, "files": [{"sha": "3dd5a7ba223e24319077d8aa18a3e63fd0cbdeb2", "filename": "crates/ide_completion/src/completions/attribute.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=33fd2d7aeffc13efc40a22a77116ae9a4de9dff1", "patch": "@@ -2,8 +2,6 @@\n //!\n //! This module uses a bit of static metadata to provide completions for builtin-in attributes and lints.\n \n-use std::iter;\n-\n use hir::ScopeDef;\n use ide_db::{\n     helpers::{\n@@ -24,7 +22,7 @@ use syntax::{\n \n use crate::{\n     completions::module_or_attr,\n-    context::{CompletionContext, PathCompletionContext, PathKind},\n+    context::{CompletionContext, PathCompletionCtx, PathKind, PathQualifierCtx},\n     item::CompletionItem,\n     Completions,\n };\n@@ -76,25 +74,23 @@ pub(crate) fn complete_known_attribute_input(\n }\n \n pub(crate) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext) {\n-    let (is_trivial_path, qualifier, is_inner, annotated_item_kind) = match ctx.path_context {\n-        Some(PathCompletionContext {\n+    let (is_absolute_path, qualifier, is_inner, annotated_item_kind) = match ctx.path_context {\n+        Some(PathCompletionCtx {\n             kind: Some(PathKind::Attr { kind, annotated_item_kind }),\n-            is_trivial_path,\n+            is_absolute_path,\n             ref qualifier,\n             ..\n-        }) => (is_trivial_path, qualifier, kind == AttrKind::Inner, annotated_item_kind),\n+        }) => (is_absolute_path, qualifier, kind == AttrKind::Inner, annotated_item_kind),\n         _ => return,\n     };\n \n     match qualifier {\n-        Some((path, qualifier)) => {\n-            let is_super_chain = iter::successors(Some(path.clone()), |p| p.qualifier())\n-                .all(|p| p.segment().and_then(|s| s.super_token()).is_some());\n-            if is_super_chain {\n+        Some(PathQualifierCtx { resolution, is_super_chain, .. }) => {\n+            if *is_super_chain {\n                 acc.add_keyword(ctx, \"super::\");\n             }\n \n-            let module = match qualifier {\n+            let module = match resolution {\n                 Some(hir::PathResolution::Def(hir::ModuleDef::Module(it))) => it,\n                 _ => return,\n             };\n@@ -107,7 +103,7 @@ pub(crate) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext)\n             return;\n         }\n         // fresh use tree with leading colon2, only show crate roots\n-        None if !is_trivial_path => {\n+        None if is_absolute_path => {\n             ctx.process_all_names(&mut |name, res| match res {\n                 ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) if m.is_crate_root(ctx.db) => {\n                     acc.add_resolution(ctx, name, res);"}, {"sha": "4a34b0f7e5625046edba6e7f00ced6068523231f", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=33fd2d7aeffc13efc40a22a77116ae9a4de9dff1", "patch": "@@ -32,7 +32,7 @@ fn complete_undotted_self(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.config.enable_self_on_the_fly {\n         return;\n     }\n-    if !ctx.is_trivial_path() || ctx.is_path_disallowed() || !ctx.expects_expression() {\n+    if ctx.is_non_trivial_path() || ctx.is_path_disallowed() || !ctx.expects_expression() {\n         return;\n     }\n     if let Some(func) = ctx.function_def.as_ref().and_then(|fn_| ctx.sema.to_def(fn_)) {"}, {"sha": "0c0c9719d317f476bf47beae7c65555dc9fefade", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=33fd2d7aeffc13efc40a22a77116ae9a4de9dff1", "patch": "@@ -5,7 +5,7 @@\n use syntax::{SyntaxKind, T};\n \n use crate::{\n-    context::{PathCompletionContext, PathKind},\n+    context::{PathCompletionCtx, PathKind},\n     patterns::ImmediateLocation,\n     CompletionContext, CompletionItem, CompletionItemKind, Completions,\n };\n@@ -122,9 +122,9 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n     }\n \n     let (can_be_stmt, in_loop_body) = match ctx.path_context {\n-        Some(PathCompletionContext {\n-            is_trivial_path: true, can_be_stmt, in_loop_body, ..\n-        }) => (can_be_stmt, in_loop_body),\n+        Some(PathCompletionCtx { is_absolute_path: false, can_be_stmt, in_loop_body, .. }) => {\n+            (can_be_stmt, in_loop_body)\n+        }\n         _ => return,\n     };\n "}, {"sha": "a3606c17f5a081580ad4ee09c1c7e4619eba4e18", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=33fd2d7aeffc13efc40a22a77116ae9a4de9dff1", "patch": "@@ -6,7 +6,7 @@ use syntax::ast;\n \n use crate::{\n     completions::module_or_fn_macro,\n-    context::{PathCompletionContext, PathKind},\n+    context::{PathCompletionCtx, PathKind},\n     patterns::ImmediateLocation,\n     CompletionContext, Completions,\n };\n@@ -15,18 +15,16 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n     if ctx.is_path_disallowed() || ctx.has_impl_or_trait_prev_sibling() {\n         return;\n     }\n-    let ((path, resolution), kind) = match ctx.path_context {\n+    let (qualifier, kind) = match ctx.path_context {\n         // let ... else, syntax would come in really handy here right now\n-        Some(PathCompletionContext { qualifier: Some(ref qualifier), kind, .. }) => {\n-            (qualifier, kind)\n-        }\n+        Some(PathCompletionCtx { qualifier: Some(ref qualifier), kind, .. }) => (qualifier, kind),\n         _ => return,\n     };\n \n     // special case `<_>::$0` as this doesn't resolve to anything.\n-    if path.qualifier().is_none() {\n+    if qualifier.path.qualifier().is_none() {\n         if matches!(\n-            path.segment().and_then(|it| it.kind()),\n+            qualifier.path.segment().and_then(|it| it.kind()),\n             Some(ast::PathSegmentKind::Type {\n                 type_ref: Some(ast::Type::InferType(_)),\n                 trait_ref: None,\n@@ -42,7 +40,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n         }\n     }\n \n-    let resolution = match resolution {\n+    let resolution = match &qualifier.resolution {\n         Some(res) => res,\n         None => return,\n     };"}, {"sha": "9a2b9c2fa4081475104b43224d2f6350169e826a", "filename": "crates/ide_completion/src/completions/snippet.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=33fd2d7aeffc13efc40a22a77116ae9a4de9dff1", "patch": "@@ -5,7 +5,7 @@ use ide_db::helpers::{insert_use::ImportScope, SnippetCap};\n use syntax::T;\n \n use crate::{\n-    context::PathCompletionContext, item::Builder, CompletionContext, CompletionItem,\n+    context::PathCompletionCtx, item::Builder, CompletionContext, CompletionItem,\n     CompletionItemKind, Completions, SnippetScope,\n };\n \n@@ -21,7 +21,9 @@ pub(crate) fn complete_expr_snippet(acc: &mut Completions, ctx: &CompletionConte\n     }\n \n     let can_be_stmt = match ctx.path_context {\n-        Some(PathCompletionContext { is_trivial_path: true, can_be_stmt, .. }) => can_be_stmt,\n+        Some(PathCompletionCtx {\n+            is_absolute_path: false, qualifier: None, can_be_stmt, ..\n+        }) => can_be_stmt,\n         _ => return,\n     };\n "}, {"sha": "c225b37d72db95a60627042cb8e7157ce0d6a5d0", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=33fd2d7aeffc13efc40a22a77116ae9a4de9dff1", "patch": "@@ -5,7 +5,7 @@ use syntax::{ast, AstNode};\n \n use crate::{\n     completions::module_or_fn_macro,\n-    context::{PathCompletionContext, PathKind},\n+    context::{PathCompletionCtx, PathKind},\n     patterns::ImmediateLocation,\n     CompletionContext, Completions,\n };\n@@ -16,11 +16,11 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         return;\n     }\n     match ctx.path_context {\n-        Some(PathCompletionContext {\n+        Some(PathCompletionCtx {\n             kind: Some(PathKind::Vis { .. } | PathKind::Attr { .. } | PathKind::Use { .. }),\n             ..\n         }) => return,\n-        Some(PathCompletionContext { is_trivial_path: true, .. }) => (),\n+        Some(PathCompletionCtx { is_absolute_path: false, qualifier: None, .. }) => (),\n         _ => return,\n     }\n "}, {"sha": "eac96c7cba09cc7684aceb45d2ece68134814a7f", "filename": "crates/ide_completion/src/completions/use_.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=33fd2d7aeffc13efc40a22a77116ae9a4de9dff1", "patch": "@@ -1,36 +1,31 @@\n //! Completion for use trees\n \n-use std::iter;\n-\n use hir::ScopeDef;\n use syntax::{ast, AstNode};\n \n use crate::{\n-    context::{CompletionContext, PathCompletionContext, PathKind},\n+    context::{CompletionContext, PathCompletionCtx, PathKind, PathQualifierCtx},\n     Completions,\n };\n \n pub(crate) fn complete_use_tree(acc: &mut Completions, ctx: &CompletionContext) {\n-    let (is_trivial_path, qualifier, use_tree_parent) = match ctx.path_context {\n-        Some(PathCompletionContext {\n+    let (is_absolute_path, qualifier) = match ctx.path_context {\n+        Some(PathCompletionCtx {\n             kind: Some(PathKind::Use),\n-            is_trivial_path,\n-            use_tree_parent,\n+            is_absolute_path,\n             ref qualifier,\n             ..\n-        }) => (is_trivial_path, qualifier, use_tree_parent),\n+        }) => (is_absolute_path, qualifier),\n         _ => return,\n     };\n \n     match qualifier {\n-        Some((path, qualifier)) => {\n-            let is_super_chain = iter::successors(Some(path.clone()), |p| p.qualifier())\n-                .all(|p| p.segment().and_then(|s| s.super_token()).is_some());\n-            if is_super_chain {\n+        Some(PathQualifierCtx { path, resolution, is_super_chain, use_tree_parent }) => {\n+            if *is_super_chain {\n                 acc.add_keyword(ctx, \"super::\");\n             }\n             // only show `self` in a new use-tree when the qualifier doesn't end in self\n-            let not_preceded_by_self = use_tree_parent\n+            let not_preceded_by_self = *use_tree_parent\n                 && !matches!(\n                     path.segment().and_then(|it| it.kind()),\n                     Some(ast::PathSegmentKind::SelfKw)\n@@ -39,12 +34,12 @@ pub(crate) fn complete_use_tree(acc: &mut Completions, ctx: &CompletionContext)\n                 acc.add_keyword(ctx, \"self\");\n             }\n \n-            let qualifier = match qualifier {\n+            let resolution = match resolution {\n                 Some(it) => it,\n                 None => return,\n             };\n \n-            match qualifier {\n+            match resolution {\n                 hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {\n                     let module_scope = module.scope(ctx.db, ctx.module);\n                     let unknown_is_current = |name: &hir::Name| {\n@@ -82,7 +77,7 @@ pub(crate) fn complete_use_tree(acc: &mut Completions, ctx: &CompletionContext)\n             }\n         }\n         // fresh use tree with leading colon2, only show crate roots\n-        None if !is_trivial_path => {\n+        None if is_absolute_path => {\n             cov_mark::hit!(use_tree_crate_roots_only);\n             ctx.process_all_names(&mut |name, res| match res {\n                 ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) if m.is_crate_root(ctx.db) => {"}, {"sha": "9cf96326588ce0cab490686772ab8d928360a843", "filename": "crates/ide_completion/src/completions/vis.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fvis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fvis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fvis.rs?ref=33fd2d7aeffc13efc40a22a77116ae9a4de9dff1", "patch": "@@ -1,28 +1,26 @@\n //! Completion for visibility specifiers.\n \n-use std::iter;\n-\n use hir::ScopeDef;\n \n use crate::{\n-    context::{CompletionContext, PathCompletionContext, PathKind},\n+    context::{CompletionContext, PathCompletionCtx, PathKind, PathQualifierCtx},\n     Completions,\n };\n \n pub(crate) fn complete_vis(acc: &mut Completions, ctx: &CompletionContext) {\n-    let (is_trivial_path, qualifier, has_in_token) = match ctx.path_context {\n-        Some(PathCompletionContext {\n+    let (is_absolute_path, qualifier, has_in_token) = match ctx.path_context {\n+        Some(PathCompletionCtx {\n             kind: Some(PathKind::Vis { has_in_token }),\n-            is_trivial_path,\n+            is_absolute_path,\n             ref qualifier,\n             ..\n-        }) => (is_trivial_path, qualifier, has_in_token),\n+        }) => (is_absolute_path, qualifier, has_in_token),\n         _ => return,\n     };\n \n     match qualifier {\n-        Some((path, qualifier)) => {\n-            if let Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) = qualifier {\n+        Some(PathQualifierCtx { resolution, is_super_chain, .. }) => {\n+            if let Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) = resolution {\n                 if let Some(current_module) = ctx.module {\n                     let next_towards_current = current_module\n                         .path_to_root(ctx.db)\n@@ -38,13 +36,11 @@ pub(crate) fn complete_vis(acc: &mut Completions, ctx: &CompletionContext) {\n                 }\n             }\n \n-            let is_super_chain = iter::successors(Some(path.clone()), |p| p.qualifier())\n-                .all(|p| p.segment().and_then(|s| s.super_token()).is_some());\n-            if is_super_chain {\n+            if *is_super_chain {\n                 acc.add_keyword(ctx, \"super::\");\n             }\n         }\n-        None if is_trivial_path => {\n+        None if !is_absolute_path => {\n             if !has_in_token {\n                 cov_mark::hit!(kw_completion_in);\n                 acc.add_keyword(ctx, \"in\");"}, {"sha": "de1a378ea82879e0e6827b37b21c673332964b56", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=33fd2d7aeffc13efc40a22a77116ae9a4de9dff1", "patch": "@@ -36,6 +36,7 @@ pub(crate) enum PatternRefutability {\n     Refutable,\n     Irrefutable,\n }\n+\n pub(crate) enum Visible {\n     Yes,\n     Editable,\n@@ -54,18 +55,13 @@ pub(super) enum PathKind {\n }\n \n #[derive(Debug)]\n-pub(crate) struct PathCompletionContext {\n+pub(crate) struct PathCompletionCtx {\n     /// If this is a call with () already there\n     has_call_parens: bool,\n-    /// A single-indent path, like `foo`. `::foo` should not be considered a trivial path.\n-    pub(super) is_trivial_path: bool,\n-    /// If not a trivial path, the prefix (qualifier).\n-    pub(super) qualifier: Option<(ast::Path, Option<PathResolution>)>,\n-    #[allow(dead_code)]\n-    /// If not a trivial path, the suffix (parent).\n-    pub(super) parent: Option<ast::Path>,\n-    /// Whether the qualifier comes from a use tree parent or not\n-    pub(super) use_tree_parent: bool,\n+    /// Whether this path stars with a `::`.\n+    pub(super) is_absolute_path: bool,\n+    /// The qualifier of the current path if it exists.\n+    pub(super) qualifier: Option<PathQualifierCtx>,\n     pub(super) kind: Option<PathKind>,\n     /// Whether the path segment has type args or not.\n     pub(super) has_type_args: bool,\n@@ -74,6 +70,16 @@ pub(crate) struct PathCompletionContext {\n     pub(super) in_loop_body: bool,\n }\n \n+#[derive(Debug)]\n+pub(crate) struct PathQualifierCtx {\n+    pub path: ast::Path,\n+    pub resolution: Option<PathResolution>,\n+    /// Whether this path consists solely of `super` segments\n+    pub is_super_chain: bool,\n+    /// Whether the qualifier comes from a use tree parent or not\n+    pub use_tree_parent: bool,\n+}\n+\n #[derive(Debug)]\n pub(super) struct PatternContext {\n     pub(super) refutability: PatternRefutability,\n@@ -131,7 +137,7 @@ pub(crate) struct CompletionContext<'a> {\n \n     pub(super) lifetime_ctx: Option<LifetimeContext>,\n     pub(super) pattern_ctx: Option<PatternContext>,\n-    pub(super) path_context: Option<PathCompletionContext>,\n+    pub(super) path_context: Option<PathCompletionCtx>,\n \n     pub(super) locals: Vec<(Name, Local)>,\n \n@@ -264,27 +270,29 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     pub(crate) fn expects_expression(&self) -> bool {\n-        matches!(self.path_context, Some(PathCompletionContext { kind: Some(PathKind::Expr), .. }))\n+        matches!(self.path_context, Some(PathCompletionCtx { kind: Some(PathKind::Expr), .. }))\n     }\n \n     pub(crate) fn expects_type(&self) -> bool {\n-        matches!(self.path_context, Some(PathCompletionContext { kind: Some(PathKind::Type), .. }))\n+        matches!(self.path_context, Some(PathCompletionCtx { kind: Some(PathKind::Type), .. }))\n     }\n \n     pub(crate) fn path_is_call(&self) -> bool {\n         self.path_context.as_ref().map_or(false, |it| it.has_call_parens)\n     }\n \n-    pub(crate) fn is_trivial_path(&self) -> bool {\n-        matches!(self.path_context, Some(PathCompletionContext { is_trivial_path: true, .. }))\n-    }\n-\n     pub(crate) fn is_non_trivial_path(&self) -> bool {\n-        matches!(self.path_context, Some(PathCompletionContext { is_trivial_path: false, .. }))\n+        matches!(\n+            self.path_context,\n+            Some(\n+                PathCompletionCtx { is_absolute_path: true, .. }\n+                    | PathCompletionCtx { qualifier: Some(_), .. }\n+            )\n+        )\n     }\n \n     pub(crate) fn path_qual(&self) -> Option<&ast::Path> {\n-        self.path_context.as_ref().and_then(|it| it.qualifier.as_ref().map(|(it, _)| it))\n+        self.path_context.as_ref().and_then(|it| it.qualifier.as_ref().map(|it| &it.path))\n     }\n \n     pub(crate) fn path_kind(&self) -> Option<PathKind> {\n@@ -791,20 +799,18 @@ impl<'a> CompletionContext<'a> {\n         sema: &Semantics<RootDatabase>,\n         original_file: &SyntaxNode,\n         name_ref: ast::NameRef,\n-    ) -> Option<(PathCompletionContext, Option<PatternContext>)> {\n+    ) -> Option<(PathCompletionCtx, Option<PatternContext>)> {\n         let parent = name_ref.syntax().parent()?;\n         let segment = ast::PathSegment::cast(parent)?;\n         let path = segment.parent_path();\n \n-        let mut path_ctx = PathCompletionContext {\n+        let mut path_ctx = PathCompletionCtx {\n             has_call_parens: false,\n-            is_trivial_path: false,\n+            is_absolute_path: false,\n             qualifier: None,\n-            parent: None,\n             has_type_args: false,\n             can_be_stmt: false,\n             in_loop_body: false,\n-            use_tree_parent: false,\n             kind: None,\n         };\n         let mut pat_ctx = None;\n@@ -859,26 +865,31 @@ impl<'a> CompletionContext<'a> {\n         path_ctx.has_type_args = segment.generic_arg_list().is_some();\n \n         if let Some((path, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n-            path_ctx.use_tree_parent = use_tree_parent;\n+            if !use_tree_parent {\n+                path_ctx.is_absolute_path =\n+                    path.top_path().segment().map_or(false, |it| it.coloncolon_token().is_some());\n+            }\n+\n             let path = path\n                 .segment()\n                 .and_then(|it| find_node_in_file(original_file, &it))\n                 .map(|it| it.parent_path());\n             path_ctx.qualifier = path.map(|path| {\n                 let res = sema.resolve_path(&path);\n-                (path, res)\n+                let is_super_chain = iter::successors(Some(path.clone()), |p| p.qualifier())\n+                    .all(|p| p.segment().and_then(|s| s.super_token()).is_some());\n+                PathQualifierCtx { path, resolution: res, is_super_chain, use_tree_parent }\n             });\n             return Some((path_ctx, pat_ctx));\n         }\n \n         if let Some(segment) = path.segment() {\n             if segment.coloncolon_token().is_some() {\n+                path_ctx.is_absolute_path = true;\n                 return Some((path_ctx, pat_ctx));\n             }\n         }\n \n-        path_ctx.is_trivial_path = true;\n-\n         // Find either enclosing expr statement (thing with `;`) or a\n         // block. If block, check that we are the last expr.\n         path_ctx.can_be_stmt = name_ref\n@@ -969,7 +980,7 @@ fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<(ast::Path, bool)> {\n     }\n     let use_tree_list = path.syntax().ancestors().find_map(ast::UseTreeList::cast)?;\n     let use_tree = use_tree_list.syntax().parent().and_then(ast::UseTree::cast)?;\n-    use_tree.path().zip(Some(true))\n+    Some((use_tree.path()?, true))\n }\n \n fn has_ref(token: &SyntaxToken) -> bool {"}, {"sha": "027fb5352715156351ef6e699ac956d329d01e15", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=33fd2d7aeffc13efc40a22a77116ae9a4de9dff1", "patch": "@@ -19,7 +19,7 @@ use ide_db::{\n use syntax::{SmolStr, SyntaxKind, TextRange};\n \n use crate::{\n-    context::{PathCompletionContext, PathKind},\n+    context::{PathCompletionCtx, PathKind},\n     item::{CompletionRelevanceTypeMatch, ImportEdit},\n     render::{enum_variant::render_variant, function::render_fn, macro_::render_macro},\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance,\n@@ -234,7 +234,7 @@ fn render_resolution_(\n     // Add `<>` for generic types\n     let type_path_no_ty_args = matches!(\n         ctx.completion.path_context,\n-        Some(PathCompletionContext { kind: Some(PathKind::Type), has_type_args: false, .. })\n+        Some(PathCompletionCtx { kind: Some(PathKind::Type), has_type_args: false, .. })\n     ) && ctx.completion.config.add_call_parenthesis;\n     if type_path_no_ty_args {\n         if let Some(cap) = ctx.snippet_cap() {"}]}