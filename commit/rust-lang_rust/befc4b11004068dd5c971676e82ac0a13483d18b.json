{"sha": "befc4b11004068dd5c971676e82ac0a13483d18b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlZmM0YjExMDA0MDY4ZGQ1Yzk3MTY3NmU4MmFjMGExMzQ4M2QxOGI=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-22T20:55:53Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-27T20:45:46Z"}, "message": "Rename hir::map::Node to hir::map::NodeKind", "tree": {"sha": "fde70e5a9e129ebd3c46ca07c7e66cb2b0cfe84a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fde70e5a9e129ebd3c46ca07c7e66cb2b0cfe84a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/befc4b11004068dd5c971676e82ac0a13483d18b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/befc4b11004068dd5c971676e82ac0a13483d18b", "html_url": "https://github.com/rust-lang/rust/commit/befc4b11004068dd5c971676e82ac0a13483d18b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/befc4b11004068dd5c971676e82ac0a13483d18b/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1a338faab386c63726c9efb4924fe6d93419108", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1a338faab386c63726c9efb4924fe6d93419108", "html_url": "https://github.com/rust-lang/rust/commit/a1a338faab386c63726c9efb4924fe6d93419108"}], "stats": {"total": 914, "additions": 457, "deletions": 457}, "files": [{"sha": "1013755e85113482626bc2068961d4ecbef1fb9f", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -22,7 +22,7 @@\n //! for the `Code` associated with a particular NodeId.\n \n use hir as ast;\n-use hir::map::{self, Node};\n+use hir::map::{self, NodeKind};\n use hir::{Expr, FnDecl};\n use hir::intravisit::FnKind;\n use syntax::ast::{Attribute, Ident, Name, NodeId};\n@@ -39,7 +39,7 @@ use syntax_pos::Span;\n ///\n /// To construct one, use the `Code::from_node` function.\n #[derive(Copy, Clone, Debug)]\n-pub struct FnLikeNode<'a> { node: map::Node<'a> }\n+pub struct FnLikeNode<'a> { node: NodeKind<'a> }\n \n /// MaybeFnLike wraps a method that indicates if an object\n /// corresponds to some FnLikeNode.\n@@ -95,11 +95,11 @@ impl<'a> Code<'a> {\n     /// Attempts to construct a Code from presumed FnLike or Expr node input.\n     pub fn from_node(map: &map::Map<'a>, id: NodeId) -> Option<Code<'a>> {\n         match map.get(id) {\n-            map::NodeBlock(_) => {\n+            map::NodeKind::Block(_) => {\n                 //  Use the parent, hopefully an expression node.\n                 Code::from_node(map, map.get_parent_node(id))\n             }\n-            map::NodeExpr(expr) => Some(Code::Expr(expr)),\n+            map::NodeKind::Expr(expr) => Some(Code::Expr(expr)),\n             node => FnLikeNode::from_node(node).map(Code::FnLike)\n         }\n     }\n@@ -143,12 +143,12 @@ impl<'a> ClosureParts<'a> {\n \n impl<'a> FnLikeNode<'a> {\n     /// Attempts to construct a FnLikeNode from presumed FnLike node input.\n-    pub fn from_node(node: Node) -> Option<FnLikeNode> {\n+    pub fn from_node(node: NodeKind) -> Option<FnLikeNode> {\n         let fn_like = match node {\n-            map::NodeItem(item) => item.is_fn_like(),\n-            map::NodeTraitItem(tm) => tm.is_fn_like(),\n-            map::NodeImplItem(it) => it.is_fn_like(),\n-            map::NodeExpr(e) => e.is_fn_like(),\n+            map::NodeKind::Item(item) => item.is_fn_like(),\n+            map::NodeKind::TraitItem(tm) => tm.is_fn_like(),\n+            map::NodeKind::ImplItem(it) => it.is_fn_like(),\n+            map::NodeKind::Expr(e) => e.is_fn_like(),\n             _ => false\n         };\n         if fn_like {\n@@ -234,7 +234,7 @@ impl<'a> FnLikeNode<'a> {\n         C: FnOnce(ClosureParts<'a>) -> A,\n     {\n         match self.node {\n-            map::NodeItem(i) => match i.node {\n+            map::NodeKind::Item(i) => match i.node {\n                 ast::ItemKind::Fn(ref decl, header, ref generics, block) =>\n                     item_fn(ItemFnParts {\n                         id: i.id,\n@@ -249,13 +249,13 @@ impl<'a> FnLikeNode<'a> {\n                     }),\n                 _ => bug!(\"item FnLikeNode that is not fn-like\"),\n             },\n-            map::NodeTraitItem(ti) => match ti.node {\n+            map::NodeKind::TraitItem(ti) => match ti.node {\n                 ast::TraitItemKind::Method(ref sig, ast::TraitMethod::Provided(body)) => {\n                     method(ti.id, ti.ident, sig, None, body, ti.span, &ti.attrs)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n-            map::NodeImplItem(ii) => {\n+            map::NodeKind::ImplItem(ii) => {\n                 match ii.node {\n                     ast::ImplItemKind::Method(ref sig, body) => {\n                         method(ii.id, ii.ident, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n@@ -265,7 +265,7 @@ impl<'a> FnLikeNode<'a> {\n                     }\n                 }\n             },\n-            map::NodeExpr(e) => match e.node {\n+            map::NodeKind::Expr(e) => match e.node {\n                 ast::ExprKind::Closure(_, ref decl, block, _fn_decl_span, _gen) =>\n                     closure(ClosureParts::new(&decl, block, e.id, e.span, &e.attrs)),\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),"}, {"sha": "d8f6819f1436dfe4a86a1423c82b877f1b1392b3", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -187,7 +187,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         self.map[id.as_usize()] = entry;\n     }\n \n-    fn insert(&mut self, id: NodeId, node: Node<'hir>) {\n+    fn insert(&mut self, id: NodeId, node: NodeKind<'hir>) {\n         let parent = self.parent_node;\n         let dep_node_index = if self.currently_in_body {\n             self.current_full_dep_index\n@@ -196,26 +196,26 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         };\n \n         let entry = match node {\n-            NodeItem(n) => EntryKind::Item(parent, dep_node_index, n),\n-            NodeForeignItem(n) => EntryKind::ForeignItem(parent, dep_node_index, n),\n-            NodeTraitItem(n) => EntryKind::TraitItem(parent, dep_node_index, n),\n-            NodeImplItem(n) => EntryKind::ImplItem(parent, dep_node_index, n),\n-            NodeVariant(n) => EntryKind::Variant(parent, dep_node_index, n),\n-            NodeField(n) => EntryKind::Field(parent, dep_node_index, n),\n-            NodeAnonConst(n) => EntryKind::AnonConst(parent, dep_node_index, n),\n-            NodeExpr(n) => EntryKind::Expr(parent, dep_node_index, n),\n-            NodeStmt(n) => EntryKind::Stmt(parent, dep_node_index, n),\n-            NodeTy(n) => EntryKind::Ty(parent, dep_node_index, n),\n-            NodeTraitRef(n) => EntryKind::TraitRef(parent, dep_node_index, n),\n-            NodeBinding(n) => EntryKind::Binding(parent, dep_node_index, n),\n-            NodePat(n) => EntryKind::Pat(parent, dep_node_index, n),\n-            NodeBlock(n) => EntryKind::Block(parent, dep_node_index, n),\n-            NodeStructCtor(n) => EntryKind::StructCtor(parent, dep_node_index, n),\n-            NodeLifetime(n) => EntryKind::Lifetime(parent, dep_node_index, n),\n-            NodeGenericParam(n) => EntryKind::GenericParam(parent, dep_node_index, n),\n-            NodeVisibility(n) => EntryKind::Visibility(parent, dep_node_index, n),\n-            NodeLocal(n) => EntryKind::Local(parent, dep_node_index, n),\n-            NodeMacroDef(n) => EntryKind::MacroDef(dep_node_index, n),\n+            NodeKind::Item(n) => EntryKind::Item(parent, dep_node_index, n),\n+            NodeKind::ForeignItem(n) => EntryKind::ForeignItem(parent, dep_node_index, n),\n+            NodeKind::TraitItem(n) => EntryKind::TraitItem(parent, dep_node_index, n),\n+            NodeKind::ImplItem(n) => EntryKind::ImplItem(parent, dep_node_index, n),\n+            NodeKind::Variant(n) => EntryKind::Variant(parent, dep_node_index, n),\n+            NodeKind::Field(n) => EntryKind::Field(parent, dep_node_index, n),\n+            NodeKind::AnonConst(n) => EntryKind::AnonConst(parent, dep_node_index, n),\n+            NodeKind::Expr(n) => EntryKind::Expr(parent, dep_node_index, n),\n+            NodeKind::Stmt(n) => EntryKind::Stmt(parent, dep_node_index, n),\n+            NodeKind::Ty(n) => EntryKind::Ty(parent, dep_node_index, n),\n+            NodeKind::TraitRef(n) => EntryKind::TraitRef(parent, dep_node_index, n),\n+            NodeKind::Binding(n) => EntryKind::Binding(parent, dep_node_index, n),\n+            NodeKind::Pat(n) => EntryKind::Pat(parent, dep_node_index, n),\n+            NodeKind::Block(n) => EntryKind::Block(parent, dep_node_index, n),\n+            NodeKind::StructCtor(n) => EntryKind::StructCtor(parent, dep_node_index, n),\n+            NodeKind::Lifetime(n) => EntryKind::Lifetime(parent, dep_node_index, n),\n+            NodeKind::GenericParam(n) => EntryKind::GenericParam(parent, dep_node_index, n),\n+            NodeKind::Visibility(n) => EntryKind::Visibility(parent, dep_node_index, n),\n+            NodeKind::Local(n) => EntryKind::Local(parent, dep_node_index, n),\n+            NodeKind::MacroDef(n) => EntryKind::MacroDef(dep_node_index, n),\n         };\n \n         // Make sure that the DepNode of some node coincides with the HirId\n@@ -326,13 +326,13 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         debug_assert_eq!(i.hir_id.owner,\n                          self.definitions.opt_def_index(i.id).unwrap());\n         self.with_dep_node_owner(i.hir_id.owner, i, |this| {\n-            this.insert(i.id, NodeItem(i));\n+            this.insert(i.id, NodeKind::Item(i));\n             this.with_parent(i.id, |this| {\n                 match i.node {\n                     ItemKind::Struct(ref struct_def, _) => {\n                         // If this is a tuple-like struct, register the constructor.\n                         if !struct_def.is_struct() {\n-                            this.insert(struct_def.id(), NodeStructCtor(struct_def));\n+                            this.insert(struct_def.id(), NodeKind::StructCtor(struct_def));\n                         }\n                     }\n                     _ => {}\n@@ -343,23 +343,23 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'hir ForeignItem) {\n-        self.insert(foreign_item.id, NodeForeignItem(foreign_item));\n+        self.insert(foreign_item.id, NodeKind::ForeignItem(foreign_item));\n \n         self.with_parent(foreign_item.id, |this| {\n             intravisit::walk_foreign_item(this, foreign_item);\n         });\n     }\n \n     fn visit_generic_param(&mut self, param: &'hir GenericParam) {\n-        self.insert(param.id, NodeGenericParam(param));\n+        self.insert(param.id, NodeKind::GenericParam(param));\n         intravisit::walk_generic_param(self, param);\n     }\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem) {\n         debug_assert_eq!(ti.hir_id.owner,\n                          self.definitions.opt_def_index(ti.id).unwrap());\n         self.with_dep_node_owner(ti.hir_id.owner, ti, |this| {\n-            this.insert(ti.id, NodeTraitItem(ti));\n+            this.insert(ti.id, NodeKind::TraitItem(ti));\n \n             this.with_parent(ti.id, |this| {\n                 intravisit::walk_trait_item(this, ti);\n@@ -371,7 +371,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         debug_assert_eq!(ii.hir_id.owner,\n                          self.definitions.opt_def_index(ii.id).unwrap());\n         self.with_dep_node_owner(ii.hir_id.owner, ii, |this| {\n-            this.insert(ii.id, NodeImplItem(ii));\n+            this.insert(ii.id, NodeKind::ImplItem(ii));\n \n             this.with_parent(ii.id, |this| {\n                 intravisit::walk_impl_item(this, ii);\n@@ -381,9 +381,9 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_pat(&mut self, pat: &'hir Pat) {\n         let node = if let PatKind::Binding(..) = pat.node {\n-            NodeBinding(pat)\n+            NodeKind::Binding(pat)\n         } else {\n-            NodePat(pat)\n+            NodeKind::Pat(pat)\n         };\n         self.insert(pat.id, node);\n \n@@ -393,15 +393,15 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_anon_const(&mut self, constant: &'hir AnonConst) {\n-        self.insert(constant.id, NodeAnonConst(constant));\n+        self.insert(constant.id, NodeKind::AnonConst(constant));\n \n         self.with_parent(constant.id, |this| {\n             intravisit::walk_anon_const(this, constant);\n         });\n     }\n \n     fn visit_expr(&mut self, expr: &'hir Expr) {\n-        self.insert(expr.id, NodeExpr(expr));\n+        self.insert(expr.id, NodeKind::Expr(expr));\n \n         self.with_parent(expr.id, |this| {\n             intravisit::walk_expr(this, expr);\n@@ -410,23 +410,23 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_stmt(&mut self, stmt: &'hir Stmt) {\n         let id = stmt.node.id();\n-        self.insert(id, NodeStmt(stmt));\n+        self.insert(id, NodeKind::Stmt(stmt));\n \n         self.with_parent(id, |this| {\n             intravisit::walk_stmt(this, stmt);\n         });\n     }\n \n     fn visit_ty(&mut self, ty: &'hir Ty) {\n-        self.insert(ty.id, NodeTy(ty));\n+        self.insert(ty.id, NodeKind::Ty(ty));\n \n         self.with_parent(ty.id, |this| {\n             intravisit::walk_ty(this, ty);\n         });\n     }\n \n     fn visit_trait_ref(&mut self, tr: &'hir TraitRef) {\n-        self.insert(tr.ref_id, NodeTraitRef(tr));\n+        self.insert(tr.ref_id, NodeKind::TraitRef(tr));\n \n         self.with_parent(tr.ref_id, |this| {\n             intravisit::walk_trait_ref(this, tr);\n@@ -440,21 +440,21 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_block(&mut self, block: &'hir Block) {\n-        self.insert(block.id, NodeBlock(block));\n+        self.insert(block.id, NodeKind::Block(block));\n         self.with_parent(block.id, |this| {\n             intravisit::walk_block(this, block);\n         });\n     }\n \n     fn visit_local(&mut self, l: &'hir Local) {\n-        self.insert(l.id, NodeLocal(l));\n+        self.insert(l.id, NodeKind::Local(l));\n         self.with_parent(l.id, |this| {\n             intravisit::walk_local(this, l)\n         })\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'hir Lifetime) {\n-        self.insert(lifetime.id, NodeLifetime(lifetime));\n+        self.insert(lifetime.id, NodeKind::Lifetime(lifetime));\n     }\n \n     fn visit_vis(&mut self, visibility: &'hir Visibility) {\n@@ -463,7 +463,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n             VisibilityKind::Crate(_) |\n             VisibilityKind::Inherited => {}\n             VisibilityKind::Restricted { id, .. } => {\n-                self.insert(id, NodeVisibility(visibility));\n+                self.insert(id, NodeKind::Visibility(visibility));\n                 self.with_parent(id, |this| {\n                     intravisit::walk_vis(this, visibility);\n                 });\n@@ -475,20 +475,20 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         let def_index = self.definitions.opt_def_index(macro_def.id).unwrap();\n \n         self.with_dep_node_owner(def_index, macro_def, |this| {\n-            this.insert(macro_def.id, NodeMacroDef(macro_def));\n+            this.insert(macro_def.id, NodeKind::MacroDef(macro_def));\n         });\n     }\n \n     fn visit_variant(&mut self, v: &'hir Variant, g: &'hir Generics, item_id: NodeId) {\n         let id = v.node.data.id();\n-        self.insert(id, NodeVariant(v));\n+        self.insert(id, NodeKind::Variant(v));\n         self.with_parent(id, |this| {\n             intravisit::walk_variant(this, v, g, item_id);\n         });\n     }\n \n     fn visit_struct_field(&mut self, field: &'hir StructField) {\n-        self.insert(field.id, NodeField(field));\n+        self.insert(field.id, NodeKind::Field(field));\n         self.with_parent(field.id, |this| {\n             intravisit::walk_struct_field(this, field);\n         });"}, {"sha": "c10aea0ac92234ed5aeedad92cba626d7c875e4b", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 179, "deletions": 180, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::Node::*;\n use self::collector::NodeCollector;\n pub use self::def_collector::{DefCollector, MacroInvocationData};\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n@@ -46,30 +45,30 @@ pub const ITEM_LIKE_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::Low;\n pub const REGULAR_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::High;\n \n #[derive(Copy, Clone, Debug)]\n-pub enum Node<'hir> {\n-    NodeItem(&'hir Item),\n-    NodeForeignItem(&'hir ForeignItem),\n-    NodeTraitItem(&'hir TraitItem),\n-    NodeImplItem(&'hir ImplItem),\n-    NodeVariant(&'hir Variant),\n-    NodeField(&'hir StructField),\n-    NodeAnonConst(&'hir AnonConst),\n-    NodeExpr(&'hir Expr),\n-    NodeStmt(&'hir Stmt),\n-    NodeTy(&'hir Ty),\n-    NodeTraitRef(&'hir TraitRef),\n-    NodeBinding(&'hir Pat),\n-    NodePat(&'hir Pat),\n-    NodeBlock(&'hir Block),\n-    NodeLocal(&'hir Local),\n-    NodeMacroDef(&'hir MacroDef),\n-\n-    /// NodeStructCtor represents a tuple struct.\n-    NodeStructCtor(&'hir VariantData),\n-\n-    NodeLifetime(&'hir Lifetime),\n-    NodeGenericParam(&'hir GenericParam),\n-    NodeVisibility(&'hir Visibility),\n+pub enum NodeKind<'hir> {\n+    Item(&'hir Item),\n+    ForeignItem(&'hir ForeignItem),\n+    TraitItem(&'hir TraitItem),\n+    ImplItem(&'hir ImplItem),\n+    Variant(&'hir Variant),\n+    Field(&'hir StructField),\n+    AnonConst(&'hir AnonConst),\n+    Expr(&'hir Expr),\n+    Stmt(&'hir Stmt),\n+    Ty(&'hir Ty),\n+    TraitRef(&'hir TraitRef),\n+    Binding(&'hir Pat),\n+    Pat(&'hir Pat),\n+    Block(&'hir Block),\n+    Local(&'hir Local),\n+    MacroDef(&'hir MacroDef),\n+\n+    /// StructCtor represents a tuple struct.\n+    StructCtor(&'hir VariantData),\n+\n+    Lifetime(&'hir Lifetime),\n+    GenericParam(&'hir GenericParam),\n+    Visibility(&'hir Visibility),\n }\n \n /// Represents an entry and its parent NodeID.\n@@ -141,28 +140,28 @@ impl<'hir> EntryKind<'hir> {\n         })\n     }\n \n-    fn to_node(self) -> Option<Node<'hir>> {\n+    fn to_node(self) -> Option<NodeKind<'hir>> {\n         Some(match self {\n-            EntryKind::Item(_, _, n) => NodeItem(n),\n-            EntryKind::ForeignItem(_, _, n) => NodeForeignItem(n),\n-            EntryKind::TraitItem(_, _, n) => NodeTraitItem(n),\n-            EntryKind::ImplItem(_, _, n) => NodeImplItem(n),\n-            EntryKind::Variant(_, _, n) => NodeVariant(n),\n-            EntryKind::Field(_, _, n) => NodeField(n),\n-            EntryKind::AnonConst(_, _, n) => NodeAnonConst(n),\n-            EntryKind::Expr(_, _, n) => NodeExpr(n),\n-            EntryKind::Stmt(_, _, n) => NodeStmt(n),\n-            EntryKind::Ty(_, _, n) => NodeTy(n),\n-            EntryKind::TraitRef(_, _, n) => NodeTraitRef(n),\n-            EntryKind::Binding(_, _, n) => NodeBinding(n),\n-            EntryKind::Pat(_, _, n) => NodePat(n),\n-            EntryKind::Block(_, _, n) => NodeBlock(n),\n-            EntryKind::StructCtor(_, _, n) => NodeStructCtor(n),\n-            EntryKind::Lifetime(_, _, n) => NodeLifetime(n),\n-            EntryKind::GenericParam(_, _, n) => NodeGenericParam(n),\n-            EntryKind::Visibility(_, _, n) => NodeVisibility(n),\n-            EntryKind::Local(_, _, n) => NodeLocal(n),\n-            EntryKind::MacroDef(_, n) => NodeMacroDef(n),\n+            EntryKind::Item(_, _, n) => NodeKind::Item(n),\n+            EntryKind::ForeignItem(_, _, n) => NodeKind::ForeignItem(n),\n+            EntryKind::TraitItem(_, _, n) => NodeKind::TraitItem(n),\n+            EntryKind::ImplItem(_, _, n) => NodeKind::ImplItem(n),\n+            EntryKind::Variant(_, _, n) => NodeKind::Variant(n),\n+            EntryKind::Field(_, _, n) => NodeKind::Field(n),\n+            EntryKind::AnonConst(_, _, n) => NodeKind::AnonConst(n),\n+            EntryKind::Expr(_, _, n) => NodeKind::Expr(n),\n+            EntryKind::Stmt(_, _, n) => NodeKind::Stmt(n),\n+            EntryKind::Ty(_, _, n) => NodeKind::Ty(n),\n+            EntryKind::TraitRef(_, _, n) => NodeKind::TraitRef(n),\n+            EntryKind::Binding(_, _, n) => NodeKind::Binding(n),\n+            EntryKind::Pat(_, _, n) => NodeKind::Pat(n),\n+            EntryKind::Block(_, _, n) => NodeKind::Block(n),\n+            EntryKind::StructCtor(_, _, n) => NodeKind::StructCtor(n),\n+            EntryKind::Lifetime(_, _, n) => NodeKind::Lifetime(n),\n+            EntryKind::GenericParam(_, _, n) => NodeKind::GenericParam(n),\n+            EntryKind::Visibility(_, _, n) => NodeKind::Visibility(n),\n+            EntryKind::Local(_, _, n) => NodeKind::Local(n),\n+            EntryKind::MacroDef(_, n) => NodeKind::MacroDef(n),\n \n             EntryKind::NotPresent |\n             EntryKind::RootCrate(_) => return None\n@@ -271,8 +270,8 @@ impl Forest {\n     }\n }\n \n-/// Represents a mapping from Node IDs to AST elements and their parent\n-/// Node IDs\n+/// Represents a mapping from NodeKind IDs to AST elements and their parent\n+/// NodeKind IDs\n #[derive(Clone)]\n pub struct Map<'hir> {\n     /// The backing storage for all the AST nodes.\n@@ -419,7 +418,7 @@ impl<'hir> Map<'hir> {\n         };\n \n         match node {\n-            NodeItem(item) => {\n+            NodeKind::Item(item) => {\n                 let def_id = || {\n                     self.local_def_id(item.id)\n                 };\n@@ -446,23 +445,23 @@ impl<'hir> Map<'hir> {\n                     ItemKind::Impl(..) => None,\n                 }\n             }\n-            NodeForeignItem(item) => {\n+            NodeKind::ForeignItem(item) => {\n                 let def_id = self.local_def_id(item.id);\n                 match item.node {\n                     ForeignItemKind::Fn(..) => Some(Def::Fn(def_id)),\n                     ForeignItemKind::Static(_, m) => Some(Def::Static(def_id, m)),\n                     ForeignItemKind::Type => Some(Def::ForeignTy(def_id)),\n                 }\n             }\n-            NodeTraitItem(item) => {\n+            NodeKind::TraitItem(item) => {\n                 let def_id = self.local_def_id(item.id);\n                 match item.node {\n                     TraitItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n                     TraitItemKind::Method(..) => Some(Def::Method(def_id)),\n                     TraitItemKind::Type(..) => Some(Def::AssociatedTy(def_id)),\n                 }\n             }\n-            NodeImplItem(item) => {\n+            NodeKind::ImplItem(item) => {\n                 let def_id = self.local_def_id(item.id);\n                 match item.node {\n                     ImplItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n@@ -471,30 +470,30 @@ impl<'hir> Map<'hir> {\n                     ImplItemKind::Existential(..) => Some(Def::AssociatedExistential(def_id)),\n                 }\n             }\n-            NodeVariant(variant) => {\n+            NodeKind::Variant(variant) => {\n                 let def_id = self.local_def_id(variant.node.data.id());\n                 Some(Def::Variant(def_id))\n             }\n-            NodeField(_) |\n-            NodeAnonConst(_) |\n-            NodeExpr(_) |\n-            NodeStmt(_) |\n-            NodeTy(_) |\n-            NodeTraitRef(_) |\n-            NodePat(_) |\n-            NodeBinding(_) |\n-            NodeStructCtor(_) |\n-            NodeLifetime(_) |\n-            NodeVisibility(_) |\n-            NodeBlock(_) => None,\n-            NodeLocal(local) => {\n+            NodeKind::Field(_) |\n+            NodeKind::AnonConst(_) |\n+            NodeKind::Expr(_) |\n+            NodeKind::Stmt(_) |\n+            NodeKind::Ty(_) |\n+            NodeKind::TraitRef(_) |\n+            NodeKind::Pat(_) |\n+            NodeKind::Binding(_) |\n+            NodeKind::StructCtor(_) |\n+            NodeKind::Lifetime(_) |\n+            NodeKind::Visibility(_) |\n+            NodeKind::Block(_) => None,\n+            NodeKind::Local(local) => {\n                 Some(Def::Local(local.id))\n             }\n-            NodeMacroDef(macro_def) => {\n+            NodeKind::MacroDef(macro_def) => {\n                 Some(Def::Macro(self.local_def_id(macro_def.id),\n                                 MacroKind::Bang))\n             }\n-            NodeGenericParam(param) => {\n+            NodeKind::GenericParam(param) => {\n                 Some(match param.kind {\n                     GenericParamKind::Lifetime { .. } => Def::Local(param.id),\n                     GenericParamKind::Type { .. } => Def::TyParam(self.local_def_id(param.id)),\n@@ -586,13 +585,13 @@ impl<'hir> Map<'hir> {\n \n     pub fn body_owner_kind(&self, id: NodeId) -> BodyOwnerKind {\n         match self.get(id) {\n-            NodeItem(&Item { node: ItemKind::Const(..), .. }) |\n-            NodeTraitItem(&TraitItem { node: TraitItemKind::Const(..), .. }) |\n-            NodeImplItem(&ImplItem { node: ImplItemKind::Const(..), .. }) |\n-            NodeAnonConst(_) => {\n+            NodeKind::Item(&Item { node: ItemKind::Const(..), .. }) |\n+            NodeKind::TraitItem(&TraitItem { node: TraitItemKind::Const(..), .. }) |\n+            NodeKind::ImplItem(&ImplItem { node: ImplItemKind::Const(..), .. }) |\n+            NodeKind::AnonConst(_) => {\n                 BodyOwnerKind::Const\n             }\n-            NodeItem(&Item { node: ItemKind::Static(_, m, _), .. }) => {\n+            NodeKind::Item(&Item { node: ItemKind::Static(_, m, _), .. }) => {\n                 BodyOwnerKind::Static(m)\n             }\n             // Default to function if it's not a constant or static.\n@@ -602,8 +601,8 @@ impl<'hir> Map<'hir> {\n \n     pub fn ty_param_owner(&self, id: NodeId) -> NodeId {\n         match self.get(id) {\n-            NodeItem(&Item { node: ItemKind::Trait(..), .. }) => id,\n-            NodeGenericParam(_) => self.get_parent_node(id),\n+            NodeKind::Item(&Item { node: ItemKind::Trait(..), .. }) => id,\n+            NodeKind::GenericParam(_) => self.get_parent_node(id),\n             _ => {\n                 bug!(\"ty_param_owner: {} not a type parameter\",\n                     self.node_to_string(id))\n@@ -613,10 +612,10 @@ impl<'hir> Map<'hir> {\n \n     pub fn ty_param_name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n-            NodeItem(&Item { node: ItemKind::Trait(..), .. }) => {\n+            NodeKind::Item(&Item { node: ItemKind::Trait(..), .. }) => {\n                 keywords::SelfType.name()\n             }\n-            NodeGenericParam(param) => param.name.ident().name,\n+            NodeKind::GenericParam(param) => param.name.ident().name,\n             _ => bug!(\"ty_param_name: {} not a type parameter\", self.node_to_string(id)),\n         }\n     }\n@@ -651,25 +650,25 @@ impl<'hir> Map<'hir> {\n         &self.forest.krate.attrs\n     }\n \n-    /// Retrieve the Node corresponding to `id`, panicking if it cannot\n+    /// Retrieve the NodeKind corresponding to `id`, panicking if it cannot\n     /// be found.\n-    pub fn get(&self, id: NodeId) -> Node<'hir> {\n+    pub fn get(&self, id: NodeId) -> NodeKind<'hir> {\n         match self.find(id) {\n             Some(node) => node, // read recorded by `find`\n             None => bug!(\"couldn't find node id {} in the AST map\", id)\n         }\n     }\n \n-    pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n+    pub fn get_if_local(&self, id: DefId) -> Option<NodeKind<'hir>> {\n         self.as_local_node_id(id).map(|id| self.get(id)) // read recorded by `get`\n     }\n \n     pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics> {\n         self.get_if_local(id).and_then(|node| {\n             match node {\n-                NodeImplItem(ref impl_item) => Some(&impl_item.generics),\n-                NodeTraitItem(ref trait_item) => Some(&trait_item.generics),\n-                NodeItem(ref item) => {\n+                NodeKind::ImplItem(ref impl_item) => Some(&impl_item.generics),\n+                NodeKind::TraitItem(ref trait_item) => Some(&trait_item.generics),\n+                NodeKind::Item(ref item) => {\n                     match item.node {\n                         ItemKind::Fn(_, _, ref generics, _) |\n                         ItemKind::Ty(_, ref generics) |\n@@ -691,9 +690,9 @@ impl<'hir> Map<'hir> {\n         self.get_generics(id).map(|generics| generics.span).filter(|sp| *sp != DUMMY_SP)\n     }\n \n-    /// Retrieve the Node corresponding to `id`, returning None if\n+    /// Retrieve the NodeKind corresponding to `id`, returning None if\n     /// cannot be found.\n-    pub fn find(&self, id: NodeId) -> Option<Node<'hir>> {\n+    pub fn find(&self, id: NodeId) -> Option<NodeKind<'hir>> {\n         let result = self.find_entry(id).and_then(|x| x.to_node());\n         if result.is_some() {\n             self.read(id);\n@@ -725,14 +724,14 @@ impl<'hir> Map<'hir> {\n     /// immediate parent is an item or a closure.\n     pub fn is_argument(&self, id: NodeId) -> bool {\n         match self.find(id) {\n-            Some(NodeBinding(_)) => (),\n+            Some(NodeKind::Binding(_)) => (),\n             _ => return false,\n         }\n         match self.find(self.get_parent_node(id)) {\n-            Some(NodeItem(_)) |\n-            Some(NodeTraitItem(_)) |\n-            Some(NodeImplItem(_)) => true,\n-            Some(NodeExpr(e)) => {\n+            Some(NodeKind::Item(_)) |\n+            Some(NodeKind::TraitItem(_)) |\n+            Some(NodeKind::ImplItem(_)) => true,\n+            Some(NodeKind::Expr(e)) => {\n                 match e.node {\n                     ExprKind::Closure(..) => true,\n                     _ => false,\n@@ -752,7 +751,7 @@ impl<'hir> Map<'hir> {\n                                 found: F,\n                                 bail_early: F2)\n         -> Result<NodeId, NodeId>\n-        where F: Fn(&Node<'hir>) -> bool, F2: Fn(&Node<'hir>) -> bool\n+        where F: Fn(&NodeKind<'hir>) -> bool, F2: Fn(&NodeKind<'hir>) -> bool\n     {\n         let mut id = start_id;\n         loop {\n@@ -808,18 +807,18 @@ impl<'hir> Map<'hir> {\n     /// }\n     /// ```\n     pub fn get_return_block(&self, id: NodeId) -> Option<NodeId> {\n-        let match_fn = |node: &Node| {\n+        let match_fn = |node: &NodeKind| {\n             match *node {\n-                NodeItem(_) |\n-                NodeForeignItem(_) |\n-                NodeTraitItem(_) |\n-                NodeImplItem(_) => true,\n+                NodeKind::Item(_) |\n+                NodeKind::ForeignItem(_) |\n+                NodeKind::TraitItem(_) |\n+                NodeKind::ImplItem(_) => true,\n                 _ => false,\n             }\n         };\n-        let match_non_returning_block = |node: &Node| {\n+        let match_non_returning_block = |node: &NodeKind| {\n             match *node {\n-                NodeExpr(ref expr) => {\n+                NodeKind::Expr(ref expr) => {\n                     match expr.node {\n                         ExprKind::While(..) | ExprKind::Loop(..) => true,\n                         _ => false,\n@@ -841,10 +840,10 @@ impl<'hir> Map<'hir> {\n     /// in a module, trait, or impl.\n     pub fn get_parent(&self, id: NodeId) -> NodeId {\n         match self.walk_parent_nodes(id, |node| match *node {\n-            NodeItem(_) |\n-            NodeForeignItem(_) |\n-            NodeTraitItem(_) |\n-            NodeImplItem(_) => true,\n+            NodeKind::Item(_) |\n+            NodeKind::ForeignItem(_) |\n+            NodeKind::TraitItem(_) |\n+            NodeKind::ImplItem(_) => true,\n             _ => false,\n         }, |_| false) {\n             Ok(id) => id,\n@@ -856,7 +855,7 @@ impl<'hir> Map<'hir> {\n     /// module parent is in this map.\n     pub fn get_module_parent(&self, id: NodeId) -> DefId {\n         let id = match self.walk_parent_nodes(id, |node| match *node {\n-            NodeItem(&Item { node: ItemKind::Mod(_), .. }) => true,\n+            NodeKind::Item(&Item { node: ItemKind::Mod(_), .. }) => true,\n             _ => false,\n         }, |_| false) {\n             Ok(id) => id,\n@@ -871,11 +870,11 @@ impl<'hir> Map<'hir> {\n     /// regard should be expected to be highly unstable.\n     pub fn get_enclosing_scope(&self, id: NodeId) -> Option<NodeId> {\n         match self.walk_parent_nodes(id, |node| match *node {\n-            NodeItem(_) |\n-            NodeForeignItem(_) |\n-            NodeTraitItem(_) |\n-            NodeImplItem(_) |\n-            NodeBlock(_) => true,\n+            NodeKind::Item(_) |\n+            NodeKind::ForeignItem(_) |\n+            NodeKind::TraitItem(_) |\n+            NodeKind::ImplItem(_) |\n+            NodeKind::Block(_) => true,\n             _ => false,\n         }, |_| false) {\n             Ok(id) => Some(id),\n@@ -910,28 +909,28 @@ impl<'hir> Map<'hir> {\n \n     pub fn expect_item(&self, id: NodeId) -> &'hir Item {\n         match self.find(id) { // read recorded by `find`\n-            Some(NodeItem(item)) => item,\n+            Some(NodeKind::Item(item)) => item,\n             _ => bug!(\"expected item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_impl_item(&self, id: NodeId) -> &'hir ImplItem {\n         match self.find(id) {\n-            Some(NodeImplItem(item)) => item,\n+            Some(NodeKind::ImplItem(item)) => item,\n             _ => bug!(\"expected impl item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_trait_item(&self, id: NodeId) -> &'hir TraitItem {\n         match self.find(id) {\n-            Some(NodeTraitItem(item)) => item,\n+            Some(NodeKind::TraitItem(item)) => item,\n             _ => bug!(\"expected trait item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_variant_data(&self, id: NodeId) -> &'hir VariantData {\n         match self.find(id) {\n-            Some(NodeItem(i)) => {\n+            Some(NodeKind::Item(i)) => {\n                 match i.node {\n                     ItemKind::Struct(ref struct_def, _) |\n                     ItemKind::Union(ref struct_def, _) => struct_def,\n@@ -941,8 +940,8 @@ impl<'hir> Map<'hir> {\n                     }\n                 }\n             }\n-            Some(NodeStructCtor(data)) => data,\n-            Some(NodeVariant(variant)) => &variant.node.data,\n+            Some(NodeKind::StructCtor(data)) => data,\n+            Some(NodeKind::Variant(variant)) => &variant.node.data,\n             _ => {\n                 bug!(\"expected struct or variant, found {}\",\n                      self.node_to_string(id));\n@@ -952,59 +951,59 @@ impl<'hir> Map<'hir> {\n \n     pub fn expect_variant(&self, id: NodeId) -> &'hir Variant {\n         match self.find(id) {\n-            Some(NodeVariant(variant)) => variant,\n+            Some(NodeKind::Variant(variant)) => variant,\n             _ => bug!(\"expected variant, found {}\", self.node_to_string(id)),\n         }\n     }\n \n     pub fn expect_foreign_item(&self, id: NodeId) -> &'hir ForeignItem {\n         match self.find(id) {\n-            Some(NodeForeignItem(item)) => item,\n+            Some(NodeKind::ForeignItem(item)) => item,\n             _ => bug!(\"expected foreign item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_expr(&self, id: NodeId) -> &'hir Expr {\n         match self.find(id) { // read recorded by find\n-            Some(NodeExpr(expr)) => expr,\n+            Some(NodeKind::Expr(expr)) => expr,\n             _ => bug!(\"expected expr, found {}\", self.node_to_string(id))\n         }\n     }\n \n     /// Returns the name associated with the given NodeId's AST.\n     pub fn name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n-            NodeItem(i) => i.name,\n-            NodeForeignItem(i) => i.name,\n-            NodeImplItem(ii) => ii.ident.name,\n-            NodeTraitItem(ti) => ti.ident.name,\n-            NodeVariant(v) => v.node.name,\n-            NodeField(f) => f.ident.name,\n-            NodeLifetime(lt) => lt.name.ident().name,\n-            NodeGenericParam(param) => param.name.ident().name,\n-            NodeBinding(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.name,\n-            NodeStructCtor(_) => self.name(self.get_parent(id)),\n+            NodeKind::Item(i) => i.name,\n+            NodeKind::ForeignItem(i) => i.name,\n+            NodeKind::ImplItem(ii) => ii.ident.name,\n+            NodeKind::TraitItem(ti) => ti.ident.name,\n+            NodeKind::Variant(v) => v.node.name,\n+            NodeKind::Field(f) => f.ident.name,\n+            NodeKind::Lifetime(lt) => lt.name.ident().name,\n+            NodeKind::GenericParam(param) => param.name.ident().name,\n+            NodeKind::Binding(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.name,\n+            NodeKind::StructCtor(_) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }\n     }\n \n     /// Given a node ID, get a list of attributes associated with the AST\n-    /// corresponding to the Node ID\n+    /// corresponding to the NodeKind ID\n     pub fn attrs(&self, id: NodeId) -> &'hir [ast::Attribute] {\n         self.read(id); // reveals attributes on the node\n         let attrs = match self.find(id) {\n-            Some(NodeItem(i)) => Some(&i.attrs[..]),\n-            Some(NodeForeignItem(fi)) => Some(&fi.attrs[..]),\n-            Some(NodeTraitItem(ref ti)) => Some(&ti.attrs[..]),\n-            Some(NodeImplItem(ref ii)) => Some(&ii.attrs[..]),\n-            Some(NodeVariant(ref v)) => Some(&v.node.attrs[..]),\n-            Some(NodeField(ref f)) => Some(&f.attrs[..]),\n-            Some(NodeExpr(ref e)) => Some(&*e.attrs),\n-            Some(NodeStmt(ref s)) => Some(s.node.attrs()),\n-            Some(NodeGenericParam(param)) => Some(&param.attrs[..]),\n+            Some(NodeKind::Item(i)) => Some(&i.attrs[..]),\n+            Some(NodeKind::ForeignItem(fi)) => Some(&fi.attrs[..]),\n+            Some(NodeKind::TraitItem(ref ti)) => Some(&ti.attrs[..]),\n+            Some(NodeKind::ImplItem(ref ii)) => Some(&ii.attrs[..]),\n+            Some(NodeKind::Variant(ref v)) => Some(&v.node.attrs[..]),\n+            Some(NodeKind::Field(ref f)) => Some(&f.attrs[..]),\n+            Some(NodeKind::Expr(ref e)) => Some(&*e.attrs),\n+            Some(NodeKind::Stmt(ref s)) => Some(s.node.attrs()),\n+            Some(NodeKind::GenericParam(param)) => Some(&param.attrs[..]),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition.\n-            Some(NodeStructCtor(_)) => {\n+            Some(NodeKind::StructCtor(_)) => {\n                 return self.attrs(self.get_parent(id));\n             }\n             _ => None\n@@ -1117,7 +1116,7 @@ impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n         fn find_first_mod_parent<'a>(map: &'a Map, mut id: NodeId) -> Option<(NodeId, Name)> {\n             loop {\n                 match map.find(id)? {\n-                    NodeItem(item) if item_is_mod(&item) =>\n+                    NodeKind::Item(item) if item_is_mod(&item) =>\n                         return Some((id, item.name)),\n                     _ => {}\n                 }\n@@ -1253,21 +1252,21 @@ impl<'hir> print::PpAnn for Map<'hir> {\n }\n \n impl<'a> print::State<'a> {\n-    pub fn print_node(&mut self, node: Node) -> io::Result<()> {\n+    pub fn print_node(&mut self, node: NodeKind) -> io::Result<()> {\n         match node {\n-            NodeItem(a)         => self.print_item(&a),\n-            NodeForeignItem(a)  => self.print_foreign_item(&a),\n-            NodeTraitItem(a)    => self.print_trait_item(a),\n-            NodeImplItem(a)     => self.print_impl_item(a),\n-            NodeVariant(a)      => self.print_variant(&a),\n-            NodeAnonConst(a)    => self.print_anon_const(&a),\n-            NodeExpr(a)         => self.print_expr(&a),\n-            NodeStmt(a)         => self.print_stmt(&a),\n-            NodeTy(a)           => self.print_type(&a),\n-            NodeTraitRef(a)     => self.print_trait_ref(&a),\n-            NodeBinding(a)       |\n-            NodePat(a)          => self.print_pat(&a),\n-            NodeBlock(a)        => {\n+            NodeKind::Item(a)         => self.print_item(&a),\n+            NodeKind::ForeignItem(a)  => self.print_foreign_item(&a),\n+            NodeKind::TraitItem(a)    => self.print_trait_item(a),\n+            NodeKind::ImplItem(a)     => self.print_impl_item(a),\n+            NodeKind::Variant(a)      => self.print_variant(&a),\n+            NodeKind::AnonConst(a)    => self.print_anon_const(&a),\n+            NodeKind::Expr(a)         => self.print_expr(&a),\n+            NodeKind::Stmt(a)         => self.print_stmt(&a),\n+            NodeKind::Ty(a)           => self.print_type(&a),\n+            NodeKind::TraitRef(a)     => self.print_trait_ref(&a),\n+            NodeKind::Binding(a)       |\n+            NodeKind::Pat(a)          => self.print_pat(&a),\n+            NodeKind::Block(a)        => {\n                 use syntax::print::pprust::PrintState;\n \n                 // containing cbox, will be closed by print-block at }\n@@ -1276,16 +1275,16 @@ impl<'a> print::State<'a> {\n                 self.ibox(0)?;\n                 self.print_block(&a)\n             }\n-            NodeLifetime(a)     => self.print_lifetime(&a),\n-            NodeVisibility(a)   => self.print_visibility(&a),\n-            NodeGenericParam(_) => bug!(\"cannot print NodeGenericParam\"),\n-            NodeField(_)        => bug!(\"cannot print StructField\"),\n+            NodeKind::Lifetime(a)     => self.print_lifetime(&a),\n+            NodeKind::Visibility(a)   => self.print_visibility(&a),\n+            NodeKind::GenericParam(_) => bug!(\"cannot print NodeKind::GenericParam\"),\n+            NodeKind::Field(_)        => bug!(\"cannot print StructField\"),\n             // these cases do not carry enough information in the\n             // hir_map to reconstruct their full structure for pretty\n             // printing.\n-            NodeStructCtor(_)   => bug!(\"cannot print isolated StructCtor\"),\n-            NodeLocal(a)        => self.print_local_decl(&a),\n-            NodeMacroDef(_)     => bug!(\"cannot print MacroDef\"),\n+            NodeKind::StructCtor(_)   => bug!(\"cannot print isolated StructCtor\"),\n+            NodeKind::Local(a)        => self.print_local_decl(&a),\n+            NodeKind::MacroDef(_)     => bug!(\"cannot print MacroDef\"),\n         }\n     }\n }\n@@ -1311,7 +1310,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n     };\n \n     match map.find(id) {\n-        Some(NodeItem(item)) => {\n+        Some(NodeKind::Item(item)) => {\n             let item_str = match item.node {\n                 ItemKind::ExternCrate(..) => \"extern crate\",\n                 ItemKind::Use(..) => \"use\",\n@@ -1332,10 +1331,10 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n             };\n             format!(\"{} {}{}\", item_str, path_str(), id_str)\n         }\n-        Some(NodeForeignItem(_)) => {\n+        Some(NodeKind::ForeignItem(_)) => {\n             format!(\"foreign item {}{}\", path_str(), id_str)\n         }\n-        Some(NodeImplItem(ii)) => {\n+        Some(NodeKind::ImplItem(ii)) => {\n             match ii.node {\n                 ImplItemKind::Const(..) => {\n                     format!(\"assoc const {} in {}{}\", ii.ident, path_str(), id_str)\n@@ -1351,7 +1350,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                 }\n             }\n         }\n-        Some(NodeTraitItem(ti)) => {\n+        Some(NodeKind::TraitItem(ti)) => {\n             let kind = match ti.node {\n                 TraitItemKind::Const(..) => \"assoc constant\",\n                 TraitItemKind::Method(..) => \"trait method\",\n@@ -1360,56 +1359,56 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n \n             format!(\"{} {} in {}{}\", kind, ti.ident, path_str(), id_str)\n         }\n-        Some(NodeVariant(ref variant)) => {\n+        Some(NodeKind::Variant(ref variant)) => {\n             format!(\"variant {} in {}{}\",\n                     variant.node.name,\n                     path_str(), id_str)\n         }\n-        Some(NodeField(ref field)) => {\n+        Some(NodeKind::Field(ref field)) => {\n             format!(\"field {} in {}{}\",\n                     field.ident,\n                     path_str(), id_str)\n         }\n-        Some(NodeAnonConst(_)) => {\n+        Some(NodeKind::AnonConst(_)) => {\n             format!(\"const {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeExpr(_)) => {\n+        Some(NodeKind::Expr(_)) => {\n             format!(\"expr {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeStmt(_)) => {\n+        Some(NodeKind::Stmt(_)) => {\n             format!(\"stmt {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeTy(_)) => {\n+        Some(NodeKind::Ty(_)) => {\n             format!(\"type {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeTraitRef(_)) => {\n+        Some(NodeKind::TraitRef(_)) => {\n             format!(\"trait_ref {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeBinding(_)) => {\n+        Some(NodeKind::Binding(_)) => {\n             format!(\"local {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodePat(_)) => {\n+        Some(NodeKind::Pat(_)) => {\n             format!(\"pat {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeBlock(_)) => {\n+        Some(NodeKind::Block(_)) => {\n             format!(\"block {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeLocal(_)) => {\n+        Some(NodeKind::Local(_)) => {\n             format!(\"local {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeStructCtor(_)) => {\n+        Some(NodeKind::StructCtor(_)) => {\n             format!(\"struct_ctor {}{}\", path_str(), id_str)\n         }\n-        Some(NodeLifetime(_)) => {\n+        Some(NodeKind::Lifetime(_)) => {\n             format!(\"lifetime {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeGenericParam(ref param)) => {\n+        Some(NodeKind::GenericParam(ref param)) => {\n             format!(\"generic_param {:?}{}\", param, id_str)\n         }\n-        Some(NodeVisibility(ref vis)) => {\n+        Some(NodeKind::Visibility(ref vis)) => {\n             format!(\"visibility {:?}{}\", vis, id_str)\n         }\n-        Some(NodeMacroDef(_)) => {\n+        Some(NodeKind::MacroDef(_)) => {\n             format!(\"macro {}{}\",  path_str(), id_str)\n         }\n         None => {"}, {"sha": "7fc986ab08372b5a53bbd3ad836e4140caae34a1", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -697,7 +697,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                             parent_def_id == tcx.hir.local_def_id(anon_parent_node_id)\n                         };\n                         let in_definition_scope = match tcx.hir.find(anon_node_id) {\n-                            Some(hir::map::NodeItem(item)) => match item.node {\n+                            Some(hir::map::NodeKind::Item(item)) => match item.node {\n                                 // impl trait\n                                 hir::ItemKind::Existential(hir::ExistTy {\n                                     impl_trait_fn: Some(parent),\n@@ -714,7 +714,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                                 ),\n                                 _ => def_scope_default(),\n                             },\n-                            Some(hir::map::NodeImplItem(item)) => match item.node {\n+                            Some(hir::map::NodeKind::ImplItem(item)) => match item.node {\n                                 hir::ImplItemKind::Existential(_) => may_define_existential_type(\n                                     tcx,\n                                     self.parent_def_id,"}, {"sha": "5bb8f75475ab311ab491b72727e9c4ae66c20161", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -100,8 +100,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 };\n                 let span = scope.span(self, region_scope_tree);\n                 let tag = match self.hir.find(scope.node_id(self, region_scope_tree)) {\n-                    Some(hir_map::NodeBlock(_)) => \"block\",\n-                    Some(hir_map::NodeExpr(expr)) => match expr.node {\n+                    Some(hir_map::NodeKind::Block(_)) => \"block\",\n+                    Some(hir_map::NodeKind::Expr(expr)) => match expr.node {\n                         hir::ExprKind::Call(..) => \"call\",\n                         hir::ExprKind::MethodCall(..) => \"method call\",\n                         hir::ExprKind::Match(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n@@ -110,10 +110,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         hir::ExprKind::Match(..) => \"match\",\n                         _ => \"expression\",\n                     },\n-                    Some(hir_map::NodeStmt(_)) => \"statement\",\n-                    Some(hir_map::NodeItem(it)) => Self::item_scope_tag(&it),\n-                    Some(hir_map::NodeTraitItem(it)) => Self::trait_item_scope_tag(&it),\n-                    Some(hir_map::NodeImplItem(it)) => Self::impl_item_scope_tag(&it),\n+                    Some(hir_map::NodeKind::Stmt(_)) => \"statement\",\n+                    Some(hir_map::NodeKind::Item(it)) => Self::item_scope_tag(&it),\n+                    Some(hir_map::NodeKind::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n+                    Some(hir_map::NodeKind::ImplItem(it)) => Self::impl_item_scope_tag(&it),\n                     Some(_) | None => {\n                         err.span_note(span, &unknown_scope());\n                         return;\n@@ -194,10 +194,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let scope = region.free_region_binding_scope(self);\n         let node = self.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n         let tag = match self.hir.find(node) {\n-            Some(hir_map::NodeBlock(_)) | Some(hir_map::NodeExpr(_)) => \"body\",\n-            Some(hir_map::NodeItem(it)) => Self::item_scope_tag(&it),\n-            Some(hir_map::NodeTraitItem(it)) => Self::trait_item_scope_tag(&it),\n-            Some(hir_map::NodeImplItem(it)) => Self::impl_item_scope_tag(&it),\n+            Some(hir_map::NodeKind::Block(_)) | Some(hir_map::NodeKind::Expr(_)) => \"body\",\n+            Some(hir_map::NodeKind::Item(it)) => Self::item_scope_tag(&it),\n+            Some(hir_map::NodeKind::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n+            Some(hir_map::NodeKind::ImplItem(it)) => Self::impl_item_scope_tag(&it),\n             _ => unreachable!()\n         };\n         let (prefix, span) = match *region {\n@@ -1127,7 +1127,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                             // instead we suggest `T: 'a + 'b` in that case.\n                             let mut has_bounds = false;\n-                            if let hir_map::NodeGenericParam(ref param) = hir.get(id) {\n+                            if let hir_map::NodeKind::GenericParam(ref param) = hir.get(id) {\n                                 has_bounds = !param.bounds.is_empty();\n                             }\n                             let sp = hir.span(id);"}, {"sha": "11aaf3f50fed166984b79dac5016c9aa6b7cbbe5", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -40,15 +40,15 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             let def_id = anon_reg.def_id;\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                 let fndecl = match self.tcx.hir.get(node_id) {\n-                    hir_map::NodeItem(&hir::Item {\n+                    hir_map::NodeKind::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(ref fndecl, ..),\n                         ..\n                     }) => &fndecl,\n-                    hir_map::NodeTraitItem(&hir::TraitItem {\n+                    hir_map::NodeKind::TraitItem(&hir::TraitItem {\n                         node: hir::TraitItemKind::Method(ref m, ..),\n                         ..\n                     })\n-                    | hir_map::NodeImplItem(&hir::ImplItem {\n+                    | hir_map::NodeKind::ImplItem(&hir::ImplItem {\n                         node: hir::ImplItemKind::Method(ref m, ..),\n                         ..\n                     }) => &m.decl,"}, {"sha": "6a8fa8fe171db66c148930a20c8914cfe28a3f89", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -15,7 +15,7 @@ use infer::error_reporting::nice_region_error::NiceRegionError;\n use infer::SubregionOrigin;\n use ty::RegionKind;\n use hir::{Expr, ExprKind::Closure};\n-use hir::map::NodeExpr;\n+use hir::map::NodeKind;\n use util::common::ErrorReported;\n use infer::lexical_region_resolve::RegionResolutionError::SubSupConflict;\n \n@@ -59,7 +59,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                 let hir = &self.tcx.hir;\n                 if let Some(node_id) = hir.as_local_node_id(free_region.scope) {\n                     match hir.get(node_id) {\n-                        NodeExpr(Expr {\n+                        NodeKind::Expr(Expr {\n                             node: Closure(_, _, _, closure_span, None),\n                             ..\n                         }) => {"}, {"sha": "7072d445b3ebb6886d4bd4ac966ed860e1e94d7d", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -137,8 +137,8 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             .as_local_node_id(suitable_region_binding_scope)\n             .unwrap();\n         let is_impl_item = match self.tcx.hir.find(node_id) {\n-            Some(hir_map::NodeItem(..)) | Some(hir_map::NodeTraitItem(..)) => false,\n-            Some(hir_map::NodeImplItem(..)) => {\n+            Some(hir_map::NodeKind::Item(..)) | Some(hir_map::NodeKind::TraitItem(..)) => false,\n+            Some(hir_map::NodeKind::ImplItem(..)) => {\n                 self.is_bound_region_in_impl_item(suitable_region_binding_scope)\n             }\n             _ => return None,"}, {"sha": "b4f748fffd93eef17ea57a888f30cb1bb29c8328", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -29,16 +29,16 @@ use syntax::attr;\n use syntax_pos;\n \n // Any local node that may call something in its body block should be\n-// explored. For example, if it's a live NodeItem that is a\n+// explored. For example, if it's a live NodeKind::Item that is a\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             node_id: ast::NodeId) -> bool {\n     match tcx.hir.find(node_id) {\n-        Some(hir_map::NodeItem(..)) |\n-        Some(hir_map::NodeImplItem(..)) |\n-        Some(hir_map::NodeForeignItem(..)) |\n-        Some(hir_map::NodeTraitItem(..)) =>\n+        Some(hir_map::NodeKind::Item(..)) |\n+        Some(hir_map::NodeKind::ImplItem(..)) |\n+        Some(hir_map::NodeKind::ForeignItem(..)) |\n+        Some(hir_map::NodeKind::TraitItem(..)) =>\n             true,\n         _ =>\n             false\n@@ -145,13 +145,13 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_node(&mut self, node: &hir_map::Node<'tcx>) {\n+    fn visit_node(&mut self, node: &hir_map::NodeKind<'tcx>) {\n         let had_repr_c = self.repr_has_repr_c;\n         self.repr_has_repr_c = false;\n         let had_inherited_pub_visibility = self.inherited_pub_visibility;\n         self.inherited_pub_visibility = false;\n         match *node {\n-            hir_map::NodeItem(item) => {\n+            hir_map::NodeKind::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n@@ -173,13 +173,13 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                     _ => ()\n                 }\n             }\n-            hir_map::NodeTraitItem(trait_item) => {\n+            hir_map::NodeKind::TraitItem(trait_item) => {\n                 intravisit::walk_trait_item(self, trait_item);\n             }\n-            hir_map::NodeImplItem(impl_item) => {\n+            hir_map::NodeKind::ImplItem(impl_item) => {\n                 intravisit::walk_impl_item(self, impl_item);\n             }\n-            hir_map::NodeForeignItem(foreign_item) => {\n+            hir_map::NodeKind::ForeignItem(foreign_item) => {\n                 intravisit::walk_foreign_item(self, &foreign_item);\n             }\n             _ => ()"}, {"sha": "e79c47a9e4d295daaf0bc38d3e6955f2e53170d7", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -362,7 +362,7 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n     // Don't run unused pass for #[derive()]\n     if let FnKind::Method(..) = fk {\n         let parent = ir.tcx.hir.get_parent(id);\n-        if let Some(hir::map::Node::NodeItem(i)) = ir.tcx.hir.find(parent) {\n+        if let Some(hir::map::NodeKind::Item(i)) = ir.tcx.hir.find(parent) {\n             if i.attrs.iter().any(|a| a.check_name(\"automatically_derived\")) {\n                 return;\n             }"}, {"sha": "f8fcc5d2ab69f9db0e6affd9eebc7b08f43d3e22", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -343,7 +343,7 @@ impl MutabilityCategory {\n \n     fn from_local(tcx: TyCtxt, tables: &ty::TypeckTables, id: ast::NodeId) -> MutabilityCategory {\n         let ret = match tcx.hir.get(id) {\n-            hir_map::NodeBinding(p) => match p.node {\n+            hir_map::NodeKind::Binding(p) => match p.node {\n                 PatKind::Binding(..) => {\n                     let bm = *tables.pat_binding_modes()\n                                     .get(p.hir_id)"}, {"sha": "29c2c70a524d7dd73f1c2c3d6d396cf6175c89b9", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -64,7 +64,7 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n     if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_src) {\n         match tcx.hir.find(impl_node_id) {\n-            Some(hir_map::NodeItem(item)) =>\n+            Some(hir_map::NodeKind::Item(item)) =>\n                 item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n             Some(..) | None =>\n                 span_bug!(impl_item.span, \"impl did is not an item\")\n@@ -156,22 +156,22 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         };\n \n         match self.tcx.hir.find(node_id) {\n-            Some(hir_map::NodeItem(item)) => {\n+            Some(hir_map::NodeKind::Item(item)) => {\n                 match item.node {\n                     hir::ItemKind::Fn(..) =>\n                         item_might_be_inlined(self.tcx, &item, self.tcx.codegen_fn_attrs(def_id)),\n                     _ => false,\n                 }\n             }\n-            Some(hir_map::NodeTraitItem(trait_method)) => {\n+            Some(hir_map::NodeKind::TraitItem(trait_method)) => {\n                 match trait_method.node {\n                     hir::TraitItemKind::Const(_, ref default) => default.is_some(),\n                     hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => true,\n                     hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) |\n                     hir::TraitItemKind::Type(..) => false,\n                 }\n             }\n-            Some(hir_map::NodeImplItem(impl_item)) => {\n+            Some(hir_map::NodeKind::ImplItem(impl_item)) => {\n                 match impl_item.node {\n                     hir::ImplItemKind::Const(..) => true,\n                     hir::ImplItemKind::Method(..) => {\n@@ -219,12 +219,12 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         }\n     }\n \n-    fn propagate_node(&mut self, node: &hir_map::Node<'tcx>,\n+    fn propagate_node(&mut self, node: &hir_map::NodeKind<'tcx>,\n                       search_item: ast::NodeId) {\n         if !self.any_library {\n             // If we are building an executable, only explicitly extern\n             // types need to be exported.\n-            if let hir_map::NodeItem(item) = *node {\n+            if let hir_map::NodeKind::Item(item) = *node {\n                 let reachable = if let hir::ItemKind::Fn(_, header, ..) = item.node {\n                     header.abi != Abi::Rust\n                 } else {\n@@ -248,7 +248,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         }\n \n         match *node {\n-            hir_map::NodeItem(item) => {\n+            hir_map::NodeKind::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Fn(.., body) => {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ItemKind::GlobalAsm(..) => {}\n                 }\n             }\n-            hir_map::NodeTraitItem(trait_method) => {\n+            hir_map::NodeKind::TraitItem(trait_method) => {\n                 match trait_method.node {\n                     hir::TraitItemKind::Const(_, None) |\n                     hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) => {\n@@ -298,7 +298,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::TraitItemKind::Type(..) => {}\n                 }\n             }\n-            hir_map::NodeImplItem(impl_item) => {\n+            hir_map::NodeKind::ImplItem(impl_item) => {\n                 match impl_item.node {\n                     hir::ImplItemKind::Const(_, body) => {\n                         self.visit_nested_body(body);\n@@ -313,16 +313,16 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Type(_) => {}\n                 }\n             }\n-            hir_map::NodeExpr(&hir::Expr { node: hir::ExprKind::Closure(.., body, _, _), .. }) => {\n+            hir_map::NodeKind::Expr(&hir::Expr { node: hir::ExprKind::Closure(.., body, _, _), .. }) => {\n                 self.visit_nested_body(body);\n             }\n             // Nothing to recurse on for these\n-            hir_map::NodeForeignItem(_) |\n-            hir_map::NodeVariant(_) |\n-            hir_map::NodeStructCtor(_) |\n-            hir_map::NodeField(_) |\n-            hir_map::NodeTy(_) |\n-            hir_map::NodeMacroDef(_) => {}\n+            hir_map::NodeKind::ForeignItem(_) |\n+            hir_map::NodeKind::Variant(_) |\n+            hir_map::NodeKind::StructCtor(_) |\n+            hir_map::NodeKind::Field(_) |\n+            hir_map::NodeKind::Ty(_) |\n+            hir_map::NodeKind::MacroDef(_) => {}\n             _ => {\n                 bug!(\"found unexpected thingy in worklist: {}\",\n                      self.tcx.hir.node_to_string(search_item))"}, {"sha": "69464581f3a5296aa1438ad3f7e68e7e5c9eda1d", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -257,7 +257,7 @@ impl Scope {\n         }\n         let span = tcx.hir.span(node_id);\n         if let ScopeData::Remainder(r) = self.data() {\n-            if let hir::map::NodeBlock(ref blk) = tcx.hir.get(node_id) {\n+            if let hir::map::NodeKind::Block(ref blk) = tcx.hir.get(node_id) {\n                 // Want span for scope starting after the\n                 // indexed statement and ending at end of\n                 // `blk`; reuse span of `blk` and shift `lo`\n@@ -1420,8 +1420,8 @@ fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n         // record its impl/trait parent, as it can also have\n         // lifetime parameters free in this body.\n         match tcx.hir.get(id) {\n-            hir::map::NodeImplItem(_) |\n-            hir::map::NodeTraitItem(_) => {\n+            hir::map::NodeKind::ImplItem(_) |\n+            hir::map::NodeKind::TraitItem(_) => {\n                 visitor.scope_tree.root_parent = Some(tcx.hir.get_parent(id));\n             }\n             _ => {}"}, {"sha": "c83c459e253eaaba670eafd87148229e6a54bf96", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -1440,10 +1440,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                     debug!(\"node id first={:?}\", node_id);\n                     if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n-                        hir::map::NodeLifetime(hir_lifetime) => {\n+                        hir::map::NodeKind::Lifetime(hir_lifetime) => {\n                             Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.ident()))\n                         }\n-                        hir::map::NodeGenericParam(param) => {\n+                        hir::map::NodeKind::GenericParam(param) => {\n                             Some((param.id, param.span, param.name.ident()))\n                         }\n                         _ => None,\n@@ -1466,10 +1466,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 None => {\n                     let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                     if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n-                        hir::map::NodeLifetime(hir_lifetime) => {\n+                        hir::map::NodeKind::Lifetime(hir_lifetime) => {\n                             Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.ident()))\n                         }\n-                        hir::map::NodeGenericParam(param) => {\n+                        hir::map::NodeKind::GenericParam(param) => {\n                             Some((param.id, param.span, param.name.ident()))\n                         }\n                         _ => None,\n@@ -1643,15 +1643,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.tcx.hir.body_owner(body_id);\n                 match self.tcx.hir.get(fn_id) {\n-                    hir::map::NodeItem(&hir::Item {\n+                    hir::map::NodeKind::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(..),\n                         ..\n                     })\n-                    | hir::map::NodeTraitItem(&hir::TraitItem {\n+                    | hir::map::NodeKind::TraitItem(&hir::TraitItem {\n                         node: hir::TraitItemKind::Method(..),\n                         ..\n                     })\n-                    | hir::map::NodeImplItem(&hir::ImplItem {\n+                    | hir::map::NodeKind::ImplItem(&hir::ImplItem {\n                         node: hir::ImplItemKind::Method(..),\n                         ..\n                     }) => {\n@@ -1868,12 +1868,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let parent = self.tcx.hir.get_parent_node(output.id);\n         let body = match self.tcx.hir.get(parent) {\n             // `fn` definitions and methods.\n-            hir::map::NodeItem(&hir::Item {\n+            hir::map::NodeKind::Item(&hir::Item {\n                 node: hir::ItemKind::Fn(.., body),\n                 ..\n             }) => Some(body),\n \n-            hir::map::NodeTraitItem(&hir::TraitItem {\n+            hir::map::NodeKind::TraitItem(&hir::TraitItem {\n                 node: hir::TraitItemKind::Method(_, ref m),\n                 ..\n             }) => {\n@@ -1896,7 +1896,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n             }\n \n-            hir::map::NodeImplItem(&hir::ImplItem {\n+            hir::map::NodeKind::ImplItem(&hir::ImplItem {\n                 node: hir::ImplItemKind::Method(_, body),\n                 ..\n             }) => {\n@@ -1918,7 +1918,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             // Foreign functions, `fn(...) -> R` and `Trait(...) -> R` (both types and bounds).\n-            hir::map::NodeForeignItem(_) | hir::map::NodeTy(_) | hir::map::NodeTraitRef(_) => None,\n+            hir::map::NodeKind::ForeignItem(_) | hir::map::NodeKind::Ty(_) | hir::map::NodeKind::TraitRef(_) => None,\n             // Everything else (only closures?) doesn't\n             // actually enjoy elision in return types.\n             _ => {"}, {"sha": "8dcb87432e34ac018b5ab7082ae5af708cb897c3", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -864,7 +864,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                        err: &mut DiagnosticBuilder<'tcx>) {\n         if let &ObligationCauseCode::VariableType(node_id) = code {\n             let parent_node = self.tcx.hir.get_parent_node(node_id);\n-            if let Some(hir::map::NodeLocal(ref local)) = self.tcx.hir.find(parent_node) {\n+            if let Some(hir::map::NodeKind::Local(ref local)) = self.tcx.hir.find(parent_node) {\n                 if let Some(ref expr) = local.init {\n                     if let hir::ExprKind::Index(_, _) = expr.node {\n                         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n@@ -932,9 +932,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to\n     /// `report_arg_count_mismatch`.\n-    pub fn get_fn_like_arguments(&self, node: hir::map::Node) -> (Span, Vec<ArgKind>) {\n+    pub fn get_fn_like_arguments(&self, node: hir::map::NodeKind) -> (Span, Vec<ArgKind>) {\n         match node {\n-            hir::map::NodeExpr(&hir::Expr {\n+            hir::map::NodeKind::Expr(&hir::Expr {\n                 node: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => {\n@@ -961,17 +961,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     })\n                     .collect::<Vec<ArgKind>>())\n             }\n-            hir::map::NodeItem(&hir::Item {\n+            hir::map::NodeKind::Item(&hir::Item {\n                 span,\n                 node: hir::ItemKind::Fn(ref decl, ..),\n                 ..\n             }) |\n-            hir::map::NodeImplItem(&hir::ImplItem {\n+            hir::map::NodeKind::ImplItem(&hir::ImplItem {\n                 span,\n                 node: hir::ImplItemKind::Method(hir::MethodSig { ref decl, .. }, _),\n                 ..\n             }) |\n-            hir::map::NodeTraitItem(&hir::TraitItem {\n+            hir::map::NodeKind::TraitItem(&hir::TraitItem {\n                 span,\n                 node: hir::TraitItemKind::Method(hir::MethodSig { ref decl, .. }, _),\n                 ..\n@@ -987,7 +987,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     _ => ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n                 }).collect::<Vec<ArgKind>>())\n             }\n-            hir::map::NodeVariant(&hir::Variant {\n+            hir::map::NodeKind::Variant(&hir::Variant {\n                 span,\n                 node: hir::VariantKind {\n                     data: hir::VariantData::Tuple(ref fields, _),\n@@ -1000,7 +1000,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                      ArgKind::Arg(field.ident.to_string(), \"_\".to_string())\n                  }).collect::<Vec<_>>())\n             }\n-            hir::map::NodeStructCtor(ref variant_data) => {\n+            hir::map::NodeKind::StructCtor(ref variant_data) => {\n                 (self.tcx.sess.source_map().def_span(self.tcx.hir.span(variant_data.id())),\n                  variant_data.fields()\n                     .iter().map(|_| ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned()))"}, {"sha": "b572e9ccd686fabb8c9b076c0902acb2e9525bc4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -2478,7 +2478,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn expr_span(self, id: NodeId) -> Span {\n         match self.hir.find(id) {\n-            Some(hir_map::NodeExpr(e)) => {\n+            Some(hir_map::NodeKind::Expr(e)) => {\n                 e.span\n             }\n             Some(f) => {\n@@ -2505,7 +2505,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn opt_associated_item(self, def_id: DefId) -> Option<AssociatedItem> {\n         let is_associated_item = if let Some(node_id) = self.hir.as_local_node_id(def_id) {\n             match self.hir.get(node_id) {\n-                hir_map::NodeTraitItem(_) | hir_map::NodeImplItem(_) => true,\n+                hir_map::NodeKind::TraitItem(_) | hir_map::NodeKind::ImplItem(_) => true,\n                 _ => false,\n             }\n         } else {\n@@ -2895,7 +2895,7 @@ fn trait_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option\n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition\n pub fn is_impl_trait_defn(tcx: TyCtxt, def_id: DefId) -> Option<DefId> {\n     if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-        if let hir::map::NodeItem(item) = tcx.hir.get(node_id) {\n+        if let hir::map::NodeKind::Item(item) = tcx.hir.get(node_id) {\n             if let hir::ItemKind::Existential(ref exist_ty) = item.node {\n                 return exist_ty.impl_trait_fn;\n             }"}, {"sha": "cc662d30f28beef0afcb515bcbd1d175aad0cd91", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -12,7 +12,7 @@\n \n use hir::def::Def;\n use hir::def_id::DefId;\n-use hir::map::{DefPathData, Node};\n+use hir::map::{DefPathData, NodeKind};\n use hir;\n use ich::NodeIdHashingMode;\n use traits::{self, ObligationCause};\n@@ -604,10 +604,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn is_static(&self, def_id: DefId) -> Option<hir::Mutability> {\n         if let Some(node) = self.hir.get_if_local(def_id) {\n             match node {\n-                Node::NodeItem(&hir::Item {\n+                NodeKind::Item(&hir::Item {\n                     node: hir::ItemKind::Static(_, mutbl, _), ..\n                 }) => Some(mutbl),\n-                Node::NodeForeignItem(&hir::ForeignItem {\n+                NodeKind::ForeignItem(&hir::ForeignItem {\n                     node: hir::ForeignItemKind::Static(_, is_mutbl), ..\n                 }) =>\n                     Some(if is_mutbl {"}, {"sha": "64ea80204be6eca7e02385a32591db5ff6f21218", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -201,7 +201,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n     let node_id = bccx.tcx.hir.as_local_node_id(def_id).unwrap();\n     let movable_generator = !match bccx.tcx.hir.get(node_id) {\n-        hir::map::Node::NodeExpr(&hir::Expr {\n+        hir::map::NodeKind::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n         }) => true,"}, {"sha": "e687e445604fc3d319515ac73a2fb5be3aa6fad4", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -24,7 +24,7 @@ use std::rc::Rc;\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir::*;\n-use rustc::hir::map::Node::*;\n+use rustc::hir::map::NodeKind;\n \n struct GatherMoveInfo<'c, 'tcx: 'c> {\n     id: hir::ItemLocalId,\n@@ -60,15 +60,15 @@ fn get_pattern_source<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &Pat) -> Patte\n     let parent = tcx.hir.get_parent_node(pat.id);\n \n     match tcx.hir.get(parent) {\n-        NodeExpr(ref e) => {\n+        NodeKind::Expr(ref e) => {\n             // the enclosing expression must be a `match` or something else\n             assert!(match e.node {\n                         ExprKind::Match(..) => true,\n                         _ => return PatternSource::Other,\n                     });\n             PatternSource::MatchExpr(e)\n         }\n-        NodeLocal(local) => PatternSource::LetDecl(local),\n+        NodeKind::Local(local) => PatternSource::LetDecl(local),\n         _ => return PatternSource::Other,\n \n     }"}, {"sha": "8fd56c07fcc8d9cd845eef82d5efa5211b555057", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -95,8 +95,8 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n     let owner_id = tcx.hir.as_local_node_id(owner_def_id).unwrap();\n \n     match tcx.hir.get(owner_id) {\n-        hir_map::NodeStructCtor(_) |\n-        hir_map::NodeVariant(_) => {\n+        hir_map::NodeKind::StructCtor(_) |\n+        hir_map::NodeKind::Variant(_) => {\n             // We get invoked with anything that has MIR, but some of\n             // those things (notably the synthesized constructors from\n             // tuple structs/variants) do not have an associated body\n@@ -419,7 +419,7 @@ fn closure_to_block(closure_id: LocalDefId,\n                     tcx: TyCtxt) -> ast::NodeId {\n     let closure_id = tcx.hir.local_def_id_to_node_id(closure_id);\n     match tcx.hir.get(closure_id) {\n-        hir_map::NodeExpr(expr) => match expr.node {\n+        hir_map::NodeKind::Expr(expr) => match expr.node {\n             hir::ExprKind::Closure(.., body_id, _, _) => {\n                 body_id.node_id\n             }\n@@ -908,7 +908,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     let node =  self.tcx.hir.get(node_id);\n \n                     // This pattern probably always matches.\n-                    if let hir_map::NodeExpr(\n+                    if let hir_map::NodeKind::Expr(\n                         hir::Expr { node: hir::ExprKind::Index(lhs, _), ..}\n                     ) = node {\n                         let ty = self.tables.expr_ty(lhs);\n@@ -1032,7 +1032,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 if let ty::ReScope(scope) = *super_scope {\n                     let node_id = scope.node_id(self.tcx, &self.region_scope_tree);\n                     match self.tcx.hir.find(node_id) {\n-                        Some(hir_map::NodeStmt(_)) => {\n+                        Some(hir_map::NodeKind::Stmt(_)) => {\n                             if *sub_scope != ty::ReStatic {\n                                 db.note(\"consider using a `let` binding to increase its lifetime\");\n                             }\n@@ -1183,7 +1183,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n     fn local_binding_mode(&self, node_id: ast::NodeId) -> ty::BindingMode {\n         let pat = match self.tcx.hir.get(node_id) {\n-            hir_map::Node::NodeBinding(pat) => pat,\n+            hir_map::NodeKind::Binding(pat) => pat,\n             node => bug!(\"bad node for local: {:?}\", node)\n         };\n \n@@ -1259,7 +1259,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     None => return\n                 };\n \n-                if let hir_map::Node::NodeField(ref field) = self.tcx.hir.get(node_id) {\n+                if let hir_map::NodeKind::Field(ref field) = self.tcx.hir.get(node_id) {\n                     if let Some(msg) = self.suggest_mut_for_immutable(&field.ty, false) {\n                         db.span_label(field.ty.span, msg);\n                     }"}, {"sha": "d59cf266ee60f33be1191b87eadcb9882e131e5b", "filename": "src/librustc_codegen_llvm/back/symbol_export.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -94,7 +94,7 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // As a result, if this id is an FFI item (foreign item) then we only\n             // let it through if it's included statically.\n             match tcx.hir.get(node_id) {\n-                hir::map::NodeForeignItem(..) => {\n+                hir::map::NodeKind::ForeignItem(..) => {\n                     let def_id = tcx.hir.local_def_id(node_id);\n                     if tcx.is_statically_included_foreign_item(def_id) {\n                         Some(def_id)\n@@ -104,14 +104,14 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n \n                 // Only consider nodes that actually have exported symbols.\n-                hir::map::NodeItem(&hir::Item {\n+                hir::map::NodeKind::Item(&hir::Item {\n                     node: hir::ItemKind::Static(..),\n                     ..\n                 }) |\n-                hir::map::NodeItem(&hir::Item {\n+                hir::map::NodeKind::Item(&hir::Item {\n                     node: hir::ItemKind::Fn(..), ..\n                 }) |\n-                hir::map::NodeImplItem(&hir::ImplItem {\n+                hir::map::NodeKind::ImplItem(&hir::ImplItem {\n                     node: hir::ImplItemKind::Method(..),\n                     ..\n                 }) => {"}, {"sha": "b8b5aee510f4a6573f030e5c6be5736928189ead", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -135,7 +135,7 @@ pub fn get_static(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll Value {\n \n         let llty = cx.layout_of(ty).llvm_type(cx);\n         let (g, attrs) = match cx.tcx.hir.get(id) {\n-            hir_map::NodeItem(&hir::Item {\n+            hir_map::NodeKind::Item(&hir::Item {\n                 ref attrs, span, node: hir::ItemKind::Static(..), ..\n             }) => {\n                 if declare::get_declared_value(cx, &sym[..]).is_some() {\n@@ -153,7 +153,7 @@ pub fn get_static(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll Value {\n                 (g, attrs)\n             }\n \n-            hir_map::NodeForeignItem(&hir::ForeignItem {\n+            hir_map::NodeKind::ForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemKind::Static(..), ..\n             }) => {\n                 let fn_attrs = cx.tcx.codegen_fn_attrs(def_id);"}, {"sha": "a03ca2d6218b55d72a46ce10776d8fcedc2ea108", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -261,7 +261,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n     // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n     let is_foreign = if let Some(id) = node_id {\n         match tcx.hir.get(id) {\n-            hir_map::NodeForeignItem(_) => true,\n+            hir_map::NodeKind::ForeignItem(_) => true,\n             _ => false,\n         }\n     } else {"}, {"sha": "415958a3a7988acf92ba3cd35598b57d6d672949", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -30,7 +30,7 @@ use std::vec::Vec;\n use rustc::dep_graph::{DepNode, label_strs};\n use rustc::hir;\n use rustc::hir::{ItemKind as HirItem, ImplItemKind, TraitItemKind};\n-use rustc::hir::map::Node as HirNode;\n+use rustc::hir::map::NodeKind as HirNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit;\n@@ -336,7 +336,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n     fn auto_labels(&mut self, item_id: ast::NodeId, attr: &Attribute) -> (&'static str, Labels) {\n         let node = self.tcx.hir.get(item_id);\n         let (name, labels) = match node {\n-            HirNode::NodeItem(item) => {\n+            HirNode::Item(item) => {\n                 match item.node {\n                     // note: these are in the same order as hir::Item_;\n                     // FIXME(michaelwoerister): do commented out ones\n@@ -399,22 +399,22 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n                     _ => self.tcx.sess.span_fatal(\n                         attr.span,\n                         &format!(\n-                            \"clean/dirty auto-assertions not yet defined for NodeItem.node={:?}\",\n+                            \"clean/dirty auto-assertions not yet defined for NodeKind::Item.node={:?}\",\n                             item.node\n                         )\n                     ),\n                 }\n             },\n-            HirNode::NodeTraitItem(item) => {\n+            HirNode::TraitItem(item) => {\n                 match item.node {\n-                    TraitItemKind::Method(..) => (\"NodeTraitItem\", LABELS_FN_IN_TRAIT),\n+                    TraitItemKind::Method(..) => (\"NodeKind::TraitItem\", LABELS_FN_IN_TRAIT),\n                     TraitItemKind::Const(..) => (\"NodeTraitConst\", LABELS_CONST_IN_TRAIT),\n                     TraitItemKind::Type(..) => (\"NodeTraitType\", LABELS_CONST_IN_TRAIT),\n                 }\n             },\n-            HirNode::NodeImplItem(item) => {\n+            HirNode::ImplItem(item) => {\n                 match item.node {\n-                    ImplItemKind::Method(..) => (\"NodeImplItem\", LABELS_FN_IN_IMPL),\n+                    ImplItemKind::Method(..) => (\"NodeKind::ImplItem\", LABELS_FN_IN_IMPL),\n                     ImplItemKind::Const(..) => (\"NodeImplConst\", LABELS_CONST_IN_IMPL),\n                     ImplItemKind::Type(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),\n                     ImplItemKind::Existential(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),"}, {"sha": "a0d7206e4c9853d5a7de86f830faa5d6fc6c2f7c", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -427,7 +427,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 let real_trait = trait_ref.path.def.def_id();\n                 if let Some(node_id) = cx.tcx.hir.as_local_node_id(real_trait) {\n                     match cx.tcx.hir.find(node_id) {\n-                        Some(hir_map::NodeItem(item)) => {\n+                        Some(hir_map::NodeKind::Item(item)) => {\n                             if let hir::VisibilityKind::Inherited = item.vis.node {\n                                 for impl_item_ref in impl_item_refs {\n                                     self.private_traits.insert(impl_item_ref.id.node_id);\n@@ -981,7 +981,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n \n         fn expr_refers_to_this_fn(cx: &LateContext, fn_id: ast::NodeId, id: ast::NodeId) -> bool {\n             match cx.tcx.hir.get(id) {\n-                hir_map::NodeExpr(&hir::Expr { node: hir::ExprKind::Call(ref callee, _), .. }) => {\n+                hir_map::NodeKind::Expr(&hir::Expr { node: hir::ExprKind::Call(ref callee, _), .. }) => {\n                     let def = if let hir::ExprKind::Path(ref qpath) = callee.node {\n                         cx.tables.qpath_def(qpath, callee.hir_id)\n                     } else {\n@@ -1004,7 +1004,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             use rustc::ty::adjustment::*;\n \n             // Ignore non-expressions.\n-            let expr = if let hir_map::NodeExpr(e) = cx.tcx.hir.get(id) {\n+            let expr = if let hir_map::NodeKind::Expr(e) = cx.tcx.hir.get(id) {\n                 e\n             } else {\n                 return false;\n@@ -1864,7 +1864,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestFunctions {\n                     if attr.name() == \"test\" {\n                         let parent = cx.tcx.hir.get_parent(it.id);\n                         match cx.tcx.hir.find(parent) {\n-                            Some(hir_map::NodeItem(hir::Item {node: hir::ItemKind::Mod(_), ..})) |\n+                            Some(hir_map::NodeKind::Item(hir::Item {node: hir::ItemKind::Mod(_), ..})) |\n                             None => {}\n                             _ => {\n                                 cx.struct_span_lint("}, {"sha": "138032a61327c462545edecc26ceb13bde545eca", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                         };\n                         if lit_val < min || lit_val > max {\n                             let parent_id = cx.tcx.hir.get_parent_node(e.id);\n-                            if let hir_map::NodeExpr(parent_expr) = cx.tcx.hir.get(parent_id) {\n+                            if let hir_map::NodeKind::Expr(parent_expr) = cx.tcx.hir.get(parent_id) {\n                                 if let hir::ExprKind::Cast(..) = parent_expr.node {\n                                     if let ty::Char = cx.tables.expr_ty(parent_expr).sty {\n                                         let mut err = cx.struct_span_lint("}, {"sha": "45435dbd7264cc5a708ac26da4a0b82023f24641", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -232,7 +232,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     ));\n \n     let movable_generator = match tcx.hir.get(id) {\n-        hir::map::Node::NodeExpr(&hir::Expr {\n+        hir::map::NodeKind::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n         }) => false,"}, {"sha": "739436eb910ea78267aef4901d45a86af7b5483f", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     .var_hir_id\n                     .assert_crate_local();\n                 let upvar_node_id = self.tcx.hir.hir_to_node_id(upvar_hir_id);\n-                if let Some(hir::map::NodeBinding(pat)) = self.tcx.hir.find(upvar_node_id) {\n+                if let Some(hir::map::NodeKind::Binding(pat)) = self.tcx.hir.find(upvar_node_id) {\n                     if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated,\n                         _,"}, {"sha": "4a1bcf16fd8e4d289e5998b49e59cc6edec85381", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -40,9 +40,9 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n \n     // Figure out what primary body this item has.\n     let body_id = match tcx.hir.get(id) {\n-        hir::map::NodeVariant(variant) =>\n+        hir::map::NodeKind::Variant(variant) =>\n             return create_constructor_shim(tcx, id, &variant.node.data),\n-        hir::map::NodeStructCtor(ctor) =>\n+        hir::map::NodeKind::StructCtor(ctor) =>\n             return create_constructor_shim(tcx, id, ctor),\n \n         _ => match tcx.hir.maybe_body_owned_by(id) {\n@@ -520,7 +520,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 by_ref,\n                 mutability: Mutability::Not,\n             };\n-            if let Some(hir::map::NodeBinding(pat)) = tcx.hir.find(var_id) {\n+            if let Some(hir::map::NodeKind::Binding(pat)) = tcx.hir.find(var_id) {\n                 if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n                     decl.debug_name = ident.name;\n "}, {"sha": "01828b42c32a93bed5906b50930d3ce1d990177c", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pattern<'tcx> {\n         let tcx = self.tcx.global_tcx();\n         let p = match tcx.hir.get(p.id) {\n-            hir::map::NodePat(p) | hir::map::NodeBinding(p) => p,\n+            hir::map::NodeKind::Pat(p) | hir::map::NodeKind::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node)\n         };\n         Pattern::from_hir(tcx,"}, {"sha": "7ee453683bd85e5c35b0a3d0b37d0f45172936a9", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -740,7 +740,7 @@ fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance:\n     };\n \n     return match tcx.hir.get_if_local(def_id) {\n-        Some(hir_map::NodeForeignItem(..)) => {\n+        Some(hir_map::NodeKind::ForeignItem(..)) => {\n             false // foreign items are linked against, not codegened.\n         }\n         Some(_) => true,"}, {"sha": "3fb8669a7cccadc37be6bf38d0d1899b24656341", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -85,7 +85,7 @@ fn place_context<'a, 'tcx, D>(\n fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) -> bool {\n     use rustc::hir::intravisit::{self, Visitor, FnKind};\n     use rustc::hir::map::blocks::FnLikeNode;\n-    use rustc::hir::map::Node;\n+    use rustc::hir::map::NodeKind;\n \n     /// Decide if this is an unsafe block\n     fn block_is_unsafe(block: &hir::Block) -> bool {\n@@ -142,13 +142,13 @@ fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) ->\n             }\n             // Check if this is an unsafe block, or an item\n             match node {\n-                Node::NodeExpr(&hir::Expr { node: hir::ExprKind::Block(ref block, _), ..}) => {\n+                NodeKind::Expr(&hir::Expr { node: hir::ExprKind::Block(ref block, _), ..}) => {\n                     if block_is_unsafe(&*block) {\n                         // Found an unsafe block, we can bail out here.\n                         return true;\n                     }\n                 }\n-                Node::NodeItem(..) => {\n+                NodeKind::Item(..) => {\n                     // No walking up beyond items.  This makes sure the loop always terminates.\n                     break;\n                 }"}, {"sha": "e13e81655126ae6f8665ab0f2e804736809067ed", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -407,7 +407,7 @@ fn is_enclosed(tcx: TyCtxt,\n     if parent_id != id {\n         if used_unsafe.contains(&parent_id) {\n             Some((\"block\".to_string(), parent_id))\n-        } else if let Some(hir::map::NodeItem(&hir::Item {\n+        } else if let Some(hir::map::NodeKind::Item(&hir::Item {\n             node: hir::ItemKind::Fn(_, header, _, _),\n             ..\n         })) = tcx.hir.find(parent_id) {"}, {"sha": "a0323a022e5df4db47a72acc55dc4205188d97a2", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -115,7 +115,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n                 if loop_id != ast::DUMMY_NODE_ID {\n                     match self.hir_map.find(loop_id).unwrap() {\n-                        hir::map::NodeBlock(_) => return,\n+                        hir::map::NodeKind::Block(_) => return,\n                         _=> (),\n                     }\n                 }\n@@ -158,7 +158,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n                 match label.target_id {\n                     Ok(loop_id) => {\n-                        if let hir::map::NodeBlock(block) = self.hir_map.find(loop_id).unwrap() {\n+                        if let hir::map::NodeKind::Block(block) = self.hir_map.find(loop_id).unwrap() {\n                             struct_span_err!(self.sess, e.span, E0696,\n                                             \"`continue` pointing to a labeled block\")\n                                 .span_label(e.span,"}, {"sha": "3a9ff9139bc19a213bc5ea3b906cfb46bd212616", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -659,17 +659,17 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n         match self.tcx.hir.as_local_node_id(did) {\n             Some(node_id) => {\n                 let vis = match self.tcx.hir.get(node_id) {\n-                    hir::map::NodeItem(item) => &item.vis,\n-                    hir::map::NodeForeignItem(foreign_item) => &foreign_item.vis,\n-                    hir::map::NodeImplItem(impl_item) => &impl_item.vis,\n-                    hir::map::NodeTraitItem(..) |\n-                    hir::map::NodeVariant(..) => {\n+                    hir::map::NodeKind::Item(item) => &item.vis,\n+                    hir::map::NodeKind::ForeignItem(foreign_item) => &foreign_item.vis,\n+                    hir::map::NodeKind::ImplItem(impl_item) => &impl_item.vis,\n+                    hir::map::NodeKind::TraitItem(..) |\n+                    hir::map::NodeKind::Variant(..) => {\n                         return self.def_id_visibility(self.tcx.hir.get_parent_did(node_id));\n                     }\n-                    hir::map::NodeStructCtor(vdata) => {\n+                    hir::map::NodeKind::StructCtor(vdata) => {\n                         let struct_node_id = self.tcx.hir.get_parent(node_id);\n                         let struct_vis = match self.tcx.hir.get(struct_node_id) {\n-                            hir::map::NodeItem(item) => &item.vis,\n+                            hir::map::NodeKind::Item(item) => &item.vis,\n                             node => bug!(\"unexpected node kind: {:?}\", node),\n                         };\n                         let mut ctor_vis\n@@ -1037,7 +1037,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             // .. and it corresponds to a private type in the AST (this returns\n             // None for type parameters)\n             match self.tcx.hir.find(node_id) {\n-                Some(hir::map::NodeItem(ref item)) => !item.vis.node.is_pub(),\n+                Some(hir::map::NodeKind::Item(ref item)) => !item.vis.node.is_pub(),\n                 Some(_) | None => false,\n             }\n         } else {\n@@ -1469,8 +1469,8 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n             // Non-local means public (private items can't leave their crate, modulo bugs)\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                 let hir_vis = match self.tcx.hir.find(node_id) {\n-                    Some(hir::map::NodeItem(item)) => &item.vis,\n-                    Some(hir::map::NodeForeignItem(item)) => &item.vis,\n+                    Some(hir::map::NodeKind::Item(item)) => &item.vis,\n+                    Some(hir::map::NodeKind::ForeignItem(item)) => &item.vis,\n                     _ => bug!(\"expected item of foreign item\"),\n                 };\n "}, {"sha": "76dbd8b2fdca76b7f25d2196ba75c509054ea79e", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -43,7 +43,7 @@ mod sig;\n \n use rustc::hir;\n use rustc::hir::def::Def as HirDef;\n-use rustc::hir::map::{Node, NodeTraitItem, NodeImplItem};\n+use rustc::hir::map::NodeKind;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::cstore::ExternCrate;\n use rustc::session::config::CrateType;\n@@ -420,7 +420,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let (qualname, parent_scope, decl_id, docs, attributes) =\n             match self.tcx.impl_of_method(self.tcx.hir.local_def_id(id)) {\n                 Some(impl_id) => match self.tcx.hir.get_if_local(impl_id) {\n-                    Some(Node::NodeItem(item)) => match item.node {\n+                    Some(NodeKind::Item(item)) => match item.node {\n                         hir::ItemKind::Impl(.., ref ty, _) => {\n                             let mut qualname = String::from(\"<\");\n                             qualname.push_str(&self.tcx.hir.node_to_pretty_string(ty.id));\n@@ -429,7 +429,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             let mut decl_id = None;\n                             let mut docs = String::new();\n                             let mut attrs = vec![];\n-                            if let Some(NodeImplItem(item)) = self.tcx.hir.find(id) {\n+                            if let Some(NodeKind::ImplItem(item)) = self.tcx.hir.find(id) {\n                                 docs = self.docs_for_attrs(&item.attrs);\n                                 attrs = item.attrs.to_vec();\n                             }\n@@ -471,7 +471,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         let mut docs = String::new();\n                         let mut attrs = vec![];\n \n-                        if let Some(NodeTraitItem(item)) = self.tcx.hir.find(id) {\n+                        if let Some(NodeKind::TraitItem(item)) = self.tcx.hir.find(id) {\n                             docs = self.docs_for_attrs(&item.attrs);\n                             attrs = item.attrs.to_vec();\n                         }\n@@ -541,7 +541,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         match expr.node {\n             ast::ExprKind::Field(ref sub_ex, ident) => {\n                 let hir_node = match self.tcx.hir.find(sub_ex.id) {\n-                    Some(Node::NodeExpr(expr)) => expr,\n+                    Some(NodeKind::Expr(expr)) => expr,\n                     _ => {\n                         debug!(\n                             \"Missing or weird node for sub-expression {} in {:?}\",\n@@ -628,45 +628,45 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_path_def(&self, id: NodeId) -> HirDef {\n         match self.tcx.hir.get(id) {\n-            Node::NodeTraitRef(tr) => tr.path.def,\n+            NodeKind::TraitRef(tr) => tr.path.def,\n \n-            Node::NodeItem(&hir::Item {\n+            NodeKind::Item(&hir::Item {\n                 node: hir::ItemKind::Use(ref path, _),\n                 ..\n             }) |\n-            Node::NodeVisibility(&Spanned {\n+            NodeKind::Visibility(&Spanned {\n                 node: hir::VisibilityKind::Restricted { ref path, .. }, .. }) => path.def,\n \n-            Node::NodeExpr(&hir::Expr {\n+            NodeKind::Expr(&hir::Expr {\n                 node: hir::ExprKind::Struct(ref qpath, ..),\n                 ..\n             }) |\n-            Node::NodeExpr(&hir::Expr {\n+            NodeKind::Expr(&hir::Expr {\n                 node: hir::ExprKind::Path(ref qpath),\n                 ..\n             }) |\n-            Node::NodePat(&hir::Pat {\n+            NodeKind::Pat(&hir::Pat {\n                 node: hir::PatKind::Path(ref qpath),\n                 ..\n             }) |\n-            Node::NodePat(&hir::Pat {\n+            NodeKind::Pat(&hir::Pat {\n                 node: hir::PatKind::Struct(ref qpath, ..),\n                 ..\n             }) |\n-            Node::NodePat(&hir::Pat {\n+            NodeKind::Pat(&hir::Pat {\n                 node: hir::PatKind::TupleStruct(ref qpath, ..),\n                 ..\n             }) => {\n                 let hir_id = self.tcx.hir.node_to_hir_id(id);\n                 self.tables.qpath_def(qpath, hir_id)\n             }\n \n-            Node::NodeBinding(&hir::Pat {\n+            NodeKind::Binding(&hir::Pat {\n                 node: hir::PatKind::Binding(_, canonical_id, ..),\n                 ..\n             }) => HirDef::Local(canonical_id),\n \n-            Node::NodeTy(ty) => if let hir::Ty {\n+            NodeKind::Ty(ty) => if let hir::Ty {\n                 node: hir::TyKind::Path(ref qpath),\n                 ..\n             } = *ty"}, {"sha": "afdbc91d253f3ce23495982d237e5b562569a7d9", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -17,7 +17,7 @@ use syntax::util::parser::PREC_POSTFIX;\n use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::def::Def;\n-use rustc::hir::map::{NodeItem, NodeExpr};\n+use rustc::hir::map::NodeKind;\n use rustc::hir::{Item, ItemKind, print};\n use rustc::ty::{self, Ty, AssociatedItem};\n use rustc::ty::adjustment::AllowTwoPhase;\n@@ -199,13 +199,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.node {\n             if let hir::def::Def::Local(id) = path.def {\n                 let parent = self.tcx.hir.get_parent_node(id);\n-                if let Some(NodeExpr(hir::Expr {\n+                if let Some(NodeKind::Expr(hir::Expr {\n                     id,\n                     node: hir::ExprKind::Closure(_, decl, ..),\n                     ..\n                 })) = self.tcx.hir.find(parent) {\n                     let parent = self.tcx.hir.get_parent_node(*id);\n-                    if let (Some(NodeExpr(hir::Expr {\n+                    if let (Some(NodeKind::Expr(hir::Expr {\n                         node: hir::ExprKind::MethodCall(path, span, expr),\n                         ..\n                     })), 1) = (self.tcx.hir.find(parent), decl.inputs.len()) {\n@@ -377,7 +377,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match self.tcx.hir.find(parent_id) {\n             Some(parent) => {\n                 // Shouldn't suggest `.into()` on `const`s.\n-                if let NodeItem(Item { node: ItemKind::Const(_, _), .. }) = parent {\n+                if let NodeKind::Item(Item { node: ItemKind::Const(_, _), .. }) = parent {\n                     // FIXME(estebank): modify once we decide to suggest `as` casts\n                     return false;\n                 }"}, {"sha": "34a641b7b7a96c71f5b30ff3563741e8d5330c25", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -275,7 +275,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                         );\n \n                                         match (filename, parent_node) {\n-                                            (FileName::Real(_), hir_map::NodeLocal(hir::Local {\n+                                            (FileName::Real(_), hir_map::NodeKind::Local(hir::Local {\n                                                 source: hir::LocalSource::Normal,\n                                                 ty,\n                                                 .."}, {"sha": "e9fc5810f72511f9c17ae51877c75d3abd40b5be", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -132,7 +132,7 @@ use syntax_pos::{self, BytePos, Span, MultiSpan};\n \n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::hir::map::Node;\n+use rustc::hir::map::NodeKind;\n use rustc::hir::{self, PatKind, ItemKind};\n use rustc::middle::lang_items;\n \n@@ -761,7 +761,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              -> Option<(hir::BodyId, Option<&'tcx hir::FnDecl>)>\n {\n     match tcx.hir.get(id) {\n-        hir::map::NodeItem(item) => {\n+        hir::map::NodeKind::Item(item) => {\n             match item.node {\n                 hir::ItemKind::Const(_, body) |\n                 hir::ItemKind::Static(_, _, body) =>\n@@ -772,7 +772,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     None,\n             }\n         }\n-        hir::map::NodeTraitItem(item) => {\n+        hir::map::NodeKind::TraitItem(item) => {\n             match item.node {\n                 hir::TraitItemKind::Const(_, Some(body)) =>\n                     Some((body, None)),\n@@ -782,7 +782,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     None,\n             }\n         }\n-        hir::map::NodeImplItem(item) => {\n+        hir::map::NodeKind::ImplItem(item) => {\n             match item.node {\n                 hir::ImplItemKind::Const(_, body) =>\n                     Some((body, None)),\n@@ -792,7 +792,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     None,\n             }\n         }\n-        hir::map::NodeAnonConst(constant) => Some((constant.body, None)),\n+        hir::map::NodeKind::AnonConst(constant) => Some((constant.body, None)),\n         _ => None,\n     }\n }\n@@ -1167,7 +1167,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                         );\n                     }\n \n-                    if let Node::NodeItem(item) = fcx.tcx.hir.get(fn_id) {\n+                    if let NodeKind::Item(item) = fcx.tcx.hir.get(fn_id) {\n                         if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n@@ -1214,7 +1214,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                         );\n                     }\n \n-                    if let Node::NodeItem(item) = fcx.tcx.hir.get(fn_id) {\n+                    if let NodeKind::Item(item) = fcx.tcx.hir.get(fn_id) {\n                         if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n@@ -4646,7 +4646,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some(fn_id) = self.tcx.hir.get_return_block(blk_id) {\n             let parent = self.tcx.hir.get(fn_id);\n \n-            if let Node::NodeItem(&hir::Item {\n+            if let NodeKind::Item(&hir::Item {\n                 name, node: hir::ItemKind::Fn(ref decl, ..), ..\n             }) = parent {\n                 decl.clone().and_then(|decl| {\n@@ -4655,15 +4655,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // but it will still present it as the reason for the expected type.\n                     Some((decl, name != Symbol::intern(\"main\")))\n                 })\n-            } else if let Node::NodeTraitItem(&hir::TraitItem {\n+            } else if let NodeKind::TraitItem(&hir::TraitItem {\n                 node: hir::TraitItemKind::Method(hir::MethodSig {\n                     ref decl, ..\n                 }, ..), ..\n             }) = parent {\n                 decl.clone().and_then(|decl| {\n                     Some((decl, true))\n                 })\n-            } else if let Node::NodeImplItem(&hir::ImplItem {\n+            } else if let NodeKind::ImplItem(&hir::ImplItem {\n                 node: hir::ImplItemKind::Method(hir::MethodSig {\n                     ref decl, ..\n                 }, ..), ..\n@@ -5174,7 +5174,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If our calling expression is indeed the function itself, we're good!\n         // If not, generate an error that this can only be called directly.\n         match self.tcx.hir.get(self.tcx.hir.get_parent_node(node_id)) {\n-            Node::NodeExpr(expr) => {\n+            NodeKind::Expr(expr) => {\n                 match expr.node {\n                     hir::ExprKind::Call(ref callee, ..) => {\n                         if callee.id == node_id {"}, {"sha": "640f2eee4eaed26d1e682ec68b9b6ad3d63299df", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -60,7 +60,7 @@ fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did:\n             // Destructors only work on nominal types.\n             if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_did) {\n                 match tcx.hir.find(impl_node_id) {\n-                    Some(hir_map::NodeItem(item)) => {\n+                    Some(hir_map::NodeKind::Item(item)) => {\n                         let span = match item.node {\n                             ItemKind::Impl(.., ref ty, _) => ty.span,\n                             _ => item.span,"}, {"sha": "c4ca106d7b8e7bc385d81130793dc898aaef35f3", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -272,11 +272,11 @@ fn type_param_predicates<'a, 'tcx>(\n \n     let item_node_id = tcx.hir.as_local_node_id(item_def_id).unwrap();\n     let ast_generics = match tcx.hir.get(item_node_id) {\n-        NodeTraitItem(item) => &item.generics,\n+        NodeKind::TraitItem(item) => &item.generics,\n \n-        NodeImplItem(item) => &item.generics,\n+        NodeKind::ImplItem(item) => &item.generics,\n \n-        NodeItem(item) => {\n+        NodeKind::Item(item) => {\n             match item.node {\n                 ItemKind::Fn(.., ref generics, _)\n                 | ItemKind::Impl(_, _, _, ref generics, ..)\n@@ -302,7 +302,7 @@ fn type_param_predicates<'a, 'tcx>(\n             }\n         }\n \n-        NodeForeignItem(item) => match item.node {\n+        NodeKind::ForeignItem(item) => match item.node {\n             ForeignItemKind::Fn(_, _, ref generics) => generics,\n             _ => return result,\n         },\n@@ -600,7 +600,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n \n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let item = match tcx.hir.get(node_id) {\n-        NodeItem(item) => item,\n+        NodeKind::Item(item) => item,\n         _ => bug!(),\n     };\n \n@@ -671,7 +671,7 @@ fn super_predicates_of<'a, 'tcx>(\n     let trait_node_id = tcx.hir.as_local_node_id(trait_def_id).unwrap();\n \n     let item = match tcx.hir.get(trait_node_id) {\n-        hir_map::NodeItem(item) => item,\n+        hir_map::NodeKind::Item(item) => item,\n         _ => bug!(\"trait_node_id {} is not an item\", trait_node_id),\n     };\n \n@@ -740,7 +740,7 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::\n \n fn has_late_bound_regions<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    node: hir_map::Node<'tcx>,\n+    node: hir_map::NodeKind<'tcx>,\n ) -> Option<Span> {\n     struct LateBoundRegionsDetector<'a, 'tcx: 'a> {\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -826,25 +826,25 @@ fn has_late_bound_regions<'a, 'tcx>(\n     }\n \n     match node {\n-        hir_map::NodeTraitItem(item) => match item.node {\n+        hir_map::NodeKind::TraitItem(item) => match item.node {\n             hir::TraitItemKind::Method(ref sig, _) => {\n                 has_late_bound_regions(tcx, &item.generics, &sig.decl)\n             }\n             _ => None,\n         },\n-        hir_map::NodeImplItem(item) => match item.node {\n+        hir_map::NodeKind::ImplItem(item) => match item.node {\n             hir::ImplItemKind::Method(ref sig, _) => {\n                 has_late_bound_regions(tcx, &item.generics, &sig.decl)\n             }\n             _ => None,\n         },\n-        hir_map::NodeForeignItem(item) => match item.node {\n+        hir_map::NodeKind::ForeignItem(item) => match item.node {\n             hir::ForeignItemKind::Fn(ref fn_decl, _, ref generics) => {\n                 has_late_bound_regions(tcx, generics, fn_decl)\n             }\n             _ => None,\n         },\n-        hir_map::NodeItem(item) => match item.node {\n+        hir_map::NodeKind::Item(item) => match item.node {\n             hir::ItemKind::Fn(ref fn_decl, .., ref generics, _) => {\n                 has_late_bound_regions(tcx, generics, fn_decl)\n             }\n@@ -862,15 +862,16 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n \n     let node = tcx.hir.get(node_id);\n     let parent_def_id = match node {\n-        NodeImplItem(_) | NodeTraitItem(_) | NodeVariant(_) | NodeStructCtor(_) | NodeField(_) => {\n+        NodeKind::ImplItem(_) | NodeKind::TraitItem(_) | NodeKind::Variant(_)\n+        | NodeKind::StructCtor(_) | NodeKind::Field(_) => {\n             let parent_id = tcx.hir.get_parent(node_id);\n             Some(tcx.hir.local_def_id(parent_id))\n         }\n-        NodeExpr(&hir::Expr {\n+        NodeKind::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(..),\n             ..\n         }) => Some(tcx.closure_base_def_id(def_id)),\n-        NodeItem(item) => match item.node {\n+        NodeKind::Item(item) => match item.node {\n             ItemKind::Existential(hir::ExistTy { impl_trait_fn, .. }) => impl_trait_fn,\n             _ => None,\n         },\n@@ -882,11 +883,11 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n \n     let no_generics = hir::Generics::empty();\n     let ast_generics = match node {\n-        NodeTraitItem(item) => &item.generics,\n+        NodeKind::TraitItem(item) => &item.generics,\n \n-        NodeImplItem(item) => &item.generics,\n+        NodeKind::ImplItem(item) => &item.generics,\n \n-        NodeItem(item) => {\n+        NodeKind::Item(item) => {\n             match item.node {\n                 ItemKind::Fn(.., ref generics, _) | ItemKind::Impl(_, _, _, ref generics, ..) => {\n                     generics\n@@ -929,7 +930,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n             }\n         }\n \n-        NodeForeignItem(item) => match item.node {\n+        NodeKind::ForeignItem(item) => match item.node {\n             ForeignItemKind::Static(..) => &no_generics,\n             ForeignItemKind::Fn(_, _, ref generics) => generics,\n             ForeignItemKind::Type => &no_generics,\n@@ -1024,7 +1025,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n     // provide junk type parameter defs - the only place that\n     // cares about anything but the length is instantiation,\n     // and we don't do that for closures.\n-    if let NodeExpr(&hir::Expr {\n+    if let NodeKind::Expr(&hir::Expr {\n         node: hir::ExprKind::Closure(.., gen),\n         ..\n     }) = node\n@@ -1102,7 +1103,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n     let icx = ItemCtxt::new(tcx, def_id);\n \n     match tcx.hir.get(node_id) {\n-        NodeTraitItem(item) => match item.node {\n+        NodeKind::TraitItem(item) => match item.node {\n             TraitItemKind::Method(..) => {\n                 let substs = Substs::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id, substs)\n@@ -1113,7 +1114,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             }\n         },\n \n-        NodeImplItem(item) => match item.node {\n+        NodeKind::ImplItem(item) => match item.node {\n             ImplItemKind::Method(..) => {\n                 let substs = Substs::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id, substs)\n@@ -1141,7 +1142,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             }\n         },\n \n-        NodeItem(item) => {\n+        NodeKind::Item(item) => {\n             match item.node {\n                 ItemKind::Static(ref t, ..)\n                 | ItemKind::Const(ref t, _)\n@@ -1199,7 +1200,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             }\n         }\n \n-        NodeForeignItem(foreign_item) => match foreign_item.node {\n+        NodeKind::ForeignItem(foreign_item) => match foreign_item.node {\n             ForeignItemKind::Fn(..) => {\n                 let substs = Substs::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id, substs)\n@@ -1208,8 +1209,8 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             ForeignItemKind::Type => tcx.mk_foreign(def_id),\n         },\n \n-        NodeStructCtor(&ref def)\n-        | NodeVariant(&Spanned {\n+        NodeKind::StructCtor(&ref def)\n+        | NodeKind::Variant(&Spanned {\n             node: hir::VariantKind { data: ref def, .. },\n             ..\n         }) => match *def {\n@@ -1222,9 +1223,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             }\n         },\n \n-        NodeField(field) => icx.to_ty(&field.ty),\n+        NodeKind::Field(field) => icx.to_ty(&field.ty),\n \n-        NodeExpr(&hir::Expr {\n+        NodeKind::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., gen),\n             ..\n         }) => {\n@@ -1240,24 +1241,24 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             tcx.mk_closure(def_id, substs)\n         }\n \n-        NodeAnonConst(_) => match tcx.hir.get(tcx.hir.get_parent_node(node_id)) {\n-            NodeTy(&hir::Ty {\n+        NodeKind::AnonConst(_) => match tcx.hir.get(tcx.hir.get_parent_node(node_id)) {\n+            NodeKind::Ty(&hir::Ty {\n                 node: hir::TyKind::Array(_, ref constant),\n                 ..\n             })\n-            | NodeTy(&hir::Ty {\n+            | NodeKind::Ty(&hir::Ty {\n                 node: hir::TyKind::Typeof(ref constant),\n                 ..\n             })\n-            | NodeExpr(&hir::Expr {\n+            | NodeKind::Expr(&hir::Expr {\n                 node: ExprKind::Repeat(_, ref constant),\n                 ..\n             }) if constant.id == node_id =>\n             {\n                 tcx.types.usize\n             }\n \n-            NodeVariant(&Spanned {\n+            NodeKind::Variant(&Spanned {\n                 node:\n                     VariantKind {\n                         disr_expr: Some(ref e),\n@@ -1277,7 +1278,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             }\n         },\n \n-        NodeGenericParam(param) => match param.kind {\n+        NodeKind::GenericParam(param) => match param.kind {\n             hir::GenericParamKind::Type {\n                 default: Some(ref ty),\n                 ..\n@@ -1375,9 +1376,9 @@ fn find_existential_constraints<'a, 'tcx>(\n     } else {\n         trace!(\"parent: {:?}\", tcx.hir.get(parent));\n         match tcx.hir.get(parent) {\n-            NodeItem(ref it) => intravisit::walk_item(&mut locator, it),\n-            NodeImplItem(ref it) => intravisit::walk_impl_item(&mut locator, it),\n-            NodeTraitItem(ref it) => intravisit::walk_trait_item(&mut locator, it),\n+            NodeKind::Item(ref it) => intravisit::walk_item(&mut locator, it),\n+            NodeKind::ImplItem(ref it) => intravisit::walk_impl_item(&mut locator, it),\n+            NodeKind::TraitItem(ref it) => intravisit::walk_trait_item(&mut locator, it),\n             other => bug!(\n                 \"{:?} is not a valid parent of an existential type item\",\n                 other\n@@ -1403,30 +1404,30 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig\n     let icx = ItemCtxt::new(tcx, def_id);\n \n     match tcx.hir.get(node_id) {\n-        NodeTraitItem(hir::TraitItem {\n+        NodeKind::TraitItem(hir::TraitItem {\n             node: TraitItemKind::Method(sig, _),\n             ..\n         })\n-        | NodeImplItem(hir::ImplItem {\n+        | NodeKind::ImplItem(hir::ImplItem {\n             node: ImplItemKind::Method(sig, _),\n             ..\n         }) => AstConv::ty_of_fn(&icx, sig.header.unsafety, sig.header.abi, &sig.decl),\n \n-        NodeItem(hir::Item {\n+        NodeKind::Item(hir::Item {\n             node: ItemKind::Fn(decl, header, _, _),\n             ..\n         }) => AstConv::ty_of_fn(&icx, header.unsafety, header.abi, decl),\n \n-        NodeForeignItem(&hir::ForeignItem {\n+        NodeKind::ForeignItem(&hir::ForeignItem {\n             node: ForeignItemKind::Fn(ref fn_decl, _, _),\n             ..\n         }) => {\n             let abi = tcx.hir.get_foreign_abi(node_id);\n             compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n         }\n \n-        NodeStructCtor(&VariantData::Tuple(ref fields, _))\n-        | NodeVariant(&Spanned {\n+        NodeKind::StructCtor(&VariantData::Tuple(ref fields, _))\n+        | NodeKind::Variant(&Spanned {\n             node:\n                 hir::VariantKind {\n                     data: VariantData::Tuple(ref fields, _),\n@@ -1447,7 +1448,7 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig\n             ))\n         }\n \n-        NodeExpr(&hir::Expr {\n+        NodeKind::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(..),\n             ..\n         }) => {\n@@ -1642,9 +1643,9 @@ fn explicit_predicates_of<'a, 'tcx>(\n     let mut predicates = vec![];\n \n     let ast_generics = match node {\n-        NodeTraitItem(item) => &item.generics,\n+        NodeKind::TraitItem(item) => &item.generics,\n \n-        NodeImplItem(item) => match item.node {\n+        NodeKind::ImplItem(item) => match item.node {\n             ImplItemKind::Existential(ref bounds) => {\n                 let substs = Substs::identity_for_item(tcx, def_id);\n                 let anon_ty = tcx.mk_anon(def_id, substs);\n@@ -1664,7 +1665,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n             _ => &item.generics,\n         },\n \n-        NodeItem(item) => {\n+        NodeKind::Item(item) => {\n             match item.node {\n                 ItemKind::Impl(_, _, defaultness, ref generics, ..) => {\n                     if defaultness.is_default() {\n@@ -1716,7 +1717,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n             }\n         }\n \n-        NodeForeignItem(item) => match item.node {\n+        NodeKind::ForeignItem(item) => match item.node {\n             ForeignItemKind::Static(..) => &no_generics,\n             ForeignItemKind::Fn(_, _, ref generics) => generics,\n             ForeignItemKind::Type => &no_generics,\n@@ -1876,7 +1877,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n     // before uses of `U`.  This avoids false ambiguity errors\n     // in trait checking. See `setup_constraining_predicates`\n     // for details.\n-    if let NodeItem(&Item {\n+    if let NodeKind::Item(&Item {\n         node: ItemKind::Impl(..),\n         ..\n     }) = node\n@@ -2026,7 +2027,7 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n \n fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n     match tcx.hir.get_if_local(def_id) {\n-        Some(hir_map::NodeForeignItem(..)) => true,\n+        Some(hir_map::NodeKind::ForeignItem(..)) => true,\n         Some(_) => false,\n         _ => bug!(\"is_foreign_item applied to non-local def-id {:?}\", def_id),\n     }"}, {"sha": "37515123c91138a826534b2af873b0d4e9d6b671", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -187,7 +187,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match main_t.sty {\n         ty::FnDef(..) => {\n             match tcx.hir.find(main_id) {\n-                Some(hir_map::NodeItem(it)) => {\n+                Some(hir_map::NodeKind::Item(it)) => {\n                     match it.node {\n                         hir::ItemKind::Fn(.., ref generics, _) => {\n                             let mut error = false;\n@@ -259,7 +259,7 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match start_t.sty {\n         ty::FnDef(..) => {\n             match tcx.hir.find(start_id) {\n-                Some(hir_map::NodeItem(it)) => {\n+                Some(hir_map::NodeKind::Item(it)) => {\n                     match it.node {\n                         hir::ItemKind::Fn(.., ref generics, _) => {\n                             let mut error = false;"}, {"sha": "06a37dfe9be45d808c589d7e4747e2f33118258c", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -70,7 +70,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n             .as_local_node_id(item_did)\n             .expect(\"expected local def-id\");\n         let item = match self.tcx.hir.get(node_id) {\n-            hir::map::NodeItem(item) => item,\n+            hir::map::NodeKind::Item(item) => item,\n             _ => bug!(),\n         };\n "}, {"sha": "56dd070cce137a3c1f21bceacb0971d5eff58107", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -40,7 +40,7 @@ fn inferred_outlives_of<'a, 'tcx>(\n         .expect(\"expected local def-id\");\n \n     match tcx.hir.get(id) {\n-        hir_map::NodeItem(item) => match item.node {\n+        hir_map::NodeKind::Item(item) => match item.node {\n             hir::ItemKind::Struct(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Union(..) => {\n                 let crate_map = tcx.inferred_outlives_crate(LOCAL_CRATE);\n "}, {"sha": "3b1b1c3ff05ebafc42463724ff164291549b7b4b", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -61,7 +61,7 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n         span_bug!(tcx.hir.span(id), \"asked to compute variance for wrong kind of item\")\n     };\n     match tcx.hir.get(id) {\n-        hir::map::NodeItem(item) => match item.node {\n+        hir::map::NodeKind::Item(item) => match item.node {\n             hir::ItemKind::Enum(..) |\n             hir::ItemKind::Struct(..) |\n             hir::ItemKind::Union(..) |\n@@ -70,25 +70,25 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n             _ => unsupported()\n         },\n \n-        hir::map::NodeTraitItem(item) => match item.node {\n+        hir::map::NodeKind::TraitItem(item) => match item.node {\n             hir::TraitItemKind::Method(..) => {}\n \n             _ => unsupported()\n         },\n \n-        hir::map::NodeImplItem(item) => match item.node {\n+        hir::map::NodeKind::ImplItem(item) => match item.node {\n             hir::ImplItemKind::Method(..) => {}\n \n             _ => unsupported()\n         },\n \n-        hir::map::NodeForeignItem(item) => match item.node {\n+        hir::map::NodeKind::ForeignItem(item) => match item.node {\n             hir::ForeignItemKind::Fn(..) => {}\n \n             _ => unsupported()\n         },\n \n-        hir::map::NodeVariant(_) | hir::map::NodeStructCtor(_) => {}\n+        hir::map::NodeKind::Variant(_) | hir::map::NodeKind::StructCtor(_) => {}\n \n         _ => unsupported()\n     }"}, {"sha": "a969449cb2781c8c09d8f55b1c653fe44caed2ea", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -295,7 +295,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n         if !self.view_item_stack.insert(def_node_id) { return false }\n \n         let ret = match tcx.hir.get(def_node_id) {\n-            hir_map::NodeItem(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n+            hir_map::NodeKind::Item(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for i in &m.item_ids {\n                     let i = self.cx.tcx.hir.expect_item(i.id);\n@@ -304,13 +304,13 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n                 self.inlining = prev;\n                 true\n             }\n-            hir_map::NodeItem(it) if !glob => {\n+            hir_map::NodeKind::Item(it) if !glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 self.visit_item(it, renamed, om);\n                 self.inlining = prev;\n                 true\n             }\n-            hir_map::NodeForeignItem(it) if !glob => {\n+            hir_map::NodeKind::ForeignItem(it) if !glob => {\n                 // generate a fresh `extern {}` block if we want to inline a foreign item.\n                 om.foreigns.push(hir::ForeignMod {\n                     abi: tcx.hir.get_foreign_abi(it.id),"}, {"sha": "a07a18908ebb028076b20bb436cee28402a9cf54", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc4b11004068dd5c971676e82ac0a13483d18b/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs?ref=befc4b11004068dd5c971676e82ac0a13483d18b", "patch": "@@ -58,7 +58,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingWhitelistedAttrPass {\n                 id: ast::NodeId) {\n \n         let item = match cx.tcx.hir.get(id) {\n-            hir_map::Node::NodeItem(item) => item,\n+            hir_map::NodeKind::Item(item) => item,\n             _ => cx.tcx.hir.expect_item(cx.tcx.hir.get_parent(id)),\n         };\n "}]}