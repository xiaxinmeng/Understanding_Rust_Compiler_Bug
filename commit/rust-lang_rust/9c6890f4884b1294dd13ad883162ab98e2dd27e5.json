{"sha": "9c6890f4884b1294dd13ad883162ab98e2dd27e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNjg5MGY0ODg0YjEyOTRkZDEzYWQ4ODMxNjJhYjk4ZTJkZDI3ZTU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-15T21:10:46Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-16T00:46:05Z"}, "message": "Convert more core types to camel case", "tree": {"sha": "37921bb9b69a5c37293653aad3d1324cb19f5771", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37921bb9b69a5c37293653aad3d1324cb19f5771"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c6890f4884b1294dd13ad883162ab98e2dd27e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c6890f4884b1294dd13ad883162ab98e2dd27e5", "html_url": "https://github.com/rust-lang/rust/commit/9c6890f4884b1294dd13ad883162ab98e2dd27e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c6890f4884b1294dd13ad883162ab98e2dd27e5/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af4361379543ce89866d087b45ffc419855e13fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/af4361379543ce89866d087b45ffc419855e13fd", "html_url": "https://github.com/rust-lang/rust/commit/af4361379543ce89866d087b45ffc419855e13fd"}], "stats": {"total": 805, "additions": 415, "deletions": 390}, "files": [{"sha": "54caad0682208ad1a44011e763cacfa5dffeccb1", "filename": "doc/tutorial.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -2975,9 +2975,9 @@ the string in response.  The child terminates when `0` is received.\n Here is the function that implements the child task:\n \n ~~~~\n-# import comm::{port, chan};\n-fn stringifier(from_parent: port<uint>,\n-               to_parent: chan<~str>) {\n+# import comm::{Port, port, Chan, chan};\n+fn stringifier(from_parent: Port<uint>,\n+               to_parent: Chan<~str>) {\n     let mut value: uint;\n     loop {\n         value = from_parent.recv();\n@@ -2999,9 +2999,9 @@ Here is the code for the parent task:\n \n ~~~~\n # import task::{spawn_conversation};\n-# import comm::{chan, port};\n-# fn stringifier(from_parent: comm::port<uint>,\n-#                to_parent: comm::chan<~str>) {\n+# import comm::{Chan, chan, Port, port};\n+# fn stringifier(from_parent: comm::Port<uint>,\n+#                to_parent: comm::Chan<~str>) {\n #     comm::send(to_parent, ~\"22\");\n #     comm::send(to_parent, ~\"23\");\n #     comm::send(to_parent, ~\"0\");"}, {"sha": "aab08ffffe78765588603bda608b9b57ef2a130b", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -62,12 +62,12 @@ fn run(lib_path: ~str,\n     writeclose(pipe_in.out, input);\n     let p = pipes::port_set();\n     let ch = p.chan();\n-    do task::spawn_sched(task::single_threaded) {\n+    do task::spawn_sched(task::SingleThreaded) {\n         let errput = readclose(pipe_err.in);\n         ch.send((2, errput));\n     }\n     let ch = p.chan();\n-    do task::spawn_sched(task::single_threaded) {\n+    do task::spawn_sched(task::SingleThreaded) {\n         let output = readclose(pipe_out.in);\n         ch.send((1, output));\n     }"}, {"sha": "6452027fa7c4ebf934e73b8874d39b5c8e4ee373", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -30,8 +30,8 @@\n import either::Either;\n import libc::size_t;\n \n-export port;\n-export chan;\n+export Port, port;\n+export Chan, chan;\n export send;\n export recv;\n export peek;\n@@ -48,8 +48,8 @@ export listen;\n  * transmitted. If a port value is copied, both copies refer to the same\n  * port.  Ports may be associated with multiple `chan`s.\n  */\n-enum port<T: send> {\n-    port_t(@port_ptr<T>)\n+enum Port<T: send> {\n+    Port_(@PortPtr<T>)\n }\n \n // It's critical that this only have one variant, so it has a record\n@@ -64,40 +64,40 @@ enum port<T: send> {\n  * data will be silently dropped.  Channels may be duplicated and\n  * themselves transmitted over other channels.\n  */\n-enum chan<T: send> {\n-    chan_t(port_id)\n+enum Chan<T: send> {\n+    Chan_(port_id)\n }\n \n /// Constructs a port\n-fn port<T: send>() -> port<T> {\n-    port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>() as size_t)))\n+fn port<T: send>() -> Port<T> {\n+    Port_(@PortPtr(rustrt::new_port(sys::size_of::<T>() as size_t)))\n }\n \n-impl<T: send> port<T> {\n+impl<T: send> Port<T> {\n \n-    fn chan() -> chan<T> { chan(self) }\n+    fn chan() -> Chan<T> { chan(self) }\n     fn send(+v: T) { self.chan().send(v) }\n     fn recv() -> T { recv(self) }\n     fn peek() -> bool { peek(self) }\n \n }\n \n-impl<T: send> chan<T> {\n+impl<T: send> Chan<T> {\n \n-    fn chan() -> chan<T> { self }\n+    fn chan() -> Chan<T> { self }\n     fn send(+v: T) { send(self, v) }\n     fn recv() -> T { recv_chan(self) }\n     fn peek() -> bool { peek_chan(self) }\n \n }\n \n /// Open a new receiving channel for the duration of a function\n-fn listen<T: send, U>(f: fn(chan<T>) -> U) -> U {\n+fn listen<T: send, U>(f: fn(Chan<T>) -> U) -> U {\n     let po = port();\n     f(po.chan())\n }\n \n-class port_ptr<T:send> {\n+class PortPtr<T:send> {\n   let po: *rust_port;\n   new(po: *rust_port) { self.po = po; }\n   drop unsafe {\n@@ -130,9 +130,9 @@ class port_ptr<T:send> {\n  * Fails if the port is detached or dead. Fails if the port\n  * is owned by a different task.\n  */\n-fn as_raw_port<T: send, U>(ch: comm::chan<T>, f: fn(*rust_port) -> U) -> U {\n+fn as_raw_port<T: send, U>(ch: comm::Chan<T>, f: fn(*rust_port) -> U) -> U {\n \n-    class portref {\n+    class PortRef {\n        let p: *rust_port;\n        new(p: *rust_port) { self.p = p; }\n        drop {\n@@ -142,7 +142,7 @@ fn as_raw_port<T: send, U>(ch: comm::chan<T>, f: fn(*rust_port) -> U) -> U {\n        }\n     }\n \n-    let p = portref(rustrt::rust_port_take(*ch));\n+    let p = PortRef(rustrt::rust_port_take(*ch));\n \n     if ptr::is_null(p.p) {\n         fail ~\"unable to locate port for channel\"\n@@ -157,16 +157,16 @@ fn as_raw_port<T: send, U>(ch: comm::chan<T>, f: fn(*rust_port) -> U) -> U {\n  * Constructs a channel. The channel is bound to the port used to\n  * construct it.\n  */\n-fn chan<T: send>(p: port<T>) -> chan<T> {\n-    chan_t(rustrt::get_port_id((**p).po))\n+fn chan<T: send>(p: Port<T>) -> Chan<T> {\n+    Chan_(rustrt::get_port_id((**p).po))\n }\n \n /**\n  * Sends data over a channel. The sent data is moved into the channel,\n  * whereupon the caller loses access to it.\n  */\n-fn send<T: send>(ch: chan<T>, +data: T) {\n-    let chan_t(p) = ch;\n+fn send<T: send>(ch: Chan<T>, +data: T) {\n+    let Chan_(p) = ch;\n     let data_ptr = ptr::addr_of(data) as *();\n     let res = rustrt::rust_port_id_send(p, data_ptr);\n     if res != 0u unsafe {\n@@ -180,17 +180,17 @@ fn send<T: send>(ch: chan<T>, +data: T) {\n  * Receive from a port.  If no data is available on the port then the\n  * task will block until data becomes available.\n  */\n-fn recv<T: send>(p: port<T>) -> T { recv_((**p).po) }\n+fn recv<T: send>(p: Port<T>) -> T { recv_((**p).po) }\n \n /// Returns true if there are messages available\n-fn peek<T: send>(p: port<T>) -> bool { peek_((**p).po) }\n+fn peek<T: send>(p: Port<T>) -> bool { peek_((**p).po) }\n \n #[doc(hidden)]\n-fn recv_chan<T: send>(ch: comm::chan<T>) -> T {\n+fn recv_chan<T: send>(ch: comm::Chan<T>) -> T {\n     as_raw_port(ch, |x|recv_(x))\n }\n \n-fn peek_chan<T: send>(ch: comm::chan<T>) -> bool {\n+fn peek_chan<T: send>(ch: comm::Chan<T>) -> bool {\n     as_raw_port(ch, |x|peek_(x))\n }\n \n@@ -221,7 +221,7 @@ fn peek_(p: *rust_port) -> bool {\n }\n \n /// Receive on one of two ports\n-fn select2<A: send, B: send>(p_a: port<A>, p_b: port<B>)\n+fn select2<A: send, B: send>(p_a: Port<A>, p_b: Port<B>)\n     -> Either<A, B> {\n     let ports = ~[(**p_a).po, (**p_b).po];\n     let yield = 0u, yieldp = ptr::addr_of(yield);\n@@ -257,9 +257,10 @@ fn select2<A: send, B: send>(p_a: port<A>, p_b: port<B>)\n \n /* Implementation details */\n \n-\n+#[allow(non_camel_case_types)] // runtime type\n enum rust_port {}\n \n+#[allow(non_camel_case_types)] // runtime type\n type port_id = int;\n \n #[abi = \"cdecl\"]\n@@ -329,7 +330,7 @@ fn chan_chan_infer() {\n \n #[test]\n fn chan_chan() {\n-    let p = port::<chan<int>>(), p2 = port::<int>();\n+    let p = port::<Chan<int>>(), p2 = port::<int>();\n     let c = chan(p);\n     send(c, chan(p2));\n     recv(p);"}, {"sha": "cd87313c696f47fcdd786f0b5dd9d0cc200409a0", "filename": "src/libcore/core.rc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -235,8 +235,11 @@ mod dlist_iter {\n mod send_map;\n \n // Concurrency\n+#[warn(non_camel_case_types)]\n mod comm;\n+#[warn(non_camel_case_types)]\n mod task;\n+//#[warn(non_camel_ase_types)] pipec code continues to trip this warning\n mod future;\n mod pipes;\n "}, {"sha": "fb3d832aef53ce43cf0eaa52ecf6bdbee00773ca", "filename": "src/libcore/future.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -18,7 +18,7 @@\n import either::Either;\n import pipes::recv;\n \n-export future;\n+export Future;\n export extensions;\n export from_value;\n export from_port;\n@@ -31,12 +31,12 @@ export spawn;\n export future_pipe;\n \n #[doc = \"The future type\"]\n-enum future<A> = {\n+enum Future<A> = {\n     mut v: Either<@A, fn@() -> A>\n };\n \n /// Methods on the `future` type\n-impl<A:copy send> future<A> {\n+impl<A:copy send> Future<A> {\n \n     fn get() -> A {\n         //! Get the value of the future\n@@ -51,15 +51,15 @@ impl<A:copy send> future<A> {\n     }\n }\n \n-fn from_value<A>(+val: A) -> future<A> {\n+fn from_value<A>(+val: A) -> Future<A> {\n     /*!\n      * Create a future from a value\n      *\n      * The value is immediately available and calling `get` later will\n      * not block.\n      */\n \n-    future({\n+    Future({\n         mut v: either::Left(@val)\n     })\n }\n@@ -68,7 +68,7 @@ macro_rules! move_it {\n     {$x:expr} => { unsafe { let y <- *ptr::addr_of($x); y } }\n }\n \n-fn from_port<A:send>(+port: future_pipe::client::waiting<A>) -> future<A> {\n+fn from_port<A:send>(+port: future_pipe::client::waiting<A>) -> Future<A> {\n     #[doc = \"\n     Create a future from a port\n \n@@ -87,7 +87,7 @@ fn from_port<A:send>(+port: future_pipe::client::waiting<A>) -> future<A> {\n     }\n }\n \n-fn from_fn<A>(f: fn@() -> A) -> future<A> {\n+fn from_fn<A>(f: fn@() -> A) -> Future<A> {\n     /*!\n      * Create a future from a function.\n      *\n@@ -96,12 +96,12 @@ fn from_fn<A>(f: fn@() -> A) -> future<A> {\n      * function. It is not spawned into another task.\n      */\n \n-    future({\n+    Future({\n         mut v: either::Right(f)\n     })\n }\n \n-fn spawn<A:send>(+blk: fn~() -> A) -> future<A> {\n+fn spawn<A:send>(+blk: fn~() -> A) -> Future<A> {\n     /*!\n      * Create a future from a unique closure.\n      *\n@@ -114,13 +114,13 @@ fn spawn<A:send>(+blk: fn~() -> A) -> future<A> {\n     }))\n }\n \n-fn get<A:copy>(future: &future<A>) -> A {\n+fn get<A:copy>(future: &Future<A>) -> A {\n     //! Get the value of the future\n \n     do with(future) |v| { *v }\n }\n \n-fn with<A,B>(future: &future<A>, blk: fn((&A)) -> B) -> B {\n+fn with<A,B>(future: &Future<A>, blk: fn((&A)) -> B) -> B {\n     //! Work with the value without copying it\n \n     let v = match copy future.v {"}, {"sha": "329172bb69ad9bfe8bca144093d746ae70750d9b", "filename": "src/libcore/os.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -24,7 +24,7 @@ import option::{some, none};\n \n import getcwd = rustrt::rust_getcwd;\n import consts::*;\n-import task::task_builder;\n+import task::TaskBuilder;\n \n export close, fclose, fsync_fd, waitpid;\n export env, getenv, setenv, fdopen, pipe;\n@@ -135,9 +135,9 @@ mod global_env {\n     }\n \n     enum Msg {\n-        MsgGetEnv(~str, comm::chan<option<~str>>),\n-        MsgSetEnv(~str, ~str, comm::chan<()>),\n-        MsgEnv(comm::chan<~[(~str,~str)]>)\n+        MsgGetEnv(~str, comm::Chan<option<~str>>),\n+        MsgSetEnv(~str, ~str, comm::Chan<()>),\n+        MsgEnv(comm::Chan<~[(~str,~str)]>)\n     }\n \n     fn getenv(n: ~str) -> option<~str> {\n@@ -161,18 +161,18 @@ mod global_env {\n         comm::recv(po)\n     }\n \n-    fn get_global_env_chan() -> comm::chan<Msg> {\n+    fn get_global_env_chan() -> comm::Chan<Msg> {\n         let global_ptr = rustrt::rust_global_env_chan_ptr();\n         unsafe {\n             priv::chan_from_global_ptr(global_ptr, || {\n                 // FIXME (#2621): This would be a good place to use a very\n                 // small foreign stack\n-                task::task().sched_mode(task::single_threaded).unlinked()\n+                task::task().sched_mode(task::SingleThreaded).unlinked()\n             }, global_env_task)\n         }\n     }\n \n-    fn global_env_task(msg_po: comm::port<Msg>) {\n+    fn global_env_task(msg_po: comm::Port<Msg>) {\n         unsafe {\n             do priv::weaken_task |weak_po| {\n                 loop {"}, {"sha": "1fcc57f503642222ecfade4be61360ae7826517f", "filename": "src/libcore/priv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -7,7 +7,7 @@\n export chan_from_global_ptr, weaken_task;\n \n import compare_and_swap = rustrt::rust_compare_and_swap_ptr;\n-import task::task_builder;\n+import task::TaskBuilder;\n \n #[allow(non_camel_case_types)] // runtime type\n type rust_port_id = uint;\n@@ -29,9 +29,9 @@ type GlobalPtr = *libc::uintptr_t;\n  */\n unsafe fn chan_from_global_ptr<T: send>(\n     global: GlobalPtr,\n-    task_fn: fn() -> task::task_builder,\n-    +f: fn~(comm::port<T>)\n-) -> comm::chan<T> {\n+    task_fn: fn() -> task::TaskBuilder,\n+    +f: fn~(comm::Port<T>)\n+) -> comm::Chan<T> {\n \n     enum Msg {\n         Proceed,\n@@ -185,7 +185,7 @@ fn test_from_global_chan2() {\n  * * Weak tasks must not be supervised. A supervised task keeps\n  *   a reference to its parent, so the parent will not die.\n  */\n-unsafe fn weaken_task(f: fn(comm::port<()>)) {\n+unsafe fn weaken_task(f: fn(comm::Port<()>)) {\n     let po = comm::port();\n     let ch = comm::chan(po);\n     unsafe {\n@@ -195,8 +195,8 @@ unsafe fn weaken_task(f: fn(comm::port<()>)) {\n     f(po);\n \n     class Unweaken {\n-      let ch: comm::chan<()>;\n-      new(ch: comm::chan<()>) { self.ch = ch; }\n+      let ch: comm::Chan<()>;\n+      new(ch: comm::Chan<()>) { self.ch = ch; }\n       drop unsafe {\n         rustrt::rust_task_unweaken(unsafe::reinterpret_cast(self.ch));\n       }"}, {"sha": "5dcd0a5272443a1fcf7d60559decf8d9e2a14444", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -173,9 +173,9 @@ impl<T> *T: Ptr {\n #[test]\n fn test() {\n     unsafe {\n-        type pair = {mut fst: int, mut snd: int};\n+        type Pair = {mut fst: int, mut snd: int};\n         let p = {mut fst: 10, mut snd: 20};\n-        let pptr: *mut pair = mut_addr_of(p);\n+        let pptr: *mut Pair = mut_addr_of(p);\n         let iptr: *mut int = unsafe::reinterpret_cast(pptr);\n         assert (*iptr == 10);;\n         *iptr = 30;"}, {"sha": "991c4d8bed2f841b1fabb9107cf6d3b610cc9c77", "filename": "src/libcore/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -298,11 +298,11 @@ fn program_output(prog: &str, args: &[~str]) ->\n     // clever way to do this.\n     let p = comm::port();\n     let ch = comm::chan(p);\n-    do task::spawn_sched(task::single_threaded) {\n+    do task::spawn_sched(task::SingleThreaded) {\n         let errput = readclose(pipe_err.in);\n         comm::send(ch, (2, errput));\n     };\n-    do task::spawn_sched(task::single_threaded) {\n+    do task::spawn_sched(task::SingleThreaded) {\n         let output = readclose(pipe_out.in);\n         comm::send(ch, (1, output));\n     };"}, {"sha": "50ff4e0d8a25b489e62ea5b1b4b82c2392fa7938", "filename": "src/libcore/task.rs", "status": "modified", "additions": 177, "deletions": 172, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -29,14 +29,15 @@\n \n import result::result;\n \n-export task;\n-export task_result;\n-export notification;\n-export sched_mode;\n-export sched_opts;\n-export task_opts;\n-export task_builder;\n+export Task;\n+export TaskResult;\n+export Notification;\n+export SchedMode;\n+export SchedOpts;\n+export TaskOpts;\n+export TaskBuilder;\n \n+export task;\n export default_task_opts;\n export get_opts;\n export set_opts;\n@@ -69,16 +70,16 @@ export local_data_get;\n export local_data_set;\n export local_data_modify;\n \n-export single_threaded;\n-export thread_per_core;\n-export thread_per_task;\n-export manual_threads;\n-export platform_thread;\n+export SingleThreaded;\n+export ThreadPerCore;\n+export ThreadPerTask;\n+export ManualThreads;\n+export PlatformThread;\n \n /* Data types */\n \n /// A handle to a task\n-enum task { task_handle(task_id) }\n+enum Task { TaskHandle(task_id) }\n \n /**\n  * Indicates the manner in which a task exited.\n@@ -91,34 +92,34 @@ enum task { task_handle(task_id) }\n  * If you wish for this result's delivery to block until all linked and/or\n  * children tasks complete, recommend using a result future.\n  */\n-enum task_result {\n-    success,\n-    failure,\n+enum TaskResult {\n+    Success,\n+    Failure,\n }\n \n /// A message type for notifying of task lifecycle events\n-enum notification {\n+enum Notification {\n     /// Sent when a task exits with the task handle and result\n-    exit(task, task_result)\n+    Exit(Task, TaskResult)\n }\n \n /// Scheduler modes\n-enum sched_mode {\n+enum SchedMode {\n     /// All tasks run in the same OS thread\n-    single_threaded,\n+    SingleThreaded,\n     /// Tasks are distributed among available CPUs\n-    thread_per_core,\n+    ThreadPerCore,\n     /// Each task runs in its own OS thread\n-    thread_per_task,\n+    ThreadPerTask,\n     /// Tasks are distributed among a fixed number of OS threads\n-    manual_threads(uint),\n+    ManualThreads(uint),\n     /**\n      * Tasks are scheduled on the main OS thread\n      *\n      * The main OS thread is the thread used to launch the runtime which,\n      * in most cases, is the process's initial thread as created by the OS.\n      */\n-    platform_thread\n+    PlatformThread\n }\n \n /**\n@@ -136,8 +137,8 @@ enum sched_mode {\n  *     default these foreign stacks have unspecified size, but with this\n  *     option their size can be precisely specified.\n  */\n-type sched_opts = {\n-    mode: sched_mode,\n+type SchedOpts = {\n+    mode: SchedMode,\n     foreign_stack_size: option<uint>\n };\n \n@@ -168,11 +169,11 @@ type sched_opts = {\n  *     into foreign code that blocks. Without doing so in a different\n  *     scheduler other tasks will be impeded or even blocked indefinitely.\n  */\n-type task_opts = {\n+type TaskOpts = {\n     linked: bool,\n     supervised: bool,\n-    notify_chan: option<comm::chan<notification>>,\n-    sched: option<sched_opts>,\n+    notify_chan: option<comm::Chan<Notification>>,\n+    sched: option<SchedOpts>,\n };\n \n /**\n@@ -189,8 +190,8 @@ type task_opts = {\n // the run function move them in.\n \n // FIXME (#2585): Replace the 'consumed' bit with move mode on self\n-enum task_builder = {\n-    opts: task_opts,\n+enum TaskBuilder = {\n+    opts: TaskOpts,\n     gen_body: fn@(+fn~()) -> fn~(),\n     can_not_copy: option<util::NonCopyable>,\n     mut consumed: bool,\n@@ -201,32 +202,32 @@ enum task_builder = {\n  * configuration methods can be chained.\n  * For example, task().unlinked().spawn is equivalent to spawn_unlinked.\n  */\n-fn task() -> task_builder {\n-    task_builder({\n+fn task() -> TaskBuilder {\n+    TaskBuilder({\n         opts: default_task_opts(),\n         gen_body: |body| body, // Identity function\n         can_not_copy: none,\n         mut consumed: false,\n     })\n }\n \n-priv impl task_builder {\n-    fn consume() -> task_builder {\n+priv impl TaskBuilder {\n+    fn consume() -> TaskBuilder {\n         if self.consumed {\n             fail ~\"Cannot copy a task_builder\"; // Fake move mode on self\n         }\n         self.consumed = true;\n-        task_builder({ can_not_copy: none, mut consumed: false, with *self })\n+        TaskBuilder({ can_not_copy: none, mut consumed: false, with *self })\n     }\n }\n \n-impl task_builder {\n+impl TaskBuilder {\n     /**\n      * Decouple the child task's failure from the parent's. If either fails,\n      * the other will not be killed.\n      */\n-    fn unlinked() -> task_builder {\n-        task_builder({\n+    fn unlinked() -> TaskBuilder {\n+        TaskBuilder({\n             opts: { linked: false with self.opts },\n             can_not_copy: none,\n             with *self.consume()\n@@ -237,8 +238,8 @@ impl task_builder {\n      * child's failure will not kill the parent, but the parent's will kill\n      * the child.\n      */\n-    fn supervised() -> task_builder {\n-        task_builder({\n+    fn supervised() -> TaskBuilder {\n+        TaskBuilder({\n             opts: { linked: false, supervised: true with self.opts },\n             can_not_copy: none,\n             with *self.consume()\n@@ -248,8 +249,8 @@ impl task_builder {\n      * Link the child task's and parent task's failures. If either fails, the\n      * other will be killed.\n      */\n-    fn linked() -> task_builder {\n-        task_builder({\n+    fn linked() -> TaskBuilder {\n+        TaskBuilder({\n             opts: { linked: true, supervised: false with self.opts },\n             can_not_copy: none,\n             with *self.consume()\n@@ -273,7 +274,7 @@ impl task_builder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn future_result(blk: fn(+future::future<task_result>)) -> task_builder {\n+    fn future_result(blk: fn(+future::Future<TaskResult>)) -> TaskBuilder {\n         // FIXME (#1087, #1857): Once linked failure and notification are\n         // handled in the library, I can imagine implementing this by just\n         // registering an arbitrary number of task::on_exit handlers and\n@@ -284,25 +285,25 @@ impl task_builder {\n         }\n \n         // Construct the future and give it to the caller.\n-        let po = comm::port::<notification>();\n+        let po = comm::port::<Notification>();\n         let ch = comm::chan(po);\n \n         blk(do future::from_fn {\n             match comm::recv(po) {\n-              exit(_, result) => result\n+              Exit(_, result) => result\n             }\n         });\n \n         // Reconfigure self to use a notify channel.\n-        task_builder({\n+        TaskBuilder({\n             opts: { notify_chan: some(ch) with self.opts },\n             can_not_copy: none,\n             with *self.consume()\n         })\n     }\n     /// Configure a custom scheduler mode for the task.\n-    fn sched_mode(mode: sched_mode) -> task_builder {\n-        task_builder({\n+    fn sched_mode(mode: SchedMode) -> TaskBuilder {\n+        TaskBuilder({\n             opts: { sched: some({ mode: mode, foreign_stack_size: none})\n                     with self.opts },\n             can_not_copy: none,\n@@ -322,9 +323,9 @@ impl task_builder {\n      * generator by applying the task body which results from the\n      * existing body generator to the new body generator.\n      */\n-    fn add_wrapper(wrapper: fn@(+fn~()) -> fn~()) -> task_builder {\n+    fn add_wrapper(wrapper: fn@(+fn~()) -> fn~()) -> TaskBuilder {\n         let prev_gen_body = self.gen_body;\n-        task_builder({\n+        TaskBuilder({\n             gen_body: |body| { wrapper(prev_gen_body(body)) },\n             can_not_copy: none,\n             with *self.consume()\n@@ -366,7 +367,7 @@ impl task_builder {\n      * otherwise be required to establish communication from the parent\n      * to the child.\n      */\n-    fn spawn_listener<A: send>(+f: fn~(comm::port<A>)) -> comm::chan<A> {\n+    fn spawn_listener<A: send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n         let setup_po = comm::port();\n         let setup_ch = comm::chan(setup_po);\n         do self.spawn {\n@@ -382,8 +383,8 @@ impl task_builder {\n      * Runs a new task, setting up communication in both directions\n      */\n     fn spawn_conversation<A: send, B: send>\n-        (+f: fn~(comm::port<A>, comm::chan<B>))\n-        -> (comm::port<B>, comm::chan<A>) {\n+        (+f: fn~(comm::Port<A>, comm::Chan<B>))\n+        -> (comm::Port<B>, comm::Chan<A>) {\n         let from_child = comm::port();\n         let to_parent = comm::chan(from_child);\n         let to_child = do self.spawn_listener |from_parent| {\n@@ -414,16 +415,16 @@ impl task_builder {\n             comm::send(ch, f());\n         }\n         match future::get(&option::unwrap(result)) {\n-            success => result::ok(comm::recv(po)),\n-            failure => result::err(())\n+            Success => result::ok(comm::recv(po)),\n+            Failure => result::err(())\n         }\n     }\n }\n \n \n /* Task construction */\n \n-fn default_task_opts() -> task_opts {\n+fn default_task_opts() -> TaskOpts {\n     /*!\n      * The default task options\n      *\n@@ -486,7 +487,7 @@ fn spawn_with<A:send>(+arg: A, +f: fn~(+A)) {\n     task().spawn_with(arg, f)\n }\n \n-fn spawn_listener<A:send>(+f: fn~(comm::port<A>)) -> comm::chan<A> {\n+fn spawn_listener<A:send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n     /*!\n      * Runs a new task while providing a channel from the parent to the child\n      *\n@@ -497,8 +498,8 @@ fn spawn_listener<A:send>(+f: fn~(comm::port<A>)) -> comm::chan<A> {\n }\n \n fn spawn_conversation<A: send, B: send>\n-    (+f: fn~(comm::port<A>, comm::chan<B>))\n-    -> (comm::port<B>, comm::chan<A>) {\n+    (+f: fn~(comm::Port<A>, comm::Chan<B>))\n+    -> (comm::Port<B>, comm::Chan<A>) {\n     /*!\n      * Runs a new task, setting up communication in both directions\n      *\n@@ -508,7 +509,7 @@ fn spawn_conversation<A: send, B: send>\n     task().spawn_conversation(f)\n }\n \n-fn spawn_sched(mode: sched_mode, +f: fn~()) {\n+fn spawn_sched(mode: SchedMode, +f: fn~()) {\n     /*!\n      * Creates a new scheduler and executes a task on it\n      *\n@@ -555,10 +556,10 @@ fn failing() -> bool {\n     rustrt::rust_task_is_unwinding(rustrt::rust_get_task())\n }\n \n-fn get_task() -> task {\n+fn get_task() -> Task {\n     //! Get a handle to the running task\n \n-    task_handle(rustrt::get_task_id())\n+    TaskHandle(rustrt::get_task_id())\n }\n \n /**\n@@ -577,28 +578,28 @@ fn get_task() -> task {\n  * ~~~\n  */\n unsafe fn unkillable<U>(f: fn() -> U) -> U {\n-    class allow_failure {\n+    class AllowFailure {\n         let t: *rust_task;\n         new(t: *rust_task) { self.t = t; }\n         drop { rustrt::rust_task_allow_kill(self.t); }\n     }\n \n     let t = rustrt::rust_get_task();\n-    let _allow_failure = allow_failure(t);\n+    let _allow_failure = AllowFailure(t);\n     rustrt::rust_task_inhibit_kill(t);\n     f()\n }\n \n /// The inverse of unkillable. Only ever to be used nested in unkillable().\n unsafe fn rekillable<U>(f: fn() -> U) -> U {\n-    class disallow_failure {\n+    class DisallowFailure {\n         let t: *rust_task;\n         new(t: *rust_task) { self.t = t; }\n         drop { rustrt::rust_task_inhibit_kill(self.t); }\n     }\n \n     let t = rustrt::rust_get_task();\n-    let _allow_failure = disallow_failure(t);\n+    let _allow_failure = DisallowFailure(t);\n     rustrt::rust_task_allow_kill(t);\n     f()\n }\n@@ -608,7 +609,7 @@ unsafe fn rekillable<U>(f: fn() -> U) -> U {\n  * For use with exclusive ARCs, which use pthread mutexes directly.\n  */\n unsafe fn atomically<U>(f: fn() -> U) -> U {\n-    class defer_interrupts {\n+    class DeferInterrupts {\n         let t: *rust_task;\n         new(t: *rust_task) { self.t = t; }\n         drop {\n@@ -617,7 +618,7 @@ unsafe fn atomically<U>(f: fn() -> U) -> U {\n         }\n     }\n     let t = rustrt::rust_get_task();\n-    let _interrupts = defer_interrupts(t);\n+    let _interrupts = DeferInterrupts(t);\n     rustrt::rust_task_inhibit_kill(t);\n     rustrt::rust_task_inhibit_yield(t);\n     f()\n@@ -685,17 +686,21 @@ unsafe fn atomically<U>(f: fn() -> U) -> U {\n  *\n  ****************************************************************************/\n \n+#[allow(non_camel_case_types)] // runtime type\n type sched_id = int;\n+#[allow(non_camel_case_types)] // runtime type\n type task_id = int;\n \n // These are both opaque runtime/compiler types that we don't know the\n // structure of and should only deal with via unsafe pointer\n+#[allow(non_camel_case_types)] // runtime type\n type rust_task = libc::c_void;\n+#[allow(non_camel_case_types)] // runtime type\n type rust_closure = libc::c_void;\n \n-type taskset = send_map::linear::LinearMap<*rust_task,()>;\n+type TaskSet = send_map::linear::LinearMap<*rust_task,()>;\n \n-fn new_taskset() -> taskset {\n+fn new_taskset() -> TaskSet {\n     pure fn task_hash(t: &*rust_task) -> uint {\n         let task: *rust_task = *t;\n         hash::hash_uint(task as uint) as uint\n@@ -708,33 +713,33 @@ fn new_taskset() -> taskset {\n \n     send_map::linear::linear_map(task_hash, task_eq)\n }\n-fn taskset_insert(tasks: &mut taskset, task: *rust_task) {\n+fn taskset_insert(tasks: &mut TaskSet, task: *rust_task) {\n     let didnt_overwrite = tasks.insert(task, ());\n     assert didnt_overwrite;\n }\n-fn taskset_remove(tasks: &mut taskset, task: *rust_task) {\n+fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n     let was_present = tasks.remove(&task);\n     assert was_present;\n }\n-fn taskset_each(tasks: &taskset, blk: fn(+*rust_task) -> bool) {\n+fn taskset_each(tasks: &TaskSet, blk: fn(+*rust_task) -> bool) {\n     tasks.each_key(blk)\n }\n \n // One of these per group of linked-failure tasks.\n-type taskgroup_data = {\n+type TaskGroupData = {\n     // All tasks which might kill this group. When this is empty, the group\n     // can be \"GC\"ed (i.e., its link in the ancestor list can be removed).\n-    mut members:     taskset,\n+    mut members:     TaskSet,\n     // All tasks unidirectionally supervised by (directly or transitively)\n     // tasks in this group.\n-    mut descendants: taskset,\n+    mut descendants: TaskSet,\n };\n-type taskgroup_arc = unsafe::Exclusive<option<taskgroup_data>>;\n+type TaskGroupArc = unsafe::Exclusive<option<TaskGroupData>>;\n \n-type taskgroup_inner = &mut option<taskgroup_data>;\n+type TaskGroupInner = &mut option<TaskGroupData>;\n \n // A taskgroup is 'dead' when nothing can cause it to fail; only members can.\n-pure fn taskgroup_is_dead(tg: &taskgroup_data) -> bool {\n+pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n     (&tg.members).is_empty()\n }\n \n@@ -745,7 +750,7 @@ pure fn taskgroup_is_dead(tg: &taskgroup_data) -> bool {\n // taskgroup which was spawned-unlinked. Tasks from intermediate generations\n // have references to the middle of the list; when intermediate generations\n // die, their node in the list will be collected at a descendant's spawn-time.\n-type ancestor_node = {\n+type AncestorNode = {\n     // Since the ancestor list is recursive, we end up with references to\n     // exclusives within other exclusives. This is dangerous business (if\n     // circular references arise, deadlock and memory leaks are imminent).\n@@ -754,20 +759,20 @@ type ancestor_node = {\n     // FIXME(#3068): Make the generation counter togglable with #[cfg(debug)].\n     generation:       uint,\n     // Should really be an immutable non-option. This way appeases borrowck.\n-    mut parent_group: option<taskgroup_arc>,\n+    mut parent_group: option<TaskGroupArc>,\n     // Recursive rest of the list.\n-    mut ancestors:    ancestor_list,\n+    mut ancestors:    AncestorList,\n };\n-enum ancestor_list = option<unsafe::Exclusive<ancestor_node>>;\n+enum AncestorList = option<unsafe::Exclusive<AncestorNode>>;\n \n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n #[inline(always)]\n-fn access_group<U>(x: taskgroup_arc, blk: fn(taskgroup_inner) -> U) -> U {\n+fn access_group<U>(x: TaskGroupArc, blk: fn(TaskGroupInner) -> U) -> U {\n     unsafe { x.with(blk) }\n }\n #[inline(always)]\n-fn access_ancestors<U>(x: unsafe::Exclusive<ancestor_node>,\n-                       blk: fn(x: &mut ancestor_node) -> U) -> U {\n+fn access_ancestors<U>(x: unsafe::Exclusive<AncestorNode>,\n+                       blk: fn(x: &mut AncestorNode) -> U) -> U {\n     unsafe { x.with(blk) }\n }\n \n@@ -779,21 +784,21 @@ fn access_ancestors<U>(x: unsafe::Exclusive<ancestor_node>,\n // (3) As a bonus, coalesces away all 'dead' taskgroup nodes in the list.\n // FIXME(#2190): Change option<fn@(...)> to option<fn&(...)>, to save on\n // allocations. Once that bug is fixed, changing the sigil should suffice.\n-fn each_ancestor(list:        &mut ancestor_list,\n-                 bail_opt:    option<fn@(taskgroup_inner)>,\n-                 forward_blk: fn(taskgroup_inner) -> bool)\n+fn each_ancestor(list:        &mut AncestorList,\n+                 bail_opt:    option<fn@(TaskGroupInner)>,\n+                 forward_blk: fn(TaskGroupInner) -> bool)\n         -> bool {\n     // \"Kickoff\" call - there was no last generation.\n     return !coalesce(list, bail_opt, forward_blk, uint::max_value);\n \n     // Recursively iterates, and coalesces afterwards if needed. Returns\n     // whether or not unwinding is needed (i.e., !successful iteration).\n-    fn coalesce(list:            &mut ancestor_list,\n-                bail_opt:        option<fn@(taskgroup_inner)>,\n-                forward_blk:     fn(taskgroup_inner) -> bool,\n+    fn coalesce(list:            &mut AncestorList,\n+                bail_opt:        option<fn@(TaskGroupInner)>,\n+                forward_blk:     fn(TaskGroupInner) -> bool,\n                 last_generation: uint) -> bool {\n         // Need to swap the list out to use it, to appease borrowck.\n-        let tmp_list = util::replace(list, ancestor_list(none));\n+        let tmp_list = util::replace(list, AncestorList(none));\n         let (coalesce_this, early_break) =\n             iterate(tmp_list, bail_opt, forward_blk, last_generation);\n         // What should our next ancestor end up being?\n@@ -816,10 +821,10 @@ fn each_ancestor(list:        &mut ancestor_list,\n     // bool:\n     //     True if the supplied block did 'break', here or in any recursive\n     //     calls. If so, must call the unwinder on all previous nodes.\n-    fn iterate(ancestors:       ancestor_list,\n-               bail_opt:        option<fn@(taskgroup_inner)>,\n-               forward_blk:     fn(taskgroup_inner) -> bool,\n-               last_generation: uint) -> (option<ancestor_list>, bool) {\n+    fn iterate(ancestors:       AncestorList,\n+               bail_opt:        option<fn@(TaskGroupInner)>,\n+               forward_blk:     fn(TaskGroupInner) -> bool,\n+               last_generation: uint) -> (option<AncestorList>, bool) {\n         // At each step of iteration, three booleans are at play which govern\n         // how the iteration should behave.\n         // 'nobe_is_dead' - Should the list should be coalesced at this point?\n@@ -885,7 +890,7 @@ fn each_ancestor(list:        &mut ancestor_list,\n                 if nobe_is_dead {\n                     // Swap the list out here; the caller replaces us with it.\n                     let rest = util::replace(&mut nobe.ancestors,\n-                                             ancestor_list(none));\n+                                             AncestorList(none));\n                     (some(rest), need_unwind)\n                 } else {\n                     (none, need_unwind)\n@@ -894,8 +899,8 @@ fn each_ancestor(list:        &mut ancestor_list,\n         };\n \n         // Wrapper around exclusive::with that appeases borrowck.\n-        fn with_parent_tg<U>(parent_group: &mut option<taskgroup_arc>,\n-                             blk: fn(taskgroup_inner) -> U) -> U {\n+        fn with_parent_tg<U>(parent_group: &mut option<TaskGroupArc>,\n+                             blk: fn(TaskGroupInner) -> U) -> U {\n             // If this trips, more likely the problem is 'blk' failed inside.\n             let tmp_arc = option::swap_unwrap(parent_group);\n             let result = do access_group(tmp_arc) |tg_opt| { blk(tg_opt) };\n@@ -906,16 +911,16 @@ fn each_ancestor(list:        &mut ancestor_list,\n }\n \n // One of these per task.\n-class tcb {\n+class Tcb {\n     let me:            *rust_task;\n     // List of tasks with whose fates this one's is intertwined.\n-    let tasks:         taskgroup_arc; // 'none' means the group has failed.\n+    let tasks:         TaskGroupArc; // 'none' means the group has failed.\n     // Lists of tasks who will kill us if they fail, but whom we won't kill.\n-    let mut ancestors: ancestor_list;\n+    let mut ancestors: AncestorList;\n     let is_main:       bool;\n-    let notifier:      option<auto_notify>;\n-    new(me: *rust_task, -tasks: taskgroup_arc, -ancestors: ancestor_list,\n-        is_main: bool, -notifier: option<auto_notify>) {\n+    let notifier:      option<AutoNotify>;\n+    new(me: *rust_task, -tasks: TaskGroupArc, -ancestors: AncestorList,\n+        is_main: bool, -notifier: option<AutoNotify>) {\n         self.me        = me;\n         self.tasks     = tasks;\n         self.ancestors = ancestors;\n@@ -947,20 +952,20 @@ class tcb {\n     }\n }\n \n-class auto_notify {\n-    let notify_chan: comm::chan<notification>;\n+class AutoNotify {\n+    let notify_chan: comm::Chan<Notification>;\n     let mut failed:  bool;\n-    new(chan: comm::chan<notification>) {\n+    new(chan: comm::Chan<Notification>) {\n         self.notify_chan = chan;\n         self.failed = true; // Un-set above when taskgroup successfully made.\n     }\n     drop {\n-        let result = if self.failed { failure } else { success };\n-        comm::send(self.notify_chan, exit(get_task(), result));\n+        let result = if self.failed { Failure } else { Success };\n+        comm::send(self.notify_chan, Exit(get_task(), result));\n     }\n }\n \n-fn enlist_in_taskgroup(state: taskgroup_inner, me: *rust_task,\n+fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n                        is_member: bool) -> bool {\n     let newstate = util::replace(state, none);\n     // If 'none', the group was failing. Can't enlist.\n@@ -976,7 +981,7 @@ fn enlist_in_taskgroup(state: taskgroup_inner, me: *rust_task,\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n-fn leave_taskgroup(state: taskgroup_inner, me: *rust_task, is_member: bool) {\n+fn leave_taskgroup(state: TaskGroupInner, me: *rust_task, is_member: bool) {\n     let newstate = util::replace(state, none);\n     // If 'none', already failing and we've already gotten a kill signal.\n     if newstate.is_some() {\n@@ -988,7 +993,7 @@ fn leave_taskgroup(state: taskgroup_inner, me: *rust_task, is_member: bool) {\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n-fn kill_taskgroup(state: taskgroup_inner, me: *rust_task, is_main: bool) {\n+fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n     // NB: We could do the killing iteration outside of the group arc, by\n     // having \"let mut newstate\" here, swapping inside, and iterating after.\n     // But that would let other exiting tasks fall-through and exit while we\n@@ -1031,7 +1036,7 @@ macro_rules! taskgroup_key {\n }\n \n fn gen_child_taskgroup(linked: bool, supervised: bool)\n-        -> (taskgroup_arc, ancestor_list, bool) {\n+        -> (TaskGroupArc, AncestorList, bool) {\n     let spawner = rustrt::rust_get_task();\n     /*######################################################################*\n      * Step 1. Get spawner's taskgroup info.\n@@ -1047,7 +1052,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                                          mut descendants: new_taskset() }));\n             // Main task/group has no ancestors, no notifier, etc.\n             let group =\n-                @tcb(spawner, tasks, ancestor_list(none), true, none);\n+                @Tcb(spawner, tasks, AncestorList(none), true, none);\n             unsafe { local_set(spawner, taskgroup_key!(), group); }\n             group\n         }\n@@ -1080,18 +1085,18 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                 };\n             assert new_generation < uint::max_value;\n             // Build a new node in the ancestor list.\n-            ancestor_list(some(unsafe::exclusive(\n+            AncestorList(some(unsafe::exclusive(\n                 { generation:       new_generation,\n                   mut parent_group: some(spawner_group.tasks.clone()),\n                   mut ancestors:    old_ancestors })))\n         } else {\n             // Child has no ancestors.\n-            ancestor_list(none)\n+            AncestorList(none)\n         };\n         (g,a, false)\n     };\n \n-    fn share_ancestors(ancestors: &mut ancestor_list) -> ancestor_list {\n+    fn share_ancestors(ancestors: &mut AncestorList) -> AncestorList {\n         // Appease the borrow-checker. Really this wants to be written as:\n         // match ancestors\n         //    some(ancestor_arc) { ancestor_list(some(ancestor_arc.clone())) }\n@@ -1101,14 +1106,14 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             let ancestor_arc = option::unwrap(tmp);\n             let result = ancestor_arc.clone();\n             **ancestors <- some(ancestor_arc);\n-            ancestor_list(some(result))\n+            AncestorList(some(result))\n         } else {\n-            ancestor_list(none)\n+            AncestorList(none)\n         }\n     }\n }\n \n-fn spawn_raw(+opts: task_opts, +f: fn~()) {\n+fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n     let (child_tg, ancestors, is_main) =\n         gen_child_taskgroup(opts.linked, opts.supervised);\n \n@@ -1146,9 +1151,9 @@ fn spawn_raw(+opts: task_opts, +f: fn~()) {\n     // (3a) If any of those fails, it leaves all groups, and does nothing.\n     // (3b) Otherwise it builds a task control structure and puts it in TLS,\n     // (4) ...and runs the provided body function.\n-    fn make_child_wrapper(child: *rust_task, +child_arc: taskgroup_arc,\n-                          +ancestors: ancestor_list, is_main: bool,\n-                          notify_chan: option<comm::chan<notification>>,\n+    fn make_child_wrapper(child: *rust_task, +child_arc: TaskGroupArc,\n+                          +ancestors: AncestorList, is_main: bool,\n+                          notify_chan: option<comm::Chan<Notification>>,\n                           +f: fn~()) -> fn~() {\n         let child_data = ~mut some((child_arc, ancestors));\n         return fn~() {\n@@ -1158,10 +1163,10 @@ fn spawn_raw(+opts: task_opts, +f: fn~()) {\n \n             // Even if the below code fails to kick the child off, we must\n             // send something on the notify channel.\n-            let notifier = notify_chan.map(|c| auto_notify(c));\n+            let notifier = notify_chan.map(|c| AutoNotify(c));\n \n             if enlist_many(child, child_arc, &mut ancestors) {\n-                let group = @tcb(child, child_arc, ancestors,\n+                let group = @Tcb(child, child_arc, ancestors,\n                                  is_main, notifier);\n                 unsafe { local_set(child, taskgroup_key!(), group); }\n                 // Run the child's body.\n@@ -1173,8 +1178,8 @@ fn spawn_raw(+opts: task_opts, +f: fn~()) {\n         // Set up membership in taskgroup and descendantship in all ancestor\n         // groups. If any enlistment fails, some task was already failing, so\n         // don't let the child task run, and undo every successful enlistment.\n-        fn enlist_many(child: *rust_task, child_arc: taskgroup_arc,\n-                       ancestors: &mut ancestor_list) -> bool {\n+        fn enlist_many(child: *rust_task, child_arc: TaskGroupArc,\n+                       ancestors: &mut AncestorList) -> bool {\n             // Join this taskgroup.\n             let mut result =\n                 do access_group(child_arc) |child_tg| {\n@@ -1203,29 +1208,29 @@ fn spawn_raw(+opts: task_opts, +f: fn~()) {\n         }\n     }\n \n-    fn new_task_in_new_sched(opts: sched_opts) -> *rust_task {\n+    fn new_task_in_new_sched(opts: SchedOpts) -> *rust_task {\n         if opts.foreign_stack_size != none {\n             fail ~\"foreign_stack_size scheduler option unimplemented\";\n         }\n \n         let num_threads = match opts.mode {\n-          single_threaded => 1u,\n-          thread_per_core => {\n+          SingleThreaded => 1u,\n+          ThreadPerCore => {\n             fail ~\"thread_per_core scheduling mode unimplemented\"\n           }\n-          thread_per_task => {\n+          ThreadPerTask => {\n             fail ~\"thread_per_task scheduling mode unimplemented\"\n           }\n-          manual_threads(threads) => {\n+          ManualThreads(threads) => {\n             if threads == 0u {\n                 fail ~\"can not create a scheduler with no threads\";\n             }\n             threads\n           }\n-          platform_thread => 0u /* Won't be used */\n+          PlatformThread => 0u /* Won't be used */\n         };\n \n-        let sched_id = if opts.mode != platform_thread {\n+        let sched_id = if opts.mode != PlatformThread {\n             rustrt::rust_new_sched(num_threads)\n         } else {\n             rustrt::rust_osmain_sched_id()\n@@ -1262,34 +1267,34 @@ fn spawn_raw(+opts: task_opts, +f: fn~()) {\n  *\n  * These two cases aside, the interface is safe.\n  */\n-type local_data_key<T: owned> = &fn(+@T);\n+type LocalDataKey<T: owned> = &fn(+@T);\n \n-trait local_data { }\n-impl<T: owned> @T: local_data { }\n+trait LocalData { }\n+impl<T: owned> @T: LocalData { }\n \n // We use dvec because it's the best data structure in core. If TLS is used\n // heavily in future, this could be made more efficient with a proper map.\n-type task_local_element = (*libc::c_void, *libc::c_void, local_data);\n+type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n // Has to be a pointer at outermost layer; the foreign call returns void *.\n-type task_local_map = @dvec::DVec<option<task_local_element>>;\n+type TaskLocalMap = @dvec::DVec<option<TaskLocalElement>>;\n \n extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n     assert !map_ptr.is_null();\n     // Get and keep the single reference that was created at the beginning.\n-    let _map: task_local_map = unsafe::reinterpret_cast(map_ptr);\n+    let _map: TaskLocalMap = unsafe::reinterpret_cast(map_ptr);\n     // All local_data will be destroyed along with the map.\n }\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n-unsafe fn get_task_local_map(task: *rust_task) -> task_local_map {\n+unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n \n     // Relies on the runtime initialising the pointer to null.\n     // NOTE: The map's box lives in TLS invisibly referenced once. Each time\n     // we retrieve it for get/set, we make another reference, which get/set\n     // drop when they finish. No \"re-storing after modifying\" is needed.\n     let map_ptr = rustrt::rust_get_task_local_data(task);\n     if map_ptr.is_null() {\n-        let map: task_local_map = @dvec::dvec();\n+        let map: TaskLocalMap = @dvec::dvec();\n         // Use reinterpret_cast -- transmute would take map away from us also.\n         rustrt::rust_set_task_local_data(task, unsafe::reinterpret_cast(map));\n         rustrt::rust_task_local_data_atexit(task, cleanup_task_local_map);\n@@ -1304,7 +1309,7 @@ unsafe fn get_task_local_map(task: *rust_task) -> task_local_map {\n }\n \n unsafe fn key_to_key_value<T: owned>(\n-    key: local_data_key<T>) -> *libc::c_void {\n+    key: LocalDataKey<T>) -> *libc::c_void {\n \n     // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n     // Use reintepret_cast -- transmute would leak (forget) the closure.\n@@ -1314,7 +1319,7 @@ unsafe fn key_to_key_value<T: owned>(\n \n // If returning some(..), returns with @T with the map's reference. Careful!\n unsafe fn local_data_lookup<T: owned>(\n-    map: task_local_map, key: local_data_key<T>)\n+    map: TaskLocalMap, key: LocalDataKey<T>)\n     -> option<(uint, *libc::c_void)> {\n \n     let key_value = key_to_key_value(key);\n@@ -1332,7 +1337,7 @@ unsafe fn local_data_lookup<T: owned>(\n }\n \n unsafe fn local_get_helper<T: owned>(\n-    task: *rust_task, key: local_data_key<T>,\n+    task: *rust_task, key: LocalDataKey<T>,\n     do_pop: bool) -> option<@T> {\n \n     let map = get_task_local_map(task);\n@@ -1354,20 +1359,20 @@ unsafe fn local_get_helper<T: owned>(\n \n unsafe fn local_pop<T: owned>(\n     task: *rust_task,\n-    key: local_data_key<T>) -> option<@T> {\n+    key: LocalDataKey<T>) -> option<@T> {\n \n     local_get_helper(task, key, true)\n }\n \n unsafe fn local_get<T: owned>(\n     task: *rust_task,\n-    key: local_data_key<T>) -> option<@T> {\n+    key: LocalDataKey<T>) -> option<@T> {\n \n     local_get_helper(task, key, false)\n }\n \n unsafe fn local_set<T: owned>(\n-    task: *rust_task, key: local_data_key<T>, +data: @T) {\n+    task: *rust_task, key: LocalDataKey<T>, +data: @T) {\n \n     let map = get_task_local_map(task);\n     // Store key+data as *voids. Data is invisibly referenced once; key isn't.\n@@ -1378,7 +1383,7 @@ unsafe fn local_set<T: owned>(\n     // does not have a reference associated with it, so it may become invalid\n     // when the box is destroyed.\n     let data_ptr = unsafe::reinterpret_cast(data);\n-    let data_box = data as local_data;\n+    let data_box = data as LocalData;\n     // Construct new entry to store in the map.\n     let new_entry = some((keyval, data_ptr, data_box));\n     // Find a place to put it.\n@@ -1399,7 +1404,7 @@ unsafe fn local_set<T: owned>(\n }\n \n unsafe fn local_modify<T: owned>(\n-    task: *rust_task, key: local_data_key<T>,\n+    task: *rust_task, key: LocalDataKey<T>,\n     modify_fn: fn(option<@T>) -> option<@T>) {\n \n     // Could be more efficient by doing the lookup work, but this is easy.\n@@ -1415,7 +1420,7 @@ unsafe fn local_modify<T: owned>(\n  * reference that was originally created to insert it.\n  */\n unsafe fn local_data_pop<T: owned>(\n-    key: local_data_key<T>) -> option<@T> {\n+    key: LocalDataKey<T>) -> option<@T> {\n \n     local_pop(rustrt::rust_get_task(), key)\n }\n@@ -1424,7 +1429,7 @@ unsafe fn local_data_pop<T: owned>(\n  * table until explicitly removed.\n  */\n unsafe fn local_data_get<T: owned>(\n-    key: local_data_key<T>) -> option<@T> {\n+    key: LocalDataKey<T>) -> option<@T> {\n \n     local_get(rustrt::rust_get_task(), key)\n }\n@@ -1433,7 +1438,7 @@ unsafe fn local_data_get<T: owned>(\n  * that value is overwritten (and its destructor is run).\n  */\n unsafe fn local_data_set<T: owned>(\n-    key: local_data_key<T>, +data: @T) {\n+    key: LocalDataKey<T>, +data: @T) {\n \n     local_set(rustrt::rust_get_task(), key, data)\n }\n@@ -1442,7 +1447,7 @@ unsafe fn local_data_set<T: owned>(\n  * data is removed (and its reference dropped).\n  */\n unsafe fn local_data_modify<T: owned>(\n-    key: local_data_key<T>,\n+    key: LocalDataKey<T>,\n     modify_fn: fn(option<@T>) -> option<@T>) {\n \n     local_modify(rustrt::rust_get_task(), key, modify_fn)\n@@ -1558,7 +1563,7 @@ fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n     // We have to cheat with opts - the interface doesn't support them because\n     // they don't make sense (redundant with task().supervised()).\n     let b0 = task();\n-    let b1 = task_builder({\n+    let b1 = TaskBuilder({\n         opts: { linked: true, supervised: true with b0.opts },\n         can_not_copy: none,\n         with *b0\n@@ -1571,7 +1576,7 @@ fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n     // We have to cheat with opts - the interface doesn't support them because\n     // they don't make sense (redundant with task().supervised()).\n     let b0 = task();\n-    let b1 = task_builder({\n+    let b1 = TaskBuilder({\n         opts: { linked: true, supervised: true with b0.opts },\n         can_not_copy: none,\n         with *b0\n@@ -1667,7 +1672,7 @@ fn test_spawn_raw_notify() {\n         comm::send(task_ch, get_task());\n     }\n     let task_ = comm::recv(task_po);\n-    assert comm::recv(notify_po) == exit(task_, success);\n+    assert comm::recv(notify_po) == Exit(task_, Success);\n \n     let opts = {\n         linked: false,\n@@ -1679,7 +1684,7 @@ fn test_spawn_raw_notify() {\n         fail;\n     }\n     let task_ = comm::recv(task_po);\n-    assert comm::recv(notify_po) == exit(task_, failure);\n+    assert comm::recv(notify_po) == Exit(task_, Failure);\n }\n \n #[test]\n@@ -1712,13 +1717,13 @@ fn test_add_wrapper() {\n fn test_future_result() {\n     let mut result = none;\n     do task().future_result(|+r| { result = some(r); }).spawn { }\n-    assert future::get(&option::unwrap(result)) == success;\n+    assert future::get(&option::unwrap(result)) == Success;\n \n     result = none;\n     do task().future_result(|+r| { result = some(r); }).unlinked().spawn {\n         fail;\n     }\n-    assert future::get(&option::unwrap(result)) == failure;\n+    assert future::get(&option::unwrap(result)) == Failure;\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -1779,18 +1784,18 @@ fn test_try_fail() {\n #[should_fail]\n #[ignore(cfg(windows))]\n fn test_spawn_sched_no_threads() {\n-    do spawn_sched(manual_threads(0u)) { }\n+    do spawn_sched(ManualThreads(0u)) { }\n }\n \n #[test]\n fn test_spawn_sched() {\n     let po = comm::port();\n     let ch = comm::chan(po);\n \n-    fn f(i: int, ch: comm::chan<()>) {\n+    fn f(i: int, ch: comm::Chan<()>) {\n         let parent_sched_id = rustrt::rust_get_sched_id();\n \n-        do spawn_sched(single_threaded) {\n+        do spawn_sched(SingleThreaded) {\n             let child_sched_id = rustrt::rust_get_sched_id();\n             assert parent_sched_id != child_sched_id;\n \n@@ -1811,7 +1816,7 @@ fn test_spawn_sched_childs_on_same_sched() {\n     let po = comm::port();\n     let ch = comm::chan(po);\n \n-    do spawn_sched(single_threaded) {\n+    do spawn_sched(SingleThreaded) {\n         let parent_sched_id = rustrt::rust_get_sched_id();\n         do spawn {\n             let child_sched_id = rustrt::rust_get_sched_id();\n@@ -1849,7 +1854,7 @@ fn test_spawn_sched_blocking() {\n \n         let lock = testrt::rust_dbg_lock_create();\n \n-        do spawn_sched(single_threaded) {\n+        do spawn_sched(SingleThreaded) {\n             testrt::rust_dbg_lock_lock(lock);\n \n             comm::send(start_ch, ());\n@@ -1864,7 +1869,7 @@ fn test_spawn_sched_blocking() {\n         // Wait until the other task has its lock\n         comm::recv(start_po);\n \n-        fn pingpong(po: comm::port<int>, ch: comm::chan<int>) {\n+        fn pingpong(po: comm::Port<int>, ch: comm::Chan<int>) {\n             let mut val = 20;\n             while val > 0 {\n                 val = comm::recv(po);\n@@ -1918,7 +1923,7 @@ fn test_avoid_copying_the_body_spawn() {\n #[test]\n fn test_avoid_copying_the_body_spawn_listener() {\n     do avoid_copying_the_body |f| {\n-        spawn_listener(fn~(move f, _po: comm::port<int>) {\n+        spawn_listener(fn~(move f, _po: comm::Port<int>) {\n             f();\n         });\n     }\n@@ -1936,7 +1941,7 @@ fn test_avoid_copying_the_body_task_spawn() {\n #[test]\n fn test_avoid_copying_the_body_spawn_listener_1() {\n     do avoid_copying_the_body |f| {\n-        task().spawn_listener(fn~(move f, _po: comm::port<int>) {\n+        task().spawn_listener(fn~(move f, _po: comm::Port<int>) {\n             f();\n         });\n     }\n@@ -1964,7 +1969,7 @@ fn test_avoid_copying_the_body_unlinked() {\n fn test_platform_thread() {\n     let po = comm::port();\n     let ch = comm::chan(po);\n-    do task().sched_mode(platform_thread).spawn {\n+    do task().sched_mode(PlatformThread).spawn {\n         comm::send(ch, ());\n     }\n     comm::recv(po);"}, {"sha": "b361e38ac29a95041079d6d29a5c2bff3b5d870d", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -245,7 +245,7 @@ mod v6 {\n }\n \n type get_addr_data = {\n-    output_ch: comm::chan<result::result<~[ip_addr],ip_get_addr_err>>\n+    output_ch: comm::Chan<result::result<~[ip_addr],ip_get_addr_err>>\n };\n \n extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,"}, {"sha": "e07075dd293c19e2f11da58f67eb699c1c0bfd67", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -292,7 +292,7 @@ fn write(sock: tcp_socket, raw_write_data: ~[u8])\n  * value as the `err` variant\n  */\n fn write_future(sock: tcp_socket, raw_write_data: ~[u8])\n-    -> future::future<result::result<(), tcp_err_data>> unsafe {\n+    -> future::Future<result::result<(), tcp_err_data>> unsafe {\n     let socket_data_ptr = ptr::addr_of(*(sock.socket_data));\n     do future_spawn {\n         let data_copy = copy(raw_write_data);\n@@ -315,7 +315,7 @@ fn write_future(sock: tcp_socket, raw_write_data: ~[u8])\n  * on) from until `read_stop` is called, or a `tcp_err_data` record\n  */\n fn read_start(sock: tcp_socket)\n-    -> result::result<comm::port<\n+    -> result::result<comm::Port<\n         result::result<~[u8], tcp_err_data>>, tcp_err_data> unsafe {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n     read_start_common_impl(socket_data)\n@@ -329,7 +329,7 @@ fn read_start(sock: tcp_socket)\n  * * `sock` - a `net::tcp::tcp_socket` that you wish to stop reading on\n  */\n fn read_stop(sock: tcp_socket,\n-             -read_port: comm::port<result::result<~[u8], tcp_err_data>>) ->\n+             -read_port: comm::Port<result::result<~[u8], tcp_err_data>>) ->\n     result::result<(), tcp_err_data> unsafe {\n     log(debug, fmt!{\"taking the read_port out of commission %?\", read_port});\n     let socket_data = ptr::addr_of(*sock.socket_data);\n@@ -387,7 +387,7 @@ fn read(sock: tcp_socket, timeout_msecs: uint)\n  * read attempt. Pass `0u` to wait indefinitely\n  */\n fn read_future(sock: tcp_socket, timeout_msecs: uint)\n-    -> future::future<result::result<~[u8],tcp_err_data>> {\n+    -> future::Future<result::result<~[u8],tcp_err_data>> {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n     do future_spawn {\n         read_common_impl(socket_data, timeout_msecs)\n@@ -563,9 +563,9 @@ fn accept(new_conn: tcp_new_connection)\n  */\n fn listen(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n           iotask: iotask,\n-          on_establish_cb: fn~(comm::chan<option<tcp_err_data>>),\n+          on_establish_cb: fn~(comm::Chan<option<tcp_err_data>>),\n           +new_connect_cb: fn~(tcp_new_connection,\n-                               comm::chan<option<tcp_err_data>>))\n+                               comm::Chan<option<tcp_err_data>>))\n     -> result::result<(), tcp_listen_err_data> unsafe {\n     do listen_common(host_ip, port, backlog, iotask, on_establish_cb)\n         // on_connect_cb\n@@ -580,7 +580,7 @@ fn listen(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n \n fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n           iotask: iotask,\n-          on_establish_cb: fn~(comm::chan<option<tcp_err_data>>),\n+          on_establish_cb: fn~(comm::Chan<option<tcp_err_data>>),\n           -on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n     -> result::result<(), tcp_listen_err_data> unsafe {\n     let stream_closed_po = comm::port::<()>();\n@@ -724,12 +724,12 @@ fn socket_buf(-sock: tcp_socket) -> tcp_socket_buf {\n \n /// Convenience methods extending `net::tcp::tcp_socket`\n impl tcp_socket {\n-    fn read_start() -> result::result<comm::port<\n+    fn read_start() -> result::result<comm::Port<\n         result::result<~[u8], tcp_err_data>>, tcp_err_data> {\n         read_start(self)\n     }\n     fn read_stop(-read_port:\n-                 comm::port<result::result<~[u8], tcp_err_data>>) ->\n+                 comm::Port<result::result<~[u8], tcp_err_data>>) ->\n         result::result<(), tcp_err_data> {\n         read_stop(self, read_port)\n     }\n@@ -738,15 +738,15 @@ impl tcp_socket {\n         read(self, timeout_msecs)\n     }\n     fn read_future(timeout_msecs: uint) ->\n-        future::future<result::result<~[u8], tcp_err_data>> {\n+        future::Future<result::result<~[u8], tcp_err_data>> {\n         read_future(self, timeout_msecs)\n     }\n     fn write(raw_write_data: ~[u8])\n         -> result::result<(), tcp_err_data> {\n         write(self, raw_write_data)\n     }\n     fn write_future(raw_write_data: ~[u8])\n-        -> future::future<result::result<(), tcp_err_data>> {\n+        -> future::Future<result::result<(), tcp_err_data>> {\n         write_future(self, raw_write_data)\n     }\n }\n@@ -922,7 +922,7 @@ fn read_stop_common_impl(socket_data: *tcp_socket_data) ->\n \n // shared impl for read_start\n fn read_start_common_impl(socket_data: *tcp_socket_data)\n-    -> result::result<comm::port<\n+    -> result::result<comm::Port<\n         result::result<~[u8], tcp_err_data>>, tcp_err_data> unsafe {\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n     let start_po = comm::port::<option<uv::ll::uv_err_data>>();\n@@ -1002,8 +1002,8 @@ enum tcp_new_connection {\n \n type tcp_listen_fc_data = {\n     server_stream_ptr: *uv::ll::uv_tcp_t,\n-    stream_closed_ch: comm::chan<()>,\n-    kill_ch: comm::chan<option<tcp_err_data>>,\n+    stream_closed_ch: comm::Chan<()>,\n+    kill_ch: comm::Chan<option<tcp_err_data>>,\n     on_connect_cb: fn~(*uv::ll::uv_tcp_t),\n     iotask: iotask,\n     mut active: bool\n@@ -1050,7 +1050,7 @@ enum tcp_write_result {\n }\n \n enum tcp_read_start_result {\n-    tcp_read_start_success(comm::port<tcp_read_result>),\n+    tcp_read_start_success(comm::Port<tcp_read_result>),\n     tcp_read_start_error(tcp_err_data)\n }\n \n@@ -1116,7 +1116,7 @@ extern fn on_alloc_cb(handle: *libc::c_void,\n }\n \n type tcp_socket_close_data = {\n-    closed_ch: comm::chan<()>\n+    closed_ch: comm::Chan<()>\n };\n \n extern fn tcp_socket_dtor_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n@@ -1145,12 +1145,12 @@ extern fn tcp_write_complete_cb(write_req: *uv::ll::uv_write_t,\n }\n \n type write_req_data = {\n-    result_ch: comm::chan<tcp_write_result>\n+    result_ch: comm::Chan<tcp_write_result>\n };\n \n type connect_req_data = {\n-    result_ch: comm::chan<conn_attempt>,\n-    closed_signal_ch: comm::chan<()>\n+    result_ch: comm::Chan<conn_attempt>,\n+    closed_signal_ch: comm::Chan<()>\n };\n \n extern fn stream_error_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n@@ -1198,8 +1198,8 @@ enum conn_attempt {\n }\n \n type tcp_socket_data = {\n-    reader_po: comm::port<result::result<~[u8], tcp_err_data>>,\n-    reader_ch: comm::chan<result::result<~[u8], tcp_err_data>>,\n+    reader_po: comm::Port<result::result<~[u8], tcp_err_data>>,\n+    reader_ch: comm::Chan<result::result<~[u8], tcp_err_data>>,\n     stream_handle_ptr: *uv::ll::uv_tcp_t,\n     connect_req: uv::ll::uv_connect_t,\n     write_req: uv::ll::uv_write_t,\n@@ -1285,7 +1285,7 @@ mod test {\n         let cont_po = comm::port::<()>();\n         let cont_ch = comm::chan(cont_po);\n         // server\n-        do task::spawn_sched(task::manual_threads(1u)) {\n+        do task::spawn_sched(task::ManualThreads(1u)) {\n             let actual_req = do comm::listen |server_ch| {\n                 run_tcp_test_server(\n                     server_ip,\n@@ -1351,7 +1351,7 @@ mod test {\n         let cont_po = comm::port::<()>();\n         let cont_ch = comm::chan(cont_po);\n         // server\n-        do task::spawn_sched(task::manual_threads(1u)) {\n+        do task::spawn_sched(task::ManualThreads(1u)) {\n             let actual_req = do comm::listen |server_ch| {\n                 run_tcp_test_server(\n                     server_ip,\n@@ -1421,7 +1421,7 @@ mod test {\n         let cont_po = comm::port::<()>();\n         let cont_ch = comm::chan(cont_po);\n         // server\n-        do task::spawn_sched(task::manual_threads(1u)) {\n+        do task::spawn_sched(task::ManualThreads(1u)) {\n             let actual_req = do comm::listen |server_ch| {\n                 run_tcp_test_server(\n                     server_ip,\n@@ -1475,8 +1475,8 @@ mod test {\n     }\n \n     fn run_tcp_test_server(server_ip: ~str, server_port: uint, resp: ~str,\n-                          server_ch: comm::chan<~str>,\n-                          cont_ch: comm::chan<()>,\n+                          server_ch: comm::Chan<~str>,\n+                          cont_ch: comm::Chan<()>,\n                           iotask: iotask) -> ~str {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n         let listen_result = listen(server_ip_addr, server_port, 128u, iotask,\n@@ -1491,7 +1491,7 @@ mod test {\n             |new_conn, kill_ch| {\n             log(debug, ~\"SERVER: new connection!\");\n             do comm::listen |cont_ch| {\n-                do task::spawn_sched(task::manual_threads(1u)) {\n+                do task::spawn_sched(task::ManualThreads(1u)) {\n                     log(debug, ~\"SERVER: starting worker for new req\");\n \n                     let accept_result = accept(new_conn);\n@@ -1582,7 +1582,7 @@ mod test {\n     }\n \n     fn run_tcp_test_client(server_ip: ~str, server_port: uint, resp: ~str,\n-                          client_ch: comm::chan<~str>,\n+                          client_ch: comm::Chan<~str>,\n                           iotask: iotask) -> result::result<~str,\n                                                     tcp_connect_err_data> {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);"}, {"sha": "1438e4ab180e30fb4783e55621c234025fd438ee", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -720,7 +720,7 @@ mod tests {\n     fn test_sem_runtime_friendly_blocking() {\n         // Force the runtime to schedule two threads on the same sched_loop.\n         // When one blocks, it should schedule the other one.\n-        do task::spawn_sched(task::manual_threads(1)) {\n+        do task::spawn_sched(task::ManualThreads(1)) {\n             let s = ~semaphore(1);\n             let s2 = ~s.clone();\n             let (c,p) = pipes::stream();"}, {"sha": "b61ad7e5a61e1d2f41b3a7e75a1566bd3e09e753", "filename": "src/libstd/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -9,7 +9,7 @@ import either::Either;\n import result::{ok, err};\n import io::WriterUtil;\n import libc::size_t;\n-import task::task_builder;\n+import task::TaskBuilder;\n \n export test_name;\n export test_fn;\n@@ -379,7 +379,7 @@ fn filter_tests(opts: test_opts,\n \n type test_future = {test: test_desc, wait: fn@() -> test_result};\n \n-fn run_test(+test: test_desc, monitor_ch: comm::chan<monitor_msg>) {\n+fn run_test(+test: test_desc, monitor_ch: comm::Chan<monitor_msg>) {\n     if test.ignore {\n         comm::send(monitor_ch, (copy test, tr_ignored));\n         return;\n@@ -392,7 +392,7 @@ fn run_test(+test: test_desc, monitor_ch: comm::chan<monitor_msg>) {\n             result_future = some(r);\n         }).spawn(testfn);\n         let task_result = future::get(&option::unwrap(result_future));\n-        let test_result = calc_result(test, task_result == task::success);\n+        let test_result = calc_result(test, task_result == task::Success);\n         comm::send(monitor_ch, (copy test, test_result));\n     };\n }"}, {"sha": "468a846163b25925f420ebdc9c4d577cd27f47ca", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -22,7 +22,7 @@ export delayed_send, sleep, recv_timeout;\n  * * val - a value of type T to send over the provided `ch`\n  */\n fn delayed_send<T: copy send>(iotask: iotask,\n-                              msecs: uint, ch: comm::chan<T>, val: T) {\n+                              msecs: uint, ch: comm::Chan<T>, val: T) {\n         unsafe {\n             let timer_done_po = comm::port::<()>();\n             let timer_done_ch = comm::chan(timer_done_po);\n@@ -99,7 +99,7 @@ fn sleep(iotask: iotask, msecs: uint) {\n  */\n fn recv_timeout<T: copy send>(iotask: iotask,\n                               msecs: uint,\n-                              wait_po: comm::port<T>) -> option<T> {\n+                              wait_po: comm::Port<T>) -> option<T> {\n     let timeout_po = comm::port::<()>();\n     let timeout_ch = comm::chan(timeout_po);\n     delayed_send(iotask, msecs, timeout_ch, ());\n@@ -120,7 +120,7 @@ extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n                                 status: libc::c_int) unsafe {\n     log(debug, fmt!{\"delayed_send_cb handle %? status %?\", handle, status});\n     let timer_done_ch =\n-        *(uv::ll::get_data_for_uv_handle(handle) as *comm::chan<()>);\n+        *(uv::ll::get_data_for_uv_handle(handle) as *comm::Chan<()>);\n     let stop_result = uv::ll::timer_stop(handle);\n     if (stop_result == 0i32) {\n         comm::send(timer_done_ch, ());\n@@ -136,7 +136,7 @@ extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n extern fn delayed_send_close_cb(handle: *uv::ll::uv_timer_t) unsafe {\n     log(debug, fmt!{\"delayed_send_close_cb handle %?\", handle});\n     let timer_done_ch =\n-        *(uv::ll::get_data_for_uv_handle(handle) as *comm::chan<()>);\n+        *(uv::ll::get_data_for_uv_handle(handle) as *comm::Chan<()>);\n     comm::send(timer_done_ch, ());\n }\n "}, {"sha": "b28b0033a017ee326a8a35cce4d3f3b3c68b5903", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -7,8 +7,8 @@ import iotask = uv_iotask;\n import get_gl = get;\n import iotask::{iotask, spawn_iotask};\n import priv::{chan_from_global_ptr, weaken_task};\n-import comm::{port, chan, select2, listen};\n-import task::task_builder;\n+import comm::{Port, Chan, port, chan, select2, listen};\n+import task::TaskBuilder;\n import either::{Left, Right};\n \n extern mod rustrt {\n@@ -40,13 +40,13 @@ fn get_monitor_task_gl() -> iotask unsafe {\n            monitor_loop_chan_ptr};\n \n     debug!{\"before priv::chan_from_global_ptr\"};\n-    type monchan = chan<iotask>;\n+    type monchan = Chan<iotask>;\n \n     let monitor_ch =\n         do chan_from_global_ptr::<monchan>(monitor_loop_chan_ptr,\n                                            || {\n                                                 task::task().sched_mode\n-                                                (task::single_threaded)\n+                                                (task::SingleThreaded)\n                                                 .unlinked()\n                                            }) |msg_po| {\n         debug!{\"global monitor task starting\"};\n@@ -108,7 +108,7 @@ fn spawn_loop() -> iotask unsafe {\n mod test {\n     extern fn simple_timer_close_cb(timer_ptr: *ll::uv_timer_t) unsafe {\n         let exit_ch_ptr = ll::get_data_for_uv_handle(\n-            timer_ptr as *libc::c_void) as *comm::chan<bool>;\n+            timer_ptr as *libc::c_void) as *comm::Chan<bool>;\n         let exit_ch = *exit_ch_ptr;\n         comm::send(exit_ch, true);\n         log(debug, fmt!{\"EXIT_CH_PTR simple_timer_close_cb exit_ch_ptr: %?\",\n@@ -164,7 +164,7 @@ mod test {\n         let hl_loop = get_gl();\n         let exit_po = comm::port::<()>();\n         let exit_ch = comm::chan(exit_po);\n-        task::spawn_sched(task::manual_threads(1u), || {\n+        task::spawn_sched(task::ManualThreads(1u), || {\n             impl_uv_hl_simple_timer(hl_loop);\n             comm::send(exit_ch, ());\n         });\n@@ -182,7 +182,7 @@ mod test {\n         let exit_ch = comm::chan(exit_po);\n         let cycles = 5000u;\n         for iter::repeat(cycles) {\n-            task::spawn_sched(task::manual_threads(1u), || {\n+            task::spawn_sched(task::ManualThreads(1u), || {\n                 impl_uv_hl_simple_timer(hl_loop);\n                 comm::send(exit_ch, ());\n             });"}, {"sha": "dd7063e4c9ba728a55daa85f505760f1a0dd2c63", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -12,23 +12,23 @@ export exit;\n \n import libc::c_void;\n import ptr::addr_of;\n-import comm::{port, chan, listen};\n-import task::task_builder;\n+import comm::{Port, port, Chan, chan, listen};\n+import task::TaskBuilder;\n import ll = uv_ll;\n \n /// Used to abstract-away direct interaction with a libuv loop.\n enum iotask {\n     iotask_({\n         async_handle: *ll::uv_async_t,\n-        op_chan: chan<iotask_msg>\n+        op_chan: Chan<iotask_msg>\n     })\n }\n \n-fn spawn_iotask(-task: task::task_builder) -> iotask {\n+fn spawn_iotask(-task: task::TaskBuilder) -> iotask {\n \n     do listen |iotask_ch| {\n \n-        do task.sched_mode(task::single_threaded).spawn {\n+        do task.sched_mode(task::SingleThreaded).spawn {\n             debug!{\"entering libuv task\"};\n             run_loop(iotask_ch);\n             debug!{\"libuv task exiting\"};\n@@ -86,7 +86,7 @@ enum iotask_msg {\n }\n \n /// Run the loop and begin handling messages\n-fn run_loop(iotask_ch: chan<iotask>) unsafe {\n+fn run_loop(iotask_ch: Chan<iotask>) unsafe {\n \n     let loop_ptr = ll::loop_new();\n \n@@ -123,7 +123,7 @@ fn run_loop(iotask_ch: chan<iotask>) unsafe {\n // data that lives for the lifetime of the high-evel oo\n type iotask_loop_data = {\n     async_handle: *ll::uv_async_t,\n-    msg_po: port<iotask_msg>\n+    msg_po: Port<iotask_msg>\n };\n \n fn send_msg(iotask: iotask,\n@@ -180,7 +180,7 @@ mod test {\n     }\n     type ah_data = {\n         iotask: iotask,\n-        exit_ch: comm::chan<()>\n+        exit_ch: comm::Chan<()>\n     };\n     fn impl_uv_iotask_async(iotask: iotask) unsafe {\n         let async_handle = ll::async_t();\n@@ -202,10 +202,10 @@ mod test {\n \n     // this fn documents the bear minimum neccesary to roll your own\n     // high_level_loop\n-    unsafe fn spawn_test_loop(exit_ch: comm::chan<()>) -> iotask {\n+    unsafe fn spawn_test_loop(exit_ch: comm::Chan<()>) -> iotask {\n         let iotask_port = comm::port::<iotask>();\n         let iotask_ch = comm::chan(iotask_port);\n-        do task::spawn_sched(task::manual_threads(1u)) {\n+        do task::spawn_sched(task::ManualThreads(1u)) {\n             run_loop(iotask_ch);\n             exit_ch.send(());\n         };\n@@ -237,7 +237,7 @@ mod test {\n         let work_exit_po = comm::port::<()>();\n         let work_exit_ch = comm::chan(work_exit_po);\n         for iter::repeat(7u) {\n-            do task::spawn_sched(task::manual_threads(1u)) {\n+            do task::spawn_sched(task::ManualThreads(1u)) {\n                 impl_uv_iotask_async(iotask);\n                 comm::send(work_exit_ch, ());\n             };"}, {"sha": "c4c9d7c460764f0f811f2931eafbc590172b3e3b", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -1008,7 +1008,7 @@ mod test {\n     type request_wrapper = {\n         write_req: *uv_write_t,\n         req_buf: *~[uv_buf_t],\n-        read_chan: *comm::chan<~str>\n+        read_chan: *comm::Chan<~str>\n     };\n \n     extern fn after_close_cb(handle: *libc::c_void) {\n@@ -1106,7 +1106,7 @@ mod test {\n     }\n \n     fn impl_uv_tcp_request(ip: ~str, port: int, req_str: ~str,\n-                          client_chan: *comm::chan<~str>) unsafe {\n+                          client_chan: *comm::Chan<~str>) unsafe {\n         let test_loop = loop_new();\n         let tcp_handle = tcp_t();\n         let tcp_handle_ptr = ptr::addr_of(tcp_handle);\n@@ -1323,12 +1323,12 @@ mod test {\n         server: *uv_tcp_t,\n         server_kill_msg: ~str,\n         server_resp_buf: *~[uv_buf_t],\n-        server_chan: *comm::chan<~str>,\n+        server_chan: *comm::Chan<~str>,\n         server_write_req: *uv_write_t\n     };\n \n     type async_handle_data = {\n-        continue_chan: *comm::chan<bool>\n+        continue_chan: *comm::Chan<bool>\n     };\n \n     extern fn async_close_cb(handle: *libc::c_void) {\n@@ -1354,8 +1354,8 @@ mod test {\n                           server_port: int,\n                           kill_server_msg: ~str,\n                           server_resp_msg: ~str,\n-                          server_chan: *comm::chan<~str>,\n-                          continue_chan: *comm::chan<bool>) unsafe {\n+                          server_chan: *comm::Chan<~str>,\n+                          continue_chan: *comm::Chan<bool>) unsafe {\n         let test_loop = loop_new();\n         let tcp_server = tcp_t();\n         let tcp_server_ptr = ptr::addr_of(tcp_server);\n@@ -1469,7 +1469,7 @@ mod test {\n         let continue_chan = comm::chan::<bool>(continue_port);\n         let continue_chan_ptr = ptr::addr_of(continue_chan);\n \n-        do task::spawn_sched(task::manual_threads(1u)) {\n+        do task::spawn_sched(task::ManualThreads(1u)) {\n             impl_uv_tcp_server(bind_ip, port,\n                                kill_server_msg,\n                                server_resp_msg,\n@@ -1482,7 +1482,7 @@ mod test {\n         comm::recv(continue_port);\n         log(debug, ~\"received on continue port, set up tcp client\");\n \n-        do task::spawn_sched(task::manual_threads(1u)) {\n+        do task::spawn_sched(task::ManualThreads(1u)) {\n             impl_uv_tcp_request(request_ip, port,\n                                kill_server_msg,\n                                ptr::addr_of(client_chan));"}, {"sha": "134af84866e5bfae7354aa4791d4a4a8c7021dca", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -231,8 +231,8 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n         };\n \n         class finally {\n-            let ch: comm::chan<monitor_msg>;\n-            new(ch: comm::chan<monitor_msg>) { self.ch = ch; }\n+            let ch: comm::Chan<monitor_msg>;\n+            new(ch: comm::Chan<monitor_msg>) { self.ch = ch; }\n             drop { comm::send(self.ch, done); }\n         }\n "}, {"sha": "3dd029f2307de72d1bb32c0d73cf0ff88d3ebfa2", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -43,7 +43,7 @@ enum msg {\n }\n \n enum srv = {\n-    ch: comm::chan<msg>\n+    ch: comm::Chan<msg>\n };\n \n fn from_str<T>(source: ~str, owner: srv_owner<T>) -> T {\n@@ -67,7 +67,7 @@ fn run<T>(owner: srv_owner<T>, source: ~str, +parse: parser) -> T {\n     return res;\n }\n \n-fn act(po: comm::port<msg>, source: ~str, parse: parser) {\n+fn act(po: comm::Port<msg>, source: ~str, parse: parser) {\n     let sess = build_session();\n \n     let ctxt = build_ctxt("}, {"sha": "20435a1cef46d142802d883e21fd716350b24483", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -110,14 +110,14 @@ fn pandoc_writer(\n \n         let stdout_po = comm::port();\n         let stdout_ch = comm::chan(stdout_po);\n-        do task::spawn_sched(task::single_threaded) {\n+        do task::spawn_sched(task::SingleThreaded) {\n             comm::send(stdout_ch, readclose(pipe_out.in));\n         }\n         let stdout = comm::recv(stdout_po);\n \n         let stderr_po = comm::port();\n         let stderr_ch = comm::chan(stderr_po);\n-        do task::spawn_sched(task::single_threaded) {\n+        do task::spawn_sched(task::SingleThreaded) {\n             comm::send(stderr_ch, readclose(pipe_err.in));\n         }\n         let stderr = comm::recv(stderr_po);\n@@ -146,7 +146,7 @@ fn readclose(fd: libc::c_int) -> ~str {\n }\n \n fn generic_writer(+process: fn~(markdown: ~str)) -> writer {\n-    let ch = do task::spawn_listener |po: comm::port<writeinstr>| {\n+    let ch = do task::spawn_listener |po: comm::Port<writeinstr>| {\n         let mut markdown = ~\"\";\n         let mut keep_going = true;\n         while keep_going {\n@@ -265,7 +265,7 @@ fn write_file(path: ~str, s: ~str) {\n }\n \n fn future_writer_factory(\n-) -> (writer_factory, comm::port<(doc::page, ~str)>) {\n+) -> (writer_factory, comm::Port<(doc::page, ~str)>) {\n     let markdown_po = comm::port();\n     let markdown_ch = comm::chan(markdown_po);\n     let writer_factory = fn~(page: doc::page) -> writer {\n@@ -283,7 +283,7 @@ fn future_writer_factory(\n     (writer_factory, markdown_po)\n }\n \n-fn future_writer() -> (writer, future::future<~str>) {\n+fn future_writer() -> (writer, future::Future<~str>) {\n     let port = comm::port();\n     let chan = comm::chan(port);\n     let writer = fn~(+instr: writeinstr) {"}, {"sha": "24d9bbc0c7b42b4ed1a09d55e0ae38feaa4bdbc6", "filename": "src/rustdoc/page_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Frustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Frustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpage_pass.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -38,8 +38,8 @@ fn run(\n     comm::recv(result_port)\n }\n \n-type page_port = comm::port<option<doc::page>>;\n-type page_chan = comm::chan<option<doc::page>>;\n+type page_port = comm::Port<option<doc::page>>;\n+type page_chan = comm::Chan<option<doc::page>>;\n \n fn make_doc_from_pages(page_port: page_port) -> doc::doc {\n     let mut pages = ~[];"}, {"sha": "b4dda9cf5e2119ec5f66434a4b7d2c14b314d646", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -2,7 +2,7 @@ export foo;\n \n import comm::*;\n \n-fn foo<T: send copy>(x: T) -> port<T> {\n+fn foo<T: send copy>(x: T) -> Port<T> {\n     let p = port();\n     let c = chan(p);\n     do task::spawn() |copy c, copy x| {"}, {"sha": "418ea3e538f242f806a5b20b1981292aed05e88b", "filename": "src/test/bench/msgsend-ring.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -12,8 +12,8 @@ import std::time;\n \n fn thread_ring(i: uint,\n                count: uint,\n-               num_chan: comm::chan<uint>,\n-               num_port: comm::port<uint>) {\n+               num_chan: comm::Chan<uint>,\n+               num_port: comm::Port<uint>) {\n     // Send/Receive lots of messages.\n     for uint::range(0u, count) |j| {\n         num_chan.send(i * j);"}, {"sha": "507515678220baee5f8e0a219f762829b1667b66", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -14,7 +14,7 @@ enum request {\n     stop\n }\n \n-fn server(requests: comm::port<request>, responses: comm::chan<uint>) {\n+fn server(requests: comm::Port<request>, responses: comm::Chan<uint>) {\n     let mut count = 0u;\n     let mut done = false;\n     while !done {"}, {"sha": "05fdf0fb709541c5658d3b3f6c932595c0b31c5c", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -85,9 +85,9 @@ fn transform(aa: color, bb: color) -> color {\n fn creature(\n     name: uint,\n     color: color,\n-    from_rendezvous: comm::port<option<creature_info>>,\n-    to_rendezvous: comm::chan<creature_info>,\n-    to_rendezvous_log: comm::chan<~str>\n+    from_rendezvous: comm::Port<option<creature_info>>,\n+    to_rendezvous: comm::Chan<creature_info>,\n+    to_rendezvous_log: comm::Chan<~str>\n ) {\n     let mut color = color;\n     let mut creatures_met = 0;\n@@ -122,17 +122,17 @@ fn creature(\n \n fn rendezvous(nn: uint, set: ~[color]) {\n     // these ports will allow us to hear from the creatures\n-    let from_creatures:     comm::port<creature_info> = comm::port();\n-    let from_creatures_log: comm::port<~str> = comm::port();\n+    let from_creatures:     comm::Port<creature_info> = comm::port();\n+    let from_creatures_log: comm::Port<~str> = comm::port();\n \n     // these channels will be passed to the creatures so they can talk to us\n     let to_rendezvous     = comm::chan(from_creatures);\n     let to_rendezvous_log = comm::chan(from_creatures_log);\n \n     // these channels will allow us to talk to each creature by 'name'/index\n-    let to_creature: ~[comm::chan<option<creature_info>>] =\n+    let to_creature: ~[comm::Chan<option<creature_info>>] =\n         vec::mapi(set,\n-            fn@(ii: uint, col: color) -> comm::chan<option<creature_info>> {\n+            fn@(ii: uint, col: color) -> comm::Chan<option<creature_info>> {\n                 // create each creature as a listener with a port, and\n                 // give us a channel to talk to each\n                 return do task::spawn_listener |from_rendezvous| {"}, {"sha": "467df1148df27deda3433f87007b52a74f6c2b0d", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -86,8 +86,8 @@ fn windows_with_carry(bb: &[u8], nn: uint,\n    return vec::slice(bb, len - (nn - 1u), len); \n }\n \n-fn make_sequence_processor(sz: uint, from_parent: comm::port<~[u8]>,\n-                           to_parent: comm::chan<~str>) {\n+fn make_sequence_processor(sz: uint, from_parent: comm::Port<~[u8]>,\n+                           to_parent: comm::Chan<~str>) {\n    \n    let freqs: hashmap<~[u8], uint> = map::bytes_hash();\n    let mut carry: ~[u8] = ~[];\n@@ -141,7 +141,7 @@ fn main(args: ~[~str]) {\n    let sizes = ~[1u,2u,3u,4u,6u,12u,18u];\n    let from_child = vec::map (sizes, |_sz| comm::port() );\n    let to_parent  = vec::mapi(sizes, |ii, _sz| comm::chan(from_child[ii]) );\n-   let to_child   = vec::mapi(sizes, fn@(ii: uint, sz: uint) -> comm::chan<~[u8]> {\n+   let to_child   = vec::mapi(sizes, fn@(ii: uint, sz: uint) -> comm::Chan<~[u8]> {\n        return do task::spawn_listener |from_parent| {\n          make_sequence_processor(sz, from_parent, to_parent[ii]);\n       };"}, {"sha": "252832f0cb758ba5895b6097fb275b1ceac03666", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -75,7 +75,7 @@ fn fillbyte(x: cmplx, incr: f64) -> u8 {\n     rv\n }\n \n-fn chanmb(i: uint, size: uint, ch: comm::chan<line>) -> ()\n+fn chanmb(i: uint, size: uint, ch: comm::Chan<line>) -> ()\n {\n     let mut crv = ~[];\n     let incr = 2f64/(size as f64);\n@@ -98,9 +98,9 @@ impl devnull: io::Writer {\n     fn get_type() -> io::WriterType { io::File }\n }\n \n-fn writer(path: ~str, writech: comm::chan<comm::chan<line>>, size: uint)\n+fn writer(path: ~str, writech: comm::Chan<comm::Chan<line>>, size: uint)\n {\n-    let p: comm::port<line> = comm::port();\n+    let p: comm::Port<line> = comm::port();\n     let ch = comm::chan(p);\n     comm::send(writech, ch);\n     let cout: io::Writer = match path {"}, {"sha": "f3b1850c88c39c0593a1269c6e4e857731c3a684", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -19,7 +19,7 @@ fn start(+token: int) {\n     roundtrip(1, p, ch);\n }\n \n-fn roundtrip(id: int, p: comm::port<int>, ch: comm::chan<int>) {\n+fn roundtrip(id: int, p: comm::Port<int>, ch: comm::Chan<int>) {\n     while (true) {\n         match comm::recv(p) {\n           1 => {"}, {"sha": "0b50195457e3cc2a3f553846b7373f69026316b3", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -34,7 +34,7 @@ fn spawn_supervised_blocking(myname: &str, +f: fn~()) {\n     task::task().future_result(|+r| res = some(r)).supervised().spawn(f);\n     #error[\"%s group waiting\", myname];\n     let x = future::get(&option::unwrap(res));\n-    assert x == task::success;\n+    assert x == task::Success;\n }\n \n fn main(args: ~[~str]) {"}, {"sha": "2b854f83b6710af7f054fd589f65e14a60437716", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -1,12 +1,12 @@\n // Test for concurrent tasks\n \n enum msg {\n-    ready(comm::chan<msg>),\n+    ready(comm::Chan<msg>),\n     start,\n     done(int),\n }\n \n-fn calc(children: uint, parent_ch: comm::chan<msg>) {\n+fn calc(children: uint, parent_ch: comm::Chan<msg>) {\n     let port = comm::port();\n     let chan = comm::chan(port);\n     let mut child_chs = ~[];"}, {"sha": "7e8084adb7de9031207ea64828865e230dfc239d", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -27,7 +27,9 @@ import u64;\n \n import task;\n import comm;\n+import comm::Chan;\n import comm::chan;\n+import comm::Port;\n import comm::port;\n import comm::recv;\n import comm::send;\n@@ -58,7 +60,7 @@ impl ~str: hash_key {\n }\n \n // These used to be in task, but they disappeard.\n-type joinable_task = port<()>;\n+type joinable_task = Port<()>;\n fn spawn_joinable(+f: fn~()) -> joinable_task {\n     let p = port();\n     let c = chan(p);\n@@ -135,7 +137,7 @@ mod map_reduce {\n     type reducer<K: copy send, V: copy send> = fn~(K, getter<V>);\n \n     enum ctrl_proto<K: copy send, V: copy send> {\n-        find_reducer(K, chan<chan<reduce_proto<V>>>),\n+        find_reducer(K, Chan<Chan<reduce_proto<V>>>),\n         mapper_done\n     }\n \n@@ -147,7 +149,7 @@ mod map_reduce {\n         }\n \n         reducer_response: recv<K: copy send, V: copy send> {\n-            reducer(chan<reduce_proto<V>>) -> open<K, V>\n+            reducer(Chan<reduce_proto<V>>) -> open<K, V>\n         }\n     }\n \n@@ -199,7 +201,7 @@ mod map_reduce {\n             send(c.get(), emit_val(val));\n         }\n \n-        fn finish<K: copy send, V: copy send>(_k: K, v: chan<reduce_proto<V>>)\n+        fn finish<K: copy send, V: copy send>(_k: K, v: Chan<reduce_proto<V>>)\n         {\n             send(v, release);\n         }\n@@ -210,7 +212,7 @@ mod map_reduce {\n     fn reduce_task<K: copy send, V: copy send>(\n         reduce: reducer<K, V>, \n         key: K,\n-        out: chan<chan<reduce_proto<V>>>)\n+        out: Chan<Chan<reduce_proto<V>>>)\n     {\n         let p = port();\n \n@@ -219,7 +221,7 @@ mod map_reduce {\n         let mut ref_count = 0;\n         let mut is_done = false;\n \n-        fn get<V: copy send>(p: port<reduce_proto<V>>,\n+        fn get<V: copy send>(p: Port<reduce_proto<V>>,\n                              &ref_count: int, &is_done: bool)\n            -> option<V> {\n             while !is_done || ref_count > 0 {"}, {"sha": "5ef4cc9fe73cb4fe4b40eb6e69f2850df3838d46", "filename": "src/test/compile-fail/fully-qualified-type-name4.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name4.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -1,10 +1,10 @@\n // Test that we use fully-qualified type names in error messages.\n \n-import core::task::task;\n+import core::task::Task;\n \n-fn bar(x: uint) -> task {\n+fn bar(x: uint) -> Task {\n     return x;\n-    //~^ ERROR mismatched types: expected `core::task::task`\n+    //~^ ERROR mismatched types: expected `core::task::Task`\n }\n \n fn main() {"}, {"sha": "a62278cefe1487167d2400adda082f8ac91fb564", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -1,7 +1,7 @@\n fn main() {\n     class foo {\n-      let _x: comm::port<()>;\n-      new(x: comm::port<()>) { self._x = x; }\n+      let _x: comm::Port<()>;\n+      new(x: comm::Port<()>) { self._x = x; }\n       drop {}\n     }\n    "}, {"sha": "835fc7acba466517c101a599161c5da6a4baad18", "filename": "src/test/run-fail/port-type.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-fail%2Fport-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-fail%2Fport-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fport-type.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -1,11 +1,12 @@\n // error-pattern:meep\n use std;\n+import comm::Chan;\n import comm::chan;\n import comm::port;\n import comm::send;\n import comm::recv;\n \n-fn echo<T: send>(c: chan<T>, oc: chan<chan<T>>) {\n+fn echo<T: send>(c: Chan<T>, oc: Chan<Chan<T>>) {\n     // Tests that the type argument in port gets\n     // visited\n     let p = port::<T>();"}, {"sha": "862020b65548cda7d7acd88318ae407f01228ebd", "filename": "src/test/run-pass/basic-1.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-1.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -1,13 +1,14 @@\n // -*- rust -*-\n \n use std;\n+import comm::Chan;\n import comm::chan;\n import comm::port;\n import comm::send;\n import comm::recv;\n import task;\n \n-fn a(c: chan<int>) { send(c, 10); }\n+fn a(c: Chan<int>) { send(c, 10); }\n \n fn main() {\n     let p = port();\n@@ -20,7 +21,7 @@ fn main() {\n     //    debug!{\"Finished.\"};\n }\n \n-fn b(c: chan<int>) {\n+fn b(c: Chan<int>) {\n     //    debug!{\"task b0\"};\n     //    debug!{\"task b1\"};\n     //    debug!{\"task b2\"};"}, {"sha": "ae884c9c6d5a6029ea2c6c47a0483208895f7ab9", "filename": "src/test/run-pass/basic-2.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-2.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -4,11 +4,12 @@ use std;\n import comm;\n import comm::port;\n import comm::send;\n+import comm::Chan;\n import comm::chan;\n import comm::recv;\n import task;\n \n-fn a(c: chan<int>) { debug!{\"task a0\"}; debug!{\"task a1\"}; send(c, 10); }\n+fn a(c: Chan<int>) { debug!{\"task a0\"}; debug!{\"task a1\"}; send(c, 10); }\n \n fn main() {\n     let p = port();\n@@ -21,7 +22,7 @@ fn main() {\n     debug!{\"Finished.\"};\n }\n \n-fn b(c: chan<int>) {\n+fn b(c: Chan<int>) {\n     debug!{\"task b0\"};\n     debug!{\"task b1\"};\n     debug!{\"task b2\"};"}, {"sha": "f3ebfa389045e38d80a6de00e032a02ed1c1ff6a", "filename": "src/test/run-pass/basic.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -3,11 +3,12 @@\n use std;\n import comm;\n import comm::send;\n+import comm::Chan;\n import comm::chan;\n import comm::recv;\n import task;\n \n-fn a(c: chan<int>) {\n+fn a(c: Chan<int>) {\n     if true {\n         debug!{\"task a\"};\n         debug!{\"task a\"};\n@@ -42,7 +43,7 @@ fn main() {\n     debug!{\"children finished, root finishing\"};\n }\n \n-fn b(c: chan<int>) {\n+fn b(c: Chan<int>) {\n     if true {\n         debug!{\"task b\"};\n         debug!{\"task b\"};"}, {"sha": "d8909290ae49cdb23c5a274fe43165a507373a60", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -68,7 +68,7 @@ fn test_port() {\n }\n \n fn test_chan() {\n-    let p: comm::port<int> = comm::port();\n+    let p: comm::Port<int> = comm::port();\n     let ch1 = comm::chan(p);\n     let ch2 = comm::chan(p);\n "}, {"sha": "8902bcaf537d2b6a84424db1042856c5cad5ffb9", "filename": "src/test/run-pass/chan-leak.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fchan-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fchan-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchan-leak.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -2,17 +2,18 @@\n \n use std;\n import task;\n+import comm::Chan;\n import comm::chan;\n import comm::send;\n import comm;\n import comm::port;\n import comm::recv;\n \n-enum request { quit, close(chan<bool>), }\n+enum request { quit, close(Chan<bool>), }\n \n-type ctx = chan<request>;\n+type ctx = Chan<request>;\n \n-fn request_task(c: chan<ctx>) {\n+fn request_task(c: Chan<ctx>) {\n     let p = port();\n     send(c, chan(p));\n     let mut req: request;"}, {"sha": "e84b844a1ea72b0ec9b11e1a29d1634fc937ec2f", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -2,6 +2,7 @@\n \n use std;\n import comm;\n+import comm::Chan;\n import comm::chan;\n import comm::send;\n import comm::recv;\n@@ -17,7 +18,7 @@ fn main() {\n     assert (y == 10);\n }\n \n-fn child(c: chan<int>) {\n+fn child(c: Chan<int>) {\n     error!{\"sending\"};\n     send(c, 10);\n     error!{\"value sent\"};"}, {"sha": "6d54dd37ef6d187dc6bb2dae4f2ad206b4858e62", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -14,6 +14,7 @@ import vec;\n import std::map;\n import std::map::hashmap;\n import task;\n+import comm::Chan;\n import comm::chan;\n import comm::port;\n import comm::send;\n@@ -31,18 +32,18 @@ mod map_reduce {\n \n     type mapper = extern fn(~str, putter);\n \n-    enum ctrl_proto { find_reducer(~[u8], chan<int>), mapper_done, }\n+    enum ctrl_proto { find_reducer(~[u8], Chan<int>), mapper_done, }\n \n-    fn start_mappers(ctrl: chan<ctrl_proto>, inputs: ~[~str]) {\n+    fn start_mappers(ctrl: Chan<ctrl_proto>, inputs: ~[~str]) {\n         for inputs.each |i| {\n             task::spawn(|| map_task(ctrl, i) );\n         }\n     }\n \n-    fn map_task(ctrl: chan<ctrl_proto>, input: ~str) {\n+    fn map_task(ctrl: Chan<ctrl_proto>, input: ~str) {\n         let intermediates = map::str_hash();\n \n-        fn emit(im: map::hashmap<~str, int>, ctrl: chan<ctrl_proto>, key: ~str,\n+        fn emit(im: map::hashmap<~str, int>, ctrl: Chan<ctrl_proto>, key: ~str,\n                 val: ~str) {\n             let mut c;\n             match im.find(key) {"}, {"sha": "a55024097a083f5d3dd2776311a1113bb6769ae6", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -10,14 +10,14 @@ mod pipes {\n \n     type packet<T: send> = {\n         mut state: state,\n-        mut blocked_task: option<task::task>,\n+        mut blocked_task: option<task::Task>,\n         mut payload: option<T>\n     };\n \n     fn packet<T: send>() -> *packet<T> unsafe {\n         let p: *packet<T> = unsafe::transmute(~{\n             mut state: empty,\n-            mut blocked_task: none::<task::task>,\n+            mut blocked_task: none::<task::Task>,\n             mut payload: none::<T>\n         });\n         p"}, {"sha": "4fec03ff711c48446d3bc64ad2df22a7225466e6", "filename": "src/test/run-pass/issue-507.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fissue-507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fissue-507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-507.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -9,14 +9,15 @@ use std;\n \n import task;\n import comm;\n+import comm::Chan;\n import comm::chan;\n import comm::send;\n import comm::port;\n import comm::recv;\n \n-fn grandchild(c: chan<int>) { send(c, 42); }\n+fn grandchild(c: Chan<int>) { send(c, 42); }\n \n-fn child(c: chan<int>) {\n+fn child(c: Chan<int>) {\n     task::spawn(|| grandchild(c) )\n }\n "}, {"sha": "1738f45c6a8fd025d4049fd52eda050a6f1a8d62", "filename": "src/test/run-pass/issue-687.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fissue-687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fissue-687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-687.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -2,21 +2,23 @@ use std;\n import vec;\n import task;\n import comm;\n+import comm::Chan;\n import comm::chan;\n+import comm::Port;\n import comm::port;\n import comm::recv;\n import comm::send;\n \n enum msg { closed, received(~[u8]), }\n \n-fn producer(c: chan<~[u8]>) {\n+fn producer(c: Chan<~[u8]>) {\n     send(c, ~[1u8, 2u8, 3u8, 4u8]);\n     let empty: ~[u8] = ~[];\n     send(c, empty);\n }\n \n-fn packager(cb: chan<chan<~[u8]>>, msg: chan<msg>) {\n-    let p: port<~[u8]> = port();\n+fn packager(cb: Chan<Chan<~[u8]>>, msg: Chan<msg>) {\n+    let p: Port<~[u8]> = port();\n     send(cb, chan(p));\n     loop {\n         debug!{\"waiting for bytes\"};\n@@ -37,13 +39,13 @@ fn packager(cb: chan<chan<~[u8]>>, msg: chan<msg>) {\n }\n \n fn main() {\n-    let p: port<msg> = port();\n+    let p: Port<msg> = port();\n     let ch = chan(p);\n-    let recv_reader: port<chan<~[u8]>> = port();\n+    let recv_reader: Port<Chan<~[u8]>> = port();\n     let recv_reader_chan = chan(recv_reader);\n     let pack = task::spawn(|| packager(recv_reader_chan, ch) );\n \n-    let source_chan: chan<~[u8]> = recv(recv_reader);\n+    let source_chan: Chan<~[u8]> = recv(recv_reader);\n     let prod = task::spawn(|| producer(source_chan) );\n \n     loop {"}, {"sha": "5a970c46ec2fa01234f29067fd3b5aee0a946f70", "filename": "src/test/run-pass/issue-783.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fissue-783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fissue-783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-783.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -4,7 +4,7 @@ import task::*;\n \n fn a() {\n     fn doit() {\n-        fn b(c: chan<chan<int>>) {\n+        fn b(c: Chan<Chan<int>>) {\n             let p = port();\n             send(c, chan(p));\n         }"}, {"sha": "85ac1a01019548e5c8096852c574f80aec5b4671", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -2,19 +2,21 @@ use std;\n \n import task;\n import comm;\n+import comm::Chan;\n import comm::chan;\n+import comm::Port;\n import comm::port;\n import comm::send;\n import comm::recv;\n \n-fn producer(c: chan<~[u8]>) {\n+fn producer(c: Chan<~[u8]>) {\n     send(c,\n          ~[1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8,\n           13u8]);\n }\n \n fn main() {\n-    let p: port<~[u8]> = port();\n+    let p: Port<~[u8]> = port();\n     let ch = chan(p);\n     let prod = task::spawn(|| producer(ch) );\n "}, {"sha": "c8c532e1018586827827d4a4dcc65fe05411eb2b", "filename": "src/test/run-pass/lazychan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Flazychan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Flazychan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazychan.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -22,4 +22,4 @@ fn main() {\n     assert (y == 10);\n }\n \n-fn child(c: chan<int>) { send(c, 10); }\n+fn child(c: Chan<int>) { send(c, 10); }"}, {"sha": "dde39ae37ed3a882375f36549bce772ec4d331f0", "filename": "src/test/run-pass/many.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fmany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fmany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmany.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -4,7 +4,7 @@ use std;\n import task;\n import comm;\n \n-fn sub(parent: comm::chan<int>, id: int) {\n+fn sub(parent: comm::Chan<int>, id: int) {\n     if id == 0 {\n         comm::send(parent, 0);\n     } else {"}, {"sha": "1878dd4618730d93d762fc941f926f506a9f023d", "filename": "src/test/run-pass/platform_thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fplatform_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fplatform_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fplatform_thread.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -14,9 +14,9 @@ fn run(i: int) {\n         return;\n     }\n \n-    do task::task().sched_mode(task::platform_thread).unlinked().spawn {\n+    do task::task().sched_mode(task::PlatformThread).unlinked().spawn {\n         task::yield();\n-        do task::task().sched_mode(task::single_threaded).unlinked().spawn {\n+        do task::task().sched_mode(task::SingleThreaded).unlinked().spawn {\n             task::yield();\n             run(i - 1);\n             task::yield();"}, {"sha": "a5e9867943f5c0668626d015f90d1d7f515d033b", "filename": "src/test/run-pass/send-type-inference.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -1,12 +1,13 @@\n use std;\n+import comm::Chan;\n import comm::chan;\n import comm::send;\n import comm::port;\n \n // tests that ctrl's type gets inferred properly\n type command<K: send, V: send> = {key: K, val: V};\n \n-fn cache_server<K: send, V: send>(c: chan<chan<command<K, V>>>) {\n+fn cache_server<K: send, V: send>(c: Chan<Chan<command<K, V>>>) {\n     let ctrl = port();\n     send(c, chan(ctrl));\n }"}, {"sha": "0c2dda20035f3b2e5e7693d42657c979270861bd", "filename": "src/test/run-pass/spawn-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-types.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -10,7 +10,7 @@ import str;\n import comm;\n import task;\n \n-type ctx = comm::chan<int>;\n+type ctx = comm::Chan<int>;\n \n fn iotask(cx: ctx, ip: ~str) {\n     assert (ip == ~\"localhost\");"}, {"sha": "65762cae08cc290611b1df85a13ad65315e22ba7", "filename": "src/test/run-pass/task-comm-chan-cleanup4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup4.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -6,7 +6,7 @@ import task;\n // We're trying to trigger a race between send and port destruction that\n // results in the string not being freed\n \n-fn starship(&&ch: comm::chan<~str>) {\n+fn starship(&&ch: comm::Chan<~str>) {\n     for int::range(0, 10) |_i| {\n         comm::send(ch, ~\"pew pew\");\n     }"}, {"sha": "399ce8e808bbcef0725814c8d5a5361b7c505784", "filename": "src/test/run-pass/task-comm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -3,6 +3,7 @@ use std;\n import task;\n import task::task;\n import comm;\n+import comm::Chan;\n import comm::chan;\n import comm::port;\n import comm::send;\n@@ -17,7 +18,7 @@ fn main() {\n     test06();\n }\n \n-fn test00_start(ch: chan<int>, message: int, count: int) {\n+fn test00_start(ch: Chan<int>, message: int, count: int) {\n     debug!{\"Starting test00_start\"};\n     let mut i: int = 0;\n     while i < count {\n@@ -93,7 +94,7 @@ fn test04() {\n     debug!{\"Finishing up.\"};\n }\n \n-fn test05_start(ch: chan<int>) {\n+fn test05_start(ch: Chan<int>) {\n     send(ch, 10);\n     send(ch, 20);\n     send(ch, 30);"}, {"sha": "4c061f152f4e288d78f0e03088ec23912db4a76c", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -7,8 +7,8 @@ use std;\n import task;\n \n class notify {\n-    let ch: comm::chan<bool>; let v: @mut bool;\n-    new(ch: comm::chan<bool>, v: @mut bool) { self.ch = ch; self.v = v; }\n+    let ch: comm::Chan<bool>; let v: @mut bool;\n+    new(ch: comm::Chan<bool>, v: @mut bool) { self.ch = ch; self.v = v; }\n     drop {\n         error!{\"notify: task=%? v=%x unwinding=%b b=%b\",\n                task::get_task(),\n@@ -20,8 +20,8 @@ class notify {\n     }\n }\n \n-fn joinable(+f: fn~()) -> comm::port<bool> {\n-    fn wrapper(+c: comm::chan<bool>, +f: fn()) {\n+fn joinable(+f: fn~()) -> comm::Port<bool> {\n+    fn wrapper(+c: comm::Chan<bool>, +f: fn()) {\n         let b = @mut false;\n         error!{\"wrapper: task=%? allocated v=%x\",\n                task::get_task(),\n@@ -36,7 +36,7 @@ fn joinable(+f: fn~()) -> comm::port<bool> {\n     p\n }\n \n-fn join(port: comm::port<bool>) -> bool {\n+fn join(port: comm::Port<bool>) -> bool {\n     comm::recv(port)\n }\n "}, {"sha": "89da4e65f88aac011e57e04760a9e30ef51405b5", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -3,7 +3,7 @@ import comm;\n import task;\n import uint;\n \n-fn child(c: comm::chan<~uint>, i: uint) {\n+fn child(c: comm::Chan<~uint>, i: uint) {\n     comm::send(c, ~i);\n }\n "}, {"sha": "39b619c590513ef43be6232c8903a2cae920cbe9", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6890f4884b1294dd13ad883162ab98e2dd27e5/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=9c6890f4884b1294dd13ad883162ab98e2dd27e5", "patch": "@@ -4,16 +4,16 @@ import task;\n import comm;\n \n class complainer {\n-  let c: comm::chan<bool>;\n-  new(c: comm::chan<bool>) {\n+  let c: comm::Chan<bool>;\n+  new(c: comm::Chan<bool>) {\n     error!{\"Hello!\"};\n     self.c = c; }\n   drop { error!{\"About to send!\"};\n     comm::send(self.c, true);\n     error!{\"Sent!\"}; }\n }\n \n-fn f(c: comm::chan<bool>) {\n+fn f(c: comm::Chan<bool>) {\n     let _c <- complainer(c);\n     fail;\n }"}]}