{"sha": "3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjMjk5YTk4N2NmZDk1MjJjNGUxZjZlNTNlZDc5MTIzYjRhNGFjYWI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-10T14:08:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-10T14:08:26Z"}, "message": "Rollup merge of #62532 - Mark-Simulacrum:syntax-print-cleanup, r=petrochenkov\n\nSome more cleanups to syntax::print\n\nAll of these changes should be functionally equivalent to previous code.\n\nEach commit mostly stands alone and this PR is easiest to review by-commit.", "tree": {"sha": "7b38859ec1d80e79e50861dac5caa24d231572db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b38859ec1d80e79e50861dac5caa24d231572db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdJfFaCRBK7hj4Ov3rIwAAdHIIAGgDa8ClE/fisPwcNBdAqYlo\n50bckKT3LgnJ4sbuD3fMJeLx884wDfScIyuKSP7KfsGlGjWau18vdysAulJTClLN\noN3+S3wfwaZOh1PGXCpXU7m8NhPYfh4Rd06fkmhaciexeTwjFNTCA/NBZXIbWaA2\nFz+DfjMiZ5h/xN8gpUwDg66IrGTXEHm9EzEIHw2RcorMtJG9CaH4ni+0+vna6GR+\nlzsbH70Ex2xIYhF3PMNDrW7aCHiE8yAwbCcVBllNHlas7ZKaAmA33BO5rNUMKMMc\nOdCsMCcz4NQmwEA+1e/C6uTW5FrzFdQUcCEcYqulCV4RyyNX3p4LUG7OU9IcY2I=\n=0Ukd\n-----END PGP SIGNATURE-----\n", "payload": "tree 7b38859ec1d80e79e50861dac5caa24d231572db\nparent d0cec040de22555519e991f08a48ec0b1b62fbc6\nparent 56a9237b595b4523f2be3123d52662739e89d4c2\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1562767706 +0200\ncommitter GitHub <noreply@github.com> 1562767706 +0200\n\nRollup merge of #62532 - Mark-Simulacrum:syntax-print-cleanup, r=petrochenkov\n\nSome more cleanups to syntax::print\n\nAll of these changes should be functionally equivalent to previous code.\n\nEach commit mostly stands alone and this PR is easiest to review by-commit.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "html_url": "https://github.com/rust-lang/rust/commit/3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0cec040de22555519e991f08a48ec0b1b62fbc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0cec040de22555519e991f08a48ec0b1b62fbc6", "html_url": "https://github.com/rust-lang/rust/commit/d0cec040de22555519e991f08a48ec0b1b62fbc6"}, {"sha": "56a9237b595b4523f2be3123d52662739e89d4c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/56a9237b595b4523f2be3123d52662739e89d4c2", "html_url": "https://github.com/rust-lang/rust/commit/56a9237b595b4523f2be3123d52662739e89d4c2"}], "stats": {"total": 835, "additions": 359, "deletions": 476}, "files": [{"sha": "9fb85410fc77aa4e5f2b9d253b8dea0cccfc0441", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "patch": "@@ -1212,10 +1212,8 @@ impl<'a> print::State<'a> {\n             Node::Pat(a)          => self.print_pat(&a),\n             Node::Arm(a)          => self.print_arm(&a),\n             Node::Block(a)        => {\n-                use syntax::print::pprust::PrintState;\n-\n                 // containing cbox, will be closed by print-block at }\n-                self.cbox(print::indent_unit);\n+                self.cbox(print::INDENT_UNIT);\n                 // head-ibox, will be closed by print-block after {\n                 self.ibox(0);\n                 self.print_block(&a)"}, {"sha": "5a14b30e699bedd99a5dad56036958e57b93326f", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 61, "deletions": 123, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "patch": "@@ -2,10 +2,9 @@ use rustc_target::spec::abi::Abi;\n use syntax::ast;\n use syntax::source_map::{SourceMap, Spanned};\n use syntax::parse::ParseSess;\n-use syntax::parse::lexer::comments;\n use syntax::print::pp::{self, Breaks};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n-use syntax::print::pprust::{self, PrintState};\n+use syntax::print::pprust::{Comments, PrintState};\n use syntax::symbol::kw;\n use syntax::util::parser::{self, AssocOp, Fixity};\n use syntax_pos::{self, BytePos, FileName};\n@@ -17,7 +16,6 @@ use crate::hir::ptr::P;\n \n use std::borrow::Cow;\n use std::cell::Cell;\n-use std::io::Read;\n use std::vec;\n \n pub enum AnnNode<'a> {\n@@ -70,46 +68,41 @@ impl PpAnn for hir::Crate {\n }\n \n pub struct State<'a> {\n-    pub s: pp::Printer<'a>,\n-    cm: Option<&'a SourceMap>,\n-    comments: Option<Vec<comments::Comment>>,\n-    cur_cmnt: usize,\n-    boxes: Vec<pp::Breaks>,\n+    pub s: pp::Printer,\n+    comments: Option<Comments<'a>>,\n     ann: &'a (dyn PpAnn + 'a),\n }\n \n-impl<'a> PrintState<'a> for State<'a> {\n-    fn writer(&mut self) -> &mut pp::Printer<'a> {\n-        &mut self.s\n+impl std::ops::Deref for State<'_> {\n+    type Target = pp::Printer;\n+    fn deref(&self) -> &Self::Target {\n+        &self.s\n     }\n+}\n \n-    fn boxes(&mut self) -> &mut Vec<pp::Breaks> {\n-        &mut self.boxes\n+impl std::ops::DerefMut for State<'_> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.s\n     }\n+}\n \n-    fn comments(&mut self) -> &mut Option<Vec<comments::Comment>> {\n+impl<'a> PrintState<'a> for State<'a> {\n+    fn comments(&mut self) -> &mut Option<Comments<'a>> {\n         &mut self.comments\n     }\n-\n-    fn cur_cmnt(&mut self) -> &mut usize {\n-        &mut self.cur_cmnt\n-    }\n }\n \n-#[allow(non_upper_case_globals)]\n-pub const indent_unit: usize = 4;\n+pub const INDENT_UNIT: usize = 4;\n \n /// Requires you to pass an input filename and reader so that\n /// it can scan the input text for comments to copy forward.\n pub fn print_crate<'a>(cm: &'a SourceMap,\n                        sess: &ParseSess,\n                        krate: &hir::Crate,\n                        filename: FileName,\n-                       input: &mut dyn Read,\n-                       out: &'a mut String,\n-                       ann: &'a dyn PpAnn)\n-                       {\n-    let mut s = State::new_from_input(cm, sess, filename, input, out, ann);\n+                       input: String,\n+                       ann: &'a dyn PpAnn) -> String {\n+    let mut s = State::new_from_input(cm, sess, filename, input, ann);\n \n     // When printing the AST, we sometimes need to inject `#[no_std]` here.\n     // Since you can't compile the HIR, it's not necessary.\n@@ -123,25 +116,12 @@ impl<'a> State<'a> {\n     pub fn new_from_input(cm: &'a SourceMap,\n                           sess: &ParseSess,\n                           filename: FileName,\n-                          input: &mut dyn Read,\n-                          out: &'a mut String,\n+                          input: String,\n                           ann: &'a dyn PpAnn)\n                           -> State<'a> {\n-        let comments = comments::gather_comments(sess, filename, input);\n-        State::new(cm, out, ann, Some(comments))\n-    }\n-\n-    pub fn new(cm: &'a SourceMap,\n-               out: &'a mut String,\n-               ann: &'a dyn PpAnn,\n-               comments: Option<Vec<comments::Comment>>)\n-               -> State<'a> {\n         State {\n-            s: pp::mk_printer(out),\n-            cm: Some(cm),\n-            comments,\n-            cur_cmnt: 0,\n-            boxes: Vec::new(),\n+            s: pp::mk_printer(),\n+            comments: Some(Comments::new(cm, sess, filename, input)),\n             ann,\n         }\n     }\n@@ -150,20 +130,13 @@ impl<'a> State<'a> {\n pub fn to_string<F>(ann: &dyn PpAnn, f: F) -> String\n     where F: FnOnce(&mut State<'_>)\n {\n-    let mut wr = String::new();\n-    {\n-        let mut printer = State {\n-            s: pp::mk_printer(&mut wr),\n-            cm: None,\n-            comments: None,\n-            cur_cmnt: 0,\n-            boxes: Vec::new(),\n-            ann,\n-        };\n-        f(&mut printer);\n-        printer.s.eof();\n-    }\n-    wr\n+    let mut printer = State {\n+        s: pp::mk_printer(),\n+        comments: None,\n+        ann,\n+    };\n+    f(&mut printer);\n+    printer.s.eof()\n }\n \n pub fn visibility_qualified<S: Into<Cow<'static, str>>>(vis: &hir::Visibility, w: S) -> String {\n@@ -175,7 +148,6 @@ pub fn visibility_qualified<S: Into<Cow<'static, str>>>(vis: &hir::Visibility, w\n \n impl<'a> State<'a> {\n     pub fn cbox(&mut self, u: usize) {\n-        self.boxes.push(pp::Breaks::Consistent);\n         self.s.cbox(u);\n     }\n \n@@ -191,7 +163,7 @@ impl<'a> State<'a> {\n     pub fn head<S: Into<Cow<'static, str>>>(&mut self, w: S) {\n         let w = w.into();\n         // outer-box is consistent\n-        self.cbox(indent_unit);\n+        self.cbox(INDENT_UNIT);\n         // head-box is inconsistent\n         self.ibox(w.len() + 1);\n         // keyword that starts the head\n@@ -205,42 +177,30 @@ impl<'a> State<'a> {\n         self.end(); // close the head-box\n     }\n \n-    pub fn bclose_(&mut self, span: syntax_pos::Span, indented: usize) {\n-        self.bclose_maybe_open(span, indented, true)\n-    }\n-\n     pub fn bclose_maybe_open(&mut self,\n                              span: syntax_pos::Span,\n-                             indented: usize,\n                              close_box: bool)\n                              {\n         self.maybe_print_comment(span.hi());\n-        self.break_offset_if_not_bol(1, -(indented as isize));\n+        self.break_offset_if_not_bol(1, -(INDENT_UNIT as isize));\n         self.s.word(\"}\");\n         if close_box {\n             self.end(); // close the outer-box\n         }\n     }\n \n     pub fn bclose(&mut self, span: syntax_pos::Span) {\n-        self.bclose_(span, indent_unit)\n-    }\n-\n-    pub fn in_cbox(&self) -> bool {\n-        match self.boxes.last() {\n-            Some(&last_box) => last_box == pp::Breaks::Consistent,\n-            None => false,\n-        }\n+        self.bclose_maybe_open(span, true)\n     }\n \n     pub fn space_if_not_bol(&mut self) {\n-        if !self.is_bol() {\n+        if !self.s.is_beginning_of_line() {\n             self.s.space();\n         }\n     }\n \n     pub fn break_offset_if_not_bol(&mut self, n: usize, off: isize) {\n-        if !self.is_bol() {\n+        if !self.s.is_beginning_of_line() {\n             self.s.break_offset(n, off)\n         } else {\n             if off != 0 && self.s.last_token().is_hardbreak_tok() {\n@@ -766,7 +726,7 @@ impl<'a> State<'a> {\n             self.space_if_not_bol();\n             self.maybe_print_comment(v.span.lo());\n             self.print_outer_attributes(&v.node.attrs);\n-            self.ibox(indent_unit);\n+            self.ibox(INDENT_UNIT);\n             self.print_variant(v);\n             self.s.word(\",\");\n             self.end();\n@@ -953,10 +913,10 @@ impl<'a> State<'a> {\n         decl: impl Fn(&mut Self)\n     ) {\n         self.space_if_not_bol();\n-        self.ibox(indent_unit);\n+        self.ibox(INDENT_UNIT);\n         self.word_nbsp(\"let\");\n \n-        self.ibox(indent_unit);\n+        self.ibox(INDENT_UNIT);\n         decl(self);\n         self.end();\n \n@@ -998,26 +958,18 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_block_unclosed(&mut self, blk: &hir::Block) {\n-        self.print_block_unclosed_indent(blk, indent_unit)\n-    }\n-\n-    pub fn print_block_unclosed_indent(&mut self,\n-                                       blk: &hir::Block,\n-                                       indented: usize)\n-                                       {\n-        self.print_block_maybe_unclosed(blk, indented, &[], false)\n+        self.print_block_maybe_unclosed(blk, &[], false)\n     }\n \n     pub fn print_block_with_attrs(&mut self,\n                                   blk: &hir::Block,\n                                   attrs: &[ast::Attribute])\n                                   {\n-        self.print_block_maybe_unclosed(blk, indent_unit, attrs, true)\n+        self.print_block_maybe_unclosed(blk, attrs, true)\n     }\n \n     pub fn print_block_maybe_unclosed(&mut self,\n                                       blk: &hir::Block,\n-                                      indented: usize,\n                                       attrs: &[ast::Attribute],\n                                       close_box: bool)\n                                       {\n@@ -1041,7 +993,7 @@ impl<'a> State<'a> {\n             self.print_expr(&expr);\n             self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi()));\n         }\n-        self.bclose_maybe_open(blk.span, indented, close_box);\n+        self.bclose_maybe_open(blk.span, close_box);\n         self.ann.post(self, AnnNode::Block(blk))\n     }\n \n@@ -1089,15 +1041,15 @@ impl<'a> State<'a> {\n     }\n \n     fn print_expr_vec(&mut self, exprs: &[hir::Expr]) {\n-        self.ibox(indent_unit);\n+        self.ibox(INDENT_UNIT);\n         self.s.word(\"[\");\n         self.commasep_exprs(Inconsistent, exprs);\n         self.s.word(\"]\");\n         self.end()\n     }\n \n     fn print_expr_repeat(&mut self, element: &hir::Expr, count: &hir::AnonConst) {\n-        self.ibox(indent_unit);\n+        self.ibox(INDENT_UNIT);\n         self.s.word(\"[\");\n         self.print_expr(element);\n         self.word_space(\";\");\n@@ -1116,7 +1068,7 @@ impl<'a> State<'a> {\n         self.commasep_cmnt(Consistent,\n                            &fields[..],\n                            |s, field| {\n-                               s.ibox(indent_unit);\n+                               s.ibox(INDENT_UNIT);\n                                if !field.is_shorthand {\n                                     s.print_ident(field.ident);\n                                     s.word_space(\":\");\n@@ -1127,7 +1079,7 @@ impl<'a> State<'a> {\n                            |f| f.span);\n         match *wth {\n             Some(ref expr) => {\n-                self.ibox(indent_unit);\n+                self.ibox(INDENT_UNIT);\n                 if !fields.is_empty() {\n                     self.s.word(\",\");\n                     self.s.space();\n@@ -1226,13 +1178,13 @@ impl<'a> State<'a> {\n \n     fn print_literal(&mut self, lit: &hir::Lit) {\n         self.maybe_print_comment(lit.span.lo());\n-        self.writer().word(pprust::literal_to_string(lit.node.to_lit_token()))\n+        self.word(lit.node.to_lit_token().to_string())\n     }\n \n     pub fn print_expr(&mut self, expr: &hir::Expr) {\n         self.maybe_print_comment(expr.span.lo());\n         self.print_outer_attributes(&expr.attrs);\n-        self.ibox(indent_unit);\n+        self.ibox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Expr(expr));\n         match expr.node {\n             hir::ExprKind::Box(ref expr) => {\n@@ -1284,7 +1236,7 @@ impl<'a> State<'a> {\n             }\n             hir::ExprKind::DropTemps(ref init) => {\n                 // Print `{`:\n-                self.cbox(indent_unit);\n+                self.cbox(INDENT_UNIT);\n                 self.ibox(0);\n                 self.bopen();\n \n@@ -1298,7 +1250,7 @@ impl<'a> State<'a> {\n                 self.print_ident(temp);\n \n                 // Print `}`:\n-                self.bclose_maybe_open(expr.span, indent_unit, true);\n+                self.bclose_maybe_open(expr.span, true);\n             }\n             hir::ExprKind::Loop(ref blk, opt_label, _) => {\n                 if let Some(label) = opt_label {\n@@ -1310,16 +1262,16 @@ impl<'a> State<'a> {\n                 self.print_block(&blk);\n             }\n             hir::ExprKind::Match(ref expr, ref arms, _) => {\n-                self.cbox(indent_unit);\n-                self.ibox(4);\n+                self.cbox(INDENT_UNIT);\n+                self.ibox(INDENT_UNIT);\n                 self.word_nbsp(\"match\");\n                 self.print_expr_as_cond(&expr);\n                 self.s.space();\n                 self.bopen();\n                 for arm in arms {\n                     self.print_arm(arm);\n                 }\n-                self.bclose_(expr.span, indent_unit);\n+                self.bclose(expr.span);\n             }\n             hir::ExprKind::Closure(capture_clause, ref decl, body, _fn_decl_span, _gen) => {\n                 self.print_capture_clause(capture_clause);\n@@ -1342,7 +1294,7 @@ impl<'a> State<'a> {\n                     self.word_space(\":\");\n                 }\n                 // containing cbox, will be closed by print-block at }\n-                self.cbox(indent_unit);\n+                self.cbox(INDENT_UNIT);\n                 // head-box, will be closed by print-block after {\n                 self.ibox(0);\n                 self.print_block(&blk);\n@@ -1712,7 +1664,7 @@ impl<'a> State<'a> {\n                 self.commasep_cmnt(Consistent,\n                                    &fields[..],\n                                    |s, f| {\n-                                       s.cbox(indent_unit);\n+                                       s.cbox(INDENT_UNIT);\n                                        if !f.node.is_shorthand {\n                                            s.print_ident(f.node.ident);\n                                            s.word_nbsp(\":\");\n@@ -1821,7 +1773,7 @@ impl<'a> State<'a> {\n         if arm.attrs.is_empty() {\n             self.s.space();\n         }\n-        self.cbox(indent_unit);\n+        self.cbox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Arm(arm));\n         self.ibox(0);\n         self.print_outer_attributes(&arm.attrs);\n@@ -1854,7 +1806,7 @@ impl<'a> State<'a> {\n                     self.word_space(\":\");\n                 }\n                 // the block will close the pattern's ibox\n-                self.print_block_unclosed_indent(&blk, indent_unit);\n+                self.print_block_unclosed(&blk);\n \n                 // If it is a user-provided unsafe block, print a comma after it\n                 if let hir::UnsafeBlock(hir::UserProvided) = blk.rules {\n@@ -1893,7 +1845,7 @@ impl<'a> State<'a> {\n         // Make sure we aren't supplied *both* `arg_names` and `body_id`.\n         assert!(arg_names.is_empty() || body_id.is_none());\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n-            s.ibox(indent_unit);\n+            s.ibox(INDENT_UNIT);\n             if let Some(arg_name) = arg_names.get(i) {\n                 s.s.word(arg_name.as_str().to_string());\n                 s.s.word(\":\");\n@@ -1920,7 +1872,7 @@ impl<'a> State<'a> {\n         self.s.word(\"|\");\n         let mut i = 0;\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n-            s.ibox(indent_unit);\n+            s.ibox(INDENT_UNIT);\n \n             s.ann.nested(s, Nested::BodyArgPat(body_id, i));\n             i += 1;\n@@ -2119,7 +2071,7 @@ impl<'a> State<'a> {\n         }\n \n         self.space_if_not_bol();\n-        self.ibox(indent_unit);\n+        self.ibox(INDENT_UNIT);\n         self.word_space(\"->\");\n         match decl.output {\n             hir::DefaultReturn(..) => unreachable!(),\n@@ -2141,7 +2093,7 @@ impl<'a> State<'a> {\n                        generic_params: &[hir::GenericParam],\n                        arg_names: &[ast::Ident])\n                        {\n-        self.ibox(indent_unit);\n+        self.ibox(INDENT_UNIT);\n         if !generic_params.is_empty() {\n             self.s.word(\"for\");\n             self.print_generic_params(generic_params);\n@@ -2174,23 +2126,9 @@ impl<'a> State<'a> {\n                                         span: syntax_pos::Span,\n                                         next_pos: Option<BytePos>)\n                                         {\n-        let cm = match self.cm {\n-            Some(cm) => cm,\n-            _ => return,\n-        };\n-        if let Some(ref cmnt) = self.next_comment() {\n-            if (*cmnt).style != comments::Trailing {\n-                return;\n-            }\n-            let span_line = cm.lookup_char_pos(span.hi());\n-            let comment_line = cm.lookup_char_pos((*cmnt).pos);\n-            let mut next = (*cmnt).pos + BytePos(1);\n-            if let Some(p) = next_pos {\n-                next = p;\n-            }\n-            if span.hi() < (*cmnt).pos && (*cmnt).pos < next &&\n-               span_line.line == comment_line.line {\n-                self.print_comment(cmnt);\n+        if let Some(cmnts) = self.comments() {\n+            if let Some(cmnt) = cmnts.trailing_comment(span, next_pos) {\n+                self.print_comment(&cmnt);\n             }\n         }\n     }"}, {"sha": "94849728a9319777b1059e457f7d5ada866695f7", "filename": "src/librustc_borrowck/dataflow.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibrustc_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibrustc_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdataflow.rs?ref=3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "patch": "@@ -8,7 +8,6 @@ use rustc::cfg::CFGIndex;\n use rustc::ty::TyCtxt;\n use std::mem;\n use std::usize;\n-use syntax::print::pprust::PrintState;\n use log::debug;\n \n use rustc_data_structures::graph::implementation::OUTGOING;\n@@ -530,7 +529,7 @@ impl<'tcx, O: DataFlowOperator + Clone + 'static> DataFlowContext<'tcx, O> {\n \n         debug!(\"Dataflow result for {}:\", self.analysis_name);\n         debug!(\"{}\", pprust::to_string(self, |s| {\n-            s.cbox(pprust::indent_unit);\n+            s.cbox(pprust::INDENT_UNIT);\n             s.ibox(0);\n             s.print_expr(&body.value)\n         }));"}, {"sha": "51b161c37680217eb4e022ef392b14fc2a887042", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "patch": "@@ -19,7 +19,6 @@ use rustc_mir::util::{write_mir_pretty, write_mir_graphviz};\n use syntax::ast;\n use syntax::mut_visit::MutVisitor;\n use syntax::print::{pprust};\n-use syntax::print::pprust::PrintState;\n use syntax_pos::FileName;\n \n use graphviz as dot;\n@@ -687,16 +686,14 @@ pub fn visit_crate(sess: &Session, krate: &mut ast::Crate, ppm: PpMode) {\n     }\n }\n \n-fn get_source(input: &Input, sess: &Session) -> (Vec<u8>, FileName) {\n+fn get_source(input: &Input, sess: &Session) -> (String, FileName) {\n     let src_name = source_name(input);\n-    let src = sess.source_map()\n+    let src = String::clone(&sess.source_map()\n         .get_source_file(&src_name)\n         .unwrap()\n         .src\n         .as_ref()\n-        .unwrap()\n-        .as_bytes()\n-        .to_vec();\n+        .unwrap());\n     (src, src_name)\n }\n \n@@ -719,7 +716,6 @@ pub fn print_after_parsing(sess: &Session,\n                            ofile: Option<&Path>) {\n     let (src, src_name) = get_source(input, sess);\n \n-    let mut rdr = &*src;\n     let mut out = String::new();\n \n     if let PpmSource(s) = ppm {\n@@ -728,12 +724,11 @@ pub fn print_after_parsing(sess: &Session,\n         s.call_with_pp_support(sess, None, move |annotation| {\n             debug!(\"pretty printing source code {:?}\", s);\n             let sess = annotation.sess();\n-            pprust::print_crate(sess.source_map(),\n+            *out = pprust::print_crate(sess.source_map(),\n                                 &sess.parse_sess,\n                                 krate,\n                                 src_name,\n-                                &mut rdr,\n-                                out,\n+                                src,\n                                 annotation.pp_ann(),\n                                 false)\n         })\n@@ -764,38 +759,37 @@ pub fn print_after_hir_lowering<'tcx>(\n \n     let (src, src_name) = get_source(input, tcx.sess);\n \n-    let mut rdr = &src[..];\n     let mut out = String::new();\n \n     match (ppm, opt_uii) {\n             (PpmSource(s), _) => {\n                 // Silently ignores an identified node.\n                 let out = &mut out;\n+                let src = src.clone();\n                 s.call_with_pp_support(tcx.sess, Some(tcx), move |annotation| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n-                    pprust::print_crate(sess.source_map(),\n+                    *out = pprust::print_crate(sess.source_map(),\n                                         &sess.parse_sess,\n                                         krate,\n                                         src_name,\n-                                        &mut rdr,\n-                                        out,\n+                                        src,\n                                         annotation.pp_ann(),\n                                         true)\n                 })\n             }\n \n             (PpmHir(s), None) => {\n                 let out = &mut out;\n+                let src = src.clone();\n                 s.call_with_pp_support_hir(tcx, move |annotation, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n-                    pprust_hir::print_crate(sess.source_map(),\n+                    *out = pprust_hir::print_crate(sess.source_map(),\n                                             &sess.parse_sess,\n                                             krate,\n                                             src_name,\n-                                            &mut rdr,\n-                                            out,\n+                                            src,\n                                             annotation.pp_ann())\n                 })\n             }\n@@ -810,15 +804,15 @@ pub fn print_after_hir_lowering<'tcx>(\n \n             (PpmHir(s), Some(uii)) => {\n                 let out = &mut out;\n+                let src = src.clone();\n                 s.call_with_pp_support_hir(tcx, move |annotation, _| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     let hir_map = annotation.hir_map().expect(\"-Z unpretty missing HIR map\");\n                     let mut pp_state = pprust_hir::State::new_from_input(sess.source_map(),\n                                                                          &sess.parse_sess,\n                                                                          src_name,\n-                                                                         &mut rdr,\n-                                                                         out,\n+                                                                         src,\n                                                                          annotation.pp_ann());\n                     for node_id in uii.all_matching_node_ids(hir_map) {\n                         let hir_id = tcx.hir().node_to_hir_id(node_id);\n@@ -830,7 +824,7 @@ pub fn print_after_hir_lowering<'tcx>(\n                         pp_state.synth_comment(path);\n                         pp_state.s.hardbreak();\n                     }\n-                    pp_state.s.eof();\n+                    *out = pp_state.s.eof();\n                 })\n             }\n "}, {"sha": "567b6b1a891bf24e3ef9eda4a9475c14bbdfbe5b", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "patch": "@@ -1316,7 +1316,7 @@ impl EncodeContext<'tcx> {\n         let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n         Entry {\n             kind: EntryKind::MacroDef(self.lazy(&MacroDef {\n-                body: pprust::tts_to_string(&macro_def.body.trees().collect::<Vec<_>>()),\n+                body: pprust::tokens_to_string(macro_def.body.clone()),\n                 legacy: macro_def.legacy,\n             })),\n             visibility: self.lazy(&ty::Visibility::Public),"}, {"sha": "8801e89a0cfc43cc6216d46cf72c4bda2c5b6403", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "patch": "@@ -50,11 +50,17 @@ impl fmt::Debug for Lifetime {\n             f,\n             \"lifetime({}: {})\",\n             self.id,\n-            pprust::lifetime_to_string(self)\n+            self\n         )\n     }\n }\n \n+impl fmt::Display for Lifetime {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.ident.name.as_str())\n+    }\n+}\n+\n /// A \"Path\" is essentially Rust's notion of a name.\n ///\n /// It's represented as a sequence of identifiers,"}, {"sha": "ee7fb97ffd71869f57966bc0c28774ac237d3c0e", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "patch": "@@ -162,6 +162,7 @@ pub mod visit;\n pub mod print {\n     pub mod pp;\n     pub mod pprust;\n+    mod helpers;\n }\n \n pub mod ext {"}, {"sha": "ae24047ac8249b6785b3cf6dce6071d601e1bbe9", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "patch": "@@ -611,8 +611,6 @@ impl<'a> Parser<'a> {\n         match ty.node {\n             TyKind::Rptr(ref lifetime, ref mut_ty) => {\n                 let sum_with_parens = pprust::to_string(|s| {\n-                    use crate::print::pprust::PrintState;\n-\n                     s.s.word(\"&\");\n                     s.print_opt_lifetime(lifetime);\n                     s.print_mutability(mut_ty.mutbl);"}, {"sha": "6ed2a7adad1c2c8255ca27a6266c833bba55193b", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "patch": "@@ -8,7 +8,6 @@ use crate::parse::lexer::{self, ParseSess, StringReader};\n use syntax_pos::{BytePos, CharPos, Pos, FileName};\n use log::debug;\n \n-use std::io::Read;\n use std::usize;\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n@@ -340,10 +339,8 @@ fn consume_comment(rdr: &mut StringReader<'_>,\n \n // it appears this function is called only from pprust... that's\n // probably not a good thing.\n-pub fn gather_comments(sess: &ParseSess, path: FileName, srdr: &mut dyn Read) -> Vec<Comment>\n+pub fn gather_comments(sess: &ParseSess, path: FileName, src: String) -> Vec<Comment>\n {\n-    let mut src = String::new();\n-    srdr.read_to_string(&mut src).unwrap();\n     let cm = SourceMap::new(sess.source_map().path_mapping().clone());\n     let source_file = cm.new_source_file(path, src);\n     let mut rdr = lexer::StringReader::new(sess, source_file, None);"}, {"sha": "683d164156540a31cbc486fbe77e49792a25aabd", "filename": "src/libsyntax/parse/literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "patch": "@@ -344,7 +344,7 @@ impl<'a> Parser<'a> {\n                 // Pack possible quotes and prefixes from the original literal into\n                 // the error literal's symbol so they can be pretty-printed faithfully.\n                 let suffixless_lit = token::Lit::new(lit.kind, lit.symbol, None);\n-                let symbol = Symbol::intern(&pprust::literal_to_string(suffixless_lit));\n+                let symbol = Symbol::intern(&suffixless_lit.to_string());\n                 let lit = token::Lit::new(token::Err, symbol, lit.suffix);\n                 Lit::from_lit_token(lit, span).map_err(|_| unreachable!())\n             }"}, {"sha": "83dbff6b2d5746dda8bb5757a0032904a352fd8d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "patch": "@@ -2571,7 +2571,6 @@ impl<'a> Parser<'a> {\n                               None => continue,\n                           };\n                           let sugg = pprust::to_string(|s| {\n-                              use crate::print::pprust::PrintState;\n                               s.popen();\n                               s.print_expr(&e);\n                               s.s.word( \".\");\n@@ -4588,11 +4587,11 @@ impl<'a> Parser<'a> {\n                         stmt_span = stmt_span.with_hi(self.prev_span.hi());\n                     }\n                     let sugg = pprust::to_string(|s| {\n-                        use crate::print::pprust::{PrintState, INDENT_UNIT};\n+                        use crate::print::pprust::INDENT_UNIT;\n                         s.ibox(INDENT_UNIT);\n                         s.bopen();\n                         s.print_stmt(&stmt);\n-                        s.bclose_maybe_open(stmt.span, INDENT_UNIT, false)\n+                        s.bclose_maybe_open(stmt.span, false)\n                     });\n                     e.span_suggestion(\n                         stmt_span,"}, {"sha": "472e4b474d627513c1c279e0ef94d89ef131200a", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "patch": "@@ -80,6 +80,34 @@ pub struct Lit {\n     pub suffix: Option<Symbol>,\n }\n \n+impl fmt::Display for Lit {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let Lit { kind, symbol, suffix } = *self;\n+        match kind {\n+            Byte          => write!(f, \"b'{}'\", symbol)?,\n+            Char          => write!(f, \"'{}'\", symbol)?,\n+            Str           => write!(f, \"\\\"{}\\\"\", symbol)?,\n+            StrRaw(n)     => write!(f, \"r{delim}\\\"{string}\\\"{delim}\",\n+                                     delim=\"#\".repeat(n as usize),\n+                                     string=symbol)?,\n+            ByteStr       => write!(f, \"b\\\"{}\\\"\", symbol)?,\n+            ByteStrRaw(n) => write!(f, \"br{delim}\\\"{string}\\\"{delim}\",\n+                                     delim=\"#\".repeat(n as usize),\n+                                     string=symbol)?,\n+            Integer       |\n+            Float         |\n+            Bool          |\n+            Err           => write!(f, \"{}\", symbol)?,\n+        }\n+\n+        if let Some(suffix) = suffix {\n+            write!(f, \"{}\", suffix)?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n impl LitKind {\n     /// An English article for the literal token kind.\n     crate fn article(self) -> &'static str {\n@@ -788,7 +816,7 @@ fn prepend_attrs(sess: &ParseSess,\n         assert_eq!(attr.style, ast::AttrStyle::Outer,\n                    \"inner attributes should prevent cached tokens from existing\");\n \n-        let source = pprust::attr_to_string(attr);\n+        let source = pprust::attribute_to_string(attr);\n         let macro_filename = FileName::macro_expansion_source_code(&source);\n         if attr.is_sugared_doc {\n             let stream = parse_stream_from_source_str(macro_filename, source, sess, Some(span));"}, {"sha": "3449e07f4562db823a55275f09ca40c59a15ccfa", "filename": "src/libsyntax/print/helpers.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Fprint%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Fprint%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fhelpers.rs?ref=3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "patch": "@@ -0,0 +1,34 @@\n+use std::borrow::Cow;\n+use crate::print::pp::Printer;\n+\n+impl Printer {\n+    pub fn word_space<W: Into<Cow<'static, str>>>(&mut self, w: W) {\n+        self.word(w);\n+        self.space();\n+    }\n+\n+    pub fn popen(&mut self) {\n+        self.word(\"(\");\n+    }\n+\n+    pub fn pclose(&mut self) {\n+        self.word(\")\");\n+    }\n+\n+    pub fn hardbreak_if_not_bol(&mut self) {\n+        if !self.is_beginning_of_line() {\n+            self.hardbreak()\n+        }\n+    }\n+\n+    pub fn space_if_not_bol(&mut self) {\n+        if !self.is_beginning_of_line() { self.space(); }\n+    }\n+\n+    pub fn nbsp(&mut self) { self.word(\" \") }\n+\n+    pub fn word_nbsp<S: Into<Cow<'static, str>>>(&mut self, w: S) {\n+        self.word(w);\n+        self.nbsp()\n+    }\n+}"}, {"sha": "660e77f77d0f2918043af691c4909a248e7a86b7", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "patch": "@@ -131,7 +131,7 @@\n //! it.\n //!\n //! In this implementation (following the paper, again) the SCAN process is the\n-//! methods called `Printer::pretty_print_*`, and the 'PRINT' process is the\n+//! methods called `Printer::scan_*`, and the 'PRINT' process is the\n //! method called `Printer::print`.\n \n use std::collections::VecDeque;\n@@ -163,7 +163,7 @@ pub enum Token {\n     // In practice a string token contains either a `&'static str` or a\n     // `String`. `Cow` is overkill for this because we never modify the data,\n     // but it's more convenient than rolling our own more specialized type.\n-    String(Cow<'static, str>, isize),\n+    String(Cow<'static, str>),\n     Break(BreakToken),\n     Begin(BeginToken),\n     End,\n@@ -194,7 +194,7 @@ impl Token {\n impl fmt::Display for Token {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            Token::String(ref s, len) => write!(f, \"STR({},{})\", s, len),\n+            Token::String(ref s) => write!(f, \"STR({},{})\", s, s.len()),\n             Token::Break(_) => f.write_str(\"BREAK\"),\n             Token::Begin(_) => f.write_str(\"BEGIN\"),\n             Token::End => f.write_str(\"END\"),\n@@ -222,26 +222,26 @@ fn buf_str(buf: &[BufEntry], left: usize, right: usize, lim: usize) -> String {\n }\n \n #[derive(Copy, Clone)]\n-crate enum PrintStackBreak {\n+enum PrintStackBreak {\n     Fits,\n     Broken(Breaks),\n }\n \n #[derive(Copy, Clone)]\n-crate struct PrintStackElem {\n+struct PrintStackElem {\n     offset: isize,\n     pbreak: PrintStackBreak\n }\n \n const SIZE_INFINITY: isize = 0xffff;\n \n-pub fn mk_printer(out: &mut String) -> Printer<'_> {\n+pub fn mk_printer() -> Printer {\n     let linewidth = 78;\n     // Yes 55, it makes the ring buffers big enough to never fall behind.\n     let n: usize = 55 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n     Printer {\n-        out,\n+        out: String::new(),\n         buf_max_len: n,\n         margin: linewidth as isize,\n         space: linewidth as isize,\n@@ -258,8 +258,8 @@ pub fn mk_printer(out: &mut String) -> Printer<'_> {\n     }\n }\n \n-pub struct Printer<'a> {\n-    out: &'a mut String,\n+pub struct Printer {\n+    out: String,\n     buf_max_len: usize,\n     /// Width of lines we're constrained to\n     margin: isize,\n@@ -300,8 +300,8 @@ impl Default for BufEntry {\n     }\n }\n \n-impl<'a> Printer<'a> {\n-    pub fn last_token(&mut self) -> Token {\n+impl Printer {\n+    pub fn last_token(&self) -> Token {\n         self.buf[self.right].token.clone()\n     }\n \n@@ -310,15 +310,14 @@ impl<'a> Printer<'a> {\n         self.buf[self.right].token = t;\n     }\n \n-    fn pretty_print_eof(&mut self) {\n+    fn scan_eof(&mut self) {\n         if !self.scan_stack.is_empty() {\n             self.check_stack(0);\n             self.advance_left();\n         }\n-        self.indent(0);\n     }\n \n-    fn pretty_print_begin(&mut self, b: BeginToken) {\n+    fn scan_begin(&mut self, b: BeginToken) {\n         if self.scan_stack.is_empty() {\n             self.left_total = 1;\n             self.right_total = 1;\n@@ -329,25 +328,21 @@ impl<'a> Printer<'a> {\n         }\n         debug!(\"pp Begin({})/buffer Vec<{},{}>\",\n                b.offset, self.left, self.right);\n-        self.buf[self.right] = BufEntry { token: Token::Begin(b), size: -self.right_total };\n-        let right = self.right;\n-        self.scan_push(right);\n+        self.scan_push(BufEntry { token: Token::Begin(b), size: -self.right_total });\n     }\n \n-    fn pretty_print_end(&mut self) {\n+    fn scan_end(&mut self) {\n         if self.scan_stack.is_empty() {\n             debug!(\"pp End/print Vec<{},{}>\", self.left, self.right);\n             self.print_end();\n         } else {\n             debug!(\"pp End/buffer Vec<{},{}>\", self.left, self.right);\n             self.advance_right();\n-            self.buf[self.right] = BufEntry { token: Token::End, size: -1 };\n-            let right = self.right;\n-            self.scan_push(right);\n+            self.scan_push(BufEntry { token: Token::End, size: -1 });\n         }\n     }\n \n-    fn pretty_print_break(&mut self, b: BreakToken) {\n+    fn scan_break(&mut self, b: BreakToken) {\n         if self.scan_stack.is_empty() {\n             self.left_total = 1;\n             self.right_total = 1;\n@@ -359,28 +354,27 @@ impl<'a> Printer<'a> {\n         debug!(\"pp Break({})/buffer Vec<{},{}>\",\n                b.offset, self.left, self.right);\n         self.check_stack(0);\n-        let right = self.right;\n-        self.scan_push(right);\n-        self.buf[self.right] = BufEntry { token: Token::Break(b), size: -self.right_total };\n+        self.scan_push(BufEntry { token: Token::Break(b), size: -self.right_total });\n         self.right_total += b.blank_space;\n     }\n \n-    fn pretty_print_string(&mut self, s: Cow<'static, str>, len: isize) {\n+    fn scan_string(&mut self, s: Cow<'static, str>) {\n         if self.scan_stack.is_empty() {\n             debug!(\"pp String('{}')/print Vec<{},{}>\",\n                    s, self.left, self.right);\n-            self.print_string(s, len);\n+            self.print_string(s);\n         } else {\n             debug!(\"pp String('{}')/buffer Vec<{},{}>\",\n                    s, self.left, self.right);\n             self.advance_right();\n-            self.buf[self.right] = BufEntry { token: Token::String(s, len), size: len };\n+            let len = s.len() as isize;\n+            self.buf[self.right] = BufEntry { token: Token::String(s), size: len };\n             self.right_total += len;\n             self.check_stream();\n         }\n     }\n \n-    crate fn check_stream(&mut self) {\n+    fn check_stream(&mut self) {\n         debug!(\"check_stream Vec<{}, {}> with left_total={}, right_total={}\",\n                self.left, self.right, self.left_total, self.right_total);\n         if self.right_total - self.left_total > self.space {\n@@ -398,24 +392,25 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n-    crate fn scan_push(&mut self, x: usize) {\n-        debug!(\"scan_push {}\", x);\n-        self.scan_stack.push_front(x);\n+    fn scan_push(&mut self, entry: BufEntry) {\n+        debug!(\"scan_push {}\", self.right);\n+        self.buf[self.right] = entry;\n+        self.scan_stack.push_front(self.right);\n     }\n \n-    crate fn scan_pop(&mut self) -> usize {\n+    fn scan_pop(&mut self) -> usize {\n         self.scan_stack.pop_front().unwrap()\n     }\n \n-    crate fn scan_top(&mut self) -> usize {\n+    fn scan_top(&mut self) -> usize {\n         *self.scan_stack.front().unwrap()\n     }\n \n-    crate fn scan_pop_bottom(&mut self) -> usize {\n+    fn scan_pop_bottom(&mut self) -> usize {\n         self.scan_stack.pop_back().unwrap()\n     }\n \n-    crate fn advance_right(&mut self) {\n+    fn advance_right(&mut self) {\n         self.right += 1;\n         self.right %= self.buf_max_len;\n         // Extend the buf if necessary.\n@@ -425,7 +420,7 @@ impl<'a> Printer<'a> {\n         assert_ne!(self.right, self.left);\n     }\n \n-    crate fn advance_left(&mut self) {\n+    fn advance_left(&mut self) {\n         debug!(\"advance_left Vec<{},{}>, sizeof({})={}\", self.left, self.right,\n                self.left, self.buf[self.left].size);\n \n@@ -436,7 +431,8 @@ impl<'a> Printer<'a> {\n \n             let len = match left {\n                 Token::Break(b) => b.blank_space,\n-                Token::String(_, len) => {\n+                Token::String(ref s) => {\n+                    let len = s.len() as isize;\n                     assert_eq!(len, left_size);\n                     len\n                 }\n@@ -458,26 +454,26 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n-    crate fn check_stack(&mut self, k: isize) {\n+    fn check_stack(&mut self, k: usize) {\n         if !self.scan_stack.is_empty() {\n             let x = self.scan_top();\n             match self.buf[x].token {\n                 Token::Begin(_) => {\n                     if k > 0 {\n-                        let popped = self.scan_pop();\n-                        self.buf[popped].size = self.buf[x].size + self.right_total;\n+                        self.scan_pop();\n+                        self.buf[x].size += self.right_total;\n                         self.check_stack(k - 1);\n                     }\n                 }\n                 Token::End => {\n                     // paper says + not =, but that makes no sense.\n-                    let popped = self.scan_pop();\n-                    self.buf[popped].size = 1;\n+                    self.scan_pop();\n+                    self.buf[x].size = 1;\n                     self.check_stack(k + 1);\n                 }\n                 _ => {\n-                    let popped = self.scan_pop();\n-                    self.buf[popped].size = self.buf[x].size + self.right_total;\n+                    self.scan_pop();\n+                    self.buf[x].size += self.right_total;\n                     if k > 0 {\n                         self.check_stack(k);\n                     }\n@@ -486,19 +482,19 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n-    crate fn print_newline(&mut self, amount: isize) {\n+    fn print_newline(&mut self, amount: isize) {\n         debug!(\"NEWLINE {}\", amount);\n         self.out.push('\\n');\n         self.pending_indentation = 0;\n         self.indent(amount);\n     }\n \n-    crate fn indent(&mut self, amount: isize) {\n+    fn indent(&mut self, amount: isize) {\n         debug!(\"INDENT {}\", amount);\n         self.pending_indentation += amount;\n     }\n \n-    crate fn get_top(&mut self) -> PrintStackElem {\n+    fn get_top(&mut self) -> PrintStackElem {\n         match self.print_stack.last() {\n             Some(el) => *el,\n             None => PrintStackElem {\n@@ -508,7 +504,7 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n-    crate fn print_begin(&mut self, b: BeginToken, l: isize) {\n+    fn print_begin(&mut self, b: BeginToken, l: isize) {\n         if l > self.space {\n             let col = self.margin - self.space + b.offset;\n             debug!(\"print Begin -> push broken block at col {}\", col);\n@@ -525,14 +521,12 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n-    crate fn print_end(&mut self) {\n+    fn print_end(&mut self) {\n         debug!(\"print End -> pop End\");\n-        let print_stack = &mut self.print_stack;\n-        assert!(!print_stack.is_empty());\n-        print_stack.pop().unwrap();\n+        self.print_stack.pop().unwrap();\n     }\n \n-    crate fn print_break(&mut self, b: BreakToken, l: isize) {\n+    fn print_break(&mut self, b: BreakToken, l: isize) {\n         let top = self.get_top();\n         match top.pbreak {\n             PrintStackBreak::Fits => {\n@@ -562,7 +556,8 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n-    crate fn print_string(&mut self, s: Cow<'static, str>, len: isize) {\n+    fn print_string(&mut self, s: Cow<'static, str>) {\n+        let len = s.len() as isize;\n         debug!(\"print String({})\", s);\n         // assert!(len <= space);\n         self.space -= len;\n@@ -579,7 +574,7 @@ impl<'a> Printer<'a> {\n         self.out.push_str(&s);\n     }\n \n-    crate fn print(&mut self, token: Token, l: isize) {\n+    fn print(&mut self, token: Token, l: isize) {\n         debug!(\"print {} {} (remaining line space={})\", token, l,\n                self.space);\n         debug!(\"{}\", buf_str(&self.buf,\n@@ -590,9 +585,10 @@ impl<'a> Printer<'a> {\n             Token::Begin(b) => self.print_begin(b, l),\n             Token::End => self.print_end(),\n             Token::Break(b) => self.print_break(b, l),\n-            Token::String(s, len) => {\n+            Token::String(s) => {\n+                let len = s.len() as isize;\n                 assert_eq!(len, l);\n-                self.print_string(s, len);\n+                self.print_string(s);\n             }\n             Token::Eof => panic!(), // Eof should never get here.\n         }\n@@ -601,15 +597,15 @@ impl<'a> Printer<'a> {\n     // Convenience functions to talk to the printer.\n \n     /// \"raw box\"\n-    crate fn rbox(&mut self, indent: usize, b: Breaks) {\n-        self.pretty_print_begin(BeginToken {\n+    pub fn rbox(&mut self, indent: usize, b: Breaks) {\n+        self.scan_begin(BeginToken {\n             offset: indent as isize,\n             breaks: b\n         })\n     }\n \n     /// Inconsistent breaking box\n-    crate fn ibox(&mut self, indent: usize) {\n+    pub fn ibox(&mut self, indent: usize) {\n         self.rbox(indent, Breaks::Inconsistent)\n     }\n \n@@ -619,24 +615,24 @@ impl<'a> Printer<'a> {\n     }\n \n     pub fn break_offset(&mut self, n: usize, off: isize) {\n-        self.pretty_print_break(BreakToken {\n+        self.scan_break(BreakToken {\n             offset: off,\n             blank_space: n as isize\n         })\n     }\n \n-    crate fn end(&mut self) {\n-        self.pretty_print_end()\n+    pub fn end(&mut self) {\n+        self.scan_end()\n     }\n \n-    pub fn eof(&mut self) {\n-        self.pretty_print_eof()\n+    pub fn eof(mut self) -> String {\n+        self.scan_eof();\n+        self.out\n     }\n \n     pub fn word<S: Into<Cow<'static, str>>>(&mut self, wrd: S) {\n         let s = wrd.into();\n-        let len = s.len() as isize;\n-        self.pretty_print_string(s, len)\n+        self.scan_string(s)\n     }\n \n     fn spaces(&mut self, n: usize) {\n@@ -655,6 +651,10 @@ impl<'a> Printer<'a> {\n         self.spaces(SIZE_INFINITY as usize)\n     }\n \n+    pub fn is_beginning_of_line(&self) -> bool {\n+        self.last_token().is_eof() || self.last_token().is_hardbreak_tok()\n+    }\n+\n     pub fn hardbreak_tok_offset(off: isize) -> Token {\n         Token::Break(BreakToken {offset: off, blank_space: SIZE_INFINITY})\n     }"}, {"sha": "8050026a00d9e8b24e0925d240bc86ffbbbf4f05", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 138, "deletions": 247, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c299a987cfd9522c4e1f6e53ed79123b4a4acab/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3c299a987cfd9522c4e1f6e53ed79123b4a4acab", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n use crate::ast::{self, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n use crate::ast::{SelfKind, GenericBound, TraitBoundModifier};\n use crate::ast::{Attribute, MacDelimiter, GenericArg};\n@@ -21,7 +19,6 @@ use syntax_pos::{self, BytePos};\n use syntax_pos::{DUMMY_SP, FileName, Span};\n \n use std::borrow::Cow;\n-use std::io::Read;\n \n pub enum AnnNode<'a> {\n     Ident(&'a ast::Ident),\n@@ -43,12 +40,53 @@ pub struct NoAnn;\n \n impl PpAnn for NoAnn {}\n \n+pub struct Comments<'a> {\n+    cm: &'a SourceMap,\n+    comments: Vec<comments::Comment>,\n+    current: usize,\n+}\n+\n+impl<'a> Comments<'a> {\n+    pub fn new(\n+        cm: &'a SourceMap,\n+        sess: &ParseSess,\n+        filename: FileName,\n+        input: String,\n+    ) -> Comments<'a> {\n+        let comments = comments::gather_comments(sess, filename, input);\n+        Comments {\n+            cm,\n+            comments,\n+            current: 0,\n+        }\n+    }\n+\n+    pub fn next(&self) -> Option<comments::Comment> {\n+        self.comments.get(self.current).cloned()\n+    }\n+\n+    pub fn trailing_comment(\n+        &mut self,\n+        span: syntax_pos::Span,\n+        next_pos: Option<BytePos>,\n+    ) -> Option<comments::Comment> {\n+        if let Some(cmnt) = self.next() {\n+            if cmnt.style != comments::Trailing { return None; }\n+            let span_line = self.cm.lookup_char_pos(span.hi());\n+            let comment_line = self.cm.lookup_char_pos(cmnt.pos);\n+            let next = next_pos.unwrap_or_else(|| cmnt.pos + BytePos(1));\n+            if span.hi() < cmnt.pos && cmnt.pos < next && span_line.line == comment_line.line {\n+                return Some(cmnt);\n+            }\n+        }\n+\n+        None\n+    }\n+}\n+\n pub struct State<'a> {\n-    pub s: pp::Printer<'a>,\n-    cm: Option<&'a SourceMap>,\n-    comments: Option<Vec<comments::Comment>>,\n-    cur_cmnt: usize,\n-    boxes: Vec<pp::Breaks>,\n+    pub s: pp::Printer,\n+    comments: Option<Comments<'a>>,\n     ann: &'a (dyn PpAnn+'a),\n     is_expanded: bool\n }\n@@ -61,11 +99,15 @@ pub fn print_crate<'a>(cm: &'a SourceMap,\n                        sess: &ParseSess,\n                        krate: &ast::Crate,\n                        filename: FileName,\n-                       input: &mut dyn Read,\n-                       out: &mut String,\n+                       input: String,\n                        ann: &'a dyn PpAnn,\n-                       is_expanded: bool) {\n-    let mut s = State::new_from_input(cm, sess, filename, input, out, ann, is_expanded);\n+                       is_expanded: bool) -> String {\n+    let mut s = State {\n+        s: pp::mk_printer(),\n+        comments: Some(Comments::new(cm, sess, filename, input)),\n+        ann,\n+        is_expanded,\n+    };\n \n     if is_expanded && std_inject::injected_crate_name().is_some() {\n         // We need to print `#![no_std]` (and its feature gate) so that\n@@ -91,53 +133,17 @@ pub fn print_crate<'a>(cm: &'a SourceMap,\n     s.s.eof()\n }\n \n-impl<'a> State<'a> {\n-    pub fn new_from_input(cm: &'a SourceMap,\n-                          sess: &ParseSess,\n-                          filename: FileName,\n-                          input: &mut dyn Read,\n-                          out: &'a mut String,\n-                          ann: &'a dyn PpAnn,\n-                          is_expanded: bool) -> State<'a> {\n-        let comments = comments::gather_comments(sess, filename, input);\n-        State::new(cm, out, ann, Some(comments), is_expanded)\n-    }\n-\n-    pub fn new(cm: &'a SourceMap,\n-               out: &'a mut String,\n-               ann: &'a dyn PpAnn,\n-               comments: Option<Vec<comments::Comment>>,\n-               is_expanded: bool) -> State<'a> {\n-        State {\n-            s: pp::mk_printer(out),\n-            cm: Some(cm),\n-            comments,\n-            cur_cmnt: 0,\n-            boxes: Vec::new(),\n-            ann,\n-            is_expanded,\n-        }\n-    }\n-}\n-\n pub fn to_string<F>(f: F) -> String where\n     F: FnOnce(&mut State<'_>),\n {\n-    let mut wr = String::new();\n-    {\n-        let mut printer = State {\n-            s: pp::mk_printer(&mut wr),\n-            cm: None,\n-            comments: None,\n-            cur_cmnt: 0,\n-            boxes: Vec::new(),\n-            ann: &NoAnn,\n-            is_expanded: false\n-        };\n-        f(&mut printer);\n-        printer.s.eof();\n-    }\n-    wr\n+    let mut printer = State {\n+        s: pp::mk_printer(),\n+        comments: None,\n+        ann: &NoAnn,\n+        is_expanded: false\n+    };\n+    f(&mut printer);\n+    printer.s.eof()\n }\n \n fn binop_to_string(op: BinOpToken) -> &'static str {\n@@ -322,18 +328,10 @@ pub fn pat_to_string(pat: &ast::Pat) -> String {\n     to_string(|s| s.print_pat(pat))\n }\n \n-pub fn arm_to_string(arm: &ast::Arm) -> String {\n-    to_string(|s| s.print_arm(arm))\n-}\n-\n pub fn expr_to_string(e: &ast::Expr) -> String {\n     to_string(|s| s.print_expr(e))\n }\n \n-pub fn lifetime_to_string(lt: &ast::Lifetime) -> String {\n-    to_string(|s| s.print_lifetime(*lt))\n-}\n-\n pub fn tt_to_string(tt: tokenstream::TokenTree) -> String {\n     to_string(|s| s.print_tt(tt, false))\n }\n@@ -350,34 +348,22 @@ pub fn stmt_to_string(stmt: &ast::Stmt) -> String {\n     to_string(|s| s.print_stmt(stmt))\n }\n \n-pub fn attr_to_string(attr: &ast::Attribute) -> String {\n-    to_string(|s| s.print_attribute(attr))\n-}\n-\n pub fn item_to_string(i: &ast::Item) -> String {\n     to_string(|s| s.print_item(i))\n }\n \n-pub fn impl_item_to_string(i: &ast::ImplItem) -> String {\n+fn impl_item_to_string(i: &ast::ImplItem) -> String {\n     to_string(|s| s.print_impl_item(i))\n }\n \n-pub fn trait_item_to_string(i: &ast::TraitItem) -> String {\n+fn trait_item_to_string(i: &ast::TraitItem) -> String {\n     to_string(|s| s.print_trait_item(i))\n }\n \n pub fn generic_params_to_string(generic_params: &[ast::GenericParam]) -> String {\n     to_string(|s| s.print_generic_params(generic_params))\n }\n \n-pub fn where_clause_to_string(i: &ast::WhereClause) -> String {\n-    to_string(|s| s.print_where_clause(i))\n-}\n-\n-pub fn fn_block_to_string(p: &ast::FnDecl) -> String {\n-    to_string(|s| s.print_fn_block_args(p))\n-}\n-\n pub fn path_to_string(p: &ast::Path) -> String {\n     to_string(|s| s.print_path(p, false, 0))\n }\n@@ -390,7 +376,8 @@ pub fn vis_to_string(v: &ast::Visibility) -> String {\n     to_string(|s| s.print_visibility(v))\n }\n \n-pub fn fun_to_string(decl: &ast::FnDecl,\n+#[cfg(test)]\n+fn fun_to_string(decl: &ast::FnDecl,\n                      header: ast::FnHeader,\n                      name: ast::Ident,\n                      generics: &ast::Generics)\n@@ -404,7 +391,7 @@ pub fn fun_to_string(decl: &ast::FnDecl,\n     })\n }\n \n-pub fn block_to_string(blk: &ast::Block) -> String {\n+fn block_to_string(blk: &ast::Block) -> String {\n     to_string(|s| {\n         // containing cbox, will be closed by print-block at }\n         s.cbox(INDENT_UNIT);\n@@ -426,85 +413,38 @@ pub fn attribute_to_string(attr: &ast::Attribute) -> String {\n     to_string(|s| s.print_attribute(attr))\n }\n \n-pub fn lit_to_string(l: &ast::Lit) -> String {\n-    to_string(|s| s.print_literal(l))\n-}\n-\n-pub fn variant_to_string(var: &ast::Variant) -> String {\n+#[cfg(test)]\n+fn variant_to_string(var: &ast::Variant) -> String {\n     to_string(|s| s.print_variant(var))\n }\n \n pub fn arg_to_string(arg: &ast::Arg) -> String {\n     to_string(|s| s.print_arg(arg, false))\n }\n \n-pub fn mac_to_string(arg: &ast::Mac) -> String {\n-    to_string(|s| s.print_mac(arg))\n-}\n-\n-pub fn foreign_item_to_string(arg: &ast::ForeignItem) -> String {\n+fn foreign_item_to_string(arg: &ast::ForeignItem) -> String {\n     to_string(|s| s.print_foreign_item(arg))\n }\n \n-pub fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n+fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n     format!(\"{}{}\", to_string(|s| s.print_visibility(vis)), s)\n }\n \n-pub trait PrintState<'a> {\n-    fn writer(&mut self) -> &mut pp::Printer<'a>;\n-    fn boxes(&mut self) -> &mut Vec<pp::Breaks>;\n-    fn comments(&mut self) -> &mut Option<Vec<comments::Comment>>;\n-    fn cur_cmnt(&mut self) -> &mut usize;\n-\n-    fn word_space<S: Into<Cow<'static, str>>>(&mut self, w: S) {\n-        self.writer().word(w);\n-        self.writer().space()\n-    }\n-\n-    fn popen(&mut self) { self.writer().word(\"(\") }\n-\n-    fn pclose(&mut self) { self.writer().word(\")\") }\n-\n-    fn is_begin(&mut self) -> bool {\n-        match self.writer().last_token() {\n-            pp::Token::Begin(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    fn is_end(&mut self) -> bool {\n-        match self.writer().last_token() {\n-            pp::Token::End => true,\n-            _ => false,\n-        }\n-    }\n-\n-    // is this the beginning of a line?\n-    fn is_bol(&mut self) -> bool {\n-        self.writer().last_token().is_eof() || self.writer().last_token().is_hardbreak_tok()\n-    }\n-\n-    fn hardbreak_if_not_bol(&mut self) {\n-        if !self.is_bol() {\n-            self.writer().hardbreak()\n-        }\n-    }\n-\n-    // \"raw box\"\n-    fn rbox(&mut self, u: usize, b: pp::Breaks) {\n-        self.boxes().push(b);\n-        self.writer().rbox(u, b)\n+impl std::ops::Deref for State<'_> {\n+    type Target = pp::Printer;\n+    fn deref(&self) -> &Self::Target {\n+        &self.s\n     }\n+}\n \n-    fn ibox(&mut self, u: usize) {\n-        self.boxes().push(pp::Breaks::Inconsistent);\n-        self.writer().ibox(u);\n+impl std::ops::DerefMut for State<'_> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.s\n     }\n+}\n \n-    fn end(&mut self) {\n-        self.boxes().pop().unwrap();\n-        self.writer().end()\n-    }\n+pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefMut {\n+    fn comments(&mut self) -> &mut Option<Comments<'a>>;\n \n     fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], mut op: F)\n         where F: FnMut(&mut Self, &T),\n@@ -533,71 +473,65 @@ pub trait PrintState<'a> {\n         match cmnt.style {\n             comments::Mixed => {\n                 assert_eq!(cmnt.lines.len(), 1);\n-                self.writer().zerobreak();\n-                self.writer().word(cmnt.lines[0].clone());\n-                self.writer().zerobreak()\n+                self.zerobreak();\n+                self.word(cmnt.lines[0].clone());\n+                self.zerobreak()\n             }\n             comments::Isolated => {\n                 self.hardbreak_if_not_bol();\n                 for line in &cmnt.lines {\n                     // Don't print empty lines because they will end up as trailing\n                     // whitespace\n                     if !line.is_empty() {\n-                        self.writer().word(line.clone());\n+                        self.word(line.clone());\n                     }\n-                    self.writer().hardbreak();\n+                    self.hardbreak();\n                 }\n             }\n             comments::Trailing => {\n-                if !self.is_bol() {\n-                    self.writer().word(\" \");\n+                if !self.is_beginning_of_line() {\n+                    self.word(\" \");\n                 }\n                 if cmnt.lines.len() == 1 {\n-                    self.writer().word(cmnt.lines[0].clone());\n-                    self.writer().hardbreak()\n+                    self.word(cmnt.lines[0].clone());\n+                    self.hardbreak()\n                 } else {\n                     self.ibox(0);\n                     for line in &cmnt.lines {\n                         if !line.is_empty() {\n-                            self.writer().word(line.clone());\n+                            self.word(line.clone());\n                         }\n-                        self.writer().hardbreak();\n+                        self.hardbreak();\n                     }\n                     self.end();\n                 }\n             }\n             comments::BlankLine => {\n                 // We need to do at least one, possibly two hardbreaks.\n-                let is_semi = match self.writer().last_token() {\n-                    pp::Token::String(s, _) => \";\" == s,\n+                let twice = match self.last_token() {\n+                    pp::Token::String(s) => \";\" == s,\n+                    pp::Token::Begin(_) => true,\n+                    pp::Token::End => true,\n                     _ => false\n                 };\n-                if is_semi || self.is_begin() || self.is_end() {\n-                    self.writer().hardbreak();\n+                if twice {\n+                    self.hardbreak();\n                 }\n-                self.writer().hardbreak();\n+                self.hardbreak();\n             }\n         }\n-        *self.cur_cmnt() = *self.cur_cmnt() + 1;\n+        if let Some(cm) = self.comments() {\n+            cm.current += 1;\n+        }\n     }\n \n     fn next_comment(&mut self) -> Option<comments::Comment> {\n-        let cur_cmnt = *self.cur_cmnt();\n-        match *self.comments() {\n-            Some(ref cmnts) => {\n-                if cur_cmnt < cmnts.len() {\n-                    Some(cmnts[cur_cmnt].clone())\n-                } else {\n-                    None\n-                }\n-            }\n-            _ => None\n-        }\n+        self.comments().as_mut().and_then(|c| c.next())\n     }\n \n     fn print_literal(&mut self, lit: &ast::Lit) {\n         self.maybe_print_comment(lit.span.lo());\n-        self.writer().word(literal_to_string(lit.token))\n+        self.word(lit.token.to_string())\n     }\n \n     fn print_string(&mut self, st: &str,\n@@ -612,7 +546,7 @@ pub trait PrintState<'a> {\n                          string=st))\n             }\n         };\n-        self.writer().word(st)\n+        self.word(st)\n     }\n \n     fn print_inner_attributes(&mut self,\n@@ -664,10 +598,10 @@ pub trait PrintState<'a> {\n     fn print_attribute_path(&mut self, path: &ast::Path) {\n         for (i, segment) in path.segments.iter().enumerate() {\n             if i > 0 {\n-                self.writer().word(\"::\");\n+                self.word(\"::\");\n             }\n             if segment.ident.name != kw::PathRoot {\n-                self.writer().word(ident_to_string(segment.ident, segment.ident.is_raw_guess()));\n+                self.word(ident_to_string(segment.ident, segment.ident.is_raw_guess()));\n             }\n         }\n     }\n@@ -683,21 +617,21 @@ pub trait PrintState<'a> {\n         }\n         self.maybe_print_comment(attr.span.lo());\n         if attr.is_sugared_doc {\n-            self.writer().word(attr.value_str().unwrap().as_str().to_string());\n-            self.writer().hardbreak()\n+            self.word(attr.value_str().unwrap().as_str().to_string());\n+            self.hardbreak()\n         } else {\n             match attr.style {\n-                ast::AttrStyle::Inner => self.writer().word(\"#![\"),\n-                ast::AttrStyle::Outer => self.writer().word(\"#[\"),\n+                ast::AttrStyle::Inner => self.word(\"#![\"),\n+                ast::AttrStyle::Outer => self.word(\"#[\"),\n             }\n             if let Some(mi) = attr.meta() {\n                 self.print_meta_item(&mi);\n             } else {\n                 self.print_attribute_path(&attr.path);\n-                self.writer().space();\n+                self.space();\n                 self.print_tts(attr.tokens.clone());\n             }\n-            self.writer().word(\"]\");\n+            self.word(\"]\");\n         }\n     }\n \n@@ -718,7 +652,7 @@ pub trait PrintState<'a> {\n             ast::MetaItemKind::Word => self.print_attribute_path(&item.path),\n             ast::MetaItemKind::NameValue(ref value) => {\n                 self.print_attribute_path(&item.path);\n-                self.writer().space();\n+                self.space();\n                 self.word_space(\"=\");\n                 self.print_literal(value);\n             }\n@@ -744,20 +678,20 @@ pub trait PrintState<'a> {\n     fn print_tt(&mut self, tt: tokenstream::TokenTree, convert_dollar_crate: bool) {\n         match tt {\n             TokenTree::Token(ref token) => {\n-                self.writer().word(token_to_string_ext(&token, convert_dollar_crate));\n+                self.word(token_to_string_ext(&token, convert_dollar_crate));\n                 match token.kind {\n                     token::DocComment(..) => {\n-                        self.writer().hardbreak()\n+                        self.hardbreak()\n                     }\n                     _ => {}\n                 }\n             }\n             TokenTree::Delimited(_, delim, tts) => {\n-                self.writer().word(token_kind_to_string(&token::OpenDelim(delim)));\n-                self.writer().space();\n+                self.word(token_kind_to_string(&token::OpenDelim(delim)));\n+                self.space();\n                 self.print_tts(tts);\n-                self.writer().space();\n-                self.writer().word(token_kind_to_string(&token::CloseDelim(delim)))\n+                self.space();\n+                self.word(token_kind_to_string(&token::CloseDelim(delim)))\n             },\n         }\n     }\n@@ -770,49 +704,21 @@ pub trait PrintState<'a> {\n         self.ibox(0);\n         for (i, tt) in tts.into_trees().enumerate() {\n             if i != 0 {\n-                self.writer().space();\n+                self.space();\n             }\n             self.print_tt(tt, convert_dollar_crate);\n         }\n         self.end();\n     }\n-\n-    fn space_if_not_bol(&mut self) {\n-        if !self.is_bol() { self.writer().space(); }\n-    }\n-\n-    fn nbsp(&mut self) { self.writer().word(\" \") }\n }\n \n impl<'a> PrintState<'a> for State<'a> {\n-    fn writer(&mut self) -> &mut pp::Printer<'a> {\n-        &mut self.s\n-    }\n-\n-    fn boxes(&mut self) -> &mut Vec<pp::Breaks> {\n-        &mut self.boxes\n-    }\n-\n-    fn comments(&mut self) -> &mut Option<Vec<comments::Comment>> {\n+    fn comments(&mut self) -> &mut Option<Comments<'a>> {\n         &mut self.comments\n     }\n-\n-    fn cur_cmnt(&mut self) -> &mut usize {\n-        &mut self.cur_cmnt\n-    }\n }\n \n impl<'a> State<'a> {\n-    pub fn cbox(&mut self, u: usize) {\n-        self.boxes.push(pp::Breaks::Consistent);\n-        self.s.cbox(u);\n-    }\n-\n-    crate fn word_nbsp<S: Into<Cow<'static, str>>>(&mut self, w: S) {\n-        self.s.word(w);\n-        self.nbsp()\n-    }\n-\n     crate fn head<S: Into<Cow<'static, str>>>(&mut self, w: S) {\n         let w = w.into();\n         // outer-box is consistent\n@@ -830,26 +736,21 @@ impl<'a> State<'a> {\n         self.end(); // close the head-box\n     }\n \n-    crate fn bclose_(&mut self, span: syntax_pos::Span,\n-                   indented: usize) {\n-        self.bclose_maybe_open(span, indented, true)\n-    }\n-    crate fn bclose_maybe_open(&mut self, span: syntax_pos::Span,\n-                             indented: usize, close_box: bool) {\n+    crate fn bclose_maybe_open(&mut self, span: syntax_pos::Span, close_box: bool) {\n         self.maybe_print_comment(span.hi());\n-        self.break_offset_if_not_bol(1, -(indented as isize));\n+        self.break_offset_if_not_bol(1, -(INDENT_UNIT as isize));\n         self.s.word(\"}\");\n         if close_box {\n             self.end(); // close the outer-box\n         }\n     }\n     crate fn bclose(&mut self, span: syntax_pos::Span) {\n-        self.bclose_(span, INDENT_UNIT)\n+        self.bclose_maybe_open(span, true)\n     }\n \n     crate fn break_offset_if_not_bol(&mut self, n: usize,\n                                    off: isize) {\n-        if !self.is_bol() {\n+        if !self.s.is_beginning_of_line() {\n             self.s.break_offset(n, off)\n         } else {\n             if off != 0 && self.s.last_token().is_hardbreak_tok() {\n@@ -1650,20 +1551,18 @@ impl<'a> State<'a> {\n         self.print_block_with_attrs(blk, &[])\n     }\n \n-    crate fn print_block_unclosed_indent(&mut self, blk: &ast::Block,\n-                                       indented: usize) {\n-        self.print_block_maybe_unclosed(blk, indented, &[], false)\n+    crate fn print_block_unclosed_indent(&mut self, blk: &ast::Block) {\n+        self.print_block_maybe_unclosed(blk, &[], false)\n     }\n \n     crate fn print_block_with_attrs(&mut self,\n                                   blk: &ast::Block,\n                                   attrs: &[ast::Attribute]) {\n-        self.print_block_maybe_unclosed(blk, INDENT_UNIT, attrs, true)\n+        self.print_block_maybe_unclosed(blk, attrs, true)\n     }\n \n     crate fn print_block_maybe_unclosed(&mut self,\n                                       blk: &ast::Block,\n-                                      indented: usize,\n                                       attrs: &[ast::Attribute],\n                                       close_box: bool) {\n         match blk.rules {\n@@ -1688,7 +1587,7 @@ impl<'a> State<'a> {\n             }\n         }\n \n-        self.bclose_maybe_open(blk.span, indented, close_box);\n+        self.bclose_maybe_open(blk.span, close_box);\n         self.ann.post(self, AnnNode::Block(blk))\n     }\n \n@@ -2070,7 +1969,7 @@ impl<'a> State<'a> {\n             }\n             ast::ExprKind::Match(ref expr, ref arms) => {\n                 self.cbox(INDENT_UNIT);\n-                self.ibox(4);\n+                self.ibox(INDENT_UNIT);\n                 self.word_nbsp(\"match\");\n                 self.print_expr_as_cond(expr);\n                 self.s.space();\n@@ -2079,7 +1978,7 @@ impl<'a> State<'a> {\n                 for arm in arms {\n                     self.print_arm(arm);\n                 }\n-                self.bclose_(expr.span, INDENT_UNIT);\n+                self.bclose(expr.span);\n             }\n             ast::ExprKind::Closure(\n                 capture_clause, asyncness, movability, ref decl, ref body, _) => {\n@@ -2610,7 +2509,7 @@ impl<'a> State<'a> {\n                 }\n \n                 // the block will close the pattern's ibox\n-                self.print_block_unclosed_indent(blk, INDENT_UNIT);\n+                self.print_block_unclosed_indent(blk);\n \n                 // If it is a user-provided unsafe block, print a comma after it\n                 if let BlockCheckMode::Unsafe(ast::UserProvided) = blk.rules {\n@@ -2963,18 +2862,10 @@ impl<'a> State<'a> {\n \n     crate fn maybe_print_trailing_comment(&mut self, span: syntax_pos::Span,\n                                         next_pos: Option<BytePos>)\n-        {\n-        let cm = match self.cm {\n-            Some(cm) => cm,\n-            _ => return,\n-        };\n-        if let Some(ref cmnt) = self.next_comment() {\n-            if cmnt.style != comments::Trailing { return; }\n-            let span_line = cm.lookup_char_pos(span.hi());\n-            let comment_line = cm.lookup_char_pos(cmnt.pos);\n-            let next = next_pos.unwrap_or_else(|| cmnt.pos + BytePos(1));\n-            if span.hi() < cmnt.pos && cmnt.pos < next && span_line.line == comment_line.line {\n-                self.print_comment(cmnt);\n+    {\n+        if let Some(cmnts) = self.comments() {\n+            if let Some(cmnt) = cmnts.trailing_comment(span, next_pos) {\n+                self.print_comment(&cmnt);\n             }\n         }\n     }"}]}