{"sha": "fee457d3af355f24ef321ea7250e968638f403c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlZTQ1N2QzYWYzNTVmMjRlZjMyMWVhNzI1MGU5Njg2MzhmNDAzYzg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-01-25T05:14:56Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-01-26T01:48:27Z"}, "message": "std: Fix some behavior without stdio handles\n\nOn all platforms, reading from stdin where the actual stdin isn't present should\nreturn 0 bytes as having been read rather than the entire buffer.\n\nOn Windows, handle the case where we're inheriting stdio handles but one of them\nisn't present. Currently the behavior is to fail returning an I/O error but\ninstead this commit corrects it to detecting this situation and propagating the\nnon-set handle.\n\nCloses #31167", "tree": {"sha": "f18d89060efa06320b851137933db8b87e99934d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f18d89060efa06320b851137933db8b87e99934d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fee457d3af355f24ef321ea7250e968638f403c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fee457d3af355f24ef321ea7250e968638f403c8", "html_url": "https://github.com/rust-lang/rust/commit/fee457d3af355f24ef321ea7250e968638f403c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fee457d3af355f24ef321ea7250e968638f403c8/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6866f1361debf5857856ff95eeee806bb7bea738", "url": "https://api.github.com/repos/rust-lang/rust/commits/6866f1361debf5857856ff95eeee806bb7bea738", "html_url": "https://github.com/rust-lang/rust/commit/6866f1361debf5857856ff95eeee806bb7bea738"}], "stats": {"total": 137, "additions": 133, "deletions": 4}, "files": [{"sha": "cd2d5e52462bb91b8e63d4bd02e74411ad0ec874", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fee457d3af355f24ef321ea7250e968638f403c8/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fee457d3af355f24ef321ea7250e968638f403c8/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=fee457d3af355f24ef321ea7250e968638f403c8", "patch": "@@ -112,7 +112,7 @@ impl<W: io::Write> io::Write for Maybe<W> {\n impl<R: io::Read> io::Read for Maybe<R> {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         match *self {\n-            Maybe::Real(ref mut r) => handle_ebadf(r.read(buf), buf.len()),\n+            Maybe::Real(ref mut r) => handle_ebadf(r.read(buf), 0),\n             Maybe::Fake => Ok(0)\n         }\n     }"}, {"sha": "61f73b00265b836de013c0bdfcb5278f80ab944d", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fee457d3af355f24ef321ea7250e968638f403c8/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fee457d3af355f24ef321ea7250e968638f403c8/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=fee457d3af355f24ef321ea7250e968638f403c8", "patch": "@@ -351,10 +351,15 @@ fn make_dirp(d: Option<&OsString>) -> (*const u16, Vec<u16>) {\n impl Stdio {\n     fn to_handle(&self, stdio_id: c::DWORD) -> io::Result<Handle> {\n         match *self {\n+            // If no stdio handle is available, then inherit means that it\n+            // should still be unavailable so propagate the\n+            // INVALID_HANDLE_VALUE.\n             Stdio::Inherit => {\n-                stdio::get(stdio_id).and_then(|io| {\n-                    io.handle().duplicate(0, true, c::DUPLICATE_SAME_ACCESS)\n-                })\n+                match stdio::get(stdio_id) {\n+                    Ok(io) => io.handle().duplicate(0, true,\n+                                                    c::DUPLICATE_SAME_ACCESS),\n+                    Err(..) => Ok(Handle::new(c::INVALID_HANDLE_VALUE)),\n+                }\n             }\n             Stdio::Raw(handle) => {\n                 RawHandle::new(handle).duplicate(0, true, c::DUPLICATE_SAME_ACCESS)"}, {"sha": "3658b6a508ab27f70dced8393300d83bd11e90a6", "filename": "src/test/run-pass/no-stdio.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/fee457d3af355f24ef321ea7250e968638f403c8/src%2Ftest%2Frun-pass%2Fno-stdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fee457d3af355f24ef321ea7250e968638f403c8/src%2Ftest%2Frun-pass%2Fno-stdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fno-stdio.rs?ref=fee457d3af355f24ef321ea7250e968638f403c8", "patch": "@@ -0,0 +1,124 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(libc)]\n+\n+extern crate libc;\n+\n+use std::process::{Command, Stdio};\n+use std::env;\n+use std::io::{self, Read, Write};\n+\n+#[cfg(unix)]\n+unsafe fn without_stdio<R, F: FnOnce() -> R>(f: F) -> R {\n+    let doit = |a| {\n+        let r = libc::dup(a);\n+        assert!(r >= 0);\n+        return r\n+    };\n+    let a = doit(0);\n+    let b = doit(1);\n+    let c = doit(2);\n+\n+    assert!(libc::close(0) >= 0);\n+    assert!(libc::close(1) >= 0);\n+    assert!(libc::close(2) >= 0);\n+\n+    let r = f();\n+\n+    assert!(libc::dup2(a, 0) >= 0);\n+    assert!(libc::dup2(b, 1) >= 0);\n+    assert!(libc::dup2(c, 2) >= 0);\n+\n+    return r\n+}\n+\n+#[cfg(windows)]\n+unsafe fn without_stdio<R, F: FnOnce() -> R>(f: F) -> R {\n+    type DWORD = u32;\n+    type HANDLE = *mut u8;\n+    type BOOL = i32;\n+\n+    const STD_INPUT_HANDLE: DWORD = -10i32 as DWORD;\n+    const STD_OUTPUT_HANDLE: DWORD = -11i32 as DWORD;\n+    const STD_ERROR_HANDLE: DWORD = -12i32 as DWORD;\n+    const INVALID_HANDLE_VALUE: HANDLE = !0 as HANDLE;\n+\n+    extern \"system\" {\n+        fn GetStdHandle(which: DWORD) -> HANDLE;\n+        fn SetStdHandle(which: DWORD, handle: HANDLE) -> BOOL;\n+    }\n+\n+    let doit = |id| {\n+        let handle = GetStdHandle(id);\n+        assert!(handle != INVALID_HANDLE_VALUE);\n+        assert!(SetStdHandle(id, INVALID_HANDLE_VALUE) != 0);\n+        return handle\n+    };\n+\n+    let a = doit(STD_INPUT_HANDLE);\n+    let b = doit(STD_OUTPUT_HANDLE);\n+    let c = doit(STD_ERROR_HANDLE);\n+\n+    let r = f();\n+\n+    let doit = |id, handle| {\n+        assert!(SetStdHandle(id, handle) != 0);\n+    };\n+    doit(STD_INPUT_HANDLE, a);\n+    doit(STD_OUTPUT_HANDLE, b);\n+    doit(STD_ERROR_HANDLE, c);\n+\n+    return r\n+}\n+\n+fn main() {\n+    if env::args().len() > 1 {\n+        println!(\"test\");\n+        assert!(io::stdout().write(b\"test\\n\").is_ok());\n+        assert!(io::stderr().write(b\"test\\n\").is_ok());\n+        assert_eq!(io::stdin().read(&mut [0; 10]).unwrap(), 0);\n+        return\n+    }\n+\n+    // First, make sure reads/writes without stdio work if stdio itself is\n+    // missing.\n+    let (a, b, c) = unsafe {\n+        without_stdio(|| {\n+            let a = io::stdout().write(b\"test\\n\");\n+            let b = io::stderr().write(b\"test\\n\");\n+            let c = io::stdin().read(&mut [0; 10]);\n+\n+            (a, b, c)\n+        })\n+    };\n+\n+    assert_eq!(a.unwrap(), 5);\n+    assert_eq!(b.unwrap(), 5);\n+    assert_eq!(c.unwrap(), 0);\n+\n+    // Second, spawn a child and do some work with \"null\" descriptors to make\n+    // sure it's ok\n+    let me = env::current_exe().unwrap();\n+    let status = Command::new(&me)\n+                        .arg(\"next\")\n+                        .stdin(Stdio::null())\n+                        .stdout(Stdio::null())\n+                        .stderr(Stdio::null())\n+                        .status().unwrap();\n+    assert!(status.success(), \"{:?} isn't a success\", status);\n+\n+    // Finally, close everything then spawn a child to make sure everything is\n+    // *still* ok.\n+    let status = unsafe {\n+        without_stdio(|| Command::new(&me).arg(\"next\").status())\n+    }.unwrap();\n+    assert!(status.success(), \"{:?} isn't a success\", status);\n+}"}]}