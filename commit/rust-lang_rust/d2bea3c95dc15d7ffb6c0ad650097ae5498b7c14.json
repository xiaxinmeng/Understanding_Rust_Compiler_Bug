{"sha": "d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyYmVhM2M5NWRjMTVkN2ZmYjZjMGFkNjUwMDk3YWU1NDk4YjdjMTQ=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-10-18T20:48:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-18T20:48:11Z"}, "message": "Rollup merge of #65197 - spastorino:place-mut-visitor-adjusts2, r=oli-obk\n\nPrepare `MutVisitor`s to handle interned projections\n\nThe following are all the files where mir's `MutVisitor` is implemented. The `-` there stands for no changes, `visit_place` wasn't making any change on `Place`s. `x` stands for this file was changed to make `visit_place` do whatever it was doing with the base but avoid modifying the projection, instead just create a new one and assign to it.\n\n```\n[-] src/librustc_mir/transform/no_landing_pads.rs\n[x] src/librustc_mir/transform/promote_consts.rs\n[x] src/librustc_mir/transform/generator.rs\n[x] src/librustc_mir/transform/erase_regions.rs\n[-] src/librustc_mir/transform/instcombine.rs\n[x] src/librustc_mir/transform/inline.rs\n[x] src/librustc_mir/transform/simplify.rs\n[x] src/librustc_mir/util/def_use.rs\n[-] src/librustc_mir/transform/const_prop.rs\n[-] src/librustc_mir/transform/cleanup_post_borrowck.rs\n[x] src/librustc_mir/borrow_check/nll/renumber.rs\n[-] src/librustc_mir/transform/copy_prop.rs\n```\n\nThere is some code repetition, just created the PR so we can start discussing it.\n\n/cc @oli-obk @nikomatsakis", "tree": {"sha": "3380f39202e30995799897d3c4ede11e7c1150cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3380f39202e30995799897d3c4ede11e7c1150cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdqiULCRBK7hj4Ov3rIwAAdHIIACTAHSk4kXYh+3Q3KOdnF4Gr\nsEnL82CbwXzvOOJPhVzfY/6ZKMFRZ8bV0VpYnktSBuLtUhweZb9kc+YSKVjSLLI5\npPVYjHhyp12+vJDw50ECT1ljwMYDYlwEBijjiW7/KnZ3rg1w+gLiFcrI37JKi1/Z\nuJk7zcvQsMOp15rDDVw1nTAirYAGnwjNeQQdWMD6pvyTR5ovbwRxaecfNGenFxtm\nqDFjpffYTiKK9IEwJMK0J4L07IzsknXFHt//NncOPOh1kAz/o62T9yQ11OzT5t7Q\nKWsYIa3wctaOY3lTuI1Cynk9nmdHJpslZnBbCCKWubLuY1ZXFPwC3yqcPgQZeXM=\n=ELyo\n-----END PGP SIGNATURE-----\n", "payload": "tree 3380f39202e30995799897d3c4ede11e7c1150cc\nparent 7167a592414875bfa01e9e37ff2b905086a2761a\nparent 48349960e68a9d19b17ac54cd12e939a9a46ea7d\nauthor Tyler Mandry <tmandry@gmail.com> 1571431691 -0700\ncommitter GitHub <noreply@github.com> 1571431691 -0700\n\nRollup merge of #65197 - spastorino:place-mut-visitor-adjusts2, r=oli-obk\n\nPrepare `MutVisitor`s to handle interned projections\n\nThe following are all the files where mir's `MutVisitor` is implemented. The `-` there stands for no changes, `visit_place` wasn't making any change on `Place`s. `x` stands for this file was changed to make `visit_place` do whatever it was doing with the base but avoid modifying the projection, instead just create a new one and assign to it.\n\n```\n[-] src/librustc_mir/transform/no_landing_pads.rs\n[x] src/librustc_mir/transform/promote_consts.rs\n[x] src/librustc_mir/transform/generator.rs\n[x] src/librustc_mir/transform/erase_regions.rs\n[-] src/librustc_mir/transform/instcombine.rs\n[x] src/librustc_mir/transform/inline.rs\n[x] src/librustc_mir/transform/simplify.rs\n[x] src/librustc_mir/util/def_use.rs\n[-] src/librustc_mir/transform/const_prop.rs\n[-] src/librustc_mir/transform/cleanup_post_borrowck.rs\n[x] src/librustc_mir/borrow_check/nll/renumber.rs\n[-] src/librustc_mir/transform/copy_prop.rs\n```\n\nThere is some code repetition, just created the PR so we can start discussing it.\n\n/cc @oli-obk @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14", "html_url": "https://github.com/rust-lang/rust/commit/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7167a592414875bfa01e9e37ff2b905086a2761a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7167a592414875bfa01e9e37ff2b905086a2761a", "html_url": "https://github.com/rust-lang/rust/commit/7167a592414875bfa01e9e37ff2b905086a2761a"}, {"sha": "48349960e68a9d19b17ac54cd12e939a9a46ea7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/48349960e68a9d19b17ac54cd12e939a9a46ea7d", "html_url": "https://github.com/rust-lang/rust/commit/48349960e68a9d19b17ac54cd12e939a9a46ea7d"}], "stats": {"total": 423, "additions": 301, "deletions": 122}, "files": [{"sha": "fef406e8987834328e3cf3aca97d58bec78e48a2", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 136, "deletions": 77, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14", "patch": "@@ -158,22 +158,7 @@ macro_rules! make_mir_visitor {\n                 self.super_place_base(base, context, location);\n             }\n \n-            fn visit_projection(&mut self,\n-                                base: & $($mutability)? PlaceBase<'tcx>,\n-                                projection: & $($mutability)? [PlaceElem<'tcx>],\n-                                context: PlaceContext,\n-                                location: Location) {\n-                self.super_projection(base, projection, context, location);\n-            }\n-\n-            fn visit_projection_elem(&mut self,\n-                                     base: & $($mutability)? PlaceBase<'tcx>,\n-                                     proj_base: & $($mutability)? [PlaceElem<'tcx>],\n-                                     elem: & $($mutability)? PlaceElem<'tcx>,\n-                                     context: PlaceContext,\n-                                     location: Location) {\n-                self.super_projection_elem(base, proj_base, elem, context, location);\n-            }\n+            visit_place_fns!($($mutability)?);\n \n             fn visit_constant(&mut self,\n                               constant: & $($mutability)? Constant<'tcx>,\n@@ -681,28 +666,6 @@ macro_rules! make_mir_visitor {\n                 );\n             }\n \n-            fn super_place(&mut self,\n-                            place: & $($mutability)? Place<'tcx>,\n-                            context: PlaceContext,\n-                            location: Location) {\n-                let mut context = context;\n-\n-                if !place.projection.is_empty() {\n-                    context = if context.is_mutating_use() {\n-                        PlaceContext::MutatingUse(MutatingUseContext::Projection)\n-                    } else {\n-                        PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n-                    };\n-                }\n-\n-                self.visit_place_base(& $($mutability)? place.base, context, location);\n-\n-                self.visit_projection(& $($mutability)? place.base,\n-                                      & $($mutability)? place.projection,\n-                                      context,\n-                                      location);\n-            }\n-\n             fn super_place_base(&mut self,\n                                 place_base: & $($mutability)? PlaceBase<'tcx>,\n                                 context: PlaceContext,\n@@ -717,45 +680,6 @@ macro_rules! make_mir_visitor {\n                 }\n             }\n \n-            fn super_projection(&mut self,\n-                                base: & $($mutability)? PlaceBase<'tcx>,\n-                                projection: & $($mutability)? [PlaceElem<'tcx>],\n-                                context: PlaceContext,\n-                                location: Location) {\n-                let mut cursor = projection;\n-                while let [proj_base @ .., elem] = cursor {\n-                    cursor = proj_base;\n-                    self.visit_projection_elem(base, cursor, elem, context, location);\n-                }\n-            }\n-\n-            fn super_projection_elem(&mut self,\n-                                     _base: & $($mutability)? PlaceBase<'tcx>,\n-                                     _proj_base: & $($mutability)? [PlaceElem<'tcx>],\n-                                     elem: & $($mutability)? PlaceElem<'tcx>,\n-                                     _context: PlaceContext,\n-                                     location: Location) {\n-                match elem {\n-                    ProjectionElem::Field(_field, ty) => {\n-                        self.visit_ty(ty, TyContext::Location(location));\n-                    }\n-                    ProjectionElem::Index(local) => {\n-                        self.visit_local(\n-                            local,\n-                            PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n-                            location\n-                        );\n-                    }\n-                    ProjectionElem::Deref |\n-                    ProjectionElem::Subslice { from: _, to: _ } |\n-                    ProjectionElem::ConstantIndex { offset: _,\n-                                                    min_length: _,\n-                                                    from_end: _ } |\n-                    ProjectionElem::Downcast(_, _) => {\n-                    }\n-                }\n-            }\n-\n             fn super_local_decl(&mut self,\n                                 local: Local,\n                                 local_decl: & $($mutability)? LocalDecl<'tcx>) {\n@@ -858,6 +782,141 @@ macro_rules! make_mir_visitor {\n     }\n }\n \n+macro_rules! visit_place_fns {\n+    (mut) => (\n+        fn super_place(\n+            &mut self,\n+            place: &mut Place<'tcx>,\n+            context: PlaceContext,\n+            location: Location,\n+        ) {\n+            self.visit_place_base(&mut place.base, context, location);\n+\n+            if let Some(new_projection) = self.process_projection(&place.projection) {\n+                place.projection = new_projection;\n+            }\n+        }\n+\n+        fn process_projection(\n+            &mut self,\n+            projection: &'a [PlaceElem<'tcx>],\n+        ) -> Option<Box<[PlaceElem<'tcx>]>> {\n+            let mut projection = Cow::Borrowed(projection);\n+\n+            for i in 0..projection.len() {\n+                if let Some(elem) = projection.get(i) {\n+                    if let Some(elem) = self.process_projection_elem(elem) {\n+                        let vec = projection.to_mut();\n+                        vec[i] = elem;\n+                    }\n+                }\n+            }\n+\n+            match projection {\n+                Cow::Borrowed(_) => None,\n+                Cow::Owned(vec) => Some(vec.into_boxed_slice()),\n+            }\n+        }\n+\n+        fn process_projection_elem(\n+            &mut self,\n+            _elem: &PlaceElem<'tcx>,\n+        ) -> Option<PlaceElem<'tcx>> {\n+            None\n+        }\n+    );\n+\n+    () => (\n+        fn visit_projection(\n+            &mut self,\n+            base: &PlaceBase<'tcx>,\n+            projection: &[PlaceElem<'tcx>],\n+            context: PlaceContext,\n+            location: Location,\n+        ) {\n+            self.super_projection(base, projection, context, location);\n+        }\n+\n+        fn visit_projection_elem(\n+            &mut self,\n+            base: &PlaceBase<'tcx>,\n+            proj_base: &[PlaceElem<'tcx>],\n+            elem: &PlaceElem<'tcx>,\n+            context: PlaceContext,\n+            location: Location,\n+        ) {\n+            self.super_projection_elem(base, proj_base, elem, context, location);\n+        }\n+\n+        fn super_place(\n+            &mut self,\n+            place: &Place<'tcx>,\n+            context: PlaceContext,\n+            location: Location,\n+        ) {\n+            let mut context = context;\n+\n+            if !place.projection.is_empty() {\n+                context = if context.is_mutating_use() {\n+                    PlaceContext::MutatingUse(MutatingUseContext::Projection)\n+                } else {\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n+                };\n+            }\n+\n+            self.visit_place_base(&place.base, context, location);\n+\n+            self.visit_projection(&place.base,\n+                                  &place.projection,\n+                                  context,\n+                                  location);\n+        }\n+\n+        fn super_projection(\n+            &mut self,\n+            base: &PlaceBase<'tcx>,\n+            projection: &[PlaceElem<'tcx>],\n+            context: PlaceContext,\n+            location: Location,\n+        ) {\n+            let mut cursor = projection;\n+            while let [proj_base @ .., elem] = cursor {\n+                cursor = proj_base;\n+                self.visit_projection_elem(base, cursor, elem, context, location);\n+            }\n+        }\n+\n+        fn super_projection_elem(\n+            &mut self,\n+            _base: &PlaceBase<'tcx>,\n+            _proj_base: &[PlaceElem<'tcx>],\n+            elem: &PlaceElem<'tcx>,\n+            _context: PlaceContext,\n+            location: Location,\n+        ) {\n+            match elem {\n+                ProjectionElem::Field(_field, ty) => {\n+                    self.visit_ty(ty, TyContext::Location(location));\n+                }\n+                ProjectionElem::Index(local) => {\n+                    self.visit_local(\n+                        local,\n+                        PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n+                        location\n+                    );\n+                }\n+                ProjectionElem::Deref |\n+                ProjectionElem::Subslice { from: _, to: _ } |\n+                ProjectionElem::ConstantIndex { offset: _,\n+                                                min_length: _,\n+                                                from_end: _ } |\n+                ProjectionElem::Downcast(_, _) => {\n+                }\n+            }\n+        }\n+    );\n+}\n+\n make_mir_visitor!(Visitor,);\n make_mir_visitor!(MutVisitor,mut);\n "}, {"sha": "9ecd6f837750e797365b467b434a4d818dcaf5ad", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14", "patch": "@@ -1,6 +1,6 @@\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::mir::{Location, Body, Promoted};\n+use rustc::mir::{Body, Location, PlaceElem, Promoted};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc_index::vec::IndexVec;\n@@ -62,6 +62,21 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'tcx> {\n         debug!(\"visit_ty: ty={:?}\", ty);\n     }\n \n+    fn process_projection_elem(\n+        &mut self,\n+        elem: &PlaceElem<'tcx>,\n+    ) -> Option<PlaceElem<'tcx>> {\n+        if let PlaceElem::Field(field, ty) = elem {\n+            let new_ty = self.renumber_regions(ty);\n+\n+            if new_ty != *ty {\n+                return Some(PlaceElem::Field(*field, new_ty));\n+            }\n+        }\n+\n+        None\n+    }\n+\n     fn visit_substs(&mut self, substs: &mut SubstsRef<'tcx>, location: Location) {\n         debug!(\"visit_substs(substs={:?}, location={:?})\", substs, location);\n "}, {"sha": "439cae2093ae5361ec82b136f369d862cd03f796", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14", "patch": "@@ -25,7 +25,6 @@ impl EraseRegionsVisitor<'tcx> {\n impl MutVisitor<'tcx> for EraseRegionsVisitor<'tcx> {\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: TyContext) {\n         *ty = self.tcx.erase_regions(ty);\n-        self.super_ty(ty);\n     }\n \n     fn visit_region(&mut self, region: &mut ty::Region<'tcx>, _: Location) {\n@@ -39,6 +38,21 @@ impl MutVisitor<'tcx> for EraseRegionsVisitor<'tcx> {\n     fn visit_substs(&mut self, substs: &mut SubstsRef<'tcx>, _: Location) {\n         *substs = self.tcx.erase_regions(substs);\n     }\n+\n+    fn process_projection_elem(\n+        &mut self,\n+        elem: &PlaceElem<'tcx>,\n+    ) -> Option<PlaceElem<'tcx>> {\n+        if let PlaceElem::Field(field, ty) = elem {\n+            let new_ty = self.tcx.erase_regions(ty);\n+\n+            if new_ty != *ty {\n+                return Some(PlaceElem::Field(*field, new_ty));\n+            }\n+        }\n+\n+        None\n+    }\n }\n \n pub struct EraseRegions;"}, {"sha": "6533e3c5ba81fcc8180252c5bb8299eb09fadb82", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14", "patch": "@@ -88,6 +88,18 @@ impl<'tcx> MutVisitor<'tcx> for RenameLocalVisitor {\n             *local = self.to;\n         }\n     }\n+\n+    fn process_projection_elem(\n+        &mut self,\n+        elem: &PlaceElem<'tcx>,\n+    ) -> Option<PlaceElem<'tcx>> {\n+        match elem {\n+            PlaceElem::Index(local) if *local == self.from => {\n+                Some(PlaceElem::Index(self.to))\n+            }\n+            _ => None,\n+        }\n+    }\n }\n \n struct DerefArgVisitor;\n@@ -110,7 +122,13 @@ impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n                 projection: Box::new([ProjectionElem::Deref]),\n             });\n         } else {\n-            self.super_place(place, context, location);\n+            self.visit_place_base(&mut place.base, context, location);\n+\n+            for elem in place.projection.iter() {\n+                if let PlaceElem::Index(local) = elem {\n+                    assert_ne!(*local, self_arg());\n+                }\n+            }\n         }\n     }\n }\n@@ -137,7 +155,13 @@ impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n                 projection: Box::new([ProjectionElem::Field(Field::new(0), self.ref_gen_ty)]),\n             });\n         } else {\n-            self.super_place(place, context, location);\n+            self.visit_place_base(&mut place.base, context, location);\n+\n+            for elem in place.projection.iter() {\n+                if let PlaceElem::Index(local) = elem {\n+                    assert_ne!(*local, self_arg());\n+                }\n+            }\n         }\n     }\n }\n@@ -247,17 +271,25 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n         assert_eq!(self.remap.get(local), None);\n     }\n \n-    fn visit_place(&mut self,\n-                    place: &mut Place<'tcx>,\n-                    context: PlaceContext,\n-                    location: Location) {\n+    fn visit_place(\n+        &mut self,\n+        place: &mut Place<'tcx>,\n+        context: PlaceContext,\n+        location: Location,\n+    ) {\n         if let PlaceBase::Local(l) = place.base {\n             // Replace an Local in the remap with a generator struct access\n             if let Some(&(ty, variant_index, idx)) = self.remap.get(&l) {\n                 replace_base(place, self.make_field(variant_index, idx, ty));\n             }\n         } else {\n-            self.super_place(place, context, location);\n+            self.visit_place_base(&mut place.base, context, location);\n+\n+            for elem in place.projection.iter() {\n+                if let PlaceElem::Index(local) = elem {\n+                    assert_ne!(*local, self_arg());\n+                }\n+            }\n         }\n     }\n "}, {"sha": "0cbdcedff4780dea11618d9a609c18f2436ff196", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14", "patch": "@@ -647,38 +647,45 @@ impl<'a, 'tcx> Integrator<'a, 'tcx> {\n         debug!(\"updating target `{:?}`, new: `{:?}`\", tgt, new);\n         new\n     }\n-}\n \n-impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n-    fn visit_local(&mut self,\n-                   local: &mut Local,\n-                   _ctxt: PlaceContext,\n-                   _location: Location) {\n+    fn make_integrate_local(&self, local: &Local) -> Local {\n         if *local == RETURN_PLACE {\n             match self.destination {\n                 Place {\n                     base: PlaceBase::Local(l),\n                     projection: box [],\n                 } => {\n-                    *local = l;\n-                    return;\n+                    return l;\n                 },\n                 ref place => bug!(\"Return place is {:?}, not local\", place)\n             }\n         }\n+\n         let idx = local.index() - 1;\n         if idx < self.args.len() {\n-            *local = self.args[idx];\n-            return;\n+            return self.args[idx];\n         }\n-        *local = self.local_map[Local::new(idx - self.args.len())];\n+\n+        self.local_map[Local::new(idx - self.args.len())]\n     }\n+}\n \n-    fn visit_place(&mut self,\n-                    place: &mut Place<'tcx>,\n-                    _ctxt: PlaceContext,\n-                    _location: Location) {\n+impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n+    fn visit_local(\n+        &mut self,\n+        local: &mut Local,\n+        _ctxt: PlaceContext,\n+        _location: Location,\n+    ) {\n+        *local = self.make_integrate_local(local);\n+    }\n \n+    fn visit_place(\n+        &mut self,\n+        place: &mut Place<'tcx>,\n+        context: PlaceContext,\n+        location: Location,\n+    ) {\n         match place {\n             Place {\n                 base: PlaceBase::Local(RETURN_PLACE),\n@@ -687,10 +694,27 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                 // Return pointer; update the place itself\n                 *place = self.destination.clone();\n             },\n-            _ => self.super_place(place, _ctxt, _location)\n+            _ => {\n+                self.super_place(place, context, location);\n+            }\n         }\n     }\n \n+    fn process_projection_elem(\n+        &mut self,\n+        elem: &PlaceElem<'tcx>,\n+    ) -> Option<PlaceElem<'tcx>> {\n+        if let PlaceElem::Index(local) = elem {\n+            let new_local = self.make_integrate_local(local);\n+\n+            if new_local != *local {\n+                return Some(PlaceElem::Index(new_local))\n+            }\n+        }\n+\n+        None\n+    }\n+\n     fn visit_basic_block_data(&mut self, block: BasicBlock, data: &mut BasicBlockData<'tcx>) {\n         self.in_cleanup_block = data.is_cleanup;\n         self.super_basic_block_data(block, data);"}, {"sha": "ad1785417cd93409633603c784e9b8735143e92c", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14", "patch": "@@ -191,6 +191,10 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         });\n     }\n \n+    fn is_temp_kind(&self, local: Local) -> bool {\n+        self.source.local_kind(local) == LocalKind::Temp\n+    }\n+\n     /// Copies the initialization of this temp to the\n     /// promoted MIR, recursing through temps.\n     fn promote_temp(&mut self, temp: Local) -> Local {\n@@ -396,10 +400,22 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n                    local: &mut Local,\n                    _: PlaceContext,\n                    _: Location) {\n-        if self.source.local_kind(*local) == LocalKind::Temp {\n+        if self.is_temp_kind(*local) {\n             *local = self.promote_temp(*local);\n         }\n     }\n+\n+    fn process_projection_elem(\n+        &mut self,\n+        elem: &PlaceElem<'tcx>,\n+    ) -> Option<PlaceElem<'tcx>> {\n+        match elem {\n+            PlaceElem::Index(local) if self.is_temp_kind(*local) => {\n+                Some(PlaceElem::Index(self.promote_temp(*local)))\n+            }\n+            _ => None,\n+        }\n+    }\n }\n \n pub fn promote_candidates<'tcx>("}, {"sha": "606c1a3a1cc09dd9deb761c42b0fe8f819340410", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14", "patch": "@@ -366,7 +366,20 @@ impl<'tcx> MutVisitor<'tcx> for LocalUpdater {\n         });\n         self.super_basic_block_data(block, data);\n     }\n+\n     fn visit_local(&mut self, l: &mut Local, _: PlaceContext, _: Location) {\n         *l = self.map[*l].unwrap();\n     }\n+\n+    fn process_projection_elem(\n+        &mut self,\n+        elem: &PlaceElem<'tcx>,\n+    ) -> Option<PlaceElem<'tcx>> {\n+        match elem {\n+            PlaceElem::Index(local) => {\n+                Some(PlaceElem::Index(self.map[*local].unwrap()))\n+            }\n+            _ => None\n+        }\n+    }\n }"}, {"sha": "cdd07ad4b8ff4b88ba81689ddbf0aca0b71a7055", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=d2bea3c95dc15d7ffb6c0ad650097ae5498b7c14", "patch": "@@ -1,6 +1,6 @@\n //! Def-use analysis.\n \n-use rustc::mir::{Local, Location, Body};\n+use rustc::mir::{Body, Local, Location, PlaceElem};\n use rustc::mir::visit::{PlaceContext, MutVisitor, Visitor};\n use rustc_index::vec::IndexVec;\n use std::mem;\n@@ -47,13 +47,10 @@ impl DefUseAnalysis {\n         &self.info[local]\n     }\n \n-    fn mutate_defs_and_uses<F>(&self, local: Local, body: &mut Body<'_>, mut callback: F)\n-                               where F: for<'a> FnMut(&'a mut Local,\n-                                                      PlaceContext,\n-                                                      Location) {\n+    fn mutate_defs_and_uses(&self, local: Local, body: &mut Body<'_>, new_local: Local) {\n         for place_use in &self.info[local].defs_and_uses {\n             MutateUseVisitor::new(local,\n-                                  &mut callback,\n+                                  new_local,\n                                   body).visit_location(body, place_use.location)\n         }\n     }\n@@ -63,7 +60,7 @@ impl DefUseAnalysis {\n                                           local: Local,\n                                           body: &mut Body<'_>,\n                                           new_local: Local) {\n-        self.mutate_defs_and_uses(local, body, |local, _, _| *local = new_local)\n+        self.mutate_defs_and_uses(local, body, new_local)\n     }\n }\n \n@@ -117,30 +114,39 @@ impl Info {\n     }\n }\n \n-struct MutateUseVisitor<F> {\n+struct MutateUseVisitor {\n     query: Local,\n-    callback: F,\n+    new_local: Local,\n }\n \n-impl<F> MutateUseVisitor<F> {\n-    fn new(query: Local, callback: F, _: &Body<'_>)\n-           -> MutateUseVisitor<F>\n-           where F: for<'a> FnMut(&'a mut Local, PlaceContext, Location) {\n+impl MutateUseVisitor {\n+    fn new(query: Local, new_local: Local, _: &Body<'_>) -> MutateUseVisitor {\n         MutateUseVisitor {\n             query,\n-            callback,\n+            new_local,\n         }\n     }\n }\n \n-impl<F> MutVisitor<'_> for MutateUseVisitor<F>\n-              where F: for<'a> FnMut(&'a mut Local, PlaceContext, Location) {\n+impl MutVisitor<'_> for MutateUseVisitor {\n     fn visit_local(&mut self,\n                     local: &mut Local,\n-                    context: PlaceContext,\n-                    location: Location) {\n+                    _context: PlaceContext,\n+                    _location: Location) {\n         if *local == self.query {\n-            (self.callback)(local, context, location)\n+            *local = self.new_local;\n+        }\n+    }\n+\n+    fn process_projection_elem(\n+        &mut self,\n+        elem: &PlaceElem<'tcx>,\n+    ) -> Option<PlaceElem<'tcx>> {\n+        match elem {\n+            PlaceElem::Index(local) if *local == self.query => {\n+                Some(PlaceElem::Index(self.new_local))\n+            }\n+            _ => None,\n         }\n     }\n }"}]}