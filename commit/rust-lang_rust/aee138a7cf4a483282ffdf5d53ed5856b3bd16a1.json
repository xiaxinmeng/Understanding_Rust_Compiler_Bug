{"sha": "aee138a7cf4a483282ffdf5d53ed5856b3bd16a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlZTEzOGE3Y2Y0YTQ4MzI4MmZmZGY1ZDUzZWQ1ODU2YjNiZDE2YTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-30T10:40:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-30T10:40:36Z"}, "message": "Auto merge of #3597 - xfix:match-ergonomics, r=phansch\n\nMatch ergonomics (lints from A to B)", "tree": {"sha": "343d0971d2d640a49d155da88879660ad96c4c24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/343d0971d2d640a49d155da88879660ad96c4c24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aee138a7cf4a483282ffdf5d53ed5856b3bd16a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aee138a7cf4a483282ffdf5d53ed5856b3bd16a1", "html_url": "https://github.com/rust-lang/rust/commit/aee138a7cf4a483282ffdf5d53ed5856b3bd16a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aee138a7cf4a483282ffdf5d53ed5856b3bd16a1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad2a4ef4bb88d7e61a0f28e19ae7e00824454cff", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad2a4ef4bb88d7e61a0f28e19ae7e00824454cff", "html_url": "https://github.com/rust-lang/rust/commit/ad2a4ef4bb88d7e61a0f28e19ae7e00824454cff"}, {"sha": "aeabb890d694b2c791c17adbff691566f6ba6984", "url": "https://api.github.com/repos/rust-lang/rust/commits/aeabb890d694b2c791c17adbff691566f6ba6984", "html_url": "https://github.com/rust-lang/rust/commit/aeabb890d694b2c791c17adbff691566f6ba6984"}], "stats": {"total": 112, "additions": 56, "deletions": 56}, "files": [{"sha": "afbfdd32304c37459b99dd55f3e7a39e05d6e7e0", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aee138a7cf4a483282ffdf5d53ed5856b3bd16a1/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee138a7cf4a483282ffdf5d53ed5856b3bd16a1/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=aee138a7cf4a483282ffdf5d53ed5856b3bd16a1", "patch": "@@ -73,7 +73,7 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprKind::Lit(ref lit) = e.node {\n+        if let ExprKind::Lit(lit) = &e.node {\n             check_lit(cx, lit, e);\n         }\n     }"}, {"sha": "c466b8cd5c9dc890aae3ab81de74eb73cddc006b", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aee138a7cf4a483282ffdf5d53ed5856b3bd16a1/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee138a7cf4a483282ffdf5d53ed5856b3bd16a1/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=aee138a7cf4a483282ffdf5d53ed5856b3bd16a1", "patch": "@@ -73,8 +73,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n                 return;\n             }\n         }\n-        match expr.node {\n-            hir::ExprKind::Binary(ref op, ref l, ref r) => {\n+        match &expr.node {\n+            hir::ExprKind::Binary(op, l, r) => {\n                 match op.node {\n                     hir::BinOpKind::And\n                     | hir::BinOpKind::Or\n@@ -100,7 +100,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n                     self.expr_span = Some(expr.span);\n                 }\n             },\n-            hir::ExprKind::Unary(hir::UnOp::UnNeg, ref arg) => {\n+            hir::ExprKind::Unary(hir::UnOp::UnNeg, arg) => {\n                 let ty = cx.tables.expr_ty(arg);\n                 if ty.is_integral() {\n                     span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");"}, {"sha": "496b6d659938c214368dc3dd936a221d886f9ae4", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aee138a7cf4a483282ffdf5d53ed5856b3bd16a1/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee138a7cf4a483282ffdf5d53ed5856b3bd16a1/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=aee138a7cf4a483282ffdf5d53ed5856b3bd16a1", "patch": "@@ -70,9 +70,9 @@ impl LintPass for AssignOps {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n-        match expr.node {\n-            hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n-                if let hir::ExprKind::Binary(binop, ref l, ref r) = rhs.node {\n+        match &expr.node {\n+            hir::ExprKind::AssignOp(op, lhs, rhs) => {\n+                if let hir::ExprKind::Binary(binop, l, r) = &rhs.node {\n                     if op.node == binop.node {\n                         let lint = |assignee: &hir::Expr, rhs_other: &hir::Expr| {\n                             span_lint_and_then(\n@@ -122,8 +122,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                     }\n                 }\n             },\n-            hir::ExprKind::Assign(ref assignee, ref e) => {\n-                if let hir::ExprKind::Binary(op, ref l, ref r) = e.node {\n+            hir::ExprKind::Assign(assignee, e) => {\n+                if let hir::ExprKind::Binary(op, l, r) = &e.node {\n                     #[allow(clippy::cyclomatic_complexity)]\n                     let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n                         let ty = cx.tables.expr_ty(assignee);\n@@ -150,8 +150,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                                         if_chain! {\n                                             if parent_impl != ast::CRATE_NODE_ID;\n                                             if let hir::Node::Item(item) = cx.tcx.hir().get(parent_impl);\n-                                            if let hir::ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) =\n-                                                item.node;\n+                                            if let hir::ItemKind::Impl(_, _, _, _, Some(trait_ref), _, _) =\n+                                                &item.node;\n                                             if trait_ref.path.def.def_id() == trait_id;\n                                             then { return; }\n                                         }"}, {"sha": "41946d06293816872aca063458f3ff0e34e28bb8", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/aee138a7cf4a483282ffdf5d53ed5856b3bd16a1/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee138a7cf4a483282ffdf5d53ed5856b3bd16a1/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=aee138a7cf4a483282ffdf5d53ed5856b3bd16a1", "patch": "@@ -212,7 +212,7 @@ impl LintPass for AttrPass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n     fn check_attribute(&mut self, cx: &LateContext<'a, 'tcx>, attr: &'tcx Attribute) {\n-        if let Some(ref items) = attr.meta_item_list() {\n+        if let Some(items) = &attr.meta_item_list() {\n             match &*attr.name().as_str() {\n                 \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n                     check_clippy_lint_names(cx, items);\n@@ -224,8 +224,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n             }\n             for item in items {\n                 if_chain! {\n-                    if let NestedMetaItemKind::MetaItem(ref mi) = item.node;\n-                    if let MetaItemKind::NameValue(ref lit) = mi.node;\n+                    if let NestedMetaItemKind::MetaItem(mi) = &item.node;\n+                    if let MetaItemKind::NameValue(lit) = &mi.node;\n                     if mi.name() == \"since\";\n                     then {\n                         check_semver(cx, item.span, lit);\n@@ -244,7 +244,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n                 let skip_unused_imports = item.attrs.iter().any(|attr| attr.name() == \"macro_use\");\n \n                 for attr in &item.attrs {\n-                    if let Some(ref lint_list) = attr.meta_item_list() {\n+                    if let Some(lint_list) = &attr.meta_item_list() {\n                         match &*attr.name().as_str() {\n                             \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n                                 // whitelist `unused_imports` and `deprecated` for `use` items\n@@ -381,22 +381,22 @@ fn is_relevant_trait(tcx: TyCtxt<'_, '_, '_>, item: &TraitItem) -> bool {\n \n fn is_relevant_block(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>, block: &Block) -> bool {\n     if let Some(stmt) = block.stmts.first() {\n-        match stmt.node {\n+        match &stmt.node {\n             StmtKind::Decl(_, _) => true,\n-            StmtKind::Expr(ref expr, _) | StmtKind::Semi(ref expr, _) => is_relevant_expr(tcx, tables, expr),\n+            StmtKind::Expr(expr, _) | StmtKind::Semi(expr, _) => is_relevant_expr(tcx, tables, expr),\n         }\n     } else {\n         block.expr.as_ref().map_or(false, |e| is_relevant_expr(tcx, tables, e))\n     }\n }\n \n fn is_relevant_expr(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>, expr: &Expr) -> bool {\n-    match expr.node {\n-        ExprKind::Block(ref block, _) => is_relevant_block(tcx, tables, block),\n-        ExprKind::Ret(Some(ref e)) => is_relevant_expr(tcx, tables, e),\n+    match &expr.node {\n+        ExprKind::Block(block, _) => is_relevant_block(tcx, tables, block),\n+        ExprKind::Ret(Some(e)) => is_relevant_expr(tcx, tables, e),\n         ExprKind::Ret(None) | ExprKind::Break(_, None) => false,\n-        ExprKind::Call(ref path_expr, _) => {\n-            if let ExprKind::Path(ref qpath) = path_expr.node {\n+        ExprKind::Call(path_expr, _) => {\n+            if let ExprKind::Path(qpath) = &path_expr.node {\n                 if let Some(fun_id) = opt_def_id(tables.qpath_def(qpath, path_expr.hir_id)) {\n                     !match_def_path(tcx, fun_id, &paths::BEGIN_PANIC)\n                 } else {\n@@ -443,7 +443,7 @@ fn check_attrs(cx: &LateContext<'_, '_>, span: Span, name: Name, attrs: &[Attrib\n             }\n         }\n \n-        if let Some(ref values) = attr.meta_item_list() {\n+        if let Some(values) = attr.meta_item_list() {\n             if values.len() != 1 || attr.name() != \"inline\" {\n                 continue;\n             }\n@@ -463,7 +463,7 @@ fn check_attrs(cx: &LateContext<'_, '_>, span: Span, name: Name, attrs: &[Attrib\n }\n \n fn check_semver(cx: &LateContext<'_, '_>, span: Span, lit: &Lit) {\n-    if let LitKind::Str(ref is, _) = lit.node {\n+    if let LitKind::Str(is, _) = lit.node {\n         if Version::parse(&is.as_str()).is_ok() {\n             return;\n         }\n@@ -477,7 +477,7 @@ fn check_semver(cx: &LateContext<'_, '_>, span: Span, lit: &Lit) {\n }\n \n fn is_word(nmi: &NestedMetaItem, expected: &str) -> bool {\n-    if let NestedMetaItemKind::MetaItem(ref mi) = nmi.node {\n+    if let NestedMetaItemKind::MetaItem(mi) = &nmi.node {\n         mi.is_word() && mi.name() == expected\n     } else {\n         false\n@@ -512,7 +512,7 @@ impl EarlyLintPass for CfgAttrPass {\n         if_chain! {\n             // check cfg_attr\n             if attr.name() == \"cfg_attr\";\n-            if let Some(ref items) = attr.meta_item_list();\n+            if let Some(items) = attr.meta_item_list();\n             if items.len() == 2;\n             // check for `rustfmt`\n             if let Some(feature_item) = items[0].meta_item();"}, {"sha": "9af80493af1c366d69bb2933979f7140ee8c0d58", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aee138a7cf4a483282ffdf5d53ed5856b3bd16a1/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee138a7cf4a483282ffdf5d53ed5856b3bd16a1/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=aee138a7cf4a483282ffdf5d53ed5856b3bd16a1", "patch": "@@ -121,7 +121,7 @@ impl LintPass for BitMask {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.node {\n+        if let ExprKind::Binary(cmp, left, right) = &e.node {\n             if cmp.node.is_comparison() {\n                 if let Some(cmp_opt) = fetch_int_literal(cx, right) {\n                     check_compare(cx, left, cmp.node, cmp_opt, e.span)\n@@ -131,13 +131,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n             }\n         }\n         if_chain! {\n-            if let ExprKind::Binary(ref op, ref left, ref right) = e.node;\n+            if let ExprKind::Binary(op, left, right) = &e.node;\n             if BinOpKind::Eq == op.node;\n-            if let ExprKind::Binary(ref op1, ref left1, ref right1) = left.node;\n+            if let ExprKind::Binary(op1, left1, right1) = &left.node;\n             if BinOpKind::BitAnd == op1.node;\n-            if let ExprKind::Lit(ref lit) = right1.node;\n+            if let ExprKind::Lit(lit) = &right1.node;\n             if let LitKind::Int(n, _) = lit.node;\n-            if let ExprKind::Lit(ref lit1) = right.node;\n+            if let ExprKind::Lit(lit1) = &right.node;\n             if let LitKind::Int(0, _) = lit1.node;\n             if n.leading_zeros() == n.count_zeros();\n             if n > u128::from(self.verbose_bit_mask_threshold);\n@@ -173,7 +173,7 @@ fn invert_cmp(cmp: BinOpKind) -> BinOpKind {\n }\n \n fn check_compare(cx: &LateContext<'_, '_>, bit_op: &Expr, cmp_op: BinOpKind, cmp_value: u128, span: Span) {\n-    if let ExprKind::Binary(ref op, ref left, ref right) = bit_op.node {\n+    if let ExprKind::Binary(op, left, right) = &bit_op.node {\n         if op.node != BinOpKind::BitAnd && op.node != BinOpKind::BitOr {\n             return;\n         }"}, {"sha": "92979dc024d3d60fb8d944bef274807b10b252b6", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aee138a7cf4a483282ffdf5d53ed5856b3bd16a1/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee138a7cf4a483282ffdf5d53ed5856b3bd16a1/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=aee138a7cf4a483282ffdf5d53ed5856b3bd16a1", "patch": "@@ -88,11 +88,11 @@ const COMPLEX_BLOCK_MESSAGE: &str = \"in an 'if' condition, avoid complex blocks\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprKind::If(ref check, ref then, _) = expr.node {\n-            if let ExprKind::Block(ref block, _) = check.node {\n+        if let ExprKind::If(check, then, _) = &expr.node {\n+            if let ExprKind::Block(block, _) = &check.node {\n                 if block.rules == DefaultBlock {\n                     if block.stmts.is_empty() {\n-                        if let Some(ref ex) = block.expr {\n+                        if let Some(ex) = &block.expr {\n                             // don't dig into the expression here, just suggest that they remove\n                             // the block\n                             if in_macro(expr.span) || differing_macro_contexts(expr.span, ex.span) {"}, {"sha": "2279d24af95f77417711635635a7b193a2eb0a3b", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/aee138a7cf4a483282ffdf5d53ed5856b3bd16a1/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee138a7cf4a483282ffdf5d53ed5856b3bd16a1/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=aee138a7cf4a483282ffdf5d53ed5856b3bd16a1", "patch": "@@ -96,7 +96,7 @@ struct Hir2Qmm<'a, 'tcx: 'a, 'v> {\n impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n     fn extract(&mut self, op: BinOpKind, a: &[&'v Expr], mut v: Vec<Bool>) -> Result<Vec<Bool>, String> {\n         for a in a {\n-            if let ExprKind::Binary(binop, ref lhs, ref rhs) = a.node {\n+            if let ExprKind::Binary(binop, lhs, rhs) = &a.node {\n                 if binop.node == op {\n                     v = self.extract(op, &[lhs, rhs], v)?;\n                     continue;\n@@ -110,14 +110,14 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n     fn run(&mut self, e: &'v Expr) -> Result<Bool, String> {\n         // prevent folding of `cfg!` macros and the like\n         if !in_macro(e.span) {\n-            match e.node {\n-                ExprKind::Unary(UnNot, ref inner) => return Ok(Bool::Not(box self.run(inner)?)),\n-                ExprKind::Binary(binop, ref lhs, ref rhs) => match binop.node {\n+            match &e.node {\n+                ExprKind::Unary(UnNot, inner) => return Ok(Bool::Not(box self.run(inner)?)),\n+                ExprKind::Binary(binop, lhs, rhs) => match &binop.node {\n                     BinOpKind::Or => return Ok(Bool::Or(self.extract(BinOpKind::Or, &[lhs, rhs], Vec::new())?)),\n                     BinOpKind::And => return Ok(Bool::And(self.extract(BinOpKind::And, &[lhs, rhs], Vec::new())?)),\n                     _ => (),\n                 },\n-                ExprKind::Lit(ref lit) => match lit.node {\n+                ExprKind::Lit(lit) => match lit.node {\n                     LitKind::Bool(true) => return Ok(Bool::True),\n                     LitKind::Bool(false) => return Ok(Bool::False),\n                     _ => (),\n@@ -130,8 +130,8 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                 #[allow(clippy::cast_possible_truncation)]\n                 return Ok(Bool::Term(n as u8));\n             }\n-            let negated = match e.node {\n-                ExprKind::Binary(binop, ref lhs, ref rhs) => {\n+            let negated = match &e.node {\n+                ExprKind::Binary(binop, lhs, rhs) => {\n                     if !implements_ord(self.cx, lhs) {\n                         continue;\n                     }\n@@ -184,8 +184,8 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n     }\n \n     fn simplify_not(&self, expr: &Expr) -> Option<String> {\n-        match expr.node {\n-            ExprKind::Binary(binop, ref lhs, ref rhs) => {\n+        match &expr.node {\n+            ExprKind::Binary(binop, lhs, rhs) => {\n                 if !implements_ord(self.cx, lhs) {\n                     return None;\n                 }\n@@ -201,7 +201,7 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n                 }\n                 .and_then(|op| Some(format!(\"{}{}{}\", self.snip(lhs)?, op, self.snip(rhs)?)))\n             },\n-            ExprKind::MethodCall(ref path, _, ref args) if args.len() == 1 => {\n+            ExprKind::MethodCall(path, _, args) if args.len() == 1 => {\n                 let type_of_receiver = self.cx.tables.expr_ty(&args[0]);\n                 if !match_type(self.cx, type_of_receiver, &paths::OPTION)\n                     && !match_type(self.cx, type_of_receiver, &paths::RESULT)\n@@ -221,14 +221,14 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n \n     fn recurse(&mut self, suggestion: &Bool) -> Option<()> {\n         use quine_mc_cluskey::Bool::*;\n-        match *suggestion {\n+        match suggestion {\n             True => {\n                 self.output.push_str(\"true\");\n             },\n             False => {\n                 self.output.push_str(\"false\");\n             },\n-            Not(ref inner) => match **inner {\n+            Not(inner) => match **inner {\n                 And(_) | Or(_) => {\n                     self.output.push('!');\n                     self.output.push('(');\n@@ -251,7 +251,7 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n                     self.recurse(inner)?;\n                 },\n             },\n-            And(ref v) => {\n+            And(v) => {\n                 for (index, inner) in v.iter().enumerate() {\n                     if index > 0 {\n                         self.output.push_str(\" && \");\n@@ -265,15 +265,15 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n                     }\n                 }\n             },\n-            Or(ref v) => {\n+            Or(v) => {\n                 for (index, inner) in v.iter().enumerate() {\n                     if index > 0 {\n                         self.output.push_str(\" || \");\n                     }\n                     self.recurse(inner);\n                 }\n             },\n-            Term(n) => {\n+            &Term(n) => {\n                 let snip = self.snip(self.terminals[n as usize])?;\n                 self.output.push_str(&snip);\n             },\n@@ -325,22 +325,22 @@ struct Stats {\n \n fn terminal_stats(b: &Bool) -> Stats {\n     fn recurse(b: &Bool, stats: &mut Stats) {\n-        match *b {\n+        match b {\n             True | False => stats.ops += 1,\n-            Not(ref inner) => {\n+            Not(inner) => {\n                 match **inner {\n                     And(_) | Or(_) => stats.ops += 1, // brackets are also operations\n                     _ => stats.negations += 1,\n                 }\n                 recurse(inner, stats);\n             },\n-            And(ref v) | Or(ref v) => {\n+            And(v) | Or(v) => {\n                 stats.ops += v.len() - 1;\n                 for inner in v {\n                     recurse(inner, stats);\n                 }\n             },\n-            Term(n) => stats.terminals[n as usize] += 1,\n+            &Term(n) => stats.terminals[n as usize] += 1,\n         }\n     }\n     use quine_mc_cluskey::Bool::*;\n@@ -461,11 +461,11 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n         if in_macro(e.span) {\n             return;\n         }\n-        match e.node {\n+        match &e.node {\n             ExprKind::Binary(binop, _, _) if binop.node == BinOpKind::Or || binop.node == BinOpKind::And => {\n                 self.bool_expr(e)\n             },\n-            ExprKind::Unary(UnNot, ref inner) => {\n+            ExprKind::Unary(UnNot, inner) => {\n                 if self.cx.tables.node_types()[inner.hir_id].is_bool() {\n                     self.bool_expr(e);\n                 } else {"}]}