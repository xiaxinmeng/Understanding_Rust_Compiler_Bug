{"sha": "ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjOTIzZDk0Zjg2YTZmN2M4ODFlY2JlZGNkMGE2OGQ3OTg2YTM1YmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-12T08:38:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-12T08:38:03Z"}, "message": "Auto merge of #83610 - bjorn3:driver_cleanup, r=cjgillot\n\nrustc_driver cleanup\n\nBest reviewed one commit at a time.", "tree": {"sha": "b6e833aafaa51f98d96634dd6f5657de2a23e9ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6e833aafaa51f98d96634dd6f5657de2a23e9ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "html_url": "https://github.com/rust-lang/rust/commit/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "html_url": "https://github.com/rust-lang/rust/commit/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb"}, {"sha": "163b4801e72a11803a6dcfece2099b11e5a9be76", "url": "https://api.github.com/repos/rust-lang/rust/commits/163b4801e72a11803a6dcfece2099b11e5a9be76", "html_url": "https://github.com/rust-lang/rust/commit/163b4801e72a11803a6dcfece2099b11e5a9be76"}], "stats": {"total": 392, "additions": 168, "deletions": 224}, "files": [{"sha": "e5f06551bb643dcb0176e44cb1399978f04253b5", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "patch": "@@ -298,7 +298,7 @@ pub(crate) fn run_aot(\n             metadata_module,\n             metadata,\n             windows_subsystem,\n-            linker_info: LinkerInfo::new(tcx),\n+            linker_info: LinkerInfo::new(tcx, crate::target_triple(tcx.sess).to_string()),\n             crate_info: CrateInfo::new(tcx),\n         },\n         work_products,"}, {"sha": "4271f695f91dc10c382c88a45718d9321fd03011", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "patch": "@@ -218,13 +218,11 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     ) -> Result<(), ErrorReported> {\n         use rustc_codegen_ssa::back::link::link_binary;\n \n-        let target_cpu = crate::target_triple(sess).to_string();\n         link_binary::<crate::archive::ArArchiveBuilder<'_>>(\n             sess,\n             &codegen_results,\n             outputs,\n             &codegen_results.crate_name.as_str(),\n-            &target_cpu,\n         );\n \n         Ok(())"}, {"sha": "6a032b9be723bc379ad9515a4a17e19f55b15050", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "patch": "@@ -4,12 +4,10 @@ use std::ffi::CString;\n \n use cstr::cstr;\n use rustc_codegen_ssa::traits::*;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_hir::def_id::DefId;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::layout::HasTyCtxt;\n-use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::config::OptLevel;\n use rustc_session::Session;\n@@ -355,35 +353,6 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n     }\n }\n \n-pub fn provide_both(providers: &mut Providers) {\n-    providers.wasm_import_module_map = |tcx, cnum| {\n-        // Build up a map from DefId to a `NativeLib` structure, where\n-        // `NativeLib` internally contains information about\n-        // `#[link(wasm_import_module = \"...\")]` for example.\n-        let native_libs = tcx.native_libraries(cnum);\n-\n-        let def_id_to_native_lib = native_libs\n-            .iter()\n-            .filter_map(|lib| lib.foreign_module.map(|id| (id, lib)))\n-            .collect::<FxHashMap<_, _>>();\n-\n-        let mut ret = FxHashMap::default();\n-        for (def_id, lib) in tcx.foreign_modules(cnum).iter() {\n-            let module = def_id_to_native_lib.get(&def_id).and_then(|s| s.wasm_import_module);\n-            let module = match module {\n-                Some(s) => s,\n-                None => continue,\n-            };\n-            ret.extend(lib.foreign_items.iter().map(|id| {\n-                assert_eq!(id.krate, cnum);\n-                (*id, module.to_string())\n-            }));\n-        }\n-\n-        ret\n-    };\n-}\n-\n fn wasm_import_module(tcx: TyCtxt<'_>, id: DefId) -> Option<CString> {\n     tcx.wasm_import_module_map(id.krate).get(&id).map(|s| CString::new(&s[..]).unwrap())\n }"}, {"sha": "91062926788cafa2bb247b7c5ee5335c8b057aea", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "patch": "@@ -254,13 +254,8 @@ impl CodegenBackend for LlvmCodegenBackend {\n         Box::new(metadata::LlvmMetadataLoader)\n     }\n \n-    fn provide(&self, providers: &mut ty::query::Providers) {\n-        attributes::provide_both(providers);\n-    }\n-\n-    fn provide_extern(&self, providers: &mut ty::query::Providers) {\n-        attributes::provide_both(providers);\n-    }\n+    fn provide(&self, _providers: &mut ty::query::Providers) {}\n+    fn provide_extern(&self, _providers: &mut ty::query::Providers) {}\n \n     fn codegen_crate<'tcx>(\n         &self,\n@@ -271,6 +266,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n         Box::new(rustc_codegen_ssa::base::codegen_crate(\n             LlvmCodegenBackend(()),\n             tcx,\n+            crate::llvm_util::target_cpu(tcx.sess).to_string(),\n             metadata,\n             need_metadata_module,\n         ))\n@@ -306,13 +302,11 @@ impl CodegenBackend for LlvmCodegenBackend {\n \n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n-        let target_cpu = crate::llvm_util::target_cpu(sess);\n         link_binary::<LlvmArchiveBuilder<'_>>(\n             sess,\n             &codegen_results,\n             outputs,\n             &codegen_results.crate_name.as_str(),\n-            target_cpu,\n         );\n \n         Ok(())"}, {"sha": "e330b5e703b1f449465c45b508d33b1abbca8fa6", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "patch": "@@ -50,7 +50,6 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n     codegen_results: &CodegenResults,\n     outputs: &OutputFilenames,\n     crate_name: &str,\n-    target_cpu: &str,\n ) {\n     let _timer = sess.timer(\"link_binary\");\n     let output_metadata = sess.opts.output_types.contains_key(&OutputType::Metadata);\n@@ -100,7 +99,6 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n                         &out_filename,\n                         codegen_results,\n                         path.as_ref(),\n-                        target_cpu,\n                     );\n                 }\n             }\n@@ -532,7 +530,6 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     out_filename: &Path,\n     codegen_results: &CodegenResults,\n     tmpdir: &Path,\n-    target_cpu: &str,\n ) {\n     info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n     let (linker_path, flavor) = linker_and_flavor(sess);\n@@ -544,7 +541,6 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n         tmpdir,\n         out_filename,\n         codegen_results,\n-        target_cpu,\n     );\n \n     linker::disable_localization(&mut cmd);\n@@ -1609,14 +1605,13 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     tmpdir: &Path,\n     out_filename: &Path,\n     codegen_results: &CodegenResults,\n-    target_cpu: &str,\n ) -> Command {\n     let crt_objects_fallback = crt_objects_fallback(sess, crate_type);\n     let base_cmd = get_linker(sess, path, flavor, crt_objects_fallback);\n     // FIXME: Move `/LIBPATH` addition for uwp targets from the linker construction\n     // to the linker args construction.\n     assert!(base_cmd.get_args().is_empty() || sess.target.vendor == \"uwp\");\n-    let cmd = &mut *codegen_results.linker_info.to_linker(base_cmd, &sess, flavor, target_cpu);\n+    let cmd = &mut *codegen_results.linker_info.to_linker(base_cmd, &sess, flavor);\n     let link_output_kind = link_output_kind(sess, crate_type);\n \n     // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT"}, {"sha": "93059b2323da8af64097880eca3fab56fbb5fee8", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "patch": "@@ -37,12 +37,14 @@ pub fn disable_localization(linker: &mut Command) {\n /// need out of the shared crate context before we get rid of it.\n #[derive(Encodable, Decodable)]\n pub struct LinkerInfo {\n+    target_cpu: String,\n     exports: FxHashMap<CrateType, Vec<String>>,\n }\n \n impl LinkerInfo {\n-    pub fn new(tcx: TyCtxt<'_>) -> LinkerInfo {\n+    pub fn new(tcx: TyCtxt<'_>, target_cpu: String) -> LinkerInfo {\n         LinkerInfo {\n+            target_cpu,\n             exports: tcx\n                 .sess\n                 .crate_types()\n@@ -57,38 +59,31 @@ impl LinkerInfo {\n         cmd: Command,\n         sess: &'a Session,\n         flavor: LinkerFlavor,\n-        target_cpu: &'a str,\n     ) -> Box<dyn Linker + 'a> {\n         match flavor {\n             LinkerFlavor::Lld(LldFlavor::Link) | LinkerFlavor::Msvc => {\n                 Box::new(MsvcLinker { cmd, sess, info: self }) as Box<dyn Linker>\n             }\n             LinkerFlavor::Em => Box::new(EmLinker { cmd, sess, info: self }) as Box<dyn Linker>,\n-            LinkerFlavor::Gcc => Box::new(GccLinker {\n-                cmd,\n-                sess,\n-                info: self,\n-                hinted_static: false,\n-                is_ld: false,\n-                target_cpu,\n-            }) as Box<dyn Linker>,\n+            LinkerFlavor::Gcc => {\n+                Box::new(GccLinker { cmd, sess, info: self, hinted_static: false, is_ld: false })\n+                    as Box<dyn Linker>\n+            }\n \n             LinkerFlavor::Lld(LldFlavor::Ld)\n             | LinkerFlavor::Lld(LldFlavor::Ld64)\n-            | LinkerFlavor::Ld => Box::new(GccLinker {\n-                cmd,\n-                sess,\n-                info: self,\n-                hinted_static: false,\n-                is_ld: true,\n-                target_cpu,\n-            }) as Box<dyn Linker>,\n+            | LinkerFlavor::Ld => {\n+                Box::new(GccLinker { cmd, sess, info: self, hinted_static: false, is_ld: true })\n+                    as Box<dyn Linker>\n+            }\n \n             LinkerFlavor::Lld(LldFlavor::Wasm) => {\n                 Box::new(WasmLd::new(cmd, sess, self)) as Box<dyn Linker>\n             }\n \n-            LinkerFlavor::PtxLinker => Box::new(PtxLinker { cmd, sess }) as Box<dyn Linker>,\n+            LinkerFlavor::PtxLinker => {\n+                Box::new(PtxLinker { cmd, sess, info: self }) as Box<dyn Linker>\n+            }\n         }\n     }\n }\n@@ -157,7 +152,6 @@ pub struct GccLinker<'a> {\n     hinted_static: bool, // Keeps track of the current hinting mode.\n     // Link as ld\n     is_ld: bool,\n-    target_cpu: &'a str,\n }\n \n impl<'a> GccLinker<'a> {\n@@ -229,8 +223,7 @@ impl<'a> GccLinker<'a> {\n         };\n \n         self.linker_arg(&format!(\"-plugin-opt={}\", opt_level));\n-        let target_cpu = self.target_cpu;\n-        self.linker_arg(&format!(\"-plugin-opt=mcpu={}\", target_cpu));\n+        self.linker_arg(&format!(\"-plugin-opt=mcpu={}\", self.info.target_cpu));\n     }\n \n     fn build_dylib(&mut self, out_filename: &Path) {\n@@ -1336,6 +1329,7 @@ fn exported_symbols(tcx: TyCtxt<'_>, crate_type: CrateType) -> Vec<String> {\n pub struct PtxLinker<'a> {\n     cmd: Command,\n     sess: &'a Session,\n+    info: &'a LinkerInfo,\n }\n \n impl<'a> Linker for PtxLinker<'a> {\n@@ -1381,10 +1375,7 @@ impl<'a> Linker for PtxLinker<'a> {\n \n     fn finalize(&mut self) {\n         // Provide the linker with fallback to internal `target-cpu`.\n-        self.cmd.arg(\"--fallback-arch\").arg(match self.sess.opts.cg.target_cpu {\n-            Some(ref s) => s,\n-            None => &self.sess.target.cpu,\n-        });\n+        self.cmd.arg(\"--fallback-arch\").arg(&self.info.target_cpu);\n     }\n \n     fn link_dylib(&mut self, _lib: Symbol, _verbatim: bool, _as_needed: bool) {"}, {"sha": "2bff2fcba43836cc329dd60b7e8b5b9771fc7adc", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "patch": "@@ -370,11 +370,13 @@ pub fn provide(providers: &mut Providers) {\n     providers.upstream_monomorphizations = upstream_monomorphizations_provider;\n     providers.is_unreachable_local_definition = is_unreachable_local_definition_provider;\n     providers.upstream_drop_glue_for = upstream_drop_glue_for_provider;\n+    providers.wasm_import_module_map = wasm_import_module_map;\n }\n \n pub fn provide_extern(providers: &mut Providers) {\n     providers.is_reachable_non_generic = is_reachable_non_generic_provider_extern;\n     providers.upstream_monomorphizations_for = upstream_monomorphizations_for_provider;\n+    providers.wasm_import_module_map = wasm_import_module_map;\n }\n \n fn symbol_export_level(tcx: TyCtxt<'_>, sym_def_id: DefId) -> SymbolExportLevel {\n@@ -442,3 +444,30 @@ pub fn symbol_name_for_instance_in_crate<'tcx>(\n         ExportedSymbol::NoDefId(symbol_name) => symbol_name.to_string(),\n     }\n }\n+\n+fn wasm_import_module_map(tcx: TyCtxt<'_>, cnum: CrateNum) -> FxHashMap<DefId, String> {\n+    // Build up a map from DefId to a `NativeLib` structure, where\n+    // `NativeLib` internally contains information about\n+    // `#[link(wasm_import_module = \"...\")]` for example.\n+    let native_libs = tcx.native_libraries(cnum);\n+\n+    let def_id_to_native_lib = native_libs\n+        .iter()\n+        .filter_map(|lib| lib.foreign_module.map(|id| (id, lib)))\n+        .collect::<FxHashMap<_, _>>();\n+\n+    let mut ret = FxHashMap::default();\n+    for (def_id, lib) in tcx.foreign_modules(cnum).iter() {\n+        let module = def_id_to_native_lib.get(&def_id).and_then(|s| s.wasm_import_module);\n+        let module = match module {\n+            Some(s) => s,\n+            None => continue,\n+        };\n+        ret.extend(lib.foreign_items.iter().map(|id| {\n+            assert_eq!(id.krate, cnum);\n+            (*id, module.to_string())\n+        }));\n+    }\n+\n+    ret\n+}"}, {"sha": "fb0662a3993fe796d75db9bde2790459dbe0acfe", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "patch": "@@ -419,6 +419,7 @@ fn need_pre_lto_bitcode_for_incr_comp(sess: &Session) -> bool {\n pub fn start_async_codegen<B: ExtraBackendMethods>(\n     backend: B,\n     tcx: TyCtxt<'_>,\n+    target_cpu: String,\n     metadata: EncodedMetadata,\n     total_cgus: usize,\n ) -> OngoingCodegen<B> {\n@@ -441,7 +442,7 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n         subsystem.to_string()\n     });\n \n-    let linker_info = LinkerInfo::new(tcx);\n+    let linker_info = LinkerInfo::new(tcx, target_cpu);\n     let crate_info = CrateInfo::new(tcx);\n \n     let regular_config ="}, {"sha": "a9ab075d3db538fdbdcd6f12b19629a01820baea", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "patch": "@@ -467,12 +467,13 @@ fn get_argc_argv<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n pub fn codegen_crate<B: ExtraBackendMethods>(\n     backend: B,\n     tcx: TyCtxt<'tcx>,\n+    target_cpu: String,\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n ) -> OngoingCodegen<B> {\n     // Skip crate items and just output metadata in -Z no-codegen mode.\n     if tcx.sess.opts.debugging_opts.no_codegen || !tcx.sess.opts.output_types.should_codegen() {\n-        let ongoing_codegen = start_async_codegen(backend, tcx, metadata, 1);\n+        let ongoing_codegen = start_async_codegen(backend, tcx, target_cpu, metadata, 1);\n \n         ongoing_codegen.codegen_finished(tcx);\n \n@@ -498,7 +499,8 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         }\n     }\n \n-    let ongoing_codegen = start_async_codegen(backend.clone(), tcx, metadata, codegen_units.len());\n+    let ongoing_codegen =\n+        start_async_codegen(backend.clone(), tcx, target_cpu, metadata, codegen_units.len());\n     let ongoing_codegen = AbortCodegenOnDrop::<B>(Some(ongoing_codegen));\n \n     // Codegen an allocator shim, if necessary."}, {"sha": "181146342097555300e212e0dc9e4a8f498239f1", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 86, "deletions": 114, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "patch": "@@ -35,7 +35,7 @@ use rustc_session::config::{ErrorOutputType, Input, OutputType, PrintRequest, Tr\n use rustc_session::getopts;\n use rustc_session::lint::{Lint, LintId};\n use rustc_session::{config, DiagnosticOutput, Session};\n-use rustc_session::{early_error, early_warn};\n+use rustc_session::{early_error, early_error_no_abort, early_warn};\n use rustc_span::source_map::{FileLoader, FileName};\n use rustc_span::symbol::sym;\n \n@@ -133,6 +133,7 @@ pub fn diagnostics_registry() -> Registry {\n     Registry::new(&rustc_error_codes::DIAGNOSTICS)\n }\n \n+/// This is the primary entry point for rustc.\n pub struct RunCompiler<'a, 'b> {\n     at_args: &'a [String],\n     callbacks: &'b mut (dyn Callbacks + Send),\n@@ -146,6 +147,9 @@ impl<'a, 'b> RunCompiler<'a, 'b> {\n     pub fn new(at_args: &'a [String], callbacks: &'b mut (dyn Callbacks + Send)) -> Self {\n         Self { at_args, callbacks, file_loader: None, emitter: None, make_codegen_backend: None }\n     }\n+\n+    /// Set a custom codegen backend.\n+    ///\n     /// Used by cg_clif.\n     pub fn set_make_codegen_backend(\n         &mut self,\n@@ -156,11 +160,17 @@ impl<'a, 'b> RunCompiler<'a, 'b> {\n         self.make_codegen_backend = make_codegen_backend;\n         self\n     }\n+\n+    /// Emit diagnostics to the specified location.\n+    ///\n     /// Used by RLS.\n     pub fn set_emitter(&mut self, emitter: Option<Box<dyn Write + Send>>) -> &mut Self {\n         self.emitter = emitter;\n         self\n     }\n+\n+    /// Load files from sources other than the file system.\n+    ///\n     /// Used by RLS.\n     pub fn set_file_loader(\n         &mut self,\n@@ -169,6 +179,8 @@ impl<'a, 'b> RunCompiler<'a, 'b> {\n         self.file_loader = file_loader;\n         self\n     }\n+\n+    /// Parse args and run the compiler.\n     pub fn run(self) -> interface::Result<()> {\n         run_compiler(\n             self.at_args,\n@@ -179,8 +191,6 @@ impl<'a, 'b> RunCompiler<'a, 'b> {\n         )\n     }\n }\n-// Parse args and run the compiler. This is the primary entry point for rustc.\n-// The FileLoader provides a way to load files from sources other than the file system.\n fn run_compiler(\n     at_args: &[String],\n     callbacks: &mut (dyn Callbacks + Send),\n@@ -199,46 +209,43 @@ fn run_compiler(\n     };\n \n     let sopts = config::build_session_options(&matches);\n-    let cfg = interface::parse_cfgspecs(matches.opt_strs(\"cfg\"));\n-\n-    // We wrap `make_codegen_backend` in another `Option` such that `dummy_config` can take\n-    // ownership of it when necessary, while also allowing the non-dummy config to take ownership\n-    // when `dummy_config` is not used.\n-    let mut make_codegen_backend = Some(make_codegen_backend);\n-\n-    let mut dummy_config = |sopts, cfg, diagnostic_output| {\n-        let mut config = interface::Config {\n-            opts: sopts,\n-            crate_cfg: cfg,\n-            input: Input::File(PathBuf::new()),\n-            input_path: None,\n-            output_file: None,\n-            output_dir: None,\n-            file_loader: None,\n-            diagnostic_output,\n-            stderr: None,\n-            lint_caps: Default::default(),\n-            parse_sess_created: None,\n-            register_lints: None,\n-            override_queries: None,\n-            make_codegen_backend: make_codegen_backend.take().unwrap(),\n-            registry: diagnostics_registry(),\n-        };\n-        callbacks.config(&mut config);\n-        config\n-    };\n \n     if let Some(ref code) = matches.opt_str(\"explain\") {\n         handle_explain(diagnostics_registry(), code, sopts.error_format);\n         return Ok(());\n     }\n \n+    let cfg = interface::parse_cfgspecs(matches.opt_strs(\"cfg\"));\n     let (odir, ofile) = make_output(&matches);\n-    let (input, input_file_path, input_err) = match make_input(&matches.free) {\n-        Some(v) => v,\n-        None => match matches.free.len() {\n+    let mut config = interface::Config {\n+        opts: sopts,\n+        crate_cfg: cfg,\n+        input: Input::File(PathBuf::new()),\n+        input_path: None,\n+        output_file: ofile,\n+        output_dir: odir,\n+        file_loader,\n+        diagnostic_output,\n+        stderr: None,\n+        lint_caps: Default::default(),\n+        parse_sess_created: None,\n+        register_lints: None,\n+        override_queries: None,\n+        make_codegen_backend,\n+        registry: diagnostics_registry(),\n+    };\n+\n+    match make_input(config.opts.error_format, &matches.free) {\n+        Err(ErrorReported) => return Err(ErrorReported),\n+        Ok(Some((input, input_file_path))) => {\n+            config.input = input;\n+            config.input_path = input_file_path;\n+\n+            callbacks.config(&mut config);\n+        }\n+        Ok(None) => match matches.free.len() {\n             0 => {\n-                let config = dummy_config(sopts, cfg, diagnostic_output);\n+                callbacks.config(&mut config);\n                 interface::run_compiler(config, |compiler| {\n                     let sopts = &compiler.session().opts;\n                     if sopts.describe_lints {\n@@ -260,8 +267,8 @@ fn run_compiler(\n                         &***compiler.codegen_backend(),\n                         compiler.session(),\n                         None,\n-                        &odir,\n-                        &ofile,\n+                        &compiler.output_dir(),\n+                        &compiler.output_file(),\n                     );\n \n                     if should_stop == Compilation::Stop {\n@@ -273,7 +280,7 @@ fn run_compiler(\n             }\n             1 => panic!(\"make_input should have provided valid inputs\"),\n             _ => early_error(\n-                sopts.error_format,\n+                config.opts.error_format,\n                 &format!(\n                     \"multiple input filenames provided (first two filenames are `{}` and `{}`)\",\n                     matches.free[0], matches.free[1],\n@@ -282,35 +289,6 @@ fn run_compiler(\n         },\n     };\n \n-    if let Some(err) = input_err {\n-        // Immediately stop compilation if there was an issue reading\n-        // the input (for example if the input stream is not UTF-8).\n-        interface::run_compiler(dummy_config(sopts, cfg, diagnostic_output), |compiler| {\n-            compiler.session().err(&err.to_string());\n-        });\n-        return Err(ErrorReported);\n-    }\n-\n-    let mut config = interface::Config {\n-        opts: sopts,\n-        crate_cfg: cfg,\n-        input,\n-        input_path: input_file_path,\n-        output_file: ofile,\n-        output_dir: odir,\n-        file_loader,\n-        diagnostic_output,\n-        stderr: None,\n-        lint_caps: Default::default(),\n-        parse_sess_created: None,\n-        register_lints: None,\n-        override_queries: None,\n-        make_codegen_backend: make_codegen_backend.unwrap(),\n-        registry: diagnostics_registry(),\n-    };\n-\n-    callbacks.config(&mut config);\n-\n     interface::run_compiler(config, |compiler| {\n         let sess = compiler.session();\n         let should_stop = RustcDefaultCalls::print_crate_info(\n@@ -324,7 +302,6 @@ fn run_compiler(\n             RustcDefaultCalls::list_metadata(\n                 sess,\n                 &*compiler.codegen_backend().metadata_loader(),\n-                &matches,\n                 compiler.input(),\n             )\n         })\n@@ -411,11 +388,10 @@ fn run_compiler(\n                 return early_exit();\n             }\n \n-            if sess.opts.debugging_opts.save_analysis {\n-                let crate_name = queries.crate_name()?.peek().clone();\n-                queries.global_ctxt()?.peek_mut().enter(|tcx| {\n-                    let result = tcx.analysis(LOCAL_CRATE);\n-\n+            queries.global_ctxt()?.peek_mut().enter(|tcx| {\n+                let result = tcx.analysis(LOCAL_CRATE);\n+                if sess.opts.debugging_opts.save_analysis {\n+                    let crate_name = queries.crate_name()?.peek().clone();\n                     sess.time(\"save_analysis\", || {\n                         save::process_crate(\n                             tcx,\n@@ -428,12 +404,9 @@ fn run_compiler(\n                             ),\n                         )\n                     });\n-\n-                    result\n-                })?;\n-            }\n-\n-            queries.global_ctxt()?.peek_mut().enter(|tcx| tcx.analysis(LOCAL_CRATE))?;\n+                }\n+                result\n+            })?;\n \n             if callbacks.after_analysis(compiler, queries) == Compilation::Stop {\n                 return early_exit();\n@@ -490,19 +463,23 @@ fn make_output(matches: &getopts::Matches) -> (Option<PathBuf>, Option<PathBuf>)\n }\n \n // Extract input (string or file and optional path) from matches.\n-fn make_input(free_matches: &[String]) -> Option<(Input, Option<PathBuf>, Option<io::Error>)> {\n+fn make_input(\n+    error_format: ErrorOutputType,\n+    free_matches: &[String],\n+) -> Result<Option<(Input, Option<PathBuf>)>, ErrorReported> {\n     if free_matches.len() == 1 {\n         let ifile = &free_matches[0];\n         if ifile == \"-\" {\n             let mut src = String::new();\n-            let err = if io::stdin().read_to_string(&mut src).is_err() {\n-                Some(io::Error::new(\n-                    io::ErrorKind::InvalidData,\n+            if io::stdin().read_to_string(&mut src).is_err() {\n+                // Immediately stop compilation if there was an issue reading\n+                // the input (for example if the input stream is not UTF-8).\n+                early_error_no_abort(\n+                    error_format,\n                     \"couldn't read from stdin, as it did not contain valid UTF-8\",\n-                ))\n-            } else {\n-                None\n-            };\n+                );\n+                return Err(ErrorReported);\n+            }\n             if let Ok(path) = env::var(\"UNSTABLE_RUSTDOC_TEST_PATH\") {\n                 let line = env::var(\"UNSTABLE_RUSTDOC_TEST_LINE\").expect(\n                     \"when UNSTABLE_RUSTDOC_TEST_PATH is set \\\n@@ -511,14 +488,15 @@ fn make_input(free_matches: &[String]) -> Option<(Input, Option<PathBuf>, Option\n                 let line = isize::from_str_radix(&line, 10)\n                     .expect(\"UNSTABLE_RUSTDOC_TEST_LINE needs to be an number\");\n                 let file_name = FileName::doc_test_source_code(PathBuf::from(path), line);\n-                return Some((Input::Str { name: file_name, input: src }, None, err));\n+                Ok(Some((Input::Str { name: file_name, input: src }, None)))\n+            } else {\n+                Ok(Some((Input::Str { name: FileName::anon_source_code(&src), input: src }, None)))\n             }\n-            Some((Input::Str { name: FileName::anon_source_code(&src), input: src }, None, err))\n         } else {\n-            Some((Input::File(PathBuf::from(ifile)), Some(PathBuf::from(ifile)), None))\n+            Ok(Some((Input::File(PathBuf::from(ifile)), Some(PathBuf::from(ifile)))))\n         }\n     } else {\n-        None\n+        Ok(None)\n     }\n }\n \n@@ -619,28 +597,24 @@ fn show_content_with_pager(content: &str) {\n }\n \n impl RustcDefaultCalls {\n-    fn process_rlink(sess: &Session, compiler: &interface::Compiler) -> Result<(), ErrorReported> {\n-        if let Input::File(file) = compiler.input() {\n-            // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n-            let attrs = vec![];\n-            sess.init_crate_types(collect_crate_types(sess, &attrs));\n-            let outputs = compiler.build_output_filenames(&sess, &attrs);\n-            let rlink_data = fs::read_to_string(file).unwrap_or_else(|err| {\n-                sess.fatal(&format!(\"failed to read rlink file: {}\", err));\n-            });\n-            let codegen_results: CodegenResults = json::decode(&rlink_data).unwrap_or_else(|err| {\n-                sess.fatal(&format!(\"failed to decode rlink: {}\", err));\n-            });\n-            compiler.codegen_backend().link(&sess, codegen_results, &outputs)\n-        } else {\n-            sess.fatal(\"rlink must be a file\")\n-        }\n-    }\n-\n     pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Compilation {\n         if sess.opts.debugging_opts.link_only {\n-            let result = RustcDefaultCalls::process_rlink(sess, compiler);\n-            abort_on_err(result, sess);\n+            if let Input::File(file) = compiler.input() {\n+                // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n+                sess.init_crate_types(collect_crate_types(sess, &[]));\n+                let outputs = compiler.build_output_filenames(&sess, &[]);\n+                let rlink_data = fs::read_to_string(file).unwrap_or_else(|err| {\n+                    sess.fatal(&format!(\"failed to read rlink file: {}\", err));\n+                });\n+                let codegen_results: CodegenResults =\n+                    json::decode(&rlink_data).unwrap_or_else(|err| {\n+                        sess.fatal(&format!(\"failed to decode rlink: {}\", err));\n+                    });\n+                let result = compiler.codegen_backend().link(&sess, codegen_results, &outputs);\n+                abort_on_err(result, sess);\n+            } else {\n+                sess.fatal(\"rlink must be a file\")\n+            }\n             Compilation::Stop\n         } else {\n             Compilation::Continue\n@@ -650,11 +624,9 @@ impl RustcDefaultCalls {\n     pub fn list_metadata(\n         sess: &Session,\n         metadata_loader: &dyn MetadataLoader,\n-        matches: &getopts::Matches,\n         input: &Input,\n     ) -> Compilation {\n-        let r = matches.opt_strs(\"Z\");\n-        if r.iter().any(|s| *s == \"ls\") {\n+        if sess.opts.debugging_opts.ls {\n             match *input {\n                 Input::File(ref ifile) => {\n                     let path = &(*ifile);"}, {"sha": "bd3b5239f7bda7245735a1ccd3ea7a7539ceb169", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "patch": "@@ -1,7 +1,7 @@\n //! Code to save/load the dep-graph from files.\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::definitions::Definitions;\n+use rustc_hir::definitions::DefPathTable;\n use rustc_middle::dep_graph::{PreviousDepGraph, SerializedDepGraph, WorkProduct, WorkProductId};\n use rustc_middle::ty::query::OnDiskCache;\n use rustc_serialize::opaque::Decoder;\n@@ -198,7 +198,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n /// creating an empty cache if it could not be loaded.\n pub fn load_query_result_cache<'a>(\n     sess: &'a Session,\n-    definitions: &Definitions,\n+    def_path_table: &DefPathTable,\n ) -> Option<OnDiskCache<'a>> {\n     if sess.opts.incremental.is_none() {\n         return None;\n@@ -212,7 +212,7 @@ pub fn load_query_result_cache<'a>(\n         sess.is_nightly_build(),\n     ) {\n         LoadResult::Ok { data: (bytes, start_pos) } => {\n-            Some(OnDiskCache::new(sess, bytes, start_pos, definitions))\n+            Some(OnDiskCache::new(sess, bytes, start_pos, def_path_table))\n         }\n         _ => Some(OnDiskCache::new_empty(sess.source_map())),\n     }"}, {"sha": "96dbdce1126aebcf386b34b1485044443d89aabb", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "patch": "@@ -13,7 +13,6 @@ use rustc_data_structures::{box_region_allow_access, declare_box_region_type, pa\n use rustc_errors::{ErrorReported, PResult};\n use rustc_expand::base::ExtCtxt;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n-use rustc_hir::definitions::Definitions;\n use rustc_hir::Crate;\n use rustc_lint::LintStore;\n use rustc_metadata::creader::CStore;\n@@ -51,7 +50,7 @@ use std::io::{self, BufWriter, Write};\n use std::lazy::SyncLazy;\n use std::path::PathBuf;\n use std::rc::Rc;\n-use std::{env, fs, iter, mem};\n+use std::{env, fs, iter};\n \n pub fn parse<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n     let krate = sess.time(\"parse_crate\", || match input {\n@@ -761,20 +760,18 @@ pub fn create_global_ctxt<'tcx>(\n     lint_store: Lrc<LintStore>,\n     krate: &'tcx Crate<'tcx>,\n     dep_graph: DepGraph,\n-    mut resolver_outputs: ResolverOutputs,\n+    resolver_outputs: ResolverOutputs,\n     outputs: OutputFilenames,\n     crate_name: &str,\n     queries: &'tcx OnceCell<TcxQueries<'tcx>>,\n     global_ctxt: &'tcx OnceCell<GlobalCtxt<'tcx>>,\n     arena: &'tcx WorkerLocal<Arena<'tcx>>,\n ) -> QueryContext<'tcx> {\n     let sess = &compiler.session();\n-    let defs: &'tcx Definitions = arena.alloc(mem::replace(\n-        &mut resolver_outputs.definitions,\n-        Definitions::new(crate_name, sess.local_crate_disambiguator()),\n-    ));\n \n-    let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess, defs);\n+    let def_path_table = resolver_outputs.definitions.def_path_table();\n+    let query_result_on_disk_cache =\n+        rustc_incremental::load_query_result_cache(sess, def_path_table);\n \n     let codegen_backend = compiler.codegen_backend();\n     let mut local_providers = *DEFAULT_QUERY_PROVIDERS;\n@@ -798,7 +795,6 @@ pub fn create_global_ctxt<'tcx>(\n                 arena,\n                 resolver_outputs,\n                 krate,\n-                defs,\n                 dep_graph,\n                 query_result_on_disk_cache,\n                 queries.as_dyn(),"}, {"sha": "7c4229b6db23ed1325c53551c313c808030f301f", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "patch": "@@ -973,7 +973,7 @@ pub struct GlobalCtxt<'tcx> {\n     export_map: ExportMap<LocalDefId>,\n \n     pub(crate) untracked_crate: &'tcx hir::Crate<'tcx>,\n-    pub(crate) definitions: &'tcx Definitions,\n+    pub(crate) definitions: Definitions,\n \n     /// This provides access to the incremental compilation on-disk cache for query results.\n     /// Do not access this directly. It is only meant to be used by\n@@ -1130,7 +1130,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         arena: &'tcx WorkerLocal<Arena<'tcx>>,\n         resolutions: ty::ResolverOutputs,\n         krate: &'tcx hir::Crate<'tcx>,\n-        definitions: &'tcx Definitions,\n         dep_graph: DepGraph,\n         on_disk_cache: Option<query::OnDiskCache<'tcx>>,\n         queries: &'tcx dyn query::QueryEngine<'tcx>,\n@@ -1172,7 +1171,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             glob_map: resolutions.glob_map,\n             extern_prelude: resolutions.extern_prelude,\n             untracked_crate: krate,\n-            definitions,\n+            definitions: resolutions.definitions,\n             on_disk_cache,\n             queries,\n             query_caches: query::QueryCaches::default(),\n@@ -1329,14 +1328,14 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn create_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n         let krate = self.gcx.untracked_crate;\n \n-        StableHashingContext::new(self.sess, krate, self.definitions, &*self.cstore)\n+        StableHashingContext::new(self.sess, krate, &self.definitions, &*self.cstore)\n     }\n \n     #[inline(always)]\n     pub fn create_no_span_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n         let krate = self.gcx.untracked_crate;\n \n-        StableHashingContext::ignore_spans(self.sess, krate, self.definitions, &*self.cstore)\n+        StableHashingContext::ignore_spans(self.sess, krate, &self.definitions, &*self.cstore)\n     }\n \n     pub fn serialize_query_result_cache(self, encoder: &mut FileEncoder) -> FileEncodeResult {"}, {"sha": "f220d83b0c7b24d0a16d11f358e167a5259c1f02", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "patch": "@@ -10,8 +10,7 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::definitions::DefPathHash;\n-use rustc_hir::definitions::Definitions;\n+use rustc_hir::definitions::{DefPathHash, DefPathTable};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_query_system::dep_graph::DepContext;\n use rustc_query_system::query::QueryContext;\n@@ -167,22 +166,13 @@ crate struct RawDefId {\n     pub index: u32,\n }\n \n-fn make_local_def_path_hash_map(definitions: &Definitions) -> UnhashMap<DefPathHash, LocalDefId> {\n-    UnhashMap::from_iter(\n-        definitions\n-            .def_path_table()\n-            .all_def_path_hashes_and_def_ids(LOCAL_CRATE)\n-            .map(|(hash, def_id)| (hash, def_id.as_local().unwrap())),\n-    )\n-}\n-\n impl<'sess> OnDiskCache<'sess> {\n     /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n     pub fn new(\n         sess: &'sess Session,\n         data: Vec<u8>,\n         start_pos: usize,\n-        definitions: &Definitions,\n+        def_path_table: &DefPathTable,\n     ) -> Self {\n         debug_assert!(sess.opts.incremental.is_some());\n \n@@ -220,7 +210,11 @@ impl<'sess> OnDiskCache<'sess> {\n             hygiene_context: Default::default(),\n             foreign_def_path_hashes: footer.foreign_def_path_hashes,\n             latest_foreign_def_path_hashes: Default::default(),\n-            local_def_path_hash_to_def_id: make_local_def_path_hash_map(definitions),\n+            local_def_path_hash_to_def_id: UnhashMap::from_iter(\n+                def_path_table\n+                    .all_def_path_hashes_and_def_ids(LOCAL_CRATE)\n+                    .map(|(hash, def_id)| (hash, def_id.as_local().unwrap())),\n+            ),\n             def_path_hash_to_def_id_cache: Default::default(),\n         }\n     }"}, {"sha": "6d74723993bcdd2ec45470294abb1a978a5f359f", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "patch": "@@ -1528,7 +1528,7 @@ pub enum IncrCompSession {\n     InvalidBecauseOfErrors { session_directory: PathBuf },\n }\n \n-pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n+pub fn early_error_no_abort(output: config::ErrorOutputType, msg: &str) {\n     let emitter: Box<dyn Emitter + sync::Send> = match output {\n         config::ErrorOutputType::HumanReadable(kind) => {\n             let (short, color_config) = kind.unzip();\n@@ -1540,6 +1540,10 @@ pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n     };\n     let handler = rustc_errors::Handler::with_emitter(true, None, emitter);\n     handler.struct_fatal(msg).emit();\n+}\n+\n+pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n+    early_error_no_abort(output, msg);\n     rustc_errors::FatalError.raise();\n }\n "}, {"sha": "684e9760cc663950d2b6ebb5e037fb9ad3503787", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "patch": "@@ -65,7 +65,7 @@ impl CodegenBackend for TheBackend {\n             metadata_module: None,\n             metadata,\n             windows_subsystem: None,\n-            linker_info: LinkerInfo::new(tcx),\n+            linker_info: LinkerInfo::new(tcx, \"fake_target_cpu\".to_string()),\n             crate_info: CrateInfo::new(tcx),\n         })\n     }"}]}