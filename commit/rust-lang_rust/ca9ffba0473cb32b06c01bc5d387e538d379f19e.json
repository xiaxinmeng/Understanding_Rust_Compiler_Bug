{"sha": "ca9ffba0473cb32b06c01bc5d387e538d379f19e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhOWZmYmEwNDczY2IzMmIwNmMwMWJjNWQzODdlNTM4ZDM3OWYxOWU=", "commit": {"author": {"name": "Joshua Warner", "email": "joshuawarner32@gmail.com", "date": "2021-06-05T04:48:32Z"}, "committer": {"name": "Joshua Warner", "email": "joshuawarner32@gmail.com", "date": "2021-06-05T04:48:32Z"}, "message": "Add assist for converting a tuple enum variant to a named variant", "tree": {"sha": "fadd1b30a9f6eefddeb024ec6e3855e965dbdf92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fadd1b30a9f6eefddeb024ec6e3855e965dbdf92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca9ffba0473cb32b06c01bc5d387e538d379f19e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca9ffba0473cb32b06c01bc5d387e538d379f19e", "html_url": "https://github.com/rust-lang/rust/commit/ca9ffba0473cb32b06c01bc5d387e538d379f19e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca9ffba0473cb32b06c01bc5d387e538d379f19e/comments", "author": {"login": "joshuawarner32", "id": 182686, "node_id": "MDQ6VXNlcjE4MjY4Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/182686?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joshuawarner32", "html_url": "https://github.com/joshuawarner32", "followers_url": "https://api.github.com/users/joshuawarner32/followers", "following_url": "https://api.github.com/users/joshuawarner32/following{/other_user}", "gists_url": "https://api.github.com/users/joshuawarner32/gists{/gist_id}", "starred_url": "https://api.github.com/users/joshuawarner32/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joshuawarner32/subscriptions", "organizations_url": "https://api.github.com/users/joshuawarner32/orgs", "repos_url": "https://api.github.com/users/joshuawarner32/repos", "events_url": "https://api.github.com/users/joshuawarner32/events{/privacy}", "received_events_url": "https://api.github.com/users/joshuawarner32/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joshuawarner32", "id": 182686, "node_id": "MDQ6VXNlcjE4MjY4Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/182686?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joshuawarner32", "html_url": "https://github.com/joshuawarner32", "followers_url": "https://api.github.com/users/joshuawarner32/followers", "following_url": "https://api.github.com/users/joshuawarner32/following{/other_user}", "gists_url": "https://api.github.com/users/joshuawarner32/gists{/gist_id}", "starred_url": "https://api.github.com/users/joshuawarner32/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joshuawarner32/subscriptions", "organizations_url": "https://api.github.com/users/joshuawarner32/orgs", "repos_url": "https://api.github.com/users/joshuawarner32/repos", "events_url": "https://api.github.com/users/joshuawarner32/events{/privacy}", "received_events_url": "https://api.github.com/users/joshuawarner32/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d647568db161db585f4f2ee3af9160e445338ac1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d647568db161db585f4f2ee3af9160e445338ac1", "html_url": "https://github.com/rust-lang/rust/commit/d647568db161db585f4f2ee3af9160e445338ac1"}], "stats": {"total": 517, "additions": 517, "deletions": 0}, "files": [{"sha": "586ad9809f504f53e66ecbd39685001ff21033f9", "filename": "crates/ide_assists/src/handlers/convert_tuple_variant_to_named_variant.rs", "status": "added", "additions": 515, "deletions": 0, "changes": 515, "blob_url": "https://github.com/rust-lang/rust/blob/ca9ffba0473cb32b06c01bc5d387e538d379f19e/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_variant_to_named_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca9ffba0473cb32b06c01bc5d387e538d379f19e/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_variant_to_named_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_variant_to_named_variant.rs?ref=ca9ffba0473cb32b06c01bc5d387e538d379f19e", "patch": "@@ -0,0 +1,515 @@\n+use ide_db::defs::{Definition, NameRefClass};\n+use syntax::{\n+    ast::{self, AstNode, VisibilityOwner},\n+    match_ast, SyntaxNode,\n+};\n+\n+use crate::{assist_context::AssistBuilder, AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: convert_tuple_variant_to_named_variant\n+//\n+// Converts tuple variant to variant with named fields.\n+//\n+// ```\n+// enum A {\n+//     Variant(usize),\n+// }\n+//\n+// impl A {\n+//     fn new(value: usize) -> A {\n+//         A::Variant(value)\n+//     }\n+//\n+//     fn new_with_default() -> A {\n+//         A::new(Default::default())\n+//     }\n+//\n+//     fn value(self) -> usize {\n+//         match self {\n+//             A::Variant(value) => value,\n+//         }\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// enum A {\n+//     Variant {\n+//         field1: usize\n+//     },\n+// }\n+//\n+// impl A {\n+//     fn new(value: usize) -> A {\n+//         A::Variant {\n+//             field1: value,\n+//         }\n+//     }\n+//\n+//     fn new_with_default() -> A {\n+//         A::new(Default::default())\n+//     }\n+//\n+//     fn value(self) -> usize {\n+//         match self {\n+//             A::Variant { field1: value } => value,\n+//         }\n+//     }\n+// }\n+// ```\n+pub(crate) fn convert_tuple_variant_to_named_variant(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+) -> Option<()> {\n+    let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n+    let tuple_fields = match variant.field_list()? {\n+        ast::FieldList::TupleFieldList(it) => it,\n+        ast::FieldList::RecordFieldList(_) => return None,\n+    };\n+    let variant_def = ctx.sema.to_def(&variant)?;\n+\n+    let target = variant.syntax().text_range();\n+    acc.add(\n+        AssistId(\"convert_tuple_variant_to_named_variant\", AssistKind::RefactorRewrite),\n+        \"Convert to named struct\",\n+        target,\n+        |edit| {\n+            let names = generate_names(tuple_fields.fields());\n+            edit_field_references(ctx, edit, tuple_fields.fields(), &names); // TODO: is this needed?\n+            edit_variant_references(ctx, edit, variant_def, &names);\n+            edit_variant_def(ctx, edit, tuple_fields, names);\n+        },\n+    )\n+}\n+\n+fn edit_variant_def(\n+    ctx: &AssistContext,\n+    edit: &mut AssistBuilder,\n+    tuple_fields: ast::TupleFieldList,\n+    names: Vec<ast::Name>,\n+) {\n+    let record_fields = tuple_fields\n+        .fields()\n+        .zip(names)\n+        .filter_map(|(f, name)| Some(ast::make::record_field(f.visibility(), name, f.ty()?)));\n+    let record_fields = ast::make::record_field_list(record_fields);\n+    let tuple_fields_text_range = tuple_fields.syntax().text_range();\n+\n+    edit.edit_file(ctx.frange.file_id);\n+\n+    edit.insert(tuple_fields_text_range.start(), ast::make::tokens::single_space().text());\n+\n+    edit.replace(tuple_fields_text_range, record_fields.to_string());\n+}\n+\n+fn edit_variant_references(\n+    ctx: &AssistContext,\n+    edit: &mut AssistBuilder,\n+    variant: hir::Variant,\n+    names: &[ast::Name],\n+) {\n+    let variant_def = Definition::ModuleDef(hir::ModuleDef::Variant(variant));\n+    let usages = variant_def.usages(&ctx.sema).include_self_refs().all();\n+\n+    let edit_node = |edit: &mut AssistBuilder, node: SyntaxNode| -> Option<()> {\n+        match_ast! {\n+            match node {\n+                ast::TupleStructPat(tuple_struct_pat) => {\n+                    edit.replace(\n+                        tuple_struct_pat.syntax().text_range(),\n+                        ast::make::record_pat_with_fields(\n+                            tuple_struct_pat.path()?,\n+                            ast::make::record_pat_field_list(tuple_struct_pat.fields().zip(names).map(\n+                                |(pat, name)| {\n+                                    ast::make::record_pat_field(\n+                                        ast::make::name_ref(&name.to_string()),\n+                                        pat,\n+                                    )\n+                                },\n+                            )),\n+                        )\n+                        .to_string(),\n+                    );\n+                },\n+                // for tuple struct creations like Foo(42)\n+                ast::CallExpr(call_expr) => {\n+                    let path = call_expr.syntax().descendants().find_map(ast::PathExpr::cast).and_then(|expr| expr.path())?;\n+\n+                    // this also includes method calls like Foo::new(42), we should skip them\n+                    if let Some(name_ref) = path.segment().and_then(|s| s.name_ref()) {\n+                        match NameRefClass::classify(&ctx.sema, &name_ref) {\n+                            Some(NameRefClass::Definition(Definition::SelfType(_))) => {},\n+                            Some(NameRefClass::Definition(def)) if def == variant_def => {},\n+                            _ => return None,\n+                        };\n+                    }\n+\n+                    let arg_list = call_expr.syntax().descendants().find_map(ast::ArgList::cast)?;\n+\n+                    edit.replace(\n+                        call_expr.syntax().text_range(),\n+                        ast::make::record_expr(\n+                            path,\n+                            ast::make::record_expr_field_list(arg_list.args().zip(names).map(\n+                                |(expr, name)| {\n+                                    ast::make::record_expr_field(\n+                                        ast::make::name_ref(&name.to_string()),\n+                                        Some(expr),\n+                                    )\n+                                },\n+                            )),\n+                        )\n+                        .to_string(),\n+                    );\n+                },\n+                _ => return None,\n+            }\n+        }\n+        Some(())\n+    };\n+\n+    for (file_id, refs) in usages {\n+        edit.edit_file(file_id);\n+        for r in refs {\n+            for node in r.name.syntax().ancestors() {\n+                if edit_node(edit, node).is_some() {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn edit_field_references(\n+    ctx: &AssistContext,\n+    edit: &mut AssistBuilder,\n+    fields: impl Iterator<Item = ast::TupleField>,\n+    names: &[ast::Name],\n+) {\n+    for (field, name) in fields.zip(names) {\n+        let field = match ctx.sema.to_def(&field) {\n+            Some(it) => it,\n+            None => continue,\n+        };\n+        let def = Definition::Field(field);\n+        let usages = def.usages(&ctx.sema).all();\n+        for (file_id, refs) in usages {\n+            edit.edit_file(file_id);\n+            for r in refs {\n+                if let Some(name_ref) = r.name.as_name_ref() {\n+                    edit.replace(name_ref.syntax().text_range(), name.text());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn generate_names(fields: impl Iterator<Item = ast::TupleField>) -> Vec<ast::Name> {\n+    fields.enumerate().map(|(i, _)| ast::make::name(&format!(\"field{}\", i + 1))).collect()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn not_applicable_other_than_tuple_variant() {\n+        check_assist_not_applicable(\n+            convert_tuple_variant_to_named_variant,\n+            r#\"enum Enum { Variant$0 { value: usize } };\"#,\n+        );\n+        check_assist_not_applicable(convert_tuple_variant_to_named_variant, r#\"enum Enum { Variant$0 }\"#);\n+    }\n+\n+    #[test]\n+    fn convert_simple_variant() {\n+        check_assist(\n+            convert_tuple_variant_to_named_variant,\n+            r#\"\n+enum A {\n+    $0Variant(usize),\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        A::Variant(value)\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            A::Variant(value) => value,\n+        }\n+    }\n+}\"#,\n+            r#\"\n+enum A {\n+    Variant { field1: usize },\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        A::Variant { field1: value }\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            A::Variant { field1: value } => value,\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_variant_referenced_via_self_kw() {\n+        check_assist(\n+            convert_tuple_variant_to_named_variant,\n+            r#\"\n+enum A {\n+    $0Variant(usize),\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        Self::Variant(value)\n+    }\n+\n+    fn new_with_default() -> A {\n+        Self::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            Self::Variant(value) => value,\n+        }\n+    }\n+}\"#,\n+            r#\"\n+enum A {\n+    Variant { field1: usize },\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        Self::Variant { field1: value }\n+    }\n+\n+    fn new_with_default() -> A {\n+        Self::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            Self::Variant { field1: value } => value,\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_destructured_variant() {\n+        check_assist(\n+            convert_tuple_variant_to_named_variant,\n+            r#\"\n+enum A {\n+    $0Variant(usize),\n+}\n+\n+impl A {\n+    fn into_inner(self) -> usize {\n+        let A::Variant(first) = self;\n+        first\n+    }\n+\n+    fn into_inner_via_self(self) -> usize {\n+        let Self::Variant(first) = self;\n+        first\n+    }\n+}\"#,\n+            r#\"\n+enum A {\n+    Variant { field1: usize },\n+}\n+\n+impl A {\n+    fn into_inner(self) -> usize {\n+        let A::Variant { field1: first } = self;\n+        first\n+    }\n+\n+    fn into_inner_via_self(self) -> usize {\n+        let Self::Variant { field1: first } = self;\n+        first\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_variant_with_wrapped_references() {\n+        check_assist(\n+            convert_tuple_variant_to_named_variant,\n+            r#\"\n+enum Inner {\n+    $0Variant(usize),\n+}\n+enum Outer {\n+    Variant(Inner),\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant(Inner::Variant(42))\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant(Inner::Variant(x)) = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+enum Inner {\n+    Variant { field1: usize },\n+}\n+enum Outer {\n+    Variant(Inner),\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant(Inner::Variant { field1: 42 })\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant(Inner::Variant { field1: x }) = self;\n+        x\n+    }\n+}\"#,\n+        );\n+\n+        check_assist(\n+            convert_tuple_variant_to_named_variant,\n+            r#\"\n+enum Inner {\n+    Variant(usize),\n+}\n+enum Outer {\n+    $0Variant(Inner),\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant(Inner::Variant(42))\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant(Inner::Variant(x)) = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+enum Inner {\n+    Variant(usize),\n+}\n+enum Outer {\n+    Variant { field1: Inner },\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant { field1: Inner::Variant(42) }\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant { field1: Inner::Variant(x) } = self;\n+        x\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_variant_with_multi_file_references() {\n+        check_assist(\n+            convert_tuple_variant_to_named_variant,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    $0Variant(Inner),\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A::Variant(Inner);\n+}\n+\"#,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    Variant { field1: Inner },\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A::Variant { field1: Inner };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_directly_used_variant() {\n+        check_assist(\n+            convert_tuple_variant_to_named_variant,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    $0Variant(Inner),\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A::Variant, Inner};\n+fn f() {\n+    let a = Variant(Inner);\n+}\n+\"#,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    Variant { field1: Inner },\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A::Variant, Inner};\n+fn f() {\n+    let a = Variant { field1: Inner };\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "d642333155c390654148d23098aaca973d8434f6", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca9ffba0473cb32b06c01bc5d387e538d379f19e/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca9ffba0473cb32b06c01bc5d387e538d379f19e/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=ca9ffba0473cb32b06c01bc5d387e538d379f19e", "patch": "@@ -186,6 +186,7 @@ mod handlers {\n     mod convert_iter_for_each_to_for;\n     mod convert_into_to_from;\n     mod convert_tuple_struct_to_named_struct;\n+    mod convert_tuple_variant_to_named_variant;\n     mod early_return;\n     mod expand_glob_import;\n     mod extract_function;\n@@ -256,6 +257,7 @@ mod handlers {\n             convert_iter_for_each_to_for::convert_iter_for_each_to_for,\n             convert_into_to_from::convert_into_to_from,\n             convert_tuple_struct_to_named_struct::convert_tuple_struct_to_named_struct,\n+            convert_tuple_variant_to_named_variant::convert_tuple_variant_to_named_variant,\n             early_return::convert_to_guarded_return,\n             expand_glob_import::expand_glob_import,\n             extract_struct_from_enum_variant::extract_struct_from_enum_variant,"}]}