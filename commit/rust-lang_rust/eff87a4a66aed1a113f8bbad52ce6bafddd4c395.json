{"sha": "eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmZjg3YTRhNjZhZWQxYTExM2Y4YmJhZDUyY2U2YmFmZGRkNGMzOTU=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-08-25T19:45:25Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-08-25T19:45:25Z"}, "message": "Merge pull request #175 from marcusklaas/assignment\n\nFormat assignment", "tree": {"sha": "3b185c5edf7851f5580cba6f779e29797e745989", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b185c5edf7851f5580cba6f779e29797e745989"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "html_url": "https://github.com/rust-lang/rust/commit/eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca39467cde0d6370d65bd7d39b02dde3ff9c28b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca39467cde0d6370d65bd7d39b02dde3ff9c28b4", "html_url": "https://github.com/rust-lang/rust/commit/ca39467cde0d6370d65bd7d39b02dde3ff9c28b4"}, {"sha": "120fd2426e271afea0332bbbd5c408c5d0e88412", "url": "https://api.github.com/repos/rust-lang/rust/commits/120fd2426e271afea0332bbbd5c408c5d0e88412", "html_url": "https://github.com/rust-lang/rust/commit/120fd2426e271afea0332bbbd5c408c5d0e88412"}], "stats": {"total": 360, "additions": 284, "deletions": 76}, "files": [{"sha": "4cee78f271d7bf4af78460b240a63eb0e5a5fb17", "filename": "src/comment.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "patch": "@@ -104,14 +104,13 @@ fn format_comments() {\n \n     let input = \"// comment\";\n     let expected = \"/* com\\n                                                                      \\\n-                    * men\\n                                                                      * \\\n-                    t */\";\n+                    * men\\n                                                                      \\\n+                    * t */\";\n     assert_eq!(expected, rewrite_comment(input, true, 9, 69));\n \n     assert_eq!(\"/* trimmed */\", rewrite_comment(\"/*   trimmed    */\", true, 100, 100));\n }\n \n-\n pub trait FindUncommented {\n     fn find_uncommented(&self, pat: &str) -> Option<usize>;\n }"}, {"sha": "f1279d93a5a3009978d9f05df160623d497d1c16", "filename": "src/expr.rs", "status": "modified", "additions": 117, "deletions": 17, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "patch": "@@ -106,6 +106,12 @@ impl Rewrite for ast::Expr {\n             ast::Expr_::ExprPath(ref qself, ref path) => {\n                 rewrite_path(context, qself.as_ref(), path, width, offset)\n             }\n+            ast::Expr_::ExprAssign(ref lhs, ref rhs) => {\n+                rewrite_assignment(context, lhs, rhs, None, width, offset)\n+            }\n+            ast::Expr_::ExprAssignOp(ref op, ref lhs, ref rhs) => {\n+                rewrite_assignment(context, lhs, rhs, Some(op), width, offset)\n+            }\n             // FIXME #184 Note that this formatting is broken due to a bad span\n             // from the parser.\n             // `continue`\n@@ -116,10 +122,47 @@ impl Rewrite for ast::Expr {\n                 };\n                 Some(format!(\"continue{}\", id_str))\n             }\n+            ast::Expr_::ExprBreak(ref opt_ident) => {\n+                let id_str = match *opt_ident {\n+                    Some(ident) => format!(\" {}\", ident),\n+                    None => String::new(),\n+                };\n+                Some(format!(\"break{}\", id_str))\n+            }\n             ast::Expr_::ExprClosure(capture, ref fn_decl, ref body) => {\n                 rewrite_closure(capture, fn_decl, body, self.span, context, width, offset)\n             }\n-            _ => context.codemap.span_to_snippet(self.span).ok(),\n+            _ => {\n+                // We do not format these expressions yet, but they should still\n+                // satisfy our width restrictions.\n+                let snippet = context.codemap.span_to_snippet(self.span).unwrap();\n+\n+                {\n+                    let mut lines = snippet.lines();\n+\n+                    // The caller of this function has already placed `offset`\n+                    // characters on the first line.\n+                    let first_line_max_len = try_opt!(context.config.max_width.checked_sub(offset));\n+                    if lines.next().unwrap().len() > first_line_max_len {\n+                        return None;\n+                    }\n+\n+                    // The other lines must fit within the maximum width.\n+                    if lines.find(|line| line.len() > context.config.max_width).is_some() {\n+                        return None;\n+                    }\n+\n+                    // `width` is the maximum length of the last line, excluding\n+                    // indentation.\n+                    // A special check for the last line, since the caller may\n+                    // place trailing characters on this line.\n+                    if snippet.lines().rev().next().unwrap().len() > offset + width {\n+                        return None;\n+                    }\n+                }\n+\n+                Some(snippet)\n+            }\n         }\n     }\n }\n@@ -402,7 +445,7 @@ fn rewrite_match(context: &RewriteContext,\n                  width: usize,\n                  offset: usize)\n                  -> Option<String> {\n-    if arms.len() == 0 {\n+    if arms.is_empty() {\n         return None;\n     }\n \n@@ -440,7 +483,7 @@ fn rewrite_match(context: &RewriteContext,\n             result.push('\\n');\n         }\n         let missed_str = missed_str.trim();\n-        if missed_str.len() > 0 {\n+        if !missed_str.is_empty() {\n             result.push('\\n');\n             result.push_str(&arm_indent_str);\n             result.push_str(missed_str);\n@@ -473,7 +516,7 @@ fn rewrite_match(context: &RewriteContext,\n \n fn arm_start_pos(arm: &ast::Arm) -> BytePos {\n     let &ast::Arm { ref attrs, ref pats, .. } = arm;\n-    if attrs.len() > 0 {\n+    if !attrs.is_empty() {\n         return attrs[0].span.lo\n     }\n \n@@ -492,7 +535,7 @@ impl Rewrite for ast::Arm {\n \n         // FIXME this is all a bit grotty, would be nice to abstract out the\n         // treatment of attributes.\n-        let attr_str = if attrs.len() > 0 {\n+        let attr_str = if !attrs.is_empty() {\n             // We only use this visitor for the attributes, should we use it for\n             // more?\n             let mut attr_visitor = FmtVisitor::from_codemap(context.codemap, context.config);\n@@ -539,7 +582,7 @@ impl Rewrite for ast::Arm {\n \n         let mut pats_str = String::new();\n         for p in pat_strs {\n-            if pats_str.len() > 0 {\n+            if !pats_str.is_empty() {\n                 if vertical {\n                     pats_str.push_str(\" |\\n\");\n                     pats_str.push_str(&indent_str);\n@@ -584,7 +627,7 @@ impl Rewrite for ast::Arm {\n         }\n \n         // We have to push the body to the next line.\n-        if comma.len() == 0 {\n+        if comma.is_empty() {\n             // We're trying to fit a block in, but it still failed, give up.\n             return None;\n         }\n@@ -645,6 +688,8 @@ fn rewrite_pat_expr(context: &RewriteContext,\n                     pat: Option<&ast::Pat>,\n                     expr: &ast::Expr,\n                     matcher: &str,\n+                    // Connecting piece between pattern and expression,\n+                    // *without* trailing space.\n                     connector: &str,\n                     width: usize,\n                     offset: usize)\n@@ -665,18 +710,18 @@ fn rewrite_pat_expr(context: &RewriteContext,\n \n     // The expression may (partionally) fit on the current line.\n     if width > extra_offset + 1 {\n-        let mut corrected_offset = extra_offset;\n-\n-        if pat.is_some() {\n-            result.push(' ');\n-            corrected_offset += 1;\n-        }\n+        let spacer = if pat.is_some() {\n+            \" \"\n+        } else {\n+            \"\"\n+        };\n \n         let expr_rewrite = expr.rewrite(context,\n-                                        width - corrected_offset,\n-                                        offset + corrected_offset);\n+                                        width - extra_offset - spacer.len(),\n+                                        offset + extra_offset + spacer.len());\n \n         if let Some(expr_string) = expr_rewrite {\n+            result.push_str(spacer);\n             result.push_str(&expr_string);\n             return Some(result);\n         }\n@@ -810,7 +855,7 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n     let path_str = try_opt!(path.rewrite(context, width - 2, offset));\n \n     // Foo { a: Foo } - indent is +3, width is -5.\n-    let h_budget = width.checked_sub(path_str.len() + 5).unwrap_or(0);\n+    let h_budget = try_opt!(width.checked_sub(path_str.len() + 5));\n     let (indent, v_budget) = match context.config.struct_lit_style {\n         StructLitStyle::VisualIndent => {\n             (offset + path_str.len() + 3, h_budget)\n@@ -1008,7 +1053,62 @@ fn rewrite_unary_op(context: &RewriteContext,\n         ast::UnOp::UnNeg => \"-\",\n     };\n \n-    let subexpr = try_opt!(expr.rewrite(context, try_opt!(width.checked_sub(operator_str.len())), offset));\n+    let subexpr =\n+        try_opt!(expr.rewrite(context, try_opt!(width.checked_sub(operator_str.len())), offset));\n \n     Some(format!(\"{}{}\", operator_str, subexpr))\n }\n+\n+fn rewrite_assignment(context: &RewriteContext,\n+                      lhs: &ast::Expr,\n+                      rhs: &ast::Expr,\n+                      op: Option<&ast::BinOp>,\n+                      width: usize,\n+                      offset: usize)\n+                      -> Option<String> {\n+    let operator_str = match op {\n+        Some(op) => context.codemap.span_to_snippet(op.span).unwrap(),\n+        None => \"=\".to_owned(),\n+    };\n+\n+    // 1 = space between lhs and operator.\n+    let max_width = try_opt!(width.checked_sub(operator_str.len() + 1));\n+    let lhs_str = format!(\"{} {}\", try_opt!(lhs.rewrite(context, max_width, offset)), operator_str);\n+\n+    rewrite_assign_rhs(&context, lhs_str, rhs, width, offset)\n+}\n+\n+// The left hand side must contain everything up to, and including, the\n+// assignment operator.\n+pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n+                                           lhs: S,\n+                                           ex: &ast::Expr,\n+                                           width: usize,\n+                                           offset: usize)\n+                                           -> Option<String> {\n+    let mut result = lhs.into();\n+\n+    // 1 = space between operator and rhs.\n+    let max_width = try_opt!(width.checked_sub(result.len() + 1));\n+    let rhs = ex.rewrite(&context, max_width, offset + result.len() + 1);\n+\n+    match rhs {\n+        Some(new_str) => {\n+            result.push(' ');\n+            result.push_str(&new_str)\n+        }\n+        None => {\n+            // Expression did not fit on the same line as the identifier. Retry\n+            // on the next line.\n+            let new_offset = offset + context.config.tab_spaces;\n+            result.push_str(&format!(\"\\n{}\", make_indent(new_offset)));\n+\n+            let max_width = try_opt!(context.config.max_width.checked_sub(new_offset + 1));\n+            let rhs = try_opt!(ex.rewrite(&context, max_width, new_offset));\n+\n+            result.push_str(&rhs);\n+        }\n+    }\n+\n+    Some(result)\n+}"}, {"sha": "7d100d6db2a6d75fd4f2c43b7b27a202ec78e5d9", "filename": "src/issues.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/src%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/src%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fissues.rs?ref=eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "patch": "@@ -214,10 +214,7 @@ impl BadIssueSeeker {\n             NumberPart::CloseParen => {}\n         }\n \n-        self.state = Seeking::Number {\n-            part: part,\n-            issue: issue\n-        };\n+        self.state = Seeking::Number { part: part, issue: issue };\n \n         IssueClassification::None\n     }"}, {"sha": "1501a904fdf034e2f745d07007afe42e8ec9c8d7", "filename": "src/items.rs", "status": "modified", "additions": 70, "deletions": 4, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "patch": "@@ -14,8 +14,10 @@ use {ReturnIndent, BraceStyle};\n use utils::{format_mutability, format_visibility, make_indent, contains_skip, span_after,\n             end_typaram};\n use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic};\n+use expr::rewrite_assign_rhs;\n use comment::FindUncommented;\n use visitor::FmtVisitor;\n+\n use rewrite::Rewrite;\n use config::Config;\n \n@@ -25,6 +27,67 @@ use syntax::print::pprust;\n use syntax::parse::token;\n \n impl<'a> FmtVisitor<'a> {\n+    pub fn visit_let(&mut self, local: &ast::Local, span: Span) {\n+        self.format_missing_with_indent(span.lo);\n+\n+        // String that is placed within the assignment pattern and expression.\n+        let infix = {\n+            let mut infix = String::new();\n+\n+            if let Some(ref ty) = local.ty {\n+                infix.push_str(\": \");\n+                infix.push_str(&pprust::ty_to_string(ty));\n+            }\n+\n+            if local.init.is_some() {\n+                infix.push_str(\" =\");\n+            }\n+\n+            infix\n+        };\n+\n+        // New scope so we drop the borrow of self (context) in time to mutably\n+        // borrow self to mutate its buffer.\n+        let result = {\n+            let context = self.get_context();\n+            let mut result = \"let \".to_owned();\n+            let pattern_offset = self.block_indent + result.len() + infix.len();\n+            // 1 = ;\n+            let pattern_width = match self.config.max_width.checked_sub(pattern_offset + 1) {\n+                Some(width) => width,\n+                None => return,\n+            };\n+\n+            match local.pat.rewrite(&context, pattern_offset, pattern_width) {\n+                Some(ref pat_string) => result.push_str(pat_string),\n+                None => return,\n+            }\n+\n+            result.push_str(&infix);\n+\n+            if let Some(ref ex) = local.init {\n+                let max_width = match self.config.max_width.checked_sub(context.block_indent + 1) {\n+                    Some(width) => width,\n+                    None => return,\n+                };\n+\n+                // 1 = trailing semicolon;\n+                let rhs = rewrite_assign_rhs(&context, result, ex, max_width, context.block_indent);\n+\n+                match rhs {\n+                    Some(result) => result,\n+                    None => return,\n+                }\n+            } else {\n+                result\n+            }\n+        };\n+\n+        self.buffer.push_str(&result);\n+        self.buffer.push_str(\";\");\n+        self.last_pos = span.hi;\n+    }\n+\n     pub fn rewrite_fn(&mut self,\n                       indent: usize,\n                       ident: ast::Ident,\n@@ -51,9 +114,11 @@ impl<'a> FmtVisitor<'a> {\n                                               span,\n                                               newline_brace);\n \n-        // Prepare for the function body by possibly adding a newline and indent.\n-        // FIXME we'll miss anything between the end of the signature and the start\n-        // of the body, but we need more spans from the compiler to solve this.\n+        // Prepare for the function body by possibly adding a newline and\n+        // indent.\n+        // FIXME we'll miss anything between the end of the signature and the\n+        // start of the body, but we need more spans from the compiler to solve\n+        // this.\n         if newline_brace {\n             result.push('\\n');\n             result.push_str(&make_indent(indent));\n@@ -783,7 +848,8 @@ fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf, args: &[ast::Arg]) -\n \n             // this hacky solution caused by absence of `Mutability` in `SelfValue`.\n             let mut_str = {\n-                if let ast::Pat_::PatIdent(ast::BindingMode::BindByValue(mutability), _, _) = args[0].pat.node {\n+                if let ast::Pat_::PatIdent(ast::BindingMode::BindByValue(mutability), _, _) =\n+                       args[0].pat.node {\n                     format_mutability(mutability)\n                 } else {\n                     panic!(\"there is a bug or change in structure of AST, aborting.\");"}, {"sha": "f410f7e54680161305f39659963ef46450486450", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "patch": "@@ -325,6 +325,8 @@ impl<'a> CompilerCalls<'a> for RustFmtCalls {\n         panic!(\"No input supplied to RustFmt\");\n     }\n \n+    #[rustfmt_skip]\n+    // FIXME(#195): closure is formatted poorly.\n     fn build_controller(&mut self, _: &Session) -> driver::CompileController<'a> {\n         let write_mode = self.write_mode;\n "}, {"sha": "931baaa107354e2aac8b6228c80bceaddc0849a9", "filename": "src/lists.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "patch": "@@ -99,7 +99,7 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> St\n     let mut tactic = formatting.tactic;\n \n     // Conservatively overestimates because of the changing separator tactic.\n-    let sep_count = if formatting.trailing_separator != SeparatorTactic::Never {\n+    let sep_count = if formatting.trailing_separator == SeparatorTactic::Always {\n         items.len()\n     } else {\n         items.len() - 1\n@@ -113,8 +113,7 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> St\n     if tactic == ListTactic::HorizontalVertical {\n         debug!(\"write_list: total_width: {}, total_sep_len: {}, h_width: {}\",\n                total_width, total_sep_len, formatting.h_width);\n-        tactic = if fits_single &&\n-                    !items.iter().any(ListItem::is_multiline) {\n+        tactic = if fits_single && !items.iter().any(ListItem::is_multiline) {\n             ListTactic::Horizontal\n         } else {\n             ListTactic::Vertical\n@@ -187,13 +186,11 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> St\n \n         // Pre-comments\n         if let Some(ref comment) = item.pre_comment {\n-            result.push_str(&rewrite_comment(comment,\n-                                             // Block style in non-vertical mode\n-                                             tactic != ListTactic::Vertical,\n-                                             // Width restriction is only\n-                                             // relevant in vertical mode.\n-                                             formatting.v_width,\n-                                             formatting.indent));\n+            // Block style in non-vertical mode.\n+            let block_mode = tactic != ListTactic::Vertical;\n+            // Width restriction is only relevant in vertical mode.\n+            let max_width = formatting.v_width;\n+            result.push_str(&rewrite_comment(comment, block_mode, max_width, formatting.indent));\n \n             if tactic == ListTactic::Vertical {\n                 result.push('\\n');"}, {"sha": "e479b49f06a2b1c5ba96de91ab63ac0cabae114d", "filename": "src/visitor.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "patch": "@@ -28,6 +28,8 @@ pub struct FmtVisitor<'a> {\n }\n \n impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n+    // FIXME: We'd rather not format expressions here, as we have little\n+    // context. How are we still reaching this?\n     fn visit_expr(&mut self, ex: &'v ast::Expr) {\n         debug!(\"visit_expr: {:?} {:?}\",\n                self.codemap.lookup_char_pos(ex.span.lo),\n@@ -44,23 +46,37 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n     }\n \n     fn visit_stmt(&mut self, stmt: &'v ast::Stmt) {\n-        // If the stmt is actually an item, then we'll handle any missing spans\n-        // there. This is important because of annotations.\n-        // Although it might make more sense for the statement span to include\n-        // any annotations on the item.\n-        let skip_missing = match stmt.node {\n+        match stmt.node {\n             ast::Stmt_::StmtDecl(ref decl, _) => {\n-                match decl.node {\n-                    ast::Decl_::DeclItem(_) => true,\n-                    _ => false,\n+                return match decl.node {\n+                    ast::Decl_::DeclLocal(ref local) => self.visit_let(local, stmt.span),\n+                    ast::Decl_::DeclItem(..) => visit::walk_stmt(self, stmt),\n+                };\n+            }\n+            ast::Stmt_::StmtExpr(ref ex, _) | ast::Stmt_::StmtSemi(ref ex, _) => {\n+                self.format_missing_with_indent(stmt.span.lo);\n+                let suffix = if let ast::Stmt_::StmtExpr(..) = stmt.node {\n+                    \"\"\n+                } else {\n+                    \";\"\n+                };\n+\n+                // 1 = trailing semicolon;\n+                let rewrite = ex.rewrite(&self.get_context(),\n+                                         self.config.max_width - self.block_indent - suffix.len(),\n+                                         self.block_indent);\n+\n+                if let Some(new_str) = rewrite {\n+                    self.buffer.push_str(&new_str);\n+                    self.buffer.push_str(suffix);\n+                    self.last_pos = stmt.span.hi;\n                 }\n             }\n-            _ => false,\n-        };\n-        if !skip_missing {\n-            self.format_missing_with_indent(stmt.span.lo);\n+            ast::Stmt_::StmtMac(..) => {\n+                self.format_missing_with_indent(stmt.span.lo);\n+                visit::walk_stmt(self, stmt);\n+            }\n         }\n-        visit::walk_stmt(self, stmt);\n     }\n \n     fn visit_block(&mut self, b: &'v ast::Block) {"}, {"sha": "347966cf555798657c3c41835cb350dcd47da14e", "filename": "tests/source/assignment.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/tests%2Fsource%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/tests%2Fsource%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fassignment.rs?ref=eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "patch": "@@ -0,0 +1,16 @@\n+// Test assignment\n+\n+fn main() {\n+    let  some_var  : Type   ;\n+\n+    let  mut mutable;\n+\n+    let variable = AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA::BBBBBBBBBBBBBBBBBBBBBB::CCCCCCCCCCCCCCCCCCCCCC::EEEEEE;\n+\n+    variable =   LOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOONG;\n+\n+    let single_line_fit =\n+        DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD;\n+\n+    single_line_fit =   5;single_lit_fit    >>=  10;\n+}"}, {"sha": "d304093ebb26df15a76232e93df9f6acc669d07a", "filename": "tests/source/expr.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/tests%2Fsource%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/tests%2Fsource%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fexpr.rs?ref=eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "patch": "@@ -2,23 +2,22 @@\n \n fn foo() -> bool {\n     let boxed: Box<i32> = box   5;\n-    let referenced = &5;\n+    let referenced = &5 ;\n \n     let very_long_variable_name = ( a +  first +   simple + test   );\n     let very_long_variable_name = (a + first + simple + test + AAAAAAAAAAAAA + BBBBBBBBBBBBBBBBB + b + c);\n \n-    //FIXME this exceeds width limit. Needs assignments reformatting\n     let is_internalxxxx = self.codemap.span_to_filename(s) == self.codemap.span_to_filename(m.inner);\n \n     let some_val = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa * bbbb / (bbbbbb -\n         function_call(x, *very_long_pointer, y))\n-    + 1000;\n+    + 1000  ;\n \n some_ridiculously_loooooooooooooooooooooong_function(10000 * 30000000000 + 40000 / 1002200000000\n                                                      - 50000 * sqrt(-1),\n                                                      trivial_value);\n     (((((((((aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa + a +\n-             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa + aaaaa)))))))));\n+             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa + aaaaa)))))))))   ;\n \n     { for _ in 0..10 {} }\n \n@@ -64,9 +63,9 @@ fn bar() {\n     syntactically_correct(loop { sup( '?'); }, if cond { 0 } else { 1 });\n \n     let third = ..10;\n-    let infi_range = ..;\n+    let infi_range = ..   ;\n     let foo = 1..;\n-    let bar = 5;\n+    let bar = 5 ;\n     let nonsense = (10 .. 0)..(0..10);\n \n     let x = (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&"}, {"sha": "51edf7076456007fa2babfe72a0a7e372a5922bf", "filename": "tests/source/paths.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/tests%2Fsource%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/tests%2Fsource%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fpaths.rs?ref=eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "patch": "@@ -15,8 +15,6 @@ fn main() {\n      Quux::<ParamOne,   // Comment 1\n             ParamTwo,   // Comment 2\n                     >::some_func();\n-\n-     AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA::BBBBBBBBBBBBBBBBBBBBBBBBBBBB::CCCCCCCCCCCCCCCCCCCCCC::quux();\n }\n \n fn op(foo: Bar, key : &[u8], upd : Fn(Option<&memcache::Item> , Baz  ) -> Result) -> MapResult {}"}, {"sha": "72b85a53e55f760cb744b4681c74f90707ac25e5", "filename": "tests/target/assignment.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/tests%2Ftarget%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/tests%2Ftarget%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fassignment.rs?ref=eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "patch": "@@ -0,0 +1,18 @@\n+// Test assignment\n+\n+fn main() {\n+    let some_var: Type;\n+\n+    let mut mutable;\n+\n+    let variable =\n+        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA::BBBBBBBBBBBBBBBBBBBBBB::CCCCCCCCCCCCCCCCCCCCCC::EEEEEE;\n+\n+    variable =\n+        LOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOONG;\n+\n+    let single_line_fit = DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD;\n+\n+    single_line_fit = 5;\n+    single_lit_fit >>= 10;\n+}"}, {"sha": "df5e98e4f1b0714c0e76603c6f96b716a4f1e55f", "filename": "tests/target/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/tests%2Ftarget%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/tests%2Ftarget%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr.rs?ref=eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "patch": "@@ -8,8 +8,8 @@ fn foo() -> bool {\n     let very_long_variable_name = (a + first + simple + test + AAAAAAAAAAAAA +\n                                    BBBBBBBBBBBBBBBBB + b + c);\n \n-    //FIXME this exceeds width limit. Needs assignments reformatting\n-    let is_internalxxxx = self.codemap.span_to_filename(s) == self.codemap.span_to_filename(m.inner);\n+    let is_internalxxxx = self.codemap.span_to_filename(s) ==\n+                          self.codemap.span_to_filename(m.inner);\n \n     let some_val = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa * bbbb /\n                    (bbbbbb - function_call(x, *very_long_pointer, y)) + 1000;"}, {"sha": "b6e4750d886114b348760b06b30a57e9e2b4ebb3", "filename": "tests/target/multiple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/tests%2Ftarget%2Fmultiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/tests%2Ftarget%2Fmultiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmultiple.rs?ref=eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "patch": "@@ -134,7 +134,7 @@ fn main() {\n                        42usize);\n     let rc = RefCell::new(42usize, remaining_width, remaining_width);  // a comment\n     let x = \"Hello!!!!!!!!! abcd  abcd abcd abcd abcd abcd\\n abcd abcd abcd abcd abcd abcd abcd \\\n-             abcd abcd abcd  abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd \\\n+             abcd abcd abcd  abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd \\\n              abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd \\\n-             abcd\";\n+             abcd abcd\";\n }"}, {"sha": "c69275c7ff92ecf697e2de120b6996fa81e3efef", "filename": "tests/target/paths.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/tests%2Ftarget%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/tests%2Ftarget%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fpaths.rs?ref=eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "patch": "@@ -13,8 +13,6 @@ fn main() {\n                                                                                      supports_clipboard);\n \n     Quux::<ParamOne /* Comment 1 */, ParamTwo /* Comment 2 */>::some_func();\n-\n-    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA::BBBBBBBBBBBBBBBBBBBBBBBBBBBB::CCCCCCCCCCCCCCCCCCCCCC::quux();\n }\n \n fn op(foo: Bar, key: &[u8], upd: Fn(Option<&memcache::Item>, Baz) -> Result) -> MapResult {"}, {"sha": "f90461030ac5725d14016c758a51bbb300fda71d", "filename": "tests/target/string-lit.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/tests%2Ftarget%2Fstring-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/tests%2Ftarget%2Fstring-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstring-lit.rs?ref=eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "patch": "@@ -3,21 +3,22 @@\n fn main() -> &'static str {\n     let str = \"AAAAAAAAAAAAAAaAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAaAA \\\n                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaAa\";\n-    let str = \"AAAAAAAAAAAAAAaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaAAAAAAAAAAAAAAAAAAAAAA\\\n-               AAAAAAAAAAAaAa\";\n+    let str = \"AAAAAAAAAAAAAAaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaAAAAAAAAAAAAAAAAAAAAA\\\n+               AAAAAAAAAAAAaAa\";\n     let str = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n \n     let too_many_lines = \"Hello\";\n \n     // Make sure we don't break after an escape character.\n-    let odd_length_name = \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\n-                           \\n\\n\";\n+    let odd_length_name = \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\n+                           \\n\\n\\n\";\n     let even_length_name = \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\n                             \\n\\n\\n\";\n \n-    let really_long_variable_name = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\\n-                                     AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\\n-                                     AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n+    let really_long_variable_name = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\\n+                                     AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\\n+                                     AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\\n+                                     AA\";\n \n     let raw_string = r#\"Do\n not"}, {"sha": "77467a40ce7d1bbef37646d1f8e75aff981d8e96", "filename": "tests/target/struct_lits_visual.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/tests%2Ftarget%2Fstruct_lits_visual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff87a4a66aed1a113f8bbad52ce6bafddd4c395/tests%2Ftarget%2Fstruct_lits_visual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstruct_lits_visual.rs?ref=eff87a4a66aed1a113f8bbad52ce6bafddd4c395", "patch": "@@ -13,18 +13,19 @@ fn main() {\n           b: bar(),\n           ..something };\n \n-    Fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { a: foo(),\n-                                                                               b: bar(), };\n+    Fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { a: foo(), b: bar() };\n \n-    Foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { // Comment\n+    Foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { // Commen\n+                                                                                        // t\n                                                                                         a: foo(), /* C\n                                                                                                    * o\n                                                                                                    * m\n                                                                                                    * m\n                                                                                                    * e\n                                                                                                    * n\n                                                                                                    * t */\n-                                                                                        // Comment\n+                                                                                        // Commen\n+                                                                                        // t\n                                                                                         b: bar(), /* C\n                                                                                                    * o\n                                                                                                    * m"}]}