{"sha": "39e2e649cb0ef3da750d296af07d4cea6aadf51f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZTJlNjQ5Y2IwZWYzZGE3NTBkMjk2YWYwN2Q0Y2VhNmFhZGY1MWY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-23T23:38:53Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-29T05:23:36Z"}, "message": "Tidy up word-wrapping in debuginfo", "tree": {"sha": "a9c9bf6b15240793abc25d366bca13f5ed18da75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9c9bf6b15240793abc25d366bca13f5ed18da75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39e2e649cb0ef3da750d296af07d4cea6aadf51f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39e2e649cb0ef3da750d296af07d4cea6aadf51f", "html_url": "https://github.com/rust-lang/rust/commit/39e2e649cb0ef3da750d296af07d4cea6aadf51f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39e2e649cb0ef3da750d296af07d4cea6aadf51f/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f025fe7b2763c8715325b573b08498ec27efd1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f025fe7b2763c8715325b573b08498ec27efd1e", "html_url": "https://github.com/rust-lang/rust/commit/3f025fe7b2763c8715325b573b08498ec27efd1e"}], "stats": {"total": 273, "additions": 142, "deletions": 131}, "files": [{"sha": "e490255a2b1ba6abc83151d001ff30b1245eeb41", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 142, "deletions": 131, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/39e2e649cb0ef3da750d296af07d4cea6aadf51f/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e2e649cb0ef3da750d296af07d4cea6aadf51f/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=39e2e649cb0ef3da750d296af07d4cea6aadf51f", "patch": "@@ -1,50 +1,51 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n+//! Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+//! file at the top-level directory of this distribution and at\n+//! http://!rust-lang.org/COPYRIGHT.\n+//!\n+//! Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+//! http://!www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+//! <LICENSE-MIT or http://!opensource.org/licenses/MIT>, at your\n+//! option. This file may not be copied, modified, or distributed\n+//! except according to those terms.\n \n //! # Debug Info Module\n //!\n //! This module serves the purpose of generating debug symbols. We use LLVM's\n-//! [source level debugging](http://llvm.org/docs/SourceLevelDebugging.html)\n-//! features for generating the debug information. The general principle is this:\n+//! [source level debugging](http://!llvm.org/docs/SourceLevelDebugging.html)\n+//! features for generating the debug information. The general principle is\n+//! this:\n //!\n //! Given the right metadata in the LLVM IR, the LLVM code generator is able to\n //! create DWARF debug symbols for the given code. The\n-//! [metadata](http://llvm.org/docs/LangRef.html#metadata-type) is structured much\n-//! like DWARF *debugging information entries* (DIE), representing type information\n-//! such as datatype layout, function signatures, block layout, variable location\n-//! and scope information, etc. It is the purpose of this module to generate correct\n-//! metadata and insert it into the LLVM IR.\n+//! [metadata](http://!llvm.org/docs/LangRef.html#metadata-type) is structured\n+//! much like DWARF *debugging information entries* (DIE), representing type\n+//! information such as datatype layout, function signatures, block layout,\n+//! variable location and scope information, etc. It is the purpose of this\n+//! module to generate correct metadata and insert it into the LLVM IR.\n //!\n //! As the exact format of metadata trees may change between different LLVM\n //! versions, we now use LLVM\n-//! [DIBuilder](http://llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html) to\n-//! create metadata where possible. This will hopefully ease the adaption of this\n-//! module to future LLVM versions.\n+//! [DIBuilder](http://!llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html)\n+//! to create metadata where possible. This will hopefully ease the adaption of\n+//! this module to future LLVM versions.\n //!\n-//! The public API of the module is a set of functions that will insert the correct\n-//! metadata into the LLVM IR when called with the right parameters. The module is\n-//! thus driven from an outside client with functions like\n+//! The public API of the module is a set of functions that will insert the\n+//! correct metadata into the LLVM IR when called with the right parameters.\n+//! The module is thus driven from an outside client with functions like\n //! `debuginfo::create_local_var_metadata(bcx: block, local: &ast::local)`.\n //!\n-//! Internally the module will try to reuse already created metadata by utilizing a\n-//! cache. The way to get a shared metadata node when needed is thus to just call\n-//! the corresponding function in this module:\n+//! Internally the module will try to reuse already created metadata by\n+//! utilizing a cache. The way to get a shared metadata node when needed is\n+//! thus to just call the corresponding function in this module:\n //!\n //!     let file_metadata = file_metadata(crate_context, path);\n //!\n-//! The function will take care of probing the cache for an existing node for that\n-//! exact file path.\n+//! The function will take care of probing the cache for an existing node for\n+//! that exact file path.\n //!\n //! All private state used by the module is stored within either the\n-//! CrateDebugContext struct (owned by the CrateContext) or the FunctionDebugContext\n-//! (owned by the FunctionContext).\n+//! CrateDebugContext struct (owned by the CrateContext) or the\n+//! FunctionDebugContext (owned by the FunctionContext).\n //!\n //! This file consists of three conceptual sections:\n //! 1. The public interface of the module\n@@ -54,12 +55,12 @@\n //!\n //! ## Recursive Types\n //!\n-//! Some kinds of types, such as structs and enums can be recursive. That means that\n-//! the type definition of some type X refers to some other type which in turn\n-//! (transitively) refers to X. This introduces cycles into the type referral graph.\n-//! A naive algorithm doing an on-demand, depth-first traversal of this graph when\n-//! describing types, can get trapped in an endless loop when it reaches such a\n-//! cycle.\n+//! Some kinds of types, such as structs and enums can be recursive. That means\n+//! that the type definition of some type X refers to some other type which in\n+//! turn (transitively) refers to X. This introduces cycles into the type\n+//! referral graph. A naive algorithm doing an on-demand, depth-first traversal\n+//! of this graph when describing types, can get trapped in an endless loop\n+//! when it reaches such a cycle.\n //!\n //! For example, the following simple type for a singly-linked list...\n //!\n@@ -81,107 +82,111 @@\n //!       ...\n //! ```\n //!\n-//! To break cycles like these, we use \"forward declarations\". That is, when the\n-//! algorithm encounters a possibly recursive type (any struct or enum), it\n+//! To break cycles like these, we use \"forward declarations\". That is, when\n+//! the algorithm encounters a possibly recursive type (any struct or enum), it\n //! immediately creates a type description node and inserts it into the cache\n-//! *before* describing the members of the type. This type description is just a\n-//! stub (as type members are not described and added to it yet) but it allows the\n-//! algorithm to already refer to the type. After the stub is inserted into the\n-//! cache, the algorithm continues as before. If it now encounters a recursive\n-//! reference, it will hit the cache and does not try to describe the type anew.\n+//! *before* describing the members of the type. This type description is just\n+//! a stub (as type members are not described and added to it yet) but it\n+//! allows the algorithm to already refer to the type. After the stub is\n+//! inserted into the cache, the algorithm continues as before. If it now\n+//! encounters a recursive reference, it will hit the cache and does not try to\n+//! describe the type anew.\n //!\n-//! This behaviour is encapsulated in the 'RecursiveTypeDescription' enum, which\n-//! represents a kind of continuation, storing all state needed to continue\n-//! traversal at the type members after the type has been registered with the cache.\n-//! (This implementation approach might be a tad over-engineered and may change in\n-//! the future)\n+//! This behaviour is encapsulated in the 'RecursiveTypeDescription' enum,\n+//! which represents a kind of continuation, storing all state needed to\n+//! continue traversal at the type members after the type has been registered\n+//! with the cache. (This implementation approach might be a tad over-\n+//! engineered and may change in the future)\n //!\n //!\n //! ## Source Locations and Line Information\n //!\n-//! In addition to data type descriptions the debugging information must also allow\n-//! to map machine code locations back to source code locations in order to be useful.\n-//! This functionality is also handled in this module. The following functions allow\n-//! to control source mappings:\n+//! In addition to data type descriptions the debugging information must also\n+//! allow to map machine code locations back to source code locations in order\n+//! to be useful. This functionality is also handled in this module. The\n+//! following functions allow to control source mappings:\n //!\n //! + set_source_location()\n //! + clear_source_location()\n //! + start_emitting_source_locations()\n //!\n //! `set_source_location()` allows to set the current source location. All IR\n-//! instructions created after a call to this function will be linked to the given\n-//! source location, until another location is specified with\n+//! instructions created after a call to this function will be linked to the\n+//! given source location, until another location is specified with\n //! `set_source_location()` or the source location is cleared with\n-//! `clear_source_location()`. In the later case, subsequent IR instruction will not\n-//! be linked to any source location. As you can see, this is a stateful API\n-//! (mimicking the one in LLVM), so be careful with source locations set by previous\n-//! calls. It's probably best to not rely on any specific state being present at a\n-//! given point in code.\n+//! `clear_source_location()`. In the later case, subsequent IR instruction\n+//! will not be linked to any source location. As you can see, this is a\n+//! stateful API (mimicking the one in LLVM), so be careful with source\n+//! locations set by previous calls. It's probably best to not rely on any\n+//! specific state being present at a given point in code.\n //!\n-//! One topic that deserves some extra attention is *function prologues*. At the\n-//! beginning of a function's machine code there are typically a few instructions\n-//! for loading argument values into allocas and checking if there's enough stack\n-//! space for the function to execute. This *prologue* is not visible in the source\n-//! code and LLVM puts a special PROLOGUE END marker into the line table at the\n-//! first non-prologue instruction of the function. In order to find out where the\n-//! prologue ends, LLVM looks for the first instruction in the function body that is\n-//! linked to a source location. So, when generating prologue instructions we have\n-//! to make sure that we don't emit source location information until the 'real'\n-//! function body begins. For this reason, source location emission is disabled by\n-//! default for any new function being translated and is only activated after a call\n-//! to the third function from the list above, `start_emitting_source_locations()`.\n-//! This function should be called right before regularly starting to translate the\n+//! One topic that deserves some extra attention is *function prologues*. At\n+//! the beginning of a function's machine code there are typically a few\n+//! instructions for loading argument values into allocas and checking if\n+//! there's enough stack space for the function to execute. This *prologue* is\n+//! not visible in the source code and LLVM puts a special PROLOGUE END marker\n+//! into the line table at the first non-prologue instruction of the function.\n+//! In order to find out where the prologue ends, LLVM looks for the first\n+//! instruction in the function body that is linked to a source location. So,\n+//! when generating prologue instructions we have to make sure that we don't\n+//! emit source location information until the 'real' function body begins. For\n+//! this reason, source location emission is disabled by default for any new\n+//! function being translated and is only activated after a call to the third\n+//! function from the list above, `start_emitting_source_locations()`. This\n+//! function should be called right before regularly starting to translate the\n //! top-level block of the given function.\n //!\n-//! There is one exception to the above rule: `llvm.dbg.declare` instruction must be\n-//! linked to the source location of the variable being declared. For function\n-//! parameters these `llvm.dbg.declare` instructions typically occur in the middle\n-//! of the prologue, however, they are ignored by LLVM's prologue detection. The\n-//! `create_argument_metadata()` and related functions take care of linking the\n-//! `llvm.dbg.declare` instructions to the correct source locations even while\n-//! source location emission is still disabled, so there is no need to do anything\n-//! special with source location handling here.\n+//! There is one exception to the above rule: `llvm.dbg.declare` instruction\n+//! must be linked to the source location of the variable being declared. For\n+//! function parameters these `llvm.dbg.declare` instructions typically occur\n+//! in the middle of the prologue, however, they are ignored by LLVM's prologue\n+//! detection. The `create_argument_metadata()` and related functions take care\n+//! of linking the `llvm.dbg.declare` instructions to the correct source\n+//! locations even while source location emission is still disabled, so there\n+//! is no need to do anything special with source location handling here.\n //!\n //! ## Unique Type Identification\n //!\n-//! In order for link-time optimization to work properly, LLVM needs a unique type\n-//! identifier that tells it across compilation units which types are the same as\n-//! others. This type identifier is created by TypeMap::get_unique_type_id_of_type()\n-//! using the following algorithm:\n+//! In order for link-time optimization to work properly, LLVM needs a unique\n+//! type identifier that tells it across compilation units which types are the\n+//! same as others. This type identifier is created by\n+//! TypeMap::get_unique_type_id_of_type() using the following algorithm:\n //!\n //! (1) Primitive types have their name as ID\n //! (2) Structs, enums and traits have a multipart identifier\n //!\n-//!     (1) The first part is the SVH (strict version hash) of the crate they were\n-//!         originally defined in\n+//!     (1) The first part is the SVH (strict version hash) of the crate they\n+//!          wereoriginally defined in\n //!\n-//!     (2) The second part is the ast::NodeId of the definition in their original\n-//!         crate\n+//!     (2) The second part is the ast::NodeId of the definition in their\n+//!          originalcrate\n //!\n-//!     (3) The final part is a concatenation of the type IDs of their concrete type\n-//!         arguments if they are generic types.\n+//!     (3) The final part is a concatenation of the type IDs of their concrete\n+//!          typearguments if they are generic types.\n //!\n-//! (3) Tuple-, pointer and function types are structurally identified, which means\n-//!     that they are equivalent if their component types are equivalent (i.e. (int,\n-//!     int) is the same regardless in which crate it is used).\n+//! (3) Tuple-, pointer and function types are structurally identified, which\n+//!     means that they are equivalent if their component types are equivalent\n+//!     (i.e. (int, int) is the same regardless in which crate it is used).\n //!\n-//! This algorithm also provides a stable ID for types that are defined in one crate\n-//! but instantiated from metadata within another crate. We just have to take care\n-//! to always map crate and node IDs back to the original crate context.\n+//! This algorithm also provides a stable ID for types that are defined in one\n+//! crate but instantiated from metadata within another crate. We just have to\n+//! take care to always map crate and node IDs back to the original crate\n+//! context.\n //!\n-//! As a side-effect these unique type IDs also help to solve a problem arising from\n-//! lifetime parameters. Since lifetime parameters are completely omitted in\n-//! debuginfo, more than one `Ty` instance may map to the same debuginfo type\n-//! metadata, that is, some struct `Struct<'a>` may have N instantiations with\n-//! different concrete substitutions for `'a`, and thus there will be N `Ty`\n-//! instances for the type `Struct<'a>` even though it is not generic otherwise.\n-//! Unfortunately this means that we cannot use `ty::type_id()` as cheap identifier\n-//! for type metadata---we have done this in the past, but it led to unnecessary\n-//! metadata duplication in the best case and LLVM assertions in the worst. However,\n-//! the unique type ID as described above *can* be used as identifier. Since it is\n-//! comparatively expensive to construct, though, `ty::type_id()` is still used\n-//! additionally as an optimization for cases where the exact same type has been\n-//! seen before (which is most of the time).\n+//! As a side-effect these unique type IDs also help to solve a problem arising\n+//! from lifetime parameters. Since lifetime parameters are completely omitted\n+//! in debuginfo, more than one `Ty` instance may map to the same debuginfo\n+//! type metadata, that is, some struct `Struct<'a>` may have N instantiations\n+//! with different concrete substitutions for `'a`, and thus there will be N\n+//! `Ty` instances for the type `Struct<'a>` even though it is not generic\n+//! otherwise. Unfortunately this means that we cannot use `ty::type_id()` as\n+//! cheap identifier for type metadata---we have done this in the past, but it\n+//! led to unnecessary metadata duplication in the best case and LLVM\n+//! assertions in the worst. However, the unique type ID as described above\n+//! *can* be used as identifier. Since it is comparatively expensive to\n+//! construct, though, `ty::type_id()` is still used additionally as an\n+//! optimization for cases where the exact same type has been seen before\n+//! (which is most of the time).\n use self::VariableAccess::*;\n use self::VariableKind::*;\n use self::MemberOffset::*;\n@@ -976,10 +981,11 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let aops = unsafe {\n         [llvm::LLVMDIBuilderCreateOpDeref()]\n     };\n-    // Regardless of the actual type (`T`) we're always passed the stack slot (alloca)\n-    // for the binding. For ByRef bindings that's a `T*` but for ByMove bindings we\n-    // actually have `T**`. So to get the actual variable we need to dereference once\n-    // more. For ByCopy we just use the stack slot we created for the binding.\n+    // Regardless of the actual type (`T`) we're always passed the stack slot\n+    // (alloca) for the binding. For ByRef bindings that's a `T*` but for ByMove\n+    // bindings we actually have `T**`. So to get the actual variable we need to\n+    // dereference once more. For ByCopy we just use the stack slot we created\n+    // for the binding.\n     let var_access = match binding.trmode {\n         TrByCopy(llbinding) => DirectVariable {\n             alloca: llbinding\n@@ -1604,9 +1610,10 @@ fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n     // current compilation unit (i.e. if it is *static* in the C-sense). The\n     // *reachable* set should provide a good approximation of this, as it\n     // contains everything that might leak out of the current crate (by being\n-    // externally visible or by being inlined into something externally visible).\n-    // It might better to use the `exported_items` set from `driver::CrateAnalysis`\n-    // in the future, but (atm) this set is not available in the translation pass.\n+    // externally visible or by being inlined into something externally\n+    // visible). It might better to use the `exported_items` set from\n+    // `driver::CrateAnalysis` in the future, but (atm) this set is not\n+    // available in the translation pass.\n     !cx.reachable().contains(&node_id)\n }\n \n@@ -1869,12 +1876,12 @@ fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n enum MemberOffset {\n     FixedMemberOffset { bytes: usize },\n-    // For ComputedMemberOffset, the offset is read from the llvm type definition\n+    // For ComputedMemberOffset, the offset is read from the llvm type definition.\n     ComputedMemberOffset\n }\n \n // Description of a type member, which can either be a regular field (as in\n-// structs or tuples) or an enum variant\n+// structs or tuples) or an enum variant.\n struct MemberDescription {\n     name: String,\n     llvm_type: Type,\n@@ -1916,8 +1923,9 @@ impl<'tcx> MemberDescriptionFactory<'tcx> {\n \n // A description of some recursive type. It can either be already finished (as\n // with FinalMetadata) or it is not yet finished, but contains all information\n-// needed to generate the missing parts of the description. See the documentation\n-// section on Recursive Types at the top of this file for more information.\n+// needed to generate the missing parts of the description. See the\n+// documentation section on Recursive Types at the top of this file for more\n+// information.\n enum RecursiveTypeDescription<'tcx> {\n     UnfinishedMetadata {\n         unfinished_type: Ty<'tcx>,\n@@ -1954,7 +1962,8 @@ fn create_and_register_recursive_type_forward_declaration<'a, 'tcx>(\n \n impl<'tcx> RecursiveTypeDescription<'tcx> {\n     // Finishes up the description of the type in question (mostly by providing\n-    // descriptions of the fields of the given type) and returns the final type metadata.\n+    // descriptions of the fields of the given type) and returns the final type\n+    // metadata.\n     fn finalize<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> MetadataCreationResult {\n         match *self {\n             FinalMetadata(metadata) => MetadataCreationResult::new(metadata, false),\n@@ -1970,7 +1979,8 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                 // the TypeMap so that recursive references are possible. This\n                 // will always be the case if the RecursiveTypeDescription has\n                 // been properly created through the\n-                // create_and_register_recursive_type_forward_declaration() function.\n+                // create_and_register_recursive_type_forward_declaration()\n+                // function.\n                 {\n                     let type_map = debug_context(cx).type_map.borrow();\n                     if type_map.find_metadata_for_unique_id(unique_type_id).is_none() ||\n@@ -2150,9 +2160,9 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n // Describes the members of an enum value: An enum is described as a union of\n // structs in DWARF. This MemberDescriptionFactory provides the description for\n-// the members of this union; so for every variant of the given enum, this factory\n-// will produce one MemberDescription (all with no name and a fixed offset of\n-// zero bytes).\n+// the members of this union; so for every variant of the given enum, this\n+// factory will produce one MemberDescription (all with no name and a fixed\n+// offset of zero bytes).\n struct EnumMemberDescriptionFactory<'tcx> {\n     enum_type: Ty<'tcx>,\n     type_rep: Rc<adt::Repr<'tcx>>,\n@@ -2496,9 +2506,9 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let discriminant_type_metadata = |inttype| {\n         // We can reuse the type of the discriminant for all monomorphized\n-        // instances of an enum because it doesn't depend on any type parameters.\n-        // The def_id, uniquely identifying the enum's polytype acts as key in\n-        // this cache.\n+        // instances of an enum because it doesn't depend on any type\n+        // parameters. The def_id, uniquely identifying the enum's polytype acts\n+        // as key in this cache.\n         let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n                                                                  .borrow()\n                                                                  .get(&enum_def_id).cloned();\n@@ -2640,10 +2650,11 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                                  composite_llvm_type: Type,\n                                  member_descriptions: &[MemberDescription]) {\n     // In some rare cases LLVM metadata uniquing would lead to an existing type\n-    // description being used instead of a new one created in create_struct_stub.\n-    // This would cause a hard to trace assertion in DICompositeType::SetTypeArray().\n-    // The following check makes sure that we get a better error message if this\n-    // should happen again due to some regression.\n+    // description being used instead of a new one created in\n+    // create_struct_stub. This would cause a hard to trace assertion in\n+    // DICompositeType::SetTypeArray(). The following check makes sure that we\n+    // get a better error message if this should happen again due to some\n+    // regression.\n     {\n         let mut composite_types_completed =\n             debug_context(cx).composite_types_completed.borrow_mut();"}]}