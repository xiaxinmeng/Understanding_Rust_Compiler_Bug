{"sha": "81f5de7f05fef5ee2361db44788bad504a029d35", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZjVkZTdmMDVmZWY1ZWUyMzYxZGI0NDc4OGJhZDUwNGEwMjlkMzU=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-09T12:53:22Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-09T12:53:22Z"}, "message": "rename `memory::Kind` to `memory::MemoryKind`", "tree": {"sha": "b49d4237e863b8a92e38f18dbd3c8135cdd4ca0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b49d4237e863b8a92e38f18dbd3c8135cdd4ca0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81f5de7f05fef5ee2361db44788bad504a029d35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81f5de7f05fef5ee2361db44788bad504a029d35", "html_url": "https://github.com/rust-lang/rust/commit/81f5de7f05fef5ee2361db44788bad504a029d35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81f5de7f05fef5ee2361db44788bad504a029d35/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bba753deac0d34081c8a66d70be3e45ed563dc03", "url": "https://api.github.com/repos/rust-lang/rust/commits/bba753deac0d34081c8a66d70be3e45ed563dc03", "html_url": "https://github.com/rust-lang/rust/commit/bba753deac0d34081c8a66d70be3e45ed563dc03"}], "stats": {"total": 96, "additions": 48, "deletions": 48}, "files": [{"sha": "26263a854dd036472f41f365fe12da2ff6ce629e", "filename": "miri/fn_call.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/81f5de7f05fef5ee2361db44788bad504a029d35/miri%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f5de7f05fef5ee2361db44788bad504a029d35/miri%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ffn_call.rs?ref=81f5de7f05fef5ee2361db44788bad504a029d35", "patch": "@@ -16,7 +16,7 @@ use super::{\n \n use tls::MemoryExt;\n \n-use super::memory::Kind;\n+use super::memory::MemoryKind;\n \n pub trait EvalContextExt<'tcx> {\n     fn call_c_abi(\n@@ -113,15 +113,15 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n                     let align = self.memory.pointer_size();\n-                    let ptr = self.memory.allocate(size, align, Kind::C.into())?;\n+                    let ptr = self.memory.allocate(size, align, MemoryKind::C.into())?;\n                     self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n                 }\n             }\n \n             \"free\" => {\n                 let ptr = args[0].into_ptr(&mut self.memory)?;\n                 if !ptr.is_null()? {\n-                    self.memory.deallocate(ptr.to_ptr()?, None, Kind::C.into())?;\n+                    self.memory.deallocate(ptr.to_ptr()?, None, MemoryKind::C.into())?;\n                 }\n             }\n \n@@ -251,7 +251,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 }\n                 if let Some(old) = success {\n                     if let Some(var) = old {\n-                        self.memory.deallocate(var, None, Kind::Env.into())?;\n+                        self.memory.deallocate(var, None, MemoryKind::Env.into())?;\n                     }\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n@@ -274,12 +274,12 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 }\n                 if let Some((name, value)) = new {\n                     // +1 for the null terminator\n-                    let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, Kind::Env.into())?;\n+                    let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, MemoryKind::Env.into())?;\n                     self.memory.write_bytes(value_copy.into(), &value)?;\n                     let trailing_zero_ptr = value_copy.offset(value.len() as u64, &self)?.into();\n                     self.memory.write_bytes(trailing_zero_ptr, &[0])?;\n                     if let Some(var) = self.machine_data.env_vars.insert(name.to_owned(), value_copy) {\n-                        self.memory.deallocate(var, None, Kind::Env.into())?;\n+                        self.memory.deallocate(var, None, MemoryKind::Env.into())?;\n                     }\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n@@ -501,7 +501,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory.allocate(size, align, Kind::Rust.into())?;\n+                let ptr = self.memory.allocate(size, align, MemoryKind::Rust.into())?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::heap::::__rust_alloc_zeroed\" => {\n@@ -513,7 +513,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory.allocate(size, align, Kind::Rust.into())?;\n+                let ptr = self.memory.allocate(size, align, MemoryKind::Rust.into())?;\n                 self.memory.write_repeat(ptr.into(), 0, size)?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n@@ -527,7 +527,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                self.memory.deallocate(ptr, Some((old_size, align)), Kind::Rust.into())?;\n+                self.memory.deallocate(ptr, Some((old_size, align)), MemoryKind::Rust.into())?;\n             }\n             \"alloc::heap::::__rust_realloc\" => {\n                 let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n@@ -544,7 +544,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if !new_align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(new_align));\n                 }\n-                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align, Kind::Rust.into())?;\n+                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align, MemoryKind::Rust.into())?;\n                 self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n             }\n "}, {"sha": "c93b938e9bd5a3fecdcb6171cba2595fcb133e43", "filename": "miri/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81f5de7f05fef5ee2361db44788bad504a029d35/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f5de7f05fef5ee2361db44788bad504a029d35/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=81f5de7f05fef5ee2361db44788bad504a029d35", "patch": "@@ -71,7 +71,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             // Return value\n             let size = ecx.tcx.data_layout.pointer_size.bytes();\n             let align = ecx.tcx.data_layout.pointer_align.abi();\n-            let ret_ptr = ecx.memory_mut().allocate(size, align, Kind::Stack)?;\n+            let ret_ptr = ecx.memory_mut().allocate(size, align, MemoryKind::Stack)?;\n             cleanup_ptr = Some(ret_ptr);\n \n             // Push our stack frame\n@@ -114,7 +114,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n         while ecx.step()? {}\n         ecx.run_tls_dtors()?;\n         if let Some(cleanup_ptr) = cleanup_ptr {\n-            ecx.memory_mut().deallocate(cleanup_ptr, None, Kind::Stack)?;\n+            ecx.memory_mut().deallocate(cleanup_ptr, None, MemoryKind::Stack)?;\n         }\n         Ok(())\n     }\n@@ -161,7 +161,7 @@ struct MemoryData<'tcx> {\n impl<'tcx> Machine<'tcx> for Evaluator {\n     type Data = EvaluatorData;\n     type MemoryData = MemoryData<'tcx>;\n-    type MemoryKinds = memory::Kind;\n+    type MemoryKinds = memory::MemoryKind;\n \n     /// Returns Ok() when the function was handled, fail otherwise\n     fn eval_fn_call<'a>(\n@@ -198,8 +198,8 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n         ecx.ptr_op(bin_op, left, left_ty, right, right_ty)\n     }\n \n-    fn mark_static_initialized(m: memory::Kind) -> EvalResult<'tcx> {\n-        use memory::Kind::*;\n+    fn mark_static_initialized(m: memory::MemoryKind) -> EvalResult<'tcx> {\n+        use memory::MemoryKind::*;\n         match m {\n             // FIXME: This could be allowed, but not for env vars set during miri execution\n             Env => err!(Unimplemented(\"statics can't refer to env vars\".to_owned())),\n@@ -218,7 +218,7 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n             Ok(PrimVal::Bytes(align.into()))\n         } else {\n             ecx.memory\n-                .allocate(size, align, Kind::Machine(memory::Kind::Rust))\n+                .allocate(size, align, MemoryKind::Machine(memory::MemoryKind::Rust))\n                 .map(PrimVal::Ptr)\n         }\n     }"}, {"sha": "110540c0cf1d2555c7e9436ae3ffb7d7272d3f17", "filename": "miri/memory.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81f5de7f05fef5ee2361db44788bad504a029d35/miri%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f5de7f05fef5ee2361db44788bad504a029d35/miri%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fmemory.rs?ref=81f5de7f05fef5ee2361db44788bad504a029d35", "patch": "@@ -1,6 +1,6 @@\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n-pub enum Kind {\n+pub enum MemoryKind {\n     /// Error if deallocated any other way than `rust_deallocate`\n     Rust,\n     /// Error if deallocated any other way than `free`\n@@ -9,8 +9,8 @@ pub enum Kind {\n     Env,\n }\n \n-impl Into<::rustc_miri::interpret::Kind<Kind>> for Kind {\n-    fn into(self) -> ::rustc_miri::interpret::Kind<Kind> {\n-        ::rustc_miri::interpret::Kind::Machine(self)\n+impl Into<::rustc_miri::interpret::MemoryKind<MemoryKind>> for MemoryKind {\n+    fn into(self) -> ::rustc_miri::interpret::MemoryKind<MemoryKind> {\n+        ::rustc_miri::interpret::MemoryKind::Machine(self)\n     }\n }"}, {"sha": "f11734a588a179d13f3e1ff0a4857043149e2149", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81f5de7f05fef5ee2361db44788bad504a029d35/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f5de7f05fef5ee2361db44788bad504a029d35/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=81f5de7f05fef5ee2361db44788bad504a029d35", "patch": "@@ -10,7 +10,7 @@ use super::{\n     GlobalId, Lvalue, Value,\n     PrimVal,\n     EvalContext, StackPopCleanup, PtrAndAlign,\n-    Kind,\n+    MemoryKind,\n };\n \n use rustc_const_math::ConstInt;\n@@ -33,7 +33,7 @@ pub fn eval_body_as_primval<'a, 'tcx>(\n     if !ecx.globals.contains_key(&cid) {\n         let size = ecx.type_size_with_substs(mir.return_ty, instance.substs)?.expect(\"unsized global\");\n         let align = ecx.type_align_with_substs(mir.return_ty, instance.substs)?;\n-        let ptr = ecx.memory.allocate(size, align, Kind::UninitializedStatic)?;\n+        let ptr = ecx.memory.allocate(size, align, MemoryKind::UninitializedStatic)?;\n         let aligned = !ecx.is_packed(mir.return_ty)?;\n         ecx.globals.insert(cid, PtrAndAlign { ptr: ptr.into(), aligned });\n         let mutable = !mir.return_ty.is_freeze("}, {"sha": "fd609d5fec1c82d4f0389aa1b0430fa2bf1f8d43", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81f5de7f05fef5ee2361db44788bad504a029d35/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f5de7f05fef5ee2361db44788bad504a029d35/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=81f5de7f05fef5ee2361db44788bad504a029d35", "patch": "@@ -20,7 +20,7 @@ use super::{\n     EvalError, EvalResult, EvalErrorKind,\n     GlobalId, Lvalue, LvalueExtra,\n     Memory, MemoryPointer, HasMemory,\n-    Kind as MemoryKind,\n+    MemoryKind,\n     operator,\n     PrimVal, PrimValKind, Value, Pointer,\n     ValidationQuery,"}, {"sha": "33644d64902dd3df1972046759f35469610d77c8", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/81f5de7f05fef5ee2361db44788bad504a029d35/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f5de7f05fef5ee2361db44788bad504a029d35/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=81f5de7f05fef5ee2361db44788bad504a029d35", "patch": "@@ -151,7 +151,7 @@ pub struct Allocation<M> {\n     /// Use the `mark_static_initalized` method of `Memory` to ensure that an error occurs, if the memory of this\n     /// allocation is modified or deallocated in the future.\n     /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n-    pub kind: Kind<M>,\n+    pub kind: MemoryKind<M>,\n     /// Memory regions that are locked by some function\n     locks: RangeMap<LockInfo>,\n }\n@@ -172,7 +172,7 @@ impl<M> Allocation<M> {\n }\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n-pub enum Kind<T> {\n+pub enum MemoryKind<T> {\n     /// Error if deallocated except during a stack pop\n     Stack,\n     /// Static in the process of being initialized.\n@@ -302,7 +302,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             return Ok(MemoryPointer::new(alloc_id, 0));\n         }\n \n-        let ptr = self.allocate(bytes.len() as u64, 1, Kind::UninitializedStatic)?;\n+        let ptr = self.allocate(bytes.len() as u64, 1, MemoryKind::UninitializedStatic)?;\n         self.write_bytes(ptr.into(), bytes)?;\n         self.mark_static_initalized(ptr.alloc_id, Mutability::Immutable)?;\n         self.literal_alloc_cache.insert(bytes.to_vec(), ptr.alloc_id);\n@@ -313,7 +313,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         &mut self,\n         size: u64,\n         align: u64,\n-        kind: Kind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, MemoryPointer> {\n         assert_ne!(align, 0);\n         assert!(align.is_power_of_two());\n@@ -349,7 +349,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         old_align: u64,\n         new_size: u64,\n         new_align: u64,\n-        kind: Kind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, MemoryPointer> {\n         use std::cmp::min;\n \n@@ -374,7 +374,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         &mut self,\n         ptr: MemoryPointer,\n         size_and_align: Option<(u64, u64)>,\n-        kind: Kind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx> {\n         if ptr.offset != 0 {\n             return err!(DeallocateNonBasePtr);\n@@ -753,11 +753,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             }\n \n             let immutable = match (alloc.kind, alloc.mutable) {\n-                (Kind::UninitializedStatic, _) => \" (static in the process of initialization)\".to_owned(),\n-                (Kind::Static, Mutability::Mutable) => \" (static mut)\".to_owned(),\n-                (Kind::Static, Mutability::Immutable) => \" (immutable)\".to_owned(),\n-                (Kind::Machine(m), _) => format!(\" ({:?})\", m),\n-                (Kind::Stack, _) => \" (stack)\".to_owned(),\n+                (MemoryKind::UninitializedStatic, _) => \" (static in the process of initialization)\".to_owned(),\n+                (MemoryKind::Static, Mutability::Mutable) => \" (static mut)\".to_owned(),\n+                (MemoryKind::Static, Mutability::Immutable) => \" (immutable)\".to_owned(),\n+                (MemoryKind::Machine(m), _) => format!(\" ({:?})\", m),\n+                (MemoryKind::Stack, _) => \" (stack)\".to_owned(),\n             };\n             trace!(\"{}({} bytes, alignment {}){}\", msg, alloc.bytes.len(), alloc.align, immutable);\n \n@@ -784,7 +784,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         let leaks: Vec<_> = self.alloc_map\n             .iter()\n             .filter_map(|(&key, val)| {\n-                if val.kind != Kind::Static {\n+                if val.kind != MemoryKind::Static {\n                     Some(AllocIdKind::Runtime(key).into_alloc_id())\n                 } else {\n                     None\n@@ -856,7 +856,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     /// mark an allocation pointed to by a static as static and initialized\n     pub fn mark_inner_allocation(&mut self, alloc: AllocId, mutability: Mutability) -> EvalResult<'tcx> {\n         // relocations into other statics are not \"inner allocations\"\n-        if self.get(alloc).ok().map_or(false, |alloc| alloc.kind != Kind::UninitializedStatic) {\n+        if self.get(alloc).ok().map_or(false, |alloc| alloc.kind != MemoryKind::UninitializedStatic) {\n             self.mark_static_initalized(alloc, mutability)?;\n         }\n         Ok(())\n@@ -876,16 +876,16 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 match *kind {\n                     // const eval results can refer to \"locals\".\n                     // E.g. `const Foo: &u32 = &1;` refers to the temp local that stores the `1`\n-                    Kind::Stack |\n+                    MemoryKind::Stack |\n                     // The entire point of this function\n-                    Kind::UninitializedStatic => {},\n-                    Kind::Machine(m) => M::mark_static_initialized(m)?,\n-                    Kind::Static => {\n+                    MemoryKind::UninitializedStatic => {},\n+                    MemoryKind::Machine(m) => M::mark_static_initialized(m)?,\n+                    MemoryKind::Static => {\n                         trace!(\"mark_static_initalized: skipping already initialized static referred to by static currently being initialized\");\n                         return Ok(());\n                     },\n                 }\n-                *kind = Kind::Static;\n+                *kind = MemoryKind::Static;\n                 *mutable = mutability;\n                 // take out the relocations vector to free the borrow on self, so we can call\n                 // mark recursively"}, {"sha": "392724757ebeccee68356205a461caafbd5d9fab", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81f5de7f05fef5ee2361db44788bad504a029d35/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f5de7f05fef5ee2361db44788bad504a029d35/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=81f5de7f05fef5ee2361db44788bad504a029d35", "patch": "@@ -46,7 +46,7 @@ pub use self::memory::{\n     AllocId,\n     Memory,\n     MemoryPointer,\n-    Kind,\n+    MemoryKind,\n     HasMemory,\n };\n "}, {"sha": "a85d8d05c3269ad4e3fc32b3ec75008017b82f86", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81f5de7f05fef5ee2361db44788bad504a029d35/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f5de7f05fef5ee2361db44788bad504a029d35/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=81f5de7f05fef5ee2361db44788bad504a029d35", "patch": "@@ -15,7 +15,7 @@ use super::{\n     EvalResult,\n     EvalContext, StackPopCleanup, TyAndPacked, PtrAndAlign,\n     GlobalId, Lvalue,\n-    HasMemory, Kind,\n+    HasMemory, MemoryKind,\n     Machine,\n };\n \n@@ -179,7 +179,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // FIXME: check that it's `#[linkage = \"extern_weak\"]`\n             trace!(\"Initializing an extern global with NULL\");\n             let ptr_size = self.memory.pointer_size();\n-            let ptr = self.memory.allocate(ptr_size, ptr_size, Kind::UninitializedStatic)?;\n+            let ptr = self.memory.allocate(ptr_size, ptr_size, MemoryKind::UninitializedStatic)?;\n             self.memory.write_usize(ptr, 0)?;\n             self.memory.mark_static_initalized(ptr.alloc_id, mutability)?;\n             self.globals.insert(cid, PtrAndAlign { ptr: ptr.into(), aligned: true });\n@@ -188,7 +188,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let mir = self.load_mir(instance.def)?;\n         let size = self.type_size_with_substs(mir.return_ty, substs)?.expect(\"unsized global\");\n         let align = self.type_align_with_substs(mir.return_ty, substs)?;\n-        let ptr = self.memory.allocate(size, align, Kind::UninitializedStatic)?;\n+        let ptr = self.memory.allocate(size, align, MemoryKind::UninitializedStatic)?;\n         let aligned = !self.is_packed(mir.return_ty)?;\n         self.globals.insert(cid, PtrAndAlign { ptr: ptr.into(), aligned });\n         let internally_mutable = !mir.return_ty.is_freeze(\n@@ -265,7 +265,7 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n                 self.try(|this| {\n                     let size = this.ecx.type_size_with_substs(mir.return_ty, this.instance.substs)?.expect(\"unsized global\");\n                     let align = this.ecx.type_align_with_substs(mir.return_ty, this.instance.substs)?;\n-                    let ptr = this.ecx.memory.allocate(size, align, Kind::UninitializedStatic)?;\n+                    let ptr = this.ecx.memory.allocate(size, align, MemoryKind::UninitializedStatic)?;\n                     let aligned = !this.ecx.is_packed(mir.return_ty)?;\n                     this.ecx.globals.insert(cid, PtrAndAlign { ptr: ptr.into(), aligned });\n                     trace!(\"pushing stack frame for {:?}\", index);"}, {"sha": "3b642591917b342a5428dede84eda456d8e1b75e", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81f5de7f05fef5ee2361db44788bad504a029d35/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f5de7f05fef5ee2361db44788bad504a029d35/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=81f5de7f05fef5ee2361db44788bad504a029d35", "patch": "@@ -8,7 +8,7 @@ use syntax::ast::{self, Mutability};\n use super::{\n     EvalResult,\n     EvalContext, eval_context,\n-    MemoryPointer, Kind,\n+    MemoryPointer, MemoryKind,\n     Value, PrimVal,\n     Machine,\n };\n@@ -51,7 +51,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n         let ptr_size = self.memory.pointer_size();\n         let methods = ::rustc::traits::get_vtable_methods(self.tcx, trait_ref);\n-        let vtable = self.memory.allocate(ptr_size * (3 + methods.count() as u64), ptr_size, Kind::UninitializedStatic)?;\n+        let vtable = self.memory.allocate(ptr_size * (3 + methods.count() as u64), ptr_size, MemoryKind::UninitializedStatic)?;\n \n         let drop = eval_context::resolve_drop_in_place(self.tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop);"}]}