{"sha": "ebf9e1aaf63e741cec122f3cea1afa6d62b01350", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViZjllMWFhZjYzZTc0MWNlYzEyMmYzY2VhMWFmYTZkNjJiMDEzNTA=", "commit": {"author": {"name": "arthurprs", "email": "arthurprs@gmail.com", "date": "2015-07-18T21:58:42Z"}, "committer": {"name": "arthurprs", "email": "arthurprs@gmail.com", "date": "2015-07-18T23:06:40Z"}, "message": "optimize integer formatting", "tree": {"sha": "a39db87ca0a2f6bf1808b17dad467ab0c24ddec7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a39db87ca0a2f6bf1808b17dad467ab0c24ddec7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebf9e1aaf63e741cec122f3cea1afa6d62b01350", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebf9e1aaf63e741cec122f3cea1afa6d62b01350", "html_url": "https://github.com/rust-lang/rust/commit/ebf9e1aaf63e741cec122f3cea1afa6d62b01350", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebf9e1aaf63e741cec122f3cea1afa6d62b01350/comments", "author": {"login": "arthurprs", "id": 715958, "node_id": "MDQ6VXNlcjcxNTk1OA==", "avatar_url": "https://avatars.githubusercontent.com/u/715958?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arthurprs", "html_url": "https://github.com/arthurprs", "followers_url": "https://api.github.com/users/arthurprs/followers", "following_url": "https://api.github.com/users/arthurprs/following{/other_user}", "gists_url": "https://api.github.com/users/arthurprs/gists{/gist_id}", "starred_url": "https://api.github.com/users/arthurprs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arthurprs/subscriptions", "organizations_url": "https://api.github.com/users/arthurprs/orgs", "repos_url": "https://api.github.com/users/arthurprs/repos", "events_url": "https://api.github.com/users/arthurprs/events{/privacy}", "received_events_url": "https://api.github.com/users/arthurprs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arthurprs", "id": 715958, "node_id": "MDQ6VXNlcjcxNTk1OA==", "avatar_url": "https://avatars.githubusercontent.com/u/715958?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arthurprs", "html_url": "https://github.com/arthurprs", "followers_url": "https://api.github.com/users/arthurprs/followers", "following_url": "https://api.github.com/users/arthurprs/following{/other_user}", "gists_url": "https://api.github.com/users/arthurprs/gists{/gist_id}", "starred_url": "https://api.github.com/users/arthurprs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arthurprs/subscriptions", "organizations_url": "https://api.github.com/users/arthurprs/orgs", "repos_url": "https://api.github.com/users/arthurprs/repos", "events_url": "https://api.github.com/users/arthurprs/events{/privacy}", "received_events_url": "https://api.github.com/users/arthurprs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a27fed7cbd9d5e2a2f025c226dd48bb0c4bbbb20", "url": "https://api.github.com/repos/rust-lang/rust/commits/a27fed7cbd9d5e2a2f025c226dd48bb0c4bbbb20", "html_url": "https://github.com/rust-lang/rust/commit/a27fed7cbd9d5e2a2f025c226dd48bb0c4bbbb20"}], "stats": {"total": 88, "additions": 86, "deletions": 2}, "files": [{"sha": "a098840c77a51a55cc3a26c458d84df260b8216d", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ebf9e1aaf63e741cec122f3cea1afa6d62b01350/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebf9e1aaf63e741cec122f3cea1afa6d62b01350/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=ebf9e1aaf63e741cec122f3cea1afa6d62b01350", "patch": "@@ -20,18 +20,25 @@ use fmt;\n use num::Zero;\n use ops::{Div, Rem, Sub};\n use str;\n+use slice;\n+use ptr;\n+use mem;\n \n #[doc(hidden)]\n trait Int: Zero + PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n            Sub<Output=Self> + Copy {\n     fn from_u8(u: u8) -> Self;\n     fn to_u8(&self) -> u8;\n+    fn to_u32(&self) -> u32;\n+    fn to_u64(&self) -> u64;\n }\n \n macro_rules! doit {\n     ($($t:ident)*) => ($(impl Int for $t {\n         fn from_u8(u: u8) -> $t { u as $t }\n         fn to_u8(&self) -> u8 { *self as u8 }\n+        fn to_u32(&self) -> u32 { *self as u32 }\n+        fn to_u64(&self) -> u64 { *self as u64 }\n     })*)\n }\n doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n@@ -188,6 +195,7 @@ macro_rules! radix_fmt {\n         }\n     }\n }\n+\n macro_rules! int_base {\n     ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -209,17 +217,16 @@ macro_rules! debug {\n         }\n     }\n }\n+\n macro_rules! integer {\n     ($Int:ident, $Uint:ident) => {\n-        int_base! { Display  for $Int as $Int   -> Decimal }\n         int_base! { Binary   for $Int as $Uint  -> Binary }\n         int_base! { Octal    for $Int as $Uint  -> Octal }\n         int_base! { LowerHex for $Int as $Uint  -> LowerHex }\n         int_base! { UpperHex for $Int as $Uint  -> UpperHex }\n         radix_fmt! { $Int as $Int, fmt_int }\n         debug! { $Int }\n \n-        int_base! { Display  for $Uint as $Uint -> Decimal }\n         int_base! { Binary   for $Uint as $Uint -> Binary }\n         int_base! { Octal    for $Uint as $Uint -> Octal }\n         int_base! { LowerHex for $Uint as $Uint -> LowerHex }\n@@ -233,3 +240,80 @@ integer! { i8, u8 }\n integer! { i16, u16 }\n integer! { i32, u32 }\n integer! { i64, u64 }\n+\n+const DEC_DIGITS_LUT: &'static[u8] =\n+    b\"0001020304050607080910111213141516171819\\\n+      2021222324252627282930313233343536373839\\\n+      4041424344454647484950515253545556575859\\\n+      6061626364656667686970717273747576777879\\\n+      8081828384858687888990919293949596979899\";\n+\n+macro_rules! impl_Display {\n+    ($($t:ident),*: $conv_fn:ident) => ($(\n+    impl fmt::Display for $t {\n+        #[allow(unused_comparisons)]\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            let is_positive = *self >= 0;\n+            let mut n = if is_positive {\n+                self.$conv_fn()\n+            } else {\n+                // convert the negative num to positive by summing 1 to it's 2 complement\n+                (!self.$conv_fn()).wrapping_add(1)\n+            };\n+            let mut buf: [u8; 20] = unsafe { mem::uninitialized() };\n+            let mut curr = buf.len() as isize;\n+            let buf_ptr = buf.as_mut_ptr();\n+            let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n+\n+            unsafe {\n+                // eagerly decode 4 characters at a time\n+                if <$t>::max_value() as u64 >= 10000 {\n+                    while n >= 10000 {\n+                        let rem = (n % 10000) as isize;\n+                        n /= 10000;\n+\n+                        let d1 = (rem / 100) << 1;\n+                        let d2 = (rem % 100) << 1;\n+                        curr -= 4;\n+                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                        ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n+                    }\n+                }\n+\n+                // if we reach here numbers are <= 9999, so at most 4 chars long\n+                let mut n = n as isize; // possibly reduce 64bit math\n+\n+                // decode 2 more chars, if > 2 chars\n+                if n >= 100 {\n+                    let d1 = (n % 100) << 1;\n+                    n /= 100;\n+                    curr -= 2;\n+                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                }\n+\n+                // decode last 1 or 2 chars\n+                if n < 10 {\n+                    curr -= 1;\n+                    *buf_ptr.offset(curr) = (n as u8) + 48;\n+                } else {\n+                    let d1 = n << 1;\n+                    curr -= 2;\n+                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                }\n+            }\n+\n+            let buf_slice = unsafe {\n+                str::from_utf8_unchecked(\n+                    slice::from_raw_parts(buf_ptr.offset(curr), buf.len() - curr as usize))\n+            };\n+            f.pad_integral(is_positive, \"\", buf_slice)\n+        }\n+    })*);\n+}\n+\n+impl_Display!(i8, u8, i16, u16, i32, u32: to_u32);\n+impl_Display!(i64, u64: to_u64);\n+#[cfg(target_pointer_width = \"32\")]\n+impl_Display!(isize, usize: to_u32);\n+#[cfg(target_pointer_width = \"64\")]\n+impl_Display!(isize, usize: to_u64);"}]}