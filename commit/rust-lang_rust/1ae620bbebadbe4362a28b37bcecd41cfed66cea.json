{"sha": "1ae620bbebadbe4362a28b37bcecd41cfed66cea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhZTYyMGJiZWJhZGJlNDM2MmEyOGIzN2JjZWNkNDFjZmVkNjZjZWE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-17T15:48:18Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-30T11:55:29Z"}, "message": "do not eagerly convert `!` to a diverging variable\n\nInstead, wait until coercion time.  This has some small effects on a few\ntests (one less temporary, generally better errors when trying to call\nmethods or otherwise \"force\" the type).", "tree": {"sha": "9acf3cbd13242401e66ce902d37510540c40599d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9acf3cbd13242401e66ce902d37510540c40599d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ae620bbebadbe4362a28b37bcecd41cfed66cea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ae620bbebadbe4362a28b37bcecd41cfed66cea", "html_url": "https://github.com/rust-lang/rust/commit/1ae620bbebadbe4362a28b37bcecd41cfed66cea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ae620bbebadbe4362a28b37bcecd41cfed66cea/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4967f1ae57120b02639f3d1493e8f0c9e168b0dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/4967f1ae57120b02639f3d1493e8f0c9e168b0dc", "html_url": "https://github.com/rust-lang/rust/commit/4967f1ae57120b02639f3d1493e8f0c9e168b0dc"}], "stats": {"total": 118, "additions": 71, "deletions": 47}, "files": [{"sha": "a08faf2610e3315096b33f6290729771f92cbb98", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1ae620bbebadbe4362a28b37bcecd41cfed66cea/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae620bbebadbe4362a28b37bcecd41cfed66cea/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=1ae620bbebadbe4362a28b37bcecd41cfed66cea", "patch": "@@ -169,7 +169,23 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         }\n \n         if a.is_never() {\n-            return success(Adjust::NeverToAny, b, vec![]);\n+            // Subtle: If we are coercing from `!` to `?T`, where `?T` is an unbound\n+            // type variable, we want `?T` to fallback to `!` if not\n+            // otherwise constrained. An example where this arises:\n+            //\n+            //     let _: Option<?T> = Some({ return; });\n+            //\n+            // here, we would coerce from `!` to `?T`.\n+            let b = self.shallow_resolve(b);\n+            return if self.shallow_resolve(b).is_ty_var() {\n+                // micro-optimization: no need for this if `b` is\n+                // already resolved in some way.\n+                let diverging_ty = self.next_diverging_ty_var(\n+                    TypeVariableOrigin::AdjustmentType(self.cause.span));\n+                self.unify_and(&b, &diverging_ty, Adjust::NeverToAny)\n+            } else {\n+                success(Adjust::NeverToAny, b, vec![])\n+            };\n         }\n \n         // Consider coercing the subtype to a DST\n@@ -687,11 +703,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let adjustment = self.register_infer_ok_obligations(ok);\n             if !adjustment.is_identity() {\n                 debug!(\"Success, coerced with {:?}\", adjustment);\n-                match self.tables.borrow().adjustments.get(&expr.id) {\n-                    None |\n-                    Some(&Adjustment { kind: Adjust::NeverToAny, .. }) => (),\n-                    _ => bug!(\"expr already has an adjustment on it!\"),\n-                };\n+                if self.tables.borrow().adjustments.get(&expr.id).is_some() {\n+                    bug!(\"expr already has an adjustment on it!\");\n+                }\n                 self.write_adjustment(expr.id, adjustment);\n             }\n             Ok(adjustment.target)"}, {"sha": "ae0ed81ac778b2817318ab33458218c12c7c8962", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 45, "deletions": 34, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/1ae620bbebadbe4362a28b37bcecd41cfed66cea/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae620bbebadbe4362a28b37bcecd41cfed66cea/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1ae620bbebadbe4362a28b37bcecd41cfed66cea", "patch": "@@ -2664,7 +2664,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_expr_has_type(&self,\n                                expr: &'gcx hir::Expr,\n                                expected: Ty<'tcx>) -> Ty<'tcx> {\n-        let ty = self.check_expr_with_hint(expr, expected);\n+        let mut ty = self.check_expr_with_hint(expr, expected);\n+\n+        // While we don't allow *arbitrary* coercions here, we *do* allow\n+        // coercions from ! to `expected`.\n+        if ty.is_never() {\n+            assert!(!self.tables.borrow().adjustments.contains_key(&expr.id),\n+                    \"expression with never type wound up being adjusted\");\n+            let adj_ty = self.next_diverging_ty_var(\n+                TypeVariableOrigin::AdjustmentType(expr.span));\n+            self.write_adjustment(expr.id, adjustment::Adjustment {\n+                kind: adjustment::Adjust::NeverToAny,\n+                target: adj_ty\n+            });\n+            ty = adj_ty;\n+        }\n+\n         self.demand_suptype(expr.span, expected, ty);\n         ty\n     }\n@@ -3370,18 +3385,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"type of {} is...\", self.tcx.hir.node_to_string(expr.id));\n         debug!(\"... {:?}, expected is {:?}\", ty, expected);\n \n-        // Add adjustments to !-expressions\n-        if ty.is_never() {\n-            if let Some(hir::map::NodeExpr(node_expr)) = self.tcx.hir.find(expr.id) {\n-                let adj_ty = self.next_diverging_ty_var(\n-                    TypeVariableOrigin::AdjustmentType(node_expr.span));\n-                self.write_adjustment(expr.id, adjustment::Adjustment {\n-                    kind: adjustment::Adjust::NeverToAny,\n-                    target: adj_ty\n-                });\n-                return adj_ty;\n-            }\n-        }\n         ty\n     }\n \n@@ -4072,7 +4075,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_block_no_value(&self, blk: &'gcx hir::Block)  {\n         let unit = self.tcx.mk_nil();\n         let ty = self.check_block_with_expected(blk, ExpectHasType(unit));\n-        self.demand_suptype(blk.span, unit, ty);\n+\n+        // if the block produces a `!` value, that can always be\n+        // (effectively) coerced to unit.\n+        if !ty.is_never() {\n+            self.demand_suptype(blk.span, unit, ty);\n+        }\n     }\n \n     fn check_block_with_expected(&self,\n@@ -4111,7 +4119,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     },\n                     None => {\n                         e_ty = if self.diverges.get().always() {\n-                            self.next_diverging_ty_var(TypeVariableOrigin::DivergingBlockExpr(blk.span))\n+                            self.tcx.types.never\n                         } else {\n                             self.tcx.mk_nil()\n                         };\n@@ -4135,6 +4143,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     Err(err) =>\n                         self.report_mismatched_types(&cause, ctxt.unified, e_ty, err).emit(),\n                 }\n+            } else if self.diverges.get().always() {\n+                // No tail expression and the body diverges; ignore\n+                // the expected type, and keep `!` as the type of the\n+                // block.\n             } else {\n                 self.check_block_no_expr(blk, self.tcx.mk_nil(), e_ty);\n             };\n@@ -4147,33 +4159,32 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             let mut ty = match blk.expr {\n                 Some(ref e) => self.check_expr_with_expectation(e, expected),\n-                None => self.tcx.mk_nil()\n+                None => if self.diverges.get().always() {\n+                    self.tcx.types.never\n+                } else {\n+                    self.tcx.mk_nil()\n+                },\n             };\n \n-            if self.diverges.get().always() {\n-                if let ExpectHasType(ety) = expected {\n-                    // Avoid forcing a type (only `!` for now) in unreachable code.\n-                    // FIXME(aburka) do we need this special case? and should it be is_uninhabited?\n-                    if !ety.is_never() {\n-                        if let Some(ref e) = blk.expr {\n-                            // Coerce the tail expression to the right type.\n-                            self.demand_coerce(e, ty, ety);\n-                        }\n-                    }\n-                }\n-\n-                ty = self.next_diverging_ty_var(TypeVariableOrigin::DivergingBlockExpr(blk.span));\n-            } else if let ExpectHasType(ety) = expected {\n+            if let ExpectHasType(ety) = expected {\n                 if let Some(ref e) = blk.expr {\n                     // Coerce the tail expression to the right type.\n                     self.demand_coerce(e, ty, ety);\n+\n+                    // We already applied the type (and potentially errored),\n+                    // use the expected type to avoid further errors out.\n+                    ty = ety;\n+                } else if self.diverges.get().always() {\n+                    // No tail expression and the body diverges; ignore\n+                    // the expected type, and keep `!` as the type of the\n+                    // block.\n                 } else {\n                     self.check_block_no_expr(blk, ty, ety);\n-                }\n \n-                // We already applied the type (and potentially errored),\n-                // use the expected type to avoid further errors out.\n-                ty = ety;\n+                    // We already applied the type (and potentially errored),\n+                    // use the expected type to avoid further errors out.\n+                    ty = ety;\n+                }\n             }\n             ty\n         };"}, {"sha": "05b04723300482fb1b58e3b1f33101016cbecef0", "filename": "src/test/compile-fail/index-bot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ae620bbebadbe4362a28b37bcecd41cfed66cea/src%2Ftest%2Fcompile-fail%2Findex-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae620bbebadbe4362a28b37bcecd41cfed66cea/src%2Ftest%2Fcompile-fail%2Findex-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Findex-bot.rs?ref=1ae620bbebadbe4362a28b37bcecd41cfed66cea", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    (return)[0]; //~ ERROR the type of this value must be known in this context\n+    (return)[0]; //~ ERROR cannot index a value of type `!`\n }"}, {"sha": "0314f109a7c8129a7184b936f8900300ca03d86d", "filename": "src/test/compile-fail/issue-13847.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ae620bbebadbe4362a28b37bcecd41cfed66cea/src%2Ftest%2Fcompile-fail%2Fissue-13847.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae620bbebadbe4362a28b37bcecd41cfed66cea/src%2Ftest%2Fcompile-fail%2Fissue-13847.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13847.rs?ref=1ae620bbebadbe4362a28b37bcecd41cfed66cea", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    return.is_failure //~ ERROR the type of this value must be known in this context\n+    return.is_failure //~ ERROR no field `is_failure` on type `!`\n }"}, {"sha": "70da8cf4169bd64c93cf3f88136c1782ccf77ec2", "filename": "src/test/compile-fail/issue-15207.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ae620bbebadbe4362a28b37bcecd41cfed66cea/src%2Ftest%2Fcompile-fail%2Fissue-15207.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae620bbebadbe4362a28b37bcecd41cfed66cea/src%2Ftest%2Fcompile-fail%2Fissue-15207.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15207.rs?ref=1ae620bbebadbe4362a28b37bcecd41cfed66cea", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     loop {\n-        break.push(1) //~ ERROR the type of this value must be known in this context\n+        break.push(1) //~ ERROR no method named `push` found for type `!`\n         ;\n     }\n }"}, {"sha": "d5d597c190ea04d9d033391661d725bd2a63b985", "filename": "src/test/compile-fail/issue-15965.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ae620bbebadbe4362a28b37bcecd41cfed66cea/src%2Ftest%2Fcompile-fail%2Fissue-15965.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae620bbebadbe4362a28b37bcecd41cfed66cea/src%2Ftest%2Fcompile-fail%2Fissue-15965.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15965.rs?ref=1ae620bbebadbe4362a28b37bcecd41cfed66cea", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     return\n         { return () }\n-//~^ ERROR the type of this value must be known in this context\n+//~^ ERROR expected function, found `!`\n     ()\n     ;\n }"}, {"sha": "f6e6a8a0852dd290b5a847c88c03e1114bea037c", "filename": "src/test/compile-fail/issue-17373.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ae620bbebadbe4362a28b37bcecd41cfed66cea/src%2Ftest%2Fcompile-fail%2Fissue-17373.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae620bbebadbe4362a28b37bcecd41cfed66cea/src%2Ftest%2Fcompile-fail%2Fissue-17373.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17373.rs?ref=1ae620bbebadbe4362a28b37bcecd41cfed66cea", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    *return //~ ERROR the type of this value must be known in this context\n+    *return //~ ERROR type `!` cannot be dereferenced\n     ;\n }"}, {"sha": "2be5fdcac4ede37b2cc4d97073f57da3bcfa38c2", "filename": "src/test/compile-fail/issue-18532.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ae620bbebadbe4362a28b37bcecd41cfed66cea/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae620bbebadbe4362a28b37bcecd41cfed66cea/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs?ref=1ae620bbebadbe4362a28b37bcecd41cfed66cea", "patch": "@@ -13,6 +13,5 @@\n // into it.\n \n fn main() {\n-    (return)((),());\n-    //~^ ERROR the type of this value must be known\n+    (return)((),()); //~ ERROR expected function, found `!`\n }"}]}