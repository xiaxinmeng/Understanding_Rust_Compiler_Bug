{"sha": "5023860a55328db5ef024225263ed71f46a19350", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMjM4NjBhNTUzMjhkYjVlZjAyNDIyNTI2M2VkNzFmNDZhMTkzNTA=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-31T18:50:34Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-31T18:50:34Z"}, "message": "Merge #1356\n\n1356: move completed requests to a separate file r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "0ea40483691d7b9a7822149c670aeb84231a1bb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ea40483691d7b9a7822149c670aeb84231a1bb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5023860a55328db5ef024225263ed71f46a19350", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5023860a55328db5ef024225263ed71f46a19350", "html_url": "https://github.com/rust-lang/rust/commit/5023860a55328db5ef024225263ed71f46a19350", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5023860a55328db5ef024225263ed71f46a19350/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "6c1ec865fb931ffd789e2caa9e2ce82d1df97c4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c1ec865fb931ffd789e2caa9e2ce82d1df97c4d", "html_url": "https://github.com/rust-lang/rust/commit/6c1ec865fb931ffd789e2caa9e2ce82d1df97c4d"}, {"sha": "78e17f65cfa0013ea51d94f0142ca6d4bcc5d088", "url": "https://api.github.com/repos/rust-lang/rust/commits/78e17f65cfa0013ea51d94f0142ca6d4bcc5d088", "html_url": "https://github.com/rust-lang/rust/commit/78e17f65cfa0013ea51d94f0142ca6d4bcc5d088"}], "stats": {"total": 450, "additions": 263, "deletions": 187}, "files": [{"sha": "4524994972661d2bc56ca4d28a0f1c0539352cbd", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 176, "deletions": 146, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/5023860a55328db5ef024225263ed71f46a19350/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5023860a55328db5ef024225263ed71f46a19350/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=5023860a55328db5ef024225263ed71f46a19350", "patch": "@@ -1,7 +1,8 @@\n mod handlers;\n mod subscriptions;\n+pub(crate) mod pending_requests;\n \n-use std::{fmt, path::PathBuf, sync::Arc, time::Instant, any::TypeId};\n+use std::{fmt, path::PathBuf, sync::Arc, time::Instant};\n \n use crossbeam_channel::{select, unbounded, Receiver, RecvError, Sender};\n use failure::{bail, format_err};\n@@ -12,19 +13,24 @@ use gen_lsp_server::{\n use lsp_types::NumberOrString;\n use ra_ide_api::{Canceled, FileId, LibraryData};\n use ra_vfs::VfsTask;\n-use rustc_hash::FxHashMap;\n use serde::{de::DeserializeOwned, Serialize};\n use threadpool::ThreadPool;\n+use ra_prof::profile;\n \n use crate::{\n-    main_loop::subscriptions::Subscriptions,\n+    main_loop::{\n+        subscriptions::Subscriptions,\n+        pending_requests::{PendingRequests, PendingRequest},\n+    },\n     project_model::workspace_loader,\n     req,\n-    server_world::{ServerWorld, ServerWorldState, CompletedRequest},\n+    server_world::{ServerWorld, ServerWorldState},\n     Result,\n     InitializationOptions,\n };\n-use ra_prof::profile;\n+\n+const THREADPOOL_SIZE: usize = 8;\n+const MAX_IN_FLIGHT_LIBS: usize = THREADPOOL_SIZE - 3;\n \n #[derive(Debug, Fail)]\n #[fail(display = \"Language Server request failed with {}. ({})\", code, message)]\n@@ -39,34 +45,12 @@ impl LspError {\n     }\n }\n \n-#[derive(Debug)]\n-enum Task {\n-    Respond(RawResponse),\n-    Notify(RawNotification),\n-}\n-\n-struct PendingRequest {\n-    received: Instant,\n-    method: String,\n-}\n-\n-impl From<(u64, PendingRequest)> for CompletedRequest {\n-    fn from((id, pending): (u64, PendingRequest)) -> CompletedRequest {\n-        CompletedRequest { id, method: pending.method, duration: pending.received.elapsed() }\n-    }\n-}\n-\n-const THREADPOOL_SIZE: usize = 8;\n-\n pub fn main_loop(\n     ws_roots: Vec<PathBuf>,\n     options: InitializationOptions,\n     msg_receiver: &Receiver<RawMessage>,\n     msg_sender: &Sender<RawMessage>,\n ) -> Result<()> {\n-    let pool = ThreadPool::new(THREADPOOL_SIZE);\n-    let (task_sender, task_receiver) = unbounded::<Task>();\n-\n     // FIXME: support dynamic workspace loading.\n     let workspaces = {\n         let ws_worker = workspace_loader();\n@@ -91,10 +75,12 @@ pub fn main_loop(\n \n     let mut state = ServerWorldState::new(ws_roots, workspaces);\n \n-    log::info!(\"server initialized, serving requests\");\n+    let pool = ThreadPool::new(THREADPOOL_SIZE);\n+    let (task_sender, task_receiver) = unbounded::<Task>();\n+    let mut pending_requests = PendingRequests::default();\n+    let mut subs = Subscriptions::default();\n \n-    let mut pending_requests = FxHashMap::default();\n-    let mut subs = Subscriptions::new();\n+    log::info!(\"server initialized, serving requests\");\n     let main_res = main_loop_inner(\n         options,\n         &pool,\n@@ -122,6 +108,12 @@ pub fn main_loop(\n     main_res\n }\n \n+#[derive(Debug)]\n+enum Task {\n+    Respond(RawResponse),\n+    Notify(RawNotification),\n+}\n+\n enum Event {\n     Msg(RawMessage),\n     Task(Task),\n@@ -172,10 +164,10 @@ fn main_loop_inner(\n     task_sender: Sender<Task>,\n     task_receiver: Receiver<Task>,\n     state: &mut ServerWorldState,\n-    pending_requests: &mut FxHashMap<u64, PendingRequest>,\n+    pending_requests: &mut PendingRequests,\n     subs: &mut Subscriptions,\n ) -> Result<()> {\n-    // We try not to index more than THREADPOOL_SIZE - 3 libraries at the same\n+    // We try not to index more than MAX_IN_FLIGHT_LIBS libraries at the same\n     // time to always have a thread ready to react to input.\n     let mut in_flight_libraries = 0;\n     let mut pending_libraries = Vec::new();\n@@ -196,15 +188,16 @@ fn main_loop_inner(\n             },\n             recv(libdata_receiver) -> data => Event::Lib(data.unwrap())\n         };\n-        // NOTE: don't count blocking select! call as a loop-turn time\n-        let _p = profile(\"main_loop_inner/loop-turn\");\n         let loop_start = Instant::now();\n \n+        // NOTE: don't count blocking select! call as a loop-turn time\n+        let _p = profile(\"main_loop_inner/loop-turn\");\n         log::info!(\"loop turn = {:?}\", event);\n         let queue_count = pool.queued_count();\n         if queue_count > 0 {\n             log::info!(\"queued count = {}\", queue_count);\n         }\n+\n         let mut state_changed = false;\n         match event {\n             Event::Task(task) => {\n@@ -226,34 +219,15 @@ fn main_loop_inner(\n                         Some(req) => req,\n                         None => return Ok(()),\n                     };\n-                    match req.cast::<req::CollectGarbage>() {\n-                        Ok((id, ())) => {\n-                            state.collect_garbage();\n-                            let resp = RawResponse::ok::<req::CollectGarbage>(id, &());\n-                            msg_sender.send(resp.into()).unwrap()\n-                        }\n-                        Err(req) => {\n-                            match on_request(\n-                                state,\n-                                pending_requests,\n-                                pool,\n-                                &task_sender,\n-                                loop_start,\n-                                req,\n-                            )? {\n-                                None => (),\n-                                Some(req) => {\n-                                    log::error!(\"unknown request: {:?}\", req);\n-                                    let resp = RawResponse::err(\n-                                        req.id,\n-                                        ErrorCode::MethodNotFound as i32,\n-                                        \"unknown request\".to_string(),\n-                                    );\n-                                    msg_sender.send(resp.into()).unwrap()\n-                                }\n-                            }\n-                        }\n-                    }\n+                    on_request(\n+                        state,\n+                        pending_requests,\n+                        pool,\n+                        &task_sender,\n+                        msg_sender,\n+                        loop_start,\n+                        req,\n+                    )?\n                 }\n                 RawMessage::Notification(not) => {\n                     on_notification(msg_sender, state, pending_requests, subs, not)?;\n@@ -264,7 +238,7 @@ fn main_loop_inner(\n         };\n \n         pending_libraries.extend(state.process_changes());\n-        while in_flight_libraries < THREADPOOL_SIZE - 3 && !pending_libraries.is_empty() {\n+        while in_flight_libraries < MAX_IN_FLIGHT_LIBS && !pending_libraries.is_empty() {\n             let (root, files) = pending_libraries.pop().unwrap();\n             in_flight_libraries += 1;\n             let sender = libdata_sender.clone();\n@@ -305,13 +279,12 @@ fn main_loop_inner(\n fn on_task(\n     task: Task,\n     msg_sender: &Sender<RawMessage>,\n-    pending_requests: &mut FxHashMap<u64, PendingRequest>,\n+    pending_requests: &mut PendingRequests,\n     state: &mut ServerWorldState,\n ) {\n     match task {\n         Task::Respond(response) => {\n-            if let Some(pending) = pending_requests.remove(&response.id) {\n-                let completed = CompletedRequest::from((response.id, pending));\n+            if let Some(completed) = pending_requests.finish(response.id) {\n                 log::info!(\"handled req#{} in {:?}\", completed.id, completed.duration);\n                 state.complete_request(completed);\n                 msg_sender.send(response.into()).unwrap();\n@@ -325,22 +298,35 @@ fn on_task(\n \n fn on_request(\n     world: &mut ServerWorldState,\n-    pending_requests: &mut FxHashMap<u64, PendingRequest>,\n+    pending_requests: &mut PendingRequests,\n     pool: &ThreadPool,\n     sender: &Sender<Task>,\n+    msg_sender: &Sender<RawMessage>,\n     request_received: Instant,\n     req: RawRequest,\n-) -> Result<Option<RawRequest>> {\n-    let method = req.method.clone();\n-    let mut pool_dispatcher = PoolDispatcher { req: Some(req), res: None, pool, world, sender };\n-    let req = pool_dispatcher\n+) -> Result<()> {\n+    let mut pool_dispatcher = PoolDispatcher {\n+        req: Some(req),\n+        pool,\n+        world,\n+        sender,\n+        msg_sender,\n+        pending_requests,\n+        request_received,\n+    };\n+    pool_dispatcher\n+        .on_sync::<req::CollectGarbage>(|s, ()| Ok(s.collect_garbage()))?\n+        .on_sync::<req::JoinLines>(|s, p| handlers::handle_join_lines(s.snapshot(), p))?\n+        .on_sync::<req::OnEnter>(|s, p| handlers::handle_on_enter(s.snapshot(), p))?\n+        .on_sync::<req::SelectionRangeRequest>(|s, p| {\n+            handlers::handle_selection_range(s.snapshot(), p)\n+        })?\n+        .on_sync::<req::FindMatchingBrace>(|s, p| {\n+            handlers::handle_find_matching_brace(s.snapshot(), p)\n+        })?\n         .on::<req::AnalyzerStatus>(handlers::handle_analyzer_status)?\n         .on::<req::SyntaxTree>(handlers::handle_syntax_tree)?\n         .on::<req::ExtendSelection>(handlers::handle_extend_selection)?\n-        .on::<req::SelectionRangeRequest>(handlers::handle_selection_range)?\n-        .on::<req::FindMatchingBrace>(handlers::handle_find_matching_brace)?\n-        .on::<req::JoinLines>(handlers::handle_join_lines)?\n-        .on::<req::OnEnter>(handlers::handle_on_enter)?\n         .on::<req::OnTypeFormatting>(handlers::handle_on_type_formatting)?\n         .on::<req::DocumentSymbolRequest>(handlers::handle_document_symbol)?\n         .on::<req::WorkspaceSymbol>(handlers::handle_workspace_symbol)?\n@@ -363,21 +349,13 @@ fn on_request(\n         .on::<req::Formatting>(handlers::handle_formatting)?\n         .on::<req::DocumentHighlightRequest>(handlers::handle_document_highlight)?\n         .finish();\n-    match req {\n-        Ok(id) => {\n-            let prev =\n-                pending_requests.insert(id, PendingRequest { method, received: request_received });\n-            assert!(prev.is_none(), \"duplicate request: {}\", id);\n-            Ok(None)\n-        }\n-        Err(req) => Ok(Some(req)),\n-    }\n+    Ok(())\n }\n \n fn on_notification(\n     msg_sender: &Sender<RawMessage>,\n     state: &mut ServerWorldState,\n-    pending_requests: &mut FxHashMap<u64, PendingRequest>,\n+    pending_requests: &mut PendingRequests,\n     subs: &mut Subscriptions,\n     not: RawNotification,\n ) -> Result<()> {\n@@ -389,7 +367,7 @@ fn on_notification(\n                     panic!(\"string id's not supported: {:?}\", id);\n                 }\n             };\n-            if pending_requests.remove(&id).is_some() {\n+            if pending_requests.cancel(id) {\n                 let response = RawResponse::err(\n                     id,\n                     ErrorCode::RequestCanceled as i32,\n@@ -445,88 +423,140 @@ fn on_notification(\n \n struct PoolDispatcher<'a> {\n     req: Option<RawRequest>,\n-    res: Option<u64>,\n     pool: &'a ThreadPool,\n     world: &'a mut ServerWorldState,\n+    pending_requests: &'a mut PendingRequests,\n+    msg_sender: &'a Sender<RawMessage>,\n     sender: &'a Sender<Task>,\n+    request_received: Instant,\n }\n \n impl<'a> PoolDispatcher<'a> {\n+    /// Dispatches the request onto the current thread\n+    fn on_sync<R>(\n+        &mut self,\n+        f: fn(&mut ServerWorldState, R::Params) -> Result<R::Result>,\n+    ) -> Result<&mut Self>\n+    where\n+        R: req::Request + 'static,\n+        R::Params: DeserializeOwned + Send + 'static,\n+        R::Result: Serialize + 'static,\n+    {\n+        let (id, params) = match self.parse::<R>() {\n+            Some(it) => it,\n+            None => {\n+                return Ok(self);\n+            }\n+        };\n+        let result = f(self.world, params);\n+        let task = result_to_task::<R>(id, result);\n+        on_task(task, self.msg_sender, self.pending_requests, self.world);\n+        Ok(self)\n+    }\n+\n+    /// Dispatches the request onto thread pool\n     fn on<R>(&mut self, f: fn(ServerWorld, R::Params) -> Result<R::Result>) -> Result<&mut Self>\n     where\n         R: req::Request + 'static,\n         R::Params: DeserializeOwned + Send + 'static,\n         R::Result: Serialize + 'static,\n     {\n-        let req = match self.req.take() {\n-            None => return Ok(self),\n-            Some(req) => req,\n+        let (id, params) = match self.parse::<R>() {\n+            Some(it) => it,\n+            None => {\n+                return Ok(self);\n+            }\n         };\n-        match req.cast::<R>() {\n-            Ok((id, params)) => {\n-                // Real time requests block user typing, so we should react quickly to them.\n-                // Currently this means that we try to cancel background jobs if we don't have\n-                // a spare thread.\n-                let is_real_time = TypeId::of::<R>() == TypeId::of::<req::JoinLines>()\n-                    || TypeId::of::<R>() == TypeId::of::<req::OnEnter>();\n-                if self.pool.queued_count() > 0 && is_real_time {\n-                    self.world.cancel_requests();\n-                }\n \n-                let world = self.world.snapshot();\n-                let sender = self.sender.clone();\n-                self.pool.execute(move || {\n-                    let response = match f(world, params) {\n-                        Ok(resp) => RawResponse::ok::<R>(id, &resp),\n-                        Err(e) => match e.downcast::<LspError>() {\n-                            Ok(lsp_error) => {\n-                                RawResponse::err(id, lsp_error.code, lsp_error.message)\n-                            }\n-                            Err(e) => {\n-                                if is_canceled(&e) {\n-                                    // FIXME: When https://github.com/Microsoft/vscode-languageserver-node/issues/457\n-                                    // gets fixed, we can return the proper response.\n-                                    // This works around the issue where \"content modified\" error would continuously\n-                                    // show an message pop-up in VsCode\n-                                    // RawResponse::err(\n-                                    //     id,\n-                                    //     ErrorCode::ContentModified as i32,\n-                                    //     \"content modified\".to_string(),\n-                                    // )\n-                                    RawResponse {\n-                                        id,\n-                                        result: Some(serde_json::to_value(&()).unwrap()),\n-                                        error: None,\n-                                    }\n-                                } else {\n-                                    RawResponse::err(\n-                                        id,\n-                                        ErrorCode::InternalError as i32,\n-                                        format!(\"{}\\n{}\", e, e.backtrace()),\n-                                    )\n-                                }\n-                            }\n-                        },\n-                    };\n-                    let task = Task::Respond(response);\n-                    sender.send(task).unwrap();\n-                });\n-                self.res = Some(id);\n+        self.pool.execute({\n+            let world = self.world.snapshot();\n+            let sender = self.sender.clone();\n+            move || {\n+                let result = f(world, params);\n+                let task = result_to_task::<R>(id, result);\n+                sender.send(task).unwrap();\n             }\n-            Err(req) => self.req = Some(req),\n-        }\n+        });\n+\n         Ok(self)\n     }\n \n-    fn finish(&mut self) -> std::result::Result<u64, RawRequest> {\n-        match (self.res.take(), self.req.take()) {\n-            (Some(res), None) => Ok(res),\n-            (None, Some(req)) => Err(req),\n-            _ => unreachable!(),\n+    fn parse<R>(&mut self) -> Option<(u64, R::Params)>\n+    where\n+        R: req::Request + 'static,\n+        R::Params: DeserializeOwned + Send + 'static,\n+    {\n+        let req = self.req.take()?;\n+        let (id, params) = match req.cast::<R>() {\n+            Ok(it) => it,\n+            Err(req) => {\n+                self.req = Some(req);\n+                return None;\n+            }\n+        };\n+        self.pending_requests.start(PendingRequest {\n+            id,\n+            method: R::METHOD.to_string(),\n+            received: self.request_received,\n+        });\n+        Some((id, params))\n+    }\n+\n+    fn finish(&mut self) {\n+        match self.req.take() {\n+            None => (),\n+            Some(req) => {\n+                log::error!(\"unknown request: {:?}\", req);\n+                let resp = RawResponse::err(\n+                    req.id,\n+                    ErrorCode::MethodNotFound as i32,\n+                    \"unknown request\".to_string(),\n+                );\n+                self.msg_sender.send(resp.into()).unwrap();\n+            }\n         }\n     }\n }\n \n+fn result_to_task<R>(id: u64, result: Result<R::Result>) -> Task\n+where\n+    R: req::Request + 'static,\n+    R::Params: DeserializeOwned + Send + 'static,\n+    R::Result: Serialize + 'static,\n+{\n+    let response = match result {\n+        Ok(resp) => RawResponse::ok::<R>(id, &resp),\n+        Err(e) => match e.downcast::<LspError>() {\n+            Ok(lsp_error) => RawResponse::err(id, lsp_error.code, lsp_error.message),\n+            Err(e) => {\n+                if is_canceled(&e) {\n+                    // FIXME: When https://github.com/Microsoft/vscode-languageserver-node/issues/457\n+                    // gets fixed, we can return the proper response.\n+                    // This works around the issue where \"content modified\" error would continuously\n+                    // show an message pop-up in VsCode\n+                    // RawResponse::err(\n+                    //     id,\n+                    //     ErrorCode::ContentModified as i32,\n+                    //     \"content modified\".to_string(),\n+                    // )\n+                    RawResponse {\n+                        id,\n+                        result: Some(serde_json::to_value(&()).unwrap()),\n+                        error: None,\n+                    }\n+                } else {\n+                    RawResponse::err(\n+                        id,\n+                        ErrorCode::InternalError as i32,\n+                        format!(\"{}\\n{}\", e, e.backtrace()),\n+                    )\n+                }\n+            }\n+        },\n+    };\n+    Task::Respond(response)\n+}\n+\n fn update_file_notifications_on_threadpool(\n     pool: &ThreadPool,\n     world: ServerWorld,"}, {"sha": "8cfb6a1925a2b28d8353b481bb7bf16d4fb1dc03", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5023860a55328db5ef024225263ed71f46a19350/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5023860a55328db5ef024225263ed71f46a19350/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=5023860a55328db5ef024225263ed71f46a19350", "patch": "@@ -31,10 +31,10 @@ use crate::{\n pub fn handle_analyzer_status(world: ServerWorld, _: ()) -> Result<String> {\n     let mut buf = world.status();\n     writeln!(buf, \"\\n\\nrequests:\").unwrap();\n-    let requests = world.latest_completed_requests.read();\n-    for (idx, r) in requests.iter().enumerate() {\n-        let current = if idx == world.request_idx { \"*\" } else { \" \" };\n-        writeln!(buf, \"{:4}{}{:<36}{}ms\", r.id, current, r.method, r.duration.as_millis()).unwrap();\n+    let requests = world.latest_requests.read();\n+    for (is_last, r) in requests.iter() {\n+        let mark = if is_last { \"*\" } else { \" \" };\n+        writeln!(buf, \"{}{:4} {:<36}{}ms\", mark, r.id, r.method, r.duration.as_millis()).unwrap();\n     }\n     Ok(buf)\n }"}, {"sha": "741770e45655e7418e78403b082599d1b70fad7f", "filename": "crates/ra_lsp_server/src/main_loop/pending_requests.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/5023860a55328db5ef024225263ed71f46a19350/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fpending_requests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5023860a55328db5ef024225263ed71f46a19350/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fpending_requests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fpending_requests.rs?ref=5023860a55328db5ef024225263ed71f46a19350", "patch": "@@ -0,0 +1,72 @@\n+use std::time::{Duration, Instant};\n+\n+use rustc_hash::FxHashMap;\n+\n+#[derive(Debug)]\n+pub struct CompletedRequest {\n+    pub id: u64,\n+    pub method: String,\n+    pub duration: Duration,\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct PendingRequest {\n+    pub(crate) id: u64,\n+    pub(crate) method: String,\n+    pub(crate) received: Instant,\n+}\n+\n+impl From<PendingRequest> for CompletedRequest {\n+    fn from(pending: PendingRequest) -> CompletedRequest {\n+        CompletedRequest {\n+            id: pending.id,\n+            method: pending.method,\n+            duration: pending.received.elapsed(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Default)]\n+pub(crate) struct PendingRequests {\n+    map: FxHashMap<u64, PendingRequest>,\n+}\n+\n+impl PendingRequests {\n+    pub(crate) fn start(&mut self, request: PendingRequest) {\n+        let id = request.id;\n+        let prev = self.map.insert(id, request);\n+        assert!(prev.is_none(), \"duplicate request with id {}\", id);\n+    }\n+    pub(crate) fn cancel(&mut self, id: u64) -> bool {\n+        self.map.remove(&id).is_some()\n+    }\n+    pub(crate) fn finish(&mut self, id: u64) -> Option<CompletedRequest> {\n+        self.map.remove(&id).map(CompletedRequest::from)\n+    }\n+}\n+\n+const N_COMPLETED_REQUESTS: usize = 10;\n+\n+#[derive(Debug, Default)]\n+pub struct LatestRequests {\n+    // hand-rolling VecDeque here to print things in a nicer way\n+    buf: [Option<CompletedRequest>; N_COMPLETED_REQUESTS],\n+    idx: usize,\n+}\n+\n+impl LatestRequests {\n+    pub(crate) fn record(&mut self, request: CompletedRequest) {\n+        // special case: don't track status request itself\n+        if request.method == \"rust-analyzer/analyzerStatus\" {\n+            return;\n+        }\n+        let idx = self.idx;\n+        self.buf[idx] = Some(request);\n+        self.idx = (idx + 1) % N_COMPLETED_REQUESTS;\n+    }\n+\n+    pub(crate) fn iter(&self) -> impl Iterator<Item = (bool, &CompletedRequest)> {\n+        let idx = self.idx;\n+        self.buf.iter().enumerate().filter_map(move |(i, req)| Some((i == idx, req.as_ref()?)))\n+    }\n+}"}, {"sha": "470bc12051e76970ce0290cc32b67124e89cc4b8", "filename": "crates/ra_lsp_server/src/main_loop/subscriptions.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5023860a55328db5ef024225263ed71f46a19350/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5023860a55328db5ef024225263ed71f46a19350/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs?ref=5023860a55328db5ef024225263ed71f46a19350", "patch": "@@ -1,21 +1,19 @@\n use ra_ide_api::FileId;\n use rustc_hash::FxHashSet;\n \n-pub struct Subscriptions {\n+#[derive(Default)]\n+pub(crate) struct Subscriptions {\n     subs: FxHashSet<FileId>,\n }\n \n impl Subscriptions {\n-    pub fn new() -> Subscriptions {\n-        Subscriptions { subs: FxHashSet::default() }\n-    }\n-    pub fn add_sub(&mut self, file_id: FileId) {\n+    pub(crate) fn add_sub(&mut self, file_id: FileId) {\n         self.subs.insert(file_id);\n     }\n-    pub fn remove_sub(&mut self, file_id: FileId) {\n+    pub(crate) fn remove_sub(&mut self, file_id: FileId) {\n         self.subs.remove(&file_id);\n     }\n-    pub fn subscriptions(&self) -> Vec<FileId> {\n+    pub(crate) fn subscriptions(&self) -> Vec<FileId> {\n         self.subs.iter().cloned().collect()\n     }\n }"}, {"sha": "6076a6cd6b268f18d4fca2920dbc913ac4b0a770", "filename": "crates/ra_lsp_server/src/server_world.rs", "status": "modified", "additions": 6, "deletions": 30, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5023860a55328db5ef024225263ed71f46a19350/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5023860a55328db5ef024225263ed71f46a19350/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs?ref=5023860a55328db5ef024225263ed71f46a19350", "patch": "@@ -1,7 +1,6 @@\n use std::{\n     path::{Path, PathBuf},\n     sync::Arc,\n-    time::Duration,\n };\n \n use lsp_types::Url;\n@@ -16,6 +15,7 @@ use failure::{Error, format_err};\n use gen_lsp_server::ErrorCode;\n \n use crate::{\n+    main_loop::pending_requests::{CompletedRequest, LatestRequests},\n     project_model::ProjectWorkspace,\n     vfs_filter::IncludeRustFiles,\n     Result,\n@@ -29,26 +29,14 @@ pub struct ServerWorldState {\n     pub workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub analysis_host: AnalysisHost,\n     pub vfs: Arc<RwLock<Vfs>>,\n-    // hand-rolling VecDeque here to print things in a nicer way\n-    pub latest_completed_requests: Arc<RwLock<[CompletedRequest; N_COMPLETED_REQUESTS]>>,\n-    pub request_idx: usize,\n+    pub latest_requests: Arc<RwLock<LatestRequests>>,\n }\n \n-const N_COMPLETED_REQUESTS: usize = 10;\n-\n pub struct ServerWorld {\n     pub workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub analysis: Analysis,\n     pub vfs: Arc<RwLock<Vfs>>,\n-    pub latest_completed_requests: Arc<RwLock<[CompletedRequest; N_COMPLETED_REQUESTS]>>,\n-    pub request_idx: usize,\n-}\n-\n-#[derive(Debug, Default)]\n-pub struct CompletedRequest {\n-    pub id: u64,\n-    pub method: String,\n-    pub duration: Duration,\n+    pub latest_requests: Arc<RwLock<LatestRequests>>,\n }\n \n impl ServerWorldState {\n@@ -88,8 +76,7 @@ impl ServerWorldState {\n             workspaces: Arc::new(workspaces),\n             analysis_host,\n             vfs: Arc::new(RwLock::new(vfs)),\n-            latest_completed_requests: Default::default(),\n-            request_idx: 0,\n+            latest_requests: Default::default(),\n         }\n     }\n \n@@ -149,17 +136,12 @@ impl ServerWorldState {\n         self.analysis_host.apply_change(change);\n     }\n \n-    pub fn cancel_requests(&mut self) {\n-        self.analysis_host.apply_change(AnalysisChange::new());\n-    }\n-\n     pub fn snapshot(&self) -> ServerWorld {\n         ServerWorld {\n             workspaces: Arc::clone(&self.workspaces),\n             analysis: self.analysis_host.analysis(),\n             vfs: Arc::clone(&self.vfs),\n-            latest_completed_requests: Arc::clone(&self.latest_completed_requests),\n-            request_idx: self.request_idx.checked_sub(1).unwrap_or(N_COMPLETED_REQUESTS - 1),\n+            latest_requests: Arc::clone(&self.latest_requests),\n         }\n     }\n \n@@ -172,13 +154,7 @@ impl ServerWorldState {\n     }\n \n     pub fn complete_request(&mut self, request: CompletedRequest) {\n-        // special case: don't track status request itself\n-        if request.method == \"rust-analyzer/analyzerStatus\" {\n-            return;\n-        }\n-        let idx = self.request_idx;\n-        self.latest_completed_requests.write()[idx] = request;\n-        self.request_idx = (idx + 1) % N_COMPLETED_REQUESTS;\n+        self.latest_requests.write().record(request)\n     }\n }\n "}]}