{"sha": "fcdac030335ba58e8267f3414101d4c2edb3797c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjZGFjMDMwMzM1YmE1OGU4MjY3ZjM0MTQxMDFkNGMyZWRiMzc5N2M=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-17T12:37:51Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-17T12:37:51Z"}, "message": "Rewrite def map tests from insta to expect\n\nThose indentation markers are annoying...", "tree": {"sha": "33f5b632ed98ffd6cbd7d670b4d9ee79893e31de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33f5b632ed98ffd6cbd7d670b4d9ee79893e31de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcdac030335ba58e8267f3414101d4c2edb3797c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcdac030335ba58e8267f3414101d4c2edb3797c", "html_url": "https://github.com/rust-lang/rust/commit/fcdac030335ba58e8267f3414101d4c2edb3797c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcdac030335ba58e8267f3414101d4c2edb3797c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c268b9a5f4502271b0eec1071f6eaf4d535cea8", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c268b9a5f4502271b0eec1071f6eaf4d535cea8", "html_url": "https://github.com/rust-lang/rust/commit/2c268b9a5f4502271b0eec1071f6eaf4d535cea8"}], "stats": {"total": 3759, "additions": 1821, "deletions": 1938}, "files": [{"sha": "02dca80c252c3f590a99077943aff9140b42f717", "filename": "crates/ra_hir_def/src/nameres/tests.rs", "status": "modified", "additions": 408, "deletions": 436, "changes": 844, "blob_url": "https://github.com/rust-lang/rust/blob/fcdac030335ba58e8267f3414101d4c2edb3797c/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcdac030335ba58e8267f3414101d4c2edb3797c/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=fcdac030335ba58e8267f3414101d4c2edb3797c", "patch": "@@ -6,558 +6,531 @@ mod primitives;\n \n use std::sync::Arc;\n \n-use insta::assert_snapshot;\n+use expect::{expect, Expect};\n use ra_db::{fixture::WithFixture, SourceDatabase};\n use test_utils::mark;\n \n use crate::{db::DefDatabase, nameres::*, test_db::TestDB};\n \n-fn def_map(ra_fixture: &str) -> String {\n-    compute_crate_def_map(ra_fixture).dump()\n-}\n-\n fn compute_crate_def_map(fixture: &str) -> Arc<CrateDefMap> {\n     let db = TestDB::with_files(fixture);\n     let krate = db.crate_graph().iter().next().unwrap();\n     db.crate_def_map(krate)\n }\n \n+fn check(ra_fixture: &str, expect: Expect) {\n+    let db = TestDB::with_files(ra_fixture);\n+    let krate = db.crate_graph().iter().next().unwrap();\n+    let actual = db.crate_def_map(krate).dump() + \"\\n\";\n+    expect.assert_eq(&actual);\n+}\n+\n #[test]\n fn crate_def_map_smoke_test() {\n-    let map = def_map(\n-        r\"\n-        //- /lib.rs\n-        mod foo;\n-        struct S;\n-        use crate::foo::bar::E;\n-        use self::E::V;\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-        fn f() {}\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-\n-        union U {\n-            to_be: bool,\n-            not_to_be: u8,\n-        }\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+struct S;\n+use crate::foo::bar::E;\n+use self::E::V;\n \n-        enum E { V }\n+//- /foo/mod.rs\n+pub mod bar;\n+fn f() {}\n \n-        extern {\n-            static EXT: u8;\n-            fn ext();\n-        }\n-        \",\n+//- /foo/bar.rs\n+pub struct Baz;\n+\n+union U { to_be: bool, not_to_be: u8 }\n+enum E { V }\n+\n+extern {\n+    static EXT: u8;\n+    fn ext();\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            E: t\n+            S: t v\n+            V: t v\n+            foo: t\n+\n+            crate::foo\n+            bar: t\n+            f: v\n+\n+            crate::foo::bar\n+            Baz: t v\n+            E: t\n+            EXT: v\n+            U: t\n+            ext: v\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeE: t\n-        \u22eeS: t v\n-        \u22eeV: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22eef: v\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-        \u22eeE: t\n-        \u22eeEXT: v\n-        \u22eeU: t\n-        \u22eeext: v\n-    \"###)\n }\n \n #[test]\n fn crate_def_map_super_super() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod a {\n-            const A: usize = 0;\n-\n-            mod b {\n-                const B: usize = 0;\n-\n-                mod c {\n-                    use super::super::*;\n-                }\n-            }\n+    check(\n+        r#\"\n+mod a {\n+    const A: usize = 0;\n+    mod b {\n+        const B: usize = 0;\n+        mod c {\n+            use super::super::*;\n         }\n-        \",\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            a: t\n+\n+            crate::a\n+            A: v\n+            b: t\n+\n+            crate::a::b\n+            B: v\n+            c: t\n+\n+            crate::a::b::c\n+            A: v\n+            b: t\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eea: t\n-        \u22ee\n-        \u22eecrate::a\n-        \u22eeA: v\n-        \u22eeb: t\n-        \u22ee\n-        \u22eecrate::a::b\n-        \u22eeB: v\n-        \u22eec: t\n-        \u22ee\n-        \u22eecrate::a::b::c\n-        \u22eeA: v\n-        \u22eeb: t\n-    \"###)\n }\n \n #[test]\n fn crate_def_map_fn_mod_same_name() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod m {\n-            pub mod z {}\n-            pub fn z() {}\n-        }\n-        \",\n+    check(\n+        r#\"\n+mod m {\n+    pub mod z {}\n+    pub fn z() {}\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            m: t\n+\n+            crate::m\n+            z: t v\n+\n+            crate::m::z\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eem: t\n-        \u22ee\n-        \u22eecrate::m\n-        \u22eez: t v\n-        \u22ee\n-        \u22eecrate::m::z\n-    \"###)\n }\n \n #[test]\n fn bogus_paths() {\n     mark::check!(bogus_paths);\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        struct S;\n-        use self;\n-\n-        //- /foo/mod.rs\n-        use super;\n-        use crate;\n-\n-        \",\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+struct S;\n+use self;\n+\n+//- /foo/mod.rs\n+use super;\n+use crate;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            S: t v\n+            foo: t\n+\n+            crate::foo\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeS: t v\n-   \u22eefoo: t\n-   \u22ee\n-   \u22eecrate::foo\n-    \"###\n-    )\n }\n \n #[test]\n fn use_as() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-\n-        use crate::foo::Baz as Foo;\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+use crate::foo::Baz as Foo;\n \n-        //- /foo/mod.rs\n-        pub struct Baz;\n-        \",\n-    );\n-    assert_snapshot!(map,\n-        @r###\"\n-   \u22eecrate\n-   \u22eeFoo: t v\n-   \u22eefoo: t\n-   \u22ee\n-   \u22eecrate::foo\n-   \u22eeBaz: t v\n-    \"###\n+//- /foo/mod.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Foo: t v\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+        \"#]],\n     );\n }\n \n #[test]\n fn use_trees() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-\n-        use crate::foo::bar::{Baz, Quux};\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+use crate::foo::bar::{Baz, Quux};\n \n-        //- /foo/mod.rs\n-        pub mod bar;\n+//- /foo/mod.rs\n+pub mod bar;\n \n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        pub enum Quux {};\n-        \",\n+//- /foo/bar.rs\n+pub struct Baz;\n+pub enum Quux {};\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+            Quux: t\n+            foo: t\n+\n+            crate::foo\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+            Quux: t\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-        \u22eeQuux: t\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-        \u22eeQuux: t\n-    \"###);\n }\n \n #[test]\n fn re_exports() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-\n-        use self::foo::Baz;\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+use self::foo::Baz;\n \n-        pub use self::bar::Baz;\n+//- /foo/mod.rs\n+pub mod bar;\n+pub use self::bar::Baz;\n \n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        \",\n+//- /foo/bar.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn std_prelude() {\n     mark::check!(std_prelude);\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:test_crate\n-        use Foo::*;\n-\n-        //- /lib.rs crate:test_crate\n-        mod prelude;\n-        #[prelude_import]\n-        use prelude::*;\n-\n-        //- /prelude.rs\n-        pub enum Foo { Bar, Baz };\n-        \",\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:test_crate\n+use Foo::*;\n+\n+//- /lib.rs crate:test_crate\n+mod prelude;\n+#[prelude_import]\n+use prelude::*;\n+\n+//- /prelude.rs\n+pub enum Foo { Bar, Baz };\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            Baz: t v\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn can_import_enum_variant() {\n     mark::check!(can_import_enum_variant);\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        enum E { V }\n-        use self::E::V;\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeE: t\n-        \u22eeV: t v\n-    \"###\n+    check(\n+        r#\"\n+enum E { V }\n+use self::E::V;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            E: t\n+            V: t v\n+        \"#]],\n     );\n }\n \n #[test]\n fn edition_2015_imports() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:other_crate edition:2015\n-        mod foo;\n-        mod bar;\n-\n-        //- /bar.rs\n-        struct Bar;\n-\n-        //- /foo.rs\n-        use bar::Bar;\n-        use other_crate::FromLib;\n-\n-        //- /lib.rs crate:other_crate edition:2018\n-        struct FromLib;\n-        \",\n-    );\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:other_crate edition:2015\n+mod foo;\n+mod bar;\n+\n+//- /bar.rs\n+struct Bar;\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eebar: t\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::bar\n-        \u22eeBar: t v\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBar: t v\n-        \u22eeFromLib: t v\n-    \"###);\n+//- /foo.rs\n+use bar::Bar;\n+use other_crate::FromLib;\n+\n+//- /lib.rs crate:other_crate edition:2018\n+struct FromLib;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            bar: t\n+            foo: t\n+\n+            crate::bar\n+            Bar: t v\n+\n+            crate::foo\n+            Bar: t v\n+            FromLib: t v\n+        \"#]],\n+    );\n }\n \n #[test]\n fn item_map_using_self() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        use crate::foo::bar::Baz::{self};\n-        //- /foo/mod.rs\n-        pub mod bar;\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        \",\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+use crate::foo::bar::Baz::{self};\n+\n+//- /foo/mod.rs\n+pub mod bar;\n+\n+//- /foo/bar.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+            foo: t\n+\n+            crate::foo\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn item_map_across_crates() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:test_crate\n-        use test_crate::Baz;\n-\n-        //- /lib.rs crate:test_crate\n-        pub struct Baz;\n-        \",\n-    );\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:test_crate\n+use test_crate::Baz;\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-    \"###);\n+//- /lib.rs crate:test_crate\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+        \"#]],\n+    );\n }\n \n #[test]\n fn extern_crate_rename() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:alloc\n-        extern crate alloc as alloc_crate;\n-\n-        mod alloc;\n-        mod sync;\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:alloc\n+extern crate alloc as alloc_crate;\n+mod alloc;\n+mod sync;\n \n-        //- /sync.rs\n-        use alloc_crate::Arc;\n+//- /sync.rs\n+use alloc_crate::Arc;\n \n-        //- /lib.rs crate:alloc\n-        struct Arc;\n-        \",\n+//- /lib.rs crate:alloc\n+struct Arc;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            alloc_crate: t\n+            sync: t\n+\n+            crate::sync\n+            Arc: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eealloc_crate: t\n-   \u22eesync: t\n-   \u22ee\n-   \u22eecrate::sync\n-   \u22eeArc: t v\n-    \"###);\n }\n \n #[test]\n fn extern_crate_rename_2015_edition() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:alloc edition:2015\n-        extern crate alloc as alloc_crate;\n-\n-        mod alloc;\n-        mod sync;\n-\n-        //- /sync.rs\n-        use alloc_crate::Arc;\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:alloc edition:2015\n+extern crate alloc as alloc_crate;\n+mod alloc;\n+mod sync;\n \n-        //- /lib.rs crate:alloc\n-        struct Arc;\n-        \",\n-    );\n+//- /sync.rs\n+use alloc_crate::Arc;\n \n-    assert_snapshot!(map,\n-        @r###\"\n-   \u22eecrate\n-   \u22eealloc_crate: t\n-   \u22eesync: t\n-   \u22ee\n-   \u22eecrate::sync\n-   \u22eeArc: t v\n-    \"###\n+//- /lib.rs crate:alloc\n+struct Arc;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            alloc_crate: t\n+            sync: t\n+\n+            crate::sync\n+            Arc: t v\n+        \"#]],\n     );\n }\n \n #[test]\n fn reexport_across_crates() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:test_crate\n-        use test_crate::Baz;\n-\n-        //- /lib.rs crate:test_crate\n-        pub use foo::Baz;\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:test_crate\n+use test_crate::Baz;\n \n-        mod foo;\n+//- /lib.rs crate:test_crate\n+pub use foo::Baz;\n+mod foo;\n \n-        //- /foo.rs\n-        pub struct Baz;\n-        \",\n+//- /foo.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn values_dont_shadow_extern_crates() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:foo\n-        fn foo() {}\n-        use foo::Bar;\n-\n-        //- /foo/lib.rs crate:foo\n-        pub struct Bar;\n-        \",\n-    );\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+fn foo() {}\n+use foo::Bar;\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eefoo: v\n-    \"###);\n+//- /foo/lib.rs crate:foo\n+pub struct Bar;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            foo: v\n+        \"#]],\n+    );\n }\n \n #[test]\n fn std_prelude_takes_precedence_above_core_prelude() {\n-    let map = def_map(\n+    check(\n         r#\"\n-        //- /main.rs crate:main deps:core,std\n-        use {Foo, Bar};\n-\n-        //- /std.rs crate:std deps:core\n-        #[prelude_import]\n-        pub use self::prelude::*;\n-        mod prelude {\n-            pub struct Foo;\n-            pub use core::prelude::Bar;\n-        }\n+//- /main.rs crate:main deps:core,std\n+use {Foo, Bar};\n+\n+//- /std.rs crate:std deps:core\n+#[prelude_import]\n+pub use self::prelude::*;\n+mod prelude {\n+    pub struct Foo;\n+    pub use core::prelude::Bar;\n+}\n \n-        //- /core.rs crate:core\n-        #[prelude_import]\n-        pub use self::prelude::*;\n-        mod prelude {\n-            pub struct Bar;\n-        }\n-        \"#,\n+//- /core.rs crate:core\n+#[prelude_import]\n+pub use self::prelude::*;\n+mod prelude {\n+    pub struct Bar;\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            Foo: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eeFoo: t v\n-    \"###);\n }\n \n #[test]\n fn cfg_not_test() {\n-    let map = def_map(\n+    check(\n         r#\"\n-        //- /main.rs crate:main deps:std\n-        use {Foo, Bar, Baz};\n-\n-        //- /lib.rs crate:std\n-        #[prelude_import]\n-        pub use self::prelude::*;\n-        mod prelude {\n-            #[cfg(test)]\n-            pub struct Foo;\n-            #[cfg(not(test))]\n-            pub struct Bar;\n-            #[cfg(all(not(any()), feature = \"foo\", feature = \"bar\", opt = \"42\"))]\n-            pub struct Baz;\n-        }\n-        \"#,\n+//- /main.rs crate:main deps:std\n+use {Foo, Bar, Baz};\n+\n+//- /lib.rs crate:std\n+#[prelude_import]\n+pub use self::prelude::*;\n+mod prelude {\n+    #[cfg(test)]\n+    pub struct Foo;\n+    #[cfg(not(test))]\n+    pub struct Bar;\n+    #[cfg(all(not(any()), feature = \"foo\", feature = \"bar\", opt = \"42\"))]\n+    pub struct Baz;\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            Baz: _\n+            Foo: _\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eeBaz: _\n-        \u22eeFoo: _\n-    \"###);\n }\n \n #[test]\n fn cfg_test() {\n-    let map = def_map(\n+    check(\n         r#\"\n-        //- /main.rs crate:main deps:std\n-        use {Foo, Bar, Baz};\n-\n-        //- /lib.rs crate:std cfg:test,feature=foo,feature=bar,opt=42\n-        #[prelude_import]\n-        pub use self::prelude::*;\n-        mod prelude {\n-            #[cfg(test)]\n-            pub struct Foo;\n-            #[cfg(not(test))]\n-            pub struct Bar;\n-            #[cfg(all(not(any()), feature = \"foo\", feature = \"bar\", opt = \"42\"))]\n-            pub struct Baz;\n-        }\n-        \"#,\n+//- /main.rs crate:main deps:std\n+use {Foo, Bar, Baz};\n+\n+//- /lib.rs crate:std cfg:test,feature=foo,feature=bar,opt=42\n+#[prelude_import]\n+pub use self::prelude::*;\n+mod prelude {\n+    #[cfg(test)]\n+    pub struct Foo;\n+    #[cfg(not(test))]\n+    pub struct Bar;\n+    #[cfg(all(not(any()), feature = \"foo\", feature = \"bar\", opt = \"42\"))]\n+    pub struct Baz;\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: _\n+            Baz: t v\n+            Foo: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: _\n-        \u22eeBaz: t v\n-        \u22eeFoo: t v\n-    \"###);\n }\n \n #[test]\n fn infer_multiple_namespace() {\n-    let map = def_map(\n+    check(\n         r#\"\n //- /main.rs\n mod a {\n@@ -571,18 +544,17 @@ mod b {\n     pub const T: () = ();\n }\n \"#,\n+        expect![[r#\"\n+            crate\n+            T: t v\n+            a: t\n+            b: t\n+\n+            crate::b\n+            T: v\n+\n+            crate::a\n+            T: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-    \u22eecrate\n-    \u22eeT: t v\n-    \u22eea: t\n-    \u22eeb: t\n-    \u22ee\n-    \u22eecrate::b\n-    \u22eeT: v\n-    \u22ee\n-    \u22eecrate::a\n-    \u22eeT: t v\n-\"###);\n }"}, {"sha": "2ae836e3c2892085080b9d53758e430933425fb7", "filename": "crates/ra_hir_def/src/nameres/tests/globs.rs", "status": "modified", "additions": 274, "deletions": 304, "changes": 578, "blob_url": "https://github.com/rust-lang/rust/blob/fcdac030335ba58e8267f3414101d4c2edb3797c/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcdac030335ba58e8267f3414101d4c2edb3797c/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs?ref=fcdac030335ba58e8267f3414101d4c2edb3797c", "patch": "@@ -2,367 +2,337 @@ use super::*;\n \n #[test]\n fn glob_1() {\n-    let map = def_map(\n-        r\"\n-        //- /lib.rs\n-        mod foo;\n-        use foo::*;\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-        pub use self::bar::Baz;\n-        pub struct Foo;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeBaz: t v\n-   \u22eeFoo: t v\n-   \u22eebar: t\n-   \u22eefoo: t\n-   \u22ee\n-   \u22eecrate::foo\n-   \u22eeBaz: t v\n-   \u22eeFoo: t v\n-   \u22eebar: t\n-   \u22ee\n-   \u22eecrate::foo::bar\n-   \u22eeBaz: t v\n-    \"###\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+use foo::*;\n+\n+//- /foo/mod.rs\n+pub mod bar;\n+pub use self::bar::Baz;\n+pub struct Foo;\n+\n+//- /foo/bar.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+            Foo: t v\n+            bar: t\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+            Foo: t v\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_2() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        use foo::*;\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-        pub use self::bar::*;\n-        pub struct Foo;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        pub use super::*;\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeBaz: t v\n-   \u22eeFoo: t v\n-   \u22eebar: t\n-   \u22eefoo: t\n-   \u22ee\n-   \u22eecrate::foo\n-   \u22eeBaz: t v\n-   \u22eeFoo: t v\n-   \u22eebar: t\n-   \u22ee\n-   \u22eecrate::foo::bar\n-   \u22eeBaz: t v\n-   \u22eeFoo: t v\n-   \u22eebar: t\n-    \"###\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+use foo::*;\n+\n+//- /foo/mod.rs\n+pub mod bar;\n+pub use self::bar::*;\n+pub struct Foo;\n+\n+//- /foo/bar.rs\n+pub struct Baz;\n+pub use super::*;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+            Foo: t v\n+            bar: t\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+            Foo: t v\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+            Foo: t v\n+            bar: t\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_privacy_1() {\n-    let map = def_map(\n+    check(\n         r\"\n-        //- /lib.rs\n-        mod foo;\n-        use foo::*;\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-        pub use self::bar::*;\n-        struct PrivateStructFoo;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        struct PrivateStructBar;\n-        pub use super::*;\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-        \u22eebar: t\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-        \u22eePrivateStructFoo: t v\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-        \u22eePrivateStructBar: t v\n-        \u22eePrivateStructFoo: t v\n-        \u22eebar: t\n-    \"###\n+//- /lib.rs\n+mod foo;\n+use foo::*;\n+\n+//- /foo/mod.rs\n+pub mod bar;\n+pub use self::bar::*;\n+struct PrivateStructFoo;\n+\n+//- /foo/bar.rs\n+pub struct Baz;\n+struct PrivateStructBar;\n+pub use super::*;\n+\",\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+            bar: t\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+            PrivateStructFoo: t v\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+            PrivateStructBar: t v\n+            PrivateStructFoo: t v\n+            bar: t\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_privacy_2() {\n-    let map = def_map(\n+    check(\n         r\"\n-        //- /lib.rs\n-        mod foo;\n-        use foo::*;\n-        use foo::bar::*;\n-\n-        //- /foo/mod.rs\n-        mod bar;\n-        fn Foo() {};\n-        pub struct Foo {};\n-\n-        //- /foo/bar.rs\n-        pub(super) struct PrivateBaz;\n-        struct PrivateBar;\n-        pub(crate) struct PubCrateStruct;\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeFoo: t\n-        \u22eePubCrateStruct: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeFoo: t v\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eePrivateBar: t v\n-        \u22eePrivateBaz: t v\n-        \u22eePubCrateStruct: t v\n-    \"###\n+//- /lib.rs\n+mod foo;\n+use foo::*;\n+use foo::bar::*;\n+\n+//- /foo/mod.rs\n+mod bar;\n+fn Foo() {};\n+pub struct Foo {};\n+\n+//- /foo/bar.rs\n+pub(super) struct PrivateBaz;\n+struct PrivateBar;\n+pub(crate) struct PubCrateStruct;\n+\",\n+        expect![[r#\"\n+            crate\n+            Foo: t\n+            PubCrateStruct: t v\n+            foo: t\n+\n+            crate::foo\n+            Foo: t v\n+            bar: t\n+\n+            crate::foo::bar\n+            PrivateBar: t v\n+            PrivateBaz: t v\n+            PubCrateStruct: t v\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_across_crates() {\n     mark::check!(glob_across_crates);\n-    let map = def_map(\n-        r\"\n-        //- /main.rs crate:main deps:test_crate\n-        use test_crate::*;\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:test_crate\n+use test_crate::*;\n \n-        //- /lib.rs crate:test_crate\n-        pub struct Baz;\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-    \"###\n+//- /lib.rs crate:test_crate\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_privacy_across_crates() {\n-    let map = def_map(\n-        r\"\n-        //- /main.rs crate:main deps:test_crate\n-        use test_crate::*;\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:test_crate\n+use test_crate::*;\n \n-        //- /lib.rs crate:test_crate\n-        pub struct Baz;\n-        struct Foo;\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-    \"###\n+//- /lib.rs crate:test_crate\n+pub struct Baz;\n+struct Foo;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_enum() {\n     mark::check!(glob_enum);\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        enum Foo {\n-            Bar, Baz\n-        }\n-        use self::Foo::*;\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eeBaz: t v\n-        \u22eeFoo: t\n-    \"###\n+    check(\n+        r#\"\n+enum Foo { Bar, Baz }\n+use self::Foo::*;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            Baz: t v\n+            Foo: t\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_enum_group() {\n     mark::check!(glob_enum_group);\n-    let map = def_map(\n-        r\"\n-        //- /lib.rs\n-        enum Foo {\n-            Bar, Baz\n-        }\n-        use self::Foo::{*};\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eeBaz: t v\n-        \u22eeFoo: t\n-    \"###\n+    check(\n+        r#\"\n+enum Foo { Bar, Baz }\n+use self::Foo::{*};\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            Baz: t v\n+            Foo: t\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_shadowed_def() {\n     mark::check!(import_shadowed);\n-    let map = def_map(\n-        r###\"\n-        //- /lib.rs\n-        mod foo;\n-        mod bar;\n-\n-        use foo::*;\n-        use bar::baz;\n-\n-        use baz::Bar;\n-\n-        //- /foo.rs\n-        pub mod baz {\n-            pub struct Foo;\n-        }\n-\n-        //- /bar.rs\n-        pub mod baz {\n-            pub struct Bar;\n-        }\n-        \"###,\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eebar: t\n-        \u22eebaz: t\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::bar\n-        \u22eebaz: t\n-        \u22ee\n-        \u22eecrate::bar::baz\n-        \u22eeBar: t v\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebaz: t\n-        \u22ee\n-        \u22eecrate::foo::baz\n-        \u22eeFoo: t v\n-    \"###\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+mod bar;\n+use foo::*;\n+use bar::baz;\n+use baz::Bar;\n+\n+//- /foo.rs\n+pub mod baz { pub struct Foo; }\n+\n+//- /bar.rs\n+pub mod baz { pub struct Bar; }\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            bar: t\n+            baz: t\n+            foo: t\n+\n+            crate::bar\n+            baz: t\n+\n+            crate::bar::baz\n+            Bar: t v\n+\n+            crate::foo\n+            baz: t\n+\n+            crate::foo::baz\n+            Foo: t v\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_shadowed_def_reversed() {\n-    let map = def_map(\n-        r###\"\n-        //- /lib.rs\n-        mod foo;\n-        mod bar;\n-\n-        use bar::baz;\n-        use foo::*;\n-\n-        use baz::Bar;\n-\n-        //- /foo.rs\n-        pub mod baz {\n-            pub struct Foo;\n-        }\n-\n-        //- /bar.rs\n-        pub mod baz {\n-            pub struct Bar;\n-        }\n-        \"###,\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eebar: t\n-        \u22eebaz: t\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::bar\n-        \u22eebaz: t\n-        \u22ee\n-        \u22eecrate::bar::baz\n-        \u22eeBar: t v\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebaz: t\n-        \u22ee\n-        \u22eecrate::foo::baz\n-        \u22eeFoo: t v\n-    \"###\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+mod bar;\n+use bar::baz;\n+use foo::*;\n+use baz::Bar;\n+\n+//- /foo.rs\n+pub mod baz { pub struct Foo; }\n+\n+//- /bar.rs\n+pub mod baz { pub struct Bar; }\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            bar: t\n+            baz: t\n+            foo: t\n+\n+            crate::bar\n+            baz: t\n+\n+            crate::bar::baz\n+            Bar: t v\n+\n+            crate::foo\n+            baz: t\n+\n+            crate::foo::baz\n+            Foo: t v\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_shadowed_def_dependencies() {\n-    let map = def_map(\n-        r###\"\n-        //- /lib.rs\n-        mod a { pub mod foo { pub struct X; } }\n-        mod b { pub use super::a::foo; }\n-        mod c { pub mod foo { pub struct Y; } }\n-        mod d {\n-            use super::c::foo;\n-            use super::b::*;\n-            use foo::Y;\n-        }\n-        \"###,\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eea: t\n-        \u22eeb: t\n-        \u22eec: t\n-        \u22eed: t\n-        \u22ee\n-        \u22eecrate::d\n-        \u22eeY: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::c\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::c::foo\n-        \u22eeY: t v\n-        \u22ee\n-        \u22eecrate::b\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::a\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::a::foo\n-        \u22eeX: t v\n-    \"###\n+    check(\n+        r#\"\n+mod a { pub mod foo { pub struct X; } }\n+mod b { pub use super::a::foo; }\n+mod c { pub mod foo { pub struct Y; } }\n+mod d {\n+    use super::c::foo;\n+    use super::b::*;\n+    use foo::Y;\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            a: t\n+            b: t\n+            c: t\n+            d: t\n+\n+            crate::d\n+            Y: t v\n+            foo: t\n+\n+            crate::c\n+            foo: t\n+\n+            crate::c::foo\n+            Y: t v\n+\n+            crate::b\n+            foo: t\n+\n+            crate::a\n+            foo: t\n+\n+            crate::a::foo\n+            X: t v\n+        \"#]],\n     );\n }"}, {"sha": "e0fb8bdef46d74cd29ced45d0b54ff6b15190656", "filename": "crates/ra_hir_def/src/nameres/tests/macros.rs", "status": "modified", "additions": 515, "deletions": 532, "changes": 1047, "blob_url": "https://github.com/rust-lang/rust/blob/fcdac030335ba58e8267f3414101d4c2edb3797c/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcdac030335ba58e8267f3414101d4c2edb3797c/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=fcdac030335ba58e8267f3414101d4c2edb3797c", "patch": "@@ -2,655 +2,635 @@ use super::*;\n \n #[test]\n fn macro_rules_are_globally_visible() {\n-    let map = def_map(\n-        r\"\n-        //- /lib.rs\n-        macro_rules! structs {\n-            ($($i:ident),*) => {\n-                $(struct $i { field: u32 } )*\n-            }\n-        }\n-        structs!(Foo);\n-        mod nested;\n-\n-        //- /nested.rs\n-        structs!(Bar, Baz);\n-        \",\n+    check(\n+        r#\"\n+//- /lib.rs\n+macro_rules! structs {\n+    ($($i:ident),*) => {\n+        $(struct $i { field: u32 } )*\n+    }\n+}\n+structs!(Foo);\n+mod nested;\n+\n+//- /nested.rs\n+structs!(Bar, Baz);\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Foo: t\n+            nested: t\n+\n+            crate::nested\n+            Bar: t\n+            Baz: t\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeFoo: t\n-   \u22eenested: t\n-   \u22ee\n-   \u22eecrate::nested\n-   \u22eeBar: t\n-   \u22eeBaz: t\n-    \"###);\n }\n \n #[test]\n fn macro_rules_can_define_modules() {\n-    let map = def_map(\n-        r\"\n-        //- /lib.rs\n-        macro_rules! m {\n-            ($name:ident) => { mod $name;  }\n-        }\n-        m!(n1);\n-\n-        mod m {\n-            m!(n3)\n-        }\n-\n-        //- /n1.rs\n-        m!(n2)\n-        //- /n1/n2.rs\n-        struct X;\n-        //- /m/n3.rs\n-        struct Y;\n-        \",\n+    check(\n+        r#\"\n+//- /lib.rs\n+macro_rules! m {\n+    ($name:ident) => { mod $name;  }\n+}\n+m!(n1);\n+mod m { m!(n3) }\n+\n+//- /n1.rs\n+m!(n2)\n+//- /n1/n2.rs\n+struct X;\n+//- /m/n3.rs\n+struct Y;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            m: t\n+            n1: t\n+\n+            crate::m\n+            n3: t\n+\n+            crate::m::n3\n+            Y: t v\n+\n+            crate::n1\n+            n2: t\n+\n+            crate::n1::n2\n+            X: t v\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eem: t\n-        \u22een1: t\n-        \u22ee\n-        \u22eecrate::m\n-        \u22een3: t\n-        \u22ee\n-        \u22eecrate::m::n3\n-        \u22eeY: t v\n-        \u22ee\n-        \u22eecrate::n1\n-        \u22een2: t\n-        \u22ee\n-        \u22eecrate::n1::n2\n-        \u22eeX: t v\n-    \"###);\n }\n \n #[test]\n fn macro_rules_from_other_crates_are_visible() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:foo\n-        foo::structs!(Foo, Bar)\n-        mod bar;\n-\n-        //- /bar.rs\n-        use crate::*;\n-\n-        //- /lib.rs crate:foo\n-        #[macro_export]\n-        macro_rules! structs {\n-            ($($i:ident),*) => {\n-                $(struct $i { field: u32 } )*\n-            }\n-        }\n-        \",\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+foo::structs!(Foo, Bar)\n+mod bar;\n+\n+//- /bar.rs\n+use crate::*;\n+\n+//- /lib.rs crate:foo\n+#[macro_export]\n+macro_rules! structs {\n+    ($($i:ident),*) => {\n+        $(struct $i { field: u32 } )*\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t\n+            Foo: t\n+            bar: t\n+\n+            crate::bar\n+            Bar: t\n+            Foo: t\n+            bar: t\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeBar: t\n-   \u22eeFoo: t\n-   \u22eebar: t\n-   \u22ee\n-   \u22eecrate::bar\n-   \u22eeBar: t\n-   \u22eeFoo: t\n-   \u22eebar: t\n-    \"###);\n }\n \n #[test]\n fn macro_rules_export_with_local_inner_macros_are_visible() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:foo\n-        foo::structs!(Foo, Bar)\n-        mod bar;\n-\n-        //- /bar.rs\n-        use crate::*;\n-\n-        //- /lib.rs crate:foo\n-        #[macro_export(local_inner_macros)]\n-        macro_rules! structs {\n-            ($($i:ident),*) => {\n-                $(struct $i { field: u32 } )*\n-            }\n-        }\n-        \",\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+foo::structs!(Foo, Bar)\n+mod bar;\n+\n+//- /bar.rs\n+use crate::*;\n+\n+//- /lib.rs crate:foo\n+#[macro_export(local_inner_macros)]\n+macro_rules! structs {\n+    ($($i:ident),*) => {\n+        $(struct $i { field: u32 } )*\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t\n+            Foo: t\n+            bar: t\n+\n+            crate::bar\n+            Bar: t\n+            Foo: t\n+            bar: t\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeBar: t\n-   \u22eeFoo: t\n-   \u22eebar: t\n-   \u22ee\n-   \u22eecrate::bar\n-   \u22eeBar: t\n-   \u22eeFoo: t\n-   \u22eebar: t\n-    \"###);\n }\n \n #[test]\n fn local_inner_macros_makes_local_macros_usable() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:foo\n-        foo::structs!(Foo, Bar);\n-        mod bar;\n-        //- /bar.rs\n-        use crate::*;\n-        //- /lib.rs crate:foo\n-        #[macro_export(local_inner_macros)]\n-        macro_rules! structs {\n-            ($($i:ident),*) => {\n-                inner!($($i),*);\n-            }\n-        }\n-        #[macro_export]\n-        macro_rules! inner {\n-            ($($i:ident),*) => {\n-                $(struct $i { field: u32 } )*\n-            }\n-        }\n-        \",\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+foo::structs!(Foo, Bar);\n+mod bar;\n+\n+//- /bar.rs\n+use crate::*;\n+\n+//- /lib.rs crate:foo\n+#[macro_export(local_inner_macros)]\n+macro_rules! structs {\n+    ($($i:ident),*) => {\n+        inner!($($i),*);\n+    }\n+}\n+#[macro_export]\n+macro_rules! inner {\n+    ($($i:ident),*) => {\n+        $(struct $i { field: u32 } )*\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t\n+            Foo: t\n+            bar: t\n+\n+            crate::bar\n+            Bar: t\n+            Foo: t\n+            bar: t\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeBar: t\n-   \u22eeFoo: t\n-   \u22eebar: t\n-   \u22ee\n-   \u22eecrate::bar\n-   \u22eeBar: t\n-   \u22eeFoo: t\n-   \u22eebar: t\n-    \"###);\n }\n \n #[test]\n fn unexpanded_macro_should_expand_by_fixedpoint_loop() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:foo\n-        macro_rules! baz {\n-            () => {\n-                use foo::bar;\n-            }\n-        }\n-\n-        foo!();\n-        bar!();\n-        baz!();\n-\n-        //- /lib.rs crate:foo\n-        #[macro_export]\n-        macro_rules! foo {\n-            () => {\n-                struct Foo { field: u32 }\n-            }\n-        }\n-        #[macro_export]\n-        macro_rules! bar {\n-            () => {\n-                use foo::foo;\n-            }\n-        }\n-        \",\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+macro_rules! baz {\n+    () => {\n+        use foo::bar;\n+    }\n+}\n+foo!();\n+bar!();\n+baz!();\n+\n+//- /lib.rs crate:foo\n+#[macro_export]\n+macro_rules! foo {\n+    () => {\n+        struct Foo { field: u32 }\n+    }\n+}\n+#[macro_export]\n+macro_rules! bar {\n+    () => {\n+        use foo::foo;\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Foo: t\n+            bar: m\n+            foo: m\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeFoo: t\n-   \u22eebar: m\n-   \u22eefoo: m\n-    \"###);\n }\n \n #[test]\n fn macro_rules_from_other_crates_are_visible_with_macro_use() {\n     mark::check!(macro_rules_from_other_crates_are_visible_with_macro_use);\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:foo\n-        structs!(Foo);\n-        structs_priv!(Bar);\n-        structs_not_exported!(MacroNotResolved1);\n-        crate::structs!(MacroNotResolved2);\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+structs!(Foo);\n+structs_priv!(Bar);\n+structs_not_exported!(MacroNotResolved1);\n+crate::structs!(MacroNotResolved2);\n \n-        mod bar;\n+mod bar;\n \n-        #[macro_use]\n-        extern crate foo;\n+#[macro_use]\n+extern crate foo;\n \n-        //- /bar.rs\n-        structs!(Baz);\n-        crate::structs!(MacroNotResolved3);\n+//- /bar.rs\n+structs!(Baz);\n+crate::structs!(MacroNotResolved3);\n \n-        //- /lib.rs crate:foo\n-        #[macro_export]\n-        macro_rules! structs {\n-            ($i:ident) => { struct $i; }\n-        }\n+//- /lib.rs crate:foo\n+#[macro_export]\n+macro_rules! structs {\n+    ($i:ident) => { struct $i; }\n+}\n \n-        macro_rules! structs_not_exported {\n-            ($i:ident) => { struct $i; }\n-        }\n+macro_rules! structs_not_exported {\n+    ($i:ident) => { struct $i; }\n+}\n \n-        mod priv_mod {\n-            #[macro_export]\n-            macro_rules! structs_priv {\n-                ($i:ident) => { struct $i; }\n-            }\n-        }\n-        \",\n+mod priv_mod {\n+    #[macro_export]\n+    macro_rules! structs_priv {\n+        ($i:ident) => { struct $i; }\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            Foo: t v\n+            bar: t\n+            foo: t\n+\n+            crate::bar\n+            Baz: t v\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeBar: t v\n-   \u22eeFoo: t v\n-   \u22eebar: t\n-   \u22eefoo: t\n-   \u22ee\n-   \u22eecrate::bar\n-   \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn prelude_is_macro_use() {\n     mark::check!(prelude_is_macro_use);\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:foo\n-        structs!(Foo);\n-        structs_priv!(Bar);\n-        structs_outside!(Out);\n-        crate::structs!(MacroNotResolved2);\n-\n-        mod bar;\n-\n-        //- /bar.rs\n-        structs!(Baz);\n-        crate::structs!(MacroNotResolved3);\n-\n-        //- /lib.rs crate:foo\n-        #[prelude_import]\n-        use self::prelude::*;\n-\n-        mod prelude {\n-            #[macro_export]\n-            macro_rules! structs {\n-                ($i:ident) => { struct $i; }\n-            }\n-\n-            mod priv_mod {\n-                #[macro_export]\n-                macro_rules! structs_priv {\n-                    ($i:ident) => { struct $i; }\n-                }\n-            }\n-        }\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+structs!(Foo);\n+structs_priv!(Bar);\n+structs_outside!(Out);\n+crate::structs!(MacroNotResolved2);\n \n+mod bar;\n+\n+//- /bar.rs\n+structs!(Baz);\n+crate::structs!(MacroNotResolved3);\n+\n+//- /lib.rs crate:foo\n+#[prelude_import]\n+use self::prelude::*;\n+\n+mod prelude {\n+    #[macro_export]\n+    macro_rules! structs {\n+        ($i:ident) => { struct $i; }\n+    }\n+\n+    mod priv_mod {\n         #[macro_export]\n-        macro_rules! structs_outside {\n+        macro_rules! structs_priv {\n             ($i:ident) => { struct $i; }\n         }\n-        \",\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! structs_outside {\n+    ($i:ident) => { struct $i; }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            Foo: t v\n+            Out: t v\n+            bar: t\n+\n+            crate::bar\n+            Baz: t v\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeBar: t v\n-   \u22eeFoo: t v\n-   \u22eeOut: t v\n-   \u22eebar: t\n-   \u22ee\n-   \u22eecrate::bar\n-   \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn prelude_cycle() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        #[prelude_import]\n-        use self::prelude::*;\n+    check(\n+        r#\"\n+#[prelude_import]\n+use self::prelude::*;\n \n-        declare_mod!();\n+declare_mod!();\n \n-        mod prelude {\n-            macro_rules! declare_mod {\n-                () => (mod foo {})\n-            }\n-        }\n-        \",\n+mod prelude {\n+    macro_rules! declare_mod {\n+        () => (mod foo {})\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            prelude: t\n+\n+            crate::prelude\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeprelude: t\n-        \u22ee\n-        \u22eecrate::prelude\n-    \"###);\n }\n \n #[test]\n fn plain_macros_are_legacy_textual_scoped() {\n-    let map = def_map(\n+    check(\n         r#\"\n-        //- /main.rs\n-        mod m1;\n-        bar!(NotFoundNotMacroUse);\n+//- /main.rs\n+mod m1;\n+bar!(NotFoundNotMacroUse);\n \n-        mod m2 {\n-            foo!(NotFoundBeforeInside2);\n-        }\n+mod m2 { foo!(NotFoundBeforeInside2); }\n \n-        macro_rules! foo {\n-            ($x:ident) => { struct $x; }\n-        }\n-        foo!(Ok);\n-\n-        mod m3;\n-        foo!(OkShadowStop);\n-        bar!(NotFoundMacroUseStop);\n-\n-        #[macro_use]\n-        mod m5 {\n-            #[macro_use]\n-            mod m6 {\n-                macro_rules! foo {\n-                    ($x:ident) => { fn $x() {} }\n-                }\n-            }\n-        }\n-        foo!(ok_double_macro_use_shadow);\n-\n-        baz!(NotFoundBefore);\n-        #[macro_use]\n-        mod m7 {\n-            macro_rules! baz {\n-                ($x:ident) => { struct $x; }\n-            }\n-        }\n-        baz!(OkAfter);\n+macro_rules! foo {\n+    ($x:ident) => { struct $x; }\n+}\n+foo!(Ok);\n \n-        //- /m1.rs\n-        foo!(NotFoundBeforeInside1);\n-        macro_rules! bar {\n-            ($x:ident) => { struct $x; }\n-        }\n+mod m3;\n+foo!(OkShadowStop);\n+bar!(NotFoundMacroUseStop);\n \n-        //- /m3/mod.rs\n-        foo!(OkAfterInside);\n+#[macro_use]\n+mod m5 {\n+    #[macro_use]\n+    mod m6 {\n         macro_rules! foo {\n             ($x:ident) => { fn $x() {} }\n         }\n-        foo!(ok_shadow);\n+    }\n+}\n+foo!(ok_double_macro_use_shadow);\n+\n+baz!(NotFoundBefore);\n+#[macro_use]\n+mod m7 {\n+    macro_rules! baz {\n+        ($x:ident) => { struct $x; }\n+    }\n+}\n+baz!(OkAfter);\n \n-        #[macro_use]\n-        mod m4;\n-        bar!(OkMacroUse);\n+//- /m1.rs\n+foo!(NotFoundBeforeInside1);\n+macro_rules! bar {\n+    ($x:ident) => { struct $x; }\n+}\n \n-        //- /m3/m4.rs\n-        foo!(ok_shadow_deep);\n-        macro_rules! bar {\n-            ($x:ident) => { struct $x; }\n-        }\n-        \"#,\n+//- /m3/mod.rs\n+foo!(OkAfterInside);\n+macro_rules! foo {\n+    ($x:ident) => { fn $x() {} }\n+}\n+foo!(ok_shadow);\n+\n+#[macro_use]\n+mod m4;\n+bar!(OkMacroUse);\n+\n+//- /m3/m4.rs\n+foo!(ok_shadow_deep);\n+macro_rules! bar {\n+    ($x:ident) => { struct $x; }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Ok: t v\n+            OkAfter: t v\n+            OkShadowStop: t v\n+            m1: t\n+            m2: t\n+            m3: t\n+            m5: t\n+            m7: t\n+            ok_double_macro_use_shadow: v\n+\n+            crate::m7\n+\n+            crate::m1\n+\n+            crate::m5\n+            m6: t\n+\n+            crate::m5::m6\n+\n+            crate::m2\n+\n+            crate::m3\n+            OkAfterInside: t v\n+            OkMacroUse: t v\n+            m4: t\n+            ok_shadow: v\n+\n+            crate::m3::m4\n+            ok_shadow_deep: v\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeOk: t v\n-   \u22eeOkAfter: t v\n-   \u22eeOkShadowStop: t v\n-   \u22eem1: t\n-   \u22eem2: t\n-   \u22eem3: t\n-   \u22eem5: t\n-   \u22eem7: t\n-   \u22eeok_double_macro_use_shadow: v\n-   \u22ee\n-   \u22eecrate::m7\n-   \u22ee\n-   \u22eecrate::m1\n-   \u22ee\n-   \u22eecrate::m5\n-   \u22eem6: t\n-   \u22ee\n-   \u22eecrate::m5::m6\n-   \u22ee\n-   \u22eecrate::m2\n-   \u22ee\n-   \u22eecrate::m3\n-   \u22eeOkAfterInside: t v\n-   \u22eeOkMacroUse: t v\n-   \u22eem4: t\n-   \u22eeok_shadow: v\n-   \u22ee\n-   \u22eecrate::m3::m4\n-   \u22eeok_shadow_deep: v\n-    \"###);\n }\n \n #[test]\n fn type_value_macro_live_in_different_scopes() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs\n-        #[macro_export]\n-        macro_rules! foo {\n-            ($x:ident) => { type $x = (); }\n-        }\n-\n-        foo!(foo);\n-        use foo as bar;\n+    check(\n+        r#\"\n+#[macro_export]\n+macro_rules! foo {\n+    ($x:ident) => { type $x = (); }\n+}\n \n-        use self::foo as baz;\n-        fn baz() {}\n-        \",\n+foo!(foo);\n+use foo as bar;\n+\n+use self::foo as baz;\n+fn baz() {}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            bar: t m\n+            baz: t v m\n+            foo: t m\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eebar: t m\n-        \u22eebaz: t v m\n-        \u22eefoo: t m\n-    \"###);\n }\n \n #[test]\n fn macro_use_can_be_aliased() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:foo\n-        #[macro_use]\n-        extern crate foo;\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+#[macro_use]\n+extern crate foo;\n \n-        foo!(Direct);\n-        bar!(Alias);\n+foo!(Direct);\n+bar!(Alias);\n \n-        //- /lib.rs crate:foo\n-        use crate::foo as bar;\n+//- /lib.rs crate:foo\n+use crate::foo as bar;\n \n-        mod m {\n-            #[macro_export]\n-            macro_rules! foo {\n-                ($x:ident) => { struct $x; }\n-            }\n-        }\n-        \",\n+mod m {\n+    #[macro_export]\n+    macro_rules! foo {\n+        ($x:ident) => { struct $x; }\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Alias: t v\n+            Direct: t v\n+            foo: t\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeAlias: t v\n-        \u22eeDirect: t v\n-        \u22eefoo: t\n-    \"###);\n }\n \n #[test]\n fn path_qualified_macros() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs\n-        macro_rules! foo {\n-            ($x:ident) => { struct $x; }\n-        }\n+    check(\n+        r#\"\n+macro_rules! foo {\n+    ($x:ident) => { struct $x; }\n+}\n \n-        crate::foo!(NotResolved);\n-\n-        crate::bar!(OkCrate);\n-        bar!(OkPlain);\n-        alias1!(NotHere);\n-        m::alias1!(OkAliasPlain);\n-        m::alias2!(OkAliasSuper);\n-        m::alias3!(OkAliasCrate);\n-        not_found!(NotFound);\n-\n-        mod m {\n-            #[macro_export]\n-            macro_rules! bar {\n-                ($x:ident) => { struct $x; }\n-            }\n-\n-            pub use bar as alias1;\n-            pub use super::bar as alias2;\n-            pub use crate::bar as alias3;\n-            pub use self::bar as not_found;\n-        }\n-        \",\n+crate::foo!(NotResolved);\n+\n+crate::bar!(OkCrate);\n+bar!(OkPlain);\n+alias1!(NotHere);\n+m::alias1!(OkAliasPlain);\n+m::alias2!(OkAliasSuper);\n+m::alias3!(OkAliasCrate);\n+not_found!(NotFound);\n+\n+mod m {\n+    #[macro_export]\n+    macro_rules! bar {\n+        ($x:ident) => { struct $x; }\n+    }\n+    pub use bar as alias1;\n+    pub use super::bar as alias2;\n+    pub use crate::bar as alias3;\n+    pub use self::bar as not_found;\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            OkAliasCrate: t v\n+            OkAliasPlain: t v\n+            OkAliasSuper: t v\n+            OkCrate: t v\n+            OkPlain: t v\n+            bar: m\n+            m: t\n+\n+            crate::m\n+            alias1: m\n+            alias2: m\n+            alias3: m\n+            not_found: _\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeOkAliasCrate: t v\n-        \u22eeOkAliasPlain: t v\n-        \u22eeOkAliasSuper: t v\n-        \u22eeOkCrate: t v\n-        \u22eeOkPlain: t v\n-        \u22eebar: m\n-        \u22eem: t\n-        \u22ee\n-        \u22eecrate::m\n-        \u22eealias1: m\n-        \u22eealias2: m\n-        \u22eealias3: m\n-        \u22eenot_found: _\n-    \"###);\n }\n \n #[test]\n fn macro_dollar_crate_is_correct_in_item() {\n     mark::check!(macro_dollar_crate_self);\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:foo\n-        #[macro_use]\n-        extern crate foo;\n-\n-        #[macro_use]\n-        mod m {\n-            macro_rules! current {\n-                () => {\n-                    use $crate::Foo as FooSelf;\n-                }\n-            }\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+#[macro_use]\n+extern crate foo;\n+\n+#[macro_use]\n+mod m {\n+    macro_rules! current {\n+        () => {\n+            use $crate::Foo as FooSelf;\n         }\n+    }\n+}\n \n-        struct Foo;\n+struct Foo;\n \n-        current!();\n-        not_current1!();\n-        foo::not_current2!();\n-\n-        //- /lib.rs crate:foo\n-        mod m {\n-            #[macro_export]\n-            macro_rules! not_current1 {\n-                () => {\n-                    use $crate::Bar;\n-                }\n-            }\n-        }\n+current!();\n+not_current1!();\n+foo::not_current2!();\n \n-        #[macro_export]\n-        macro_rules! not_current2 {\n-            () => {\n-                use $crate::Baz;\n-            }\n+//- /lib.rs crate:foo\n+mod m {\n+    #[macro_export]\n+    macro_rules! not_current1 {\n+        () => {\n+            use $crate::Bar;\n         }\n+    }\n+}\n \n-        struct Bar;\n-        struct Baz;\n-        \",\n+#[macro_export]\n+macro_rules! not_current2 {\n+    () => {\n+        use $crate::Baz;\n+    }\n+}\n+\n+struct Bar;\n+struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            Baz: t v\n+            Foo: t v\n+            FooSelf: t v\n+            foo: t\n+            m: t\n+\n+            crate::m\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eeBaz: t v\n-        \u22eeFoo: t v\n-        \u22eeFooSelf: t v\n-        \u22eefoo: t\n-        \u22eem: t\n-        \u22ee\n-        \u22eecrate::m\n-    \"###);\n }\n \n #[test]\n fn macro_dollar_crate_is_correct_in_indirect_deps() {\n     mark::check!(macro_dollar_crate_other);\n     // From std\n-    let map = def_map(\n+    check(\n         r#\"\n-        //- /main.rs crate:main deps:std\n-        foo!();\n+//- /main.rs crate:main deps:std\n+foo!();\n \n-        //- /std.rs crate:std deps:core\n-        #[prelude_import]\n-        use self::prelude::*;\n+//- /std.rs crate:std deps:core\n+#[prelude_import]\n+use self::prelude::*;\n \n-        pub use core::foo;\n+pub use core::foo;\n \n-        mod prelude {}\n+mod prelude {}\n \n-        #[macro_use]\n-        mod std_macros;\n+#[macro_use]\n+mod std_macros;\n \n-        //- /core.rs crate:core\n-        #[macro_export]\n-        macro_rules! foo {\n-            () => {\n-                use $crate::bar;\n-            }\n-        }\n-\n-        pub struct bar;\n-        \"#,\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eebar: t v\n-    \"###);\n+//- /core.rs crate:core\n+#[macro_export]\n+macro_rules! foo {\n+    () => {\n+        use $crate::bar;\n+    }\n }\n \n-#[test]\n-fn expand_derive() {\n-    let map = compute_crate_def_map(\n-        \"\n-        //- /main.rs\n-        #[derive(Clone)]\n-        struct Foo;\n-        \",\n+pub struct bar;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            bar: t v\n+        \"#]],\n     );\n-    assert_eq!(map.modules[map.root].scope.impls().len(), 1);\n }\n \n #[test]\n-fn expand_multiple_derive() {\n+fn expand_derive() {\n     let map = compute_crate_def_map(\n         \"\n         //- /main.rs\n@@ -664,8 +644,8 @@ fn expand_multiple_derive() {\n #[test]\n fn macro_expansion_overflow() {\n     mark::check!(macro_expansion_overflow);\n-    compute_crate_def_map(\n-        \"\n+    check(\n+        r#\"\n macro_rules! a {\n     ($e:expr; $($t:tt)*) => {\n         b!($($t)*);\n@@ -681,6 +661,9 @@ macro_rules! b {\n }\n \n b! { static = #[] (); }\n-\",\n+\"#,\n+        expect![[r#\"\n+            crate\n+        \"#]],\n     );\n }"}, {"sha": "3da16fbe30fa2f161ba4ba163872c2f43039bb20", "filename": "crates/ra_hir_def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 608, "deletions": 649, "changes": 1257, "blob_url": "https://github.com/rust-lang/rust/blob/fcdac030335ba58e8267f3414101d4c2edb3797c/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcdac030335ba58e8267f3414101d4c2edb3797c/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=fcdac030335ba58e8267f3414101d4c2edb3797c", "patch": "@@ -3,710 +3,672 @@ use super::*;\n #[test]\n fn name_res_works_for_broken_modules() {\n     mark::check!(name_res_works_for_broken_modules);\n-    let map = def_map(\n+    check(\n         r\"\n-        //- /lib.rs\n-        mod foo // no `;`, no body\n-\n-        use self::foo::Baz;\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-\n-        pub use self::bar::Baz;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        \",\n+//- /lib.rs\n+mod foo // no `;`, no body\n+use self::foo::Baz;\n+\n+//- /foo/mod.rs\n+pub mod bar;\n+pub use self::bar::Baz;\n+\n+//- /foo/bar.rs\n+pub struct Baz;\n+\",\n+        expect![[r#\"\n+            crate\n+            Baz: _\n+            foo: t\n+\n+            crate::foo\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-crate\n-Baz: _\n-foo: t\n-\n-crate::foo\n-    \"###);\n }\n \n #[test]\n fn nested_module_resolution() {\n-    let map = def_map(\n-        r\"\n-        //- /lib.rs\n-        mod n1;\n-\n-        //- /n1.rs\n-        mod n2;\n-\n-        //- /n1/n2.rs\n-        struct X;\n-        \",\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod n1;\n+\n+//- /n1.rs\n+mod n2;\n+\n+//- /n1/n2.rs\n+struct X;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            n1: t\n+\n+            crate::n1\n+            n2: t\n+\n+            crate::n1::n2\n+            X: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22een1: t\n-        \u22ee\n-        \u22eecrate::n1\n-        \u22een2: t\n-        \u22ee\n-        \u22eecrate::n1::n2\n-        \u22eeX: t v\n-    \"###);\n }\n \n #[test]\n fn nested_module_resolution_2() {\n-    let map = def_map(\n-        r\"\n-        //- /lib.rs\n-        mod prelude;\n-        mod iter;\n-\n-        //- /prelude.rs\n-        pub use crate::iter::Iterator;\n-\n-        //- /iter.rs\n-        pub use self::traits::Iterator;\n-        mod traits;\n-\n-        //- /iter/traits.rs\n-        pub use self::iterator::Iterator;\n-        mod iterator;\n-\n-        //- /iter/traits/iterator.rs\n-        pub trait Iterator;\n-        \",\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod prelude;\n+mod iter;\n+\n+//- /prelude.rs\n+pub use crate::iter::Iterator;\n+\n+//- /iter.rs\n+pub use self::traits::Iterator;\n+mod traits;\n+\n+//- /iter/traits.rs\n+pub use self::iterator::Iterator;\n+mod iterator;\n+\n+//- /iter/traits/iterator.rs\n+pub trait Iterator;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            iter: t\n+            prelude: t\n+\n+            crate::iter\n+            Iterator: t\n+            traits: t\n+\n+            crate::iter::traits\n+            Iterator: t\n+            iterator: t\n+\n+            crate::iter::traits::iterator\n+            Iterator: t\n+\n+            crate::prelude\n+            Iterator: t\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeiter: t\n-        \u22eeprelude: t\n-        \u22ee\n-        \u22eecrate::iter\n-        \u22eeIterator: t\n-        \u22eetraits: t\n-        \u22ee\n-        \u22eecrate::iter::traits\n-        \u22eeIterator: t\n-        \u22eeiterator: t\n-        \u22ee\n-        \u22eecrate::iter::traits::iterator\n-        \u22eeIterator: t\n-        \u22ee\n-        \u22eecrate::prelude\n-        \u22eeIterator: t\n-    \"###);\n }\n \n #[test]\n fn module_resolution_works_for_non_standard_filenames() {\n-    let map = def_map(\n-        \"\n-        //- /my_library.rs crate:my_library\n-        mod foo;\n-        use self::foo::Bar;\n-\n-        //- /foo/mod.rs\n-        pub struct Bar;\n-        \",\n+    check(\n+        r#\"\n+//- /my_library.rs crate:my_library\n+mod foo;\n+use self::foo::Bar;\n+\n+//- /foo/mod.rs\n+pub struct Bar;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            foo: t\n+\n+            crate::foo\n+            Bar: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBar: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_works_for_raw_modules() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod r#async;\n-        use self::r#async::Bar;\n-\n-        //- /async.rs\n-        pub struct Bar;\n-        \",\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod r#async;\n+use self::r#async::Bar;\n+\n+//- /async.rs\n+pub struct Bar;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            async: t\n+\n+            crate::async\n+            Bar: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eeasync: t\n-        \u22ee\n-        \u22eecrate::async\n-        \u22eeBar: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_decl_path() {\n-    let map = def_map(\n-        r###\"\n-        //- /lib.rs\n-        #[path = \"bar/baz/foo.rs\"]\n-        mod foo;\n-        use self::foo::Bar;\n-\n-        //- /bar/baz/foo.rs\n-        pub struct Bar;\n-        \"###,\n+    check(\n+        r#\"\n+//- /lib.rs\n+#[path = \"bar/baz/foo.rs\"]\n+mod foo;\n+use self::foo::Bar;\n+\n+//- /bar/baz/foo.rs\n+pub struct Bar;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            foo: t\n+\n+            crate::foo\n+            Bar: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBar: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_module_with_path_in_mod_rs() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        mod foo;\n-\n-        //- /foo/mod.rs\n-        #[path = \"baz.rs\"]\n-        pub mod bar;\n-\n-        use self::bar::Baz;\n-\n-        //- /foo/baz.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+mod foo;\n+\n+//- /foo/mod.rs\n+#[path = \"baz.rs\"]\n+pub mod bar;\n+use self::bar::Baz;\n+\n+//- /foo/baz.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_module_with_path_non_crate_root() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        mod foo;\n-\n-        //- /foo.rs\n-        #[path = \"baz.rs\"]\n-        pub mod bar;\n-\n-        use self::bar::Baz;\n-\n-        //- /baz.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+mod foo;\n+\n+//- /foo.rs\n+#[path = \"baz.rs\"]\n+pub mod bar;\n+use self::bar::Baz;\n+\n+//- /baz.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_module_decl_path_super() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"bar/baz/module.rs\"]\n-        mod foo;\n-        pub struct Baz;\n-\n-        //- /bar/baz/module.rs\n-        use super::Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"bar/baz/module.rs\"]\n+mod foo;\n+pub struct Baz;\n+\n+//- /bar/baz/module.rs\n+use super::Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_explicit_path_mod_rs() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"module/mod.rs\"]\n-        mod foo;\n-\n-        //- /module/mod.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"module/mod.rs\"]\n+mod foo;\n+\n+//- /module/mod.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_relative_path() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        mod foo;\n-\n-        //- /foo.rs\n-        #[path = \"./sub.rs\"]\n-        pub mod foo_bar;\n-\n-        //- /sub.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+mod foo;\n+\n+//- /foo.rs\n+#[path = \"./sub.rs\"]\n+pub mod foo_bar;\n+\n+//- /sub.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            foo_bar: t\n+\n+            crate::foo::foo_bar\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eefoo_bar: t\n-        \u22ee\n-        \u22eecrate::foo::foo_bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_relative_path_2() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        mod foo;\n-\n-        //- /foo/mod.rs\n-        #[path=\"../sub.rs\"]\n-        pub mod foo_bar;\n-\n-        //- /sub.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+mod foo;\n+\n+//- /foo/mod.rs\n+#[path=\"../sub.rs\"]\n+pub mod foo_bar;\n+\n+//- /sub.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            foo_bar: t\n+\n+            crate::foo::foo_bar\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eefoo_bar: t\n-        \u22ee\n-        \u22eecrate::foo::foo_bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_relative_path_outside_root() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-\n-        #[path=\"../../../../../outside.rs\"]\n-        mod foo;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path=\"../../../../../outside.rs\"]\n+mod foo;\n+\"#,\n+        expect![[r#\"\n+            crate\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-    \"###);\n }\n \n #[test]\n fn module_resolution_explicit_path_mod_rs_2() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"module/bar/mod.rs\"]\n-        mod foo;\n-\n-        //- /module/bar/mod.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"module/bar/mod.rs\"]\n+mod foo;\n+\n+//- /module/bar/mod.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_explicit_path_mod_rs_with_win_separator() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"module\\bar\\mod.rs\"]\n-        mod foo;\n-\n-        //- /module/bar/mod.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"module\\bar\\mod.rs\"]\n+mod foo;\n+\n+//- /module/bar/mod.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module_with_path_attribute() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"models\"]\n-        mod foo {\n-            mod bar;\n-        }\n-\n-        //- /models/bar.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"models\"]\n+mod foo { mod bar; }\n+\n+//- /models/bar.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        mod foo {\n-            mod bar;\n-        }\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+mod foo { mod bar; }\n+\n+//- /foo/bar.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module_2_with_path_attribute() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"models/db\"]\n-        mod foo {\n-            mod bar;\n-        }\n-\n-        //- /models/db/bar.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"models/db\"]\n+mod foo { mod bar; }\n+\n+//- /models/db/bar.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module_3() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"models/db\"]\n-        mod foo {\n-            #[path = \"users.rs\"]\n-            mod bar;\n-        }\n-\n-        //- /models/db/users.rs\n-        pub struct Baz;\n-        \"###,\n-    );\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"models/db\"]\n+mod foo {\n+    #[path = \"users.rs\"]\n+    mod bar;\n+}\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n+//- /models/db/users.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n+    );\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module_empty_path() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"\"]\n-        mod foo {\n-            #[path = \"users.rs\"]\n-            mod bar;\n-        }\n-\n-        //- /users.rs\n-        pub struct Baz;\n-        \"###,\n-    );\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"\"]\n+mod foo {\n+    #[path = \"users.rs\"]\n+    mod bar;\n+}\n+\n+//- /users.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n+            crate::foo\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n+    );\n }\n \n #[test]\n fn module_resolution_decl_empty_path() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"\"] // Should try to read `/` (a directory)\n-        mod foo;\n-\n-        //- /foo.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"\"] // Should try to read `/` (a directory)\n+mod foo;\n+\n+//- /foo.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-    \"###);\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module_relative_path() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"./models\"]\n-        mod foo {\n-            mod bar;\n-        }\n-\n-        //- /models/bar.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"./models\"]\n+mod foo { mod bar; }\n+\n+//- /models/bar.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module_in_crate_root() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        mod foo {\n-            #[path = \"baz.rs\"]\n-            mod bar;\n-        }\n-        use self::foo::bar::Baz;\n-\n-        //- /foo/baz.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+mod foo {\n+    #[path = \"baz.rs\"]\n+    mod bar;\n+}\n+use self::foo::bar::Baz;\n+\n+//- /foo/baz.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+            foo: t\n+\n+            crate::foo\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module_in_mod_rs() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        mod foo;\n+    check(\n+        r#\"\n+//- /main.rs\n+mod foo;\n+\n+//- /foo/mod.rs\n+mod bar {\n+    #[path = \"qwe.rs\"]\n+    pub mod baz;\n+}\n+use self::bar::baz::Baz;\n \n-        //- /foo/mod.rs\n-        mod bar {\n-            #[path = \"qwe.rs\"]\n-            pub mod baz;\n-        }\n-        use self::bar::baz::Baz;\n+//- /foo/bar/qwe.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n \n-        //- /foo/bar/qwe.rs\n-        pub struct Baz;\n-        \"###,\n-    );\n+            crate::foo\n+            Baz: t v\n+            bar: t\n+\n+            crate::foo::bar\n+            baz: t\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eebaz: t\n-        \u22ee\n-        \u22eecrate::foo::bar::baz\n-        \u22eeBaz: t v\n-    \"###);\n+            crate::foo::bar::baz\n+            Baz: t v\n+        \"#]],\n+    );\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module_in_non_crate_root() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        mod foo;\n+    check(\n+        r#\"\n+//- /main.rs\n+mod foo;\n+\n+//- /foo.rs\n+mod bar {\n+    #[path = \"qwe.rs\"]\n+    pub mod baz;\n+}\n+use self::bar::baz::Baz;\n \n-        //- /foo.rs\n-        mod bar {\n-            #[path = \"qwe.rs\"]\n-            pub mod baz;\n-        }\n-        use self::bar::baz::Baz;\n-\n-        //- /foo/bar/qwe.rs\n-        pub struct Baz;\n-        \"###,\n-    );\n+//- /foo/bar/qwe.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+            bar: t\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eebaz: t\n-        \u22ee\n-        \u22eecrate::foo::bar::baz\n-        \u22eeBaz: t v\n-    \"###);\n+            crate::foo::bar\n+            baz: t\n+\n+            crate::foo::bar::baz\n+            Baz: t v\n+        \"#]],\n+    );\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module_in_non_crate_root_2() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        mod foo;\n+    check(\n+        r#\"\n+//- /main.rs\n+mod foo;\n+\n+//- /foo.rs\n+#[path = \"bar\"]\n+mod bar {\n+    pub mod baz;\n+}\n+use self::bar::baz::Baz;\n \n-        //- /foo.rs\n-        #[path = \"bar\"]\n-        mod bar {\n-            pub mod baz;\n-        }\n-        use self::bar::baz::Baz;\n-\n-        //- /bar/baz.rs\n-        pub struct Baz;\n-        \"###,\n-    );\n+//- /bar/baz.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eebaz: t\n-        \u22ee\n-        \u22eecrate::foo::bar::baz\n-        \u22eeBaz: t v\n-    \"###);\n+            crate::foo\n+            Baz: t v\n+            bar: t\n+\n+            crate::foo::bar\n+            baz: t\n+\n+            crate::foo::bar::baz\n+            Baz: t v\n+        \"#]],\n+    );\n }\n \n #[test]\n@@ -749,91 +711,88 @@ fn unresolved_module_diagnostics() {\n \n #[test]\n fn module_resolution_decl_inside_module_in_non_crate_root_2() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path=\"module/m2.rs\"]\n-        mod module;\n-\n-        //- /module/m2.rs\n-        pub mod submod;\n-\n-        //- /module/submod.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path=\"module/m2.rs\"]\n+mod module;\n+\n+//- /module/m2.rs\n+pub mod submod;\n+\n+//- /module/submod.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            module: t\n+\n+            crate::module\n+            submod: t\n+\n+            crate::module::submod\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eemodule: t\n-        \u22ee\n-        \u22eecrate::module\n-        \u22eesubmod: t\n-        \u22ee\n-        \u22eecrate::module::submod\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn nested_out_of_line_module() {\n-    let map = def_map(\n-        r###\"\n-        //- /lib.rs\n-        mod a {\n-            mod b {\n-                mod c;\n-            }\n-        }\n-\n-        //- /a/b/c.rs\n-        struct X;\n-        \"###,\n-    );\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod a {\n+    mod b {\n+        mod c;\n+    }\n+}\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eea: t\n-        \u22ee\n-        \u22eecrate::a\n-        \u22eeb: t\n-        \u22ee\n-        \u22eecrate::a::b\n-        \u22eec: t\n-        \u22ee\n-        \u22eecrate::a::b::c\n-        \u22eeX: t v\n-    \"###);\n+//- /a/b/c.rs\n+struct X;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            a: t\n+\n+            crate::a\n+            b: t\n+\n+            crate::a::b\n+            c: t\n+\n+            crate::a::b::c\n+            X: t v\n+        \"#]],\n+    );\n }\n \n #[test]\n fn nested_out_of_line_module_with_path() {\n-    let map = def_map(\n-        r###\"\n-        //- /lib.rs\n-        mod a {\n-            #[path = \"d/e\"]\n-            mod b {\n-                mod c;\n-            }\n-        }\n-\n-        //- /a/d/e/c.rs\n-        struct X;\n-        \"###,\n-    );\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod a {\n+    #[path = \"d/e\"]\n+    mod b {\n+        mod c;\n+    }\n+}\n+\n+//- /a/d/e/c.rs\n+struct X;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            a: t\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eea: t\n-        \u22ee\n-        \u22eecrate::a\n-        \u22eeb: t\n-        \u22ee\n-        \u22eecrate::a::b\n-        \u22eec: t\n-        \u22ee\n-        \u22eecrate::a::b::c\n-        \u22eeX: t v\n-    \"###);\n+            crate::a\n+            b: t\n+\n+            crate::a::b\n+            c: t\n+\n+            crate::a::b::c\n+            X: t v\n+        \"#]],\n+    );\n }"}, {"sha": "215e8952d90299e3c977ef96a51d6e8b96143ec7", "filename": "crates/ra_hir_def/src/nameres/tests/primitives.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fcdac030335ba58e8267f3414101d4c2edb3797c/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fprimitives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcdac030335ba58e8267f3414101d4c2edb3797c/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fprimitives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fprimitives.rs?ref=fcdac030335ba58e8267f3414101d4c2edb3797c", "patch": "@@ -2,23 +2,22 @@ use super::*;\n \n #[test]\n fn primitive_reexport() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        use foo::int;\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+use foo::int;\n \n-        //- /foo.rs\n-        pub use i32 as int;\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eefoo: t\n-   \u22eeint: t\n-   \u22ee\n-   \u22eecrate::foo\n-   \u22eeint: t\n-    \"###\n+//- /foo.rs\n+pub use i32 as int;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+            int: t\n+\n+            crate::foo\n+            int: t\n+        \"#]],\n     );\n }"}]}