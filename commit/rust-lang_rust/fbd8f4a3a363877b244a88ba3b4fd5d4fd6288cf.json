{"sha": "fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiZDhmNGEzYTM2Mzg3N2IyNDRhODhiYTNiNGZkNWQ0ZmQ2Mjg4Y2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-15T15:36:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-15T15:36:50Z"}, "message": "auto merge of #13954 : aturon/rust/issue-11650, r=alexcrichton\n\n## Process API\r\n\r\nThe existing APIs for spawning processes took strings for the command\r\nand arguments, but the underlying system may not impose utf8 encoding,\r\nso this is overly limiting.\r\n\r\nThe assumption we actually want to make is just that the command and\r\narguments are viewable as [u8] slices with no interior NULLs, i.e., as\r\nCStrings. The ToCStr trait is a handy bound for types that meet this\r\nrequirement (such as &str and Path).\r\n\r\nHowever, since the commands and arguments are often a mixture of\r\nstrings and paths, it would be inconvenient to take a slice with a\r\nsingle T: ToCStr bound. So this patch revamps the process creation API\r\nto instead use a builder-style interface, called `Command`, allowing\r\narguments to be added one at a time with differing ToCStr\r\nimplementations for each.\r\n\r\nThe initial cut of the builder API has some drawbacks that can be\r\naddressed once issue #13851 (libstd as a facade) is closed. These are\r\ndetailed as FIXMEs.\r\n\r\n## Dynamic library API\r\n\r\n`std::unstable::dynamic_library::open_external` currently takes a\r\n`Path`, but because `Paths` produce normalized strings, this can\r\nchange the semantics of lookups in a given environment. This patch\r\ngeneralizes the function to take a `ToCStr`-bounded type, which\r\nincludes both `Path`s and `str`s.\r\n\r\n## ToCStr API\r\n\r\nAdds ToCStr impl for &Path and ~str. This is a stopgap until DST (#12938) lands.\r\n\r\nUntil DST lands, we cannot decompose &str into & and str, so we cannot\r\nusefully take ToCStr arguments by reference (without forcing an\r\nadditional & around &str). So we are instead temporarily adding an\r\ninstance for &Path and ~str, so that we can take ToCStr as owned. When\r\nDST lands, the &Path instance should be removed, the string instances\r\nshould be revisted, and arguments bound by ToCStr should be passed by\r\nreference.\r\n\r\nFIXMEs have been added accordingly. \r\n\r\n## Tickets closed\r\n\r\nCloses #11650.\r\nCloses #7928.", "tree": {"sha": "3ee1b9063d2c7204230c59142286991ee0471e18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ee1b9063d2c7204230c59142286991ee0471e18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "html_url": "https://github.com/rust-lang/rust/commit/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a2b3d14711771a02b1247ce664c67de1b68f2e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a2b3d14711771a02b1247ce664c67de1b68f2e6", "html_url": "https://github.com/rust-lang/rust/commit/6a2b3d14711771a02b1247ce664c67de1b68f2e6"}, {"sha": "e71202aecf47db99225101f842474490121d8a69", "url": "https://api.github.com/repos/rust-lang/rust/commits/e71202aecf47db99225101f842474490121d8a69", "html_url": "https://github.com/rust-lang/rust/commit/e71202aecf47db99225101f842474490121d8a69"}], "stats": {"total": 1528, "additions": 792, "deletions": 736}, "files": [{"sha": "27a31ea909fea35107a925ef508e828139ad8b35", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -10,7 +10,7 @@\n \n use std::os;\n use std::str;\n-use std::io::process::{ProcessExit, Process, ProcessConfig, ProcessOutput};\n+use std::io::process::{ProcessExit, Command, Process, ProcessOutput};\n \n #[cfg(target_os = \"win32\")]\n fn target_env(lib_path: &str, prog: &str) -> Vec<(~str, ~str)> {\n@@ -68,14 +68,7 @@ pub fn run(lib_path: &str,\n            input: Option<~str>) -> Option<Result> {\n \n     let env = env.clone().append(target_env(lib_path, prog).as_slice());\n-    let opt_process = Process::configure(ProcessConfig {\n-        program: prog,\n-        args: args,\n-        env: Some(env.as_slice()),\n-        .. ProcessConfig::new()\n-    });\n-\n-    match opt_process {\n+    match Command::new(prog).args(args).env(env.as_slice()).spawn() {\n         Ok(mut process) => {\n             for input in input.iter() {\n                 process.stdin.get_mut_ref().write(input.as_bytes()).unwrap();\n@@ -100,14 +93,7 @@ pub fn run_background(lib_path: &str,\n            input: Option<~str>) -> Option<Process> {\n \n     let env = env.clone().append(target_env(lib_path, prog).as_slice());\n-    let opt_process = Process::configure(ProcessConfig {\n-        program: prog,\n-        args: args,\n-        env: Some(env.as_slice()),\n-        .. ProcessConfig::new()\n-    });\n-\n-    match opt_process {\n+    match Command::new(prog).args(args).env(env.as_slice()).spawn() {\n         Ok(mut process) => {\n             for input in input.iter() {\n                 process.stdin.get_mut_ref().write(input.as_bytes()).unwrap();"}, {"sha": "fbbfcf94eb11de3c01ec2dcaa5e7eb7505061543", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -420,7 +420,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n }\n \n fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path) {\n-    use std::io::process::{Process, ProcessConfig, ProcessOutput};\n+    use std::io::process::{Command, ProcessOutput};\n \n     if config.lldb_python_dir.is_none() {\n         fatal(\"Can't run LLDB test because LLDB's python path is not set.\".to_owned());\n@@ -483,25 +483,13 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n \n     fn run_lldb(config: &Config, test_executable: &Path, debugger_script: &Path) -> ProcRes {\n         // Prepare the lldb_batchmode which executes the debugger script\n-        let lldb_batchmode_script = \"./src/etc/lldb_batchmode.py\".to_owned();\n-        let test_executable_str = test_executable.as_str().unwrap().to_owned();\n-        let debugger_script_str = debugger_script.as_str().unwrap().to_owned();\n-        let commandline = format!(\"python {} {} {}\",\n-                                  lldb_batchmode_script.as_slice(),\n-                                  test_executable_str.as_slice(),\n-                                  debugger_script_str.as_slice());\n-\n-        let args = &[lldb_batchmode_script, test_executable_str, debugger_script_str];\n-        let env = &[(\"PYTHONPATH\".to_owned(), config.lldb_python_dir.clone().unwrap())];\n-\n-        let opt_process = Process::configure(ProcessConfig {\n-            program: \"python\",\n-            args: args,\n-            env: Some(env),\n-            .. ProcessConfig::new()\n-        });\n-\n-        let (status, out, err) = match opt_process {\n+        let mut cmd = Command::new(\"python\");\n+        cmd.arg(\"./src/etc/lldb_batchmode.py\")\n+           .arg(test_executable)\n+           .arg(debugger_script)\n+           .env([(\"PYTHONPATH\", config.lldb_python_dir.clone().unwrap().as_slice())]);\n+\n+        let (status, out, err) = match cmd.spawn() {\n             Ok(process) => {\n                 let ProcessOutput { status, output, error } =\n                     process.wait_with_output().unwrap();\n@@ -520,7 +508,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n             status: status,\n             stdout: out,\n             stderr: err,\n-            cmdline: commandline\n+            cmdline: format!(\"{}\", cmd)\n         };\n     }\n }"}, {"sha": "0c103bc4695fd7bbb1146e69b1f5bac49c2bb761", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -27,13 +27,12 @@ use std::c_str::CString;\n use std::io;\n use std::io::IoError;\n use std::io::net::ip::SocketAddr;\n-use std::io::process::ProcessConfig;\n use std::io::signal::Signum;\n use std::os;\n use std::rt::rtio;\n use std::rt::rtio::{RtioTcpStream, RtioTcpListener, RtioUdpSocket};\n use std::rt::rtio::{RtioUnixListener, RtioPipe, RtioFileStream, RtioProcess};\n-use std::rt::rtio::{RtioSignal, RtioTTY, CloseBehavior, RtioTimer};\n+use std::rt::rtio::{RtioSignal, RtioTTY, CloseBehavior, RtioTimer, ProcessConfig};\n use ai = std::io::net::addrinfo;\n \n // Local re-exports\n@@ -258,10 +257,10 @@ impl rtio::IoFactory for IoFactory {\n     fn timer_init(&mut self) -> IoResult<Box<RtioTimer:Send>> {\n         timer::Timer::new().map(|t| box t as Box<RtioTimer:Send>)\n     }\n-    fn spawn(&mut self, config: ProcessConfig)\n+    fn spawn(&mut self, cfg: ProcessConfig)\n             -> IoResult<(Box<RtioProcess:Send>,\n                          Vec<Option<Box<RtioPipe:Send>>>)> {\n-        process::Process::spawn(config).map(|(p, io)| {\n+        process::Process::spawn(cfg).map(|(p, io)| {\n             (box p as Box<RtioProcess:Send>,\n              io.move_iter().map(|p| p.map(|p| {\n                  box p as Box<RtioPipe:Send>"}, {"sha": "0eebd3380e626c21953780729dd82e9e11ed3aa1", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 90, "deletions": 95, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -15,9 +15,10 @@ use std::mem;\n use std::os;\n use std::ptr;\n use std::rt::rtio;\n+use std::rt::rtio::ProcessConfig;\n+use std::c_str::CString;\n use p = std::io::process;\n \n-\n use super::IoResult;\n use super::file;\n use super::util;\n@@ -65,27 +66,11 @@ impl Process {\n     /// Creates a new process using native process-spawning abilities provided\n     /// by the OS. Operations on this process will be blocking instead of using\n     /// the runtime for sleeping just this current task.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * prog - the program to run\n-    /// * args - the arguments to pass to the program, not including the program\n-    ///          itself\n-    /// * env - an optional environment to specify for the child process. If\n-    ///         this value is `None`, then the child will inherit the parent's\n-    ///         environment\n-    /// * cwd - an optionally specified current working directory of the child,\n-    ///         defaulting to the parent's current working directory\n-    /// * stdin, stdout, stderr - These optionally specified file descriptors\n-    ///     dictate where the stdin/out/err of the child process will go. If\n-    ///     these are `None`, then this module will bind the input/output to an\n-    ///     os pipe instead. This process takes ownership of these file\n-    ///     descriptors, closing them upon destruction of the process.\n-    pub fn spawn(config: p::ProcessConfig)\n+    pub fn spawn(cfg: ProcessConfig)\n         -> Result<(Process, Vec<Option<file::FileDesc>>), io::IoError>\n     {\n         // right now we only handle stdin/stdout/stderr.\n-        if config.extra_io.len() > 0 {\n+        if cfg.extra_io.len() > 0 {\n             return Err(super::unimpl());\n         }\n \n@@ -109,14 +94,11 @@ impl Process {\n         }\n \n         let mut ret_io = Vec::new();\n-        let (in_pipe, in_fd) = get_io(config.stdin, &mut ret_io);\n-        let (out_pipe, out_fd) = get_io(config.stdout, &mut ret_io);\n-        let (err_pipe, err_fd) = get_io(config.stderr, &mut ret_io);\n+        let (in_pipe, in_fd) = get_io(cfg.stdin, &mut ret_io);\n+        let (out_pipe, out_fd) = get_io(cfg.stdout, &mut ret_io);\n+        let (err_pipe, err_fd) = get_io(cfg.stderr, &mut ret_io);\n \n-        let env = config.env.map(|a| a.to_owned());\n-        let cwd = config.cwd.map(|a| Path::new(a));\n-        let res = spawn_process_os(config, env, cwd.as_ref(), in_fd, out_fd,\n-                                   err_fd);\n+        let res = spawn_process_os(cfg, in_fd, out_fd, err_fd);\n \n         unsafe {\n             for pipe in in_pipe.iter() { let _ = libc::close(pipe.input); }\n@@ -262,11 +244,8 @@ struct SpawnProcessResult {\n }\n \n #[cfg(windows)]\n-fn spawn_process_os(config: p::ProcessConfig,\n-                    env: Option<~[(~str, ~str)]>,\n-                    dir: Option<&Path>,\n-                    in_fd: c_int, out_fd: c_int,\n-                    err_fd: c_int) -> IoResult<SpawnProcessResult> {\n+fn spawn_process_os(cfg: ProcessConfig, in_fd: c_int, out_fd: c_int, err_fd: c_int)\n+                 -> IoResult<SpawnProcessResult> {\n     use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n     use libc::consts::os::extra::{\n         TRUE, FALSE,\n@@ -284,7 +263,7 @@ fn spawn_process_os(config: p::ProcessConfig,\n \n     use std::mem;\n \n-    if config.gid.is_some() || config.uid.is_some() {\n+    if cfg.gid.is_some() || cfg.uid.is_some() {\n         return Err(io::IoError {\n             kind: io::OtherIoError,\n             desc: \"unsupported gid/uid requested on windows\",\n@@ -293,7 +272,6 @@ fn spawn_process_os(config: p::ProcessConfig,\n     }\n \n     unsafe {\n-\n         let mut si = zeroed_startupinfo();\n         si.cb = mem::size_of::<STARTUPINFO>() as DWORD;\n         si.dwFlags = STARTF_USESTDHANDLES;\n@@ -333,23 +311,26 @@ fn spawn_process_os(config: p::ProcessConfig,\n             }\n         }\n \n-        let cmd = make_command_line(config.program, config.args);\n+        let cmd_str = make_command_line(cfg.program, cfg.args);\n         let mut pi = zeroed_process_information();\n         let mut create_err = None;\n \n         // stolen from the libuv code.\n         let mut flags = libc::CREATE_UNICODE_ENVIRONMENT;\n-        if config.detach {\n+        if cfg.detach {\n             flags |= libc::DETACHED_PROCESS | libc::CREATE_NEW_PROCESS_GROUP;\n         }\n \n-        with_envp(env, |envp| {\n-            with_dirp(dir, |dirp| {\n-                os::win32::as_mut_utf16_p(cmd, |cmdp| {\n-                    let created = CreateProcessW(ptr::null(), cmdp,\n-                                                 ptr::mut_null(), ptr::mut_null(), TRUE,\n-                                                 flags, envp, dirp, &mut si,\n-                                                 &mut pi);\n+        with_envp(cfg.env, |envp| {\n+            with_dirp(cfg.cwd, |dirp| {\n+                os::win32::as_mut_utf16_p(cmd_str, |cmdp| {\n+                    let created = CreateProcessW(ptr::null(),\n+                                                 cmdp,\n+                                                 ptr::mut_null(),\n+                                                 ptr::mut_null(),\n+                                                 TRUE,\n+                                                 flags, envp, dirp,\n+                                                 &mut si, &mut pi);\n                     if created == FALSE {\n                         create_err = Some(super::last_error());\n                     }\n@@ -415,12 +396,14 @@ fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMA\n }\n \n #[cfg(windows)]\n-fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n+fn make_command_line(prog: &CString, args: &[CString]) -> ~str {\n     let mut cmd = StrBuf::new();\n-    append_arg(&mut cmd, prog);\n+    append_arg(&mut cmd, prog.as_str()\n+                             .expect(\"expected program name to be utf-8 encoded\"));\n     for arg in args.iter() {\n         cmd.push_char(' ');\n-        append_arg(&mut cmd, *arg);\n+        append_arg(&mut cmd, arg.as_str()\n+                                .expect(\"expected argument to be utf-8 encoded\"));\n     }\n     return cmd.into_owned();\n \n@@ -468,11 +451,9 @@ fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n }\n \n #[cfg(unix)]\n-fn spawn_process_os(config: p::ProcessConfig,\n-                    env: Option<~[(~str, ~str)]>,\n-                    dir: Option<&Path>,\n-                    in_fd: c_int, out_fd: c_int,\n-                    err_fd: c_int) -> IoResult<SpawnProcessResult> {\n+fn spawn_process_os(cfg: ProcessConfig, in_fd: c_int, out_fd: c_int, err_fd: c_int)\n+                -> IoResult<SpawnProcessResult>\n+{\n     use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n     use libc::funcs::bsd44::getdtablesize;\n     use io::c;\n@@ -500,11 +481,10 @@ fn spawn_process_os(config: p::ProcessConfig,\n         assert_eq!(ret, 0);\n     }\n \n-    let dirp = dir.map(|p| p.to_c_str());\n-    let dirp = dirp.as_ref().map(|c| c.with_ref(|p| p)).unwrap_or(ptr::null());\n+    let dirp = cfg.cwd.map(|c| c.with_ref(|p| p)).unwrap_or(ptr::null());\n \n-    with_envp(env, proc(envp) {\n-        with_argv(config.program, config.args, proc(argv) unsafe {\n+    with_envp(cfg.env, proc(envp) {\n+        with_argv(cfg.program, cfg.args, proc(argv) unsafe {\n             let pipe = os::pipe();\n             let mut input = file::FileDesc::new(pipe.input, true);\n             let mut output = file::FileDesc::new(pipe.out, true);\n@@ -605,15 +585,15 @@ fn spawn_process_os(config: p::ProcessConfig,\n                 }\n             }\n \n-            match config.gid {\n+            match cfg.gid {\n                 Some(u) => {\n                     if libc::setgid(u as libc::gid_t) != 0 {\n                         fail(&mut output);\n                     }\n                 }\n                 None => {}\n             }\n-            match config.uid {\n+            match cfg.uid {\n                 Some(u) => {\n                     // When dropping privileges from root, the `setgroups` call will\n                     // remove any extraneous groups. If we don't call this, then\n@@ -633,7 +613,7 @@ fn spawn_process_os(config: p::ProcessConfig,\n                 }\n                 None => {}\n             }\n-            if config.detach {\n+            if cfg.detach {\n                 // Don't check the error of setsid because it fails if we're the\n                 // process leader already. We just forked so it shouldn't return\n                 // error, but ignore it anyway.\n@@ -652,47 +632,47 @@ fn spawn_process_os(config: p::ProcessConfig,\n }\n \n #[cfg(unix)]\n-fn with_argv<T>(prog: &str, args: &[~str], cb: proc(**libc::c_char) -> T) -> T {\n-    // We can't directly convert `str`s into `*char`s, as someone needs to hold\n-    // a reference to the intermediary byte buffers. So first build an array to\n-    // hold all the ~[u8] byte strings.\n-    let mut tmps = Vec::with_capacity(args.len() + 1);\n-\n-    tmps.push(prog.to_c_str());\n-\n-    for arg in args.iter() {\n-        tmps.push(arg.to_c_str());\n-    }\n-\n-    // Next, convert each of the byte strings into a pointer. This is\n-    // technically unsafe as the caller could leak these pointers out of our\n-    // scope.\n-    let mut ptrs: Vec<_> = tmps.iter().map(|tmp| tmp.with_ref(|buf| buf)).collect();\n-\n-    // Finally, make sure we add a null pointer.\n+fn with_argv<T>(prog: &CString, args: &[CString], cb: proc(**libc::c_char) -> T) -> T {\n+    let mut ptrs: Vec<*libc::c_char> = Vec::with_capacity(args.len()+1);\n+\n+    // Convert the CStrings into an array of pointers. Note: the\n+    // lifetime of the various CStrings involved is guaranteed to be\n+    // larger than the lifetime of our invocation of cb, but this is\n+    // technically unsafe as the callback could leak these pointers\n+    // out of our scope.\n+    ptrs.push(prog.with_ref(|buf| buf));\n+    ptrs.extend(args.iter().map(|tmp| tmp.with_ref(|buf| buf)));\n+\n+    // Add a terminating null pointer (required by libc).\n     ptrs.push(ptr::null());\n \n     cb(ptrs.as_ptr())\n }\n \n #[cfg(unix)]\n-fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: proc(*c_void) -> T) -> T {\n+fn with_envp<T>(env: Option<&[(CString, CString)]>, cb: proc(*c_void) -> T) -> T {\n     // On posixy systems we can pass a char** for envp, which is a\n-    // null-terminated array of \"k=v\\n\" strings. Like `with_argv`, we have to\n-    // have a temporary buffer to hold the intermediary `~[u8]` byte strings.\n+    // null-terminated array of \"k=v\\0\" strings. Since we must create\n+    // these strings locally, yet expose a raw pointer to them, we\n+    // create a temporary vector to own the CStrings that outlives the\n+    // call to cb.\n     match env {\n         Some(env) => {\n             let mut tmps = Vec::with_capacity(env.len());\n \n             for pair in env.iter() {\n-                let kv = format!(\"{}={}\", *pair.ref0(), *pair.ref1());\n-                tmps.push(kv.to_c_str());\n+                let mut kv = Vec::new();\n+                kv.push_all(pair.ref0().as_bytes_no_nul());\n+                kv.push('=' as u8);\n+                kv.push_all(pair.ref1().as_bytes()); // includes terminal \\0\n+                tmps.push(kv);\n             }\n \n-            // Once again, this is unsafe.\n-            let mut ptrs: Vec<*libc::c_char> = tmps.iter()\n-                                                   .map(|tmp| tmp.with_ref(|buf| buf))\n-                                                   .collect();\n+            // As with `with_argv`, this is unsafe, since cb could leak the pointers.\n+            let mut ptrs: Vec<*libc::c_char> =\n+                tmps.iter()\n+                    .map(|tmp| tmp.as_ptr() as *libc::c_char)\n+                    .collect();\n             ptrs.push(ptr::null());\n \n             cb(ptrs.as_ptr() as *c_void)\n@@ -702,7 +682,7 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: proc(*c_void) -> T) -> T {\n }\n \n #[cfg(windows)]\n-fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*mut c_void| -> T) -> T {\n+fn with_envp<T>(env: Option<&[(CString, CString)]>, cb: |*mut c_void| -> T) -> T {\n     // On win32 we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n@@ -711,7 +691,9 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*mut c_void| -> T) -> T {\n             let mut blk = Vec::new();\n \n             for pair in env.iter() {\n-                let kv = format!(\"{}={}\", *pair.ref0(), *pair.ref1());\n+                let kv = format!(\"{}={}\",\n+                                 pair.ref0().as_str().unwrap(),\n+                                 pair.ref1().as_str().unwrap());\n                 blk.push_all(kv.to_utf16().as_slice());\n                 blk.push(0);\n             }\n@@ -725,11 +707,12 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*mut c_void| -> T) -> T {\n }\n \n #[cfg(windows)]\n-fn with_dirp<T>(d: Option<&Path>, cb: |*u16| -> T) -> T {\n+fn with_dirp<T>(d: Option<&CString>, cb: |*u16| -> T) -> T {\n     match d {\n-      Some(dir) => match dir.as_str() {\n-          Some(dir_str) => os::win32::as_utf16_p(dir_str, cb),\n-          None => cb(ptr::null())\n+      Some(dir) => {\n+          let dir_str = dir.as_str()\n+                           .expect(\"expected workingdirectory to be utf-8 encoded\");\n+          os::win32::as_utf16_p(dir_str, cb)\n       },\n       None => cb(ptr::null())\n     }\n@@ -1106,25 +1089,37 @@ mod tests {\n \n     #[test] #[cfg(windows)]\n     fn test_make_command_line() {\n+        use std::str;\n+        use std::c_str::CString;\n         use super::make_command_line;\n+\n+        fn test_wrapper(prog: &str, args: &[&str]) -> ~str {\n+            make_command_line(&prog.to_c_str(),\n+                              args.iter()\n+                                  .map(|a| a.to_c_str())\n+                                  .collect::<Vec<CString>>()\n+                                  .as_slice())\n+        }\n+\n         assert_eq!(\n-            make_command_line(\"prog\", [\"aaa\".to_owned(), \"bbb\".to_owned(), \"ccc\".to_owned()]),\n+            test_wrapper(\"prog\", [\"aaa\", \"bbb\", \"ccc\"]),\n             \"prog aaa bbb ccc\".to_owned()\n         );\n+\n         assert_eq!(\n-            make_command_line(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", [\"aaa\".to_owned()]),\n+            test_wrapper(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", [\"aaa\"]),\n             \"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\".to_owned()\n         );\n         assert_eq!(\n-            make_command_line(\"C:\\\\Program Files\\\\test\", [\"aa\\\"bb\".to_owned()]),\n+            test_wrapper(\"C:\\\\Program Files\\\\test\", [\"aa\\\"bb\"]),\n             \"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\".to_owned()\n         );\n         assert_eq!(\n-            make_command_line(\"echo\", [\"a b c\".to_owned()]),\n+            test_wrapper(\"echo\", [\"a b c\"]),\n             \"echo \\\"a b c\\\"\".to_owned()\n         );\n         assert_eq!(\n-            make_command_line(\"\\u03c0\\u042f\\u97f3\\u00e6\\u221e\", []),\n+            test_wrapper(\"\\u03c0\\u042f\\u97f3\\u00e6\\u221e\", []),\n             \"\\u03c0\\u042f\\u97f3\\u00e6\\u221e\".to_owned()\n         );\n     }"}, {"sha": "571959d812a45c5210d2b39c2d153c757cf1db39", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -16,7 +16,7 @@ use metadata::filesearch;\n use lib::llvm::{ArchiveRef, llvm};\n \n use libc;\n-use std::io::process::{ProcessConfig, Process, ProcessOutput};\n+use std::io::process::{Command, ProcessOutput};\n use std::io::{fs, TempDir};\n use std::io;\n use std::mem;\n@@ -39,26 +39,24 @@ pub struct ArchiveRO {\n fn run_ar(sess: &Session, args: &str, cwd: Option<&Path>,\n           paths: &[&Path]) -> ProcessOutput {\n     let ar = get_ar_prog(sess);\n+    let mut cmd = Command::new(ar.as_slice());\n+\n+    cmd.arg(args).args(paths);\n+    debug!(\"{}\", cmd);\n \n-    let mut args = vec!(args.to_owned());\n-    let paths = paths.iter().map(|p| p.as_str().unwrap().to_owned());\n-    args.extend(paths);\n-    debug!(\"{} {}\", ar, args.connect(\" \"));\n     match cwd {\n-        Some(p) => { debug!(\"inside {}\", p.display()); }\n+        Some(p) => {\n+            cmd.cwd(p);\n+            debug!(\"inside {}\", p.display());\n+        }\n         None => {}\n     }\n-    match Process::configure(ProcessConfig {\n-        program: ar.as_slice(),\n-        args: args.as_slice(),\n-        cwd: cwd.map(|a| &*a),\n-        .. ProcessConfig::new()\n-    }) {\n+\n+    match cmd.spawn() {\n         Ok(prog) => {\n             let o = prog.wait_with_output().unwrap();\n             if !o.status.success() {\n-                sess.err(format!(\"{} {} failed with: {}\", ar, args.connect(\" \"),\n-                                 o.status));\n+                sess.err(format!(\"{} failed with: {}\", cmd, o.status));\n                 sess.note(format!(\"stdout ---\\n{}\",\n                                   str::from_utf8(o.output.as_slice()).unwrap()));\n                 sess.note(format!(\"stderr ---\\n{}\",\n@@ -68,7 +66,7 @@ fn run_ar(sess: &Session, args: &str, cwd: Option<&Path>,\n             o\n         },\n         Err(e) => {\n-            sess.err(format!(\"could not exec `{}`: {}\", ar, e));\n+            sess.err(format!(\"could not exec `{}`: {}\", ar.as_slice(), e));\n             sess.abort_if_errors();\n             fail!(\"rustc::back::archive::run_ar() should not reach this point\");\n         }"}, {"sha": "4d70ecb888fdb6ec34136550b4ed33e6c90804ab", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 96, "deletions": 113, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -29,7 +29,7 @@ use util::sha2::{Digest, Sha256};\n \n use std::c_str::{ToCStr, CString};\n use std::char;\n-use std::io::{fs, TempDir, Process};\n+use std::io::{fs, TempDir, Command};\n use std::io;\n use std::ptr;\n use std::str;\n@@ -103,7 +103,7 @@ pub mod write {\n     use syntax::abi;\n \n     use std::c_str::ToCStr;\n-    use std::io::Process;\n+    use std::io::{Command};\n     use libc::{c_uint, c_int};\n     use std::str;\n \n@@ -348,30 +348,26 @@ pub mod write {\n     }\n \n     pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n-        let cc = super::get_cc_prog(sess);\n-        let assembly = outputs.temp_path(OutputTypeAssembly);\n-        let object = outputs.path(OutputTypeObject);\n-\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let args = [\n-            \"-c\".to_owned(),\n-            \"-o\".to_owned(), object.as_str().unwrap().to_owned(),\n-            assembly.as_str().unwrap().to_owned()];\n-\n-        debug!(\"{} '{}'\", cc, args.connect(\"' '\"));\n-        match Process::output(cc.as_slice(), args) {\n+        let pname = super::get_cc_prog(sess);\n+        let mut cmd = Command::new(pname.as_slice());\n+\n+        cmd.arg(\"-c\").arg(\"-o\").arg(outputs.path(OutputTypeObject))\n+                               .arg(outputs.temp_path(OutputTypeAssembly));\n+        debug!(\"{}\", &cmd);\n+\n+        match cmd.output() {\n             Ok(prog) => {\n                 if !prog.status.success() {\n-                    sess.err(format!(\"linking with `{}` failed: {}\", cc, prog.status));\n-                    sess.note(format!(\"{} arguments: '{}'\", cc, args.connect(\"' '\")));\n+                    sess.err(format!(\"linking with `{}` failed: {}\", pname, prog.status));\n+                    sess.note(format!(\"{}\", &cmd));\n                     let mut note = prog.error.clone();\n                     note.push_all(prog.output.as_slice());\n                     sess.note(str::from_utf8(note.as_slice()).unwrap().to_owned());\n                     sess.abort_if_errors();\n                 }\n             },\n             Err(e) => {\n-                sess.err(format!(\"could not exec the linker `{}`: {}\", cc, e));\n+                sess.err(format!(\"could not exec the linker `{}`: {}\", pname, e));\n                 sess.abort_if_errors();\n             }\n         }\n@@ -527,6 +523,7 @@ pub mod write {\n  *    system linkers understand.\n  */\n \n+// FIXME (#9639): This needs to handle non-utf8 `out_filestem` values\n pub fn find_crate_id(attrs: &[ast::Attribute], out_filestem: &str) -> CrateId {\n     match attr::find_crateid(attrs) {\n         None => from_str(out_filestem).unwrap_or_else(|| {\n@@ -547,6 +544,7 @@ pub fn crate_id_hash(crate_id: &CrateId) -> StrBuf {\n     truncated_hash_result(&mut s).as_slice().slice_to(8).to_strbuf()\n }\n \n+// FIXME (#9639): This needs to handle non-utf8 `out_filestem` values\n pub fn build_link_meta(krate: &ast::Crate, out_filestem: &str) -> LinkMeta {\n     let r = LinkMeta {\n         crateid: find_crate_id(krate.attrs.as_slice(), out_filestem),\n@@ -1026,39 +1024,38 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n                  obj_filename: &Path, out_filename: &Path) {\n     let tmpdir = TempDir::new(\"rustc\").expect(\"needs a temp dir\");\n+\n     // The invocations of cc share some flags across platforms\n-    let cc_prog = get_cc_prog(sess);\n-    let mut cc_args = sess.targ_cfg.target_strs.cc_args.clone();\n-    cc_args.push_all_move(link_args(sess, dylib, tmpdir.path(), trans,\n-                                    obj_filename, out_filename));\n+    let pname = get_cc_prog(sess);\n+    let mut cmd = Command::new(pname.as_slice());\n+\n+    cmd.args(sess.targ_cfg.target_strs.cc_args.as_slice());\n+    link_args(&mut cmd, sess, dylib, tmpdir.path(),\n+              trans, obj_filename, out_filename);\n+\n     if (sess.opts.debugging_opts & config::PRINT_LINK_ARGS) != 0 {\n-        println!(\"{} link args: '{}'\", cc_prog, cc_args.connect(\"' '\"));\n+        println!(\"{}\", &cmd);\n     }\n \n     // May have not found libraries in the right formats.\n     sess.abort_if_errors();\n \n     // Invoke the system linker\n-    debug!(\"{} {}\", cc_prog, cc_args.connect(\" \"));\n-    let prog = time(sess.time_passes(), \"running linker\", (), |()|\n-                    Process::output(cc_prog.as_slice(),\n-                                    cc_args.iter()\n-                                           .map(|x| (*x).to_owned())\n-                                           .collect::<Vec<_>>()\n-                                           .as_slice()));\n+    debug!(\"{}\", &cmd);\n+    let prog = time(sess.time_passes(), \"running linker\", (), |()| cmd.output());\n     match prog {\n         Ok(prog) => {\n             if !prog.status.success() {\n-                sess.err(format!(\"linking with `{}` failed: {}\", cc_prog, prog.status));\n-                sess.note(format!(\"{} arguments: '{}'\", cc_prog, cc_args.connect(\"' '\")));\n+                sess.err(format!(\"linking with `{}` failed: {}\", pname, prog.status));\n+                sess.note(format!(\"{}\", &cmd));\n                 let mut output = prog.error.clone();\n                 output.push_all(prog.output.as_slice());\n                 sess.note(str::from_utf8(output.as_slice()).unwrap().to_owned());\n                 sess.abort_if_errors();\n             }\n         },\n         Err(e) => {\n-            sess.err(format!(\"could not exec the linker `{}`: {}\", cc_prog, e));\n+            sess.err(format!(\"could not exec the linker `{}`: {}\", pname, e));\n             sess.abort_if_errors();\n         }\n     }\n@@ -1067,9 +1064,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n     // On OSX, debuggers need this utility to get run to do some munging of\n     // the symbols\n     if sess.targ_cfg.os == abi::OsMacos && (sess.opts.debuginfo != NoDebugInfo) {\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        match Process::status(\"dsymutil\",\n-                                  [out_filename.as_str().unwrap().to_owned()]) {\n+        match Command::new(\"dsymutil\").arg(out_filename).status() {\n             Ok(..) => {}\n             Err(e) => {\n                 sess.err(format!(\"failed to run dsymutil: {}\", e));\n@@ -1079,25 +1074,20 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n     }\n }\n \n-fn link_args(sess: &Session,\n+fn link_args(cmd: &mut Command,\n+             sess: &Session,\n              dylib: bool,\n              tmpdir: &Path,\n              trans: &CrateTranslation,\n              obj_filename: &Path,\n-             out_filename: &Path) -> Vec<StrBuf> {\n+             out_filename: &Path) {\n \n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n     let lib_path = sess.target_filesearch().get_lib_path();\n-    let stage = (\"-L\".to_owned() + lib_path.as_str().unwrap()).to_strbuf();\n+    cmd.arg(\"-L\").arg(lib_path);\n \n-    let mut args = vec!(stage);\n-\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    args.push_all([\n-        \"-o\".to_strbuf(), out_filename.as_str().unwrap().to_strbuf(),\n-        obj_filename.as_str().unwrap().to_strbuf()]);\n+    cmd.arg(\"-o\").arg(out_filename).arg(obj_filename);\n \n     // Stack growth requires statically linking a __morestack function. Note\n     // that this is listed *before* all other libraries, even though it may be\n@@ -1114,14 +1104,13 @@ fn link_args(sess: &Session,\n     // line, but inserting this farther to the left makes the\n     // \"rust_stack_exhausted\" symbol an outstanding undefined symbol, which\n     // flags libstd as a required library (or whatever provides the symbol).\n-    args.push(\"-lmorestack\".to_strbuf());\n+    cmd.arg(\"-lmorestack\");\n \n     // When linking a dynamic library, we put the metadata into a section of the\n     // executable. This metadata is in a separate object file from the main\n     // object file, so we link that in here.\n     if dylib {\n-        let metadata = obj_filename.with_extension(\"metadata.o\");\n-        args.push(metadata.as_str().unwrap().to_strbuf());\n+        cmd.arg(obj_filename.with_extension(\"metadata.o\"));\n     }\n \n     // We want to prevent the compiler from accidentally leaking in any system\n@@ -1132,28 +1121,28 @@ fn link_args(sess: &Session,\n     //\n     // FIXME(#11937) we should invoke the system linker directly\n     if sess.targ_cfg.os != abi::OsWin32 {\n-        args.push(\"-nodefaultlibs\".to_strbuf());\n+        cmd.arg(\"-nodefaultlibs\");\n     }\n \n     // If we're building a dylib, we don't use --gc-sections because LLVM has\n     // already done the best it can do, and we also don't want to eliminate the\n     // metadata. If we're building an executable, however, --gc-sections drops\n     // the size of hello world from 1.8MB to 597K, a 67% reduction.\n     if !dylib && sess.targ_cfg.os != abi::OsMacos {\n-        args.push(\"-Wl,--gc-sections\".to_strbuf());\n+        cmd.arg(\"-Wl,--gc-sections\");\n     }\n \n     if sess.targ_cfg.os == abi::OsLinux {\n         // GNU-style linkers will use this to omit linking to libraries which\n         // don't actually fulfill any relocations, but only for libraries which\n         // follow this flag. Thus, use it before specifying libraries to link to.\n-        args.push(\"-Wl,--as-needed\".to_strbuf());\n+        cmd.arg(\"-Wl,--as-needed\");\n \n         // GNU-style linkers support optimization with -O. GNU ld doesn't need a\n         // numeric argument, but other linkers do.\n         if sess.opts.optimize == config::Default ||\n            sess.opts.optimize == config::Aggressive {\n-            args.push(\"-Wl,-O1\".to_strbuf());\n+            cmd.arg(\"-Wl,-O1\");\n         }\n     } else if sess.targ_cfg.os == abi::OsMacos {\n         // The dead_strip option to the linker specifies that functions and data\n@@ -1166,14 +1155,14 @@ fn link_args(sess: &Session,\n         // won't get much benefit from dylibs because LLVM will have already\n         // stripped away as much as it could. This has not been seen to impact\n         // link times negatively.\n-        args.push(\"-Wl,-dead_strip\".to_strbuf());\n+        cmd.arg(\"-Wl,-dead_strip\");\n     }\n \n     if sess.targ_cfg.os == abi::OsWin32 {\n         // Make sure that we link to the dynamic libgcc, otherwise cross-module\n         // DWARF stack unwinding will not work.\n         // This behavior may be overridden by --link-args \"-static-libgcc\"\n-        args.push(\"-shared-libgcc\".to_strbuf());\n+        cmd.arg(\"-shared-libgcc\");\n \n         // And here, we see obscure linker flags #45. On windows, it has been\n         // found to be necessary to have this flag to compile liblibc.\n@@ -1200,13 +1189,13 @@ fn link_args(sess: &Session,\n         //\n         // [1] - https://sourceware.org/bugzilla/show_bug.cgi?id=13130\n         // [2] - https://code.google.com/p/go/issues/detail?id=2139\n-        args.push(\"-Wl,--enable-long-section-names\".to_strbuf());\n+        cmd.arg(\"-Wl,--enable-long-section-names\");\n     }\n \n     if sess.targ_cfg.os == abi::OsAndroid {\n         // Many of the symbols defined in compiler-rt are also defined in libgcc.\n         // Android linker doesn't like that by default.\n-        args.push(\"-Wl,--allow-multiple-definition\".to_strbuf());\n+        cmd.arg(\"-Wl,--allow-multiple-definition\");\n     }\n \n     // Take careful note of the ordering of the arguments we pass to the linker\n@@ -1242,39 +1231,38 @@ fn link_args(sess: &Session,\n     // this kind of behavior is pretty platform specific and generally not\n     // recommended anyway, so I don't think we're shooting ourself in the foot\n     // much with that.\n-    add_upstream_rust_crates(&mut args, sess, dylib, tmpdir, trans);\n-    add_local_native_libraries(&mut args, sess);\n-    add_upstream_native_libraries(&mut args, sess);\n+    add_upstream_rust_crates(cmd, sess, dylib, tmpdir, trans);\n+    add_local_native_libraries(cmd, sess);\n+    add_upstream_native_libraries(cmd, sess);\n \n     // # Telling the linker what we're doing\n \n     if dylib {\n         // On mac we need to tell the linker to let this library be rpathed\n         if sess.targ_cfg.os == abi::OsMacos {\n-            args.push(\"-dynamiclib\".to_strbuf());\n-            args.push(\"-Wl,-dylib\".to_strbuf());\n-            // FIXME (#9639): This needs to handle non-utf8 paths\n+            cmd.args([\"-dynamiclib\", \"-Wl,-dylib\"]);\n+\n             if !sess.opts.cg.no_rpath {\n-                args.push(format_strbuf!(\"-Wl,-install_name,@rpath/{}\",\n-                                         out_filename.filename_str()\n-                                                     .unwrap()));\n+                let mut v = Vec::from_slice(\"-Wl,-install_name,@rpath/\".as_bytes());\n+                v.push_all(out_filename.filename().unwrap());\n+                cmd.arg(v.as_slice());\n             }\n         } else {\n-            args.push(\"-shared\".to_strbuf())\n+            cmd.arg(\"-shared\");\n         }\n     }\n \n     if sess.targ_cfg.os == abi::OsFreebsd {\n-        args.push_all([\"-L/usr/local/lib\".to_strbuf(),\n-                       \"-L/usr/local/lib/gcc46\".to_strbuf(),\n-                       \"-L/usr/local/lib/gcc44\".to_strbuf()]);\n+        cmd.args([\"-L/usr/local/lib\",\n+                  \"-L/usr/local/lib/gcc46\",\n+                  \"-L/usr/local/lib/gcc44\"]);\n     }\n \n     // FIXME (#2397): At some point we want to rpath our guesses as to\n     // where extern libraries might live, based on the\n     // addl_lib_search_paths\n     if !sess.opts.cg.no_rpath {\n-        args.push_all(rpath::get_rpath_flags(sess, out_filename).as_slice());\n+        cmd.args(rpath::get_rpath_flags(sess, out_filename).as_slice());\n     }\n \n     // compiler-rt contains implementations of low-level LLVM helpers. This is\n@@ -1284,15 +1272,14 @@ fn link_args(sess: &Session,\n     //\n     // This is the end of the command line, so this library is used to resolve\n     // *all* undefined symbols in all other libraries, and this is intentional.\n-    args.push(\"-lcompiler-rt\".to_strbuf());\n+    cmd.arg(\"-lcompiler-rt\");\n \n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n-    args.push_all(sess.opts.cg.link_args.as_slice());\n+    cmd.args(sess.opts.cg.link_args.as_slice());\n     for arg in sess.cstore.get_used_link_args().borrow().iter() {\n-        args.push(arg.clone());\n+        cmd.arg(arg.as_slice());\n     }\n-    return args;\n }\n \n // # Native library linking\n@@ -1306,16 +1293,14 @@ fn link_args(sess: &Session,\n // Also note that the native libraries linked here are only the ones located\n // in the current crate. Upstream crates with native library dependencies\n // may have their native library pulled in above.\n-fn add_local_native_libraries(args: &mut Vec<StrBuf>, sess: &Session) {\n+fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n     for path in sess.opts.addl_lib_search_paths.borrow().iter() {\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        args.push((\"-L\" + path.as_str().unwrap().to_owned()).to_strbuf());\n+        cmd.arg(\"-L\").arg(path);\n     }\n \n     let rustpath = filesearch::rust_path();\n     for path in rustpath.iter() {\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        args.push((\"-L\" + path.as_str().unwrap().to_owned()).to_strbuf());\n+        cmd.arg(\"-L\").arg(path);\n     }\n \n     // Some platforms take hints about whether a library is static or dynamic.\n@@ -1329,21 +1314,21 @@ fn add_local_native_libraries(args: &mut Vec<StrBuf>, sess: &Session) {\n             cstore::NativeUnknown | cstore::NativeStatic => {\n                 if takes_hints {\n                     if kind == cstore::NativeStatic {\n-                        args.push(\"-Wl,-Bstatic\".to_strbuf());\n+                        cmd.arg(\"-Wl,-Bstatic\");\n                     } else {\n-                        args.push(\"-Wl,-Bdynamic\".to_strbuf());\n+                        cmd.arg(\"-Wl,-Bdynamic\");\n                     }\n                 }\n-                args.push(format_strbuf!(\"-l{}\", *l));\n+                cmd.arg(format_strbuf!(\"-l{}\", *l));\n             }\n             cstore::NativeFramework => {\n-                args.push(\"-framework\".to_strbuf());\n-                args.push(l.to_strbuf());\n+                cmd.arg(\"-framework\");\n+                cmd.arg(l.as_slice());\n             }\n         }\n     }\n     if takes_hints {\n-        args.push(\"-Wl,-Bdynamic\".to_strbuf());\n+        cmd.arg(\"-Wl,-Bdynamic\");\n     }\n }\n \n@@ -1352,7 +1337,7 @@ fn add_local_native_libraries(args: &mut Vec<StrBuf>, sess: &Session) {\n // Rust crates are not considered at all when creating an rlib output. All\n // dependencies will be linked when producing the final output (instead of\n // the intermediate rlib version)\n-fn add_upstream_rust_crates(args: &mut Vec<StrBuf>, sess: &Session,\n+fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                             dylib: bool, tmpdir: &Path,\n                             trans: &CrateTranslation) {\n     // All of the heavy lifting has previously been accomplished by the\n@@ -1384,26 +1369,26 @@ fn add_upstream_rust_crates(args: &mut Vec<StrBuf>, sess: &Session,\n         let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n         match kind {\n             cstore::RequireDynamic => {\n-                add_dynamic_crate(args, sess, src.dylib.unwrap())\n+                add_dynamic_crate(cmd, sess, src.dylib.unwrap())\n             }\n             cstore::RequireStatic => {\n-                add_static_crate(args, sess, tmpdir, cnum, src.rlib.unwrap())\n+                add_static_crate(cmd, sess, tmpdir, cnum, src.rlib.unwrap())\n             }\n         }\n \n     }\n \n     // Converts a library file-stem into a cc -l argument\n-    fn unlib(config: &config::Config, stem: &str) -> StrBuf {\n-        if stem.starts_with(\"lib\") && config.os != abi::OsWin32 {\n-            stem.slice(3, stem.len()).to_strbuf()\n+    fn unlib<'a>(config: &config::Config, stem: &'a [u8]) -> &'a [u8] {\n+        if stem.starts_with(\"lib\".as_bytes()) && config.os != abi::OsWin32 {\n+            stem.tailn(3)\n         } else {\n-            stem.to_strbuf()\n+            stem\n         }\n     }\n \n     // Adds the static \"rlib\" versions of all crates to the command line.\n-    fn add_static_crate(args: &mut Vec<StrBuf>, sess: &Session, tmpdir: &Path,\n+    fn add_static_crate(cmd: &mut Command, sess: &Session, tmpdir: &Path,\n                         cnum: ast::CrateNum, cratepath: Path) {\n         // When performing LTO on an executable output, all of the\n         // bytecode from the upstream libraries has already been\n@@ -1434,34 +1419,32 @@ fn add_upstream_rust_crates(args: &mut Vec<StrBuf>, sess: &Session,\n                         sess.abort_if_errors();\n                     }\n                 }\n-                let dst_str = dst.as_str().unwrap().to_strbuf();\n-                let mut archive = Archive::open(sess, dst);\n+                let mut archive = Archive::open(sess, dst.clone());\n                 archive.remove_file(format!(\"{}.o\", name));\n                 let files = archive.files();\n                 if files.iter().any(|s| s.as_slice().ends_with(\".o\")) {\n-                    args.push(dst_str);\n+                    cmd.arg(dst);\n                 }\n             });\n         } else {\n-            args.push(cratepath.as_str().unwrap().to_strbuf());\n+            cmd.arg(cratepath);\n         }\n     }\n \n     // Same thing as above, but for dynamic crates instead of static crates.\n-    fn add_dynamic_crate(args: &mut Vec<StrBuf>, sess: &Session,\n-                         cratepath: Path) {\n+    fn add_dynamic_crate(cmd: &mut Command, sess: &Session, cratepath: Path) {\n         // If we're performing LTO, then it should have been previously required\n         // that all upstream rust dependencies were available in an rlib format.\n         assert!(!sess.lto());\n \n         // Just need to tell the linker about where the library lives and\n         // what its name is\n-        let dir = cratepath.dirname_str().unwrap();\n-        if !dir.is_empty() {\n-            args.push(format_strbuf!(\"-L{}\", dir));\n-        }\n-        let libarg = unlib(&sess.targ_cfg, cratepath.filestem_str().unwrap());\n-        args.push(format_strbuf!(\"-l{}\", libarg));\n+        let dir = cratepath.dirname();\n+        if !dir.is_empty() { cmd.arg(\"-L\").arg(dir); }\n+\n+        let mut v = Vec::from_slice(\"-l\".as_bytes());\n+        v.push_all(unlib(&sess.targ_cfg, cratepath.filestem().unwrap()));\n+        cmd.arg(v.as_slice());\n     }\n }\n \n@@ -1470,20 +1453,20 @@ fn add_upstream_rust_crates(args: &mut Vec<StrBuf>, sess: &Session,\n // dependencies. We've got two cases then:\n //\n // 1. The upstream crate is an rlib. In this case we *must* link in the\n-//    native dependency because the rlib is just an archive.\n+// native dependency because the rlib is just an archive.\n //\n // 2. The upstream crate is a dylib. In order to use the dylib, we have to\n-//    have the dependency present on the system somewhere. Thus, we don't\n-//    gain a whole lot from not linking in the dynamic dependency to this\n-//    crate as well.\n+// have the dependency present on the system somewhere. Thus, we don't\n+// gain a whole lot from not linking in the dynamic dependency to this\n+// crate as well.\n //\n // The use case for this is a little subtle. In theory the native\n // dependencies of a crate are purely an implementation detail of the crate\n // itself, but the problem arises with generic and inlined functions. If a\n // generic function calls a native function, then the generic function must\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n-fn add_upstream_native_libraries(args: &mut Vec<StrBuf>, sess: &Session) {\n+fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n     // Be sure to use a topological sorting of crates because there may be\n     // interdependencies between native libraries. When passing -nodefaultlibs,\n     // for example, almost all native libraries depend on libc, so we have to\n@@ -1499,11 +1482,11 @@ fn add_upstream_native_libraries(args: &mut Vec<StrBuf>, sess: &Session) {\n         for &(kind, ref lib) in libs.iter() {\n             match kind {\n                 cstore::NativeUnknown => {\n-                    args.push(format_strbuf!(\"-l{}\", *lib))\n+                    cmd.arg(format_strbuf!(\"-l{}\", *lib));\n                 }\n                 cstore::NativeFramework => {\n-                    args.push(\"-framework\".to_strbuf());\n-                    args.push(lib.to_strbuf());\n+                    cmd.arg(\"-framework\");\n+                    cmd.arg(lib.as_slice());\n                 }\n                 cstore::NativeStatic => {\n                     sess.bug(\"statics shouldn't be propagated\");"}, {"sha": "024f5a1b3fda7bdf56cdcab064165ab5ded429cc", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -11,7 +11,7 @@\n use std::cell::RefCell;\n use std::char;\n use std::io;\n-use std::io::{Process, TempDir};\n+use std::io::{Command, TempDir};\n use std::os;\n use std::str;\n use std::strbuf::StrBuf;\n@@ -155,9 +155,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n     if no_run { return }\n \n     // Run the code!\n-    let exe = outdir.path().join(\"rust_out\");\n-    let out = Process::output(exe.as_str().unwrap(), []);\n-    match out {\n+    match Command::new(outdir.path().join(\"rust_out\")).output() {\n         Err(e) => fail!(\"couldn't run the test: {}{}\", e,\n                         if e.kind == io::PermissionDenied {\n                             \" - maybe your tempdir is mounted with noexec?\""}, {"sha": "f6fcf3e48162fa138e251dc4cdb0d6e62862f6bc", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 57, "deletions": 47, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -13,7 +13,8 @@ use libc;\n use std::io::IoError;\n use std::io::process;\n use std::ptr;\n-use std::rt::rtio::RtioProcess;\n+use std::c_str::CString;\n+use std::rt::rtio::{ProcessConfig, RtioProcess};\n use std::rt::task::BlockedTask;\n \n use homing::{HomingIO, HomeHandle};\n@@ -50,12 +51,10 @@ impl Process {\n     ///\n     /// Returns either the corresponding process object or an error which\n     /// occurred.\n-    pub fn spawn(io_loop: &mut UvIoFactory, config: process::ProcessConfig)\n-                -> Result<(Box<Process>, Vec<Option<PipeWatcher>>), UvError>\n-    {\n-        let cwd = config.cwd.map(|s| s.to_c_str());\n-        let mut io = vec![config.stdin, config.stdout, config.stderr];\n-        for slot in config.extra_io.iter() {\n+    pub fn spawn(io_loop: &mut UvIoFactory, cfg: ProcessConfig)\n+                -> Result<(Box<Process>, Vec<Option<PipeWatcher>>), UvError> {\n+        let mut io = vec![cfg.stdin, cfg.stdout, cfg.stderr];\n+        for slot in cfg.extra_io.iter() {\n             io.push(*slot);\n         }\n         let mut stdio = Vec::<uvll::uv_stdio_container_t>::with_capacity(io.len());\n@@ -69,32 +68,32 @@ impl Process {\n             }\n         }\n \n-        let ret = with_argv(config.program, config.args, |argv| {\n-            with_env(config.env, |envp| {\n+        let ret = with_argv(cfg.program, cfg.args, |argv| {\n+            with_env(cfg.env, |envp| {\n                 let mut flags = 0;\n-                if config.uid.is_some() {\n+                if cfg.uid.is_some() {\n                     flags |= uvll::PROCESS_SETUID;\n                 }\n-                if config.gid.is_some() {\n+                if cfg.gid.is_some() {\n                     flags |= uvll::PROCESS_SETGID;\n                 }\n-                if config.detach {\n+                if cfg.detach {\n                     flags |= uvll::PROCESS_DETACHED;\n                 }\n                 let options = uvll::uv_process_options_t {\n                     exit_cb: on_exit,\n                     file: unsafe { *argv },\n                     args: argv,\n                     env: envp,\n-                    cwd: match cwd {\n-                        Some(ref cwd) => cwd.with_ref(|p| p),\n+                    cwd: match cfg.cwd {\n+                        Some(cwd) => cwd.with_ref(|p| p),\n                         None => ptr::null(),\n                     },\n                     flags: flags as libc::c_uint,\n                     stdio_count: stdio.len() as libc::c_int,\n                     stdio: stdio.as_ptr(),\n-                    uid: config.uid.unwrap_or(0) as uvll::uv_uid_t,\n-                    gid: config.gid.unwrap_or(0) as uvll::uv_gid_t,\n+                    uid: cfg.uid.unwrap_or(0) as uvll::uv_uid_t,\n+                    gid: cfg.gid.unwrap_or(0) as uvll::uv_gid_t,\n                 };\n \n                 let handle = UvHandle::alloc(None::<Process>, uvll::UV_PROCESS);\n@@ -175,42 +174,53 @@ unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n     }\n }\n \n-/// Converts the program and arguments to the argv array expected by libuv\n-fn with_argv<T>(prog: &str, args: &[~str], f: |**libc::c_char| -> T) -> T {\n-    // First, allocation space to put all the C-strings (we need to have\n-    // ownership of them somewhere\n-    let mut c_strs = Vec::with_capacity(args.len() + 1);\n-    c_strs.push(prog.to_c_str());\n-    for arg in args.iter() {\n-        c_strs.push(arg.to_c_str());\n-    }\n+/// Converts the program and arguments to the argv array expected by libuv.\n+fn with_argv<T>(prog: &CString, args: &[CString], cb: |**libc::c_char| -> T) -> T {\n+    let mut ptrs: Vec<*libc::c_char> = Vec::with_capacity(args.len()+1);\n \n-    // Next, create the char** array\n-    let mut c_args = Vec::with_capacity(c_strs.len() + 1);\n-    for s in c_strs.iter() {\n-        c_args.push(s.with_ref(|p| p));\n-    }\n-    c_args.push(ptr::null());\n-    f(c_args.as_ptr())\n+    // Convert the CStrings into an array of pointers. Note: the\n+    // lifetime of the various CStrings involved is guaranteed to be\n+    // larger than the lifetime of our invocation of cb, but this is\n+    // technically unsafe as the callback could leak these pointers\n+    // out of our scope.\n+    ptrs.push(prog.with_ref(|buf| buf));\n+    ptrs.extend(args.iter().map(|tmp| tmp.with_ref(|buf| buf)));\n+\n+    // Add a terminating null pointer (required by libc).\n+    ptrs.push(ptr::null());\n+\n+    cb(ptrs.as_ptr())\n }\n \n /// Converts the environment to the env array expected by libuv\n-fn with_env<T>(env: Option<&[(~str, ~str)]>, f: |**libc::c_char| -> T) -> T {\n-    let env = match env {\n-        Some(s) => s,\n-        None => { return f(ptr::null()); }\n-    };\n-    // As with argv, create some temporary storage and then the actual array\n-    let mut envp = Vec::with_capacity(env.len());\n-    for &(ref key, ref value) in env.iter() {\n-        envp.push(format!(\"{}={}\", *key, *value).to_c_str());\n-    }\n-    let mut c_envp = Vec::with_capacity(envp.len() + 1);\n-    for s in envp.iter() {\n-        c_envp.push(s.with_ref(|p| p));\n+fn with_env<T>(env: Option<&[(CString, CString)]>, cb: |**libc::c_char| -> T) -> T {\n+    // We can pass a char** for envp, which is a null-terminated array\n+    // of \"k=v\\0\" strings. Since we must create these strings locally,\n+    // yet expose a raw pointer to them, we create a temporary vector\n+    // to own the CStrings that outlives the call to cb.\n+    match env {\n+        Some(env) => {\n+            let mut tmps = Vec::with_capacity(env.len());\n+\n+            for pair in env.iter() {\n+                let mut kv = Vec::new();\n+                kv.push_all(pair.ref0().as_bytes_no_nul());\n+                kv.push('=' as u8);\n+                kv.push_all(pair.ref1().as_bytes()); // includes terminal \\0\n+                tmps.push(kv);\n+            }\n+\n+            // As with `with_argv`, this is unsafe, since cb could leak the pointers.\n+            let mut ptrs: Vec<*libc::c_char> =\n+                tmps.iter()\n+                    .map(|tmp| tmp.as_ptr() as *libc::c_char)\n+                    .collect();\n+            ptrs.push(ptr::null());\n+\n+            cb(ptrs.as_ptr())\n+        }\n+        _ => cb(ptr::null())\n     }\n-    c_envp.push(ptr::null());\n-    f(c_envp.as_ptr())\n }\n \n impl HomingIO for Process {"}, {"sha": "1b8175448fc90be62a38d98b196220745f20073f", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -13,7 +13,6 @@\n use std::c_str::CString;\n use std::io::IoError;\n use std::io::net::ip::SocketAddr;\n-use std::io::process::ProcessConfig;\n use std::io::signal::Signum;\n use std::io::{FileMode, FileAccess, Open, Append, Truncate, Read, Write,\n               ReadWrite, FileStat};\n@@ -25,7 +24,7 @@ use libc::{O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY, S_IRUSR,\n use libc;\n use std::path::Path;\n use std::rt::rtio;\n-use std::rt::rtio::{IoFactory, EventLoop};\n+use std::rt::rtio::{ProcessConfig, IoFactory, EventLoop};\n use ai = std::io::net::addrinfo;\n \n #[cfg(test)] use std::unstable::run_in_bare_thread;\n@@ -270,12 +269,12 @@ impl IoFactory for UvIoFactory {\n         r.map_err(uv_error_to_io_error)\n     }\n \n-    fn spawn(&mut self, config: ProcessConfig)\n+    fn spawn(&mut self, cfg: ProcessConfig)\n             -> Result<(Box<rtio::RtioProcess:Send>,\n                        Vec<Option<Box<rtio::RtioPipe:Send>>>),\n                       IoError>\n     {\n-        match Process::spawn(self, config) {\n+        match Process::spawn(self, cfg) {\n             Ok((p, io)) => {\n                 Ok((p as Box<rtio::RtioProcess:Send>,\n                     io.move_iter().map(|i| i.map(|p| {"}, {"sha": "0c529ee4d963e64404c013325956b5f5e43ef65b", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -82,6 +82,7 @@ use slice::{ImmutableVector, MutableVector};\n use slice;\n use str::StrSlice;\n use str;\n+use strbuf::StrBuf;\n \n /// The representation of a C String.\n ///\n@@ -292,6 +293,14 @@ pub trait ToCStr {\n     }\n }\n \n+// FIXME (#12938): Until DST lands, we cannot decompose &str into &\n+// and str, so we cannot usefully take ToCStr arguments by reference\n+// (without forcing an additional & around &str). So we are instead\n+// temporarily adding an instance for ~str and StrBuf, so that we can\n+// take ToCStr as owned. When DST lands, the string instances should\n+// be revisted, and arguments bound by ToCStr should be passed by\n+// reference.\n+\n impl<'a> ToCStr for &'a str {\n     #[inline]\n     fn to_c_str(&self) -> CString {\n@@ -314,6 +323,51 @@ impl<'a> ToCStr for &'a str {\n     }\n }\n \n+impl ToCStr for ~str {\n+    #[inline]\n+    fn to_c_str(&self) -> CString {\n+        self.as_bytes().to_c_str()\n+    }\n+\n+    #[inline]\n+    unsafe fn to_c_str_unchecked(&self) -> CString {\n+        self.as_bytes().to_c_str_unchecked()\n+    }\n+\n+    #[inline]\n+    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n+        self.as_bytes().with_c_str(f)\n+    }\n+\n+    #[inline]\n+    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {\n+        self.as_bytes().with_c_str_unchecked(f)\n+    }\n+}\n+\n+\n+impl ToCStr for StrBuf {\n+    #[inline]\n+    fn to_c_str(&self) -> CString {\n+        self.as_bytes().to_c_str()\n+    }\n+\n+    #[inline]\n+    unsafe fn to_c_str_unchecked(&self) -> CString {\n+        self.as_bytes().to_c_str_unchecked()\n+    }\n+\n+    #[inline]\n+    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n+        self.as_bytes().with_c_str(f)\n+    }\n+\n+    #[inline]\n+    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {\n+        self.as_bytes().with_c_str_unchecked(f)\n+    }\n+}\n+\n // The length of the stack allocated buffer for `vec.with_c_str()`\n static BUF_LEN: uint = 128;\n "}, {"sha": "5c9d5feab10360230f03497f8f41a85caba4e238", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -245,7 +245,7 @@ pub use self::net::tcp::TcpListener;\n pub use self::net::tcp::TcpStream;\n pub use self::net::udp::UdpStream;\n pub use self::pipe::PipeStream;\n-pub use self::process::{Process, ProcessConfig};\n+pub use self::process::{Process, Command};\n pub use self::tempfile::TempDir;\n \n pub use self::mem::{MemReader, BufReader, MemWriter, BufWriter};"}, {"sha": "fe51615285a0081d9e622644501ccf08b391117a", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 290, "deletions": 305, "changes": 595, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -14,13 +14,15 @@\n \n use prelude::*;\n \n+use std::str;\n use fmt;\n use io::IoResult;\n use io;\n use libc;\n use mem;\n use owned::Box;\n-use rt::rtio::{RtioProcess, IoFactory, LocalIo};\n+use rt::rtio::{RtioProcess, ProcessConfig, IoFactory, LocalIo};\n+use c_str::CString;\n \n /// Signal a process to exit, without forcibly killing it. Corresponds to\n /// SIGTERM on unix platforms.\n@@ -37,16 +39,16 @@ use rt::rtio::{RtioProcess, IoFactory, LocalIo};\n \n /// Representation of a running or exited child process.\n ///\n-/// This structure is used to create, run, and manage child processes. A process\n-/// is configured with the `ProcessConfig` struct which contains specific\n-/// options for dictating how the child is spawned.\n+/// This structure is used to represent and manage child processes. A child\n+/// process is created via the `Command` struct, which configures the spawning\n+/// process and can itself be constructed using a builder-style interface.\n ///\n /// # Example\n ///\n /// ```should_fail\n-/// use std::io::Process;\n+/// use std::io::Command;\n ///\n-/// let mut child = match Process::new(\"/bin/cat\", [\"file.txt\".to_owned()]) {\n+/// let mut child = match Command::new(\"/bin/cat\").arg(\"file.txt\").spawn() {\n ///     Ok(child) => child,\n ///     Err(e) => fail!(\"failed to execute child: {}\", e),\n /// };\n@@ -74,71 +76,244 @@ pub struct Process {\n     pub extra_io: Vec<Option<io::PipeStream>>,\n }\n \n-/// This configuration describes how a new process should be spawned. A blank\n-/// configuration can be created with `ProcessConfig::new()`. It is also\n-/// recommented to use a functional struct update pattern when creating process\n-/// configuration:\n+/// The `Command` type acts as a process builder, providing fine-grained control\n+/// over how a new process should be spawned. A default configuration can be\n+/// generated using `Command::new(program)`, where `program` gives a path to the\n+/// program to be executed. Additional builder methods allow the configuration\n+/// to be changed (for example, by adding arguments) prior to spawning:\n ///\n /// ```\n-/// use std::io::ProcessConfig;\n+/// use std::io::Command;\n ///\n-/// let config = ProcessConfig {\n-///     program: \"/bin/sh\",\n-///     args: &[\"-c\".to_owned(), \"true\".to_owned()],\n-///     .. ProcessConfig::new()\n+/// let mut process = match Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").spawn() {\n+///   Ok(p) => p,\n+///   Err(e) => fail!(\"failed to execute process: {}\", e),\n /// };\n+///\n+/// let output = process.stdout.get_mut_ref().read_to_end();\n /// ```\n-pub struct ProcessConfig<'a> {\n-    /// Path to the program to run\n-    pub program: &'a str,\n+pub struct Command {\n+    // The internal data for the builder. Documented by the builder\n+    // methods below, and serialized into rt::rtio::ProcessConfig.\n+    program: CString,\n+    args: Vec<CString>,\n+    env: Option<Vec<(CString, CString)>>,\n+    cwd: Option<CString>,\n+    stdin: StdioContainer,\n+    stdout: StdioContainer,\n+    stderr: StdioContainer,\n+    extra_io: Vec<StdioContainer>,\n+    uid: Option<uint>,\n+    gid: Option<uint>,\n+    detach: bool,\n+}\n+\n+// FIXME (#12938): Until DST lands, we cannot decompose &str into & and str, so\n+// we cannot usefully take ToCStr arguments by reference (without forcing an\n+// additional & around &str). So we are instead temporarily adding an instance\n+// for &Path, so that we can take ToCStr as owned. When DST lands, the &Path\n+// instance should be removed, and arguments bound by ToCStr should be passed by\n+// reference. (Here: {new, arg, args, env}.)\n+\n+impl Command {\n+    /// Constructs a new `Command` for launching the program at\n+    /// path `program`, with the following default configuration:\n+    ///\n+    /// * No arguments to the program\n+    /// * Inherit the current process's environment\n+    /// * Inherit the current process's working directory\n+    /// * A readable pipe for stdin (file descriptor 0)\n+    /// * A writeable pipe for stdour and stderr (file descriptors 1 and 2)\n+    ///\n+    /// Builder methods are provided to change these defaults and\n+    /// otherwise configure the process.\n+    pub fn new<T:ToCStr>(program: T) -> Command {\n+        Command {\n+            program: program.to_c_str(),\n+            args: Vec::new(),\n+            env: None,\n+            cwd: None,\n+            stdin: CreatePipe(true, false),\n+            stdout: CreatePipe(false, true),\n+            stderr: CreatePipe(false, true),\n+            extra_io: Vec::new(),\n+            uid: None,\n+            gid: None,\n+            detach: false,\n+        }\n+    }\n+\n+    /// Add an argument to pass to the program.\n+    pub fn arg<'a, T:ToCStr>(&'a mut self, arg: T) -> &'a mut Command {\n+        self.args.push(arg.to_c_str());\n+        self\n+    }\n \n-    /// Arguments to pass to the program (doesn't include the program itself)\n-    pub args: &'a [~str],\n+    /// Add multiple arguments to pass to the program.\n+    pub fn args<'a, T:ToCStr>(&'a mut self, args: &[T]) -> &'a mut Command {\n+        self.args.extend(args.iter().map(|arg| arg.to_c_str()));;\n+        self\n+    }\n \n-    /// Optional environment to specify for the program. If this is None, then\n-    /// it will inherit the current process's environment.\n-    pub env: Option<&'a [(~str, ~str)]>,\n+    /// Sets the environment for the child process (rather than inheriting it\n+    /// from the current process).\n+\n+    // FIXME (#13851): We should change this interface to allow clients to (1)\n+    // build up the env vector incrementally and (2) allow both inheriting the\n+    // current process's environment AND overriding/adding additional\n+    // environment variables. The underlying syscalls assume that the\n+    // environment has no duplicate names, so we really want to use a hashtable\n+    // to compute the environment to pass down to the syscall; resolving issue\n+    // #13851 will make it possible to use the standard hashtable.\n+    pub fn env<'a, T:ToCStr>(&'a mut self, env: &[(T,T)]) -> &'a mut Command {\n+        self.env = Some(env.iter().map(|&(ref name, ref val)| {\n+            (name.to_c_str(), val.to_c_str())\n+        }).collect());\n+        self\n+    }\n \n-    /// Optional working directory for the new process. If this is None, then\n-    /// the current directory of the running process is inherited.\n-    pub cwd: Option<&'a Path>,\n+    /// Set the working directory for the child process.\n+    pub fn cwd<'a>(&'a mut self, dir: &Path) -> &'a mut Command {\n+        self.cwd = Some(dir.to_c_str());\n+        self\n+    }\n \n     /// Configuration for the child process's stdin handle (file descriptor 0).\n-    /// This field defaults to `CreatePipe(true, false)` so the input can be\n-    /// written to.\n-    pub stdin: StdioContainer,\n+    /// Defaults to `CreatePipe(true, false)` so the input can be written to.\n+    pub fn stdin<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command {\n+        self.stdin = cfg;\n+        self\n+    }\n \n     /// Configuration for the child process's stdout handle (file descriptor 1).\n-    /// This field defaults to `CreatePipe(false, true)` so the output can be\n-    /// collected.\n-    pub stdout: StdioContainer,\n-\n-    /// Configuration for the child process's stdout handle (file descriptor 2).\n-    /// This field defaults to `CreatePipe(false, true)` so the output can be\n-    /// collected.\n-    pub stderr: StdioContainer,\n-\n-    /// Any number of streams/file descriptors/pipes may be attached to this\n-    /// process. This list enumerates the file descriptors and such for the\n-    /// process to be spawned, and the file descriptors inherited will start at\n-    /// 3 and go to the length of this array. The first three file descriptors\n-    /// (stdin/stdout/stderr) are configured with the `stdin`, `stdout`, and\n-    /// `stderr` fields.\n-    pub extra_io: &'a [StdioContainer],\n+    /// Defaults to `CreatePipe(false, true)` so the output can be collected.\n+    pub fn stdout<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command {\n+        self.stdout = cfg;\n+        self\n+    }\n+\n+    /// Configuration for the child process's stderr handle (file descriptor 2).\n+    /// Defaults to `CreatePipe(false, true)` so the output can be collected.\n+    pub fn stderr<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command {\n+        self.stderr = cfg;\n+        self\n+    }\n+    /// Attaches a stream/file descriptor/pipe to the child process. Inherited\n+    /// file descriptors are numbered consecutively, starting at 3; the first\n+    /// three file descriptors (stdin/stdout/stderr) are configured with the\n+    /// `stdin`, `stdout`, and `stderr` methods.\n+    pub fn extra_io<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command {\n+        self.extra_io.push(cfg);\n+        self\n+    }\n \n     /// Sets the child process's user id. This translates to a `setuid` call in\n     /// the child process. Setting this value on windows will cause the spawn to\n     /// fail. Failure in the `setuid` call on unix will also cause the spawn to\n     /// fail.\n-    pub uid: Option<uint>,\n+    pub fn uid<'a>(&'a mut self, id: uint) -> &'a mut Command {\n+        self.uid = Some(id);\n+        self\n+    }\n \n     /// Similar to `uid`, but sets the group id of the child process. This has\n     /// the same semantics as the `uid` field.\n-    pub gid: Option<uint>,\n+    pub fn gid<'a>(&'a mut self, id: uint) -> &'a mut Command {\n+        self.gid = Some(id);\n+        self\n+    }\n \n-    /// If true, the child process is spawned in a detached state. On unix, this\n+    /// Sets the child process to be spawned in a detached state. On unix, this\n     /// means that the child is the leader of a new process group.\n-    pub detach: bool,\n+    pub fn detached<'a>(&'a mut self) -> &'a mut Command {\n+        self.detach = true;\n+        self\n+    }\n+\n+    /// Executes the command as a child process, which is returned.\n+    pub fn spawn(&self) -> IoResult<Process> {\n+        LocalIo::maybe_raise(|io| {\n+            let cfg = ProcessConfig {\n+                program: &self.program,\n+                args: self.args.as_slice(),\n+                env: self.env.as_ref().map(|env| env.as_slice()),\n+                cwd: self.cwd.as_ref(),\n+                stdin: self.stdin,\n+                stdout: self.stdout,\n+                stderr: self.stderr,\n+                extra_io: self.extra_io.as_slice(),\n+                uid: self.uid,\n+                gid: self.gid,\n+                detach: self.detach,\n+            };\n+            io.spawn(cfg).map(|(p, io)| {\n+                let mut io = io.move_iter().map(|p| {\n+                    p.map(|p| io::PipeStream::new(p))\n+                });\n+                Process {\n+                    handle: p,\n+                    stdin: io.next().unwrap(),\n+                    stdout: io.next().unwrap(),\n+                    stderr: io.next().unwrap(),\n+                    extra_io: io.collect(),\n+                }\n+            })\n+        })\n+    }\n+\n+    /// Executes the command as a child process, waiting for it to finish and\n+    /// collecting all of its output.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::io::Command;\n+    /// use std::str;\n+    ///\n+    /// let output = match Command::new(\"cat\").arg(\"foot.txt\").output() {\n+    ///     Ok(output) => output,\n+    ///     Err(e) => fail!(\"failed to execute process: {}\", e),\n+    /// };\n+    ///\n+    /// println!(\"status: {}\", output.status);\n+    /// println!(\"stdout: {}\", str::from_utf8_lossy(output.output.as_slice()));\n+    /// println!(\"stderr: {}\", str::from_utf8_lossy(output.error.as_slice()));\n+    /// ```\n+    pub fn output(&self) -> IoResult<ProcessOutput> {\n+        self.spawn().and_then(|p| p.wait_with_output())\n+    }\n+\n+    /// Executes a command as a child process, waiting for it to finish and\n+    /// collecting its exit status.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::io::Command;\n+    ///\n+    /// let status = match Command::new(\"ls\").status() {\n+    ///     Ok(status) => status,\n+    ///     Err(e) => fail!(\"failed to execute process: {}\", e),\n+    /// };\n+    ///\n+    /// println!(\"process exited with: {}\", status);\n+    /// ```\n+    pub fn status(&self) -> IoResult<ProcessExit> {\n+        self.spawn().and_then(|mut p| p.wait())\n+    }\n+}\n+\n+impl fmt::Show for Command {\n+    /// Format the program and arguments of a Command for display. Any\n+    /// non-utf8 data is lossily converted using the utf8 replacement\n+    /// character.\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f.buf, \"{}\", str::from_utf8_lossy(self.program.as_bytes_no_nul())));\n+        for arg in self.args.iter() {\n+            try!(write!(f.buf, \" '{}'\", str::from_utf8_lossy(arg.as_bytes_no_nul())));\n+        }\n+        Ok(())\n+    }\n }\n \n /// The output of a finished process.\n@@ -206,127 +381,7 @@ impl ProcessExit {\n     }\n }\n \n-impl<'a> ProcessConfig<'a> {\n-    /// Creates a new configuration with blanks as all of the defaults. This is\n-    /// useful when using functional struct updates:\n-    ///\n-    /// ```rust\n-    /// use std::io::process::{ProcessConfig, Process};\n-    ///\n-    /// let config = ProcessConfig {\n-    ///     program: \"/bin/sh\",\n-    ///     args: &[\"-c\".to_owned(), \"echo hello\".to_owned()],\n-    ///     .. ProcessConfig::new()\n-    /// };\n-    ///\n-    /// let p = Process::configure(config);\n-    /// ```\n-    ///\n-    pub fn new<'a>() -> ProcessConfig<'a> {\n-        ProcessConfig {\n-            program: \"\",\n-            args: &[],\n-            env: None,\n-            cwd: None,\n-            stdin: CreatePipe(true, false),\n-            stdout: CreatePipe(false, true),\n-            stderr: CreatePipe(false, true),\n-            extra_io: &[],\n-            uid: None,\n-            gid: None,\n-            detach: false,\n-        }\n-    }\n-}\n-\n impl Process {\n-    /// Creates a new process for the specified program/arguments, using\n-    /// otherwise default configuration.\n-    ///\n-    /// By default, new processes have their stdin/stdout/stderr handles created\n-    /// as pipes the can be manipulated through the respective fields of the\n-    /// returned `Process`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::io::Process;\n-    ///\n-    /// let mut process = match Process::new(\"sh\", &[\"c\".to_owned(), \"echo hello\".to_owned()]) {\n-    ///     Ok(p) => p,\n-    ///     Err(e) => fail!(\"failed to execute process: {}\", e),\n-    /// };\n-    ///\n-    /// let output = process.stdout.get_mut_ref().read_to_end();\n-    /// ```\n-    pub fn new(prog: &str, args: &[~str]) -> IoResult<Process> {\n-        Process::configure(ProcessConfig {\n-            program: prog,\n-            args: args,\n-            .. ProcessConfig::new()\n-        })\n-    }\n-\n-    /// Executes the specified program with arguments, waiting for it to finish\n-    /// and collecting all of its output.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::io::Process;\n-    /// use std::str;\n-    ///\n-    /// let output = match Process::output(\"cat\", [\"foo.txt\".to_owned()]) {\n-    ///     Ok(output) => output,\n-    ///     Err(e) => fail!(\"failed to execute process: {}\", e),\n-    /// };\n-    ///\n-    /// println!(\"status: {}\", output.status);\n-    /// println!(\"stdout: {}\", str::from_utf8_lossy(output.output.as_slice()));\n-    /// println!(\"stderr: {}\", str::from_utf8_lossy(output.error.as_slice()));\n-    /// ```\n-    pub fn output(prog: &str, args: &[~str]) -> IoResult<ProcessOutput> {\n-        Process::new(prog, args).and_then(|p| p.wait_with_output())\n-    }\n-\n-    /// Executes a child process and collects its exit status. This will block\n-    /// waiting for the child to exit.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::io::Process;\n-    ///\n-    /// let status = match Process::status(\"ls\", []) {\n-    ///     Ok(status) => status,\n-    ///     Err(e) => fail!(\"failed to execute process: {}\", e),\n-    /// };\n-    ///\n-    /// println!(\"process exited with: {}\", status);\n-    /// ```\n-    pub fn status(prog: &str, args: &[~str]) -> IoResult<ProcessExit> {\n-        Process::new(prog, args).and_then(|mut p| p.wait())\n-    }\n-\n-    /// Creates a new process with the specified configuration.\n-    pub fn configure(config: ProcessConfig) -> IoResult<Process> {\n-        let mut config = Some(config);\n-        LocalIo::maybe_raise(|io| {\n-            io.spawn(config.take_unwrap()).map(|(p, io)| {\n-                let mut io = io.move_iter().map(|p| {\n-                    p.map(|p| io::PipeStream::new(p))\n-                });\n-                Process {\n-                    handle: p,\n-                    stdin: io.next().unwrap(),\n-                    stdout: io.next().unwrap(),\n-                    stderr: io.next().unwrap(),\n-                    extra_io: io.collect(),\n-                }\n-            })\n-        })\n-    }\n-\n     /// Sends `signal` to another process in the system identified by `id`.\n     ///\n     /// Note that windows doesn't quite have the same model as unix, so some\n@@ -403,11 +458,11 @@ impl Process {\n     ///\n     /// ```no_run\n     /// # #![allow(experimental)]\n-    /// use std::io::process::{Process, ProcessExit};\n+    /// use std::io::process::{Command, ProcessExit};\n     /// use std::io::IoResult;\n     ///\n     /// fn run_gracefully(prog: &str) -> IoResult<ProcessExit> {\n-    ///     let mut p = try!(Process::new(\"long-running-process\", []));\n+    ///     let mut p = try!(Command::new(\"long-running-process\").spawn());\n     ///\n     ///     // give the process 10 seconds to finish completely\n     ///     p.set_timeout(Some(10_000));\n@@ -487,42 +542,30 @@ impl Drop for Process {\n \n #[cfg(test)]\n mod tests {\n-    use io::process::{ProcessConfig, Process};\n+    use io::process::{Command, Process};\n     use prelude::*;\n \n     // FIXME(#10380) these tests should not all be ignored on android.\n \n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn smoke() {\n-        let args = ProcessConfig {\n-            program: \"true\",\n-            .. ProcessConfig::new()\n-        };\n-        let p = Process::configure(args);\n+        let p = Command::new(\"true\").spawn();\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n         assert!(p.wait().unwrap().success());\n     })\n \n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn smoke_failure() {\n-        let args = ProcessConfig {\n-            program: \"if-this-is-a-binary-then-the-world-has-ended\",\n-            .. ProcessConfig::new()\n-        };\n-        match Process::configure(args) {\n+        match Command::new(\"if-this-is-a-binary-then-the-world-has-ended\").spawn() {\n             Ok(..) => fail!(),\n             Err(..) => {}\n         }\n     })\n \n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn exit_reported_right() {\n-        let args = ProcessConfig {\n-            program: \"false\",\n-            .. ProcessConfig::new()\n-        };\n-        let p = Process::configure(args);\n+        let p = Command::new(\"false\").spawn();\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n         assert!(p.wait().unwrap().matches_exit_status(1));\n@@ -531,12 +574,7 @@ mod tests {\n \n     #[cfg(unix, not(target_os=\"android\"))]\n     iotest!(fn signal_reported_right() {\n-        let args = ProcessConfig {\n-            program: \"/bin/sh\",\n-            args: &[\"-c\".to_owned(), \"kill -1 $$\".to_owned()],\n-            .. ProcessConfig::new()\n-        };\n-        let p = Process::configure(args);\n+        let p = Command::new(\"/bin/sh\").arg(\"-c\").arg(\"kill -1 $$\").spawn();\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n         match p.wait().unwrap() {\n@@ -549,8 +587,8 @@ mod tests {\n         input.read_to_str().unwrap()\n     }\n \n-    pub fn run_output(args: ProcessConfig) -> ~str {\n-        let p = Process::configure(args);\n+    pub fn run_output(cmd: Command) -> ~str {\n+        let p = cmd.spawn();\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n         assert!(p.stdout.is_some());\n@@ -561,38 +599,27 @@ mod tests {\n \n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn stdout_works() {\n-        let args = ProcessConfig {\n-            program: \"echo\",\n-            args: &[\"foobar\".to_owned()],\n-            stdout: CreatePipe(false, true),\n-            .. ProcessConfig::new()\n-        };\n-        assert_eq!(run_output(args), \"foobar\\n\".to_owned());\n+        let mut cmd = Command::new(\"echo\");\n+        cmd.arg(\"foobar\").stdout(CreatePipe(false, true));\n+        assert_eq!(run_output(cmd), \"foobar\\n\".to_owned());\n     })\n \n     #[cfg(unix, not(target_os=\"android\"))]\n     iotest!(fn set_cwd_works() {\n-        let cwd = Path::new(\"/\");\n-        let args = ProcessConfig {\n-            program: \"/bin/sh\",\n-            args: &[\"-c\".to_owned(), \"pwd\".to_owned()],\n-            cwd: Some(&cwd),\n-            stdout: CreatePipe(false, true),\n-            .. ProcessConfig::new()\n-        };\n-        assert_eq!(run_output(args), \"/\\n\".to_owned());\n+        let mut cmd = Command::new(\"/bin/sh\");\n+        cmd.arg(\"-c\").arg(\"pwd\")\n+           .cwd(&Path::new(\"/\"))\n+           .stdout(CreatePipe(false, true));\n+        assert_eq!(run_output(cmd), \"/\\n\".to_owned());\n     })\n \n     #[cfg(unix, not(target_os=\"android\"))]\n     iotest!(fn stdin_works() {\n-        let args = ProcessConfig {\n-            program: \"/bin/sh\",\n-            args: &[\"-c\".to_owned(), \"read line; echo $line\".to_owned()],\n-            stdin: CreatePipe(true, false),\n-            stdout: CreatePipe(false, true),\n-            .. ProcessConfig::new()\n-        };\n-        let mut p = Process::configure(args).unwrap();\n+        let mut p = Command::new(\"/bin/sh\")\n+                            .arg(\"-c\").arg(\"read line; echo $line\")\n+                            .stdin(CreatePipe(true, false))\n+                            .stdout(CreatePipe(false, true))\n+                            .spawn().unwrap();\n         p.stdin.get_mut_ref().write(\"foobar\".as_bytes()).unwrap();\n         drop(p.stdin.take());\n         let out = read_all(p.stdout.get_mut_ref() as &mut Reader);\n@@ -602,36 +629,23 @@ mod tests {\n \n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn detach_works() {\n-        let args = ProcessConfig {\n-            program: \"true\",\n-            detach: true,\n-            .. ProcessConfig::new()\n-        };\n-        let mut p = Process::configure(args).unwrap();\n+        let mut p = Command::new(\"true\").detached().spawn().unwrap();\n         assert!(p.wait().unwrap().success());\n     })\n \n     #[cfg(windows)]\n     iotest!(fn uid_fails_on_windows() {\n-        let args = ProcessConfig {\n-            program: \"test\",\n-            uid: Some(10),\n-            .. ProcessConfig::new()\n-        };\n-        assert!(Process::configure(args).is_err());\n+        assert!(Command::new(\"test\").uid(10).spawn().is_err());\n     })\n \n     #[cfg(unix, not(target_os=\"android\"))]\n     iotest!(fn uid_works() {\n         use libc;\n-        let args = ProcessConfig {\n-            program: \"/bin/sh\",\n-            args: &[\"-c\".to_owned(), \"true\".to_owned()],\n-            uid: Some(unsafe { libc::getuid() as uint }),\n-            gid: Some(unsafe { libc::getgid() as uint }),\n-            .. ProcessConfig::new()\n-        };\n-        let mut p = Process::configure(args).unwrap();\n+        let mut p = Command::new(\"/bin/sh\")\n+                            .arg(\"-c\").arg(\"true\")\n+                            .uid(unsafe { libc::getuid() as uint })\n+                            .gid(unsafe { libc::getgid() as uint })\n+                            .spawn().unwrap();\n         assert!(p.wait().unwrap().success());\n     })\n \n@@ -642,36 +656,29 @@ mod tests {\n         // if we're already root, this isn't a valid test. Most of the bots run\n         // as non-root though (android is an exception).\n         if unsafe { libc::getuid() == 0 } { return }\n-        let args = ProcessConfig {\n-            program: \"/bin/ls\",\n-            uid: Some(0),\n-            gid: Some(0),\n-            .. ProcessConfig::new()\n-        };\n-        assert!(Process::configure(args).is_err());\n+        assert!(Command::new(\"/bin/ls\").uid(0).gid(0).spawn().is_err());\n     })\n \n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn test_process_status() {\n-        let mut status = Process::status(\"false\", []).unwrap();\n+        let mut status = Command::new(\"false\").status().unwrap();\n         assert!(status.matches_exit_status(1));\n \n-        status = Process::status(\"true\", []).unwrap();\n+        status = Command::new(\"true\").status().unwrap();\n         assert!(status.success());\n     })\n \n     iotest!(fn test_process_output_fail_to_start() {\n-        match Process::output(\"/no-binary-by-this-name-should-exist\", []) {\n+        match Command::new(\"/no-binary-by-this-name-should-exist\").output() {\n             Err(e) => assert_eq!(e.kind, FileNotFound),\n             Ok(..) => fail!()\n         }\n     })\n \n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn test_process_output_output() {\n-\n         let ProcessOutput {status, output, error}\n-             = Process::output(\"echo\", [\"hello\".to_owned()]).unwrap();\n+             = Command::new(\"echo\").arg(\"hello\").output().unwrap();\n         let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n         assert!(status.success());\n@@ -685,7 +692,7 @@ mod tests {\n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn test_process_output_error() {\n         let ProcessOutput {status, output, error}\n-             = Process::output(\"mkdir\", [\".\".to_owned()]).unwrap();\n+             = Command::new(\"mkdir\").arg(\".\").output().unwrap();\n \n         assert!(status.matches_exit_status(1));\n         assert_eq!(output, Vec::new());\n@@ -694,21 +701,20 @@ mod tests {\n \n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn test_finish_once() {\n-        let mut prog = Process::new(\"false\", []).unwrap();\n+        let mut prog = Command::new(\"false\").spawn().unwrap();\n         assert!(prog.wait().unwrap().matches_exit_status(1));\n     })\n \n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn test_finish_twice() {\n-        let mut prog = Process::new(\"false\", []).unwrap();\n+        let mut prog = Command::new(\"false\").spawn().unwrap();\n         assert!(prog.wait().unwrap().matches_exit_status(1));\n         assert!(prog.wait().unwrap().matches_exit_status(1));\n     })\n \n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn test_wait_with_output_once() {\n-\n-        let prog = Process::new(\"echo\", [\"hello\".to_owned()]).unwrap();\n+        let prog = Command::new(\"echo\").arg(\"hello\").spawn().unwrap();\n         let ProcessOutput {status, output, error} = prog.wait_with_output().unwrap();\n         let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n@@ -721,36 +727,26 @@ mod tests {\n     })\n \n     #[cfg(unix,not(target_os=\"android\"))]\n-    pub fn run_pwd(dir: Option<&Path>) -> Process {\n-        Process::configure(ProcessConfig {\n-            program: \"pwd\",\n-            cwd: dir,\n-            .. ProcessConfig::new()\n-        }).unwrap()\n+    pub fn pwd_cmd() -> Command {\n+        Command::new(\"pwd\")\n     }\n     #[cfg(target_os=\"android\")]\n-    pub fn run_pwd(dir: Option<&Path>) -> Process {\n-        Process::configure(ProcessConfig {\n-            program: \"/system/bin/sh\",\n-            args: &[\"-c\".to_owned(),\"pwd\".to_owned()],\n-            cwd: dir.map(|a| &*a),\n-            .. ProcessConfig::new()\n-        }).unwrap()\n+    pub fn pwd_cmd() -> Command {\n+        let mut cmd = Command::new(\"/system/bin/sh\");\n+        cmd.arg(\"-c\").arg(\"pwd\");\n+        cmd\n     }\n \n     #[cfg(windows)]\n-    pub fn run_pwd(dir: Option<&Path>) -> Process {\n-        Process::configure(ProcessConfig {\n-            program: \"cmd\",\n-            args: &[\"/c\".to_owned(), \"cd\".to_owned()],\n-            cwd: dir.map(|a| &*a),\n-            .. ProcessConfig::new()\n-        }).unwrap()\n+    pub fn pwd_cmd() -> Command {\n+        let mut cmd = Command::new(\"cmd\");\n+        cmd.arg(\"/c\").arg(\"cd\");\n+        cmd\n     }\n \n     iotest!(fn test_keep_current_working_dir() {\n         use os;\n-        let prog = run_pwd(None);\n+        let prog = pwd_cmd().spawn().unwrap();\n \n         let output = str::from_utf8(prog.wait_with_output().unwrap()\n                                         .output.as_slice()).unwrap().to_owned();\n@@ -769,7 +765,7 @@ mod tests {\n         // test changing to the parent of os::getcwd() because we know\n         // the path exists (and os::getcwd() is not expected to be root)\n         let parent_dir = os::getcwd().dir_path();\n-        let prog = run_pwd(Some(&parent_dir));\n+        let prog = pwd_cmd().cwd(&parent_dir).spawn().unwrap();\n \n         let output = str::from_utf8(prog.wait_with_output().unwrap()\n                                         .output.as_slice()).unwrap().to_owned();\n@@ -783,39 +779,29 @@ mod tests {\n     })\n \n     #[cfg(unix,not(target_os=\"android\"))]\n-    pub fn run_env(env: Option<~[(~str, ~str)]>) -> Process {\n-        Process::configure(ProcessConfig {\n-            program: \"env\",\n-            env: env.as_ref().map(|e| e.as_slice()),\n-            .. ProcessConfig::new()\n-        }).unwrap()\n+    pub fn env_cmd() -> Command {\n+        Command::new(\"env\")\n     }\n     #[cfg(target_os=\"android\")]\n-    pub fn run_env(env: Option<~[(~str, ~str)]>) -> Process {\n-        Process::configure(ProcessConfig {\n-            program: \"/system/bin/sh\",\n-            args: &[\"-c\".to_owned(),\"set\".to_owned()],\n-            env: env.as_ref().map(|e| e.as_slice()),\n-            .. ProcessConfig::new()\n-        }).unwrap()\n+    pub fn env_cmd() -> Command {\n+        let mut cmd = Command::new(\"/system/bin/sh\");\n+        cmd.arg(\"-c\").arg(\"set\");\n+        cmd\n     }\n \n     #[cfg(windows)]\n-    pub fn run_env(env: Option<~[(~str, ~str)]>) -> Process {\n-        Process::configure(ProcessConfig {\n-            program: \"cmd\",\n-            args: &[\"/c\".to_owned(), \"set\".to_owned()],\n-            env: env.as_ref().map(|e| e.as_slice()),\n-            .. ProcessConfig::new()\n-        }).unwrap()\n+    pub fn env_cmd() -> Command {\n+        let mut cmd = Command::new(\"cmd\");\n+        cmd.arg(\"/c\").arg(\"set\");\n+        cmd\n     }\n \n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn test_inherit_env() {\n         use os;\n         if running_on_valgrind() { return; }\n \n-        let prog = run_env(None);\n+        let prog = env_cmd().spawn().unwrap();\n         let output = str::from_utf8(prog.wait_with_output().unwrap()\n                                         .output.as_slice()).unwrap().to_owned();\n \n@@ -830,7 +816,7 @@ mod tests {\n         use os;\n         if running_on_valgrind() { return; }\n \n-        let prog = run_env(None);\n+        let mut prog = env_cmd().spawn().unwrap();\n         let output = str::from_utf8(prog.wait_with_output()\n                                         .unwrap().output.as_slice())\n                                    .unwrap().to_owned();\n@@ -846,9 +832,8 @@ mod tests {\n     })\n \n     iotest!(fn test_add_to_env() {\n-        let new_env = box [(\"RUN_TEST_NEW_ENV\".to_owned(), \"123\".to_owned())];\n-\n-        let prog = run_env(Some(new_env));\n+        let new_env = box [(\"RUN_TEST_NEW_ENV\", \"123\")];\n+        let prog = env_cmd().env(new_env).spawn().unwrap();\n         let result = prog.wait_with_output().unwrap();\n         let output = str::from_utf8_lossy(result.output.as_slice()).into_owned();\n \n@@ -858,14 +843,14 @@ mod tests {\n \n     #[cfg(unix)]\n     pub fn sleeper() -> Process {\n-        Process::new(\"sleep\", [\"1000\".to_owned()]).unwrap()\n+        Command::new(\"sleep\").arg(\"1000\").spawn().unwrap()\n     }\n     #[cfg(windows)]\n     pub fn sleeper() -> Process {\n         // There's a `timeout` command on windows, but it doesn't like having\n         // its output piped, so instead just ping ourselves a few times with\n         // gaps inbetweeen so we're sure this process is alive for awhile\n-        Process::new(\"ping\", [\"127.0.0.1\".to_owned(), \"-n\".to_owned(), \"1000\".to_owned()]).unwrap()\n+        Command::new(\"ping\").arg(\"127.0.0.1\").arg(\"-n\").arg(\"1000\").spawn().unwrap()\n     }\n \n     iotest!(fn test_kill() {"}, {"sha": "4f7132dc6e442238af1107a7abba4a7658239d48", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -79,11 +79,18 @@ impl FromStr for Path {\n     }\n }\n \n+// FIXME (#12938): Until DST lands, we cannot decompose &str into & and str, so\n+// we cannot usefully take ToCStr arguments by reference (without forcing an\n+// additional & around &str). So we are instead temporarily adding an instance\n+// for &Path, so that we can take ToCStr as owned. When DST lands, the &Path\n+// instance should be removed, and arguments bound by ToCStr should be passed by\n+// reference.\n+\n impl ToCStr for Path {\n     #[inline]\n     fn to_c_str(&self) -> CString {\n         // The Path impl guarantees no internal NUL\n-        unsafe { self.as_vec().to_c_str_unchecked() }\n+        unsafe { self.to_c_str_unchecked() }\n     }\n \n     #[inline]\n@@ -92,6 +99,18 @@ impl ToCStr for Path {\n     }\n }\n \n+impl<'a> ToCStr for &'a Path {\n+    #[inline]\n+    fn to_c_str(&self) -> CString {\n+        (*self).to_c_str()\n+    }\n+\n+    #[inline]\n+    unsafe fn to_c_str_unchecked(&self) -> CString {\n+        (*self).to_c_str_unchecked()\n+    }\n+}\n+\n impl<S: Writer> ::hash::Hash<S> for Path {\n     #[inline]\n     fn hash(&self, state: &mut S) {"}, {"sha": "176788edcc46650720f705a303e5d5c7f19ec44b", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -103,11 +103,18 @@ impl FromStr for Path {\n     }\n }\n \n+// FIXME (#12938): Until DST lands, we cannot decompose &str into & and str, so\n+// we cannot usefully take ToCStr arguments by reference (without forcing an\n+// additional & around &str). So we are instead temporarily adding an instance\n+// for &Path, so that we can take ToCStr as owned. When DST lands, the &Path\n+// instance should be removed, and arguments bound by ToCStr should be passed by\n+// reference.\n+\n impl ToCStr for Path {\n     #[inline]\n     fn to_c_str(&self) -> CString {\n-        // The Path impl guarantees no embedded NULs\n-        unsafe { self.as_vec().to_c_str_unchecked() }\n+        // The Path impl guarantees no internal NUL\n+        unsafe { self.to_c_str_unchecked() }\n     }\n \n     #[inline]\n@@ -116,6 +123,18 @@ impl ToCStr for Path {\n     }\n }\n \n+impl<'a> ToCStr for &'a Path {\n+    #[inline]\n+    fn to_c_str(&self) -> CString {\n+        (*self).to_c_str()\n+    }\n+\n+    #[inline]\n+    unsafe fn to_c_str_unchecked(&self) -> CString {\n+        (*self).to_c_str_unchecked()\n+    }\n+}\n+\n impl<S: Writer> ::hash::Hash<S> for Path {\n     #[inline]\n     fn hash(&self, state: &mut S) {"}, {"sha": "a6c60df2642362798c899343eddcfa535c5bc8f2", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -29,7 +29,7 @@ use ai = io::net::addrinfo;\n use io;\n use io::IoResult;\n use io::net::ip::{IpAddr, SocketAddr};\n-use io::process::{ProcessConfig, ProcessExit};\n+use io::process::{StdioContainer, ProcessExit};\n use io::signal::Signum;\n use io::{FileMode, FileAccess, FileStat, FilePermission};\n use io::{SeekStyle};\n@@ -87,6 +87,61 @@ pub enum CloseBehavior {\n     CloseAsynchronously,\n }\n \n+/// Data needed to spawn a process. Serializes the `std::io::process::Command`\n+/// builder.\n+pub struct ProcessConfig<'a> {\n+    /// Path to the program to run.\n+    pub program: &'a CString,\n+\n+    /// Arguments to pass to the program (doesn't include the program itself).\n+    pub args: &'a [CString],\n+\n+    /// Optional environment to specify for the program. If this is None, then\n+    /// it will inherit the current process's environment.\n+    pub env: Option<&'a [(CString, CString)]>,\n+\n+    /// Optional working directory for the new process. If this is None, then\n+    /// the current directory of the running process is inherited.\n+    pub cwd: Option<&'a CString>,\n+\n+    /// Configuration for the child process's stdin handle (file descriptor 0).\n+    /// This field defaults to `CreatePipe(true, false)` so the input can be\n+    /// written to.\n+    pub stdin: StdioContainer,\n+\n+    /// Configuration for the child process's stdout handle (file descriptor 1).\n+    /// This field defaults to `CreatePipe(false, true)` so the output can be\n+    /// collected.\n+    pub stdout: StdioContainer,\n+\n+    /// Configuration for the child process's stdout handle (file descriptor 2).\n+    /// This field defaults to `CreatePipe(false, true)` so the output can be\n+    /// collected.\n+    pub stderr: StdioContainer,\n+\n+    /// Any number of streams/file descriptors/pipes may be attached to this\n+    /// process. This list enumerates the file descriptors and such for the\n+    /// process to be spawned, and the file descriptors inherited will start at\n+    /// 3 and go to the length of this array. The first three file descriptors\n+    /// (stdin/stdout/stderr) are configured with the `stdin`, `stdout`, and\n+    /// `stderr` fields.\n+    pub extra_io: &'a [StdioContainer],\n+\n+    /// Sets the child process's user id. This translates to a `setuid` call in\n+    /// the child process. Setting this value on windows will cause the spawn to\n+    /// fail. Failure in the `setuid` call on unix will also cause the spawn to\n+    /// fail.\n+    pub uid: Option<uint>,\n+\n+    /// Similar to `uid`, but sets the group id of the child process. This has\n+    /// the same semantics as the `uid` field.\n+    pub gid: Option<uint>,\n+\n+    /// If true, the child process is spawned in a detached state. On unix, this\n+    /// means that the child is the leader of a new process group.\n+    pub detach: bool,\n+}\n+\n pub struct LocalIo<'a> {\n     factory: &'a mut IoFactory,\n }\n@@ -189,7 +244,7 @@ pub trait IoFactory {\n \n     // misc\n     fn timer_init(&mut self) -> IoResult<Box<RtioTimer:Send>>;\n-    fn spawn(&mut self, config: ProcessConfig)\n+    fn spawn(&mut self, cfg: ProcessConfig)\n             -> IoResult<(Box<RtioProcess:Send>,\n                          Vec<Option<Box<RtioPipe:Send>>>)>;\n     fn kill(&mut self, pid: libc::pid_t, signal: int) -> IoResult<()>;"}, {"sha": "68bfde84e2a2dc76966e272e5823854a55e323e6", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -45,12 +45,22 @@ impl Drop for DynamicLibrary {\n }\n \n impl DynamicLibrary {\n+    // FIXME (#12938): Until DST lands, we cannot decompose &str into\n+    // & and str, so we cannot usefully take ToCStr arguments by\n+    // reference (without forcing an additional & around &str). So we\n+    // are instead temporarily adding an instance for &Path, so that\n+    // we can take ToCStr as owned. When DST lands, the &Path instance\n+    // should be removed, and arguments bound by ToCStr should be\n+    // passed by reference. (Here: in the `open` method.)\n+\n     /// Lazily open a dynamic library. When passed None it gives a\n     /// handle to the calling process\n-    pub fn open(filename: Option<&path::Path>) -> Result<DynamicLibrary, ~str> {\n+    pub fn open<T: ToCStr>(filename: Option<T>)\n+                        -> Result<DynamicLibrary, ~str> {\n         unsafe {\n+            let mut filename = filename;\n             let maybe_library = dl::check_for_errors_in(|| {\n-                match filename {\n+                match filename.take() {\n                     Some(name) => dl::open_external(name),\n                     None => dl::open_internal()\n                 }\n@@ -114,7 +124,8 @@ mod test {\n     fn test_loading_cosine() {\n         // The math library does not need to be loaded since it is already\n         // statically linked in\n-        let libm = match DynamicLibrary::open(None) {\n+        let none: Option<Path> = None; // appease the typechecker\n+        let libm = match DynamicLibrary::open(none) {\n             Err(error) => fail!(\"Could not load self as module: {}\", error),\n             Ok(libm) => libm\n         };\n@@ -142,7 +153,7 @@ mod test {\n     fn test_errors_do_not_crash() {\n         // Open /dev/null as a library to get an error, and make sure\n         // that only causes an error, and not a crash.\n-        let path = GenericPath::new(\"/dev/null\");\n+        let path = Path::new(\"/dev/null\");\n         match DynamicLibrary::open(Some(&path)) {\n             Err(_) => {}\n             Ok(_) => fail!(\"Successfully opened the empty library.\")\n@@ -157,12 +168,11 @@ mod test {\n pub mod dl {\n     use c_str::ToCStr;\n     use libc;\n-    use path;\n     use ptr;\n     use str;\n     use result::*;\n \n-    pub unsafe fn open_external(filename: &path::Path) -> *u8 {\n+    pub unsafe fn open_external<T: ToCStr>(filename: T) -> *u8 {\n         filename.with_c_str(|raw_name| {\n             dlopen(raw_name, Lazy as libc::c_int) as *u8\n         })\n@@ -221,13 +231,16 @@ pub mod dl {\n pub mod dl {\n     use libc;\n     use os;\n-    use path::GenericPath;\n-    use path;\n     use ptr;\n     use result::{Ok, Err, Result};\n+    use str;\n+    use c_str::ToCStr;\n \n-    pub unsafe fn open_external(filename: &path::Path) -> *u8 {\n-        os::win32::as_utf16_p(filename.as_str().unwrap(), |raw_name| {\n+    pub unsafe fn open_external<T: ToCStr>(filename: T) -> *u8 {\n+        // Windows expects Unicode data\n+        let filename_cstr = filename.to_c_str();\n+        let filename_str = str::from_utf8(filename_cstr.as_bytes_no_nul()).unwrap();\n+        os::win32::as_utf16_p(filename_str, |raw_name| {\n             LoadLibraryW(raw_name as *libc::c_void) as *u8\n         })\n     }"}, {"sha": "98fbb00f4378d37d8f99806b43d3eb2c2c41df66", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -488,7 +488,7 @@ impl<'a, T:Send +\n #[cfg(not(target_os=\"android\"))] // FIXME(#10455)\n fn test() {\n     use std::os;\n-    use std::io::{fs, Process};\n+    use std::io::{fs, Command};\n     use std::str::from_utf8;\n \n     // Create a path to a new file 'filename' in the directory in which\n@@ -522,10 +522,7 @@ fn test() {\n         prep.exec(proc(_exe) {\n             let out = make_path(\"foo.o\".to_strbuf());\n             let compiler = if cfg!(windows) {\"gcc\"} else {\"cc\"};\n-            // FIXME (#9639): This needs to handle non-utf8 paths\n-            Process::status(compiler, [pth.as_str().unwrap().to_owned(),\n-                                    \"-o\".to_owned(),\n-                                    out.as_str().unwrap().to_owned()]).unwrap();\n+            Command::new(compiler).arg(pth).arg(\"-o\").arg(out.clone()).status().unwrap();\n \n             let _proof_of_concept = subcx.prep(\"subfn\");\n             // Could run sub-rules inside here."}, {"sha": "4ae0b6f14f59d4fcd009a629edf46aa8f0e38b55", "filename": "src/test/auxiliary/linkage-visibility.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -27,7 +27,8 @@ fn bar() { }\n fn baz() { }\n \n pub fn test() {\n-    let lib = DynamicLibrary::open(None).unwrap();\n+    let none: Option<Path> = None; // appease the typechecker\n+    let lib = DynamicLibrary::open(none).unwrap();\n     unsafe {\n         assert!(lib.symbol::<int>(\"foo\").is_ok());\n         assert!(lib.symbol::<int>(\"baz\").is_err());"}, {"sha": "219eb1a3ebd459da0c14e9a4d93d91cead169934", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -12,7 +12,7 @@ extern crate rand;\n use rand::{task_rng, Rng};\n \n use std::{char, os, str};\n-use std::io::{File, Process};\n+use std::io::{File, Command};\n \n // creates unicode_input_multiple_files_{main,chars}.rs, where the\n // former imports the latter. `_chars` just contains an indentifier\n@@ -40,7 +40,6 @@ fn main() {\n     let tmpdir = Path::new(args.get(2).as_slice());\n \n     let main_file = tmpdir.join(\"unicode_input_multiple_files_main.rs\");\n-    let main_file_str = main_file.as_str().unwrap();\n     {\n         let _ = File::create(&main_file).unwrap()\n             .write_str(\"mod unicode_input_multiple_files_chars;\");\n@@ -57,7 +56,9 @@ fn main() {\n \n         // rustc is passed to us with --out-dir and -L etc., so we\n         // can't exec it directly\n-        let result = Process::output(\"sh\", [\"-c\".to_owned(), rustc + \" \" + main_file_str]).unwrap();\n+        let result = Command::new(\"sh\")\n+                             .arg(\"-c\").arg(rustc + \" \" + main_file.as_str().unwrap())\n+                             .output().unwrap();\n         let err = str::from_utf8_lossy(result.error.as_slice());\n \n         // positive test so that this test will be updated when the"}, {"sha": "2bb89d7621320c2634c276c184f5d3bebbb22ed7", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -12,7 +12,7 @@ extern crate rand;\n use rand::{task_rng, Rng};\n \n use std::{char, os, str};\n-use std::io::{File, Process};\n+use std::io::{File, Command};\n \n // creates a file with `fn main() { <random ident> }` and checks the\n // compiler emits a span of the appropriate length (for the\n@@ -37,9 +37,7 @@ fn main() {\n     let args = os::args();\n     let rustc = args.get(1).as_slice();\n     let tmpdir = Path::new(args.get(2).as_slice());\n-\n     let main_file = tmpdir.join(\"span_main.rs\");\n-    let main_file_str = main_file.as_str().unwrap();\n \n     for _ in range(0, 100) {\n         let n = task_rng().gen_range(3u, 20);\n@@ -53,7 +51,9 @@ fn main() {\n \n         // rustc is passed to us with --out-dir and -L etc., so we\n         // can't exec it directly\n-        let result = Process::output(\"sh\", [\"-c\".to_owned(), rustc + \" \" + main_file_str]).unwrap();\n+        let result = Command::new(\"sh\")\n+                             .arg(\"-c\").arg(rustc + \" \" + main_file.as_str().unwrap())\n+                             .output().unwrap();\n \n         let err = str::from_utf8_lossy(result.error.as_slice());\n "}, {"sha": "25df896ec15a12caff393dde26a9aedb00a746a0", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -14,7 +14,7 @@\n extern crate native;\n \n use std::os;\n-use std::io::process::{Process, ProcessConfig};\n+use std::io::process::Command;\n use std::unstable::finally::Finally;\n use std::str;\n \n@@ -48,52 +48,31 @@ fn runtest(me: &str) {\n     env.push((\"RUST_BACKTRACE\".to_strbuf(), \"1\".to_strbuf()));\n \n     // Make sure that the stack trace is printed\n-    let env = env.iter()\n-                 .map(|&(ref k, ref v)| (k.to_owned(), v.to_owned()))\n-                 .collect::<Vec<_>>();\n-    let mut p = Process::configure(ProcessConfig {\n-        program: me,\n-        args: [\"fail\".to_owned()],\n-        env: Some(env.as_slice()),\n-        .. ProcessConfig::new()\n-    }).unwrap();\n+    let mut p = Command::new(me).arg(\"fail\").env(env.as_slice()).spawn().unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();\n     assert!(s.contains(\"stack backtrace\") && s.contains(\"foo::h\"),\n             \"bad output: {}\", s);\n \n     // Make sure the stack trace is *not* printed\n-    let mut p = Process::configure(ProcessConfig {\n-        program: me,\n-        args: [\"fail\".to_owned()],\n-        .. ProcessConfig::new()\n-    }).unwrap();\n+    let mut p = Command::new(me).arg(\"fail\").spawn().unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();\n     assert!(!s.contains(\"stack backtrace\") && !s.contains(\"foo::h\"),\n             \"bad output2: {}\", s);\n \n     // Make sure a stack trace is printed\n-    let mut p = Process::configure(ProcessConfig {\n-        program: me,\n-        args: [\"double-fail\".to_owned()],\n-        .. ProcessConfig::new()\n-    }).unwrap();\n+    let mut p = Command::new(me).arg(\"double-fail\").spawn().unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();\n     assert!(s.contains(\"stack backtrace\") && s.contains(\"double::h\"),\n             \"bad output3: {}\", s);\n \n     // Make sure a stack trace isn't printed too many times\n-    let mut p = Process::configure(ProcessConfig {\n-        program: me,\n-        args: [\"double-fail\".to_owned()],\n-        env: Some(env.as_slice()),\n-        .. ProcessConfig::new()\n-    }).unwrap();\n+    let mut p = Command::new(me).arg(\"double-fail\").env(env.as_slice()).spawn().unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();"}, {"sha": "a0d4785d8d2be420b79ff024251575dfe953815e", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -22,7 +22,7 @@ extern crate native;\n extern crate green;\n extern crate rustuv;\n \n-use std::io::Process;\n+use std::io::{Process, Command};\n \n macro_rules! succeed( ($e:expr) => (\n     match $e { Ok(..) => {}, Err(e) => fail!(\"failure: {}\", e) }\n@@ -36,7 +36,7 @@ macro_rules! iotest (\n             use std::io::timer;\n             use libc;\n             use std::str;\n-            use std::io::process::{Process, ProcessOutput};\n+            use std::io::process::Command;\n             use native;\n             use super::*;\n \n@@ -68,14 +68,14 @@ iotest!(fn test_destroy_once() {\n \n #[cfg(unix)]\n pub fn sleeper() -> Process {\n-    Process::new(\"sleep\", [\"1000\".to_owned()]).unwrap()\n+    Command::new(\"sleep\").arg(\"1000\").spawn().unwrap()\n }\n #[cfg(windows)]\n pub fn sleeper() -> Process {\n     // There's a `timeout` command on windows, but it doesn't like having\n     // its output piped, so instead just ping ourselves a few times with\n     // gaps inbetweeen so we're sure this process is alive for awhile\n-    Process::new(\"ping\", [\"127.0.0.1\".to_owned(), \"-n\".to_owned(), \"1000\".to_owned()]).unwrap()\n+    Command::new(\"ping\").arg(\"127.0.0.1\").arg(\"-n\").arg(\"1000\").spawn().unwrap()\n }\n \n iotest!(fn test_destroy_twice() {\n@@ -85,7 +85,7 @@ iotest!(fn test_destroy_twice() {\n })\n \n pub fn test_destroy_actually_kills(force: bool) {\n-    use std::io::process::{Process, ProcessOutput, ExitStatus, ExitSignal};\n+    use std::io::process::{Command, ProcessOutput, ExitStatus, ExitSignal};\n     use std::io::timer;\n     use libc;\n     use std::str;\n@@ -100,7 +100,7 @@ pub fn test_destroy_actually_kills(force: bool) {\n     static BLOCK_COMMAND: &'static str = \"cmd\";\n \n     // this process will stay alive indefinitely trying to read from stdin\n-    let mut p = Process::new(BLOCK_COMMAND, []).unwrap();\n+    let mut p = Command::new(BLOCK_COMMAND).spawn().unwrap();\n \n     assert!(p.signal(0).is_ok());\n "}, {"sha": "dd513547212666c51ef9303e325051a4e88b42a7", "filename": "src/test/run-pass/issue-10626.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10626.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -18,7 +18,7 @@ use std::io::process;\n pub fn main () {\n     let args = os::args();\n     let args = args.as_slice();\n-    if args.len() > 1 && args[1] == \"child\".to_owned() {\n+    if args.len() > 1 && args[1].as_slice() == \"child\" {\n         for _ in range(0, 1000) {\n             println!(\"hello?\");\n         }\n@@ -28,14 +28,7 @@ pub fn main () {\n         return;\n     }\n \n-    let config = process::ProcessConfig {\n-        program : args[0].as_slice(),\n-        args : &[\"child\".to_owned()],\n-        stdout: process::Ignored,\n-        stderr: process::Ignored,\n-        .. process::ProcessConfig::new()\n-    };\n-\n-    let mut p = process::Process::configure(config).unwrap();\n-    println!(\"{}\", p.wait());\n+    let mut p = process::Command::new(args[0].as_slice());\n+    p.arg(\"child\").stdout(process::Ignored).stderr(process::Ignored);\n+    println!(\"{}\", p.spawn().unwrap().wait());\n }"}, {"sha": "36fc48432a8217693eab78cc7895d34a84c28d0f", "filename": "src/test/run-pass/issue-13304.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13304.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -50,10 +50,8 @@ fn main() {\n fn parent(flavor: StrBuf) {\n     let args = os::args();\n     let args = args.as_slice();\n-    let mut p = io::Process::new(args[0].as_slice(), [\n-        \"child\".to_owned(),\n-        flavor.to_owned()\n-    ]).unwrap();\n+    let mut p = io::process::Command::new(args[0].as_slice())\n+                                     .arg(\"child\").arg(flavor).spawn().unwrap();\n     p.stdin.get_mut_ref().write_str(\"test1\\ntest2\\ntest3\").unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(out.status.success());"}, {"sha": "06151e498f5367f7e0e3819b0bc2486a69dd9096", "filename": "src/test/run-pass/logging-separate-lines.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -16,7 +16,7 @@\n #[phase(syntax, link)]\n extern crate log;\n \n-use std::io::{Process, ProcessConfig};\n+use std::io::Command;\n use std::os;\n use std::str;\n \n@@ -30,16 +30,11 @@ fn main() {\n     }\n \n     let env = [(\"RUST_LOG\".to_owned(), \"debug\".to_owned())];\n-    let config = ProcessConfig {\n-        program: args[0].as_slice(),\n-        args: &[\"child\".to_owned()],\n-        env: Some(env.as_slice()),\n-        ..ProcessConfig::new()\n-    };\n-    let p = Process::configure(config).unwrap().wait_with_output().unwrap();\n+    let p = Command::new(args[0].as_slice())\n+                    .arg(\"child\").env(env.as_slice())\n+                    .spawn().unwrap().wait_with_output().unwrap();\n     assert!(p.status.success());\n     let mut lines = str::from_utf8(p.error.as_slice()).unwrap().lines();\n     assert!(lines.next().unwrap().contains(\"foo\"));\n     assert!(lines.next().unwrap().contains(\"bar\"));\n }\n-"}, {"sha": "1566b9ed6f19c1d467e67426794bf03966b98521", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(asm)]\n \n-use std::io::Process;\n+use std::io::process::Command;\n use std::os;\n use std::str;\n \n@@ -40,12 +40,12 @@ fn main() {\n     } else if args.len() > 1 && args[1].as_slice() == \"loud\" {\n         loud_recurse();\n     } else {\n-        let silent = Process::output(args[0], [\"silent\".to_owned()]).unwrap();\n+        let silent = Command::new(args[0].as_slice()).arg(\"silent\").output().unwrap();\n         assert!(!silent.status.success());\n         let error = str::from_utf8_lossy(silent.error.as_slice());\n         assert!(error.as_slice().contains(\"has overflowed its stack\"));\n \n-        let loud = Process::output(args[0], [\"loud\".to_owned()]).unwrap();\n+        let loud = Command::new(args[0].as_slice()).arg(\"loud\").output().unwrap();\n         assert!(!loud.status.success());\n         let error = str::from_utf8_lossy(silent.error.as_slice());\n         assert!(error.as_slice().contains(\"has overflowed its stack\"));"}, {"sha": "44ff58c151ed6a4c89184b01f1316ab0e978795c", "filename": "src/test/run-pass/process-detach.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Fprocess-detach.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Fprocess-detach.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-detach.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -24,6 +24,7 @@ extern crate rustuv;\n extern crate libc;\n \n use std::io::process;\n+use std::io::process::Command;\n use std::io::signal::{Listener, Interrupt};\n \n #[start]\n@@ -34,19 +35,12 @@ fn start(argc: int, argv: **u8) -> int {\n fn main() {\n     unsafe { libc::setsid(); }\n \n-    let config = process::ProcessConfig {\n-        program : \"/bin/sh\",\n-        args: &[\"-c\".to_owned(), \"read a\".to_owned()],\n-        detach: true,\n-        .. process::ProcessConfig::new()\n-    };\n-\n     // we shouldn't die because of an interrupt\n     let mut l = Listener::new();\n     l.register(Interrupt).unwrap();\n \n     // spawn the child\n-    let mut p = process::Process::configure(config).unwrap();\n+    let mut p = Command::new(\"/bin/sh\").arg(\"-c\").arg(\"read a\").detached().spawn().unwrap();\n \n     // send an interrupt to everyone in our process group\n     unsafe { libc::funcs::posix88::signal::kill(0, libc::SIGINT); }\n@@ -59,4 +53,3 @@ fn main() {\n         process::ExitSignal(..) => fail!()\n     }\n }\n-"}, {"sha": "5e1f9bbaf0cfd1291cc4214ef0435f600b3f762c", "filename": "src/test/run-pass/process-spawn-with-unicode-params.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -20,8 +20,7 @@ extern crate native;\n \n use std::io;\n use std::io::fs;\n-use std::io::process::Process;\n-use std::io::process::ProcessConfig;\n+use std::io::Command;\n use std::os;\n use std::path::Path;\n \n@@ -56,13 +55,11 @@ fn main() {\n         assert!(fs::copy(&my_path, &child_path).is_ok());\n \n         // run child\n-        let p = Process::configure(ProcessConfig {\n-            program: child_path.as_str().unwrap(),\n-            args: [arg.to_owned()],\n-            cwd: Some(&cwd),\n-            env: Some(my_env.append_one(env).as_slice()),\n-            .. ProcessConfig::new()\n-        }).unwrap().wait_with_output().unwrap();\n+        let p = Command::new(&child_path)\n+                        .arg(arg)\n+                        .cwd(&cwd)\n+                        .env(my_env.append_one(env).as_slice())\n+                        .spawn().unwrap().wait_with_output().unwrap();\n \n         // display the output\n         assert!(io::stdout().write(p.output.as_slice()).is_ok());"}, {"sha": "174a441ace57547879e1eb2a9a441cd1b7e5cfbc", "filename": "src/test/run-pass/signal-exit-status.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -21,7 +21,7 @@\n // ignore-win32\n \n use std::os;\n-use std::io::process::{Process, ExitSignal, ExitStatus};\n+use std::io::process::{Command, ExitSignal, ExitStatus};\n \n pub fn main() {\n     let args = os::args();\n@@ -30,7 +30,7 @@ pub fn main() {\n         // Raise a segfault.\n         unsafe { *(0 as *mut int) = 0; }\n     } else {\n-        let status = Process::status(args[0], [\"signal\".to_owned()]).unwrap();\n+        let status = Command::new(args[0].as_slice()).arg(\"signal\").status().unwrap();\n         // Windows does not have signal, so we get exit status 0xC0000028 (STATUS_BAD_STACK).\n         match status {\n             ExitSignal(_) if cfg!(unix) => {},\n@@ -39,4 +39,3 @@ pub fn main() {\n         }\n     }\n }\n-"}, {"sha": "8e2cfa30066495e00b7241d4022bb0b4ae7da155", "filename": "src/test/run-pass/sigpipe-should-be-ignored.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs?ref=fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "patch": "@@ -12,7 +12,8 @@\n // doesn't die in a ball of fire, but rather it's gracefully handled.\n \n use std::os;\n-use std::io::{PipeStream, Process};\n+use std::io::PipeStream;\n+use std::io::Command;\n \n fn test() {\n     let os::Pipe { input, out } = os::pipe();\n@@ -30,6 +31,7 @@ fn main() {\n         return test();\n     }\n \n-    let mut p = Process::new(args[0], [\"test\".to_owned()]).unwrap();\n+    let mut p = Command::new(args[0].as_slice())\n+                        .arg(\"test\").spawn().unwrap();\n     assert!(p.wait().unwrap().success());\n }"}]}