{"sha": "29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YTNjNGQyOGM2N2NhOGI4MDhhNmU5MWRlNTMwYjNkOTA5ZDRkYjM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-02T14:59:01Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-02T14:59:01Z"}, "message": "Produce backtraces for miri internals", "tree": {"sha": "8c2574262fbcca804695483e3a923985798daf81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c2574262fbcca804695483e3a923985798daf81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "html_url": "https://github.com/rust-lang/rust/commit/29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf318b1f6feef3dc7115bb767d180cd9308fc052", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf318b1f6feef3dc7115bb767d180cd9308fc052", "html_url": "https://github.com/rust-lang/rust/commit/cf318b1f6feef3dc7115bb767d180cd9308fc052"}], "stats": {"total": 478, "additions": 306, "deletions": 172}, "files": [{"sha": "e33d99ed4496cbe72f92e1f04628aaf16990b765", "filename": "Cargo.lock", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -2,6 +2,7 @@\n name = \"rustc_miri\"\n version = \"0.1.0\"\n dependencies = [\n+ \"backtrace 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -17,6 +18,29 @@ dependencies = [\n  \"memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"backtrace\"\n+version = \"0.3.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"backtrace-sys 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.28 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"backtrace-sys\"\n+version = \"0.1.12\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.28 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"byteorder\"\n version = \"1.1.0\"\n@@ -32,6 +56,11 @@ dependencies = [\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"cfg-if\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"compiletest_rs\"\n version = \"0.2.8\"\n@@ -41,6 +70,15 @@ dependencies = [\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"dbghelp-sys\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"dtoa\"\n version = \"0.4.1\"\n@@ -55,11 +93,25 @@ dependencies = [\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"gcc\"\n+version = \"0.3.51\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"itoa\"\n version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"kernel32-sys\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"lazy_static\"\n version = \"0.2.8\"\n@@ -131,6 +183,11 @@ name = \"regex-syntax\"\n version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"rustc-demangle\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"rustc-serialize\"\n version = \"0.3.24\"\n@@ -221,14 +278,30 @@ name = \"void\"\n version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"winapi\"\n+version = \"0.2.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"winapi-build\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [metadata]\n \"checksum aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"500909c4f87a9e52355b26626d890833e9e1d53ac566db76c36faa984b889699\"\n+\"checksum backtrace 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"72f9b4182546f4b04ebc4ab7f84948953a118bd6021a1b6a6c909e3e94f6be76\"\n+\"checksum backtrace-sys 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"afccc5772ba333abccdf60d55200fa3406f8c59dcf54d5f7998c9107d3799c7c\"\n \"checksum byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff81738b726f5d099632ceaffe7fb65b90212e8dce59d518729e7e8634032d3d\"\n \"checksum cargo_metadata 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be1057b8462184f634c3a208ee35b0f935cfd94b694b26deadccd98732088d7b\"\n+\"checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de\"\n \"checksum compiletest_rs 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"617b23d0ed4f57b3bcff6b5fe0a78f0010f1efb636298317665a960b6dbc0533\"\n+\"checksum dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"97590ba53bcb8ac28279161ca943a924d1fd4a8fb3fa63302591647c4fc5b850\"\n \"checksum dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"80c8b71fd71146990a9742fc06dcbbde19161a267e0ad4e572c35162f4578c90\"\n \"checksum env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ddf21e73e016298f5cb37d6ef8e8da8e39f91f9ec8b0df44b7deb16a9f8cd5b\"\n+\"checksum gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\" = \"120d07f202dcc3f72859422563522b66fe6463a4c513df062874daad05f85f0a\"\n \"checksum itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb2f404fbc66fd9aac13e998248505e7ecb2ad8e44ab6388684c5fb11c6c251c\"\n+\"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n \"checksum lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b37545ab726dd833ec6420aaba8231c5b320814b9029ad585555d2a03e94fbf\"\n \"checksum libc 0.2.28 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb7b49972ee23d8aa1026c365a5b440ba08e35075f18c459980c7395c221ec48\"\n \"checksum log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"880f77541efa6e5cc74e76910c9884d9859683118839d6a1dc3b11e63512565b\"\n@@ -238,6 +311,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n \"checksum regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1731164734096285ec2a5ec7fea5248ae2f5485b3feeb0115af4fda2183b2d1b\"\n \"checksum regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad890a5eef7953f55427c50575c680c42841653abd2b028b68cd223d157f62db\"\n+\"checksum rustc-demangle 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3058a43ada2c2d0b92b3ae38007a2d0fa5e9db971be260e0171408a4ff471c95\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n \"checksum serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f7726f29ddf9731b17ff113c461e362c381d9d69433f79de4f3dd572488823e9\"\n \"checksum serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cf823e706be268e73e7747b147aa31c8f633ab4ba31f115efb57e5047c3a76dd\"\n@@ -250,3 +324,5 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"382810877fe448991dfc7f0dd6e3ae5d58088fd0ea5e35189655f84e6814fa56\"\n \"checksum utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"662fab6525a98beff2921d7f61a39e7d59e0b425ebc7d0d9e66d316e55124122\"\n \"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n+\"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n+\"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\""}, {"sha": "81db48fe1296b4a9417f12e6fb244abe92c3414e", "filename": "miri/fn_call.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/miri%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/miri%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ffn_call.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n \n         let mir = match self.load_mir(instance.def) {\n             Ok(mir) => mir,\n-            Err(EvalError::NoMirFor(path)) => {\n+            Err(EvalError{ kind: EvalErrorKind::NoMirFor(path), ..} ) => {\n                 self.call_missing_fn(instance, destination, arg_operands, sig, path)?;\n                 return Ok(true);\n             },\n@@ -133,8 +133,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 // is called if a `HashMap` is created the regular way.\n                 match self.value_to_primval(args[0], usize)?.to_u64()? {\n                     318 |\n-                    511 => return Err(EvalError::Unimplemented(\"miri does not support random number generators\".to_owned())),\n-                    id => return Err(EvalError::Unimplemented(format!(\"miri does not support syscall id {}\", id))),\n+                    511 => return err!(Unimplemented(\"miri does not support random number generators\".to_owned())),\n+                    id => return err!(Unimplemented(format!(\"miri does not support syscall id {}\", id))),\n                 }\n             }\n \n@@ -144,7 +144,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let symbol_name = self.memory.read_c_str(symbol)?;\n                 let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n                 let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n-                return Err(EvalError::Unimplemented(format!(\"miri does not support dynamically loading libraries (requested symbol: {})\", symbol_name)));\n+                return err!(Unimplemented(format!(\"miri does not support dynamically loading libraries (requested symbol: {})\", symbol_name)));\n             }\n \n             \"__rust_maybe_catch_panic\" => {\n@@ -167,7 +167,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     StackPopCleanup::Goto(dest_block),\n                 )?;\n \n-                let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\".to_owned()))?;\n+                let arg_local = self.frame().mir.args_iter().next().ok_or(EvalErrorKind::AbiViolation(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\".to_owned()))?;\n                 let arg_dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                 self.write_ptr(arg_dest, data, u8_ptr_ty)?;\n \n@@ -179,7 +179,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             }\n \n             \"__rust_start_panic\" => {\n-                return Err(EvalError::Panic);\n+                return err!(Panic);\n             }\n \n             \"memcmp\" => {\n@@ -342,7 +342,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if let Some(result) = result {\n                     self.write_primval(dest, result, dest_ty)?;\n                 } else {\n-                    return Err(EvalError::Unimplemented(format!(\"Unimplemented sysconf name: {}\", name)));\n+                    return err!(Unimplemented(format!(\"Unimplemented sysconf name: {}\", name)));\n                 }\n             }\n \n@@ -354,13 +354,13 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let dtor = match args[1].into_ptr(&mut self.memory)?.into_inner_primval() {\n                     PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n                     PrimVal::Bytes(0) => None,\n-                    PrimVal::Bytes(_) => return Err(EvalError::ReadBytesAsPointer),\n-                    PrimVal::Undef => return Err(EvalError::ReadUndefBytes),\n+                    PrimVal::Bytes(_) => return err!(ReadBytesAsPointer),\n+                    PrimVal::Undef => return err!(ReadUndefBytes),\n                 };\n \n                 // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n                 let key_type = self.operand_ty(&arg_operands[0]).builtin_deref(true, ty::LvaluePreference::NoPreference)\n-                                   .ok_or(EvalError::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n+                                   .ok_or(EvalErrorKind::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n                 let key_size = {\n                     let layout = self.type_layout(key_type)?;\n                     layout.size(&self.tcx.data_layout)\n@@ -369,7 +369,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 // Create key and write it into the memory where key_ptr wants it\n                 let key = self.memory.create_tls_key(dtor) as u128;\n                 if key_size.bits() < 128 && key >= (1u128 << key_size.bits() as u128) {\n-                    return Err(EvalError::OutOfTls);\n+                    return err!(OutOfTls);\n                 }\n                 // TODO: Does this need checking for alignment?\n                 self.memory.write_uint(key_ptr.to_ptr()?, key, key_size.bytes())?;\n@@ -407,7 +407,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             },\n \n             _ => {\n-                return Err(EvalError::Unimplemented(format!(\"can't call C ABI function: {}\", link_name)));\n+                return err!(Unimplemented(format!(\"can't call C ABI function: {}\", link_name)));\n             }\n         }\n \n@@ -452,7 +452,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let path = path.iter()\n                     .map(|&s| s.to_owned())\n                     .collect();\n-                EvalError::PathNotFound(path)\n+                EvalErrorKind::PathNotFound(path).into()\n             })\n     }\n \n@@ -467,12 +467,12 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n         // In some cases in non-MIR libstd-mode, not having a destination is legit.  Handle these early.\n         match &path[..] {\n             \"std::panicking::rust_panic_with_hook\" |\n-            \"std::rt::begin_panic_fmt\" => return Err(EvalError::Panic),\n+            \"std::rt::begin_panic_fmt\" => return err!(Panic),\n             _ => {},\n         }\n \n         let dest_ty = sig.output();\n-        let (dest, dest_block) = destination.ok_or_else(|| EvalError::NoMirFor(path.clone()))?;\n+        let (dest, dest_block) = destination.ok_or_else(|| EvalErrorKind::NoMirFor(path.clone()))?;\n \n         if sig.abi == Abi::C {\n             // An external C function\n@@ -495,10 +495,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n                 let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n                 if size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n+                    return err!(HeapAllocZeroBytes);\n                 }\n                 if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 let ptr = self.memory.allocate(size, align, Kind::Rust.into())?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n@@ -507,10 +507,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n                 let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n                 if size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n+                    return err!(HeapAllocZeroBytes);\n                 }\n                 if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 let ptr = self.memory.allocate(size, align, Kind::Rust.into())?;\n                 self.memory.write_repeat(ptr.into(), 0, size)?;\n@@ -521,10 +521,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n                 let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if old_size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n+                    return err!(HeapAllocZeroBytes);\n                 }\n                 if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 self.memory.deallocate(ptr, Some((old_size, align)), Kind::Rust.into())?;\n             }\n@@ -535,13 +535,13 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let new_size = self.value_to_primval(args[3], usize)?.to_u64()?;\n                 let new_align = self.value_to_primval(args[4], usize)?.to_u64()?;\n                 if old_size == 0 || new_size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n+                    return err!(HeapAllocZeroBytes);\n                 }\n                 if !old_align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(old_align));\n+                    return err!(HeapAllocNonPowerOfTwoAlignment(old_align));\n                 }\n                 if !new_align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(new_align));\n+                    return err!(HeapAllocNonPowerOfTwoAlignment(new_align));\n                 }\n                 let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align, Kind::Rust.into())?;\n                 self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n@@ -552,15 +552,15 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             \"std::io::_print\" => {\n                 trace!(\"Ignoring output.  To run programs that print, make sure you have a libstd with full MIR.\");\n             }\n-            \"std::thread::Builder::new\" => return Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n-            \"std::env::args\" => return Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n+            \"std::thread::Builder::new\" => return err!(Unimplemented(\"miri does not support threading\".to_owned())),\n+            \"std::env::args\" => return err!(Unimplemented(\"miri does not support program arguments\".to_owned())),\n             \"std::panicking::panicking\" |\n             \"std::rt::panicking\" => {\n                 // we abort on panic -> `std::rt::panicking` always returns false\n                 let bool = self.tcx.types.bool;\n                 self.write_primval(dest, PrimVal::from_bool(false), bool)?;\n             }\n-            _ => return Err(EvalError::NoMirFor(path)),\n+            _ => return err!(NoMirFor(path)),\n         }\n \n         // Since we pushed no stack frame, the main loop will act"}, {"sha": "3cdabd4e623d66ea6a3bcdab47891740b60439d1", "filename": "miri/helpers.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/miri%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/miri%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fhelpers.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -1,6 +1,6 @@\n use rustc_miri::interpret::{\n     Pointer,\n-    EvalResult, EvalError,\n+    EvalResult,\n     PrimVal,\n     EvalContext,\n };\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n         // allocation.\n \n         if ptr.is_null()? { // NULL pointers must only be offset by 0\n-            return if offset == 0 { Ok(ptr) } else { Err(EvalError::InvalidNullPointerUsage) };\n+            return if offset == 0 { Ok(ptr) } else { err!(InvalidNullPointerUsage) };\n         }\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n@@ -59,11 +59,11 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 self.memory.check_bounds(ptr, false)?;\n             } else if ptr.is_null()? {\n                 // We moved *to* a NULL pointer.  That seems wrong, LLVM considers the NULL pointer its own small allocation.  Reject this, for now.\n-                return Err(EvalError::InvalidNullPointerUsage);\n+                return err!(InvalidNullPointerUsage);\n             }\n             Ok(ptr)\n         } else {\n-            Err(EvalError::OverflowingMath)\n+            err!(OverflowingMath)\n         }\n     }\n }"}, {"sha": "4cdad350b43e60635e573a1d1f8ae0490af15e7c", "filename": "miri/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/miri%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/miri%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fintrinsic.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::layout::Layout;\n use rustc::ty::{self, Ty};\n \n use rustc_miri::interpret::{\n-    EvalError, EvalResult,\n+    EvalResult,\n     Lvalue, LvalueExtra,\n     PrimVal, PrimValKind, Value, Pointer,\n     HasMemory,\n@@ -68,7 +68,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             \"assume\" => {\n                 let bool = self.tcx.types.bool;\n                 let cond = self.value_to_primval(arg_vals[0], bool)?.to_bool()?;\n-                if !cond { return Err(EvalError::AssumptionNotHeld); }\n+                if !cond { return err!(AssumptionNotHeld); }\n             }\n \n             \"atomic_load\" |\n@@ -180,7 +180,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let kind = self.ty_to_primval_kind(ty)?;\n                 let num = if intrinsic_name.ends_with(\"_nonzero\") {\n                     if num == 0 {\n-                        return Err(EvalError::Intrinsic(format!(\"{} called on 0\", intrinsic_name)))\n+                        return err!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)))\n                     }\n                     numeric_intrinsic(intrinsic_name.trim_right_matches(\"_nonzero\"), num, kind)?\n                 } else {\n@@ -423,7 +423,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let bits = self.type_size(dest_ty)?.expect(\"intrinsic can't be called on unsized type\") as u128 * 8;\n                 let rhs = self.value_to_primval(arg_vals[1], substs.type_at(0))?.to_bytes()?;\n                 if rhs >= bits {\n-                    return Err(EvalError::Intrinsic(format!(\"Overflowing shift by {} in unchecked_shl\", rhs)));\n+                    return err!(Intrinsic(format!(\"Overflowing shift by {} in unchecked_shl\", rhs)));\n                 }\n                 self.intrinsic_overflowing(mir::BinOp::Shl, &args[0], &args[1], dest, dest_ty)?;\n             }\n@@ -432,23 +432,23 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let bits = self.type_size(dest_ty)?.expect(\"intrinsic can't be called on unsized type\") as u128 * 8;\n                 let rhs = self.value_to_primval(arg_vals[1], substs.type_at(0))?.to_bytes()?;\n                 if rhs >= bits {\n-                    return Err(EvalError::Intrinsic(format!(\"Overflowing shift by {} in unchecked_shr\", rhs)));\n+                    return err!(Intrinsic(format!(\"Overflowing shift by {} in unchecked_shr\", rhs)));\n                 }\n                 self.intrinsic_overflowing(mir::BinOp::Shr, &args[0], &args[1], dest, dest_ty)?;\n             }\n \n             \"unchecked_div\" => {\n                 let rhs = self.value_to_primval(arg_vals[1], substs.type_at(0))?.to_bytes()?;\n                 if rhs == 0 {\n-                    return Err(EvalError::Intrinsic(format!(\"Division by 0 in unchecked_div\")));\n+                    return err!(Intrinsic(format!(\"Division by 0 in unchecked_div\")));\n                 }\n                 self.intrinsic_overflowing(mir::BinOp::Div, &args[0], &args[1], dest, dest_ty)?;\n             }\n \n             \"unchecked_rem\" => {\n                 let rhs = self.value_to_primval(arg_vals[1], substs.type_at(0))?.to_bytes()?;\n                 if rhs == 0 {\n-                    return Err(EvalError::Intrinsic(format!(\"Division by 0 in unchecked_rem\")));\n+                    return err!(Intrinsic(format!(\"Division by 0 in unchecked_rem\")));\n                 }\n                 self.intrinsic_overflowing(mir::BinOp::Rem, &args[0], &args[1], dest, dest_ty)?;\n             }\n@@ -489,7 +489,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 }\n             }\n \n-            name => return Err(EvalError::Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),\n+            name => return err!(Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),\n         }\n \n         self.goto_block(target);"}, {"sha": "cdccc5a9d4435fecb10f6afe56f0510d7be3d34b", "filename": "miri/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -25,6 +25,7 @@ use std::collections::{\n     BTreeMap,\n };\n \n+#[macro_use]\n extern crate rustc_miri;\n pub use rustc_miri::interpret::*;\n \n@@ -56,15 +57,15 @@ pub fn eval_main<'a, 'tcx: 'a>(\n         let mut cleanup_ptr = None; // Pointer to be deallocated when we are done\n \n         if !main_mir.return_ty.is_nil() || main_mir.arg_count != 0 {\n-            return Err(EvalError::Unimplemented(\"miri does not support main functions without `fn()` type signatures\".to_owned()));\n+            return err!(Unimplemented(\"miri does not support main functions without `fn()` type signatures\".to_owned()));\n         }\n \n         if let Some(start_id) = start_wrapper {\n             let start_instance = ty::Instance::mono(ecx.tcx, start_id);\n             let start_mir = ecx.load_mir(start_instance.def)?;\n \n             if start_mir.arg_count != 3 {\n-                return Err(EvalError::AbiViolation(format!(\"'start' lang item should have three arguments, but has {}\", start_mir.arg_count)));\n+                return err!(AbiViolation(format!(\"'start' lang item should have three arguments, but has {}\", start_mir.arg_count)));\n             }\n \n             // Return value\n@@ -201,7 +202,7 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n         use memory::Kind::*;\n         match m {\n             // FIXME: This could be allowed, but not for env vars set during miri execution\n-            Env => Err(EvalError::Unimplemented(\"statics can't refer to env vars\".to_owned())),\n+            Env => err!(Unimplemented(\"statics can't refer to env vars\".to_owned())),\n             _ => Ok(()),\n         }\n     }"}, {"sha": "b6ab72c5dd0191e3274c364ec7c064bf5881b8fa", "filename": "miri/operator.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/miri%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/miri%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Foperator.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -50,7 +50,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let result = match (left, right) {\n                     (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left == right,\n                     (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left == right,\n-                    (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n+                    (PrimVal::Undef, _) | (_, PrimVal::Undef) => return err!(ReadUndefBytes),\n                     _ => false,\n                 };\n                 Ok(Some((PrimVal::from_bool(result), false)))\n@@ -59,7 +59,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let result = match (left, right) {\n                     (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left != right,\n                     (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left != right,\n-                    (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n+                    (PrimVal::Undef, _) | (_, PrimVal::Undef) => return err!(ReadUndefBytes),\n                     _ => true,\n                 };\n                 Ok(Some((PrimVal::from_bool(result), false)))\n@@ -89,7 +89,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     Ok(Some((PrimVal::from_bool(res), false)))\n                 } else {\n                     // Both are pointers, but from different allocations.\n-                    Err(EvalError::InvalidPointerMath)\n+                    err!(InvalidPointerMath)\n                 }\n             }\n             // These work if one operand is a pointer, the other an integer\n@@ -141,13 +141,13 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     // Case 2: The base address bits are all taken away, i.e., right is all-0 there\n                     (PrimVal::from_u128((left.offset & right) as u128), false)\n                 } else {\n-                    return Err(EvalError::ReadPointerAsBytes);\n+                    return err!(ReadPointerAsBytes);\n                 }\n             }\n \n             _ => {\n                 let msg = format!(\"unimplemented binary op on pointer {:?}: {:?}, {:?} ({})\", bin_op, left, right, if signed { \"signed\" } else { \"unsigned\" });\n-                return Err(EvalError::Unimplemented(msg));\n+                return err!(Unimplemented(msg));\n             }\n         })\n     }"}, {"sha": "6900535dfb89fa9f8eaad74c3886a8963e43332f", "filename": "miri/tls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/miri%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/miri%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ftls.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -2,7 +2,7 @@ use rustc::{ty, mir};\n \n use super::{\n     TlsKey, TlsEntry,\n-    EvalResult, EvalError,\n+    EvalResult, EvalErrorKind,\n     Pointer,\n     Memory,\n     Evaluator,\n@@ -37,7 +37,7 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator> {\n                 trace!(\"TLS key {} removed\", key);\n                 Ok(())\n             },\n-            None => Err(EvalError::TlsOutOfBounds)\n+            None => err!(TlsOutOfBounds)\n         }\n     }\n \n@@ -47,7 +47,7 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator> {\n                 trace!(\"TLS key {} loaded: {:?}\", key, data);\n                 Ok(data)\n             },\n-            None => Err(EvalError::TlsOutOfBounds)\n+            None => err!(TlsOutOfBounds)\n         }\n     }\n \n@@ -58,7 +58,7 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator> {\n                 *data = new_data;\n                 Ok(())\n             },\n-            None => Err(EvalError::TlsOutOfBounds)\n+            None => err!(TlsOutOfBounds)\n         }\n     }\n     \n@@ -115,7 +115,7 @@ impl<'a, 'tcx: 'a> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, Evaluator> {\n                 Lvalue::undef(),\n                 StackPopCleanup::None,\n             )?;\n-            let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()))?;\n+            let arg_local = self.frame().mir.args_iter().next().ok_or(EvalErrorKind::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()))?;\n             let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n             let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n             self.write_ptr(dest, ptr, ty)?;"}, {"sha": "1ccb9ec0d296a4235a9c70c731eb97efdbc576fc", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -17,3 +17,4 @@ log = \"0.3.6\"\n log_settings = \"0.1.1\"\n lazy_static = \"0.2.8\"\n regex = \"0.2.2\"\n+backtrace = \"0.3\""}, {"sha": "c3ddeca0e65546e622ce81e232f0680a8ca657a4", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -5,7 +5,6 @@ use super::{\n     PrimVal,\n     EvalContext,\n     EvalResult,\n-    EvalError,\n     MemoryPointer, PointerArithmetic,\n     Machine,\n };\n@@ -79,12 +78,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             TyFloat(FloatTy::F32)             => Ok(PrimVal::from_f32(v as f32)),\n \n             TyChar if v as u8 as u128 == v => Ok(PrimVal::Bytes(v)),\n-            TyChar => Err(EvalError::InvalidChar(v)),\n+            TyChar => err!(InvalidChar(v)),\n \n             // No alignment check needed for raw pointers.  But we have to truncate to target ptr size.\n             TyRawPtr(_) => Ok(PrimVal::Bytes(self.memory.truncate_to_ptr(v).0 as u128)),\n \n-            _ => Err(EvalError::Unimplemented(format!(\"int to {:?} cast\", ty))),\n+            _ => err!(Unimplemented(format!(\"int to {:?} cast\", ty))),\n         }\n     }\n \n@@ -99,7 +98,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n             TyFloat(FloatTy::F64) => Ok(PrimVal::from_f64(val)),\n             TyFloat(FloatTy::F32) => Ok(PrimVal::from_f32(val as f32)),\n-            _ => Err(EvalError::Unimplemented(format!(\"float to {:?} cast\", ty))),\n+            _ => err!(Unimplemented(format!(\"float to {:?} cast\", ty))),\n         }\n     }\n \n@@ -109,8 +108,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // Casting to a reference or fn pointer is not permitted by rustc, no need to support it here.\n             TyRawPtr(_) | TyInt(IntTy::Is) | TyUint(UintTy::Us) =>\n                 Ok(PrimVal::Ptr(ptr)),\n-            TyInt(_) | TyUint(_) => Err(EvalError::ReadPointerAsBytes),\n-            _ => Err(EvalError::Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n+            TyInt(_) | TyUint(_) => err!(ReadPointerAsBytes),\n+            _ => err!(Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n         }\n     }\n }"}, {"sha": "51f18bccf43fb377ab22066e061055acbd8224c9", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -6,7 +6,7 @@ use syntax::ast::Mutability;\n use syntax::codemap::Span;\n \n use super::{\n-    EvalResult, EvalError,\n+    EvalResult, EvalError, EvalErrorKind,\n     Global, GlobalId, Lvalue,\n     PrimVal,\n     EvalContext, StackPopCleanup,\n@@ -87,7 +87,7 @@ struct CompileTimeFunctionEvaluator;\n \n impl<'tcx> Into<EvalError<'tcx>> for ConstEvalError {\n     fn into(self) -> EvalError<'tcx> {\n-        EvalError::MachineError(Box::new(self))\n+        EvalErrorKind::MachineError(Box::new(self)).into()\n     }\n }\n \n@@ -142,7 +142,7 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeFunctionEvaluator {\n         }\n         let mir = match ecx.load_mir(instance.def) {\n             Ok(mir) => mir,\n-            Err(EvalError::NoMirFor(path)) => {\n+            Err(EvalError{ kind: EvalErrorKind::NoMirFor(path), ..} ) => {\n                 // some simple things like `malloc` might get accepted in the future\n                 return Err(ConstEvalError::NeedsRfc(format!(\"calling extern function `{}`\", path)).into());\n             },"}, {"sha": "98622303f8ae812d3c068465bb8022ae410d2739", "filename": "src/librustc_mir/interpret/error.rs", "status": "modified", "additions": 45, "deletions": 9, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ferror.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -1,5 +1,7 @@\n use std::error::Error;\n use std::fmt;\n+use std::path::{PathBuf, Path};\n+\n use rustc::mir;\n use rustc::ty::{FnSig, Ty, layout};\n \n@@ -11,7 +13,41 @@ use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n #[derive(Debug)]\n-pub enum EvalError<'tcx> {\n+pub struct EvalError<'tcx> {\n+    pub kind: EvalErrorKind<'tcx>,\n+    pub backtrace: Vec<Frame>,\n+}\n+\n+impl<'tcx> From<EvalErrorKind<'tcx>> for EvalError<'tcx> {\n+    fn from(kind: EvalErrorKind<'tcx>) -> Self {\n+        let mut backtrace = Vec::new();\n+        use backtrace::{trace, resolve};\n+        trace(|frame| {\n+            resolve(frame.ip(), |symbol| {\n+                backtrace.push(Frame {\n+                    function: symbol.name().map(|s| s.to_string()).unwrap_or(String::new()),\n+                    file: symbol.filename().unwrap_or(Path::new(\"\")).to_owned(),\n+                    line: symbol.lineno().unwrap_or(0),\n+                });\n+            });\n+            true\n+        });\n+        EvalError {\n+            kind,\n+            backtrace,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Frame {\n+    pub function: String,\n+    pub file: PathBuf,\n+    pub line: u32,\n+}\n+\n+#[derive(Debug)]\n+pub enum EvalErrorKind<'tcx> {\n     /// This variant is used by machines to signal their own errors that do not\n     /// match an existing variant\n     MachineError(Box<Error>),\n@@ -106,8 +142,8 @@ pub type EvalResult<'tcx, T = ()> = Result<T, EvalError<'tcx>>;\n \n impl<'tcx> Error for EvalError<'tcx> {\n     fn description(&self) -> &str {\n-        use self::EvalError::*;\n-        match *self {\n+        use self::EvalErrorKind::*;\n+        match self.kind {\n             MachineError(ref inner) => inner.description(),\n             FunctionPointerTyMismatch(..) =>\n                 \"tried to call a function through a function pointer of a different type\",\n@@ -192,7 +228,7 @@ impl<'tcx> Error for EvalError<'tcx> {\n             TypeNotPrimitive(_) =>\n                 \"expected primitive type, got nonprimitive\",\n             ReallocatedWrongMemoryKind(_, _) =>\n-                \"tried to reallocate memory from one kind to another\",\n+                \"tried to EvalErrorKindreallocate memory from one kind to another\",\n             DeallocatedWrongMemoryKind(_, _) =>\n                 \"tried to deallocate memory of the wrong kind\",\n             ReallocateNonBasePtr =>\n@@ -215,14 +251,14 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"the evaluated program panicked\",\n             ReadFromReturnPointer =>\n                 \"tried to read from the return pointer\",\n-            EvalError::PathNotFound(_) =>\n+            EvalErrorKind::PathNotFound(_) =>\n                 \"a path could not be resolved, maybe the crate is not loaded\",\n         }\n     }\n \n     fn cause(&self) -> Option<&Error> {\n-        use self::EvalError::*;\n-        match *self {\n+        use self::EvalErrorKind::*;\n+        match self.kind {\n             MachineError(ref inner) => Some(&**inner),\n             _ => None,\n         }\n@@ -231,8 +267,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n \n impl<'tcx> fmt::Display for EvalError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        use self::EvalError::*;\n-        match *self {\n+        use self::EvalErrorKind::*;\n+        match self.kind {\n             PointerOutOfBounds { ptr, access, allocation_size } => {\n                 write!(f, \"{} at offset {}, outside bounds of allocation {} which has size {}\",\n                        if access { \"memory access\" } else { \"pointer computed\" },"}, {"sha": "42c1bc656c3def1e0a9a982055871ac5609f561b", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -17,7 +17,7 @@ use syntax::ast::{self, Mutability};\n use syntax::abi::Abi;\n \n use super::{\n-    EvalError, EvalResult,\n+    EvalError, EvalResult, EvalErrorKind,\n     Global, GlobalId, Lvalue, LvalueExtra,\n     Memory, MemoryPointer, HasMemory,\n     Kind as MemoryKind,\n@@ -257,7 +257,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub fn load_mir(&self, instance: ty::InstanceDef<'tcx>) -> EvalResult<'tcx, &'tcx mir::Mir<'tcx>> {\n         trace!(\"load mir {:?}\", instance);\n         match instance {\n-            ty::InstanceDef::Item(def_id) => self.tcx.maybe_optimized_mir(def_id).ok_or_else(|| EvalError::NoMirFor(self.tcx.item_path_str(def_id))),\n+            ty::InstanceDef::Item(def_id) => self.tcx.maybe_optimized_mir(def_id).ok_or_else(|| EvalErrorKind::NoMirFor(self.tcx.item_path_str(def_id)).into()),\n             _ => Ok(self.tcx.instance_mir(instance)),\n         }\n     }\n@@ -402,7 +402,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // TODO(solson): Is this inefficient? Needs investigation.\n         let ty = self.monomorphize(ty, substs);\n \n-        ty.layout(self.tcx, ty::ParamEnv::empty(Reveal::All)).map_err(EvalError::Layout)\n+        ty.layout(self.tcx, ty::ParamEnv::empty(Reveal::All)).map_err(|layout| EvalErrorKind::Layout(layout).into())\n     }\n \n     pub fn push_stack_frame(\n@@ -460,7 +460,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         self.memory.set_cur_frame(cur_frame);\n \n         if self.stack.len() > self.stack_limit {\n-            Err(EvalError::StackFrameLimitReached)\n+            err!(StackFrameLimitReached)\n         } else {\n             Ok(())\n         }\n@@ -609,7 +609,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     // it emits in debug mode) is performance, but it doesn't cost us any performance in miri.\n                     // If, however, the compiler ever starts transforming unchecked intrinsics into unchecked binops,\n                     // we have to go back to just ignoring the overflow here.\n-                    return Err(EvalError::OverflowingMath);\n+                    return err!(OverflowingMath);\n                 }\n             }\n \n@@ -729,7 +729,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     }\n \n                     _ => {\n-                        return Err(EvalError::Unimplemented(format!(\n+                        return err!(Unimplemented(format!(\n                             \"can't handle destination layout {:?} when assigning {:?}\",\n                             dest_layout,\n                             kind\n@@ -857,7 +857,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let discr_val = self.read_discriminant_value(ptr, ty)?;\n                 if let ty::TyAdt(adt_def, _) = ty.sty {\n                     if adt_def.discriminants(self.tcx).all(|v| discr_val != v.to_u128_unchecked()) {\n-                        return Err(EvalError::InvalidDiscriminant);\n+                        return err!(InvalidDiscriminant);\n                     }\n                 } else {\n                     bug!(\"rustc only generates Rvalue::Discriminant for enums\");\n@@ -948,7 +948,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         let ty = adt_def.variants[nndiscr as usize].fields[field_index].ty(self.tcx, substs);\n                         Ok(TyAndPacked { ty, packed: nonnull.packed })\n                     },\n-                    _ => Err(EvalError::Unimplemented(format!(\"get_field_ty can't handle enum type: {:?}, {:?}\", ty, ty.sty))),\n+                    _ => err!(Unimplemented(format!(\"get_field_ty can't handle enum type: {:?}, {:?}\", ty, ty.sty))),\n                 }\n             }\n             ty::TyAdt(adt_def, substs) => {\n@@ -959,7 +959,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         Ok(TyAndPacked { ty: variant_def.fields[field_index].ty(self.tcx, substs), packed: variants.packed }),\n                     Univariant { ref variant, .. } =>\n                         Ok(TyAndPacked { ty: variant_def.fields[field_index].ty(self.tcx, substs), packed: variant.packed }),\n-                    _ => Err(EvalError::Unimplemented(format!(\"get_field_ty can't handle struct type: {:?}, {:?}\", ty, ty.sty))),\n+                    _ => err!(Unimplemented(format!(\"get_field_ty can't handle struct type: {:?}, {:?}\", ty, ty.sty))),\n                 }\n             }\n \n@@ -970,7 +970,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n             ty::TyArray(ref inner, _) => Ok(TyAndPacked { ty: inner, packed: false }),\n \n-            _ => Err(EvalError::Unimplemented(format!(\"can't handle type: {:?}, {:?}\", ty, ty.sty))),\n+            _ => err!(Unimplemented(format!(\"can't handle type: {:?}, {:?}\", ty, ty.sty))),\n         }\n     }\n \n@@ -993,7 +993,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             UntaggedUnion { .. } => Ok(Size::from_bytes(0)),\n             _ => {\n                 let msg = format!(\"get_field_offset: can't handle type: {:?}, with layout: {:?}\", ty, layout);\n-                Err(EvalError::Unimplemented(msg))\n+                err!(Unimplemented(msg))\n             }\n         }\n     }\n@@ -1012,7 +1012,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             UntaggedUnion { .. } => Ok(1),\n             _ => {\n                 let msg = format!(\"get_field_count: can't handle type: {:?}, with layout: {:?}\", ty, layout);\n-                Err(EvalError::Unimplemented(msg))\n+                err!(Unimplemented(msg))\n             }\n         }\n     }\n@@ -1073,7 +1073,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             Lvalue::Local { frame, local } => {\n                 // -1 since we don't store the return value\n                 match self.stack[frame].locals[local.index() - 1] {\n-                    None => return Err(EvalError::DeadLocal),\n+                    None => return err!(DeadLocal),\n                     Some(Value::ByRef { ptr, aligned }) => {\n                         Lvalue::Ptr { ptr, aligned, extra: LvalueExtra::None }\n                     },\n@@ -1179,7 +1179,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             Lvalue::Global(cid) => {\n                 let dest = self.globals.get_mut(&cid).expect(\"global should be cached\").clone();\n                 if dest.mutable == Mutability::Immutable {\n-                    return Err(EvalError::ModifiedConstantMemory);\n+                    return err!(ModifiedConstantMemory);\n                 }\n                 let write_dest = |this: &mut Self, val| {\n                     *this.globals.get_mut(&cid).expect(\"already checked\") = Global {\n@@ -1382,26 +1382,26 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         if variant.fields.len() == 1 {\n                             return self.ty_to_primval_kind(variant.fields[0].ty(self.tcx, substs));\n                         } else {\n-                            return Err(EvalError::TypeNotPrimitive(ty));\n+                            return err!(TypeNotPrimitive(ty));\n                         }\n                     }\n \n-                    _ => return Err(EvalError::TypeNotPrimitive(ty)),\n+                    _ => return err!(TypeNotPrimitive(ty)),\n                 }\n             }\n \n-            _ => return Err(EvalError::TypeNotPrimitive(ty)),\n+            _ => return err!(TypeNotPrimitive(ty)),\n         };\n \n         Ok(kind)\n     }\n \n     fn ensure_valid_value(&self, val: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n         match ty.sty {\n-            ty::TyBool if val.to_bytes()? > 1 => Err(EvalError::InvalidBool),\n+            ty::TyBool if val.to_bytes()? > 1 => err!(InvalidBool),\n \n             ty::TyChar if ::std::char::from_u32(val.to_bytes()? as u32).is_none()\n-                => Err(EvalError::InvalidChar(val.to_bytes()? as u32 as u128)),\n+                => err!(InvalidChar(val.to_bytes()? as u32 as u128)),\n \n             _ => Ok(()),\n         }\n@@ -1440,7 +1440,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let c = self.memory.read_uint(ptr.to_ptr()?, 4)? as u32;\n                 match ::std::char::from_u32(c) {\n                     Some(ch) => PrimVal::from_char(ch),\n-                    None => return Err(EvalError::InvalidChar(c as u128)),\n+                    None => return err!(InvalidChar(c as u128)),\n                 }\n             }\n \n@@ -1457,7 +1457,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 // if we transmute a ptr to an isize, reading it back into a primval shouldn't panic\n                 // Due to read_ptr ignoring the sign, we need to jump around some hoops\n                 match self.memory.read_int(ptr.to_ptr()?, size) {\n-                    Err(EvalError::ReadPointerAsBytes) if size == self.memory.pointer_size() =>\n+                    Err(EvalError { kind: EvalErrorKind::ReadPointerAsBytes, .. }) if size == self.memory.pointer_size() =>\n                         // Reading as an int failed because we are seeing ptr bytes *and* we are actually reading at ptr size.\n                         // Let's try again, reading a ptr this time.\n                         self.memory.read_ptr(ptr.to_ptr()?)?.into_inner_primval(),\n@@ -1478,7 +1478,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 // if we transmute a ptr to an usize, reading it back into a primval shouldn't panic\n                 // for consistency's sake, we use the same code as above\n                 match self.memory.read_uint(ptr.to_ptr()?, size) {\n-                    Err(EvalError::ReadPointerAsBytes) if size == self.memory.pointer_size() => self.memory.read_ptr(ptr.to_ptr()?)?.into_inner_primval(),\n+                    Err(EvalError { kind: EvalErrorKind::ReadPointerAsBytes, .. }) if size == self.memory.pointer_size() => self.memory.read_ptr(ptr.to_ptr()?)?.into_inner_primval(),\n                     other => PrimVal::from_u128(other?),\n                 }\n             }\n@@ -1642,7 +1642,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             write!(msg, \":\").unwrap();\n \n             match self.stack[frame].get_local(local) {\n-                Err(EvalError::DeadLocal) => {\n+                Err(EvalError{ kind: EvalErrorKind::DeadLocal, ..} ) => {\n                     write!(msg, \" is dead\").unwrap();\n                 }\n                 Err(err) => {\n@@ -1677,7 +1677,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     {\n         let mut val = self.globals.get(&cid).expect(\"global not cached\").clone();\n         if val.mutable == Mutability::Immutable {\n-            return Err(EvalError::ModifiedConstantMemory);\n+            return err!(ModifiedConstantMemory);\n         }\n         val.value = f(self, val.value)?;\n         *self.globals.get_mut(&cid).expect(\"already checked\") = val;\n@@ -1704,6 +1704,16 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub fn report(&self, e: &EvalError) {\n+        let mut trace_text = \"\\n################################\\nerror occurred in miri at\\n\".to_string();\n+        for frame in e.backtrace.iter().skip_while(|frame| frame.function.starts_with(\"backtrace::\")) {\n+            // don't report initialization gibberish\n+            if frame.function == \"miri::after_analysis\" {\n+                break;\n+            }\n+            write!(trace_text, \"# {}\\n\", frame.function).unwrap();\n+            write!(trace_text, \"{}:{}\\n\", frame.file.display(), frame.line).unwrap();\n+        }\n+        trace!(\"{}\", trace_text);\n         if let Some(frame) = self.stack().last() {\n             let block = &frame.mir.basic_blocks()[frame.block];\n             let span = if frame.stmt < block.statements.len() {\n@@ -1729,13 +1739,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n impl<'tcx> Frame<'tcx> {\n     pub fn get_local(&self, local: mir::Local) -> EvalResult<'tcx, Value> {\n         // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n-        self.locals[local.index() - 1].ok_or(EvalError::DeadLocal)\n+        self.locals[local.index() - 1].ok_or(EvalErrorKind::DeadLocal.into())\n     }\n \n     fn set_local(&mut self, local: mir::Local, value: Value) -> EvalResult<'tcx> {\n         // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n         match self.locals[local.index() - 1] {\n-            None => Err(EvalError::DeadLocal),\n+            None => err!(DeadLocal),\n             Some(ref mut local) => {\n                 *local = value;\n                 Ok(())"}, {"sha": "8722c96dbecd435e4863870f8c4df34a114cbf97", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -5,7 +5,7 @@ use rustc_data_structures::indexed_vec::Idx;\n use syntax::ast::Mutability;\n \n use super::{\n-    EvalError, EvalResult,\n+    EvalResult,\n     EvalContext,\n     MemoryPointer,\n     PrimVal, Value, Pointer,\n@@ -140,7 +140,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         use rustc::mir::Lvalue::*;\n         match *lvalue {\n             // Might allow this in the future, right now there's no way to do this from Rust code anyway\n-            Local(mir::RETURN_POINTER) => Err(EvalError::ReadFromReturnPointer),\n+            Local(mir::RETURN_POINTER) => err!(ReadFromReturnPointer),\n             // Directly reading a local will always succeed\n             Local(local) => self.frame().get_local(local).map(Some),\n             // Directly reading a static will always succeed"}, {"sha": "9c436fb76cccdb66af36f63db36e025ce38eb27b", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -9,7 +9,7 @@ use syntax::ast::Mutability;\n use rustc::middle::region::CodeExtent;\n \n use super::{\n-    EvalError, EvalResult,\n+    EvalResult, EvalErrorKind,\n     PrimVal, Pointer,\n     EvalContext, DynamicLifetime,\n     Machine,\n@@ -319,7 +319,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         assert!(align.is_power_of_two());\n \n         if self.memory_size - self.memory_usage < size {\n-            return Err(EvalError::OutOfMemory {\n+            return err!(OutOfMemory {\n                 allocation_size: size,\n                 memory_size: self.memory_size,\n                 memory_usage: self.memory_usage,\n@@ -354,11 +354,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         use std::cmp::min;\n \n         if ptr.offset != 0 {\n-            return Err(EvalError::ReallocateNonBasePtr);\n+            return err!(ReallocateNonBasePtr);\n         }\n         if let Ok(alloc) = self.get(ptr.alloc_id) {\n             if alloc.kind != kind {\n-                return Err(EvalError::ReallocatedWrongMemoryKind(format!(\"{:?}\", alloc.kind), format!(\"{:?}\", kind)));\n+                return err!(ReallocatedWrongMemoryKind(format!(\"{:?}\", alloc.kind), format!(\"{:?}\", kind)));\n             }\n         }\n \n@@ -377,12 +377,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         kind: Kind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx> {\n         if ptr.offset != 0 {\n-            return Err(EvalError::DeallocateNonBasePtr);\n+            return err!(DeallocateNonBasePtr);\n         }\n \n         let alloc = match self.alloc_map.remove(&ptr.alloc_id) {\n             Some(alloc) => alloc,\n-            None => return Err(EvalError::DoubleFree),\n+            None => return err!(DoubleFree),\n         };\n \n         // It is okay for us to still holds locks on deallocation -- for example, we could store data we own\n@@ -391,14 +391,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         // lock by another frame.  We *have* to permit deallocation if we hold a read lock.\n         // TODO: Figure out the exact rules here.\n         alloc.check_locks(Some(self.cur_frame), 0, alloc.bytes.len() as u64, AccessKind::Read)\n-            .map_err(|lock| EvalError::DeallocatedLockedMemory { ptr, lock })?;\n+            .map_err(|lock| EvalErrorKind::DeallocatedLockedMemory { ptr, lock })?;\n \n         if alloc.kind != kind {\n-            return Err(EvalError::DeallocatedWrongMemoryKind(format!(\"{:?}\", alloc.kind), format!(\"{:?}\", kind)));\n+            return err!(DeallocatedWrongMemoryKind(format!(\"{:?}\", alloc.kind), format!(\"{:?}\", kind)));\n         }\n         if let Some((size, align)) = size_and_align {\n             if size != alloc.bytes.len() as u64 || align != alloc.align {\n-                return Err(EvalError::IncorrectAllocationInformation);\n+                return err!(IncorrectAllocationInformation);\n             }\n         }\n \n@@ -422,7 +422,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             PrimVal::Ptr(ptr) => {\n                 let alloc = self.get(ptr.alloc_id)?;\n                 if alloc.align < align {\n-                    return Err(EvalError::AlignmentCheckFailed {\n+                    return err!(AlignmentCheckFailed {\n                         has: alloc.align,\n                         required: align,\n                     });\n@@ -432,16 +432,16 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             PrimVal::Bytes(bytes) => {\n                 let v = ((bytes as u128) % (1 << self.pointer_size())) as u64;\n                 if v == 0 {\n-                    return Err(EvalError::InvalidNullPointerUsage);\n+                    return err!(InvalidNullPointerUsage);\n                 }\n                 v\n             },\n-            PrimVal::Undef => return Err(EvalError::ReadUndefBytes),\n+            PrimVal::Undef => return err!(ReadUndefBytes),\n         };\n         if offset % align == 0 {\n             Ok(())\n         } else {\n-            Err(EvalError::AlignmentCheckFailed {\n+            err!(AlignmentCheckFailed {\n                 has: offset % align,\n                 required: align,\n             })\n@@ -452,7 +452,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         let alloc = self.get(ptr.alloc_id)?;\n         let allocation_size = alloc.bytes.len() as u64;\n         if ptr.offset > allocation_size {\n-            return Err(EvalError::PointerOutOfBounds { ptr, access, allocation_size });\n+            return err!(PointerOutOfBounds { ptr, access, allocation_size });\n         }\n         Ok(())\n     }\n@@ -471,7 +471,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         let alloc = self.get(ptr.alloc_id)?;\n         let frame = self.cur_frame;\n         alloc.check_locks(Some(frame), ptr.offset, len, access)\n-            .map_err(|lock| EvalError::MemoryLockViolation { ptr, len, frame, access, lock })\n+            .map_err(|lock| EvalErrorKind::MemoryLockViolation { ptr, len, frame, access, lock }.into())\n     }\n \n     #[allow(dead_code)]\n@@ -488,7 +488,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n         // Check if this conflicts with other locks\n         alloc.check_locks(None, ptr.offset, len, kind)\n-            .map_err(|lock| EvalError::MemoryAcquireConflict { ptr, len, kind, lock })?;\n+            .map_err(|lock| EvalErrorKind::MemoryAcquireConflict { ptr, len, kind, lock })?;\n \n         let lifetime = DynamicLifetime { frame, region };\n         match (alloc.locks.entry(MemoryRange::new(ptr.offset, len)), kind) {\n@@ -518,17 +518,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 WriteLock(ref lft) => {\n                     // Make sure we can release this lock\n                     if lft.frame != cur_frame {\n-                        return Err(EvalError::InvalidMemoryLockRelease { ptr, len, frame: cur_frame, lock: lock.clone() });\n+                        return err!(InvalidMemoryLockRelease { ptr, len, frame: cur_frame, lock: lock.clone() });\n                     }\n                     if !range.contained_in(ptr.offset, len) {\n-                        return Err(EvalError::Unimplemented(format!(\"miri does not support releasing part of a write-locked region\")));\n+                        return err!(Unimplemented(format!(\"miri does not support releasing part of a write-locked region\")));\n                     }\n                     // Release it later.  We cannot do this now.\n                     remove_list.push(*range);\n                 }\n                 ReadLock(_) => {\n                     // Abort here and bubble the error outwards so that we do not even register a suspension.\n-                    return Err(EvalError::InvalidMemoryLockRelease { ptr, len, frame: cur_frame, lock: lock.clone() });\n+                    return err!(InvalidMemoryLockRelease { ptr, len, frame: cur_frame, lock: lock.clone() });\n                 },\n             }\n         }\n@@ -591,8 +591,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         match self.alloc_map.get(&id) {\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n-                Some(_) => Err(EvalError::DerefFunctionPointer),\n-                None => Err(EvalError::DanglingPointerDeref),\n+                Some(_) => err!(DerefFunctionPointer),\n+                None => err!(DanglingPointerDeref),\n             }\n         }\n     }\n@@ -601,8 +601,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         match self.alloc_map.get_mut(&id) {\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n-                Some(_) => Err(EvalError::DerefFunctionPointer),\n-                None => Err(EvalError::DanglingPointerDeref),\n+                Some(_) => err!(DerefFunctionPointer),\n+                None => err!(DanglingPointerDeref),\n             }\n         }\n     }\n@@ -612,20 +612,20 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         if alloc.mutable == Mutability::Mutable {\n             Ok(alloc)\n         } else {\n-            Err(EvalError::ModifiedConstantMemory)\n+            err!(ModifiedConstantMemory)\n         }\n     }\n \n     pub fn get_fn(&self, ptr: MemoryPointer) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n         if ptr.offset != 0 {\n-            return Err(EvalError::InvalidFunctionPointer);\n+            return err!(InvalidFunctionPointer);\n         }\n         debug!(\"reading fn ptr: {}\", ptr.alloc_id);\n         match self.functions.get(&ptr.alloc_id) {\n             Some(&fndef) => Ok(fndef),\n             None => match self.alloc_map.get(&ptr.alloc_id) {\n-                Some(_) => Err(EvalError::ExecuteMemory),\n-                None => Err(EvalError::InvalidFunctionPointer),\n+                Some(_) => err!(ExecuteMemory),\n+                None => err!(InvalidFunctionPointer),\n             }\n         }\n     }\n@@ -760,7 +760,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     fn get_bytes(&self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n         assert_ne!(size, 0);\n         if self.relocations(ptr, size)?.count() != 0 {\n-            return Err(EvalError::ReadPointerAsBytes);\n+            return err!(ReadPointerAsBytes);\n         }\n         self.check_defined(ptr, size)?;\n         self.get_bytes_unchecked(ptr, size, align)\n@@ -818,7 +818,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 // mark recursively\n                 mem::replace(relocations, Default::default())\n             },\n-            None if !self.functions.contains_key(&alloc_id) => return Err(EvalError::DanglingPointerDeref),\n+            None if !self.functions.contains_key(&alloc_id) => return err!(DanglingPointerDeref),\n             _ => return Ok(()),\n         };\n         // recurse into inner allocations\n@@ -857,7 +857,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 if nonoverlapping {\n                     if (src.offset <= dest.offset && src.offset + size > dest.offset) ||\n                        (dest.offset <= src.offset && dest.offset + size > src.offset) {\n-                        return Err(EvalError::Intrinsic(format!(\"copy_nonoverlapping called on overlapping ranges\")));\n+                        return err!(Intrinsic(format!(\"copy_nonoverlapping called on overlapping ranges\")));\n                     }\n                 }\n                 ptr::copy(src_bytes, dest_bytes, size as usize);\n@@ -879,13 +879,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         match alloc.bytes[offset..].iter().position(|&c| c == 0) {\n             Some(size) => {\n                 if self.relocations(ptr, (size + 1) as u64)?.count() != 0 {\n-                    return Err(EvalError::ReadPointerAsBytes);\n+                    return err!(ReadPointerAsBytes);\n                 }\n                 self.check_defined(ptr, (size + 1) as u64)?;\n                 self.check_locks(ptr, (size + 1) as u64, AccessKind::Read)?;\n                 Ok(&alloc.bytes[offset..offset + size])\n             },\n-            None => Err(EvalError::UnterminatedCString(ptr)),\n+            None => err!(UnterminatedCString(ptr)),\n         }\n     }\n \n@@ -987,7 +987,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         match bytes[0] {\n             0 => Ok(false),\n             1 => Ok(true),\n-            _ => Err(EvalError::InvalidBool),\n+            _ => err!(InvalidBool),\n         }\n     }\n \n@@ -1117,7 +1117,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         let overlapping_start = self.relocations(ptr, 0)?.count();\n         let overlapping_end = self.relocations(ptr.offset(size, self.layout)?, 0)?.count();\n         if overlapping_start + overlapping_end != 0 {\n-            return Err(EvalError::ReadPointerAsBytes);\n+            return err!(ReadPointerAsBytes);\n         }\n         Ok(())\n     }\n@@ -1154,7 +1154,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     fn check_defined(&self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         if !alloc.undef_mask.is_range_defined(ptr.offset, ptr.offset + size) {\n-            return Err(EvalError::ReadUndefBytes);\n+            return err!(ReadUndefBytes);\n         }\n         Ok(())\n     }\n@@ -1416,7 +1416,7 @@ pub trait PointerArithmetic : layout::HasDataLayout {\n     fn signed_offset<'tcx>(self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n         let (res, over) = self.overflowing_signed_offset(val, i as i128);\n         if over {\n-            Err(EvalError::OverflowingMath)\n+            err!(OverflowingMath)\n         } else {\n             Ok(res)\n         }\n@@ -1425,7 +1425,7 @@ pub trait PointerArithmetic : layout::HasDataLayout {\n     fn offset<'tcx>(self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n         let (res, over) = self.overflowing_offset(val, i);\n         if over {\n-            Err(EvalError::OverflowingMath)\n+            err!(OverflowingMath)\n         } else {\n             Ok(res)\n         }"}, {"sha": "3b3f82b7a730feaf25e6274e1350d2032ff9f0ae", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -1,5 +1,10 @@\n //! An interpreter for MIR used in CTFE and by miri\n \n+#[macro_export]\n+macro_rules! err {\n+    ($($tt:tt)*) => { Err($crate::interpret::EvalErrorKind::$($tt)*.into()) };\n+}\n+\n mod cast;\n mod const_eval;\n mod error;\n@@ -17,6 +22,7 @@ mod value;\n pub use self::error::{\n     EvalError,\n     EvalResult,\n+    EvalErrorKind,\n };\n \n pub use self::eval_context::{"}, {"sha": "a9675d148d6643971342be1d9330eca311a66376", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -2,7 +2,7 @@ use rustc::mir;\n use rustc::ty::Ty;\n \n use super::{\n-    EvalError, EvalResult,\n+    EvalResult,\n     EvalContext,\n     Lvalue,\n     Machine,\n@@ -173,7 +173,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n         if left_kind != right_kind {\n             let msg = format!(\"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n-            return Err(EvalError::Unimplemented(msg));\n+            return err!(Unimplemented(msg));\n         }\n \n         let val = match (bin_op, left_kind) {\n@@ -227,7 +227,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n             _ => {\n                 let msg = format!(\"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n-                return Err(EvalError::Unimplemented(msg));\n+                return err!(Unimplemented(msg));\n             }\n         };\n \n@@ -271,7 +271,7 @@ pub fn unary_op<'tcx>(\n \n         _ => {\n             let msg = format!(\"unimplemented unary op: {:?}, {:?}\", un_op, val);\n-            return Err(EvalError::Unimplemented(msg));\n+            return err!(Unimplemented(msg));\n         }\n     };\n "}, {"sha": "12de6b1b6830bf0745c428bb139c228b32d5a1a8", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -12,7 +12,7 @@ use rustc::ty::layout::Layout;\n use rustc::ty::subst::Substs;\n \n use super::{\n-    EvalResult, EvalError,\n+    EvalResult,\n     EvalContext, StackPopCleanup, TyAndPacked,\n     Global, GlobalId, Lvalue,\n     Value, PrimVal,\n@@ -29,7 +29,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         if self.steps_remaining > 0 {\n             Ok(())\n         } else {\n-            Err(EvalError::ExecutionTimeLimitReached)\n+            err!(ExecutionTimeLimitReached)\n         }\n     }\n \n@@ -123,7 +123,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             StorageLive(ref lvalue) | StorageDead(ref lvalue)=> {\n                 let (frame, local) = match self.eval_lvalue(lvalue)? {\n                     Lvalue::Local{ frame, local } if self.cur_frame() == frame => (frame, local),\n-                    _ => return Err(EvalError::Unimplemented(\"Storage annotations must refer to locals of the topmost stack frame.\".to_owned())) // FIXME maybe this should get its own error type\n+                    _ => return err!(Unimplemented(\"Storage annotations must refer to locals of the topmost stack frame.\".to_owned())) // FIXME maybe this should get its own error type\n                 };\n                 let old_val = match stmt.kind {\n                     StorageLive(_) => self.stack[frame].storage_live(local)?,\n@@ -140,7 +140,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // size of MIR constantly.\n             Nop => {}\n \n-            InlineAsm { .. } => return Err(EvalError::InlineAsm),\n+            InlineAsm { .. } => return err!(InlineAsm),\n         }\n \n         self.frame_mut().stmt += 1;"}, {"sha": "ce04e1b8d1e06674da44c260cf57448ae57d8361", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -5,7 +5,7 @@ use syntax::codemap::Span;\n use syntax::abi::Abi;\n \n use super::{\n-    EvalError, EvalResult,\n+    EvalError, EvalResult, EvalErrorKind,\n     EvalContext, eval_context, TyAndPacked,\n     Lvalue,\n     MemoryPointer,\n@@ -78,7 +78,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                 let real_sig = self.erase_lifetimes(&real_sig);\n                                 let real_sig = self.tcx.normalize_associated_type(&real_sig);\n                                 if !self.check_sig_compat(sig, real_sig)? {\n-                                    return Err(EvalError::FunctionPointerTyMismatch(real_sig, sig));\n+                                    return err!(FunctionPointerTyMismatch(real_sig, sig));\n                                 }\n                             },\n                             ref other => bug!(\"instance def ty: {:?}\", other),\n@@ -88,7 +88,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     ty::TyFnDef(def_id, substs) => (eval_context::resolve(self.tcx, def_id, substs), func_ty.fn_sig(self.tcx)),\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func_ty);\n-                        return Err(EvalError::Unimplemented(msg));\n+                        return err!(Unimplemented(msg));\n                     }\n                 };\n                 let sig = self.erase_lifetimes(&sig);\n@@ -121,17 +121,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                             let index = self.eval_operand_to_primval(index)\n                                 .expect(\"can't eval index\")\n                                 .to_u64()?;\n-                            Err(EvalError::ArrayIndexOutOfBounds(span, len, index))\n+                            err!(ArrayIndexOutOfBounds(span, len, index))\n                         },\n                         mir::AssertMessage::Math(ref err) =>\n-                            Err(EvalError::Math(terminator.source_info.span, err.clone())),\n+                            err!(Math(terminator.source_info.span, err.clone())),\n                     }\n                 }\n             },\n \n             DropAndReplace { .. } => unimplemented!(),\n             Resume => unimplemented!(),\n-            Unreachable => return Err(EvalError::Unreachable),\n+            Unreachable => return err!(Unreachable),\n         }\n \n         Ok(())\n@@ -214,11 +214,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             ty::InstanceDef::Intrinsic(..) => {\n                 let (ret, target) = match destination {\n                     Some(dest) => dest,\n-                    _ => return Err(EvalError::Unreachable),\n+                    _ => return err!(Unreachable),\n                 };\n                 let ty = sig.output();\n                 if !eval_context::is_inhabited(self.tcx, ty) {\n-                    return Err(EvalError::Unreachable);\n+                    return err!(Unreachable);\n                 }\n                 let layout = self.type_layout(ty)?;\n                 M::call_intrinsic(self, instance, arg_operands, ret, ty, layout, target)?;\n@@ -462,7 +462,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         trace!(\"read_nonnull_discriminant_value: {:?}, {}, {}\", ptr, nndiscr, discr_size);\n         let not_null = match self.memory.read_uint(ptr, discr_size) {\n             Ok(0) => false,\n-            Ok(_) | Err(EvalError::ReadPointerAsBytes) => true,\n+            Ok(_) | Err(EvalError{ kind: EvalErrorKind::ReadPointerAsBytes, .. }) => true,\n             Err(e) => return Err(e),\n         };\n         assert!(nndiscr == 0 || nndiscr == 1);"}, {"sha": "a1821e58a996ffe82dbe5f953773994006a8863f", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -6,7 +6,7 @@ use syntax::codemap::DUMMY_SP;\n use syntax::ast::{self, Mutability};\n \n use super::{\n-    EvalResult, EvalError,\n+    EvalResult,\n     EvalContext, eval_context,\n     MemoryPointer, Kind,\n     Value, PrimVal,\n@@ -82,7 +82,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // some values don't need to call a drop impl, so the value is null\n             Value::ByVal(PrimVal::Bytes(0)) => Ok(None),\n             Value::ByVal(PrimVal::Ptr(drop_fn)) => self.memory.get_fn(drop_fn).map(Some),\n-            _ => Err(EvalError::ReadBytesAsPointer),\n+            _ => err!(ReadBytesAsPointer),\n         }\n     }\n "}, {"sha": "23ac6bbfcd841715db24846f3a69214889fc84aa", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -11,7 +11,7 @@ use rustc::infer::TransNormalize;\n use rustc::middle::region::CodeExtent;\n \n use super::{\n-    EvalError, EvalResult,\n+    EvalError, EvalResult, EvalErrorKind,\n     EvalContext, DynamicLifetime,\n     AccessKind, LockInfo,\n     PrimVal, Value,\n@@ -98,7 +98,7 @@ std::sync::atomic::AtomicBool::get_mut$|\\\n             ValidationOp::Suspend(_) => ValidationMode::Release,\n         };\n         match self.validate(query.clone(), mode) {\n-            Err(EvalError::InvalidMemoryLockRelease { lock: LockInfo::ReadLock(_), .. }) => {\n+            Err(EvalError { kind: EvalErrorKind::InvalidMemoryLockRelease { lock: LockInfo::ReadLock(_), .. }, .. }) => {\n                 // HACK: When &x is used while x is already borrowed read-only, AddValidation still\n                 // emits suspension.  This code is legit, so just ignore the error *and*\n                 // do NOT register a suspension.\n@@ -170,7 +170,8 @@ std::sync::atomic::AtomicBool::get_mut$|\\\n             // HACK: If, during releasing, we hit memory we cannot use, we just ignore that.\n             // This can happen because releases are added before drop elaboration.\n             // TODO: Fix the MIR so that these releases do not happen.\n-            res @ Err(EvalError::DanglingPointerDeref) | res @ Err(EvalError::ReadUndefBytes) => {\n+            res @ Err(EvalError{ kind: EvalErrorKind::DanglingPointerDeref, ..}) |\n+            res @ Err(EvalError{ kind: EvalErrorKind::ReadUndefBytes, ..}) => {\n                 if let ValidationMode::Release = mode {\n                     return Ok(());\n                 }\n@@ -207,8 +208,8 @@ std::sync::atomic::AtomicBool::get_mut$|\\\n             Lvalue::Local { frame, local } => {\n                 let res = self.stack[frame].get_local(local);\n                 match (res, mode) {\n-                    (Err(EvalError::DeadLocal), ValidationMode::Recover(_)) |\n-                    (Err(EvalError::DeadLocal), ValidationMode::Release) |\n+                    (Err(EvalError{ kind: EvalErrorKind::DeadLocal, ..}), ValidationMode::Recover(_)) |\n+                    (Err(EvalError{ kind: EvalErrorKind::DeadLocal, ..}), ValidationMode::Release) |\n                     (Ok(Value::ByVal(PrimVal::Undef)), ValidationMode::Release) => {\n                         return Ok(());\n                     }\n@@ -287,7 +288,7 @@ std::sync::atomic::AtomicBool::get_mut$|\\\n                 Ok(())\n             }\n             TyNever => {\n-                Err(EvalError::ValidationFailure(format!(\"The empty type is never valid.\")))\n+                err!(ValidationFailure(format!(\"The empty type is never valid.\")))\n             }\n             TyRef(region, ty::TypeAndMut { ty: pointee_ty, mutbl }) => {\n                 let val = self.read_lvalue(query.lval)?;\n@@ -370,8 +371,11 @@ std::sync::atomic::AtomicBool::get_mut$|\\\n \n                         // Get variant index for discriminant\n                         let variant_idx = adt.discriminants(self.tcx)\n-                            .position(|variant_discr| variant_discr.to_u128_unchecked() == discr)\n-                            .ok_or(EvalError::InvalidDiscriminant)?;\n+                            .position(|variant_discr| variant_discr.to_u128_unchecked() == discr);\n+                        let variant_idx = match variant_idx {\n+                            Some(val) => val,\n+                            None => return err!(InvalidDiscriminant),\n+                        };\n                         let variant = &adt.variants[variant_idx];\n \n                         if variant.fields.len() > 0 {"}, {"sha": "163643be01c32237fa20f14ffc3083a9f150e6cb", "filename": "src/librustc_mir/interpret/value.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -4,7 +4,7 @@\n use rustc::ty::layout::HasDataLayout;\n \n use super::{\n-    EvalError, EvalResult,\n+    EvalResult,\n     Memory, MemoryPointer, HasMemory, PointerArithmetic,\n     Machine,\n };\n@@ -72,7 +72,7 @@ impl<'tcx> Pointer {\n                 Ok(Pointer::from(PrimVal::Bytes(layout.signed_offset(b as u64, i)? as u128)))\n             },\n             PrimVal::Ptr(ptr) => ptr.signed_offset(i, layout).map(Pointer::from),\n-            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n+            PrimVal::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n@@ -84,7 +84,7 @@ impl<'tcx> Pointer {\n                 Ok(Pointer::from(PrimVal::Bytes(layout.offset(b as u64, i)? as u128)))\n             },\n             PrimVal::Ptr(ptr) => ptr.offset(i, layout).map(Pointer::from),\n-            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n+            PrimVal::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n@@ -96,15 +96,15 @@ impl<'tcx> Pointer {\n                 Ok(Pointer::from(PrimVal::Bytes(layout.wrapping_signed_offset(b as u64, i) as u128)))\n             },\n             PrimVal::Ptr(ptr) => Ok(Pointer::from(ptr.wrapping_signed_offset(i, layout))),\n-            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n+            PrimVal::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n     pub fn is_null(self) -> EvalResult<'tcx, bool> {\n         match self.primval {\n             PrimVal::Bytes(b) => Ok(b == 0),\n             PrimVal::Ptr(_) => Ok(false),\n-            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n+            PrimVal::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n@@ -249,16 +249,16 @@ impl<'tcx> PrimVal {\n     pub fn to_bytes(self) -> EvalResult<'tcx, u128> {\n         match self {\n             PrimVal::Bytes(b) => Ok(b),\n-            PrimVal::Ptr(_) => Err(EvalError::ReadPointerAsBytes),\n-            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n+            PrimVal::Ptr(_) => err!(ReadPointerAsBytes),\n+            PrimVal::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n     pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n         match self {\n-            PrimVal::Bytes(_) => Err(EvalError::ReadBytesAsPointer),\n+            PrimVal::Bytes(_) => err!(ReadBytesAsPointer),\n             PrimVal::Ptr(p) => Ok(p),\n-            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n+            PrimVal::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n@@ -324,7 +324,7 @@ impl<'tcx> PrimVal {\n         match self.to_bytes()? {\n             0 => Ok(false),\n             1 => Ok(true),\n-            _ => Err(EvalError::InvalidBool),\n+            _ => err!(InvalidBool),\n         }\n     }\n }"}, {"sha": "de0cde265601a8156ceb15676c1f34e9f570e548", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a3c4d28c67ca8b808a6e91de530b3d909d4db3/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=29a3c4d28c67ca8b808a6e91de530b3d909d4db3", "patch": "@@ -20,5 +20,6 @@ extern crate byteorder;\n #[macro_use]\n extern crate lazy_static;\n extern crate regex;\n+extern crate backtrace;\n \n pub mod interpret;"}]}