{"sha": "30d3ce06742fc5d0eb844239652a0af4d47bb095", "node_id": "C_kwDOAAsO6NoAKDMwZDNjZTA2NzQyZmM1ZDBlYjg0NDIzOTY1MmEwYWY0ZDQ3YmIwOTU", "commit": {"author": {"name": "Erik Desjardins", "email": "erikdesjardins@users.noreply.github.com", "date": "2022-02-21T16:19:16Z"}, "committer": {"name": "Erik Desjardins", "email": "erikdesjardins@users.noreply.github.com", "date": "2022-02-26T18:14:55Z"}, "message": "Add LLVM attributes in batches instead of individually\n\nThis should improve performance.", "tree": {"sha": "d1fa3a83f6d9844567fc46bd59104e7377cfba39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1fa3a83f6d9844567fc46bd59104e7377cfba39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30d3ce06742fc5d0eb844239652a0af4d47bb095", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30d3ce06742fc5d0eb844239652a0af4d47bb095", "html_url": "https://github.com/rust-lang/rust/commit/30d3ce06742fc5d0eb844239652a0af4d47bb095", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30d3ce06742fc5d0eb844239652a0af4d47bb095/comments", "author": {"login": "erikdesjardins", "id": 7673145, "node_id": "MDQ6VXNlcjc2NzMxNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7673145?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikdesjardins", "html_url": "https://github.com/erikdesjardins", "followers_url": "https://api.github.com/users/erikdesjardins/followers", "following_url": "https://api.github.com/users/erikdesjardins/following{/other_user}", "gists_url": "https://api.github.com/users/erikdesjardins/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikdesjardins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikdesjardins/subscriptions", "organizations_url": "https://api.github.com/users/erikdesjardins/orgs", "repos_url": "https://api.github.com/users/erikdesjardins/repos", "events_url": "https://api.github.com/users/erikdesjardins/events{/privacy}", "received_events_url": "https://api.github.com/users/erikdesjardins/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erikdesjardins", "id": 7673145, "node_id": "MDQ6VXNlcjc2NzMxNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7673145?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikdesjardins", "html_url": "https://github.com/erikdesjardins", "followers_url": "https://api.github.com/users/erikdesjardins/followers", "following_url": "https://api.github.com/users/erikdesjardins/following{/other_user}", "gists_url": "https://api.github.com/users/erikdesjardins/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikdesjardins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikdesjardins/subscriptions", "organizations_url": "https://api.github.com/users/erikdesjardins/orgs", "repos_url": "https://api.github.com/users/erikdesjardins/repos", "events_url": "https://api.github.com/users/erikdesjardins/events{/privacy}", "received_events_url": "https://api.github.com/users/erikdesjardins/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f681a8eb3fbdf37075ae5f921518f5f4b9306a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f681a8eb3fbdf37075ae5f921518f5f4b9306a6", "html_url": "https://github.com/rust-lang/rust/commit/6f681a8eb3fbdf37075ae5f921518f5f4b9306a6"}], "stats": {"total": 856, "additions": 417, "deletions": 439}, "files": [{"sha": "8e5904a54f8f1d790b245c3b55ed38bb4f5ccd45", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 85, "deletions": 129, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=30d3ce06742fc5d0eb844239652a0af4d47bb095", "patch": "@@ -1,6 +1,7 @@\n+use crate::attributes;\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n-use crate::llvm::{self, AttributePlace};\n+use crate::llvm::{self, Attribute, AttributePlace};\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n@@ -20,6 +21,7 @@ use rustc_target::abi::{self, HasDataLayout, Int};\n pub use rustc_target::spec::abi::Abi;\n \n use libc::c_uint;\n+use smallvec::SmallVec;\n \n pub trait ArgAttributesExt {\n     fn apply_attrs_to_llfn(&self, idx: AttributePlace, cx: &CodegenCx<'_, '_>, llfn: &Value);\n@@ -38,57 +40,68 @@ fn should_use_mutable_noalias(cx: &CodegenCx<'_, '_>) -> bool {\n     cx.tcx.sess.opts.debugging_opts.mutable_noalias.unwrap_or(true)\n }\n \n-const ABI_AFFECTING_ATTRIBUTES: [(ArgAttribute, llvm::Attribute); 1] =\n-    [(ArgAttribute::InReg, llvm::Attribute::InReg)];\n+const ABI_AFFECTING_ATTRIBUTES: [(ArgAttribute, llvm::AttributeKind); 1] =\n+    [(ArgAttribute::InReg, llvm::AttributeKind::InReg)];\n \n-const OPTIMIZATION_ATTRIBUTES: [(ArgAttribute, llvm::Attribute); 5] = [\n-    (ArgAttribute::NoAlias, llvm::Attribute::NoAlias),\n-    (ArgAttribute::NoCapture, llvm::Attribute::NoCapture),\n-    (ArgAttribute::NonNull, llvm::Attribute::NonNull),\n-    (ArgAttribute::ReadOnly, llvm::Attribute::ReadOnly),\n-    (ArgAttribute::NoUndef, llvm::Attribute::NoUndef),\n+const OPTIMIZATION_ATTRIBUTES: [(ArgAttribute, llvm::AttributeKind); 5] = [\n+    (ArgAttribute::NoAlias, llvm::AttributeKind::NoAlias),\n+    (ArgAttribute::NoCapture, llvm::AttributeKind::NoCapture),\n+    (ArgAttribute::NonNull, llvm::AttributeKind::NonNull),\n+    (ArgAttribute::ReadOnly, llvm::AttributeKind::ReadOnly),\n+    (ArgAttribute::NoUndef, llvm::AttributeKind::NoUndef),\n ];\n \n-impl ArgAttributesExt for ArgAttributes {\n-    fn apply_attrs_to_llfn(&self, idx: AttributePlace, cx: &CodegenCx<'_, '_>, llfn: &Value) {\n-        let mut regular = self.regular;\n-        unsafe {\n-            // ABI-affecting attributes must always be applied\n-            for (attr, llattr) in ABI_AFFECTING_ATTRIBUTES {\n-                if regular.contains(attr) {\n-                    llattr.apply_llfn(idx, llfn);\n-                }\n-            }\n-            if let Some(align) = self.pointee_align {\n-                llvm::LLVMRustAddAlignmentAttr(llfn, idx.as_uint(), align.bytes() as u32);\n-            }\n-            match self.arg_ext {\n-                ArgExtension::None => {}\n-                ArgExtension::Zext => llvm::Attribute::ZExt.apply_llfn(idx, llfn),\n-                ArgExtension::Sext => llvm::Attribute::SExt.apply_llfn(idx, llfn),\n-            }\n-            // Only apply remaining attributes when optimizing\n-            if cx.sess().opts.optimize == config::OptLevel::No {\n-                return;\n-            }\n-            let deref = self.pointee_size.bytes();\n-            if deref != 0 {\n-                if regular.contains(ArgAttribute::NonNull) {\n-                    llvm::LLVMRustAddDereferenceableAttr(llfn, idx.as_uint(), deref);\n-                } else {\n-                    llvm::LLVMRustAddDereferenceableOrNullAttr(llfn, idx.as_uint(), deref);\n-                }\n-                regular -= ArgAttribute::NonNull;\n-            }\n-            for (attr, llattr) in OPTIMIZATION_ATTRIBUTES {\n-                if regular.contains(attr) {\n-                    llattr.apply_llfn(idx, llfn);\n-                }\n+fn get_attrs<'ll>(\n+    this: &ArgAttributes,\n+    cx: &CodegenCx<'ll, '_>,\n+) -> SmallVec<impl smallvec::Array<Item = &'ll Attribute>> {\n+    let mut regular = this.regular;\n+\n+    let mut attrs = SmallVec::<[_; 8]>::new();\n+\n+    // ABI-affecting attributes must always be applied\n+    for (attr, llattr) in ABI_AFFECTING_ATTRIBUTES {\n+        if regular.contains(attr) {\n+            attrs.push(llattr.create_attr(cx.llcx));\n+        }\n+    }\n+    if let Some(align) = this.pointee_align {\n+        attrs.push(llvm::CreateAlignmentAttr(cx.llcx, align.bytes()));\n+    }\n+    match this.arg_ext {\n+        ArgExtension::None => {}\n+        ArgExtension::Zext => attrs.push(llvm::AttributeKind::ZExt.create_attr(cx.llcx)),\n+        ArgExtension::Sext => attrs.push(llvm::AttributeKind::SExt.create_attr(cx.llcx)),\n+    }\n+\n+    // Only apply remaining attributes when optimizing\n+    if cx.sess().opts.optimize != config::OptLevel::No {\n+        let deref = this.pointee_size.bytes();\n+        if deref != 0 {\n+            if regular.contains(ArgAttribute::NonNull) {\n+                attrs.push(llvm::CreateDereferenceableAttr(cx.llcx, deref));\n+            } else {\n+                attrs.push(llvm::CreateDereferenceableOrNullAttr(cx.llcx, deref));\n             }\n-            if regular.contains(ArgAttribute::NoAliasMutRef) && should_use_mutable_noalias(cx) {\n-                llvm::Attribute::NoAlias.apply_llfn(idx, llfn);\n+            regular -= ArgAttribute::NonNull;\n+        }\n+        for (attr, llattr) in OPTIMIZATION_ATTRIBUTES {\n+            if regular.contains(attr) {\n+                attrs.push(llattr.create_attr(cx.llcx));\n             }\n         }\n+        if regular.contains(ArgAttribute::NoAliasMutRef) && should_use_mutable_noalias(cx) {\n+            attrs.push(llvm::AttributeKind::NoAlias.create_attr(cx.llcx));\n+        }\n+    }\n+\n+    attrs\n+}\n+\n+impl ArgAttributesExt for ArgAttributes {\n+    fn apply_attrs_to_llfn(&self, idx: AttributePlace, cx: &CodegenCx<'_, '_>, llfn: &Value) {\n+        let attrs = get_attrs(self, cx);\n+        attributes::apply_to_llfn(llfn, idx, &attrs);\n     }\n \n     fn apply_attrs_to_callsite(\n@@ -97,52 +110,8 @@ impl ArgAttributesExt for ArgAttributes {\n         cx: &CodegenCx<'_, '_>,\n         callsite: &Value,\n     ) {\n-        let mut regular = self.regular;\n-        unsafe {\n-            // ABI-affecting attributes must always be applied\n-            for (attr, llattr) in ABI_AFFECTING_ATTRIBUTES {\n-                if regular.contains(attr) {\n-                    llattr.apply_callsite(idx, callsite);\n-                }\n-            }\n-            if let Some(align) = self.pointee_align {\n-                llvm::LLVMRustAddAlignmentCallSiteAttr(\n-                    callsite,\n-                    idx.as_uint(),\n-                    align.bytes() as u32,\n-                );\n-            }\n-            match self.arg_ext {\n-                ArgExtension::None => {}\n-                ArgExtension::Zext => llvm::Attribute::ZExt.apply_callsite(idx, callsite),\n-                ArgExtension::Sext => llvm::Attribute::SExt.apply_callsite(idx, callsite),\n-            }\n-            // Only apply remaining attributes when optimizing\n-            if cx.sess().opts.optimize == config::OptLevel::No {\n-                return;\n-            }\n-            let deref = self.pointee_size.bytes();\n-            if deref != 0 {\n-                if regular.contains(ArgAttribute::NonNull) {\n-                    llvm::LLVMRustAddDereferenceableCallSiteAttr(callsite, idx.as_uint(), deref);\n-                } else {\n-                    llvm::LLVMRustAddDereferenceableOrNullCallSiteAttr(\n-                        callsite,\n-                        idx.as_uint(),\n-                        deref,\n-                    );\n-                }\n-                regular -= ArgAttribute::NonNull;\n-            }\n-            for (attr, llattr) in OPTIMIZATION_ATTRIBUTES {\n-                if regular.contains(attr) {\n-                    llattr.apply_callsite(idx, callsite);\n-                }\n-            }\n-            if regular.contains(ArgAttribute::NoAliasMutRef) && should_use_mutable_noalias(cx) {\n-                llvm::Attribute::NoAlias.apply_callsite(idx, callsite);\n-            }\n-        }\n+        let attrs = get_attrs(self, cx);\n+        attributes::apply_to_callsite(callsite, idx, &attrs);\n     }\n }\n \n@@ -444,15 +413,14 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n     }\n \n     fn apply_attrs_llfn(&self, cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value) {\n-        // FIXME(eddyb) can this also be applied to callsites?\n+        let mut func_attrs = SmallVec::<[_; 2]>::new();\n         if self.ret.layout.abi.is_uninhabited() {\n-            llvm::Attribute::NoReturn.apply_llfn(llvm::AttributePlace::Function, llfn);\n+            func_attrs.push(llvm::AttributeKind::NoReturn.create_attr(cx.llcx));\n         }\n-\n-        // FIXME(eddyb, wesleywiser): apply this to callsites as well?\n         if !self.can_unwind {\n-            llvm::Attribute::NoUnwind.apply_llfn(llvm::AttributePlace::Function, llfn);\n+            func_attrs.push(llvm::AttributeKind::NoUnwind.create_attr(cx.llcx));\n         }\n+        attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &{ func_attrs });\n \n         let mut i = 0;\n         let mut apply = |attrs: &ArgAttributes| {\n@@ -467,13 +435,8 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n                 assert!(!on_stack);\n                 let i = apply(attrs);\n-                unsafe {\n-                    llvm::LLVMRustAddStructRetAttr(\n-                        llfn,\n-                        llvm::AttributePlace::Argument(i).as_uint(),\n-                        self.ret.layout.llvm_type(cx),\n-                    );\n-                }\n+                let sret = llvm::CreateStructRetAttr(cx.llcx, self.ret.layout.llvm_type(cx));\n+                attributes::apply_to_llfn(llfn, llvm::AttributePlace::Argument(i), &[sret]);\n             }\n             PassMode::Cast(cast) => {\n                 cast.attrs.apply_attrs_to_llfn(llvm::AttributePlace::ReturnValue, cx, llfn);\n@@ -488,13 +451,8 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                 PassMode::Ignore => {}\n                 PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: true } => {\n                     let i = apply(attrs);\n-                    unsafe {\n-                        llvm::LLVMRustAddByValAttr(\n-                            llfn,\n-                            llvm::AttributePlace::Argument(i).as_uint(),\n-                            arg.layout.llvm_type(cx),\n-                        );\n-                    }\n+                    let byval = llvm::CreateByValAttr(cx.llcx, arg.layout.llvm_type(cx));\n+                    attributes::apply_to_llfn(llfn, llvm::AttributePlace::Argument(i), &[byval]);\n                 }\n                 PassMode::Direct(ref attrs)\n                 | PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: false } => {\n@@ -517,12 +475,14 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n     }\n \n     fn apply_attrs_callsite(&self, bx: &mut Builder<'_, 'll, 'tcx>, callsite: &'ll Value) {\n+        let mut func_attrs = SmallVec::<[_; 2]>::new();\n         if self.ret.layout.abi.is_uninhabited() {\n-            llvm::Attribute::NoReturn.apply_callsite(llvm::AttributePlace::Function, callsite);\n+            func_attrs.push(llvm::AttributeKind::NoReturn.create_attr(bx.cx.llcx));\n         }\n         if !self.can_unwind {\n-            llvm::Attribute::NoUnwind.apply_callsite(llvm::AttributePlace::Function, callsite);\n+            func_attrs.push(llvm::AttributeKind::NoUnwind.create_attr(bx.cx.llcx));\n         }\n+        attributes::apply_to_callsite(callsite, llvm::AttributePlace::Function, &{ func_attrs });\n \n         let mut i = 0;\n         let mut apply = |cx: &CodegenCx<'_, '_>, attrs: &ArgAttributes| {\n@@ -537,13 +497,8 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n                 assert!(!on_stack);\n                 let i = apply(bx.cx, attrs);\n-                unsafe {\n-                    llvm::LLVMRustAddStructRetCallSiteAttr(\n-                        callsite,\n-                        llvm::AttributePlace::Argument(i).as_uint(),\n-                        self.ret.layout.llvm_type(bx),\n-                    );\n-                }\n+                let sret = llvm::CreateStructRetAttr(bx.cx.llcx, self.ret.layout.llvm_type(bx));\n+                attributes::apply_to_callsite(callsite, llvm::AttributePlace::Argument(i), &[sret]);\n             }\n             PassMode::Cast(cast) => {\n                 cast.attrs.apply_attrs_to_callsite(\n@@ -572,13 +527,12 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                 PassMode::Ignore => {}\n                 PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: true } => {\n                     let i = apply(bx.cx, attrs);\n-                    unsafe {\n-                        llvm::LLVMRustAddByValCallSiteAttr(\n-                            callsite,\n-                            llvm::AttributePlace::Argument(i).as_uint(),\n-                            arg.layout.llvm_type(bx),\n-                        );\n-                    }\n+                    let byval = llvm::CreateByValAttr(bx.cx.llcx, arg.layout.llvm_type(bx));\n+                    attributes::apply_to_callsite(\n+                        callsite,\n+                        llvm::AttributePlace::Argument(i),\n+                        &[byval],\n+                    );\n                 }\n                 PassMode::Direct(ref attrs)\n                 | PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: false } => {\n@@ -610,10 +564,12 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n         if self.conv == Conv::CCmseNonSecureCall {\n             // This will probably get ignored on all targets but those supporting the TrustZone-M\n             // extension (thumbv8m targets).\n-            llvm::AddCallSiteAttrString(\n+            let cmse_nonsecure_call =\n+                llvm::CreateAttrString(bx.cx.llcx, cstr::cstr!(\"cmse_nonsecure_call\"));\n+            attributes::apply_to_callsite(\n                 callsite,\n                 llvm::AttributePlace::Function,\n-                cstr::cstr!(\"cmse_nonsecure_call\"),\n+                &[cmse_nonsecure_call],\n             );\n         }\n     }"}, {"sha": "eb19e427217017d72db8ca2f1ab9775c730bf90a", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=30d3ce06742fc5d0eb844239652a0af4d47bb095", "patch": "@@ -64,7 +64,8 @@ pub(crate) unsafe fn codegen(\n             llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n         }\n         if tcx.sess.must_emit_unwind_tables() {\n-            attributes::emit_uwtable(llfn);\n+            let uwtable = attributes::uwtable_attr(llcx);\n+            attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &[uwtable]);\n         }\n \n         let callee = kind.fn_name(method.name);\n@@ -105,20 +106,22 @@ pub(crate) unsafe fn codegen(\n     let name = \"__rust_alloc_error_handler\";\n     let llfn = llvm::LLVMRustGetOrInsertFunction(llmod, name.as_ptr().cast(), name.len(), ty);\n     // -> ! DIFlagNoReturn\n-    llvm::Attribute::NoReturn.apply_llfn(llvm::AttributePlace::Function, llfn);\n+    let no_return = llvm::AttributeKind::NoReturn.create_attr(llcx);\n+    attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &[no_return]);\n \n     if tcx.sess.target.default_hidden_visibility {\n         llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n     }\n     if tcx.sess.must_emit_unwind_tables() {\n-        attributes::emit_uwtable(llfn);\n+        let uwtable = attributes::uwtable_attr(llcx);\n+        attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &[uwtable]);\n     }\n \n     let kind = if has_alloc_error_handler { AllocatorKind::Global } else { AllocatorKind::Default };\n     let callee = kind.fn_name(sym::oom);\n     let callee = llvm::LLVMRustGetOrInsertFunction(llmod, callee.as_ptr().cast(), callee.len(), ty);\n     // -> ! DIFlagNoReturn\n-    llvm::Attribute::NoReturn.apply_llfn(llvm::AttributePlace::Function, callee);\n+    attributes::apply_to_llfn(callee, llvm::AttributePlace::Function, &[no_return]);\n     llvm::LLVMRustSetVisibility(callee, llvm::Visibility::Hidden);\n \n     let llbb = llvm::LLVMAppendBasicBlockInContext(llcx, llfn, \"entry\\0\".as_ptr().cast());"}, {"sha": "96c7d884b7b2066baf2ecb9c76213f1df7a068be", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=30d3ce06742fc5d0eb844239652a0af4d47bb095", "patch": "@@ -1,3 +1,4 @@\n+use crate::attributes;\n use crate::builder::Builder;\n use crate::common::Funclet;\n use crate::context::CodegenCx;\n@@ -18,6 +19,7 @@ use rustc_target::abi::*;\n use rustc_target::asm::*;\n \n use libc::{c_char, c_uint};\n+use smallvec::SmallVec;\n use tracing::debug;\n \n impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n@@ -273,19 +275,20 @@ impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n         )\n         .unwrap_or_else(|| span_bug!(line_spans[0], \"LLVM asm constraint validation failed\"));\n \n+        let mut attrs = SmallVec::<[_; 2]>::new();\n         if options.contains(InlineAsmOptions::PURE) {\n             if options.contains(InlineAsmOptions::NOMEM) {\n-                llvm::Attribute::ReadNone.apply_callsite(llvm::AttributePlace::Function, result);\n+                attrs.push(llvm::AttributeKind::ReadNone.create_attr(self.cx.llcx));\n             } else if options.contains(InlineAsmOptions::READONLY) {\n-                llvm::Attribute::ReadOnly.apply_callsite(llvm::AttributePlace::Function, result);\n+                attrs.push(llvm::AttributeKind::ReadOnly.create_attr(self.cx.llcx));\n             }\n-            llvm::Attribute::WillReturn.apply_callsite(llvm::AttributePlace::Function, result);\n+            attrs.push(llvm::AttributeKind::WillReturn.create_attr(self.cx.llcx));\n         } else if options.contains(InlineAsmOptions::NOMEM) {\n-            llvm::Attribute::InaccessibleMemOnly\n-                .apply_callsite(llvm::AttributePlace::Function, result);\n+            attrs.push(llvm::AttributeKind::InaccessibleMemOnly.create_attr(self.cx.llcx));\n         } else {\n             // LLVM doesn't have an attribute to represent ReadOnly + SideEffect\n         }\n+        attributes::apply_to_callsite(result, llvm::AttributePlace::Function, &{ attrs });\n \n         // Write results to outputs\n         for (idx, op) in operands.iter().enumerate() {"}, {"sha": "bc67ab1770314738ea945aa11a70cbaf8c0cda34", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 145, "deletions": 139, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=30d3ce06742fc5d0eb844239652a0af4d47bb095", "patch": "@@ -7,53 +7,75 @@ use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_hir::def_id::DefId;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n-use rustc_middle::ty::layout::HasTyCtxt;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::config::OptLevel;\n-use rustc_session::Session;\n use rustc_target::spec::abi::Abi;\n use rustc_target::spec::{FramePointer, SanitizerSet, StackProbeType, StackProtector};\n+use smallvec::SmallVec;\n \n use crate::attributes;\n use crate::llvm::AttributePlace::Function;\n-use crate::llvm::{self, Attribute};\n+use crate::llvm::{self, Attribute, AttributeKind, AttributePlace};\n use crate::llvm_util;\n pub use rustc_attr::{InlineAttr, InstructionSetAttr, OptimizeAttr};\n \n use crate::context::CodegenCx;\n use crate::value::Value;\n \n-/// Mark LLVM function to use provided inline heuristic.\n+pub fn apply_to_llfn(llfn: &Value, idx: AttributePlace, attrs: &[&Attribute]) {\n+    if !attrs.is_empty() {\n+        llvm::AddFunctionAttributes(llfn, idx, attrs);\n+    }\n+}\n+\n+pub fn remove_from_llfn(llfn: &Value, idx: AttributePlace, attrs: &[AttributeKind]) {\n+    if !attrs.is_empty() {\n+        llvm::RemoveFunctionAttributes(llfn, idx, attrs);\n+    }\n+}\n+\n+pub fn apply_to_callsite(callsite: &Value, idx: AttributePlace, attrs: &[&Attribute]) {\n+    if !attrs.is_empty() {\n+        llvm::AddCallSiteAttributes(callsite, idx, attrs);\n+    }\n+}\n+\n+/// Get LLVM attribute for the provided inline heuristic.\n #[inline]\n-fn inline<'ll>(cx: &CodegenCx<'ll, '_>, val: &'ll Value, inline: InlineAttr) {\n-    use self::InlineAttr::*;\n+fn inline_attr<'ll>(cx: &CodegenCx<'ll, '_>, inline: InlineAttr) -> Option<&'ll Attribute> {\n     match inline {\n-        Hint => Attribute::InlineHint.apply_llfn(Function, val),\n-        Always => Attribute::AlwaysInline.apply_llfn(Function, val),\n-        Never => {\n-            if cx.tcx().sess.target.arch != \"amdgpu\" {\n-                Attribute::NoInline.apply_llfn(Function, val);\n+        InlineAttr::Hint => Some(AttributeKind::InlineHint.create_attr(cx.llcx)),\n+        InlineAttr::Always => Some(AttributeKind::AlwaysInline.create_attr(cx.llcx)),\n+        InlineAttr::Never => {\n+            if cx.sess().target.arch != \"amdgpu\" {\n+                Some(AttributeKind::NoInline.create_attr(cx.llcx))\n+            } else {\n+                None\n             }\n         }\n-        None => {}\n-    };\n+        InlineAttr::None => None,\n+    }\n }\n \n-/// Apply LLVM sanitize attributes.\n+/// Get LLVM sanitize attributes.\n #[inline]\n-pub fn sanitize<'ll>(cx: &CodegenCx<'ll, '_>, no_sanitize: SanitizerSet, llfn: &'ll Value) {\n+pub fn sanitize_attrs<'ll>(\n+    cx: &CodegenCx<'ll, '_>,\n+    no_sanitize: SanitizerSet,\n+) -> SmallVec<impl smallvec::Array<Item = &'ll Attribute>> {\n+    let mut attrs = SmallVec::<[_; 4]>::new();\n     let enabled = cx.tcx.sess.opts.debugging_opts.sanitizer - no_sanitize;\n     if enabled.contains(SanitizerSet::ADDRESS) {\n-        llvm::Attribute::SanitizeAddress.apply_llfn(Function, llfn);\n+        attrs.push(llvm::AttributeKind::SanitizeAddress.create_attr(cx.llcx));\n     }\n     if enabled.contains(SanitizerSet::MEMORY) {\n-        llvm::Attribute::SanitizeMemory.apply_llfn(Function, llfn);\n+        attrs.push(llvm::AttributeKind::SanitizeMemory.create_attr(cx.llcx));\n     }\n     if enabled.contains(SanitizerSet::THREAD) {\n-        llvm::Attribute::SanitizeThread.apply_llfn(Function, llfn);\n+        attrs.push(llvm::AttributeKind::SanitizeThread.create_attr(cx.llcx));\n     }\n     if enabled.contains(SanitizerSet::HWADDRESS) {\n-        llvm::Attribute::SanitizeHWAddress.apply_llfn(Function, llfn);\n+        attrs.push(llvm::AttributeKind::SanitizeHWAddress.create_attr(cx.llcx));\n     }\n     if enabled.contains(SanitizerSet::MEMTAG) {\n         // Check to make sure the mte target feature is actually enabled.\n@@ -66,26 +88,21 @@ pub fn sanitize<'ll>(cx: &CodegenCx<'ll, '_>, no_sanitize: SanitizerSet, llfn: &\n             sess.err(\"`-Zsanitizer=memtag` requires `-Ctarget-feature=+mte`\");\n         }\n \n-        llvm::Attribute::SanitizeMemTag.apply_llfn(Function, llfn);\n+        attrs.push(llvm::AttributeKind::SanitizeMemTag.create_attr(cx.llcx));\n     }\n+    attrs\n }\n \n /// Tell LLVM to emit or not emit the information necessary to unwind the stack for the function.\n #[inline]\n-pub fn emit_uwtable(val: &Value) {\n+pub fn uwtable_attr(llcx: &llvm::Context) -> &Attribute {\n     // NOTE: We should determine if we even need async unwind tables, as they\n     // take have more overhead and if we can use sync unwind tables we\n     // probably should.\n-    llvm::EmitUWTableAttr(val, true);\n-}\n-\n-/// Tell LLVM if this function should be 'naked', i.e., skip the epilogue and prologue.\n-#[inline]\n-fn naked(val: &Value, is_naked: bool) {\n-    Attribute::Naked.toggle_llfn(Function, val, is_naked);\n+    llvm::CreateUWTableAttr(llcx, true)\n }\n \n-pub fn set_frame_pointer_type<'ll>(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n+pub fn frame_pointer_type_attr<'ll>(cx: &CodegenCx<'ll, '_>) -> Option<&'ll Attribute> {\n     let mut fp = cx.sess().target.frame_pointer;\n     // \"mcount\" function relies on stack pointer.\n     // See <https://sourceware.org/binutils/docs/gprof/Implementation.html>.\n@@ -96,19 +113,14 @@ pub fn set_frame_pointer_type<'ll>(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     let attr_value = match fp {\n         FramePointer::Always => cstr!(\"all\"),\n         FramePointer::NonLeaf => cstr!(\"non-leaf\"),\n-        FramePointer::MayOmit => return,\n+        FramePointer::MayOmit => return None,\n     };\n-    llvm::AddFunctionAttrStringValue(\n-        llfn,\n-        llvm::AttributePlace::Function,\n-        cstr!(\"frame-pointer\"),\n-        attr_value,\n-    );\n+    Some(llvm::CreateAttrStringValue(cx.llcx, cstr!(\"frame-pointer\"), attr_value))\n }\n \n /// Tell LLVM what instrument function to insert.\n #[inline]\n-fn set_instrument_function<'ll>(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n+fn instrument_function_attr<'ll>(cx: &CodegenCx<'ll, '_>) -> Option<&'ll Attribute> {\n     if cx.sess().instrument_mcount() {\n         // Similar to `clang -pg` behavior. Handled by the\n         // `post-inline-ee-instrument` LLVM pass.\n@@ -117,16 +129,17 @@ fn set_instrument_function<'ll>(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n         // See test/CodeGen/mcount.c in clang.\n         let mcount_name = CString::new(cx.sess().target.mcount.as_str().as_bytes()).unwrap();\n \n-        llvm::AddFunctionAttrStringValue(\n-            llfn,\n-            llvm::AttributePlace::Function,\n+        Some(llvm::CreateAttrStringValue(\n+            cx.llcx,\n             cstr!(\"instrument-function-entry-inlined\"),\n             &mcount_name,\n-        );\n+        ))\n+    } else {\n+        None\n     }\n }\n \n-fn set_probestack<'ll>(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n+fn probestack_attr<'ll>(cx: &CodegenCx<'ll, '_>) -> Option<&'ll Attribute> {\n     // Currently stack probes seem somewhat incompatible with the address\n     // sanitizer and thread sanitizer. With asan we're already protected from\n     // stack overflow anyway so we don't really need stack probes regardless.\n@@ -137,107 +150,105 @@ fn set_probestack<'ll>(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n         .sanitizer\n         .intersects(SanitizerSet::ADDRESS | SanitizerSet::THREAD)\n     {\n-        return;\n+        return None;\n     }\n \n     // probestack doesn't play nice either with `-C profile-generate`.\n     if cx.sess().opts.cg.profile_generate.enabled() {\n-        return;\n+        return None;\n     }\n \n     // probestack doesn't play nice either with gcov profiling.\n     if cx.sess().opts.debugging_opts.profile {\n-        return;\n+        return None;\n     }\n \n     let attr_value = match cx.sess().target.stack_probes {\n-        StackProbeType::None => None,\n+        StackProbeType::None => return None,\n         // Request LLVM to generate the probes inline. If the given LLVM version does not support\n         // this, no probe is generated at all (even if the attribute is specified).\n-        StackProbeType::Inline => Some(cstr!(\"inline-asm\")),\n+        StackProbeType::Inline => cstr!(\"inline-asm\"),\n         // Flag our internal `__rust_probestack` function as the stack probe symbol.\n         // This is defined in the `compiler-builtins` crate for each architecture.\n-        StackProbeType::Call => Some(cstr!(\"__rust_probestack\")),\n+        StackProbeType::Call => cstr!(\"__rust_probestack\"),\n         // Pick from the two above based on the LLVM version.\n         StackProbeType::InlineOrCall { min_llvm_version_for_inline } => {\n             if llvm_util::get_version() < min_llvm_version_for_inline {\n-                Some(cstr!(\"__rust_probestack\"))\n+                cstr!(\"__rust_probestack\")\n             } else {\n-                Some(cstr!(\"inline-asm\"))\n+                cstr!(\"inline-asm\")\n             }\n         }\n     };\n-    if let Some(attr_value) = attr_value {\n-        llvm::AddFunctionAttrStringValue(\n-            llfn,\n-            llvm::AttributePlace::Function,\n-            cstr!(\"probe-stack\"),\n-            attr_value,\n-        );\n-    }\n+    Some(llvm::CreateAttrStringValue(cx.llcx, cstr!(\"probe-stack\"), attr_value))\n }\n \n-fn set_stackprotector<'ll>(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n+fn stackprotector_attr<'ll>(cx: &CodegenCx<'ll, '_>) -> Option<&'ll Attribute> {\n     let sspattr = match cx.sess().stack_protector() {\n-        StackProtector::None => return,\n-        StackProtector::All => Attribute::StackProtectReq,\n-        StackProtector::Strong => Attribute::StackProtectStrong,\n-        StackProtector::Basic => Attribute::StackProtect,\n+        StackProtector::None => return None,\n+        StackProtector::All => AttributeKind::StackProtectReq,\n+        StackProtector::Strong => AttributeKind::StackProtectStrong,\n+        StackProtector::Basic => AttributeKind::StackProtect,\n     };\n \n-    sspattr.apply_llfn(Function, llfn)\n+    Some(sspattr.create_attr(cx.llcx))\n }\n \n-pub fn apply_target_cpu_attr<'ll>(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n+pub fn target_cpu_attr<'ll>(cx: &CodegenCx<'ll, '_>) -> &'ll Attribute {\n     let target_cpu = SmallCStr::new(llvm_util::target_cpu(cx.tcx.sess));\n-    llvm::AddFunctionAttrStringValue(\n-        llfn,\n-        llvm::AttributePlace::Function,\n-        cstr!(\"target-cpu\"),\n-        target_cpu.as_c_str(),\n-    );\n+    llvm::CreateAttrStringValue(cx.llcx, cstr!(\"target-cpu\"), target_cpu.as_c_str())\n }\n \n-pub fn apply_tune_cpu_attr<'ll>(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n-    if let Some(tune) = llvm_util::tune_cpu(cx.tcx.sess) {\n+pub fn tune_cpu_attr<'ll>(cx: &CodegenCx<'ll, '_>) -> Option<&'ll Attribute> {\n+    llvm_util::tune_cpu(cx.tcx.sess).map(|tune| {\n         let tune_cpu = SmallCStr::new(tune);\n-        llvm::AddFunctionAttrStringValue(\n-            llfn,\n-            llvm::AttributePlace::Function,\n-            cstr!(\"tune-cpu\"),\n-            tune_cpu.as_c_str(),\n-        );\n-    }\n+        llvm::CreateAttrStringValue(cx.llcx, cstr!(\"tune-cpu\"), tune_cpu.as_c_str())\n+    })\n }\n \n-/// Sets the `NonLazyBind` LLVM attribute on a given function,\n-/// assuming the codegen options allow skipping the PLT.\n-pub fn non_lazy_bind<'ll>(sess: &Session, llfn: &'ll Value) {\n+/// Get the `NonLazyBind` LLVM attribute,\n+/// if the codegen options allow skipping the PLT.\n+pub fn non_lazy_bind_attr<'ll>(cx: &CodegenCx<'ll, '_>) -> Option<&'ll Attribute> {\n     // Don't generate calls through PLT if it's not necessary\n-    if !sess.needs_plt() {\n-        Attribute::NonLazyBind.apply_llfn(Function, llfn);\n+    if !cx.sess().needs_plt() {\n+        Some(AttributeKind::NonLazyBind.create_attr(cx.llcx))\n+    } else {\n+        None\n     }\n }\n \n-pub(crate) fn default_optimisation_attrs<'ll>(sess: &Session, llfn: &'ll Value) {\n-    match sess.opts.optimize {\n+/// Returns attributes to remove and to add, respectively,\n+/// to set the default optimizations attrs on a function.\n+#[inline]\n+pub(crate) fn default_optimisation_attrs<'ll>(\n+    cx: &CodegenCx<'ll, '_>,\n+) -> (\n+    // Attributes to remove\n+    SmallVec<impl smallvec::Array<Item = AttributeKind>>,\n+    // Attributes to add\n+    SmallVec<impl smallvec::Array<Item = &'ll Attribute>>,\n+) {\n+    let mut to_remove = SmallVec::<[_; 3]>::new();\n+    let mut to_add = SmallVec::<[_; 2]>::new();\n+    match cx.sess().opts.optimize {\n         OptLevel::Size => {\n-            llvm::Attribute::MinSize.unapply_llfn(Function, llfn);\n-            llvm::Attribute::OptimizeForSize.apply_llfn(Function, llfn);\n-            llvm::Attribute::OptimizeNone.unapply_llfn(Function, llfn);\n+            to_remove.push(llvm::AttributeKind::MinSize);\n+            to_add.push(llvm::AttributeKind::OptimizeForSize.create_attr(cx.llcx));\n+            to_remove.push(llvm::AttributeKind::OptimizeNone);\n         }\n         OptLevel::SizeMin => {\n-            llvm::Attribute::MinSize.apply_llfn(Function, llfn);\n-            llvm::Attribute::OptimizeForSize.apply_llfn(Function, llfn);\n-            llvm::Attribute::OptimizeNone.unapply_llfn(Function, llfn);\n+            to_add.push(llvm::AttributeKind::MinSize.create_attr(cx.llcx));\n+            to_add.push(llvm::AttributeKind::OptimizeForSize.create_attr(cx.llcx));\n+            to_remove.push(llvm::AttributeKind::OptimizeNone);\n         }\n         OptLevel::No => {\n-            llvm::Attribute::MinSize.unapply_llfn(Function, llfn);\n-            llvm::Attribute::OptimizeForSize.unapply_llfn(Function, llfn);\n-            llvm::Attribute::OptimizeNone.unapply_llfn(Function, llfn);\n+            to_remove.push(llvm::AttributeKind::MinSize);\n+            to_remove.push(llvm::AttributeKind::OptimizeForSize);\n+            to_remove.push(llvm::AttributeKind::OptimizeNone);\n         }\n         _ => {}\n     }\n+    (to_remove, to_add)\n }\n \n /// Composite function which sets LLVM attributes for function depending on its AST (`#[attribute]`)\n@@ -249,30 +260,35 @@ pub fn from_fn_attrs<'ll, 'tcx>(\n ) {\n     let codegen_fn_attrs = cx.tcx.codegen_fn_attrs(instance.def_id());\n \n+    let mut to_remove = SmallVec::<[_; 4]>::new();\n+    let mut to_add = SmallVec::<[_; 16]>::new();\n+\n     match codegen_fn_attrs.optimize {\n         OptimizeAttr::None => {\n-            default_optimisation_attrs(cx.tcx.sess, llfn);\n+            let (to_remove_opt, to_add_opt) = default_optimisation_attrs(cx);\n+            to_remove.extend(to_remove_opt);\n+            to_add.extend(to_add_opt);\n         }\n         OptimizeAttr::Speed => {\n-            llvm::Attribute::MinSize.unapply_llfn(Function, llfn);\n-            llvm::Attribute::OptimizeForSize.unapply_llfn(Function, llfn);\n-            llvm::Attribute::OptimizeNone.unapply_llfn(Function, llfn);\n+            to_remove.push(llvm::AttributeKind::MinSize);\n+            to_remove.push(llvm::AttributeKind::OptimizeForSize);\n+            to_remove.push(llvm::AttributeKind::OptimizeNone);\n         }\n         OptimizeAttr::Size => {\n-            llvm::Attribute::MinSize.apply_llfn(Function, llfn);\n-            llvm::Attribute::OptimizeForSize.apply_llfn(Function, llfn);\n-            llvm::Attribute::OptimizeNone.unapply_llfn(Function, llfn);\n+            to_add.push(llvm::AttributeKind::MinSize.create_attr(cx.llcx));\n+            to_add.push(llvm::AttributeKind::OptimizeForSize.create_attr(cx.llcx));\n+            to_remove.push(llvm::AttributeKind::OptimizeNone);\n         }\n     }\n \n-    let inline_attr = if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n+    let inline = if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n         InlineAttr::Never\n     } else if codegen_fn_attrs.inline == InlineAttr::None && instance.def.requires_inline(cx.tcx) {\n         InlineAttr::Hint\n     } else {\n         codegen_fn_attrs.inline\n     };\n-    inline(cx, llfn, inline_attr);\n+    to_add.extend(inline_attr(cx, inline));\n \n     // The `uwtable` attribute according to LLVM is:\n     //\n@@ -291,52 +307,54 @@ pub fn from_fn_attrs<'ll, 'tcx>(\n     // You can also find more info on why Windows always requires uwtables here:\n     //      https://bugzilla.mozilla.org/show_bug.cgi?id=1302078\n     if cx.sess().must_emit_unwind_tables() {\n-        attributes::emit_uwtable(llfn);\n+        to_add.push(uwtable_attr(cx.llcx));\n     }\n \n     if cx.sess().opts.debugging_opts.profile_sample_use.is_some() {\n-        llvm::AddFunctionAttrString(llfn, Function, cstr!(\"use-sample-profile\"));\n+        to_add.push(llvm::CreateAttrString(cx.llcx, cstr!(\"use-sample-profile\")));\n     }\n \n     // FIXME: none of these three functions interact with source level attributes.\n-    set_frame_pointer_type(cx, llfn);\n-    set_instrument_function(cx, llfn);\n-    set_probestack(cx, llfn);\n-    set_stackprotector(cx, llfn);\n+    to_add.extend(frame_pointer_type_attr(cx));\n+    to_add.extend(instrument_function_attr(cx));\n+    to_add.extend(probestack_attr(cx));\n+    to_add.extend(stackprotector_attr(cx));\n \n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::COLD) {\n-        Attribute::Cold.apply_llfn(Function, llfn);\n+        to_add.push(AttributeKind::Cold.create_attr(cx.llcx));\n     }\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::FFI_RETURNS_TWICE) {\n-        Attribute::ReturnsTwice.apply_llfn(Function, llfn);\n+        to_add.push(AttributeKind::ReturnsTwice.create_attr(cx.llcx));\n     }\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::FFI_PURE) {\n-        Attribute::ReadOnly.apply_llfn(Function, llfn);\n+        to_add.push(AttributeKind::ReadOnly.create_attr(cx.llcx));\n     }\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::FFI_CONST) {\n-        Attribute::ReadNone.apply_llfn(Function, llfn);\n+        to_add.push(AttributeKind::ReadNone.create_attr(cx.llcx));\n     }\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n-        naked(llfn, true);\n+        to_add.push(AttributeKind::Naked.create_attr(cx.llcx));\n     }\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::ALLOCATOR) {\n-        Attribute::NoAlias.apply_llfn(llvm::AttributePlace::ReturnValue, llfn);\n+        // apply to return place instead of function (unlike all other attributes applied in this function)\n+        let no_alias = AttributeKind::NoAlias.create_attr(cx.llcx);\n+        attributes::apply_to_llfn(llfn, AttributePlace::ReturnValue, &[no_alias]);\n     }\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY) {\n-        llvm::AddFunctionAttrString(llfn, Function, cstr!(\"cmse_nonsecure_entry\"));\n+        to_add.push(llvm::CreateAttrString(cx.llcx, cstr!(\"cmse_nonsecure_entry\")));\n     }\n     if let Some(align) = codegen_fn_attrs.alignment {\n         llvm::set_alignment(llfn, align as usize);\n     }\n-    sanitize(cx, codegen_fn_attrs.no_sanitize, llfn);\n+    to_add.extend(sanitize_attrs(cx, codegen_fn_attrs.no_sanitize));\n \n     // Always annotate functions with the target-cpu they are compiled for.\n     // Without this, ThinLTO won't inline Rust functions into Clang generated\n     // functions (because Clang annotates functions this way too).\n-    apply_target_cpu_attr(cx, llfn);\n+    to_add.push(target_cpu_attr(cx));\n     // tune-cpu is only conveyed through the attribute for our purpose.\n     // The target doesn't care; the subtarget reads our attribute.\n-    apply_tune_cpu_attr(cx, llfn);\n+    to_add.extend(tune_cpu_attr(cx));\n \n     let function_features =\n         codegen_fn_attrs.target_features.iter().map(|f| f.as_str()).collect::<Vec<&str>>();\n@@ -379,22 +397,12 @@ pub fn from_fn_attrs<'ll, 'tcx>(\n         // If this function is an import from the environment but the wasm\n         // import has a specific module/name, apply them here.\n         if let Some(module) = wasm_import_module(cx.tcx, instance.def_id()) {\n-            llvm::AddFunctionAttrStringValue(\n-                llfn,\n-                llvm::AttributePlace::Function,\n-                cstr!(\"wasm-import-module\"),\n-                &module,\n-            );\n+            to_add.push(llvm::CreateAttrStringValue(cx.llcx, cstr!(\"wasm-import-module\"), &module));\n \n             let name =\n                 codegen_fn_attrs.link_name.unwrap_or_else(|| cx.tcx.item_name(instance.def_id()));\n             let name = CString::new(name.as_str()).unwrap();\n-            llvm::AddFunctionAttrStringValue(\n-                llfn,\n-                llvm::AttributePlace::Function,\n-                cstr!(\"wasm-import-name\"),\n-                &name,\n-            );\n+            to_add.push(llvm::CreateAttrStringValue(cx.llcx, cstr!(\"wasm-import-name\"), &name));\n         }\n \n         // The `\"wasm\"` abi on wasm targets automatically enables the\n@@ -414,13 +422,11 @@ pub fn from_fn_attrs<'ll, 'tcx>(\n         global_features.extend(function_features.into_iter());\n         let features = global_features.join(\",\");\n         let val = CString::new(features).unwrap();\n-        llvm::AddFunctionAttrStringValue(\n-            llfn,\n-            llvm::AttributePlace::Function,\n-            cstr!(\"target-features\"),\n-            &val,\n-        );\n+        to_add.push(llvm::CreateAttrStringValue(cx.llcx, cstr!(\"target-features\"), &val));\n     }\n+\n+    attributes::remove_from_llfn(llfn, Function, &to_remove);\n+    attributes::apply_to_llfn(llfn, Function, &to_add);\n }\n \n fn wasm_import_module(tcx: TyCtxt<'_>, id: DefId) -> Option<CString> {"}, {"sha": "dd3ada443895fabef4c4389167ebda493c66cea7", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=30d3ce06742fc5d0eb844239652a0af4d47bb095", "patch": "@@ -95,7 +95,8 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol) -> (ModuleCodegen\n             // If this codegen unit contains the main function, also create the\n             // wrapper here\n             if let Some(entry) = maybe_create_entry_wrapper::<Builder<'_, '_, '_>>(&cx) {\n-                attributes::sanitize(&cx, SanitizerSet::empty(), entry);\n+                let attrs = attributes::sanitize_attrs(&cx, SanitizerSet::empty());\n+                attributes::apply_to_llfn(entry, llvm::AttributePlace::Function, &attrs);\n             }\n \n             // Run replace-all-uses-with for statics that need it"}, {"sha": "5e78d6fc851a5e61eabbf1d48ea4009471c13b69", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=30d3ce06742fc5d0eb844239652a0af4d47bb095", "patch": "@@ -1,3 +1,4 @@\n+use crate::attributes;\n use crate::common::Funclet;\n use crate::context::CodegenCx;\n use crate::llvm::{self, BasicBlock, False};\n@@ -22,6 +23,7 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::Span;\n use rustc_target::abi::{self, call::FnAbi, Align, Size, WrappingRange};\n use rustc_target::spec::{HasTargetSpec, Target};\n+use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::ffi::CStr;\n use std::iter;\n@@ -1174,14 +1176,18 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn apply_attrs_to_cleanup_callsite(&mut self, llret: &'ll Value) {\n+        let mut attrs = SmallVec::<[_; 2]>::new();\n+\n         // Cleanup is always the cold path.\n-        llvm::Attribute::Cold.apply_callsite(llvm::AttributePlace::Function, llret);\n+        attrs.push(llvm::AttributeKind::Cold.create_attr(self.llcx));\n \n         // In LLVM versions with deferred inlining (currently, system LLVM < 14),\n         // inlining drop glue can lead to exponential size blowup, see #41696 and #92110.\n         if !llvm_util::is_rust_llvm() && llvm_util::get_version() < (14, 0, 0) {\n-            llvm::Attribute::NoInline.apply_callsite(llvm::AttributePlace::Function, llret);\n+            attrs.push(llvm::AttributeKind::NoInline.create_attr(self.llcx));\n         }\n+\n+        attributes::apply_to_callsite(llret, llvm::AttributePlace::Function, &attrs);\n     }\n }\n "}, {"sha": "74f0f5ab952162f7b2406e64dc704035c85ae756", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=30d3ce06742fc5d0eb844239652a0af4d47bb095", "patch": "@@ -520,7 +520,8 @@ impl<'ll, 'tcx> MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 } else {\n                     let fty = self.type_variadic_func(&[], self.type_i32());\n                     let llfn = self.declare_cfn(name, llvm::UnnamedAddr::Global, fty);\n-                    attributes::apply_target_cpu_attr(self, llfn);\n+                    let target_cpu = attributes::target_cpu_attr(self);\n+                    attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &[target_cpu]);\n                     llfn\n                 }\n             }\n@@ -550,12 +551,16 @@ impl<'ll, 'tcx> MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn set_frame_pointer_type(&self, llfn: &'ll Value) {\n-        attributes::set_frame_pointer_type(self, llfn)\n+        if let Some(attr) = attributes::frame_pointer_type_attr(self) {\n+            attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &[attr]);\n+        }\n     }\n \n     fn apply_target_cpu_attr(&self, llfn: &'ll Value) {\n-        attributes::apply_target_cpu_attr(self, llfn);\n-        attributes::apply_tune_cpu_attr(self, llfn);\n+        let mut attrs = SmallVec::<[_; 2]>::new();\n+        attrs.push(attributes::target_cpu_attr(self));\n+        attrs.extend(attributes::tune_cpu_attr(self));\n+        attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &attrs);\n     }\n \n     fn create_used_variable(&self) {"}, {"sha": "43d1a1f2389684ce4a4d2015b25de067825e4beb", "filename": "compiler/rustc_codegen_llvm/src/declare.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs?ref=30d3ce06742fc5d0eb844239652a0af4d47bb095", "patch": "@@ -18,8 +18,8 @@ use crate::llvm;\n use crate::llvm::AttributePlace::Function;\n use crate::type_::Type;\n use crate::value::Value;\n-use rustc_codegen_ssa::traits::*;\n use rustc_middle::ty::Ty;\n+use smallvec::SmallVec;\n use tracing::debug;\n \n /// Declare a function.\n@@ -41,12 +41,21 @@ fn declare_raw_fn<'ll>(\n     llvm::SetFunctionCallConv(llfn, callconv);\n     llvm::SetUnnamedAddress(llfn, unnamed);\n \n+    let mut attrs_to_remove = SmallVec::<[_; 4]>::new();\n+    let mut attrs_to_add = SmallVec::<[_; 4]>::new();\n+\n     if cx.tcx.sess.opts.cg.no_redzone.unwrap_or(cx.tcx.sess.target.disable_redzone) {\n-        llvm::Attribute::NoRedZone.apply_llfn(Function, llfn);\n+        attrs_to_add.push(llvm::AttributeKind::NoRedZone.create_attr(cx.llcx));\n     }\n \n-    attributes::default_optimisation_attrs(cx.tcx.sess, llfn);\n-    attributes::non_lazy_bind(cx.sess(), llfn);\n+    let (to_remove, to_add) = attributes::default_optimisation_attrs(cx);\n+    attrs_to_remove.extend(to_remove);\n+    attrs_to_add.extend(to_add);\n+\n+    attrs_to_add.extend(attributes::non_lazy_bind_attr(cx));\n+\n+    attributes::remove_from_llfn(llfn, Function, &attrs_to_remove);\n+    attributes::apply_to_llfn(llfn, Function, &attrs_to_add);\n \n     llfn\n }"}, {"sha": "31d1460e178bafe26256692a7aec31ff38fb1173", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=30d3ce06742fc5d0eb844239652a0af4d47bb095", "patch": "@@ -155,7 +155,7 @@ pub enum DLLStorageClass {\n /// though it is not ABI compatible (since it's a C++ enum)\n #[repr(C)]\n #[derive(Copy, Clone, Debug)]\n-pub enum Attribute {\n+pub enum AttributeKind {\n     AlwaysInline = 0,\n     ByVal = 1,\n     Cold = 2,\n@@ -643,6 +643,9 @@ extern \"C\" {\n extern \"C\" {\n     pub type ConstantInt;\n }\n+extern \"C\" {\n+    pub type Attribute;\n+}\n extern \"C\" {\n     pub type Metadata;\n }\n@@ -1169,6 +1172,21 @@ extern \"C\" {\n     ) -> Option<&Value>;\n     pub fn LLVMSetTailCall(CallInst: &Value, IsTailCall: Bool);\n \n+    // Operations on attributes\n+    pub fn LLVMRustCreateAttrNoValue(C: &Context, attr: AttributeKind) -> &Attribute;\n+    pub fn LLVMRustCreateAttrString(C: &Context, Name: *const c_char) -> &Attribute;\n+    pub fn LLVMRustCreateAttrStringValue(\n+        C: &Context,\n+        Name: *const c_char,\n+        Value: *const c_char,\n+    ) -> &Attribute;\n+    pub fn LLVMRustCreateAlignmentAttr(C: &Context, bytes: u64) -> &Attribute;\n+    pub fn LLVMRustCreateDereferenceableAttr(C: &Context, bytes: u64) -> &Attribute;\n+    pub fn LLVMRustCreateDereferenceableOrNullAttr(C: &Context, bytes: u64) -> &Attribute;\n+    pub fn LLVMRustCreateByValAttr<'a>(C: &'a Context, ty: &'a Type) -> &'a Attribute;\n+    pub fn LLVMRustCreateStructRetAttr<'a>(C: &'a Context, ty: &'a Type) -> &'a Attribute;\n+    pub fn LLVMRustCreateUWTableAttr(C: &Context, async_: bool) -> &Attribute;\n+\n     // Operations on functions\n     pub fn LLVMRustGetOrInsertFunction<'a>(\n         M: &'a Module,\n@@ -1177,20 +1195,18 @@ extern \"C\" {\n         FunctionTy: &'a Type,\n     ) -> &'a Value;\n     pub fn LLVMSetFunctionCallConv(Fn: &Value, CC: c_uint);\n-    pub fn LLVMRustAddAlignmentAttr(Fn: &Value, index: c_uint, bytes: u32);\n-    pub fn LLVMRustAddDereferenceableAttr(Fn: &Value, index: c_uint, bytes: u64);\n-    pub fn LLVMRustAddDereferenceableOrNullAttr(Fn: &Value, index: c_uint, bytes: u64);\n-    pub fn LLVMRustAddByValAttr(Fn: &Value, index: c_uint, ty: &Type);\n-    pub fn LLVMRustAddStructRetAttr(Fn: &Value, index: c_uint, ty: &Type);\n-    pub fn LLVMRustAddFunctionAttribute(Fn: &Value, index: c_uint, attr: Attribute);\n-    pub fn LLVMRustEmitUWTableAttr(Fn: &Value, async_: bool);\n-    pub fn LLVMRustAddFunctionAttrStringValue(\n+    pub fn LLVMRustAddFunctionAttributes<'a>(\n+        Fn: &'a Value,\n+        index: c_uint,\n+        Attrs: *const &'a Attribute,\n+        AttrsLen: size_t,\n+    );\n+    pub fn LLVMRustRemoveFunctionAttributes(\n         Fn: &Value,\n         index: c_uint,\n-        Name: *const c_char,\n-        Value: *const c_char,\n+        Attrs: *const AttributeKind,\n+        AttrsLen: size_t,\n     );\n-    pub fn LLVMRustRemoveFunctionAttributes(Fn: &Value, index: c_uint, attr: Attribute);\n \n     // Operations on parameters\n     pub fn LLVMIsAArgument(Val: &Value) -> Option<&Value>;\n@@ -1211,13 +1227,12 @@ extern \"C\" {\n \n     // Operations on call sites\n     pub fn LLVMSetInstructionCallConv(Instr: &Value, CC: c_uint);\n-    pub fn LLVMRustAddCallSiteAttribute(Instr: &Value, index: c_uint, attr: Attribute);\n-    pub fn LLVMRustAddCallSiteAttrString(Instr: &Value, index: c_uint, Name: *const c_char);\n-    pub fn LLVMRustAddAlignmentCallSiteAttr(Instr: &Value, index: c_uint, bytes: u32);\n-    pub fn LLVMRustAddDereferenceableCallSiteAttr(Instr: &Value, index: c_uint, bytes: u64);\n-    pub fn LLVMRustAddDereferenceableOrNullCallSiteAttr(Instr: &Value, index: c_uint, bytes: u64);\n-    pub fn LLVMRustAddByValCallSiteAttr(Instr: &Value, index: c_uint, ty: &Type);\n-    pub fn LLVMRustAddStructRetCallSiteAttr(Instr: &Value, index: c_uint, ty: &Type);\n+    pub fn LLVMRustAddCallSiteAttributes<'a>(\n+        Instr: &'a Value,\n+        index: c_uint,\n+        Attrs: *const &'a Attribute,\n+        AttrsLen: size_t,\n+    );\n \n     // Operations on load/store instructions (only)\n     pub fn LLVMSetVolatile(MemoryAccessInst: &Value, volatile: Bool);"}, {"sha": "1c1c4e0a159468675b3f76adb1df0447a576cd38", "filename": "compiler/rustc_codegen_llvm/src/llvm/mod.rs", "status": "modified", "additions": 46, "deletions": 27, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs?ref=30d3ce06742fc5d0eb844239652a0af4d47bb095", "patch": "@@ -31,24 +31,58 @@ impl LLVMRustResult {\n     }\n }\n \n-pub fn EmitUWTableAttr(llfn: &Value, async_: bool) {\n-    unsafe { LLVMRustEmitUWTableAttr(llfn, async_) }\n+pub fn AddFunctionAttributes<'ll>(llfn: &'ll Value, idx: AttributePlace, attrs: &[&'ll Attribute]) {\n+    unsafe {\n+        LLVMRustAddFunctionAttributes(llfn, idx.as_uint(), attrs.as_ptr(), attrs.len());\n+    }\n }\n \n-pub fn AddFunctionAttrStringValue(llfn: &Value, idx: AttributePlace, attr: &CStr, value: &CStr) {\n+pub fn RemoveFunctionAttributes(llfn: &Value, idx: AttributePlace, attrs: &[AttributeKind]) {\n     unsafe {\n-        LLVMRustAddFunctionAttrStringValue(llfn, idx.as_uint(), attr.as_ptr(), value.as_ptr())\n+        LLVMRustRemoveFunctionAttributes(llfn, idx.as_uint(), attrs.as_ptr(), attrs.len());\n     }\n }\n \n-pub fn AddFunctionAttrString(llfn: &Value, idx: AttributePlace, attr: &CStr) {\n+pub fn AddCallSiteAttributes<'ll>(\n+    callsite: &'ll Value,\n+    idx: AttributePlace,\n+    attrs: &[&'ll Attribute],\n+) {\n     unsafe {\n-        LLVMRustAddFunctionAttrStringValue(llfn, idx.as_uint(), attr.as_ptr(), std::ptr::null())\n+        LLVMRustAddCallSiteAttributes(callsite, idx.as_uint(), attrs.as_ptr(), attrs.len());\n     }\n }\n \n-pub fn AddCallSiteAttrString(callsite: &Value, idx: AttributePlace, attr: &CStr) {\n-    unsafe { LLVMRustAddCallSiteAttrString(callsite, idx.as_uint(), attr.as_ptr()) }\n+pub fn CreateAttrStringValue<'ll>(llcx: &'ll Context, attr: &CStr, value: &CStr) -> &'ll Attribute {\n+    unsafe { LLVMRustCreateAttrStringValue(llcx, attr.as_ptr(), value.as_ptr()) }\n+}\n+\n+pub fn CreateAttrString<'ll>(llcx: &'ll Context, attr: &CStr) -> &'ll Attribute {\n+    unsafe { LLVMRustCreateAttrStringValue(llcx, attr.as_ptr(), std::ptr::null()) }\n+}\n+\n+pub fn CreateAlignmentAttr(llcx: &Context, bytes: u64) -> &Attribute {\n+    unsafe { LLVMRustCreateAlignmentAttr(llcx, bytes) }\n+}\n+\n+pub fn CreateDereferenceableAttr(llcx: &Context, bytes: u64) -> &Attribute {\n+    unsafe { LLVMRustCreateDereferenceableAttr(llcx, bytes) }\n+}\n+\n+pub fn CreateDereferenceableOrNullAttr(llcx: &Context, bytes: u64) -> &Attribute {\n+    unsafe { LLVMRustCreateDereferenceableOrNullAttr(llcx, bytes) }\n+}\n+\n+pub fn CreateByValAttr<'ll>(llcx: &'ll Context, ty: &'ll Type) -> &'ll Attribute {\n+    unsafe { LLVMRustCreateByValAttr(llcx, ty) }\n+}\n+\n+pub fn CreateStructRetAttr<'ll>(llcx: &'ll Context, ty: &'ll Type) -> &'ll Attribute {\n+    unsafe { LLVMRustCreateStructRetAttr(llcx, ty) }\n+}\n+\n+pub fn CreateUWTableAttr(llcx: &Context, async_: bool) -> &Attribute {\n+    unsafe { LLVMRustCreateUWTableAttr(llcx, async_) }\n }\n \n #[derive(Copy, Clone)]\n@@ -132,25 +166,10 @@ pub fn set_thread_local_mode(global: &Value, mode: ThreadLocalMode) {\n     }\n }\n \n-impl Attribute {\n-    pub fn apply_llfn(&self, idx: AttributePlace, llfn: &Value) {\n-        unsafe { LLVMRustAddFunctionAttribute(llfn, idx.as_uint(), *self) }\n-    }\n-\n-    pub fn apply_callsite(&self, idx: AttributePlace, callsite: &Value) {\n-        unsafe { LLVMRustAddCallSiteAttribute(callsite, idx.as_uint(), *self) }\n-    }\n-\n-    pub fn unapply_llfn(&self, idx: AttributePlace, llfn: &Value) {\n-        unsafe { LLVMRustRemoveFunctionAttributes(llfn, idx.as_uint(), *self) }\n-    }\n-\n-    pub fn toggle_llfn(&self, idx: AttributePlace, llfn: &Value, set: bool) {\n-        if set {\n-            self.apply_llfn(idx, llfn);\n-        } else {\n-            self.unapply_llfn(idx, llfn);\n-        }\n+impl AttributeKind {\n+    /// Create an LLVM Attribute with no associated value.\n+    pub fn create_attr(self, llcx: &Context) -> &Attribute {\n+        unsafe { LLVMRustCreateAttrNoValue(llcx, self) }\n     }\n }\n "}, {"sha": "632a7985c799f9cd0322590a39c95069435db58c", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 60, "deletions": 105, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/30d3ce06742fc5d0eb844239652a0af4d47bb095/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=30d3ce06742fc5d0eb844239652a0af4d47bb095", "patch": "@@ -232,142 +232,97 @@ static Attribute::AttrKind fromRust(LLVMRustAttribute Kind) {\n   report_fatal_error(\"bad AttributeKind\");\n }\n \n-template<typename T> static inline void AddAttribute(T *t, unsigned Index, Attribute Attr) {\n+template<typename T> static inline void AddAttributes(T *t, unsigned Index,\n+                                                      LLVMAttributeRef *Attrs, size_t AttrsLen) {\n+  AttrBuilder B(t->getContext());\n+  for (LLVMAttributeRef Attr : makeArrayRef(Attrs, AttrsLen))\n+    B.addAttribute(unwrap(Attr));\n+  AttributeList PAL = t->getAttributes();\n+  AttributeList PALNew;\n #if LLVM_VERSION_LT(14, 0)\n-  t->addAttribute(Index, Attr);\n+  PALNew = PAL.addAttributes(t->getContext(), Index, B);\n #else\n-  t->addAttributeAtIndex(Index, Attr);\n+  PALNew = PAL.addAttributesAtIndex(t->getContext(), Index, B);\n #endif\n+  t->setAttributes(PALNew);\n }\n \n-extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned Index,\n-                                             LLVMRustAttribute RustAttr) {\n-  CallBase *Call = unwrap<CallBase>(Instr);\n-  Attribute Attr = Attribute::get(Call->getContext(), fromRust(RustAttr));\n-  AddAttribute(Call, Index, Attr);\n-}\n-\n-extern \"C\" void LLVMRustAddCallSiteAttrString(LLVMValueRef Instr, unsigned Index,\n-                                              const char *Name) {\n-  CallBase *Call = unwrap<CallBase>(Instr);\n-  Attribute Attr = Attribute::get(Call->getContext(), Name);\n-  AddAttribute(Call, Index, Attr);\n-}\n-\n-extern \"C\" void LLVMRustAddAlignmentCallSiteAttr(LLVMValueRef Instr,\n-                                                 unsigned Index,\n-                                                 uint32_t Bytes) {\n-  CallBase *Call = unwrap<CallBase>(Instr);\n-  Attribute Attr = Attribute::getWithAlignment(Call->getContext(), Align(Bytes));\n-  AddAttribute(Call, Index, Attr);\n+template<typename T> static inline void RemoveAttributes(T *t, unsigned Index,\n+                                                         LLVMRustAttribute *RustAttrs,\n+                                                         size_t RustAttrsLen) {\n+  AttributeMask Mask;\n+  for (LLVMRustAttribute RustAttr : makeArrayRef(RustAttrs, RustAttrsLen))\n+    Mask.addAttribute(fromRust(RustAttr));\n+  AttributeList PAL = t->getAttributes();\n+  AttributeList PALNew;\n+#if LLVM_VERSION_LT(14, 0)\n+  PALNew = PAL.removeAttributes(t->getContext(), Index, Mask);\n+#else\n+  PALNew = PAL.removeAttributesAtIndex(t->getContext(), Index, Mask);\n+#endif\n+  t->setAttributes(PALNew);\n }\n \n-extern \"C\" void LLVMRustAddDereferenceableCallSiteAttr(LLVMValueRef Instr,\n-                                                       unsigned Index,\n-                                                       uint64_t Bytes) {\n-  CallBase *Call = unwrap<CallBase>(Instr);\n-  Attribute Attr = Attribute::getWithDereferenceableBytes(Call->getContext(), Bytes);\n-  AddAttribute(Call, Index, Attr);\n+extern \"C\" void LLVMRustAddFunctionAttributes(LLVMValueRef Fn, unsigned Index,\n+                                              LLVMAttributeRef *Attrs, size_t AttrsLen) {\n+  Function *F = unwrap<Function>(Fn);\n+  AddAttributes(F, Index, Attrs, AttrsLen);\n }\n \n-extern \"C\" void LLVMRustAddDereferenceableOrNullCallSiteAttr(LLVMValueRef Instr,\n-                                                             unsigned Index,\n-                                                             uint64_t Bytes) {\n-  CallBase *Call = unwrap<CallBase>(Instr);\n-  Attribute Attr = Attribute::getWithDereferenceableOrNullBytes(Call->getContext(), Bytes);\n-  AddAttribute(Call, Index, Attr);\n+extern \"C\" void LLVMRustRemoveFunctionAttributes(LLVMValueRef Fn, unsigned Index,\n+                                                 LLVMRustAttribute *RustAttrs,\n+                                                 size_t RustAttrsLen) {\n+  Function *F = unwrap<Function>(Fn);\n+  RemoveAttributes(F, Index, RustAttrs, RustAttrsLen);\n }\n \n-extern \"C\" void LLVMRustAddByValCallSiteAttr(LLVMValueRef Instr, unsigned Index,\n-                                             LLVMTypeRef Ty) {\n+extern \"C\" void LLVMRustAddCallSiteAttributes(LLVMValueRef Instr, unsigned Index,\n+                                              LLVMAttributeRef *Attrs, size_t AttrsLen) {\n   CallBase *Call = unwrap<CallBase>(Instr);\n-  Attribute Attr = Attribute::getWithByValType(Call->getContext(), unwrap(Ty));\n-  AddAttribute(Call, Index, Attr);\n+  AddAttributes(Call, Index, Attrs, AttrsLen);\n }\n \n-extern \"C\" void LLVMRustAddStructRetCallSiteAttr(LLVMValueRef Instr, unsigned Index,\n-                                                 LLVMTypeRef Ty) {\n-  CallBase *Call = unwrap<CallBase>(Instr);\n-  Attribute Attr = Attribute::getWithStructRetType(Call->getContext(), unwrap(Ty));\n-  AddAttribute(Call, Index, Attr);\n+extern \"C\" LLVMAttributeRef LLVMRustCreateAttrNoValue(LLVMContextRef C,\n+                                                      LLVMRustAttribute RustAttr) {\n+  return wrap(Attribute::get(*unwrap(C), fromRust(RustAttr)));\n }\n \n-extern \"C\" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn, unsigned Index,\n-                                             LLVMRustAttribute RustAttr) {\n-  Function *A = unwrap<Function>(Fn);\n-  Attribute Attr = Attribute::get(A->getContext(), fromRust(RustAttr));\n-  AddAttribute(A, Index, Attr);\n+extern \"C\" LLVMAttributeRef LLVMRustCreateAttrStringValue(LLVMContextRef C,\n+                                                          const char *Name,\n+                                                          const char *Value) {\n+  return wrap(Attribute::get(*unwrap(C), StringRef(Name), StringRef(Value)));\n }\n \n-extern \"C\" void LLVMRustAddAlignmentAttr(LLVMValueRef Fn,\n-                                         unsigned Index,\n-                                         uint32_t Bytes) {\n-  Function *A = unwrap<Function>(Fn);\n-  AddAttribute(A, Index, Attribute::getWithAlignment(\n-      A->getContext(), llvm::Align(Bytes)));\n+extern \"C\" LLVMAttributeRef LLVMRustCreateAlignmentAttr(LLVMContextRef C,\n+                                                        uint64_t Bytes) {\n+  return wrap(Attribute::getWithAlignment(*unwrap(C), llvm::Align(Bytes)));\n }\n \n-extern \"C\" void LLVMRustAddDereferenceableAttr(LLVMValueRef Fn, unsigned Index,\n-                                               uint64_t Bytes) {\n-  Function *A = unwrap<Function>(Fn);\n-  AddAttribute(A, Index, Attribute::getWithDereferenceableBytes(A->getContext(),\n-                                                                Bytes));\n+extern \"C\" LLVMAttributeRef LLVMRustCreateDereferenceableAttr(LLVMContextRef C,\n+                                                              uint64_t Bytes) {\n+  return wrap(Attribute::getWithDereferenceableBytes(*unwrap(C), Bytes));\n }\n \n-extern \"C\" void LLVMRustAddDereferenceableOrNullAttr(LLVMValueRef Fn,\n-                                                     unsigned Index,\n-                                                     uint64_t Bytes) {\n-  Function *A = unwrap<Function>(Fn);\n-  AddAttribute(A, Index, Attribute::getWithDereferenceableOrNullBytes(\n-      A->getContext(), Bytes));\n+extern \"C\" LLVMAttributeRef LLVMRustCreateDereferenceableOrNullAttr(LLVMContextRef C,\n+                                                                    uint64_t Bytes) {\n+  return wrap(Attribute::getWithDereferenceableOrNullBytes(*unwrap(C), Bytes));\n }\n \n-extern \"C\" void LLVMRustAddByValAttr(LLVMValueRef Fn, unsigned Index,\n-                                     LLVMTypeRef Ty) {\n-  Function *F = unwrap<Function>(Fn);\n-  Attribute Attr = Attribute::getWithByValType(F->getContext(), unwrap(Ty));\n-  AddAttribute(F, Index, Attr);\n+extern \"C\" LLVMAttributeRef LLVMRustCreateByValAttr(LLVMContextRef C, LLVMTypeRef Ty) {\n+  return wrap(Attribute::getWithByValType(*unwrap(C), unwrap(Ty)));\n }\n \n-extern \"C\" void LLVMRustAddStructRetAttr(LLVMValueRef Fn, unsigned Index,\n-                                         LLVMTypeRef Ty) {\n-  Function *F = unwrap<Function>(Fn);\n-  Attribute Attr = Attribute::getWithStructRetType(F->getContext(), unwrap(Ty));\n-  AddAttribute(F, Index, Attr);\n+extern \"C\" LLVMAttributeRef LLVMRustCreateStructRetAttr(LLVMContextRef C, LLVMTypeRef Ty) {\n+  return wrap(Attribute::getWithStructRetType(*unwrap(C), unwrap(Ty)));\n }\n \n-extern \"C\" void LLVMRustEmitUWTableAttr(LLVMValueRef Fn, bool Async) {\n-  Function *F = unwrap<Function>(Fn);\n+extern \"C\" LLVMAttributeRef LLVMRustCreateUWTableAttr(LLVMContextRef C, bool Async) {\n #if LLVM_VERSION_LT(15, 0)\n-  Attribute Attr = Attribute::get(F->getContext(), Attribute::UWTable);\n-#else\n-  Attribute Attr = Attribute::getWithUWTableKind(\n-      F->getContext(), Async ? UWTableKind::Async : UWTableKind::Sync);\n-#endif\n-  AddAttribute(F, AttributeList::AttrIndex::FunctionIndex, Attr);\n-}\n-\n-extern \"C\" void LLVMRustAddFunctionAttrStringValue(LLVMValueRef Fn,\n-                                                   unsigned Index,\n-                                                   const char *Name,\n-                                                   const char *Value) {\n-  Function *F = unwrap<Function>(Fn);\n-  AddAttribute(F, Index, Attribute::get(\n-      F->getContext(), StringRef(Name), StringRef(Value)));\n-}\n-\n-extern \"C\" void LLVMRustRemoveFunctionAttributes(LLVMValueRef Fn,\n-                                                 unsigned Index,\n-                                                 LLVMRustAttribute RustAttr) {\n-  Function *F = unwrap<Function>(Fn);\n-  AttributeList PAL = F->getAttributes();\n-  AttributeList PALNew;\n-#if LLVM_VERSION_LT(14, 0)\n-  PALNew = PAL.removeAttribute(F->getContext(), Index, fromRust(RustAttr));\n+  return wrap(Attribute::get(*unwrap(C), Attribute::UWTable));\n #else\n-  PALNew = PAL.removeAttributeAtIndex(F->getContext(), Index, fromRust(RustAttr));\n+  return wrap(Attribute::getWithUWTableKind(\n+      *unwrap(C), Async ? UWTableKind::Async : UWTableKind::Sync));\n #endif\n-  F->setAttributes(PALNew);\n }\n \n // Enable a fast-math flag"}]}