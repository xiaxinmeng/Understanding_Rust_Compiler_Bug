{"sha": "b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3Nzk0YzBkM2Y1MzlmZmU5ZjFiZjczNWFkMDViNmRhNjMyNDIzNmU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-23T13:05:58Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-11T15:11:13Z"}, "message": "move `resolve_lifetimes` into a proper query\n\nNow that we made `resolve_lifetimes` into a query, elision errors no\nlonger abort compilation, which affects some tests.\n\nAlso, remove `dep_graph_crosscontaminate_tables` -- there is no a path in\nthe dep-graph, though red-green handles it. The same scenario\nis (correctly) tested by issue-42602.rs in any case.", "tree": {"sha": "79f064f28a40744fe154b2a57227221d3ec4f4e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79f064f28a40744fe154b2a57227221d3ec4f4e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "html_url": "https://github.com/rust-lang/rust/commit/b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d737ea7902fb10fd3161d8001ceaec70ebe074d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d737ea7902fb10fd3161d8001ceaec70ebe074d2", "html_url": "https://github.com/rust-lang/rust/commit/d737ea7902fb10fd3161d8001ceaec70ebe074d2"}], "stats": {"total": 520, "additions": 283, "deletions": 237}, "files": [{"sha": "06b745dbaaf1ca459723b3302960646cb949506b", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "patch": "@@ -588,9 +588,10 @@ define_dep_nodes!( <'tcx>\n     [] NativeLibraryKind(DefId),\n     [input] LinkArgs,\n \n-    [input] NamedRegion(DefIndex),\n-    [input] IsLateBound(DefIndex),\n-    [input] ObjectLifetimeDefaults(DefIndex),\n+    [] ResolveLifetimes(CrateNum),\n+    [] NamedRegion(DefIndex),\n+    [] IsLateBound(DefIndex),\n+    [] ObjectLifetimeDefaults(DefIndex),\n \n     [] Visibility(DefId),\n     [] DepKind(CrateNum),"}, {"sha": "d6107a8f55197320f1845a3638d67ffd37407009", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "patch": "@@ -28,7 +28,7 @@ pub use self::UnsafeSource::*;\n pub use self::Visibility::{Public, Inherited};\n \n use hir::def::Def;\n-use hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n+use hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n use util::nodemap::{NodeMap, FxHashSet};\n \n use syntax_pos::{Span, DUMMY_SP};\n@@ -92,6 +92,16 @@ pub struct HirId {\n     pub local_id: ItemLocalId,\n }\n \n+impl HirId {\n+    pub fn owner_def_id(self) -> DefId {\n+        DefId::local(self.owner)\n+    }\n+\n+    pub fn owner_local_def_id(self) -> LocalDefId {\n+        LocalDefId::from_def_id(DefId::local(self.owner))\n+    }\n+}\n+\n impl serialize::UseSpecializedEncodable for HirId {\n     fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         let HirId {"}, {"sha": "89df212938a423f416cf99659b8a8150c637e437", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 206, "deletions": 130, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "patch": "@@ -17,13 +17,13 @@\n \n use hir::map::Map;\n use hir::def::Def;\n-use hir::def_id::DefId;\n-use middle::cstore::CrateStore;\n-use session::Session;\n-use ty;\n+use hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n+use hir::ItemLocalId;\n+use ty::{self, TyCtxt};\n \n use std::cell::Cell;\n use std::mem::replace;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::attr;\n use syntax::ptr::P;\n@@ -181,9 +181,14 @@ impl<T: PartialEq> Set1<T> {\n \n pub type ObjectLifetimeDefault = Set1<Region>;\n \n-// Maps the id of each lifetime reference to the lifetime decl\n-// that it corresponds to.\n-pub struct NamedRegionMap {\n+/// Maps the id of each lifetime reference to the lifetime decl\n+/// that it corresponds to.\n+///\n+/// FIXME. This struct gets converted to a `ResolveLifetimes` for\n+/// actual use. It has the same data, but indexed by `DefIndex`.  This\n+/// is silly.\n+#[derive(Default)]\n+struct NamedRegionMap {\n     // maps from every use of a named (not anonymous) lifetime to a\n     // `Region` describing how that region is bound\n     pub defs: NodeMap<Region>,\n@@ -198,10 +203,22 @@ pub struct NamedRegionMap {\n     pub object_lifetime_defaults: NodeMap<Vec<ObjectLifetimeDefault>>,\n }\n \n+/// See `NamedRegionMap`.\n+pub struct ResolveLifetimes {\n+    defs: FxHashMap<LocalDefId, Rc<FxHashMap<ItemLocalId, Region>>>,\n+    late_bound: FxHashMap<LocalDefId, Rc<FxHashSet<ItemLocalId>>>,\n+    object_lifetime_defaults:\n+        FxHashMap<LocalDefId, Rc<FxHashMap<ItemLocalId, Rc<Vec<ObjectLifetimeDefault>>>>>,\n+}\n+\n+impl_stable_hash_for!(struct ::middle::resolve_lifetime::ResolveLifetimes {\n+    defs,\n+    late_bound,\n+    object_lifetime_defaults\n+});\n+\n struct LifetimeContext<'a, 'tcx: 'a> {\n-    sess: &'a Session,\n-    cstore: &'a CrateStore,\n-    hir_map: &'a Map<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n     // Deep breath. Our representation for poly trait refs contains a single\n@@ -299,22 +316,92 @@ type ScopeRef<'a> = &'a Scope<'a>;\n \n const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n \n-pub fn krate(\n-    sess: &Session,\n-    cstore: &CrateStore,\n-    hir_map: &Map,\n-) -> Result<NamedRegionMap, ErrorReported> {\n-    let krate = hir_map.krate();\n+pub fn provide(providers: &mut ty::maps::Providers) {\n+    *providers = ty::maps::Providers {\n+        resolve_lifetimes,\n+\n+        named_region_map: |tcx, id| {\n+            let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n+            tcx.resolve_lifetimes(LOCAL_CRATE).defs.get(&id).cloned()\n+        },\n+\n+        is_late_bound_map: |tcx, id| {\n+            let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n+            tcx.resolve_lifetimes(LOCAL_CRATE)\n+                .late_bound\n+                .get(&id)\n+                .cloned()\n+        },\n+\n+        object_lifetime_defaults_map: |tcx, id| {\n+            let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n+            tcx.resolve_lifetimes(LOCAL_CRATE)\n+                .object_lifetime_defaults\n+                .get(&id)\n+                .cloned()\n+        },\n+\n+        ..*providers\n+    };\n+\n+    // (*) FIXME the query should be defined to take a LocalDefId\n+}\n+\n+/// Computes the `ResolveLifetimes` map that contains data for the\n+/// entire crate. You should not read the result of this query\n+/// directly, but rather use `named_region_map`, `is_late_bound_map`,\n+/// etc.\n+fn resolve_lifetimes<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    for_krate: CrateNum,\n+) -> Rc<ResolveLifetimes> {\n+    assert_eq!(for_krate, LOCAL_CRATE);\n+\n+    let named_region_map = krate(tcx).unwrap_or_default();\n+\n+    let mut defs = FxHashMap();\n+    for (k, v) in named_region_map.defs {\n+        let hir_id = tcx.hir.node_to_hir_id(k);\n+        let map = defs.entry(hir_id.owner_local_def_id())\n+            .or_insert_with(|| Rc::new(FxHashMap()));\n+        Rc::get_mut(map).unwrap().insert(hir_id.local_id, v);\n+    }\n+    let mut late_bound = FxHashMap();\n+    for k in named_region_map.late_bound {\n+        let hir_id = tcx.hir.node_to_hir_id(k);\n+        let map = late_bound\n+            .entry(hir_id.owner_local_def_id())\n+            .or_insert_with(|| Rc::new(FxHashSet()));\n+        Rc::get_mut(map).unwrap().insert(hir_id.local_id);\n+    }\n+    let mut object_lifetime_defaults = FxHashMap();\n+    for (k, v) in named_region_map.object_lifetime_defaults {\n+        let hir_id = tcx.hir.node_to_hir_id(k);\n+        let map = object_lifetime_defaults\n+            .entry(hir_id.owner_local_def_id())\n+            .or_insert_with(|| Rc::new(FxHashMap()));\n+        Rc::get_mut(map)\n+            .unwrap()\n+            .insert(hir_id.local_id, Rc::new(v));\n+    }\n+\n+    Rc::new(ResolveLifetimes {\n+        defs,\n+        late_bound,\n+        object_lifetime_defaults,\n+    })\n+}\n+\n+fn krate<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> Result<NamedRegionMap, ErrorReported> {\n+    let krate = tcx.hir.krate();\n     let mut map = NamedRegionMap {\n         defs: NodeMap(),\n         late_bound: NodeSet(),\n-        object_lifetime_defaults: compute_object_lifetime_defaults(sess, hir_map),\n+        object_lifetime_defaults: compute_object_lifetime_defaults(tcx),\n     };\n-    sess.track_errors(|| {\n+    {\n         let mut visitor = LifetimeContext {\n-            sess,\n-            cstore,\n-            hir_map,\n+            tcx,\n             map: &mut map,\n             scope: ROOT_SCOPE,\n             trait_ref_hack: false,\n@@ -325,13 +412,13 @@ pub fn krate(\n         for (_, item) in &krate.items {\n             visitor.visit_item(item);\n         }\n-    })?;\n+    }\n     Ok(map)\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(self.hir_map)\n+        NestedVisitorMap::All(&self.tcx.hir)\n     }\n \n     // We want to nest trait/impl items in their parent, but nothing else.\n@@ -340,7 +427,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         // Each body has their own set of labels, save labels.\n         let saved = replace(&mut self.labels_in_fn, vec![]);\n-        let body = self.hir_map.body(body);\n+        let body = self.tcx.hir.body(body);\n         extract_labels(self, body);\n         self.with(\n             Scope::Body {\n@@ -393,7 +480,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let lifetimes = generics\n                     .lifetimes\n                     .iter()\n-                    .map(|def| Region::early(self.hir_map, &mut index, def))\n+                    .map(|def| Region::early(&self.tcx.hir, &mut index, def))\n                     .collect();\n                 let next_early_index = index + generics.ty_params.len() as u32;\n                 let scope = Scope::Binder {\n@@ -435,10 +522,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let scope = Scope::Binder {\n                     lifetimes: c.lifetimes\n                         .iter()\n-                        .map(|def| Region::late(self.hir_map, def))\n+                        .map(|def| Region::late(&self.tcx.hir, def))\n                         .collect(),\n-                    next_early_index,\n                     s: self.scope,\n+                    next_early_index,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n@@ -481,18 +568,18 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     // In the future, this should be fixed and this error should be removed.\n                     let def = self.map.defs.get(&lifetime.id);\n                     if let Some(&Region::LateBound(_, def_id, _)) = def {\n-                        if let Some(node_id) = self.hir_map.as_local_node_id(def_id) {\n+                        if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                             // Ensure that the parent of the def is an item, not HRTB\n-                            let parent_id = self.hir_map.get_parent_node(node_id);\n+                            let parent_id = self.tcx.hir.get_parent_node(node_id);\n                             let parent_impl_id = hir::ImplItemId { node_id: parent_id };\n                             let parent_trait_id = hir::TraitItemId { node_id: parent_id };\n-                            let krate = self.hir_map.forest.krate();\n+                            let krate = self.tcx.hir.forest.krate();\n                             if !(krate.items.contains_key(&parent_id)\n                                 || krate.impl_items.contains_key(&parent_impl_id)\n                                 || krate.trait_items.contains_key(&parent_trait_id))\n                             {\n                                 span_err!(\n-                                    self.sess,\n+                                    self.tcx.sess,\n                                     lifetime.span,\n                                     E0657,\n                                     \"`impl Trait` can only capture lifetimes \\\n@@ -517,7 +604,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let lifetimes = generics\n                     .lifetimes\n                     .iter()\n-                    .map(|lt_def| Region::early(self.hir_map, &mut index, lt_def))\n+                    .map(|lt_def| Region::early(&self.tcx.hir, &mut index, lt_def))\n                     .collect();\n \n                 let next_early_index = index + generics.ty_params.len() as u32;\n@@ -538,9 +625,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+        let tcx = self.tcx;\n         if let hir::TraitItemKind::Method(ref sig, _) = trait_item.node {\n             self.visit_early_late(\n-                Some(self.hir_map.get_parent(trait_item.id)),\n+                Some(tcx.hir.get_parent(trait_item.id)),\n                 &sig.decl,\n                 &trait_item.generics,\n                 |this| intravisit::walk_trait_item(this, trait_item),\n@@ -551,9 +639,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+        let tcx = self.tcx;\n         if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n             self.visit_early_late(\n-                Some(self.hir_map.get_parent(impl_item.id)),\n+                Some(tcx.hir.get_parent(impl_item.id)),\n                 &sig.decl,\n                 &impl_item.generics,\n                 |this| intravisit::walk_impl_item(this, impl_item),\n@@ -593,7 +682,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n-        check_mixed_explicit_and_in_band_defs(&self.sess, &generics.lifetimes);\n+        check_mixed_explicit_and_in_band_defs(self.tcx, &generics.lifetimes);\n         for ty_param in generics.ty_params.iter() {\n             walk_list!(self, visit_ty_param_bound, &ty_param.bounds);\n             if let Some(ref ty) = ty_param.default {\n@@ -614,10 +703,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         let scope = Scope::Binder {\n                             lifetimes: bound_lifetimes\n                                 .iter()\n-                                .map(|def| Region::late(self.hir_map, def))\n+                                .map(|def| Region::late(&self.tcx.hir, def))\n                                 .collect(),\n-                            next_early_index,\n                             s: self.scope,\n+                            next_early_index,\n                         };\n                         let result = self.with(scope, |old_scope, this| {\n                             this.check_lifetime_defs(old_scope, bound_lifetimes);\n@@ -663,7 +752,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         if !self.trait_ref_hack || !trait_ref.bound_lifetimes.is_empty() {\n             if self.trait_ref_hack {\n                 span_err!(\n-                    self.sess,\n+                    self.tcx.sess,\n                     trait_ref.span,\n                     E0316,\n                     \"nested quantification of lifetimes\"\n@@ -674,10 +763,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 lifetimes: trait_ref\n                     .bound_lifetimes\n                     .iter()\n-                    .map(|def| Region::late(self.hir_map, def))\n+                    .map(|def| Region::late(&self.tcx.hir, def))\n                     .collect(),\n-                next_early_index,\n                 s: self.scope,\n+                next_early_index,\n             };\n             self.with(scope, |old_scope, this| {\n                 this.check_lifetime_defs(old_scope, &trait_ref.bound_lifetimes);\n@@ -740,13 +829,16 @@ impl ShadowKind {\n     }\n }\n \n-fn check_mixed_explicit_and_in_band_defs(sess: &Session, lifetime_defs: &[hir::LifetimeDef]) {\n+fn check_mixed_explicit_and_in_band_defs(\n+    tcx: TyCtxt<'_, '_, '_>,\n+    lifetime_defs: &[hir::LifetimeDef],\n+) {\n     let oob_def = lifetime_defs.iter().find(|lt| !lt.in_band);\n     let in_band_def = lifetime_defs.iter().find(|lt| lt.in_band);\n \n     if let (Some(oob_def), Some(in_band_def)) = (oob_def, in_band_def) {\n         struct_span_err!(\n-            sess,\n+            tcx.sess,\n             in_band_def.lifetime.span,\n             E0688,\n             \"cannot mix in-band and explicit lifetime definitions\"\n@@ -759,11 +851,16 @@ fn check_mixed_explicit_and_in_band_defs(sess: &Session, lifetime_defs: &[hir::L\n     }\n }\n \n-fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, shadower: Shadower) {\n+fn signal_shadowing_problem(\n+    tcx: TyCtxt<'_, '_, '_>,\n+    name: ast::Name,\n+    orig: Original,\n+    shadower: Shadower,\n+) {\n     let mut err = if let (ShadowKind::Lifetime, ShadowKind::Lifetime) = (orig.kind, shadower.kind) {\n         // lifetime/lifetime shadowing is an error\n         struct_span_err!(\n-            sess,\n+            tcx.sess,\n             shadower.span,\n             E0496,\n             \"{} name `{}` shadows a \\\n@@ -775,7 +872,7 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n     } else {\n         // shadowing involving a label is only a warning, due to issues with\n         // labels and lifetimes not being macro-hygienic.\n-        sess.struct_span_warn(\n+        tcx.sess.struct_span_warn(\n             shadower.span,\n             &format!(\n                 \"{} name `{}` shadows a \\\n@@ -793,17 +890,15 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n \n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n // if one of the label shadows a lifetime or another label.\n-fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n+fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n     struct GatherLabels<'a, 'tcx: 'a> {\n-        sess: &'a Session,\n-        hir_map: &'a Map<'tcx>,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         scope: ScopeRef<'a>,\n         labels_in_fn: &'a mut Vec<(ast::Name, Span)>,\n     }\n \n     let mut gather = GatherLabels {\n-        sess: ctxt.sess,\n-        hir_map: ctxt.hir_map,\n+        tcx: ctxt.tcx,\n         scope: ctxt.scope,\n         labels_in_fn: &mut ctxt.labels_in_fn,\n     };\n@@ -820,21 +915,15 @@ fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n                     // FIXME (#24278): non-hygienic comparison\n                     if label == prior {\n                         signal_shadowing_problem(\n-                            self.sess,\n+                            self.tcx,\n                             label,\n                             original_label(prior_span),\n                             shadower_label(label_span),\n                         );\n                     }\n                 }\n \n-                check_if_label_shadows_lifetime(\n-                    self.sess,\n-                    self.hir_map,\n-                    self.scope,\n-                    label,\n-                    label_span,\n-                );\n+                check_if_label_shadows_lifetime(self.tcx, self.scope, label, label_span);\n \n                 self.labels_in_fn.push((label, label_span));\n             }\n@@ -851,10 +940,9 @@ fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n         }\n     }\n \n-    fn check_if_label_shadows_lifetime<'a>(\n-        sess: &'a Session,\n-        hir_map: &Map,\n-        mut scope: ScopeRef<'a>,\n+    fn check_if_label_shadows_lifetime(\n+        tcx: TyCtxt<'_, '_, '_>,\n+        mut scope: ScopeRef<'_>,\n         label: ast::Name,\n         label_span: Span,\n     ) {\n@@ -877,12 +965,12 @@ fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n                 } => {\n                     // FIXME (#24278): non-hygienic comparison\n                     if let Some(def) = lifetimes.get(&hir::LifetimeName::Name(label)) {\n-                        let node_id = hir_map.as_local_node_id(def.id().unwrap()).unwrap();\n+                        let node_id = tcx.hir.as_local_node_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n-                            sess,\n+                            tcx,\n                             label,\n-                            original_lifetime(hir_map.span(node_id)),\n+                            original_lifetime(tcx.hir.span(node_id)),\n                             shadower_label(label_span),\n                         );\n                         return;\n@@ -895,18 +983,17 @@ fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n }\n \n fn compute_object_lifetime_defaults(\n-    sess: &Session,\n-    hir_map: &Map,\n+    tcx: TyCtxt<'_, '_, '_>,\n ) -> NodeMap<Vec<ObjectLifetimeDefault>> {\n     let mut map = NodeMap();\n-    for item in hir_map.krate().items.values() {\n+    for item in tcx.hir.krate().items.values() {\n         match item.node {\n             hir::ItemStruct(_, ref generics)\n             | hir::ItemUnion(_, ref generics)\n             | hir::ItemEnum(_, ref generics)\n             | hir::ItemTy(_, ref generics)\n             | hir::ItemTrait(_, _, ref generics, ..) => {\n-                let result = object_lifetime_defaults_for_item(hir_map, generics);\n+                let result = object_lifetime_defaults_for_item(tcx, generics);\n \n                 // Debugging aid.\n                 if attr::contains_name(&item.attrs, \"rustc_object_lifetime_default\") {\n@@ -926,7 +1013,7 @@ fn compute_object_lifetime_defaults(\n                         })\n                         .collect::<Vec<String>>()\n                         .join(\",\");\n-                    sess.span_err(item.span, &object_lifetime_default_reprs);\n+                    tcx.sess.span_err(item.span, &object_lifetime_default_reprs);\n                 }\n \n                 map.insert(item.id, result);\n@@ -941,7 +1028,7 @@ fn compute_object_lifetime_defaults(\n /// of the form `T:'a` so as to determine the `ObjectLifetimeDefault`\n /// for each type parameter.\n fn object_lifetime_defaults_for_item(\n-    hir_map: &Map,\n+    tcx: TyCtxt<'_, '_, '_>,\n     generics: &hir::Generics,\n ) -> Vec<ObjectLifetimeDefault> {\n     fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::TyParamBound]) {\n@@ -960,7 +1047,7 @@ fn object_lifetime_defaults_for_item(\n \n             add_bounds(&mut set, &param.bounds);\n \n-            let param_def_id = hir_map.local_def_id(param.id);\n+            let param_def_id = tcx.hir.local_def_id(param.id);\n             for predicate in &generics.where_clause.predicates {\n                 // Look for `type: ...` where clauses.\n                 let data = match *predicate {\n@@ -996,7 +1083,7 @@ fn object_lifetime_defaults_for_item(\n                             .enumerate()\n                             .find(|&(_, def)| def.lifetime.name == name)\n                             .map_or(Set1::Many, |(i, def)| {\n-                                let def_id = hir_map.local_def_id(def.lifetime.id);\n+                                let def_id = tcx.hir.local_def_id(def.lifetime.id);\n                                 let origin = LifetimeDefOrigin::from_is_in_band(def.in_band);\n                                 Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n                             })\n@@ -1022,19 +1109,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         F: for<'b> FnOnce(ScopeRef, &mut LifetimeContext<'b, 'tcx>),\n     {\n         let LifetimeContext {\n-            sess,\n-            cstore,\n-            hir_map,\n-            ref mut map,\n-            ..\n+            tcx, ref mut map, ..\n         } = *self;\n         let labels_in_fn = replace(&mut self.labels_in_fn, vec![]);\n         let xcrate_object_lifetime_defaults =\n             replace(&mut self.xcrate_object_lifetime_defaults, DefIdMap());\n         let mut this = LifetimeContext {\n-            sess,\n-            cstore,\n-            hir_map,\n+            tcx,\n             map: *map,\n             scope: &wrap_scope,\n             trait_ref_hack: self.trait_ref_hack,\n@@ -1081,7 +1162,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // Find the start of nested early scopes, e.g. in methods.\n         let mut index = 0;\n         if let Some(parent_id) = parent_id {\n-            let parent = self.hir_map.expect_item(parent_id);\n+            let parent = self.tcx.hir.expect_item(parent_id);\n             if let hir::ItemTrait(..) = parent.node {\n                 index += 1; // Self comes first.\n             }\n@@ -1099,9 +1180,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             .iter()\n             .map(|def| {\n                 if self.map.late_bound.contains(&def.lifetime.id) {\n-                    Region::late(self.hir_map, def)\n+                    Region::late(&self.tcx.hir, def)\n                 } else {\n-                    Region::early(self.hir_map, &mut index, def)\n+                    Region::early(&self.tcx.hir, &mut index, def)\n                 }\n             })\n             .collect();\n@@ -1182,8 +1263,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             if let Region::EarlyBound(..) = def {\n                 // Do not free early-bound regions, only late-bound ones.\n             } else if let Some(body_id) = outermost_body {\n-                let fn_id = self.hir_map.body_owner(body_id);\n-                match self.hir_map.get(fn_id) {\n+                let fn_id = self.tcx.hir.body_owner(body_id);\n+                match self.tcx.hir.get(fn_id) {\n                     hir::map::NodeItem(&hir::Item {\n                         node: hir::ItemFn(..),\n                         ..\n@@ -1196,7 +1277,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         node: hir::ImplItemKind::Method(..),\n                         ..\n                     }) => {\n-                        let scope = self.hir_map.local_def_id(fn_id);\n+                        let scope = self.tcx.hir.local_def_id(fn_id);\n                         def = Region::Free(scope, def.id().unwrap());\n                     }\n                     _ => {}\n@@ -1209,7 +1290,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     Region::EarlyBound(_, _, LifetimeDefOrigin::InBand)\n                     | Region::LateBound(_, _, LifetimeDefOrigin::InBand) => {\n                         struct_span_err!(\n-                            self.sess,\n+                            self.tcx.sess,\n                             lifetime_ref.span,\n                             E0687,\n                             \"lifetimes used in `fn` or `Fn` syntax must be \\\n@@ -1229,7 +1310,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             self.insert_lifetime(lifetime_ref, def);\n         } else {\n             struct_span_err!(\n-                self.sess,\n+                self.tcx.sess,\n                 lifetime_ref.span,\n                 E0261,\n                 \"use of undeclared lifetime name `{}`\",\n@@ -1264,11 +1345,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // Figure out if this is a type/trait segment,\n         // which requires object lifetime defaults.\n         let parent_def_id = |this: &mut Self, def_id: DefId| {\n-            let def_key = if def_id.is_local() {\n-                this.hir_map.def_key(def_id)\n-            } else {\n-                this.cstore.def_key(def_id)\n-            };\n+            let def_key = this.tcx.def_key(def_id);\n             DefId {\n                 krate: def_id.krate,\n                 index: def_key.parent.expect(\"missing parent\"),\n@@ -1307,32 +1384,28 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             };\n \n             let map = &self.map;\n-            let unsubst = if let Some(id) = self.hir_map.as_local_node_id(def_id) {\n+            let unsubst = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n                 &map.object_lifetime_defaults[&id]\n             } else {\n-                let cstore = self.cstore;\n-                let sess = self.sess;\n+                let tcx = self.tcx;\n                 self.xcrate_object_lifetime_defaults\n                     .entry(def_id)\n                     .or_insert_with(|| {\n-                        cstore\n-                            .item_generics_cloned_untracked(def_id, sess)\n+                        tcx.generics_of(def_id)\n                             .types\n-                            .into_iter()\n+                            .iter()\n                             .map(|def| def.object_lifetime_default)\n                             .collect()\n                     })\n             };\n             unsubst\n                 .iter()\n                 .map(|set| match *set {\n-                    Set1::Empty => {\n-                        if in_body {\n-                            None\n-                        } else {\n-                            Some(Region::Static)\n-                        }\n-                    }\n+                    Set1::Empty => if in_body {\n+                        None\n+                    } else {\n+                        Some(Region::Static)\n+                    },\n                     Set1::One(r) => r.subst(&params.lifetimes, map),\n                     Set1::Many => None,\n                 })\n@@ -1387,8 +1460,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // and whether there's a `self` argument (treated specially).\n         let mut assoc_item_kind = None;\n         let mut impl_self = None;\n-        let parent = self.hir_map.get_parent_node(output.id);\n-        let body = match self.hir_map.get(parent) {\n+        let parent = self.tcx.hir.get_parent_node(output.id);\n+        let body = match self.tcx.hir.get(parent) {\n             // `fn` definitions and methods.\n             hir::map::NodeItem(&hir::Item {\n                 node: hir::ItemFn(.., body),\n@@ -1399,8 +1472,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 node: hir::TraitItemKind::Method(_, ref m),\n                 ..\n             }) => {\n-                match self.hir_map\n-                    .expect_item(self.hir_map.get_parent(parent))\n+                match self.tcx\n+                    .hir\n+                    .expect_item(self.tcx.hir.get_parent(parent))\n                     .node\n                 {\n                     hir::ItemTrait(.., ref trait_items) => {\n@@ -1421,8 +1495,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 node: hir::ImplItemKind::Method(_, body),\n                 ..\n             }) => {\n-                match self.hir_map\n-                    .expect_item(self.hir_map.get_parent(parent))\n+                match self.tcx\n+                    .hir\n+                    .expect_item(self.tcx.hir.get_parent(parent))\n                     .node\n                 {\n                     hir::ItemImpl(.., ref self_ty, ref impl_items) => {\n@@ -1660,7 +1735,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         };\n \n         let mut err = struct_span_err!(\n-            self.sess,\n+            self.tcx.sess,\n             span,\n             E0106,\n             \"missing lifetime specifier{}\",\n@@ -1706,8 +1781,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } = info;\n \n             let help_name = if let Some(body) = parent {\n-                let arg = &self.hir_map.body(body).arguments[index];\n-                format!(\"`{}`\", self.hir_map.node_to_pretty_string(arg.pat.id))\n+                let arg = &self.tcx.hir.body(body).arguments[index];\n+                format!(\"`{}`\", self.tcx.hir.node_to_pretty_string(arg.pat.id))\n             } else {\n                 format!(\"argument {}\", index + 1)\n             };\n@@ -1802,7 +1877,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         let lifetime = lifetime.lifetime;\n                         let name = lifetime.name.name();\n                         let mut err = struct_span_err!(\n-                            self.sess,\n+                            self.tcx.sess,\n                             lifetime.span,\n                             E0262,\n                             \"invalid lifetime parameter name: `{}`\",\n@@ -1824,7 +1899,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 if lifetime_i.lifetime.name == lifetime_j.lifetime.name {\n                     struct_span_err!(\n-                        self.sess,\n+                        self.tcx.sess,\n                         lifetime_j.lifetime.span,\n                         E0263,\n                         \"lifetime name `{}` declared twice in the same scope\",\n@@ -1842,7 +1917,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 match bound.name {\n                     hir::LifetimeName::Underscore => {\n                         let mut err = struct_span_err!(\n-                            self.sess,\n+                            self.tcx.sess,\n                             bound.span,\n                             E0637,\n                             \"invalid lifetime bound name: `'_`\"\n@@ -1852,7 +1927,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     }\n                     hir::LifetimeName::Static => {\n                         self.insert_lifetime(bound, Region::Static);\n-                        self.sess\n+                        self.tcx\n+                            .sess\n                             .struct_span_warn(\n                                 lifetime_i.lifetime.span.to(bound.span),\n                                 &format!(\n@@ -1880,7 +1956,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             // FIXME (#24278): non-hygienic comparison\n             if lifetime.name.name() == label {\n                 signal_shadowing_problem(\n-                    self.sess,\n+                    self.tcx,\n                     label,\n                     original_label(label_span),\n                     shadower_lifetime(&lifetime),\n@@ -1907,12 +1983,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     next_early_index: _,\n                 } => {\n                     if let Some(&def) = lifetimes.get(&lifetime.name) {\n-                        let node_id = self.hir_map.as_local_node_id(def.id().unwrap()).unwrap();\n+                        let node_id = self.tcx.hir.as_local_node_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n-                            self.sess,\n+                            self.tcx,\n                             lifetime.name.name(),\n-                            original_lifetime(self.hir_map.span(node_id)),\n+                            original_lifetime(self.tcx.hir.span(node_id)),\n                             shadower_lifetime(&lifetime),\n                         );\n                         return;\n@@ -1935,9 +2011,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         debug!(\n             \"insert_lifetime: {} resolved to {:?} span={:?}\",\n-            self.hir_map.node_to_string(lifetime_ref.id),\n+            self.tcx.hir.node_to_string(lifetime_ref.id),\n             def,\n-            self.sess.codemap().span_to_string(lifetime_ref.span)\n+            self.tcx.sess.codemap().span_to_string(lifetime_ref.span)\n         );\n         self.map.defs.insert(lifetime_ref.id, def);\n     }\n@@ -2007,13 +2083,13 @@ fn insert_late_bound_lifetimes(\n     walk_list!(\n         &mut appears_in_where_clause,\n         visit_ty,\n-        decl.inputs.iter().filter(|ty| {\n-            if let hir::TyImplTraitUniversal(..) = ty.node {\n+        decl.inputs\n+            .iter()\n+            .filter(|ty| if let hir::TyImplTraitUniversal(..) = ty.node {\n                 true\n             } else {\n                 false\n-            }\n-        })\n+            })\n     );\n     for lifetime_def in &generics.lifetimes {\n         if !lifetime_def.bounds.is_empty() {"}, {"sha": "4315d59f77165f65e1cf290b7400d714a9436909", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "patch": "@@ -802,8 +802,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// Export map produced by name resolution.\n     export_map: FxHashMap<DefId, Rc<Vec<Export>>>,\n \n-    named_region_map: NamedRegionMap,\n-\n     pub hir: hir_map::Map<'tcx>,\n \n     /// A map from DefPathHash -> DefId. Includes DefIds from the local crate\n@@ -986,7 +984,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                   arenas: &'tcx GlobalArenas<'tcx>,\n                                   arena: &'tcx DroplessArena,\n                                   resolutions: ty::Resolutions,\n-                                  named_region_map: resolve_lifetime::NamedRegionMap,\n                                   hir: hir_map::Map<'tcx>,\n                                   on_disk_query_result_cache: maps::OnDiskCache<'tcx>,\n                                   crate_name: &str,\n@@ -1044,27 +1041,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                             .insert(hir_id.local_id,\n                                     Rc::new(StableVec::new(v)));\n         }\n-        let mut defs = FxHashMap();\n-        for (k, v) in named_region_map.defs {\n-            let hir_id = hir.node_to_hir_id(k);\n-            let map = defs.entry(hir_id.owner)\n-                .or_insert_with(|| Rc::new(FxHashMap()));\n-            Rc::get_mut(map).unwrap().insert(hir_id.local_id, v);\n-        }\n-        let mut late_bound = FxHashMap();\n-        for k in named_region_map.late_bound {\n-            let hir_id = hir.node_to_hir_id(k);\n-            let map = late_bound.entry(hir_id.owner)\n-                .or_insert_with(|| Rc::new(FxHashSet()));\n-            Rc::get_mut(map).unwrap().insert(hir_id.local_id);\n-        }\n-        let mut object_lifetime_defaults = FxHashMap();\n-        for (k, v) in named_region_map.object_lifetime_defaults {\n-            let hir_id = hir.node_to_hir_id(k);\n-            let map = object_lifetime_defaults.entry(hir_id.owner)\n-                .or_insert_with(|| Rc::new(FxHashMap()));\n-            Rc::get_mut(map).unwrap().insert(hir_id.local_id, Rc::new(v));\n-        }\n \n         tls::enter_global(GlobalCtxt {\n             sess: s,\n@@ -1074,11 +1050,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             dep_graph: dep_graph.clone(),\n             on_disk_query_result_cache,\n             types: common_types,\n-            named_region_map: NamedRegionMap {\n-                defs,\n-                late_bound,\n-                object_lifetime_defaults,\n-            },\n             trait_map,\n             export_map: resolutions.export_map.into_iter().map(|(k, v)| {\n                 (k, Rc::new(v))\n@@ -2176,27 +2147,12 @@ impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n     }\n }\n \n-struct NamedRegionMap {\n-    defs: FxHashMap<DefIndex, Rc<FxHashMap<ItemLocalId, resolve_lifetime::Region>>>,\n-    late_bound: FxHashMap<DefIndex, Rc<FxHashSet<ItemLocalId>>>,\n-    object_lifetime_defaults:\n-        FxHashMap<\n-            DefIndex,\n-            Rc<FxHashMap<ItemLocalId, Rc<Vec<ObjectLifetimeDefault>>>>,\n-        >,\n-}\n-\n pub fn provide(providers: &mut ty::maps::Providers) {\n     // FIXME(#44234) - almost all of these queries have no sub-queries and\n     // therefore no actual inputs, they're just reading tables calculated in\n     // resolve! Does this work? Unsure! That's what the issue is about\n     providers.in_scope_traits_map = |tcx, id| tcx.gcx.trait_map.get(&id).cloned();\n     providers.module_exports = |tcx, id| tcx.gcx.export_map.get(&id).cloned();\n-    providers.named_region_map = |tcx, id| tcx.gcx.named_region_map.defs.get(&id).cloned();\n-    providers.is_late_bound_map = |tcx, id| tcx.gcx.named_region_map.late_bound.get(&id).cloned();\n-    providers.object_lifetime_defaults_map = |tcx, id| {\n-        tcx.gcx.named_region_map.object_lifetime_defaults.get(&id).cloned()\n-    };\n     providers.crate_name = |tcx, id| {\n         assert_eq!(id, LOCAL_CRATE);\n         tcx.crate_name"}, {"sha": "a556861147e396f85b728666f564206f448fdcea", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "patch": "@@ -443,6 +443,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::link_args<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::resolve_lifetimes<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"resolving lifetimes\")\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::named_region_map<'tcx> {\n     fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n         format!(\"looking up a named region\")"}, {"sha": "7ba063adff4c2b7cb1080a472132761273406925", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "patch": "@@ -23,7 +23,7 @@ use middle::cstore::{NativeLibraryKind, DepKind, CrateSource, ExternConstBody};\n use middle::privacy::AccessLevels;\n use middle::reachable::ReachableSet;\n use middle::region;\n-use middle::resolve_lifetime::{Region, ObjectLifetimeDefault};\n+use middle::resolve_lifetime::{ResolveLifetimes, Region, ObjectLifetimeDefault};\n use middle::stability::{self, DeprecationEntry};\n use middle::lang_items::{LanguageItems, LangItem};\n use middle::exported_symbols::SymbolExportLevel;\n@@ -306,6 +306,8 @@ define_maps! { <'tcx>\n         -> Option<NativeLibraryKind>,\n     [] fn link_args: link_args_node(CrateNum) -> Rc<Vec<String>>,\n \n+    // Lifetime resolution. See `middle::resolve_lifetimes`.\n+    [] fn resolve_lifetimes: ResolveLifetimes(CrateNum) -> Rc<ResolveLifetimes>,\n     [] fn named_region_map: NamedRegion(DefIndex) ->\n         Option<Rc<FxHashMap<ItemLocalId, Region>>>,\n     [] fn is_late_bound_map: IsLateBound(DefIndex) ->"}, {"sha": "8875439be6b3d08833ab255ce6113ee7c0368fdb", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "patch": "@@ -875,6 +875,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::NativeLibraryKind => { force!(native_library_kind, def_id!()); }\n         DepKind::LinkArgs => { force!(link_args, LOCAL_CRATE); }\n \n+        DepKind::ResolveLifetimes => { force!(resolve_lifetimes, krate!()); }\n         DepKind::NamedRegion => { force!(named_region_map, def_id!().index); }\n         DepKind::IsLateBound => { force!(is_late_bound_map, def_id!().index); }\n         DepKind::ObjectLifetimeDefaults => {"}, {"sha": "86b05955f19727c77cc5d14e9a32f674cf2d18ae", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "patch": "@@ -19,7 +19,7 @@ use rustc::session::CompileIncomplete;\n use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n-use rustc::middle::{self, stability, reachable};\n+use rustc::middle::{self, stability, reachable, resolve_lifetime};\n use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt, Resolutions, GlobalArenas};\n@@ -928,6 +928,7 @@ pub fn default_provide(providers: &mut ty::maps::Providers) {\n     borrowck::provide(providers);\n     mir::provide(providers);\n     reachable::provide(providers);\n+    resolve_lifetime::provide(providers);\n     rustc_privacy::provide(providers);\n     DefaultTransCrate::provide(providers);\n     typeck::provide(providers);\n@@ -984,10 +985,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(control: &CompileController,\n         \"load query result cache\",\n         || rustc_incremental::load_query_result_cache(sess));\n \n-    let named_region_map = time(time_passes,\n-                                \"lifetime resolution\",\n-                                || middle::resolve_lifetime::krate(sess, cstore, &hir_map))?;\n-\n     time(time_passes,\n          \"looking for entry point\",\n          || middle::entry::find_entry_point(sess, &hir_map));\n@@ -1022,7 +1019,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(control: &CompileController,\n                              arenas,\n                              arena,\n                              resolutions,\n-                             named_region_map,\n                              hir_map,\n                              query_result_on_disk_cache,\n                              name,"}, {"sha": "2f55bee210838a55a0098de2af70c4fee74362f9", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "patch": "@@ -18,7 +18,6 @@ use rustc_lint;\n use rustc_resolve::MakeGlobMap;\n use rustc_trans;\n use rustc::middle::region;\n-use rustc::middle::resolve_lifetime;\n use rustc::ty::subst::{Kind, Subst};\n use rustc::traits::{ObligationCause, Reveal};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -137,7 +136,6 @@ fn test_env<F>(source_string: &str,\n     let hir_map = hir_map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n \n     // run just enough stuff to build a tcx:\n-    let named_region_map = resolve_lifetime::krate(&sess, &*cstore, &hir_map);\n     let (tx, _rx) = mpsc::channel();\n     let outputs = OutputFilenames {\n         out_directory: PathBuf::new(),\n@@ -153,7 +151,6 @@ fn test_env<F>(source_string: &str,\n                              &arenas,\n                              &arena,\n                              resolutions,\n-                             named_region_map.unwrap(),\n                              hir_map,\n                              OnDiskCache::new_empty(sess.codemap()),\n                              \"test_crate\","}, {"sha": "83aec27c15315d4e5af72a1873e9010753be9cb1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "patch": "@@ -140,7 +140,18 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n \n             None => {\n-                self.re_infer(lifetime.span, def).expect(\"unelided lifetime in signature\")\n+                self.re_infer(lifetime.span, def)\n+                    .unwrap_or_else(|| {\n+                        // This indicates an illegal lifetime\n+                        // elision. `resolve_lifetime` should have\n+                        // reported an error in this case -- but if\n+                        // not, let's error out.\n+                        tcx.sess.delay_span_bug(lifetime.span, \"unelided lifetime in signature\");\n+\n+                        // Supply some dummy value. We don't have an\n+                        // `re_error`, annoyingly, so use `'static`.\n+                        tcx.types.re_static\n+                    })\n             }\n         };\n "}, {"sha": "2520e3a095e1d623bb510f8e4ae125d3cf7c6ed3", "filename": "src/test/compile-fail/dep_graph_crosscontaminate_tables.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d737ea7902fb10fd3161d8001ceaec70ebe074d2/src%2Ftest%2Fcompile-fail%2Fdep_graph_crosscontaminate_tables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d737ea7902fb10fd3161d8001ceaec70ebe074d2/src%2Ftest%2Fcompile-fail%2Fdep_graph_crosscontaminate_tables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep_graph_crosscontaminate_tables.rs?ref=d737ea7902fb10fd3161d8001ceaec70ebe074d2", "patch": "@@ -1,40 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that the `TypeckTables` nodes for impl items are independent from\n-// one another.\n-\n-// compile-flags: -Z query-dep-graph\n-\n-#![feature(rustc_attrs)]\n-\n-struct Foo {\n-    x: u8\n-}\n-\n-impl Foo {\n-    // Changing the item `new`...\n-    #[rustc_if_this_changed(HirBody)]\n-    fn new() -> Foo {\n-        Foo { x: 0 }\n-    }\n-\n-    // ...should not cause us to recompute the tables for `with`!\n-    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR no path\n-    fn with(x: u8) -> Foo {\n-        Foo { x: x }\n-    }\n-}\n-\n-fn main() {\n-    let f = Foo::new();\n-    let g = Foo::with(22);\n-    assert_eq!(f.x, g.x - 22);\n-}"}, {"sha": "1204cc0df47b1e568b20444ca7e1069a9ccae372", "filename": "src/test/compile-fail/where-lifetime-resolution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fcompile-fail%2Fwhere-lifetime-resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fcompile-fail%2Fwhere-lifetime-resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-lifetime-resolution.rs?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Trait1 {}\n-trait Trait2 {}\n+trait Trait1<'a> {}\n+trait Trait2<'a, 'b> {}\n \n fn f() where\n     for<'a> Trait1<'a>: Trait1<'a>, // OK"}, {"sha": "6afd794de8484384aab05d5373236a383f4f6a68", "filename": "src/test/incremental/issue-42602.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fincremental%2Fissue-42602.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fincremental%2Fissue-42602.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-42602.rs?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "patch": "@@ -16,8 +16,9 @@\n // This was fixed by improving the resolution of the `FnOnce` trait\n // selection node.\n \n-// revisions:cfail1\n+// revisions:cfail1 cfail2 cfail3\n // compile-flags:-Zquery-dep-graph\n+// must-compile-successfully\n \n #![feature(rustc_attrs)]\n \n@@ -27,16 +28,24 @@ fn main() {\n }\n \n mod a {\n-    #[rustc_if_this_changed(HirBody)]\n+    #[cfg(cfail1)]\n     pub fn foo() {\n         let x = vec![1, 2, 3];\n         let v = || ::std::mem::drop(x);\n         v();\n     }\n+\n+    #[cfg(not(cfail1))]\n+    pub fn foo() {\n+        let x = vec![1, 2, 3, 4];\n+        let v = || ::std::mem::drop(x);\n+        v();\n+    }\n }\n \n mod b {\n-    #[rustc_then_this_would_need(TypeckTables)] //[cfail1]~ ERROR no path\n+    #[rustc_clean(cfg=\"cfail2\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     pub fn bar() {\n         let x = vec![1, 2, 3];\n         let v = || ::std::mem::drop(x);"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/print_type_sizes/anonymous.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.stderr?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/print_type_sizes/anonymous.stdout", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.stdout?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/print_type_sizes/multiple_types.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Fprint_type_sizes%2Fmultiple_types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Fprint_type_sizes%2Fmultiple_types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fmultiple_types.stderr?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/print_type_sizes/packed.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.stderr?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/print_type_sizes/repr-align.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.stderr?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e"}, {"sha": "208fc2ea08957d2922e38fb2d405bffcb12116f8", "filename": "src/test/ui/rfc1598-generic-associated-types/construct_with_other_type.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.rs?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "patch": "@@ -23,6 +23,7 @@ trait Baz {\n impl<T> Baz for T where T: Foo {\n     type Quux<'a> = <T as Foo>::Bar<'a, 'static>;\n     //~^ ERROR undeclared lifetime\n+    //~| ERROR lifetime parameters are not allowed on this type [E0110]\n }\n \n fn main() {}"}, {"sha": "6a2047d10e6a54ad130e7bf48520372748d82de8", "filename": "src/test/ui/rfc1598-generic-associated-types/construct_with_other_type.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.stderr?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "patch": "@@ -4,5 +4,11 @@ error[E0261]: use of undeclared lifetime name `'a`\n 24 |     type Quux<'a> = <T as Foo>::Bar<'a, 'static>;\n    |                                     ^^ undeclared lifetime\n \n-error: aborting due to previous error\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/construct_with_other_type.rs:24:37\n+   |\n+24 |     type Quux<'a> = <T as Foo>::Bar<'a, 'static>;\n+   |                                     ^^ lifetime parameter not allowed on this type\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "b99cb2a18309e11b1ed2961a47f94e67438cea2f", "filename": "src/test/ui/rfc1598-generic-associated-types/generic-associated-types-where.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric-associated-types-where.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric-associated-types-where.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric-associated-types-where.stderr?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "patch": "@@ -4,5 +4,5 @@ error[E0261]: use of undeclared lifetime name `'a`\n 34 |     type WithDefault<'a, T> = &'a Iterator<T>;\n    |                                ^^ undeclared lifetime\n \n-error: aborting due to previous error\n+error: cannot continue compilation due to previous error\n "}, {"sha": "219554b587a9e45adf110426b2e1b4fc22b18b2e", "filename": "src/test/ui/rfc1598-generic-associated-types/iterable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.rs?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "patch": "@@ -16,8 +16,10 @@ trait Iterable {\n     type Item<'a>;\n     type Iter<'a>: Iterator<Item = Self::Item<'a>>;\n     //~^ ERROR undeclared lifetime\n+    //~| ERROR lifetime parameters are not allowed on this type [E0110]\n \n     fn iter<'a>(&'a self) -> Self::Iter<'a>;\n+    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n }\n \n fn main() {}"}, {"sha": "fb91d38ba7a1494e220f0859f1a5775da275741e", "filename": "src/test/ui/rfc1598-generic-associated-types/iterable.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7794c0d3f539ffe9f1bf735ad05b6da6324236e/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.stderr?ref=b7794c0d3f539ffe9f1bf735ad05b6da6324236e", "patch": "@@ -4,5 +4,17 @@ error[E0261]: use of undeclared lifetime name `'a`\n 17 |     type Iter<'a>: Iterator<Item = Self::Item<'a>>;\n    |                                               ^^ undeclared lifetime\n \n-error: aborting due to previous error\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/iterable.rs:17:47\n+   |\n+17 |     type Iter<'a>: Iterator<Item = Self::Item<'a>>;\n+   |                                               ^^ lifetime parameter not allowed on this type\n+\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/iterable.rs:21:41\n+   |\n+21 |     fn iter<'a>(&'a self) -> Self::Iter<'a>;\n+   |                                         ^^ lifetime parameter not allowed on this type\n+\n+error: aborting due to 3 previous errors\n "}]}