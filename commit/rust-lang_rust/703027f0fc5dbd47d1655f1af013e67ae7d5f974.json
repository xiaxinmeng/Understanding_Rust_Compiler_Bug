{"sha": "703027f0fc5dbd47d1655f1af013e67ae7d5f974", "node_id": "C_kwDOAAsO6NoAKDcwMzAyN2YwZmM1ZGJkNDdkMTY1NWYxYWYwMTNlNjdhZTdkNWY5NzQ", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-11-22T02:28:16Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-11-22T03:15:12Z"}, "message": "Code cleanup as a follow up to the previous commit", "tree": {"sha": "751beb4329f189214dd78dcd9d0039d3e5215e2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/751beb4329f189214dd78dcd9d0039d3e5215e2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/703027f0fc5dbd47d1655f1af013e67ae7d5f974", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/703027f0fc5dbd47d1655f1af013e67ae7d5f974", "html_url": "https://github.com/rust-lang/rust/commit/703027f0fc5dbd47d1655f1af013e67ae7d5f974", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/703027f0fc5dbd47d1655f1af013e67ae7d5f974/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "894468a5377b374da3cb5c143549b21dd2dd32d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/894468a5377b374da3cb5c143549b21dd2dd32d6", "html_url": "https://github.com/rust-lang/rust/commit/894468a5377b374da3cb5c143549b21dd2dd32d6"}], "stats": {"total": 85, "additions": 44, "deletions": 41}, "files": [{"sha": "8b999f3c55a8b19300eb24538916ff89656d144b", "filename": "src/inline_asm.rs", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/703027f0fc5dbd47d1655f1af013e67ae7d5f974/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/703027f0fc5dbd47d1655f1af013e67ae7d5f974/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=703027f0fc5dbd47d1655f1af013e67ae7d5f974", "patch": "@@ -103,7 +103,6 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n     }\n \n-    let mut clobbered_regs = Vec::new();\n     let mut inputs = Vec::new();\n     let mut outputs = Vec::new();\n \n@@ -122,40 +121,37 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     asm_gen.allocate_registers();\n     asm_gen.allocate_stack_slots();\n \n+    let inline_asm_index = fx.inline_asm_index;\n+    fx.inline_asm_index += 1;\n+    let asm_name = format!(\"{}__inline_asm_{}\", fx.symbol_name, inline_asm_index);\n+\n+    let generated_asm = asm_gen.generate_asm_wrapper(&asm_name);\n+    fx.cx.global_asm.push_str(&generated_asm);\n+\n     // FIXME overlap input and output slots to save stack space\n     for (i, operand) in operands.iter().enumerate() {\n         match *operand {\n-            InlineAsmOperand::In { reg, ref value } => {\n-                let reg = asm_gen.registers[i].unwrap();\n-                clobbered_regs.push((reg, asm_gen.stack_slots_clobber[i].unwrap()));\n+            InlineAsmOperand::In { reg: _, ref value } => {\n                 inputs.push((\n-                    reg,\n                     asm_gen.stack_slots_input[i].unwrap(),\n                     crate::base::codegen_operand(fx, value).load_scalar(fx),\n                 ));\n             }\n-            InlineAsmOperand::Out { reg, late: _, place } => {\n-                let reg = asm_gen.registers[i].unwrap();\n-                clobbered_regs.push((reg, asm_gen.stack_slots_clobber[i].unwrap()));\n+            InlineAsmOperand::Out { reg: _, late: _, place } => {\n                 if let Some(place) = place {\n                     outputs.push((\n-                        reg,\n                         asm_gen.stack_slots_output[i].unwrap(),\n                         crate::base::codegen_place(fx, place),\n                     ));\n                 }\n             }\n-            InlineAsmOperand::InOut { reg, late: _, ref in_value, out_place } => {\n-                let reg = asm_gen.registers[i].unwrap();\n-                clobbered_regs.push((reg, asm_gen.stack_slots_clobber[i].unwrap()));\n+            InlineAsmOperand::InOut { reg: _, late: _, ref in_value, out_place } => {\n                 inputs.push((\n-                    reg,\n                     asm_gen.stack_slots_input[i].unwrap(),\n                     crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n                 ));\n                 if let Some(out_place) = out_place {\n                     outputs.push((\n-                        reg,\n                         asm_gen.stack_slots_output[i].unwrap(),\n                         crate::base::codegen_place(fx, out_place),\n                     ));\n@@ -167,13 +163,6 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         }\n     }\n \n-    let inline_asm_index = fx.inline_asm_index;\n-    fx.inline_asm_index += 1;\n-    let asm_name = format!(\"{}__inline_asm_{}\", fx.symbol_name, inline_asm_index);\n-\n-    let generated_asm = asm_gen.generate_asm_wrapper(&asm_name, clobbered_regs, &inputs, &outputs);\n-    fx.cx.global_asm.push_str(&generated_asm);\n-\n     call_inline_asm(fx, &asm_name, asm_gen.stack_slot_size, inputs, outputs);\n }\n \n@@ -364,13 +353,7 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         self.stack_slot_size = slot_size;\n     }\n \n-    fn generate_asm_wrapper(\n-        &self,\n-        asm_name: &str,\n-        clobbered_regs: Vec<(InlineAsmReg, Size)>,\n-        inputs: &[(InlineAsmReg, Size, Value)],\n-        outputs: &[(InlineAsmReg, Size, CPlace<'_>)],\n-    ) -> String {\n+    fn generate_asm_wrapper(&self, asm_name: &str) -> String {\n         let mut generated_asm = String::new();\n         writeln!(generated_asm, \".globl {}\", asm_name).unwrap();\n         writeln!(generated_asm, \".type {},@function\", asm_name).unwrap();\n@@ -384,14 +367,24 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Save clobbered registers\n         if !self.options.contains(InlineAsmOptions::NORETURN) {\n             // FIXME skip registers saved by the calling convention\n-            for &(reg, offset) in &clobbered_regs {\n-                save_register(&mut generated_asm, self.arch, reg, offset);\n+            for (reg, slot) in self\n+                .registers\n+                .iter()\n+                .zip(self.stack_slots_clobber.iter().copied())\n+                .filter_map(|(r, s)| r.zip(s))\n+            {\n+                save_register(&mut generated_asm, self.arch, reg, slot);\n             }\n         }\n \n         // Write input registers\n-        for &(reg, offset, _value) in inputs {\n-            restore_register(&mut generated_asm, self.arch, reg, offset);\n+        for (reg, slot) in self\n+            .registers\n+            .iter()\n+            .zip(self.stack_slots_input.iter().copied())\n+            .filter_map(|(r, s)| r.zip(s))\n+        {\n+            restore_register(&mut generated_asm, self.arch, reg, slot);\n         }\n \n         if self.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n@@ -414,19 +407,29 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         }\n         generated_asm.push('\\n');\n \n-        if self.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+        if is_x86 && self.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n             generated_asm.push_str(\".intel_syntax noprefix\\n\");\n         }\n \n         if !self.options.contains(InlineAsmOptions::NORETURN) {\n             // Read output registers\n-            for &(reg, offset, _place) in outputs {\n-                save_register(&mut generated_asm, self.arch, reg, offset);\n+            for (reg, slot) in self\n+                .registers\n+                .iter()\n+                .zip(self.stack_slots_output.iter().copied())\n+                .filter_map(|(r, s)| r.zip(s))\n+            {\n+                save_register(&mut generated_asm, self.arch, reg, slot);\n             }\n \n             // Restore clobbered registers\n-            for &(reg, offset) in clobbered_regs.iter().rev() {\n-                restore_register(&mut generated_asm, self.arch, reg, offset);\n+            for (reg, slot) in self\n+                .registers\n+                .iter()\n+                .zip(self.stack_slots_clobber.iter().copied())\n+                .filter_map(|(r, s)| r.zip(s))\n+            {\n+                restore_register(&mut generated_asm, self.arch, reg, slot);\n             }\n \n             generated_asm.push_str(\"    pop rbp\\n\");\n@@ -448,8 +451,8 @@ fn call_inline_asm<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     asm_name: &str,\n     slot_size: Size,\n-    inputs: Vec<(InlineAsmReg, Size, Value)>,\n-    outputs: Vec<(InlineAsmReg, Size, CPlace<'tcx>)>,\n+    inputs: Vec<(Size, Value)>,\n+    outputs: Vec<(Size, CPlace<'tcx>)>,\n ) {\n     let stack_slot = fx.bcx.func.create_stack_slot(StackSlotData {\n         kind: StackSlotKind::ExplicitSlot,\n@@ -476,14 +479,14 @@ fn call_inline_asm<'tcx>(\n         fx.add_comment(inline_asm_func, asm_name);\n     }\n \n-    for (_reg, offset, value) in inputs {\n+    for (offset, value) in inputs {\n         fx.bcx.ins().stack_store(value, stack_slot, i32::try_from(offset.bytes()).unwrap());\n     }\n \n     let stack_slot_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n     fx.bcx.ins().call(inline_asm_func, &[stack_slot_addr]);\n \n-    for (_reg, offset, place) in outputs {\n+    for (offset, place) in outputs {\n         let ty = fx.clif_type(place.layout().ty).unwrap();\n         let value = fx.bcx.ins().stack_load(ty, stack_slot, i32::try_from(offset.bytes()).unwrap());\n         place.write_cvalue(fx, CValue::by_val(value, place.layout()));"}]}