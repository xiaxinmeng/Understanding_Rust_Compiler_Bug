{"sha": "7a2a669bb70633a8c9ac4be708813b311c52ff93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMmE2NjliYjcwNjMzYThjOWFjNGJlNzA4ODEzYjMxMWM1MmZmOTM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-09T15:46:11Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-28T00:56:46Z"}, "message": "rustc: always include elidable lifetimes in HIR types.", "tree": {"sha": "7208cdb89fec46aacbe5902b1dfe422f46aa2863", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7208cdb89fec46aacbe5902b1dfe422f46aa2863"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a2a669bb70633a8c9ac4be708813b311c52ff93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a2a669bb70633a8c9ac4be708813b311c52ff93", "html_url": "https://github.com/rust-lang/rust/commit/7a2a669bb70633a8c9ac4be708813b311c52ff93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a2a669bb70633a8c9ac4be708813b311c52ff93/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f79feba2053c78425b6490c8587359846fa6648f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f79feba2053c78425b6490c8587359846fa6648f", "html_url": "https://github.com/rust-lang/rust/commit/f79feba2053c78425b6490c8587359846fa6648f"}], "stats": {"total": 378, "additions": 246, "deletions": 132}, "files": [{"sha": "d71263bea0046a76105506ceaada2d47fe52d15c", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=7a2a669bb70633a8c9ac4be708813b311c52ff93", "patch": "@@ -547,8 +547,8 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyPtr(ref mutable_type) => {\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyRptr(ref opt_lifetime, ref mutable_type) => {\n-            walk_list!(visitor, visit_lifetime, opt_lifetime);\n+        TyRptr(ref lifetime, ref mutable_type) => {\n+            visitor.visit_lifetime(lifetime);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n         TyNever => {},"}, {"sha": "4160ec5b74a92de923f712e48fcf78e71bfd8973", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 120, "deletions": 30, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=7a2a669bb70633a8c9ac4be708813b311c52ff93", "patch": "@@ -41,12 +41,12 @@\n // in the HIR, especially for multiple identifiers.\n \n use hir;\n-use hir::map::Definitions;\n+use hir::map::{Definitions, DefKey};\n use hir::map::definitions::DefPathData;\n use hir::def_id::{DefIndex, DefId};\n use hir::def::{Def, PathResolution};\n use session::Session;\n-use util::nodemap::{NodeMap, FxHashMap};\n+use util::nodemap::{DefIdMap, NodeMap, FxHashMap};\n \n use std::collections::BTreeMap;\n use std::iter;\n@@ -78,6 +78,8 @@ pub struct LoweringContext<'a> {\n     trait_items: BTreeMap<hir::TraitItemId, hir::TraitItem>,\n     impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n     bodies: FxHashMap<hir::BodyId, hir::Body>,\n+\n+    type_def_lifetime_params: DefIdMap<usize>,\n }\n \n pub trait Resolver {\n@@ -110,6 +112,7 @@ pub fn lower_crate(sess: &Session,\n         trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n         bodies: FxHashMap(),\n+        type_def_lifetime_params: DefIdMap(),\n     }.lower_crate(krate)\n }\n \n@@ -123,24 +126,33 @@ enum ParamMode {\n \n impl<'a> LoweringContext<'a> {\n     fn lower_crate(mut self, c: &Crate) -> hir::Crate {\n-        self.lower_items(c);\n-        let module = self.lower_mod(&c.module);\n-        let attrs = self.lower_attrs(&c.attrs);\n-        let exported_macros = c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect();\n+        /// Full-crate AST visitor that inserts into a fresh\n+        /// `LoweringContext` any information that may be\n+        /// needed from arbitrary locations in the crate.\n+        /// E.g. The number of lifetime generic parameters\n+        /// declared for every type and trait definition.\n+        struct MiscCollector<'lcx, 'interner: 'lcx> {\n+            lctx: &'lcx mut LoweringContext<'interner>,\n+        }\n \n-        hir::Crate {\n-            module: module,\n-            attrs: attrs,\n-            span: c.span,\n-            exported_macros: exported_macros,\n-            items: self.items,\n-            trait_items: self.trait_items,\n-            impl_items: self.impl_items,\n-            bodies: self.bodies,\n+        impl<'lcx, 'interner> Visitor<'lcx> for MiscCollector<'lcx, 'interner> {\n+            fn visit_item(&mut self, item: &'lcx Item) {\n+                match item.node {\n+                    ItemKind::Struct(_, ref generics) |\n+                    ItemKind::Union(_, ref generics) |\n+                    ItemKind::Enum(_, ref generics) |\n+                    ItemKind::Ty(_, ref generics) |\n+                    ItemKind::Trait(_, ref generics, ..) => {\n+                        let def_id = self.lctx.resolver.definitions().local_def_id(item.id);\n+                        let count = generics.lifetimes.len();\n+                        self.lctx.type_def_lifetime_params.insert(def_id, count);\n+                    }\n+                    _ => {}\n+                }\n+                visit::walk_item(self, item);\n+            }\n         }\n-    }\n \n-    fn lower_items(&mut self, c: &Crate) {\n         struct ItemLowerer<'lcx, 'interner: 'lcx> {\n             lctx: &'lcx mut LoweringContext<'interner>,\n         }\n@@ -167,8 +179,23 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n-        let mut item_lowerer = ItemLowerer { lctx: self };\n-        visit::walk_crate(&mut item_lowerer, c);\n+        visit::walk_crate(&mut MiscCollector { lctx: &mut self }, c);\n+        visit::walk_crate(&mut ItemLowerer { lctx: &mut self }, c);\n+\n+        let module = self.lower_mod(&c.module);\n+        let attrs = self.lower_attrs(&c.attrs);\n+        let exported_macros = c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect();\n+\n+        hir::Crate {\n+            module: module,\n+            attrs: attrs,\n+            span: c.span,\n+            exported_macros: exported_macros,\n+            items: self.items,\n+            trait_items: self.trait_items,\n+            impl_items: self.impl_items,\n+            bodies: self.bodies,\n+        }\n     }\n \n     fn record_body(&mut self, value: hir::Expr, decl: Option<&FnDecl>)\n@@ -232,6 +259,14 @@ impl<'a> LoweringContext<'a> {\n         result\n     }\n \n+    fn def_key(&mut self, id: DefId) -> DefKey {\n+        if id.is_local() {\n+            self.resolver.definitions().def_key(id.index)\n+        } else {\n+            self.sess.cstore.def_key(id)\n+        }\n+    }\n+\n     fn lower_opt_sp_ident(&mut self, o_id: Option<Spanned<Ident>>) -> Option<Spanned<Name>> {\n         o_id.map(|sp_ident| respan(sp_ident.span, sp_ident.node.name))\n     }\n@@ -279,7 +314,11 @@ impl<'a> LoweringContext<'a> {\n                 TyKind::Slice(ref ty) => hir::TySlice(self.lower_ty(ty)),\n                 TyKind::Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt)),\n                 TyKind::Rptr(ref region, ref mt) => {\n-                    hir::TyRptr(self.lower_opt_lifetime(region), self.lower_mt(mt))\n+                    let lifetime = match *region {\n+                        Some(ref lt) => self.lower_lifetime(lt),\n+                        None => self.elided_lifetime(t.span)\n+                    };\n+                    hir::TyRptr(lifetime, self.lower_mt(mt))\n                 }\n                 TyKind::BareFn(ref f) => {\n                     hir::TyBareFn(P(hir::BareFnTy {\n@@ -377,7 +416,40 @@ impl<'a> LoweringContext<'a> {\n                     }\n                     _ => param_mode\n                 };\n-                self.lower_path_segment(segment, param_mode)\n+\n+                // Figure out if this is a type/trait segment,\n+                // which may need lifetime elision performed.\n+                let parent_def_id = |this: &mut Self, def_id: DefId| {\n+                    DefId {\n+                        krate: def_id.krate,\n+                        index: this.def_key(def_id).parent.expect(\"missing parent\")\n+                    }\n+                };\n+                let type_def_id = match resolution.base_def {\n+                    Def::AssociatedTy(def_id) if i + 2 == proj_start => {\n+                        Some(parent_def_id(self, def_id))\n+                    }\n+                    Def::Variant(def_id) if i + 1 == proj_start => {\n+                        Some(parent_def_id(self, def_id))\n+                    }\n+                    Def::Struct(def_id) |\n+                    Def::Union(def_id) |\n+                    Def::Enum(def_id) |\n+                    Def::TyAlias(def_id) |\n+                    Def::Trait(def_id) if i + 1 == proj_start => Some(def_id),\n+                    _ => None\n+                };\n+\n+                let num_lifetimes = type_def_id.map_or(0, |def_id| {\n+                    if let Some(&n) = self.type_def_lifetime_params.get(&def_id) {\n+                        return n;\n+                    }\n+                    assert!(!def_id.is_local());\n+                    let (n, _) = self.sess.cstore.item_generics_own_param_counts(def_id);\n+                    self.type_def_lifetime_params.insert(def_id, n);\n+                    n\n+                });\n+                self.lower_path_segment(p.span, segment, param_mode, num_lifetimes)\n             }).collect(),\n             span: p.span,\n         });\n@@ -411,7 +483,7 @@ impl<'a> LoweringContext<'a> {\n         //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n         // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n         for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n-            let segment = P(self.lower_path_segment(segment, param_mode));\n+            let segment = P(self.lower_path_segment(p.span, segment, param_mode, 0));\n             let qpath = hir::QPath::TypeRelative(ty, segment);\n \n             // It's finished, return the extension of the right node type.\n@@ -443,7 +515,7 @@ impl<'a> LoweringContext<'a> {\n         hir::Path {\n             def: self.expect_full_def(id),\n             segments: segments.map(|segment| {\n-                self.lower_path_segment(segment, param_mode)\n+                self.lower_path_segment(p.span, segment, param_mode, 0)\n             }).chain(name.map(|name| {\n                 hir::PathSegment {\n                     name: name,\n@@ -464,10 +536,12 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_path_segment(&mut self,\n+                          path_span: Span,\n                           segment: &PathSegment,\n-                          param_mode: ParamMode)\n+                          param_mode: ParamMode,\n+                          expected_lifetimes: usize)\n                           -> hir::PathSegment {\n-        let parameters = if let Some(ref parameters) = segment.parameters {\n+        let mut parameters = if let Some(ref parameters) = segment.parameters {\n             match **parameters {\n                 PathParameters::AngleBracketed(ref data) => {\n                     let data = self.lower_angle_bracketed_parameter_data(data, param_mode);\n@@ -482,6 +556,14 @@ impl<'a> LoweringContext<'a> {\n             hir::AngleBracketedParameters(data)\n         };\n \n+        if let hir::AngleBracketedParameters(ref mut data) = parameters {\n+            if data.lifetimes.is_empty() {\n+                data.lifetimes = (0..expected_lifetimes).map(|_| {\n+                    self.elided_lifetime(path_span)\n+                }).collect();\n+            }\n+        }\n+\n         hir::PathSegment {\n             name: segment.identifier.name,\n             parameters: parameters,\n@@ -628,10 +710,6 @@ impl<'a> LoweringContext<'a> {\n         lts.iter().map(|l| self.lower_lifetime_def(l)).collect()\n     }\n \n-    fn lower_opt_lifetime(&mut self, o_lt: &Option<Lifetime>) -> Option<hir::Lifetime> {\n-        o_lt.as_ref().map(|lt| self.lower_lifetime(lt))\n-    }\n-\n     fn lower_generics(&mut self, g: &Generics) -> hir::Generics {\n         // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n         let mut add_bounds = NodeMap();\n@@ -751,8 +829,12 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_trait_ref(&mut self, p: &TraitRef) -> hir::TraitRef {\n+        let path = match self.lower_qpath(p.ref_id, &None, &p.path, ParamMode::Explicit) {\n+            hir::QPath::Resolved(None, path) => path.and_then(|path| path),\n+            qpath => bug!(\"lower_trait_ref: unexpected QPath `{:?}`\", qpath)\n+        };\n         hir::TraitRef {\n-            path: self.lower_path(p.ref_id, &p.path, ParamMode::Explicit, false),\n+            path: path,\n             ref_id: p.ref_id,\n         }\n     }\n@@ -2276,4 +2358,12 @@ impl<'a> LoweringContext<'a> {\n             span: span,\n         })\n     }\n+\n+    fn elided_lifetime(&mut self, span: Span) -> hir::Lifetime {\n+        hir::Lifetime {\n+            id: self.next_id(),\n+            span: span,\n+            name: keywords::Invalid.name()\n+        }\n+    }\n }"}, {"sha": "94cb33b138c58341dac9ec70c4850bc740d6829b", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 14, "deletions": 31, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=7a2a669bb70633a8c9ac4be708813b311c52ff93", "patch": "@@ -77,6 +77,13 @@ pub mod svh;\n pub struct Lifetime {\n     pub id: NodeId,\n     pub span: Span,\n+\n+    /// Either \"'a\", referring to a named lifetime definition,\n+    /// or \"\" (aka keywords::Invalid), for elision placeholders.\n+    ///\n+    /// HIR lowering inserts these placeholders in type paths that\n+    /// refer to type definitions needing lifetime parameters,\n+    /// `&T` and `&mut T`, and trait objects without `... + 'a`.\n     pub name: Name,\n }\n \n@@ -89,6 +96,12 @@ impl fmt::Debug for Lifetime {\n     }\n }\n \n+impl Lifetime {\n+    pub fn is_elided(&self) -> bool {\n+        self.name == keywords::Invalid.name()\n+    }\n+}\n+\n /// A lifetime definition, eg `'a: 'b+'c+'d`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct LifetimeDef {\n@@ -165,30 +178,6 @@ impl PathParameters {\n         })\n     }\n \n-    pub fn is_empty(&self) -> bool {\n-        match *self {\n-            AngleBracketedParameters(ref data) => data.is_empty(),\n-\n-            // Even if the user supplied no types, something like\n-            // `X()` is equivalent to `X<(),()>`.\n-            ParenthesizedParameters(..) => false,\n-        }\n-    }\n-\n-    pub fn has_lifetimes(&self) -> bool {\n-        match *self {\n-            AngleBracketedParameters(ref data) => !data.lifetimes.is_empty(),\n-            ParenthesizedParameters(_) => false,\n-        }\n-    }\n-\n-    pub fn has_types(&self) -> bool {\n-        match *self {\n-            AngleBracketedParameters(ref data) => !data.types.is_empty(),\n-            ParenthesizedParameters(..) => true,\n-        }\n-    }\n-\n     /// Returns the types that the user wrote. Note that these do not necessarily map to the type\n     /// parameters in the parenthesized case.\n     pub fn types(&self) -> HirVec<&P<Ty>> {\n@@ -245,12 +234,6 @@ pub struct AngleBracketedParameterData {\n     pub bindings: HirVec<TypeBinding>,\n }\n \n-impl AngleBracketedParameterData {\n-    fn is_empty(&self) -> bool {\n-        self.lifetimes.is_empty() && self.types.is_empty() && self.bindings.is_empty()\n-    }\n-}\n-\n /// A path like `Foo(A,B) -> C`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ParenthesizedParameterData {\n@@ -1208,7 +1191,7 @@ pub enum Ty_ {\n     /// A raw pointer (`*const T` or `*mut T`)\n     TyPtr(MutTy),\n     /// A reference (`&'a T` or `&'a mut T`)\n-    TyRptr(Option<Lifetime>, MutTy),\n+    TyRptr(Lifetime, MutTy),\n     /// A bare function (e.g. `fn(usize) -> bool`)\n     TyBareFn(P<BareFnTy>),\n     /// The never type (`!`)"}, {"sha": "8e866f5717498c188d35b21eb40412f813ee8e63", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 24, "deletions": 39, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=7a2a669bb70633a8c9ac4be708813b311c52ff93", "patch": "@@ -26,6 +26,7 @@ use syntax_pos::{self, BytePos};\n use hir;\n use hir::{PatKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier, RangeEnd};\n \n+use std::cell::Cell;\n use std::io::{self, Write, Read};\n \n pub enum AnnNode<'a> {\n@@ -359,9 +360,9 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_opt_lifetime(&mut self, lifetime: &Option<hir::Lifetime>) -> io::Result<()> {\n-        if let Some(l) = *lifetime {\n-            self.print_lifetime(&l)?;\n+    pub fn print_opt_lifetime(&mut self, lifetime: &hir::Lifetime) -> io::Result<()> {\n+        if !lifetime.is_elided() {\n+            self.print_lifetime(lifetime)?;\n             self.nbsp()?;\n         }\n         Ok(())\n@@ -1553,65 +1554,49 @@ impl<'a> State<'a> {\n                              parameters: &hir::PathParameters,\n                              colons_before_params: bool)\n                              -> io::Result<()> {\n-        if parameters.is_empty() {\n-            let infer_types = match *parameters {\n-                hir::AngleBracketedParameters(ref data) => data.infer_types,\n-                hir::ParenthesizedParameters(_) => false\n-            };\n-\n-            // FIXME(eddyb) See the comment below about infer_types.\n-            if !(infer_types && false) {\n-                return Ok(());\n-            }\n-        }\n-\n-        if colons_before_params {\n-            word(&mut self.s, \"::\")?\n-        }\n-\n         match *parameters {\n             hir::AngleBracketedParameters(ref data) => {\n-                word(&mut self.s, \"<\")?;\n+                let start = if colons_before_params { \"::<\" } else { \"<\" };\n+                let empty = Cell::new(true);\n+                let start_or_comma = |this: &mut Self| {\n+                    if empty.get() {\n+                        empty.set(false);\n+                        word(&mut this.s, start)\n+                    } else {\n+                        this.word_space(\",\")\n+                    }\n+                };\n \n-                let mut comma = false;\n-                for lifetime in &data.lifetimes {\n-                    if comma {\n-                        self.word_space(\",\")?\n+                if !data.lifetimes.iter().all(|lt| lt.is_elided()) {\n+                    for lifetime in &data.lifetimes {\n+                        start_or_comma(self)?;\n+                        self.print_lifetime(lifetime)?;\n                     }\n-                    self.print_lifetime(lifetime)?;\n-                    comma = true;\n                 }\n \n                 if !data.types.is_empty() {\n-                    if comma {\n-                        self.word_space(\",\")?\n-                    }\n+                    start_or_comma(self)?;\n                     self.commasep(Inconsistent, &data.types, |s, ty| s.print_type(&ty))?;\n-                    comma = true;\n                 }\n \n                 // FIXME(eddyb) This would leak into error messages, e.g.:\n                 // \"non-exhaustive patterns: `Some::<..>(_)` not covered\".\n                 if data.infer_types && false {\n-                    if comma {\n-                        self.word_space(\",\")?\n-                    }\n+                    start_or_comma(self)?;\n                     word(&mut self.s, \"..\")?;\n-                    comma = true;\n                 }\n \n                 for binding in data.bindings.iter() {\n-                    if comma {\n-                        self.word_space(\",\")?\n-                    }\n+                    start_or_comma(self)?;\n                     self.print_name(binding.name)?;\n                     space(&mut self.s)?;\n                     self.word_space(\"=\")?;\n                     self.print_type(&binding.ty)?;\n-                    comma = true;\n                 }\n \n-                word(&mut self.s, \">\")?\n+                if !empty.get() {\n+                    word(&mut self.s, \">\")?\n+                }\n             }\n \n             hir::ParenthesizedParameters(ref data) => {"}, {"sha": "8cf13cddc8c7fa97f31d8e01693f4a2dd9d09d91", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=7a2a669bb70633a8c9ac4be708813b311c52ff93", "patch": "@@ -182,6 +182,7 @@ pub trait CrateStore<'tcx> {\n                                  -> ty::GenericPredicates<'tcx>;\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                          -> ty::Generics<'tcx>;\n+    fn item_generics_own_param_counts(&self, def: DefId) -> (usize, usize);\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef;\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> &'tcx ty::AdtDef;\n@@ -331,6 +332,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n                                  -> ty::GenericPredicates<'tcx> { bug!(\"item_super_predicates\") }\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                          -> ty::Generics<'tcx> { bug!(\"item_generics\") }\n+    fn item_generics_own_param_counts(&self, def: DefId) -> (usize, usize)\n+        { bug!(\"item_generics_own_param_counts\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef\n         { bug!(\"trait_def\") }"}, {"sha": "a09f0ed7552bf146c7ab367c792af6a12107bf50", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=7a2a669bb70633a8c9ac4be708813b311c52ff93", "patch": "@@ -279,6 +279,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n+        if lifetime_ref.is_elided() {\n+            return;\n+        }\n         if lifetime_ref.name == keywords::StaticLifetime.name() {\n             self.insert_lifetime(lifetime_ref, DefStaticRegion);\n             return;"}, {"sha": "46179b31d5cb45bc2c212baad7a898355109e9e0", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=7a2a669bb70633a8c9ac4be708813b311c52ff93", "patch": "@@ -939,12 +939,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     /// Given a type, if it is an immutable reference, return a suggestion to make it mutable\n     fn suggest_mut_for_immutable(&self, pty: &hir::Ty) -> Option<String> {\n         // Check wether the argument is an immutable reference\n-        if let hir::TyRptr(opt_lifetime, hir::MutTy {\n+        if let hir::TyRptr(lifetime, hir::MutTy {\n             mutbl: hir::Mutability::MutImmutable,\n             ref ty\n         }) = pty.node {\n             // Account for existing lifetimes when generating the message\n-            if let Some(lifetime) = opt_lifetime {\n+            if !lifetime.is_elided() {\n                 if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(ty.span) {\n                     if let Ok(lifetime_snippet) = self.tcx.sess.codemap()\n                         .span_to_snippet(lifetime.span) {"}, {"sha": "05ba262ef90c08eae406ba8ebe6f3b6642cb3afc", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=7a2a669bb70633a8c9ac4be708813b311c52ff93", "patch": "@@ -377,8 +377,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.node {\n-            if path.segments.len() == 1 && path.segments[0].parameters.is_empty() {\n-                if let Def::Const(..) = path.def {\n+            if let Def::Const(..) = path.def {\n+                if path.segments.len() == 1 {\n                     NonUpperCaseGlobals::check_upper_case(cx,\n                                                           \"constant in pattern\",\n                                                           path.segments[0].name,"}, {"sha": "03b2b0114f19c2a8d8d4025d15060f749de60c11", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=7a2a669bb70633a8c9ac4be708813b311c52ff93", "patch": "@@ -110,6 +110,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def.krate).get_generics(def.index, tcx)\n     }\n \n+    fn item_generics_own_param_counts(&self, def: DefId) -> (usize, usize) {\n+        self.dep_graph.read(DepNode::MetaData(def));\n+        self.get_crate_data(def.krate).generics_own_param_counts(def.index)\n+    }\n+\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>\n     {\n         self.dep_graph.read(DepNode::MetaData(def_id));"}, {"sha": "bfc4257bda01341ac49734cab5f8620f70709e40", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=7a2a669bb70633a8c9ac4be708813b311c52ff93", "patch": "@@ -598,7 +598,20 @@ impl<'a, 'tcx> CrateMetadata {\n                         item_id: DefIndex,\n                         tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                         -> ty::Generics<'tcx> {\n-        self.entry(item_id).generics.unwrap().decode((self, tcx))\n+        let g = self.entry(item_id).generics.unwrap().decode(self);\n+        ty::Generics {\n+            parent: g.parent,\n+            parent_regions: g.parent_regions,\n+            parent_types: g.parent_types,\n+            regions: g.regions.decode((self, tcx)).collect(),\n+            types: g.types.decode((self, tcx)).collect(),\n+            has_self: g.has_self,\n+        }\n+    }\n+\n+    pub fn generics_own_param_counts(&self, item_id: DefIndex) -> (usize, usize) {\n+        let g = self.entry(item_id).generics.unwrap().decode(self);\n+        (g.regions.len, g.types.len)\n     }\n \n     pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {"}, {"sha": "c407c27b096e1d896d2876b46282aff4696fdb54", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=7a2a669bb70633a8c9ac4be708813b311c52ff93", "patch": "@@ -417,9 +417,19 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_generics(&mut self, def_id: DefId) -> Lazy<ty::Generics<'tcx>> {\n+    fn encode_generics(&mut self, def_id: DefId) -> Lazy<Generics<'tcx>> {\n         let tcx = self.tcx;\n-        self.lazy(tcx.item_generics(def_id))\n+        let g = tcx.item_generics(def_id);\n+        let regions = self.lazy_seq_ref(&g.regions);\n+        let types = self.lazy_seq_ref(&g.types);\n+        self.lazy(&Generics {\n+            parent: g.parent,\n+            parent_regions: g.parent_regions,\n+            parent_types: g.parent_types,\n+            regions: regions,\n+            types: types,\n+            has_self: g.has_self,\n+        })\n     }\n \n     fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {"}, {"sha": "4f9f2d23f5d3e775205baee9e4b207e5c7aacf7f", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=7a2a669bb70633a8c9ac4be708813b311c52ff93", "patch": "@@ -213,7 +213,7 @@ pub struct Entry<'tcx> {\n     pub ty: Option<Lazy<Ty<'tcx>>>,\n     pub inherent_impls: LazySeq<DefIndex>,\n     pub variances: LazySeq<ty::Variance>,\n-    pub generics: Option<Lazy<ty::Generics<'tcx>>>,\n+    pub generics: Option<Lazy<Generics<'tcx>>>,\n     pub predicates: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n \n     pub ast: Option<Lazy<astencode::Ast<'tcx>>>,\n@@ -247,6 +247,19 @@ pub enum EntryKind<'tcx> {\n     AssociatedConst(AssociatedContainer),\n }\n \n+/// A copy of `ty::Generics` which allows lazy decoding of\n+/// `regions` and `types` (e.g. knowing the number of type\n+/// and lifetime parameters before `TyCtxt` is created).\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct Generics<'tcx> {\n+    pub parent: Option<DefId>,\n+    pub parent_regions: u32,\n+    pub parent_types: u32,\n+    pub regions: LazySeq<ty::RegionParameterDef<'tcx>>,\n+    pub types: LazySeq<ty::TypeParameterDef<'tcx>>,\n+    pub has_self: bool,\n+}\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ModData {\n     pub reexports: LazySeq<def::Export>,"}, {"sha": "bc8e56e811ed28b10d9d8942771448a5570a38a2", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=7a2a669bb70633a8c9ac4be708813b311c52ff93", "patch": "@@ -404,19 +404,20 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         };\n         let expected_num_region_params = decl_generics.regions.len();\n         let supplied_num_region_params = lifetimes.len();\n-        let has_exact_lifetimes = expected_num_region_params == supplied_num_region_params;\n-        let mut can_report_lifetime_count_mismatch = !has_exact_lifetimes;\n-        let mut maybe_report_lifetime_count_mismatch = || {\n-            if can_report_lifetime_count_mismatch {\n-                can_report_lifetime_count_mismatch = false;\n+        let mut reported_lifetime_count_mismatch = false;\n+        let mut report_lifetime_count_mismatch = || {\n+            if !reported_lifetime_count_mismatch {\n+                reported_lifetime_count_mismatch = true;\n+                let all_infer = lifetimes.iter().all(|lt| lt.is_elided());\n+                let supplied = if all_infer { 0 } else { supplied_num_region_params };\n                 report_lifetime_number_error(tcx, span,\n-                                             supplied_num_region_params,\n+                                             supplied,\n                                              expected_num_region_params);\n             }\n         };\n \n-        if supplied_num_region_params != 0 {\n-            maybe_report_lifetime_count_mismatch();\n+        if expected_num_region_params != supplied_num_region_params {\n+            report_lifetime_count_mismatch();\n         }\n \n         // If a self-type was declared, one should be provided.\n@@ -444,13 +445,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let mut output_assoc_binding = None;\n         let substs = Substs::for_item(tcx, def_id, |def, _| {\n             let i = def.index as usize - self_ty.is_some() as usize;\n-            let l = if has_exact_lifetimes {\n-                Some(&lifetimes[i])\n-            } else {\n-                None\n-            };\n+            let l = lifetimes.get(i);\n             self.try_opt_ast_region_to_region(rscope, span, l, Some(def)).unwrap_or_else(|_| {\n-                maybe_report_lifetime_count_mismatch();\n+                report_lifetime_count_mismatch();\n                 tcx.mk_region(ty::ReStatic)\n             })\n         }, |def, substs| {\n@@ -1472,7 +1469,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 })\n             }\n             hir::TyRptr(ref region, ref mt) => {\n-                let r = self.opt_ast_region_to_region(rscope, ast_ty.span, region.as_ref(), None);\n+                let r = self.opt_ast_region_to_region(rscope, ast_ty.span, Some(region), None);\n                 debug!(\"TyRef r={:?}\", r);\n                 let rscope1 =\n                     &ObjectLifetimeDefaultRscope::new("}, {"sha": "54a5b9f43c0dc641800c59d1053e559037bf8977", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7a2a669bb70633a8c9ac4be708813b311c52ff93", "patch": "@@ -1688,9 +1688,15 @@ impl Clean<Type> for hir::Ty {\n         match self.node {\n             TyNever => Never,\n             TyPtr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n-            TyRptr(ref l, ref m) =>\n-                BorrowedRef {lifetime: l.clean(cx), mutability: m.mutbl.clean(cx),\n-                             type_: box m.ty.clean(cx)},\n+            TyRptr(ref l, ref m) => {\n+                let lifetime = if l.is_elided() {\n+                    None\n+                } else {\n+                    Some(l.clean(cx))\n+                };\n+                BorrowedRef {lifetime: lifetime, mutability: m.mutbl.clean(cx),\n+                             type_: box m.ty.clean(cx)}\n+            }\n             TySlice(ref ty) => Vector(box ty.clean(cx)),\n             TyArray(ref ty, length) => {\n                 use rustc_const_eval::eval_length;\n@@ -1729,7 +1735,9 @@ impl Clean<Type> for hir::Ty {\n                     for (i, lt_param) in generics.lifetimes.iter().enumerate() {\n                         if let Some(lt) = provided_params.lifetimes().get(i).cloned()\n                                                                             .cloned() {\n-                            lt_substs.insert(lt_param.lifetime.id, lt.clean(cx));\n+                            if !lt.is_elided() {\n+                                lt_substs.insert(lt_param.lifetime.id, lt.clean(cx));\n+                            }\n                         }\n                     }\n                     return cx.enter_alias(ty_substs, lt_substs, || ty.clean(cx));\n@@ -2242,7 +2250,11 @@ impl Clean<PathParameters> for hir::PathParameters {\n         match *self {\n             hir::AngleBracketedParameters(ref data) => {\n                 PathParameters::AngleBracketed {\n-                    lifetimes: data.lifetimes.clean(cx),\n+                    lifetimes: if data.lifetimes.iter().all(|lt| lt.is_elided()) {\n+                        vec![]\n+                    } else {\n+                        data.lifetimes.clean(cx)\n+                    },\n                     types: data.types.clean(cx),\n                     bindings: data.bindings.clean(cx)\n                 }"}, {"sha": "18a1185d695f70ca0de33391fc4fadbc9843bbc5", "filename": "src/test/compile-fail/unboxed-closure-sugar-region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2a669bb70633a8c9ac4be708813b311c52ff93/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs?ref=7a2a669bb70633a8c9ac4be708813b311c52ff93", "patch": "@@ -38,9 +38,9 @@ fn test<'a,'b>() {\n }\n \n fn test2(x: &Foo<(isize,),Output=()>, y: &Foo(isize)) {\n+//~^ ERROR wrong number of lifetime parameters: expected 1, found 0\n     // Here, the omitted lifetimes are expanded to distinct things.\n-    same_type(x, y) //~ ERROR cannot infer\n-                    //~^ ERROR cannot infer\n+    same_type(x, y)\n }\n \n fn main() { }"}]}