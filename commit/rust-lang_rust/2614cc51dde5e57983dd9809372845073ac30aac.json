{"sha": "2614cc51dde5e57983dd9809372845073ac30aac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MTRjYzUxZGRlNWU1Nzk4M2RkOTgwOTM3Mjg0NTA3M2FjMzBhYWM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-11-23T17:05:23Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-05T13:42:33Z"}, "message": "convert the new conflicts to a soft error", "tree": {"sha": "cfb570cb827ef0f3901498d46afbe56964e86f68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfb570cb827ef0f3901498d46afbe56964e86f68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2614cc51dde5e57983dd9809372845073ac30aac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2614cc51dde5e57983dd9809372845073ac30aac", "html_url": "https://github.com/rust-lang/rust/commit/2614cc51dde5e57983dd9809372845073ac30aac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2614cc51dde5e57983dd9809372845073ac30aac/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1271ea4f958d335ee67452faff925ab9b8715648", "url": "https://api.github.com/repos/rust-lang/rust/commits/1271ea4f958d335ee67452faff925ab9b8715648", "html_url": "https://github.com/rust-lang/rust/commit/1271ea4f958d335ee67452faff925ab9b8715648"}], "stats": {"total": 272, "additions": 207, "deletions": 65}, "files": [{"sha": "e31fc48b90783696ceb1b515a7779254692041a3", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2614cc51dde5e57983dd9809372845073ac30aac/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614cc51dde5e57983dd9809372845073ac30aac/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=2614cc51dde5e57983dd9809372845073ac30aac", "patch": "@@ -204,6 +204,12 @@ declare_lint! {\n     \"detects generic lifetime arguments in path segments with late bound lifetime parameters\"\n }\n \n+declare_lint! {\n+    pub INCOHERENT_FUNDAMENTAL_IMPLS,\n+    Deny,\n+    \"potentially-conflicting impls were erroneously allowed\"\n+}\n+\n declare_lint! {\n     pub DEPRECATED,\n     Warn,\n@@ -267,6 +273,7 @@ impl LintPass for HardwiredLints {\n             MISSING_FRAGMENT_SPECIFIER,\n             PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n             LATE_BOUND_LIFETIME_ARGUMENTS,\n+            INCOHERENT_FUNDAMENTAL_IMPLS,\n             DEPRECATED,\n             UNUSED_UNSAFE,\n             UNUSED_MUT,"}, {"sha": "756921d7a8774b526498f0ea605b78bf5acff304", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2614cc51dde5e57983dd9809372845073ac30aac/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614cc51dde5e57983dd9809372845073ac30aac/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=2614cc51dde5e57983dd9809372845073ac30aac", "patch": "@@ -13,6 +13,7 @@\n use hir::def_id::{DefId, LOCAL_CRATE};\n use syntax_pos::DUMMY_SP;\n use traits::{self, Normalized, SelectionContext, Obligation, ObligationCause, Reveal};\n+use traits::IntercrateMode;\n use traits::select::IntercrateAmbiguityCause;\n use ty::{self, Ty, TyCtxt};\n use ty::subst::Subst;\n@@ -42,16 +43,19 @@ pub struct OverlapResult<'tcx> {\n /// `ImplHeader` with those types substituted\n pub fn overlapping_impls<'cx, 'gcx, 'tcx>(infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n                                           impl1_def_id: DefId,\n-                                          impl2_def_id: DefId)\n+                                          impl2_def_id: DefId,\n+                                          intercrate_mode: IntercrateMode)\n                                           -> Option<OverlapResult<'tcx>>\n {\n     debug!(\"impl_can_satisfy(\\\n            impl1_def_id={:?}, \\\n-           impl2_def_id={:?})\",\n+           impl2_def_id={:?},\n+           intercrate_mode={:?})\",\n            impl1_def_id,\n-           impl2_def_id);\n+           impl2_def_id,\n+           intercrate_mode);\n \n-    let selcx = &mut SelectionContext::intercrate(infcx);\n+    let selcx = &mut SelectionContext::intercrate(infcx, intercrate_mode);\n     overlap(selcx, impl1_def_id, impl2_def_id)\n }\n "}, {"sha": "94605d895a5545c399843428bbe9b8aacc25b0fe", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2614cc51dde5e57983dd9809372845073ac30aac/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614cc51dde5e57983dd9809372845073ac30aac/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=2614cc51dde5e57983dd9809372845073ac30aac", "patch": "@@ -60,7 +60,8 @@ mod structural_impls;\n pub mod trans;\n mod util;\n \n-#[derive(Copy, Clone, Debug)]\n+// Whether to enable bug compatibility with issue #43355\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum IntercrateMode {\n     Issue43355,\n     Fixed"}, {"sha": "6d845accc64945200f9e356d10180dd67c9e6d6d", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2614cc51dde5e57983dd9809372845073ac30aac/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614cc51dde5e57983dd9809372845073ac30aac/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=2614cc51dde5e57983dd9809372845073ac30aac", "patch": "@@ -15,6 +15,7 @@ use self::EvaluationResult::*;\n \n use super::coherence::{self, Conflict};\n use super::DerivedObligationCause;\n+use super::IntercrateMode;\n use super::project;\n use super::project::{normalize_with_depth, Normalized, ProjectionCacheKey};\n use super::{PredicateObligation, TraitObligation, ObligationCause};\n@@ -87,7 +88,7 @@ pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     /// other words, we consider `$0 : Bar` to be unimplemented if\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n-    intercrate: bool,\n+    intercrate: Option<IntercrateMode>,\n \n     inferred_obligations: SnapshotVec<InferredObligationsSnapshotVecDelegate<'tcx>>,\n \n@@ -111,21 +112,24 @@ impl IntercrateAmbiguityCause {\n     /// See #23980 for details.\n     pub fn add_intercrate_ambiguity_hint<'a, 'tcx>(&self,\n                                                    err: &mut ::errors::DiagnosticBuilder) {\n+        err.note(&self.intercrate_ambiguity_hint());\n+    }\n+\n+    pub fn intercrate_ambiguity_hint(&self) -> String {\n         match self {\n             &IntercrateAmbiguityCause::DownstreamCrate { ref trait_desc, ref self_desc } => {\n                 let self_desc = if let &Some(ref ty) = self_desc {\n                     format!(\" for type `{}`\", ty)\n                 } else { \"\".to_string() };\n-                err.note(&format!(\"downstream crates may implement trait `{}`{}\",\n-                                  trait_desc, self_desc));\n+                format!(\"downstream crates may implement trait `{}`{}\", trait_desc, self_desc)\n             }\n             &IntercrateAmbiguityCause::UpstreamCrateUpdate { ref trait_desc, ref self_desc } => {\n                 let self_desc = if let &Some(ref ty) = self_desc {\n                     format!(\" for type `{}`\", ty)\n                 } else { \"\".to_string() };\n-                err.note(&format!(\"upstream crates may add new impl of trait `{}`{} \\\n-                                  in future versions\",\n-                                  trait_desc, self_desc));\n+                format!(\"upstream crates may add new impl of trait `{}`{} \\\n+                         in future versions\",\n+                        trait_desc, self_desc)\n             }\n         }\n     }\n@@ -417,17 +421,19 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener(),\n-            intercrate: false,\n+            intercrate: None,\n             inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: Vec::new(),\n         }\n     }\n \n-    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>) -> SelectionContext<'cx, 'gcx, 'tcx> {\n+    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+                      mode: IntercrateMode) -> SelectionContext<'cx, 'gcx, 'tcx> {\n+        debug!(\"intercrate({:?})\", mode);\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener(),\n-            intercrate: true,\n+            intercrate: Some(mode),\n             inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: Vec::new(),\n         }\n@@ -758,7 +764,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"evaluate_trait_predicate_recursively({:?})\",\n                obligation);\n \n-        if !self.intercrate && obligation.is_global() {\n+        if !self.intercrate.is_some() && obligation.is_global() {\n             // If a param env is consistent, global obligations do not depend on its particular\n             // value in order to work, so we can clear out the param env and get better\n             // caching. (If the current param env is inconsistent, we don't care what happens).\n@@ -814,7 +820,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // terms of `Fn` etc, but we could probably make this more\n         // precise still.\n         let unbound_input_types = stack.fresh_trait_ref.input_types().any(|ty| ty.is_fresh());\n-        if unbound_input_types && self.intercrate && false {\n+        // this check was an imperfect workaround for a bug n the old\n+        // intercrate mode, it should be removed when that goes away.\n+        if unbound_input_types &&\n+            self.intercrate == Some(IntercrateMode::Issue43355)\n+        {\n             debug!(\"evaluate_stack({:?}) --> unbound argument, intercrate -->  ambiguous\",\n                    stack.fresh_trait_ref);\n             // Heuristics: show the diagnostics when there are no candidates in crate.\n@@ -1212,9 +1222,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                        stack: &TraitObligationStack<'o, 'tcx>)\n                        -> Option<Conflict>\n     {\n-        debug!(\"is_knowable(intercrate={})\", self.intercrate);\n+        debug!(\"is_knowable(intercrate={:?})\", self.intercrate);\n \n-        if !self.intercrate {\n+        if !self.intercrate.is_some() {\n             return None;\n         }\n \n@@ -1226,7 +1236,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // bound regions\n         let trait_ref = predicate.skip_binder().trait_ref;\n \n-        coherence::trait_ref_is_knowable(self.tcx(), trait_ref)\n+        let result = coherence::trait_ref_is_knowable(self.tcx(), trait_ref);\n+        if let (Some(Conflict::Downstream { used_to_be_broken: true }),\n+                Some(IntercrateMode::Issue43355)) = (result, self.intercrate) {\n+            debug!(\"is_knowable: IGNORING conflict to be bug-compatible with #43355\");\n+            None\n+        } else {\n+            result\n+        }\n     }\n \n     /// Returns true if the global caches can be used.\n@@ -1251,7 +1268,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // the master cache. Since coherence executes pretty quickly,\n         // it's not worth going to more trouble to increase the\n         // hit-rate I don't think.\n-        if self.intercrate {\n+        if self.intercrate.is_some() {\n             return false;\n         }\n "}, {"sha": "6a96d01d5f92a498c272e82cb3ecb34b4de47f54", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2614cc51dde5e57983dd9809372845073ac30aac/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614cc51dde5e57983dd9809372845073ac30aac/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=2614cc51dde5e57983dd9809372845073ac30aac", "patch": "@@ -30,6 +30,8 @@ use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;\n use std::rc::Rc;\n \n+use lint;\n+\n pub mod specialization_graph;\n \n /// Information pertinent to an overlapping impl error.\n@@ -325,16 +327,33 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n             // This is where impl overlap checking happens:\n             let insert_result = sg.insert(tcx, impl_def_id);\n             // Report error if there was one.\n-            if let Err(overlap) = insert_result {\n-                let mut err = struct_span_err!(tcx.sess,\n-                                               tcx.span_of_impl(impl_def_id).unwrap(),\n-                                               E0119,\n-                                               \"conflicting implementations of trait `{}`{}:\",\n-                                               overlap.trait_desc,\n-                                               overlap.self_desc.clone().map_or(String::new(),\n-                                                                                |ty| {\n-                    format!(\" for type `{}`\", ty)\n-                }));\n+            let (overlap, used_to_be_allowed) = match insert_result {\n+                Err(overlap) => (Some(overlap), false),\n+                Ok(opt_overlap) => (opt_overlap, true)\n+            };\n+\n+            if let Some(overlap) = overlap {\n+                let msg = format!(\"conflicting implementations of trait `{}`{}:{}\",\n+                    overlap.trait_desc,\n+                    overlap.self_desc.clone().map_or(\n+                        String::new(), |ty| {\n+                            format!(\" for type `{}`\", ty)\n+                        }),\n+                    if used_to_be_allowed { \" (E0119)\" } else { \"\" }\n+                );\n+                let mut err = if used_to_be_allowed {\n+                    tcx.struct_span_lint_node(\n+                        lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n+                        tcx.hir.as_local_node_id(impl_def_id).unwrap(),\n+                        tcx.span_of_impl(impl_def_id).unwrap(),\n+                        &msg)\n+                } else {\n+                    struct_span_err!(tcx.sess,\n+                                     tcx.span_of_impl(impl_def_id).unwrap(),\n+                                     E0119,\n+                                     \"{}\",\n+                                     msg)\n+                };\n \n                 match tcx.span_of_impl(overlap.with_impl) {\n                     Ok(span) => {"}, {"sha": "834389e5d009c62145d41e7fd88b2d0698e62265", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 45, "deletions": 23, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2614cc51dde5e57983dd9809372845073ac30aac/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614cc51dde5e57983dd9809372845073ac30aac/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=2614cc51dde5e57983dd9809372845073ac30aac", "patch": "@@ -68,7 +68,7 @@ struct Children {\n /// The result of attempting to insert an impl into a group of children.\n enum Inserted {\n     /// The impl was inserted as a new child in this group of children.\n-    BecameNewSibling,\n+    BecameNewSibling(Option<OverlapError>),\n \n     /// The impl replaced an existing impl that specializes it.\n     Replaced(DefId),\n@@ -105,17 +105,39 @@ impl<'a, 'gcx, 'tcx> Children {\n               simplified_self: Option<SimplifiedType>)\n               -> Result<Inserted, OverlapError>\n     {\n+        let mut last_lint = None;\n+\n         for slot in match simplified_self {\n             Some(sty) => self.filtered_mut(sty),\n             None => self.iter_mut(),\n         } {\n             let possible_sibling = *slot;\n \n+            let overlap_error = |overlap: traits::coherence::OverlapResult| {\n+                // overlap, but no specialization; error out\n+                let trait_ref = overlap.impl_header.trait_ref.unwrap();\n+                let self_ty = trait_ref.self_ty();\n+                OverlapError {\n+                    with_impl: possible_sibling,\n+                    trait_desc: trait_ref.to_string(),\n+                    // only report the Self type if it has at least\n+                    // some outer concrete shell; otherwise, it's\n+                    // not adding much information.\n+                    self_desc: if self_ty.has_concrete_skeleton() {\n+                        Some(self_ty.to_string())\n+                    } else {\n+                        None\n+                    },\n+                    intercrate_ambiguity_causes: overlap.intercrate_ambiguity_causes,\n+                }\n+            };\n+\n             let tcx = tcx.global_tcx();\n             let (le, ge) = tcx.infer_ctxt().enter(|infcx| {\n                 let overlap = traits::overlapping_impls(&infcx,\n                                                         possible_sibling,\n-                                                        impl_def_id);\n+                                                        impl_def_id,\n+                                                        traits::IntercrateMode::Issue43355);\n                 if let Some(overlap) = overlap {\n                     if tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n                         return Ok((false, false));\n@@ -125,22 +147,7 @@ impl<'a, 'gcx, 'tcx> Children {\n                     let ge = tcx.specializes((possible_sibling, impl_def_id));\n \n                     if le == ge {\n-                        // overlap, but no specialization; error out\n-                        let trait_ref = overlap.impl_header.trait_ref.unwrap();\n-                        let self_ty = trait_ref.self_ty();\n-                        Err(OverlapError {\n-                            with_impl: possible_sibling,\n-                            trait_desc: trait_ref.to_string(),\n-                            // only report the Self type if it has at least\n-                            // some outer concrete shell; otherwise, it's\n-                            // not adding much information.\n-                            self_desc: if self_ty.has_concrete_skeleton() {\n-                                Some(self_ty.to_string())\n-                            } else {\n-                                None\n-                            },\n-                            intercrate_ambiguity_causes: overlap.intercrate_ambiguity_causes,\n-                        })\n+                        Err(overlap_error(overlap))\n                     } else {\n                         Ok((le, ge))\n                     }\n@@ -163,14 +170,27 @@ impl<'a, 'gcx, 'tcx> Children {\n                     *slot = impl_def_id;\n                 return Ok(Inserted::Replaced(possible_sibling));\n             } else {\n+                if !tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n+                    tcx.infer_ctxt().enter(|infcx| {\n+                        if let Some(overlap) = traits::overlapping_impls(\n+                            &infcx,\n+                            possible_sibling,\n+                            impl_def_id,\n+                            traits::IntercrateMode::Fixed)\n+                        {\n+                            last_lint = Some(overlap_error(overlap));\n+                        }\n+                    });\n+                }\n+\n                 // no overlap (error bailed already via ?)\n             }\n         }\n \n         // no overlap with any potential siblings, so add as a new sibling\n         debug!(\"placing as new sibling\");\n         self.insert_blindly(tcx, impl_def_id);\n-        Ok(Inserted::BecameNewSibling)\n+        Ok(Inserted::BecameNewSibling(last_lint))\n     }\n \n     fn iter_mut(&'a mut self) -> Box<Iterator<Item = &'a mut DefId> + 'a> {\n@@ -199,7 +219,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n     pub fn insert(&mut self,\n                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                   impl_def_id: DefId)\n-                  -> Result<(), OverlapError> {\n+                  -> Result<Option<OverlapError>, OverlapError> {\n         assert!(impl_def_id.is_local());\n \n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n@@ -220,10 +240,11 @@ impl<'a, 'gcx, 'tcx> Graph {\n             self.parent.insert(impl_def_id, trait_def_id);\n             self.children.entry(trait_def_id).or_insert(Children::new())\n                 .insert_blindly(tcx, impl_def_id);\n-            return Ok(());\n+            return Ok(None);\n         }\n \n         let mut parent = trait_def_id;\n+        let mut last_lint = None;\n         let simplified = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false);\n \n         // Descend the specialization tree, where `parent` is the current parent node\n@@ -234,7 +255,8 @@ impl<'a, 'gcx, 'tcx> Graph {\n                 .insert(tcx, impl_def_id, simplified)?;\n \n             match insert_result {\n-                BecameNewSibling => {\n+                BecameNewSibling(opt_lint) => {\n+                    last_lint = opt_lint;\n                     break;\n                 }\n                 Replaced(new_child) => {\n@@ -251,7 +273,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n         }\n \n         self.parent.insert(impl_def_id, parent);\n-        Ok(())\n+        Ok(last_lint)\n     }\n \n     /// Insert cached metadata mapping from a child impl back to its parent."}, {"sha": "8b41dd62742ce278fe51f92ed5f570b330daa810", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2614cc51dde5e57983dd9809372845073ac30aac/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614cc51dde5e57983dd9809372845073ac30aac/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=2614cc51dde5e57983dd9809372845073ac30aac", "patch": "@@ -247,11 +247,14 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(SAFE_PACKED_BORROWS),\n             reference: \"issue #46043 <https://github.com/rust-lang/rust/issues/46043>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(INCOHERENT_FUNDAMENTAL_IMPLS),\n+            reference: \"issue #46205 <https://github.com/rust-lang/rust/issues/46205>\",\n+        },\n         FutureIncompatibleInfo {\n             id: LintId::of(COERCE_NEVER),\n             reference: \"issue #46325 <https://github.com/rust-lang/rust/issues/46325>\",\n         },\n-\n         ]);\n \n     // Register renamed and removed lints"}, {"sha": "07d5f813cbbce76977700c569af80bdd868a8ea3", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2614cc51dde5e57983dd9809372845073ac30aac/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614cc51dde5e57983dd9809372845073ac30aac/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=2614cc51dde5e57983dd9809372845073ac30aac", "patch": "@@ -12,9 +12,11 @@ use namespace::Namespace;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::traits;\n+use rustc::traits::{self, IntercrateMode};\n use rustc::ty::TyCtxt;\n \n+use lint;\n+\n pub fn crate_inherent_impls_overlap_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                     crate_num: CrateNum) {\n     assert_eq!(crate_num, LOCAL_CRATE);\n@@ -28,7 +30,8 @@ struct InherentOverlapChecker<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n     fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId,\n-                                       overlap: traits::OverlapResult) {\n+                                       overlap: traits::OverlapResult,\n+                                       used_to_be_allowed: bool) {\n \n         let name_and_namespace = |def_id| {\n             let item = self.tcx.associated_item(def_id);\n@@ -43,11 +46,21 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n             for &item2 in &impl_items2[..] {\n                 if (name, namespace) == name_and_namespace(item2) {\n-                    let mut err = struct_span_err!(self.tcx.sess,\n-                                                   self.tcx.span_of_impl(item1).unwrap(),\n-                                                   E0592,\n-                                                   \"duplicate definitions with name `{}`\",\n-                                                   name);\n+                    let node_id = self.tcx.hir.as_local_node_id(impl1);\n+                    let mut err = if used_to_be_allowed && node_id.is_some() {\n+                        self.tcx.struct_span_lint_node(\n+                            lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n+                            node_id.unwrap(),\n+                            self.tcx.span_of_impl(item1).unwrap(),\n+                            &format!(\"duplicate definitions with name `{}` (E0592)\", name)\n+                        )\n+                    } else {\n+                        struct_span_err!(self.tcx.sess,\n+                                         self.tcx.span_of_impl(item1).unwrap(),\n+                                         E0592,\n+                                         \"duplicate definitions with name `{}`\",\n+                                         name)\n+                    };\n \n                     err.span_label(self.tcx.span_of_impl(item1).unwrap(),\n                                    format!(\"duplicate definitions for `{}`\", name));\n@@ -69,12 +82,30 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {\n-                self.tcx.infer_ctxt().enter(|infcx| {\n+                let used_to_be_allowed = self.tcx.infer_ctxt().enter(|infcx| {\n                     if let Some(overlap) =\n-                            traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n-                        self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id, overlap)\n+                        traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id,\n+                                                  IntercrateMode::Issue43355)\n+                    {\n+                        self.check_for_common_items_in_impls(\n+                            impl1_def_id, impl2_def_id, overlap, false);\n+                        false\n+                    } else {\n+                        true\n                     }\n                 });\n+\n+                if used_to_be_allowed {\n+                    self.tcx.infer_ctxt().enter(|infcx| {\n+                        if let Some(overlap) =\n+                            traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id,\n+                                                      IntercrateMode::Fixed)\n+                        {\n+                            self.check_for_common_items_in_impls(\n+                                impl1_def_id, impl2_def_id, overlap, true);\n+                        }\n+                    });\n+                }\n             }\n         }\n     }\n@@ -100,4 +131,3 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentOverlapChecker<'a, 'tcx> {\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n     }\n }\n-"}, {"sha": "d793a78799a70714ef6d1d832aa1c78eed34f8d6", "filename": "src/test/compile-fail/issue-43355.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2614cc51dde5e57983dd9809372845073ac30aac/src%2Ftest%2Fcompile-fail%2Fissue-43355.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614cc51dde5e57983dd9809372845073ac30aac/src%2Ftest%2Fcompile-fail%2Fissue-43355.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43355.rs?ref=2614cc51dde5e57983dd9809372845073ac30aac", "patch": "@@ -22,6 +22,7 @@ impl<X, T> Trait1<X> for T where T: Trait2<X> {\n \n impl<X> Trait1<Box<X>> for A {\n //~^ ERROR conflicting implementations of trait\n+//~| hard error\n //~| downstream crates may implement trait `Trait2<std::boxed::Box<_>>` for type `A`\n     type Output = i32;\n }"}, {"sha": "58d68bb955fe536079f14d1efc187bc9961d2c7d", "filename": "src/test/run-pass/issue-43355.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2614cc51dde5e57983dd9809372845073ac30aac/src%2Ftest%2Frun-pass%2Fissue-43355.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614cc51dde5e57983dd9809372845073ac30aac/src%2Ftest%2Frun-pass%2Fissue-43355.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-43355.rs?ref=2614cc51dde5e57983dd9809372845073ac30aac", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that the code for issue #43355 can run without an ICE, please remove\n+// this test when it becomes an hard error.\n+\n+#![allow(incoherent_fundamental_impls)]\n+\n+pub trait Trait1<X> {\n+    type Output;\n+}\n+pub trait Trait2<X> {}\n+\n+impl<X, T> Trait1<X> for T where T: Trait2<X> {\n+    type Output = ();\n+}\n+impl<X> Trait1<Box<X>> for A {\n+    type Output = i32;\n+}\n+\n+pub struct A;\n+\n+fn f<X, T: Trait1<Box<X>>>() {\n+    println!(\"k: {}\", ::std::mem::size_of::<<T as Trait1<Box<X>>>::Output>());\n+}\n+\n+pub fn g<X, T: Trait2<Box<X>>>() {\n+    f::<X, T>();\n+}\n+\n+fn main() {}"}]}