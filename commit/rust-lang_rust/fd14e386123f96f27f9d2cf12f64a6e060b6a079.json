{"sha": "fd14e386123f96f27f9d2cf12f64a6e060b6a079", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMTRlMzg2MTIzZjk2ZjI3ZjlkMmNmMTJmNjRhNmUwNjBiNmEwNzk=", "commit": {"author": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2021-02-14T07:17:38Z"}, "committer": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2021-03-04T18:24:56Z"}, "message": "Moved `write_shared` to its own file", "tree": {"sha": "c63f300456bc2f37f74389de7fb6cc3ee056cea1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c63f300456bc2f37f74389de7fb6cc3ee056cea1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd14e386123f96f27f9d2cf12f64a6e060b6a079", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd14e386123f96f27f9d2cf12f64a6e060b6a079", "html_url": "https://github.com/rust-lang/rust/commit/fd14e386123f96f27f9d2cf12f64a6e060b6a079", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd14e386123f96f27f9d2cf12f64a6e060b6a079/comments", "author": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14983b9812e67a283587b651c0a14e1d4e1ab723", "url": "https://api.github.com/repos/rust-lang/rust/commits/14983b9812e67a283587b651c0a14e1d4e1ab723", "html_url": "https://github.com/rust-lang/rust/commit/14983b9812e67a283587b651c0a14e1d4e1ab723"}], "stats": {"total": 1084, "additions": 549, "deletions": 535}, "files": [{"sha": "976168a9ac407a126802d3e72ae9376f24a12e62", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd14e386123f96f27f9d2cf12f64a6e060b6a079/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd14e386123f96f27f9d2cf12f64a6e060b6a079/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=fd14e386123f96f27f9d2cf12f64a6e060b6a079", "patch": "@@ -16,6 +16,7 @@ use rustc_span::symbol::sym;\n \n use super::cache::{build_index, ExternalLocation};\n use super::print_item::{full_path, item_path, print_item};\n+use super::write_shared::write_shared;\n use super::{\n     print_sidebar, settings, AllTypes, NameDoc, SharedContext, StylePath, BASIC_KEYWORDS,\n     CURRENT_DEPTH, INITIAL_IDS,"}, {"sha": "1db081b181f9b4c881e6d17b2d2db4b79b7fb7b2", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 6, "deletions": 535, "changes": 541, "blob_url": "https://github.com/rust-lang/rust/blob/fd14e386123f96f27f9d2cf12f64a6e060b6a079/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd14e386123f96f27f9d2cf12f64a6e060b6a079/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=fd14e386123f96f27f9d2cf12f64a6e060b6a079", "patch": "@@ -31,26 +31,22 @@ crate mod cache;\n mod tests;\n \n mod context;\n-crate use context::*;\n-\n mod print_item;\n+mod write_shared;\n+\n+crate use context::*;\n \n use std::cell::{Cell, RefCell};\n use std::collections::VecDeque;\n use std::default::Default;\n-use std::ffi::OsStr;\n-use std::fmt::{self, Write};\n-use std::fs::{self, File};\n-use std::io::prelude::*;\n-use std::io::{self, BufReader};\n-use std::path::{Component, Path, PathBuf};\n+use std::fmt;\n+use std::path::{Path, PathBuf};\n use std::str;\n use std::string::ToString;\n \n use itertools::Itertools;\n use rustc_ast_pretty::pprust;\n use rustc_attr::{Deprecation, StabilityLevel};\n-use rustc_data_structures::flock;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n@@ -64,7 +60,6 @@ use serde::ser::SerializeSeq;\n use serde::{Serialize, Serializer};\n \n use crate::clean::{self, GetDefId, RenderedLink, SelfTy, TypeKind};\n-use crate::config::RenderOptions;\n use crate::docfs::{DocFS, PathError};\n use crate::error::Error;\n use crate::formats::cache::Cache;\n@@ -75,8 +70,8 @@ use crate::html::format::{\n     href, print_abi_with_space, print_default_space, print_generic_bounds, Buffer, Function,\n     PrintWithSpace, WhereClause,\n };\n+use crate::html::layout;\n use crate::html::markdown::{self, ErrorCodes, Markdown, MarkdownHtml, MarkdownSummaryLine};\n-use crate::html::{layout, static_files};\n \n /// A pair of name and its optional document.\n crate type NameDoc = (String, Option<String>);\n@@ -318,529 +313,6 @@ crate const INITIAL_IDS: [&'static str; 15] = [\n     \"implementations\",\n ];\n \n-fn write_shared(\n-    cx: &Context<'_>,\n-    krate: &clean::Crate,\n-    search_index: String,\n-    options: &RenderOptions,\n-) -> Result<(), Error> {\n-    // Write out the shared files. Note that these are shared among all rustdoc\n-    // docs placed in the output directory, so this needs to be a synchronized\n-    // operation with respect to all other rustdocs running around.\n-    let lock_file = cx.dst.join(\".lock\");\n-    let _lock = try_err!(flock::Lock::new(&lock_file, true, true, true), &lock_file);\n-\n-    // Add all the static files. These may already exist, but we just\n-    // overwrite them anyway to make sure that they're fresh and up-to-date.\n-\n-    write_minify(\n-        &cx.shared.fs,\n-        cx.path(\"rustdoc.css\"),\n-        static_files::RUSTDOC_CSS,\n-        options.enable_minification,\n-    )?;\n-    write_minify(\n-        &cx.shared.fs,\n-        cx.path(\"settings.css\"),\n-        static_files::SETTINGS_CSS,\n-        options.enable_minification,\n-    )?;\n-    write_minify(\n-        &cx.shared.fs,\n-        cx.path(\"noscript.css\"),\n-        static_files::NOSCRIPT_CSS,\n-        options.enable_minification,\n-    )?;\n-\n-    // To avoid \"light.css\" to be overwritten, we'll first run over the received themes and only\n-    // then we'll run over the \"official\" styles.\n-    let mut themes: FxHashSet<String> = FxHashSet::default();\n-\n-    for entry in &cx.shared.style_files {\n-        let theme = try_none!(try_none!(entry.path.file_stem(), &entry.path).to_str(), &entry.path);\n-        let extension =\n-            try_none!(try_none!(entry.path.extension(), &entry.path).to_str(), &entry.path);\n-\n-        // Handle the official themes\n-        match theme {\n-            \"light\" => write_minify(\n-                &cx.shared.fs,\n-                cx.path(\"light.css\"),\n-                static_files::themes::LIGHT,\n-                options.enable_minification,\n-            )?,\n-            \"dark\" => write_minify(\n-                &cx.shared.fs,\n-                cx.path(\"dark.css\"),\n-                static_files::themes::DARK,\n-                options.enable_minification,\n-            )?,\n-            \"ayu\" => write_minify(\n-                &cx.shared.fs,\n-                cx.path(\"ayu.css\"),\n-                static_files::themes::AYU,\n-                options.enable_minification,\n-            )?,\n-            _ => {\n-                // Handle added third-party themes\n-                let content = try_err!(fs::read(&entry.path), &entry.path);\n-                cx.shared\n-                    .fs\n-                    .write(cx.path(&format!(\"{}.{}\", theme, extension)), content.as_slice())?;\n-            }\n-        };\n-\n-        themes.insert(theme.to_owned());\n-    }\n-\n-    let write = |p, c| cx.shared.fs.write(p, c);\n-    if (*cx.shared).layout.logo.is_empty() {\n-        write(cx.path(\"rust-logo.png\"), static_files::RUST_LOGO)?;\n-    }\n-    if (*cx.shared).layout.favicon.is_empty() {\n-        write(cx.path(\"favicon.svg\"), static_files::RUST_FAVICON_SVG)?;\n-        write(cx.path(\"favicon-16x16.png\"), static_files::RUST_FAVICON_PNG_16)?;\n-        write(cx.path(\"favicon-32x32.png\"), static_files::RUST_FAVICON_PNG_32)?;\n-    }\n-    write(cx.path(\"brush.svg\"), static_files::BRUSH_SVG)?;\n-    write(cx.path(\"wheel.svg\"), static_files::WHEEL_SVG)?;\n-    write(cx.path(\"down-arrow.svg\"), static_files::DOWN_ARROW_SVG)?;\n-\n-    let mut themes: Vec<&String> = themes.iter().collect();\n-    themes.sort();\n-    // To avoid theme switch latencies as much as possible, we put everything theme related\n-    // at the beginning of the html files into another js file.\n-    let theme_js = format!(\n-        r#\"var themes = document.getElementById(\"theme-choices\");\n-var themePicker = document.getElementById(\"theme-picker\");\n-\n-function showThemeButtonState() {{\n-    themes.style.display = \"block\";\n-    themePicker.style.borderBottomRightRadius = \"0\";\n-    themePicker.style.borderBottomLeftRadius = \"0\";\n-}}\n-\n-function hideThemeButtonState() {{\n-    themes.style.display = \"none\";\n-    themePicker.style.borderBottomRightRadius = \"3px\";\n-    themePicker.style.borderBottomLeftRadius = \"3px\";\n-}}\n-\n-function switchThemeButtonState() {{\n-    if (themes.style.display === \"block\") {{\n-        hideThemeButtonState();\n-    }} else {{\n-        showThemeButtonState();\n-    }}\n-}};\n-\n-function handleThemeButtonsBlur(e) {{\n-    var active = document.activeElement;\n-    var related = e.relatedTarget;\n-\n-    if (active.id !== \"theme-picker\" &&\n-        (!active.parentNode || active.parentNode.id !== \"theme-choices\") &&\n-        (!related ||\n-         (related.id !== \"theme-picker\" &&\n-          (!related.parentNode || related.parentNode.id !== \"theme-choices\")))) {{\n-        hideThemeButtonState();\n-    }}\n-}}\n-\n-themePicker.onclick = switchThemeButtonState;\n-themePicker.onblur = handleThemeButtonsBlur;\n-{}.forEach(function(item) {{\n-    var but = document.createElement(\"button\");\n-    but.textContent = item;\n-    but.onclick = function(el) {{\n-        switchTheme(currentTheme, mainTheme, item, true);\n-        useSystemTheme(false);\n-    }};\n-    but.onblur = handleThemeButtonsBlur;\n-    themes.appendChild(but);\n-}});\"#,\n-        serde_json::to_string(&themes).unwrap()\n-    );\n-\n-    write_minify(&cx.shared.fs, cx.path(\"theme.js\"), &theme_js, options.enable_minification)?;\n-    write_minify(\n-        &cx.shared.fs,\n-        cx.path(\"main.js\"),\n-        static_files::MAIN_JS,\n-        options.enable_minification,\n-    )?;\n-    write_minify(\n-        &cx.shared.fs,\n-        cx.path(\"settings.js\"),\n-        static_files::SETTINGS_JS,\n-        options.enable_minification,\n-    )?;\n-    if cx.shared.include_sources {\n-        write_minify(\n-            &cx.shared.fs,\n-            cx.path(\"source-script.js\"),\n-            static_files::sidebar::SOURCE_SCRIPT,\n-            options.enable_minification,\n-        )?;\n-    }\n-\n-    {\n-        write_minify(\n-            &cx.shared.fs,\n-            cx.path(\"storage.js\"),\n-            &format!(\n-                \"var resourcesSuffix = \\\"{}\\\";{}\",\n-                cx.shared.resource_suffix,\n-                static_files::STORAGE_JS\n-            ),\n-            options.enable_minification,\n-        )?;\n-    }\n-\n-    if let Some(ref css) = cx.shared.layout.css_file_extension {\n-        let out = cx.path(\"theme.css\");\n-        let buffer = try_err!(fs::read_to_string(css), css);\n-        if !options.enable_minification {\n-            cx.shared.fs.write(&out, &buffer)?;\n-        } else {\n-            write_minify(&cx.shared.fs, out, &buffer, options.enable_minification)?;\n-        }\n-    }\n-    write_minify(\n-        &cx.shared.fs,\n-        cx.path(\"normalize.css\"),\n-        static_files::NORMALIZE_CSS,\n-        options.enable_minification,\n-    )?;\n-    write(cx.dst.join(\"FiraSans-Regular.woff2\"), static_files::fira_sans::REGULAR2)?;\n-    write(cx.dst.join(\"FiraSans-Medium.woff2\"), static_files::fira_sans::MEDIUM2)?;\n-    write(cx.dst.join(\"FiraSans-Regular.woff\"), static_files::fira_sans::REGULAR)?;\n-    write(cx.dst.join(\"FiraSans-Medium.woff\"), static_files::fira_sans::MEDIUM)?;\n-    write(cx.dst.join(\"FiraSans-LICENSE.txt\"), static_files::fira_sans::LICENSE)?;\n-    write(cx.dst.join(\"SourceSerifPro-Regular.ttf.woff\"), static_files::source_serif_pro::REGULAR)?;\n-    write(cx.dst.join(\"SourceSerifPro-Bold.ttf.woff\"), static_files::source_serif_pro::BOLD)?;\n-    write(cx.dst.join(\"SourceSerifPro-It.ttf.woff\"), static_files::source_serif_pro::ITALIC)?;\n-    write(cx.dst.join(\"SourceSerifPro-LICENSE.md\"), static_files::source_serif_pro::LICENSE)?;\n-    write(cx.dst.join(\"SourceCodePro-Regular.woff\"), static_files::source_code_pro::REGULAR)?;\n-    write(cx.dst.join(\"SourceCodePro-Semibold.woff\"), static_files::source_code_pro::SEMIBOLD)?;\n-    write(cx.dst.join(\"SourceCodePro-LICENSE.txt\"), static_files::source_code_pro::LICENSE)?;\n-    write(cx.dst.join(\"LICENSE-MIT.txt\"), static_files::LICENSE_MIT)?;\n-    write(cx.dst.join(\"LICENSE-APACHE.txt\"), static_files::LICENSE_APACHE)?;\n-    write(cx.dst.join(\"COPYRIGHT.txt\"), static_files::COPYRIGHT)?;\n-\n-    fn collect(path: &Path, krate: &str, key: &str) -> io::Result<(Vec<String>, Vec<String>)> {\n-        let mut ret = Vec::new();\n-        let mut krates = Vec::new();\n-\n-        if path.exists() {\n-            let prefix = format!(r#\"{}[\"{}\"]\"#, key, krate);\n-            for line in BufReader::new(File::open(path)?).lines() {\n-                let line = line?;\n-                if !line.starts_with(key) {\n-                    continue;\n-                }\n-                if line.starts_with(&prefix) {\n-                    continue;\n-                }\n-                ret.push(line.to_string());\n-                krates.push(\n-                    line[key.len() + 2..]\n-                        .split('\"')\n-                        .next()\n-                        .map(|s| s.to_owned())\n-                        .unwrap_or_else(String::new),\n-                );\n-            }\n-        }\n-        Ok((ret, krates))\n-    }\n-\n-    fn collect_json(path: &Path, krate: &str) -> io::Result<(Vec<String>, Vec<String>)> {\n-        let mut ret = Vec::new();\n-        let mut krates = Vec::new();\n-\n-        if path.exists() {\n-            let prefix = format!(\"\\\"{}\\\"\", krate);\n-            for line in BufReader::new(File::open(path)?).lines() {\n-                let line = line?;\n-                if !line.starts_with('\"') {\n-                    continue;\n-                }\n-                if line.starts_with(&prefix) {\n-                    continue;\n-                }\n-                if line.ends_with(\",\\\\\") {\n-                    ret.push(line[..line.len() - 2].to_string());\n-                } else {\n-                    // Ends with \"\\\\\" (it's the case for the last added crate line)\n-                    ret.push(line[..line.len() - 1].to_string());\n-                }\n-                krates.push(\n-                    line.split('\"')\n-                        .find(|s| !s.is_empty())\n-                        .map(|s| s.to_owned())\n-                        .unwrap_or_else(String::new),\n-                );\n-            }\n-        }\n-        Ok((ret, krates))\n-    }\n-\n-    use std::ffi::OsString;\n-\n-    #[derive(Debug)]\n-    struct Hierarchy {\n-        elem: OsString,\n-        children: FxHashMap<OsString, Hierarchy>,\n-        elems: FxHashSet<OsString>,\n-    }\n-\n-    impl Hierarchy {\n-        fn new(elem: OsString) -> Hierarchy {\n-            Hierarchy { elem, children: FxHashMap::default(), elems: FxHashSet::default() }\n-        }\n-\n-        fn to_json_string(&self) -> String {\n-            let mut subs: Vec<&Hierarchy> = self.children.values().collect();\n-            subs.sort_unstable_by(|a, b| a.elem.cmp(&b.elem));\n-            let mut files = self\n-                .elems\n-                .iter()\n-                .map(|s| format!(\"\\\"{}\\\"\", s.to_str().expect(\"invalid osstring conversion\")))\n-                .collect::<Vec<_>>();\n-            files.sort_unstable();\n-            let subs = subs.iter().map(|s| s.to_json_string()).collect::<Vec<_>>().join(\",\");\n-            let dirs =\n-                if subs.is_empty() { String::new() } else { format!(\",\\\"dirs\\\":[{}]\", subs) };\n-            let files = files.join(\",\");\n-            let files =\n-                if files.is_empty() { String::new() } else { format!(\",\\\"files\\\":[{}]\", files) };\n-            format!(\n-                \"{{\\\"name\\\":\\\"{name}\\\"{dirs}{files}}}\",\n-                name = self.elem.to_str().expect(\"invalid osstring conversion\"),\n-                dirs = dirs,\n-                files = files\n-            )\n-        }\n-    }\n-\n-    if cx.shared.include_sources {\n-        let mut hierarchy = Hierarchy::new(OsString::new());\n-        for source in cx\n-            .shared\n-            .local_sources\n-            .iter()\n-            .filter_map(|p| p.0.strip_prefix(&cx.shared.src_root).ok())\n-        {\n-            let mut h = &mut hierarchy;\n-            let mut elems = source\n-                .components()\n-                .filter_map(|s| match s {\n-                    Component::Normal(s) => Some(s.to_owned()),\n-                    _ => None,\n-                })\n-                .peekable();\n-            loop {\n-                let cur_elem = elems.next().expect(\"empty file path\");\n-                if elems.peek().is_none() {\n-                    h.elems.insert(cur_elem);\n-                    break;\n-                } else {\n-                    let e = cur_elem.clone();\n-                    h = h.children.entry(cur_elem.clone()).or_insert_with(|| Hierarchy::new(e));\n-                }\n-            }\n-        }\n-\n-        let dst = cx.dst.join(&format!(\"source-files{}.js\", cx.shared.resource_suffix));\n-        let (mut all_sources, _krates) =\n-            try_err!(collect(&dst, &krate.name.as_str(), \"sourcesIndex\"), &dst);\n-        all_sources.push(format!(\n-            \"sourcesIndex[\\\"{}\\\"] = {};\",\n-            &krate.name,\n-            hierarchy.to_json_string()\n-        ));\n-        all_sources.sort();\n-        let v = format!(\n-            \"var N = null;var sourcesIndex = {{}};\\n{}\\ncreateSourceSidebar();\\n\",\n-            all_sources.join(\"\\n\")\n-        );\n-        cx.shared.fs.write(&dst, v.as_bytes())?;\n-    }\n-\n-    // Update the search index and crate list.\n-    let dst = cx.dst.join(&format!(\"search-index{}.js\", cx.shared.resource_suffix));\n-    let (mut all_indexes, mut krates) = try_err!(collect_json(&dst, &krate.name.as_str()), &dst);\n-    all_indexes.push(search_index);\n-    krates.push(krate.name.to_string());\n-    krates.sort();\n-\n-    // Sort the indexes by crate so the file will be generated identically even\n-    // with rustdoc running in parallel.\n-    all_indexes.sort();\n-    {\n-        let mut v = String::from(\"var searchIndex = JSON.parse('{\\\\\\n\");\n-        v.push_str(&all_indexes.join(\",\\\\\\n\"));\n-        v.push_str(\"\\\\\\n}');\\ninitSearch(searchIndex);\");\n-        cx.shared.fs.write(&dst, &v)?;\n-    }\n-\n-    let crate_list_dst = cx.dst.join(&format!(\"crates{}.js\", cx.shared.resource_suffix));\n-    let crate_list =\n-        format!(\"window.ALL_CRATES = [{}];\", krates.iter().map(|k| format!(\"\\\"{}\\\"\", k)).join(\",\"));\n-    cx.shared.fs.write(&crate_list_dst, &crate_list)?;\n-\n-    if options.enable_index_page {\n-        if let Some(index_page) = options.index_page.clone() {\n-            let mut md_opts = options.clone();\n-            md_opts.output = cx.dst.clone();\n-            md_opts.external_html = (*cx.shared).layout.external_html.clone();\n-\n-            crate::markdown::render(&index_page, md_opts, cx.shared.edition)\n-                .map_err(|e| Error::new(e, &index_page))?;\n-        } else {\n-            let dst = cx.dst.join(\"index.html\");\n-            let page = layout::Page {\n-                title: \"Index of crates\",\n-                css_class: \"mod\",\n-                root_path: \"./\",\n-                static_root_path: cx.shared.static_root_path.as_deref(),\n-                description: \"List of crates\",\n-                keywords: BASIC_KEYWORDS,\n-                resource_suffix: &cx.shared.resource_suffix,\n-                extra_scripts: &[],\n-                static_extra_scripts: &[],\n-            };\n-\n-            let content = format!(\n-                \"<h1 class=\\\"fqn\\\">\\\n-                     <span class=\\\"in-band\\\">List of all crates</span>\\\n-                </h1><ul class=\\\"crate mod\\\">{}</ul>\",\n-                krates\n-                    .iter()\n-                    .map(|s| {\n-                        format!(\n-                            \"<li><a class=\\\"crate mod\\\" href=\\\"{}index.html\\\">{}</a></li>\",\n-                            ensure_trailing_slash(s),\n-                            s\n-                        )\n-                    })\n-                    .collect::<String>()\n-            );\n-            let v = layout::render(&cx.shared.layout, &page, \"\", content, &cx.shared.style_files);\n-            cx.shared.fs.write(&dst, v.as_bytes())?;\n-        }\n-    }\n-\n-    // Update the list of all implementors for traits\n-    let dst = cx.dst.join(\"implementors\");\n-    for (&did, imps) in &cx.cache.implementors {\n-        // Private modules can leak through to this phase of rustdoc, which\n-        // could contain implementations for otherwise private types. In some\n-        // rare cases we could find an implementation for an item which wasn't\n-        // indexed, so we just skip this step in that case.\n-        //\n-        // FIXME: this is a vague explanation for why this can't be a `get`, in\n-        //        theory it should be...\n-        let &(ref remote_path, remote_item_type) = match cx.cache.paths.get(&did) {\n-            Some(p) => p,\n-            None => match cx.cache.external_paths.get(&did) {\n-                Some(p) => p,\n-                None => continue,\n-            },\n-        };\n-\n-        #[derive(Serialize)]\n-        struct Implementor {\n-            text: String,\n-            synthetic: bool,\n-            types: Vec<String>,\n-        }\n-\n-        let implementors = imps\n-            .iter()\n-            .filter_map(|imp| {\n-                // If the trait and implementation are in the same crate, then\n-                // there's no need to emit information about it (there's inlining\n-                // going on). If they're in different crates then the crate defining\n-                // the trait will be interested in our implementation.\n-                //\n-                // If the implementation is from another crate then that crate\n-                // should add it.\n-                if imp.impl_item.def_id.krate == did.krate || !imp.impl_item.def_id.is_local() {\n-                    None\n-                } else {\n-                    Some(Implementor {\n-                        text: imp.inner_impl().print(cx.cache(), false).to_string(),\n-                        synthetic: imp.inner_impl().synthetic,\n-                        types: collect_paths_for_type(imp.inner_impl().for_.clone(), cx.cache()),\n-                    })\n-                }\n-            })\n-            .collect::<Vec<_>>();\n-\n-        // Only create a js file if we have impls to add to it. If the trait is\n-        // documented locally though we always create the file to avoid dead\n-        // links.\n-        if implementors.is_empty() && !cx.cache.paths.contains_key(&did) {\n-            continue;\n-        }\n-\n-        let implementors = format!(\n-            r#\"implementors[\"{}\"] = {};\"#,\n-            krate.name,\n-            serde_json::to_string(&implementors).unwrap()\n-        );\n-\n-        let mut mydst = dst.clone();\n-        for part in &remote_path[..remote_path.len() - 1] {\n-            mydst.push(part);\n-        }\n-        cx.shared.ensure_dir(&mydst)?;\n-        mydst.push(&format!(\"{}.{}.js\", remote_item_type, remote_path[remote_path.len() - 1]));\n-\n-        let (mut all_implementors, _) =\n-            try_err!(collect(&mydst, &krate.name.as_str(), \"implementors\"), &mydst);\n-        all_implementors.push(implementors);\n-        // Sort the implementors by crate so the file will be generated\n-        // identically even with rustdoc running in parallel.\n-        all_implementors.sort();\n-\n-        let mut v = String::from(\"(function() {var implementors = {};\\n\");\n-        for implementor in &all_implementors {\n-            writeln!(v, \"{}\", *implementor).unwrap();\n-        }\n-        v.push_str(\n-            \"if (window.register_implementors) {\\\n-                 window.register_implementors(implementors);\\\n-             } else {\\\n-                 window.pending_implementors = implementors;\\\n-             }\",\n-        );\n-        v.push_str(\"})()\");\n-        cx.shared.fs.write(&mydst, &v)?;\n-    }\n-    Ok(())\n-}\n-\n-fn write_minify(\n-    fs: &DocFS,\n-    dst: PathBuf,\n-    contents: &str,\n-    enable_minification: bool,\n-) -> Result<(), Error> {\n-    if enable_minification {\n-        if dst.extension() == Some(&OsStr::new(\"css\")) {\n-            let res = try_none!(minifier::css::minify(contents).ok(), &dst);\n-            fs.write(dst, res.as_bytes())\n-        } else {\n-            fs.write(dst, minifier::js::minify(contents).as_bytes())\n-        }\n-    } else {\n-        fs.write(dst, contents.as_bytes())\n-    }\n-}\n-\n fn write_srclink(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer) {\n     if let Some(l) = cx.src_href(item) {\n         write!(buf, \"<a class=\\\"srclink\\\" href=\\\"{}\\\" title=\\\"goto source code\\\">[src]</a>\", l)\n@@ -2924,7 +2396,6 @@ fn sidebar_foreign_type(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n \n crate const BASIC_KEYWORDS: &str = \"rust, rustlang, rust-lang\";\n \n-\n /// Returns a list of all paths used in the type.\n /// This is used to help deduplicate imported impls\n /// for reexported types. If any of the contained"}, {"sha": "cbf0f9a4927c61b279e836e3d97a5f2d5a378450", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "added", "additions": 542, "deletions": 0, "changes": 542, "blob_url": "https://github.com/rust-lang/rust/blob/fd14e386123f96f27f9d2cf12f64a6e060b6a079/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd14e386123f96f27f9d2cf12f64a6e060b6a079/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=fd14e386123f96f27f9d2cf12f64a6e060b6a079", "patch": "@@ -0,0 +1,542 @@\n+use std::ffi::OsStr;\n+use std::fmt::Write;\n+use std::fs::{self, File};\n+use std::io::prelude::*;\n+use std::io::{self, BufReader};\n+use std::path::{Component, Path, PathBuf};\n+\n+use itertools::Itertools;\n+use rustc_data_structures::flock;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use serde::Serialize;\n+\n+use super::{collect_paths_for_type, ensure_trailing_slash, Context, BASIC_KEYWORDS};\n+use crate::clean::Crate;\n+use crate::config::RenderOptions;\n+use crate::docfs::{DocFS, PathError};\n+use crate::error::Error;\n+use crate::formats::FormatRenderer;\n+use crate::html::{layout, static_files};\n+\n+pub(super) fn write_shared(\n+    cx: &Context<'_>,\n+    krate: &Crate,\n+    search_index: String,\n+    options: &RenderOptions,\n+) -> Result<(), Error> {\n+    // Write out the shared files. Note that these are shared among all rustdoc\n+    // docs placed in the output directory, so this needs to be a synchronized\n+    // operation with respect to all other rustdocs running around.\n+    let lock_file = cx.dst.join(\".lock\");\n+    let _lock = try_err!(flock::Lock::new(&lock_file, true, true, true), &lock_file);\n+\n+    // Add all the static files. These may already exist, but we just\n+    // overwrite them anyway to make sure that they're fresh and up-to-date.\n+\n+    write_minify(\n+        &cx.shared.fs,\n+        cx.path(\"rustdoc.css\"),\n+        static_files::RUSTDOC_CSS,\n+        options.enable_minification,\n+    )?;\n+    write_minify(\n+        &cx.shared.fs,\n+        cx.path(\"settings.css\"),\n+        static_files::SETTINGS_CSS,\n+        options.enable_minification,\n+    )?;\n+    write_minify(\n+        &cx.shared.fs,\n+        cx.path(\"noscript.css\"),\n+        static_files::NOSCRIPT_CSS,\n+        options.enable_minification,\n+    )?;\n+\n+    // To avoid \"light.css\" to be overwritten, we'll first run over the received themes and only\n+    // then we'll run over the \"official\" styles.\n+    let mut themes: FxHashSet<String> = FxHashSet::default();\n+\n+    for entry in &cx.shared.style_files {\n+        let theme = try_none!(try_none!(entry.path.file_stem(), &entry.path).to_str(), &entry.path);\n+        let extension =\n+            try_none!(try_none!(entry.path.extension(), &entry.path).to_str(), &entry.path);\n+\n+        // Handle the official themes\n+        match theme {\n+            \"light\" => write_minify(\n+                &cx.shared.fs,\n+                cx.path(\"light.css\"),\n+                static_files::themes::LIGHT,\n+                options.enable_minification,\n+            )?,\n+            \"dark\" => write_minify(\n+                &cx.shared.fs,\n+                cx.path(\"dark.css\"),\n+                static_files::themes::DARK,\n+                options.enable_minification,\n+            )?,\n+            \"ayu\" => write_minify(\n+                &cx.shared.fs,\n+                cx.path(\"ayu.css\"),\n+                static_files::themes::AYU,\n+                options.enable_minification,\n+            )?,\n+            _ => {\n+                // Handle added third-party themes\n+                let content = try_err!(fs::read(&entry.path), &entry.path);\n+                cx.shared\n+                    .fs\n+                    .write(cx.path(&format!(\"{}.{}\", theme, extension)), content.as_slice())?;\n+            }\n+        };\n+\n+        themes.insert(theme.to_owned());\n+    }\n+\n+    let write = |p, c| cx.shared.fs.write(p, c);\n+    if (*cx.shared).layout.logo.is_empty() {\n+        write(cx.path(\"rust-logo.png\"), static_files::RUST_LOGO)?;\n+    }\n+    if (*cx.shared).layout.favicon.is_empty() {\n+        write(cx.path(\"favicon.svg\"), static_files::RUST_FAVICON_SVG)?;\n+        write(cx.path(\"favicon-16x16.png\"), static_files::RUST_FAVICON_PNG_16)?;\n+        write(cx.path(\"favicon-32x32.png\"), static_files::RUST_FAVICON_PNG_32)?;\n+    }\n+    write(cx.path(\"brush.svg\"), static_files::BRUSH_SVG)?;\n+    write(cx.path(\"wheel.svg\"), static_files::WHEEL_SVG)?;\n+    write(cx.path(\"down-arrow.svg\"), static_files::DOWN_ARROW_SVG)?;\n+\n+    let mut themes: Vec<&String> = themes.iter().collect();\n+    themes.sort();\n+    // To avoid theme switch latencies as much as possible, we put everything theme related\n+    // at the beginning of the html files into another js file.\n+    let theme_js = format!(\n+        r#\"var themes = document.getElementById(\"theme-choices\");\n+var themePicker = document.getElementById(\"theme-picker\");\n+\n+function showThemeButtonState() {{\n+    themes.style.display = \"block\";\n+    themePicker.style.borderBottomRightRadius = \"0\";\n+    themePicker.style.borderBottomLeftRadius = \"0\";\n+}}\n+\n+function hideThemeButtonState() {{\n+    themes.style.display = \"none\";\n+    themePicker.style.borderBottomRightRadius = \"3px\";\n+    themePicker.style.borderBottomLeftRadius = \"3px\";\n+}}\n+\n+function switchThemeButtonState() {{\n+    if (themes.style.display === \"block\") {{\n+        hideThemeButtonState();\n+    }} else {{\n+        showThemeButtonState();\n+    }}\n+}};\n+\n+function handleThemeButtonsBlur(e) {{\n+    var active = document.activeElement;\n+    var related = e.relatedTarget;\n+\n+    if (active.id !== \"theme-picker\" &&\n+        (!active.parentNode || active.parentNode.id !== \"theme-choices\") &&\n+        (!related ||\n+         (related.id !== \"theme-picker\" &&\n+          (!related.parentNode || related.parentNode.id !== \"theme-choices\")))) {{\n+        hideThemeButtonState();\n+    }}\n+}}\n+\n+themePicker.onclick = switchThemeButtonState;\n+themePicker.onblur = handleThemeButtonsBlur;\n+{}.forEach(function(item) {{\n+    var but = document.createElement(\"button\");\n+    but.textContent = item;\n+    but.onclick = function(el) {{\n+        switchTheme(currentTheme, mainTheme, item, true);\n+        useSystemTheme(false);\n+    }};\n+    but.onblur = handleThemeButtonsBlur;\n+    themes.appendChild(but);\n+}});\"#,\n+        serde_json::to_string(&themes).unwrap()\n+    );\n+\n+    write_minify(&cx.shared.fs, cx.path(\"theme.js\"), &theme_js, options.enable_minification)?;\n+    write_minify(\n+        &cx.shared.fs,\n+        cx.path(\"main.js\"),\n+        static_files::MAIN_JS,\n+        options.enable_minification,\n+    )?;\n+    write_minify(\n+        &cx.shared.fs,\n+        cx.path(\"settings.js\"),\n+        static_files::SETTINGS_JS,\n+        options.enable_minification,\n+    )?;\n+    if cx.shared.include_sources {\n+        write_minify(\n+            &cx.shared.fs,\n+            cx.path(\"source-script.js\"),\n+            static_files::sidebar::SOURCE_SCRIPT,\n+            options.enable_minification,\n+        )?;\n+    }\n+\n+    {\n+        write_minify(\n+            &cx.shared.fs,\n+            cx.path(\"storage.js\"),\n+            &format!(\n+                \"var resourcesSuffix = \\\"{}\\\";{}\",\n+                cx.shared.resource_suffix,\n+                static_files::STORAGE_JS\n+            ),\n+            options.enable_minification,\n+        )?;\n+    }\n+\n+    if let Some(ref css) = cx.shared.layout.css_file_extension {\n+        let out = cx.path(\"theme.css\");\n+        let buffer = try_err!(fs::read_to_string(css), css);\n+        if !options.enable_minification {\n+            cx.shared.fs.write(&out, &buffer)?;\n+        } else {\n+            write_minify(&cx.shared.fs, out, &buffer, options.enable_minification)?;\n+        }\n+    }\n+    write_minify(\n+        &cx.shared.fs,\n+        cx.path(\"normalize.css\"),\n+        static_files::NORMALIZE_CSS,\n+        options.enable_minification,\n+    )?;\n+    write(cx.dst.join(\"FiraSans-Regular.woff2\"), static_files::fira_sans::REGULAR2)?;\n+    write(cx.dst.join(\"FiraSans-Medium.woff2\"), static_files::fira_sans::MEDIUM2)?;\n+    write(cx.dst.join(\"FiraSans-Regular.woff\"), static_files::fira_sans::REGULAR)?;\n+    write(cx.dst.join(\"FiraSans-Medium.woff\"), static_files::fira_sans::MEDIUM)?;\n+    write(cx.dst.join(\"FiraSans-LICENSE.txt\"), static_files::fira_sans::LICENSE)?;\n+    write(cx.dst.join(\"SourceSerifPro-Regular.ttf.woff\"), static_files::source_serif_pro::REGULAR)?;\n+    write(cx.dst.join(\"SourceSerifPro-Bold.ttf.woff\"), static_files::source_serif_pro::BOLD)?;\n+    write(cx.dst.join(\"SourceSerifPro-It.ttf.woff\"), static_files::source_serif_pro::ITALIC)?;\n+    write(cx.dst.join(\"SourceSerifPro-LICENSE.md\"), static_files::source_serif_pro::LICENSE)?;\n+    write(cx.dst.join(\"SourceCodePro-Regular.woff\"), static_files::source_code_pro::REGULAR)?;\n+    write(cx.dst.join(\"SourceCodePro-Semibold.woff\"), static_files::source_code_pro::SEMIBOLD)?;\n+    write(cx.dst.join(\"SourceCodePro-LICENSE.txt\"), static_files::source_code_pro::LICENSE)?;\n+    write(cx.dst.join(\"LICENSE-MIT.txt\"), static_files::LICENSE_MIT)?;\n+    write(cx.dst.join(\"LICENSE-APACHE.txt\"), static_files::LICENSE_APACHE)?;\n+    write(cx.dst.join(\"COPYRIGHT.txt\"), static_files::COPYRIGHT)?;\n+\n+    fn collect(path: &Path, krate: &str, key: &str) -> io::Result<(Vec<String>, Vec<String>)> {\n+        let mut ret = Vec::new();\n+        let mut krates = Vec::new();\n+\n+        if path.exists() {\n+            let prefix = format!(r#\"{}[\"{}\"]\"#, key, krate);\n+            for line in BufReader::new(File::open(path)?).lines() {\n+                let line = line?;\n+                if !line.starts_with(key) {\n+                    continue;\n+                }\n+                if line.starts_with(&prefix) {\n+                    continue;\n+                }\n+                ret.push(line.to_string());\n+                krates.push(\n+                    line[key.len() + 2..]\n+                        .split('\"')\n+                        .next()\n+                        .map(|s| s.to_owned())\n+                        .unwrap_or_else(String::new),\n+                );\n+            }\n+        }\n+        Ok((ret, krates))\n+    }\n+\n+    fn collect_json(path: &Path, krate: &str) -> io::Result<(Vec<String>, Vec<String>)> {\n+        let mut ret = Vec::new();\n+        let mut krates = Vec::new();\n+\n+        if path.exists() {\n+            let prefix = format!(\"\\\"{}\\\"\", krate);\n+            for line in BufReader::new(File::open(path)?).lines() {\n+                let line = line?;\n+                if !line.starts_with('\"') {\n+                    continue;\n+                }\n+                if line.starts_with(&prefix) {\n+                    continue;\n+                }\n+                if line.ends_with(\",\\\\\") {\n+                    ret.push(line[..line.len() - 2].to_string());\n+                } else {\n+                    // Ends with \"\\\\\" (it's the case for the last added crate line)\n+                    ret.push(line[..line.len() - 1].to_string());\n+                }\n+                krates.push(\n+                    line.split('\"')\n+                        .find(|s| !s.is_empty())\n+                        .map(|s| s.to_owned())\n+                        .unwrap_or_else(String::new),\n+                );\n+            }\n+        }\n+        Ok((ret, krates))\n+    }\n+\n+    use std::ffi::OsString;\n+\n+    #[derive(Debug)]\n+    struct Hierarchy {\n+        elem: OsString,\n+        children: FxHashMap<OsString, Hierarchy>,\n+        elems: FxHashSet<OsString>,\n+    }\n+\n+    impl Hierarchy {\n+        fn new(elem: OsString) -> Hierarchy {\n+            Hierarchy { elem, children: FxHashMap::default(), elems: FxHashSet::default() }\n+        }\n+\n+        fn to_json_string(&self) -> String {\n+            let mut subs: Vec<&Hierarchy> = self.children.values().collect();\n+            subs.sort_unstable_by(|a, b| a.elem.cmp(&b.elem));\n+            let mut files = self\n+                .elems\n+                .iter()\n+                .map(|s| format!(\"\\\"{}\\\"\", s.to_str().expect(\"invalid osstring conversion\")))\n+                .collect::<Vec<_>>();\n+            files.sort_unstable();\n+            let subs = subs.iter().map(|s| s.to_json_string()).collect::<Vec<_>>().join(\",\");\n+            let dirs =\n+                if subs.is_empty() { String::new() } else { format!(\",\\\"dirs\\\":[{}]\", subs) };\n+            let files = files.join(\",\");\n+            let files =\n+                if files.is_empty() { String::new() } else { format!(\",\\\"files\\\":[{}]\", files) };\n+            format!(\n+                \"{{\\\"name\\\":\\\"{name}\\\"{dirs}{files}}}\",\n+                name = self.elem.to_str().expect(\"invalid osstring conversion\"),\n+                dirs = dirs,\n+                files = files\n+            )\n+        }\n+    }\n+\n+    if cx.shared.include_sources {\n+        let mut hierarchy = Hierarchy::new(OsString::new());\n+        for source in cx\n+            .shared\n+            .local_sources\n+            .iter()\n+            .filter_map(|p| p.0.strip_prefix(&cx.shared.src_root).ok())\n+        {\n+            let mut h = &mut hierarchy;\n+            let mut elems = source\n+                .components()\n+                .filter_map(|s| match s {\n+                    Component::Normal(s) => Some(s.to_owned()),\n+                    _ => None,\n+                })\n+                .peekable();\n+            loop {\n+                let cur_elem = elems.next().expect(\"empty file path\");\n+                if elems.peek().is_none() {\n+                    h.elems.insert(cur_elem);\n+                    break;\n+                } else {\n+                    let e = cur_elem.clone();\n+                    h = h.children.entry(cur_elem.clone()).or_insert_with(|| Hierarchy::new(e));\n+                }\n+            }\n+        }\n+\n+        let dst = cx.dst.join(&format!(\"source-files{}.js\", cx.shared.resource_suffix));\n+        let (mut all_sources, _krates) =\n+            try_err!(collect(&dst, &krate.name.as_str(), \"sourcesIndex\"), &dst);\n+        all_sources.push(format!(\n+            \"sourcesIndex[\\\"{}\\\"] = {};\",\n+            &krate.name,\n+            hierarchy.to_json_string()\n+        ));\n+        all_sources.sort();\n+        let v = format!(\n+            \"var N = null;var sourcesIndex = {{}};\\n{}\\ncreateSourceSidebar();\\n\",\n+            all_sources.join(\"\\n\")\n+        );\n+        cx.shared.fs.write(&dst, v.as_bytes())?;\n+    }\n+\n+    // Update the search index and crate list.\n+    let dst = cx.dst.join(&format!(\"search-index{}.js\", cx.shared.resource_suffix));\n+    let (mut all_indexes, mut krates) = try_err!(collect_json(&dst, &krate.name.as_str()), &dst);\n+    all_indexes.push(search_index);\n+    krates.push(krate.name.to_string());\n+    krates.sort();\n+\n+    // Sort the indexes by crate so the file will be generated identically even\n+    // with rustdoc running in parallel.\n+    all_indexes.sort();\n+    {\n+        let mut v = String::from(\"var searchIndex = JSON.parse('{\\\\\\n\");\n+        v.push_str(&all_indexes.join(\",\\\\\\n\"));\n+        v.push_str(\"\\\\\\n}');\\ninitSearch(searchIndex);\");\n+        cx.shared.fs.write(&dst, &v)?;\n+    }\n+\n+    let crate_list_dst = cx.dst.join(&format!(\"crates{}.js\", cx.shared.resource_suffix));\n+    let crate_list =\n+        format!(\"window.ALL_CRATES = [{}];\", krates.iter().map(|k| format!(\"\\\"{}\\\"\", k)).join(\",\"));\n+    cx.shared.fs.write(&crate_list_dst, &crate_list)?;\n+\n+    if options.enable_index_page {\n+        if let Some(index_page) = options.index_page.clone() {\n+            let mut md_opts = options.clone();\n+            md_opts.output = cx.dst.clone();\n+            md_opts.external_html = (*cx.shared).layout.external_html.clone();\n+\n+            crate::markdown::render(&index_page, md_opts, cx.shared.edition)\n+                .map_err(|e| Error::new(e, &index_page))?;\n+        } else {\n+            let dst = cx.dst.join(\"index.html\");\n+            let page = layout::Page {\n+                title: \"Index of crates\",\n+                css_class: \"mod\",\n+                root_path: \"./\",\n+                static_root_path: cx.shared.static_root_path.as_deref(),\n+                description: \"List of crates\",\n+                keywords: BASIC_KEYWORDS,\n+                resource_suffix: &cx.shared.resource_suffix,\n+                extra_scripts: &[],\n+                static_extra_scripts: &[],\n+            };\n+\n+            let content = format!(\n+                \"<h1 class=\\\"fqn\\\">\\\n+                     <span class=\\\"in-band\\\">List of all crates</span>\\\n+                </h1><ul class=\\\"crate mod\\\">{}</ul>\",\n+                krates\n+                    .iter()\n+                    .map(|s| {\n+                        format!(\n+                            \"<li><a class=\\\"crate mod\\\" href=\\\"{}index.html\\\">{}</a></li>\",\n+                            ensure_trailing_slash(s),\n+                            s\n+                        )\n+                    })\n+                    .collect::<String>()\n+            );\n+            let v = layout::render(&cx.shared.layout, &page, \"\", content, &cx.shared.style_files);\n+            cx.shared.fs.write(&dst, v.as_bytes())?;\n+        }\n+    }\n+\n+    // Update the list of all implementors for traits\n+    let dst = cx.dst.join(\"implementors\");\n+    for (&did, imps) in &cx.cache.implementors {\n+        // Private modules can leak through to this phase of rustdoc, which\n+        // could contain implementations for otherwise private types. In some\n+        // rare cases we could find an implementation for an item which wasn't\n+        // indexed, so we just skip this step in that case.\n+        //\n+        // FIXME: this is a vague explanation for why this can't be a `get`, in\n+        //        theory it should be...\n+        let &(ref remote_path, remote_item_type) = match cx.cache.paths.get(&did) {\n+            Some(p) => p,\n+            None => match cx.cache.external_paths.get(&did) {\n+                Some(p) => p,\n+                None => continue,\n+            },\n+        };\n+\n+        #[derive(Serialize)]\n+        struct Implementor {\n+            text: String,\n+            synthetic: bool,\n+            types: Vec<String>,\n+        }\n+\n+        let implementors = imps\n+            .iter()\n+            .filter_map(|imp| {\n+                // If the trait and implementation are in the same crate, then\n+                // there's no need to emit information about it (there's inlining\n+                // going on). If they're in different crates then the crate defining\n+                // the trait will be interested in our implementation.\n+                //\n+                // If the implementation is from another crate then that crate\n+                // should add it.\n+                if imp.impl_item.def_id.krate == did.krate || !imp.impl_item.def_id.is_local() {\n+                    None\n+                } else {\n+                    Some(Implementor {\n+                        text: imp.inner_impl().print(cx.cache(), false).to_string(),\n+                        synthetic: imp.inner_impl().synthetic,\n+                        types: collect_paths_for_type(imp.inner_impl().for_.clone(), cx.cache()),\n+                    })\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+\n+        // Only create a js file if we have impls to add to it. If the trait is\n+        // documented locally though we always create the file to avoid dead\n+        // links.\n+        if implementors.is_empty() && !cx.cache.paths.contains_key(&did) {\n+            continue;\n+        }\n+\n+        let implementors = format!(\n+            r#\"implementors[\"{}\"] = {};\"#,\n+            krate.name,\n+            serde_json::to_string(&implementors).unwrap()\n+        );\n+\n+        let mut mydst = dst.clone();\n+        for part in &remote_path[..remote_path.len() - 1] {\n+            mydst.push(part);\n+        }\n+        cx.shared.ensure_dir(&mydst)?;\n+        mydst.push(&format!(\"{}.{}.js\", remote_item_type, remote_path[remote_path.len() - 1]));\n+\n+        let (mut all_implementors, _) =\n+            try_err!(collect(&mydst, &krate.name.as_str(), \"implementors\"), &mydst);\n+        all_implementors.push(implementors);\n+        // Sort the implementors by crate so the file will be generated\n+        // identically even with rustdoc running in parallel.\n+        all_implementors.sort();\n+\n+        let mut v = String::from(\"(function() {var implementors = {};\\n\");\n+        for implementor in &all_implementors {\n+            writeln!(v, \"{}\", *implementor).unwrap();\n+        }\n+        v.push_str(\n+            \"if (window.register_implementors) {\\\n+                 window.register_implementors(implementors);\\\n+             } else {\\\n+                 window.pending_implementors = implementors;\\\n+             }\",\n+        );\n+        v.push_str(\"})()\");\n+        cx.shared.fs.write(&mydst, &v)?;\n+    }\n+    Ok(())\n+}\n+\n+fn write_minify(\n+    fs: &DocFS,\n+    dst: PathBuf,\n+    contents: &str,\n+    enable_minification: bool,\n+) -> Result<(), Error> {\n+    if enable_minification {\n+        if dst.extension() == Some(&OsStr::new(\"css\")) {\n+            let res = try_none!(minifier::css::minify(contents).ok(), &dst);\n+            fs.write(dst, res.as_bytes())\n+        } else {\n+            fs.write(dst, minifier::js::minify(contents).as_bytes())\n+        }\n+    } else {\n+        fs.write(dst, contents.as_bytes())\n+    }\n+}"}]}