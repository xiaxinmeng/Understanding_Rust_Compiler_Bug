{"sha": "dc4dc99649471a06a3fd5dbffabf71eab8ff8f95", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNGRjOTk2NDk0NzFhMDZhM2ZkNWRiZmZhYmY3MWVhYjhmZjhmOTU=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-08-06T03:45:57Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-08-06T03:45:57Z"}, "message": "Change to various generic impls", "tree": {"sha": "6af81006f10da5fa10c26b79bf72b1e41f7647e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6af81006f10da5fa10c26b79bf72b1e41f7647e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc4dc99649471a06a3fd5dbffabf71eab8ff8f95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc4dc99649471a06a3fd5dbffabf71eab8ff8f95", "html_url": "https://github.com/rust-lang/rust/commit/dc4dc99649471a06a3fd5dbffabf71eab8ff8f95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc4dc99649471a06a3fd5dbffabf71eab8ff8f95/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "054f25f2b0212ada7caae70a4470e32f503a3eea", "url": "https://api.github.com/repos/rust-lang/rust/commits/054f25f2b0212ada7caae70a4470e32f503a3eea", "html_url": "https://github.com/rust-lang/rust/commit/054f25f2b0212ada7caae70a4470e32f503a3eea"}], "stats": {"total": 770, "additions": 370, "deletions": 400}, "files": [{"sha": "9ad3a6c100eaf1e5357adb8ae8f2243f85b534a5", "filename": "crates/core_simd/src/fmt.rs", "status": "modified", "additions": 25, "deletions": 77, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/dc4dc99649471a06a3fd5dbffabf71eab8ff8f95/crates%2Fcore_simd%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4dc99649471a06a3fd5dbffabf71eab8ff8f95/crates%2Fcore_simd%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Ffmt.rs?ref=dc4dc99649471a06a3fd5dbffabf71eab8ff8f95", "patch": "@@ -1,88 +1,36 @@\n-macro_rules! debug_wrapper {\n-    { $($trait:ident => $name:ident,)* } => {\n+macro_rules! impl_fmt_trait {\n+    { $($trait:ident,)* } => {\n         $(\n-            pub(crate) fn $name<T: core::fmt::$trait>(slice: &[T], f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                #[repr(transparent)]\n-                struct Wrapper<'a, T: core::fmt::$trait>(&'a T);\n+            impl<Element, const LANES: usize> core::fmt::$trait for crate::Simd<Element, LANES>\n+            where\n+                crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+                Element: crate::SimdElement + core::fmt::$trait,\n+            {\n+                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                    #[repr(transparent)]\n+                    struct Wrapper<'a, T: core::fmt::$trait>(&'a T);\n \n-                impl<T: core::fmt::$trait> core::fmt::Debug for Wrapper<'_, T> {\n-                    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                        self.0.fmt(f)\n+                    impl<T: core::fmt::$trait> core::fmt::Debug for Wrapper<'_, T> {\n+                        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                            self.0.fmt(f)\n+                        }\n                     }\n-                }\n-\n-                f.debug_list()\n-                    .entries(slice.iter().map(|x| Wrapper(x)))\n-                    .finish()\n-            }\n-        )*\n-    }\n-}\n \n-debug_wrapper! {\n-    Debug => format,\n-    Binary => format_binary,\n-    LowerExp => format_lower_exp,\n-    UpperExp => format_upper_exp,\n-    Octal => format_octal,\n-    LowerHex => format_lower_hex,\n-    UpperHex => format_upper_hex,\n-}\n-\n-macro_rules! impl_fmt_trait {\n-    { $($type:ident => $(($trait:ident, $format:ident)),*;)* } => {\n-        $( // repeat type\n-            $( // repeat trait\n-                impl<const LANES: usize> core::fmt::$trait for crate::$type<LANES>\n-                where\n-                    crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-                {\n-                    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                        $format(self.as_ref(), f)\n-                    }\n+                    f.debug_list()\n+                        .entries(self.as_array().iter().map(|x| Wrapper(x)))\n+                        .finish()\n                 }\n-            )*\n+            }\n         )*\n-    };\n-    { integers: $($type:ident,)* } => {\n-        impl_fmt_trait! {\n-            $($type =>\n-              (Debug, format),\n-              (Binary, format_binary),\n-              (LowerExp, format_lower_exp),\n-              (UpperExp, format_upper_exp),\n-              (Octal, format_octal),\n-              (LowerHex, format_lower_hex),\n-              (UpperHex, format_upper_hex);\n-            )*\n-        }\n-    };\n-    { floats: $($type:ident,)* } => {\n-        impl_fmt_trait! {\n-            $($type =>\n-              (Debug, format),\n-              (LowerExp, format_lower_exp),\n-              (UpperExp, format_upper_exp);\n-            )*\n-        }\n-    };\n-    { masks: $($type:ident,)* } => {\n-        impl_fmt_trait! {\n-            $($type =>\n-              (Debug, format);\n-            )*\n-        }\n     }\n }\n \n impl_fmt_trait! {\n-    integers:\n-        SimdU8, SimdU16, SimdU32, SimdU64,\n-        SimdI8, SimdI16, SimdI32, SimdI64,\n-        SimdUsize, SimdIsize,\n-}\n-\n-impl_fmt_trait! {\n-    floats:\n-        SimdF32, SimdF64,\n+    Debug,\n+    Binary,\n+    LowerExp,\n+    UpperExp,\n+    Octal,\n+    LowerHex,\n+    UpperHex,\n }"}, {"sha": "fc0df1813b9467284ed8772e9b5c4a6375f646f8", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc4dc99649471a06a3fd5dbffabf71eab8ff8f95/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4dc99649471a06a3fd5dbffabf71eab8ff8f95/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=dc4dc99649471a06a3fd5dbffabf71eab8ff8f95", "patch": "@@ -2,6 +2,7 @@\n #![allow(incomplete_features)]\n #![feature(\n     const_evaluatable_checked,\n+    const_fn_trait_bound,\n     const_generics,\n     platform_intrinsics,\n     repr_simd,"}, {"sha": "4e377d68915b041e89eeb4e9fb62a4d69ee85512", "filename": "crates/core_simd/src/permute.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dc4dc99649471a06a3fd5dbffabf71eab8ff8f95/crates%2Fcore_simd%2Fsrc%2Fpermute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4dc99649471a06a3fd5dbffabf71eab8ff8f95/crates%2Fcore_simd%2Fsrc%2Fpermute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fpermute.rs?ref=dc4dc99649471a06a3fd5dbffabf71eab8ff8f95", "patch": "@@ -1,6 +1,9 @@\n macro_rules! impl_shuffle_lane {\n-    { $name:ident, $fn:ident, $n:literal } => {\n-        impl $name<$n> {\n+    { $fn:ident, $n:literal } => {\n+        impl<Element> crate::Simd<Element, $n>\n+        where\n+            Element: crate::SimdElement,\n+        {\n             /// A const SIMD shuffle that takes 2 SIMD vectors and produces another vector, using\n             /// the indices in the const parameter. The first or \"self\" vector will have its lanes\n             /// indexed from 0, and the second vector will have its first lane indexed at $n.\n@@ -138,12 +141,8 @@ macro_rules! impl_shuffle_lane {\n     }\n }\n \n-macro_rules! impl_shuffle_2pow_lanes {\n-    { $name:ident } => {\n-        impl_shuffle_lane!{ $name, simd_shuffle2, 2 }\n-        impl_shuffle_lane!{ $name, simd_shuffle4, 4 }\n-        impl_shuffle_lane!{ $name, simd_shuffle8, 8 }\n-        impl_shuffle_lane!{ $name, simd_shuffle16, 16 }\n-        impl_shuffle_lane!{ $name, simd_shuffle32, 32 }\n-    }\n-}\n+impl_shuffle_lane! { simd_shuffle2, 2 }\n+impl_shuffle_lane! { simd_shuffle4, 4 }\n+impl_shuffle_lane! { simd_shuffle8, 8 }\n+impl_shuffle_lane! { simd_shuffle16, 16 }\n+impl_shuffle_lane! { simd_shuffle32, 32 }"}, {"sha": "2e3855bff3cf9ba14ccd30e69f1d20dad18fd517", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 334, "deletions": 4, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/dc4dc99649471a06a3fd5dbffabf71eab8ff8f95/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4dc99649471a06a3fd5dbffabf71eab8ff8f95/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=dc4dc99649471a06a3fd5dbffabf71eab8ff8f95", "patch": "@@ -1,6 +1,3 @@\n-#[macro_use]\n-mod vector_impl;\n-\n mod float;\n mod int;\n mod uint;\n@@ -21,13 +18,325 @@ where\n     Element: SimdElement,\n     LaneCount<LANES>: SupportedLaneCount;\n \n+impl<Element, const LANES: usize> Simd<Element, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    Element: SimdElement,\n+{\n+    /// Construct a SIMD vector by setting all lanes to the given value.\n+    pub const fn splat(value: Element) -> Self {\n+        Self([value; LANES])\n+    }\n+\n+    /// Returns an array reference containing the entire SIMD vector.\n+    pub const fn as_array(&self) -> &[Element; LANES] {\n+        &self.0\n+    }\n+\n+    /// Returns a mutable array reference containing the entire SIMD vector.\n+    pub fn as_mut_array(&mut self) -> &mut [Element; LANES] {\n+        &mut self.0\n+    }\n+\n+    /// Converts an array to a SIMD vector.\n+    pub const fn from_array(array: [Element; LANES]) -> Self {\n+        Self(array)\n+    }\n+\n+    /// Converts a SIMD vector to an array.\n+    pub const fn to_array(self) -> [Element; LANES] {\n+        self.0\n+    }\n+\n+    /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n+    /// If an index is out of bounds, that lane instead selects the value from the \"or\" vector.\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core_simd::*;\n+    /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 5]);\n+    /// let alt = SimdI32::from_array([-5, -4, -3, -2]);\n+    ///\n+    /// let result = SimdI32::<4>::gather_or(&vec, idxs, alt); // Note the lane that is out-of-bounds.\n+    /// assert_eq!(result, SimdI32::from_array([-5, 13, 10, 15]));\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    pub fn gather_or(slice: &[Element], idxs: crate::SimdUsize<LANES>, or: Self) -> Self {\n+        Self::gather_select(slice, crate::MaskSize::splat(true), idxs, or)\n+    }\n+\n+    /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n+    /// Out-of-bounds indices instead use the default value for that lane (0).\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core_simd::*;\n+    /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 5]);\n+    ///\n+    /// let result = SimdI32::<4>::gather_or_default(&vec, idxs); // Note the lane that is out-of-bounds.\n+    /// assert_eq!(result, SimdI32::from_array([0, 13, 10, 15]));\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    pub fn gather_or_default(slice: &[Element], idxs: crate::SimdUsize<LANES>) -> Self\n+    where\n+        Element: Default,\n+    {\n+        Self::gather_or(slice, idxs, Self::splat(Element::default()))\n+    }\n+\n+    /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n+    /// Out-of-bounds or masked indices instead select the value from the \"or\" vector.\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core_simd::*;\n+    /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 5]);\n+    /// let alt = SimdI32::from_array([-5, -4, -3, -2]);\n+    /// let mask = MaskSize::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    ///\n+    /// let result = SimdI32::<4>::gather_select(&vec, mask, idxs, alt); // Note the lane that is out-of-bounds.\n+    /// assert_eq!(result, SimdI32::from_array([-5, 13, 10, -2]));\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    pub fn gather_select(\n+        slice: &[Element],\n+        mask: crate::MaskSize<LANES>,\n+        idxs: crate::SimdUsize<LANES>,\n+        or: Self,\n+    ) -> Self {\n+        let mask = (mask & idxs.lanes_lt(crate::SimdUsize::splat(slice.len()))).to_int();\n+        let base_ptr = crate::vector::ptr::SimdConstPtr::splat(slice.as_ptr());\n+        // Ferris forgive me, I have done pointer arithmetic here.\n+        let ptrs = base_ptr.wrapping_add(idxs);\n+        // SAFETY: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n+        unsafe { crate::intrinsics::simd_gather(or, ptrs, mask) }\n+    }\n+\n+    /// SIMD scatter: write a SIMD vector's values into a slice, using potentially discontiguous indices.\n+    /// Out-of-bounds indices are not written.\n+    /// `scatter` writes \"in order\", so if an index receives two writes, only the last is guaranteed.\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core_simd::*;\n+    /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 0]);\n+    /// let vals = SimdI32::from_array([-27, 82, -41, 124]);\n+    ///\n+    /// vals.scatter(&mut vec, idxs); // index 0 receives two writes.\n+    /// assert_eq!(vec, vec![124, 11, 12, 82, 14, 15, 16, 17, 18]);\n+    /// ```\n+    #[inline]\n+    pub fn scatter(self, slice: &mut [Element], idxs: crate::SimdUsize<LANES>) {\n+        self.scatter_select(slice, crate::MaskSize::splat(true), idxs)\n+    }\n+\n+    /// SIMD scatter: write a SIMD vector's values into a slice, using potentially discontiguous indices.\n+    /// Out-of-bounds or masked indices are not written.\n+    /// `scatter_select` writes \"in order\", so if an index receives two writes, only the last is guaranteed.\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core_simd::*;\n+    /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 0]);\n+    /// let vals = SimdI32::from_array([-27, 82, -41, 124]);\n+    /// let mask = MaskSize::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    ///\n+    /// vals.scatter_select(&mut vec, mask, idxs); // index 0's second write is masked, thus omitted.\n+    /// assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n+    /// ```\n+    #[inline]\n+    pub fn scatter_select(\n+        self,\n+        slice: &mut [Element],\n+        mask: crate::MaskSize<LANES>,\n+        idxs: crate::SimdUsize<LANES>,\n+    ) {\n+        // We must construct our scatter mask before we derive a pointer!\n+        let mask = (mask & idxs.lanes_lt(crate::SimdUsize::splat(slice.len()))).to_int();\n+        // SAFETY: This block works with *mut T derived from &mut 'a [T],\n+        // which means it is delicate in Rust's borrowing model, circa 2021:\n+        // &mut 'a [T] asserts uniqueness, so deriving &'a [T] invalidates live *mut Ts!\n+        // Even though this block is largely safe methods, it must be almost exactly this way\n+        // to prevent invalidating the raw ptrs while they're live.\n+        // Thus, entering this block requires all values to use being already ready:\n+        // 0. idxs we want to write to, which are used to construct the mask.\n+        // 1. mask, which depends on an initial &'a [T] and the idxs.\n+        // 2. actual values to scatter (self).\n+        // 3. &mut [T] which will become our base ptr.\n+        unsafe {\n+            // Now Entering \u2622\ufe0f *mut T Zone\n+            let base_ptr = crate::vector::ptr::SimdMutPtr::splat(slice.as_mut_ptr());\n+            // Ferris forgive me, I have done pointer arithmetic here.\n+            let ptrs = base_ptr.wrapping_add(idxs);\n+            // The ptrs have been bounds-masked to prevent memory-unsafe writes insha'allah\n+            crate::intrinsics::simd_scatter(self, ptrs, mask)\n+            // Cleared \u2622\ufe0f *mut T Zone\n+        }\n+    }\n+}\n+\n+impl<Element, const LANES: usize> Copy for Simd<Element, LANES>\n+where\n+    Element: SimdElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n+\n+impl<Element, const LANES: usize> Clone for Simd<Element, LANES>\n+where\n+    Element: SimdElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+impl<Element, const LANES: usize> Default for Simd<Element, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    Element: SimdElement + Default,\n+{\n+    #[inline]\n+    fn default() -> Self {\n+        Self::splat(Element::default())\n+    }\n+}\n+\n+impl<Element, const LANES: usize> PartialEq for Simd<Element, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    Element: SimdElement + PartialEq,\n+{\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        // TODO use SIMD equality\n+        self.to_array() == other.to_array()\n+    }\n+}\n+\n+impl<Element, const LANES: usize> PartialOrd for Simd<Element, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    Element: SimdElement + PartialOrd,\n+{\n+    #[inline]\n+    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        // TODO use SIMD equality\n+        self.to_array().partial_cmp(other.as_ref())\n+    }\n+}\n+\n+impl<Element, const LANES: usize> Eq for Simd<Element, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    Element: SimdElement + Eq,\n+{\n+}\n+\n+impl<Element, const LANES: usize> Ord for Simd<Element, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    Element: SimdElement + Ord,\n+{\n+    #[inline]\n+    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n+        // TODO use SIMD equality\n+        self.to_array().cmp(other.as_ref())\n+    }\n+}\n+\n+impl<Element, const LANES: usize> core::hash::Hash for Simd<Element, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    Element: SimdElement + core::hash::Hash,\n+{\n+    #[inline]\n+    fn hash<H>(&self, state: &mut H)\n+    where\n+        H: core::hash::Hasher,\n+    {\n+        self.as_array().hash(state)\n+    }\n+}\n+\n+// array references\n+impl<Element, const LANES: usize> AsRef<[Element; LANES]> for Simd<Element, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    Element: SimdElement,\n+{\n+    #[inline]\n+    fn as_ref(&self) -> &[Element; LANES] {\n+        &self.0\n+    }\n+}\n+\n+impl<Element, const LANES: usize> AsMut<[Element; LANES]> for Simd<Element, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    Element: SimdElement,\n+{\n+    #[inline]\n+    fn as_mut(&mut self) -> &mut [Element; LANES] {\n+        &mut self.0\n+    }\n+}\n+\n+// slice references\n+impl<Element, const LANES: usize> AsRef<[Element]> for Simd<Element, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    Element: SimdElement,\n+{\n+    #[inline]\n+    fn as_ref(&self) -> &[Element] {\n+        &self.0\n+    }\n+}\n+\n+impl<Element, const LANES: usize> AsMut<[Element]> for Simd<Element, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    Element: SimdElement,\n+{\n+    #[inline]\n+    fn as_mut(&mut self) -> &mut [Element] {\n+        &mut self.0\n+    }\n+}\n+\n+// vector/array conversion\n+impl<Element, const LANES: usize> From<[Element; LANES]> for Simd<Element, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    Element: SimdElement,\n+{\n+    fn from(array: [Element; LANES]) -> Self {\n+        Self(array)\n+    }\n+}\n+\n+impl<Element, const LANES: usize> From<Simd<Element, LANES>> for [Element; LANES]\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    Element: SimdElement,\n+{\n+    fn from(vector: Simd<Element, LANES>) -> Self {\n+        vector.to_array()\n+    }\n+}\n+\n mod sealed {\n     pub trait Sealed {}\n }\n use sealed::Sealed;\n \n /// Marker trait for types that may be used as SIMD vector elements.\n-pub unsafe trait SimdElement: Sealed {\n+pub unsafe trait SimdElement: Sealed + Copy {\n     /// The mask element type corresponding to this element type.\n     type Mask: SimdElement;\n }\n@@ -106,3 +415,24 @@ pub trait Vector: sealed::Sealed {\n     #[must_use]\n     fn splat(val: Self::Scalar) -> Self;\n }\n+\n+impl<Element, const LANES: usize> Sealed for Simd<Element, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    Element: SimdElement,\n+{\n+}\n+\n+impl<Element, const LANES: usize> Vector for Simd<Element, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    Element: SimdElement,\n+{\n+    type Scalar = Element;\n+    const LANES: usize = LANES;\n+\n+    #[inline]\n+    fn splat(val: Self::Scalar) -> Self {\n+        Self::splat(val)\n+    }\n+}"}, {"sha": "40959d66872c68eb427cdb4c560b7629f49e1748", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc4dc99649471a06a3fd5dbffabf71eab8ff8f95/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4dc99649471a06a3fd5dbffabf71eab8ff8f95/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=dc4dc99649471a06a3fd5dbffabf71eab8ff8f95", "patch": "@@ -7,7 +7,6 @@ use crate::{LaneCount, SupportedLaneCount};\n /// representation. Called from `define_float_vector!`.\n macro_rules! impl_float_vector {\n     { $name:ident, $type:ident, $bits_ty:ident, $mask_ty:ident, $mask_impl_ty:ident } => {\n-        impl_vector! { $name, $type }\n         impl_float_reductions! { $name, $type }\n \n         impl<const LANES: usize> $name<LANES>"}, {"sha": "74c4a0f2fb637a1e18de2d5e9b46aff640034183", "filename": "crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dc4dc99649471a06a3fd5dbffabf71eab8ff8f95/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4dc99649471a06a3fd5dbffabf71eab8ff8f95/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=dc4dc99649471a06a3fd5dbffabf71eab8ff8f95", "patch": "@@ -5,32 +5,8 @@ use crate::{LaneCount, SupportedLaneCount};\n /// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n macro_rules! impl_integer_vector {\n     { $name:ident, $type:ty, $mask_ty:ident, $mask_impl_ty:ident } => {\n-        impl_vector! { $name, $type }\n         impl_integer_reductions! { $name, $type }\n \n-        impl<const LANES: usize> Eq for $name<LANES> where LaneCount<LANES>: SupportedLaneCount {}\n-\n-        impl<const LANES: usize> Ord for $name<LANES> where LaneCount<LANES>: SupportedLaneCount {\n-            #[inline]\n-            fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n-                // TODO use SIMD cmp\n-                self.as_array().cmp(other.as_ref())\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::hash::Hash for $name<LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            #[inline]\n-            fn hash<H>(&self, state: &mut H)\n-            where\n-                H: core::hash::Hasher\n-            {\n-                self.as_array().hash(state)\n-            }\n-        }\n-\n         impl<const LANES: usize> $name<LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,"}, {"sha": "6dfcbe795939f8886df2ac2565df7dba5c4a900b", "filename": "crates/core_simd/src/vector/uint.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dc4dc99649471a06a3fd5dbffabf71eab8ff8f95/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4dc99649471a06a3fd5dbffabf71eab8ff8f95/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs?ref=dc4dc99649471a06a3fd5dbffabf71eab8ff8f95", "patch": "@@ -1,35 +1,9 @@\n #![allow(non_camel_case_types)]\n \n-use crate::{LaneCount, SupportedLaneCount};\n-\n /// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n macro_rules! impl_unsigned_vector {\n     { $name:ident, $type:ty } => {\n-        impl_vector! { $name, $type }\n         impl_integer_reductions! { $name, $type }\n-\n-        impl<const LANES: usize> Eq for $name<LANES> where LaneCount<LANES>: SupportedLaneCount {}\n-\n-        impl<const LANES: usize> Ord for $name<LANES> where LaneCount<LANES>: SupportedLaneCount {\n-            #[inline]\n-            fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n-                // TODO use SIMD cmp\n-                self.as_array().cmp(other.as_ref())\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::hash::Hash for $name<LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            #[inline]\n-            fn hash<H>(&self, state: &mut H)\n-            where\n-                H: core::hash::Hasher\n-            {\n-                self.as_array().hash(state)\n-            }\n-        }\n     }\n }\n "}, {"sha": "58ea244adfcb097637604c53eb72f508ffaf2729", "filename": "crates/core_simd/src/vector/vector_impl.rs", "status": "removed", "additions": 0, "deletions": 257, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/054f25f2b0212ada7caae70a4470e32f503a3eea/crates%2Fcore_simd%2Fsrc%2Fvector%2Fvector_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/054f25f2b0212ada7caae70a4470e32f503a3eea/crates%2Fcore_simd%2Fsrc%2Fvector%2Fvector_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fvector_impl.rs?ref=054f25f2b0212ada7caae70a4470e32f503a3eea", "patch": "@@ -1,257 +0,0 @@\n-/// Implements common traits on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n-macro_rules! impl_vector {\n-    { $name:ident, $type:ty } => {\n-        impl<const LANES: usize> crate::vector::sealed::Sealed for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {}\n-\n-        impl<const LANES: usize> crate::vector::Vector for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            type Scalar = $type;\n-            const LANES: usize = LANES;\n-\n-            #[inline]\n-            fn splat(val: Self::Scalar) -> Self {\n-                Self::splat(val)\n-            }\n-        }\n-\n-        impl<const LANES: usize> $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            /// Construct a SIMD vector by setting all lanes to the given value.\n-            pub const fn splat(value: $type) -> Self {\n-                Self([value; LANES])\n-            }\n-\n-            /// Returns an array reference containing the entire SIMD vector.\n-            pub const fn as_array(&self) -> &[$type; LANES] {\n-                &self.0\n-            }\n-\n-            /// Returns a mutable array reference containing the entire SIMD vector.\n-            pub fn as_mut_array(&mut self) -> &mut [$type; LANES] {\n-                &mut self.0\n-            }\n-\n-            /// Converts an array to a SIMD vector.\n-            pub const fn from_array(array: [$type; LANES]) -> Self {\n-                Self(array)\n-            }\n-\n-            /// Converts a SIMD vector to an array.\n-            pub const fn to_array(self) -> [$type; LANES] {\n-                self.0\n-            }\n-\n-            /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n-            /// If an index is out of bounds, that lane instead selects the value from the \"or\" vector.\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core_simd::*;\n-            /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-            /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 5]);\n-            /// let alt = SimdI32::from_array([-5, -4, -3, -2]);\n-            ///\n-            /// let result = SimdI32::<4>::gather_or(&vec, idxs, alt); // Note the lane that is out-of-bounds.\n-            /// assert_eq!(result, SimdI32::from_array([-5, 13, 10, 15]));\n-            /// ```\n-            #[must_use]\n-            #[inline]\n-            pub fn gather_or(slice: &[$type], idxs: crate::SimdUsize<LANES>, or: Self) -> Self {\n-                Self::gather_select(slice, crate::MaskSize::splat(true), idxs, or)\n-            }\n-\n-            /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n-            /// Out-of-bounds indices instead use the default value for that lane (0).\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core_simd::*;\n-            /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-            /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 5]);\n-            ///\n-            /// let result = SimdI32::<4>::gather_or_default(&vec, idxs); // Note the lane that is out-of-bounds.\n-            /// assert_eq!(result, SimdI32::from_array([0, 13, 10, 15]));\n-            /// ```\n-            #[must_use]\n-            #[inline]\n-            pub fn gather_or_default(slice: &[$type], idxs: crate::SimdUsize<LANES>) -> Self {\n-                Self::gather_or(slice, idxs, Self::splat(<$type>::default()))\n-            }\n-\n-            /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n-            /// Out-of-bounds or masked indices instead select the value from the \"or\" vector.\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core_simd::*;\n-            /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-            /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 5]);\n-            /// let alt = SimdI32::from_array([-5, -4, -3, -2]);\n-            /// let mask = MaskSize::from_array([true, true, true, false]); // Note the mask of the last lane.\n-            ///\n-            /// let result = SimdI32::<4>::gather_select(&vec, mask, idxs, alt); // Note the lane that is out-of-bounds.\n-            /// assert_eq!(result, SimdI32::from_array([-5, 13, 10, -2]));\n-            /// ```\n-            #[must_use]\n-            #[inline]\n-            pub fn gather_select(\n-                slice: &[$type],\n-                mask: crate::MaskSize<LANES>,\n-                idxs: crate::SimdUsize<LANES>,\n-                or: Self,\n-            ) -> Self\n-            {\n-                let mask = (mask & idxs.lanes_lt(crate::SimdUsize::splat(slice.len()))).to_int();\n-                let base_ptr = crate::vector::ptr::SimdConstPtr::splat(slice.as_ptr());\n-                // Ferris forgive me, I have done pointer arithmetic here.\n-                let ptrs = base_ptr.wrapping_add(idxs);\n-                // SAFETY: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n-                unsafe { crate::intrinsics::simd_gather(or, ptrs, mask) }\n-            }\n-\n-            /// SIMD scatter: write a SIMD vector's values into a slice, using potentially discontiguous indices.\n-            /// Out-of-bounds indices are not written.\n-            /// `scatter` writes \"in order\", so if an index receives two writes, only the last is guaranteed.\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core_simd::*;\n-            /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-            /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 0]);\n-            /// let vals = SimdI32::from_array([-27, 82, -41, 124]);\n-            ///\n-            /// vals.scatter(&mut vec, idxs); // index 0 receives two writes.\n-            /// assert_eq!(vec, vec![124, 11, 12, 82, 14, 15, 16, 17, 18]);\n-            /// ```\n-            #[inline]\n-            pub fn scatter(self, slice: &mut [$type], idxs: crate::SimdUsize<LANES>) {\n-                self.scatter_select(slice, crate::MaskSize::splat(true), idxs)\n-            }\n-\n-            /// SIMD scatter: write a SIMD vector's values into a slice, using potentially discontiguous indices.\n-            /// Out-of-bounds or masked indices are not written.\n-            /// `scatter_select` writes \"in order\", so if an index receives two writes, only the last is guaranteed.\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core_simd::*;\n-            /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-            /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 0]);\n-            /// let vals = SimdI32::from_array([-27, 82, -41, 124]);\n-            /// let mask = MaskSize::from_array([true, true, true, false]); // Note the mask of the last lane.\n-            ///\n-            /// vals.scatter_select(&mut vec, mask, idxs); // index 0's second write is masked, thus omitted.\n-            /// assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n-            /// ```\n-            #[inline]\n-            pub fn scatter_select(\n-                self,\n-                slice: &mut [$type],\n-                mask: crate::MaskSize<LANES>,\n-                idxs: crate::SimdUsize<LANES>,\n-            )\n-            {\n-                // We must construct our scatter mask before we derive a pointer!\n-                let mask = (mask & idxs.lanes_lt(crate::SimdUsize::splat(slice.len()))).to_int();\n-                // SAFETY: This block works with *mut T derived from &mut 'a [T],\n-                // which means it is delicate in Rust's borrowing model, circa 2021:\n-                // &mut 'a [T] asserts uniqueness, so deriving &'a [T] invalidates live *mut Ts!\n-                // Even though this block is largely safe methods, it must be almost exactly this way\n-                // to prevent invalidating the raw ptrs while they're live.\n-                // Thus, entering this block requires all values to use being already ready:\n-                // 0. idxs we want to write to, which are used to construct the mask.\n-                // 1. mask, which depends on an initial &'a [T] and the idxs.\n-                // 2. actual values to scatter (self).\n-                // 3. &mut [T] which will become our base ptr.\n-                unsafe {\n-                    // Now Entering \u2622\ufe0f *mut T Zone\n-                    let base_ptr = crate::vector::ptr::SimdMutPtr::splat(slice.as_mut_ptr());\n-                    // Ferris forgive me, I have done pointer arithmetic here.\n-                    let ptrs = base_ptr.wrapping_add(idxs);\n-                    // The ptrs have been bounds-masked to prevent memory-unsafe writes insha'allah\n-                    crate::intrinsics::simd_scatter(self, ptrs, mask)\n-                    // Cleared \u2622\ufe0f *mut T Zone\n-                }\n-            }\n-        }\n-\n-        impl<const LANES: usize> Copy for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {}\n-\n-        impl<const LANES: usize> Clone for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            #[inline]\n-            fn clone(&self) -> Self {\n-                *self\n-            }\n-        }\n-\n-        impl<const LANES: usize> Default for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            #[inline]\n-            fn default() -> Self {\n-                Self::splat(<$type>::default())\n-            }\n-        }\n-\n-        impl<const LANES: usize> PartialEq for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            #[inline]\n-            fn eq(&self, other: &Self) -> bool {\n-                // TODO use SIMD equality\n-                self.to_array() == other.to_array()\n-            }\n-        }\n-\n-        impl<const LANES: usize> PartialOrd for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            #[inline]\n-            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n-                // TODO use SIMD equalitya\n-                self.to_array().partial_cmp(other.as_ref())\n-            }\n-        }\n-\n-        // array references\n-        impl<const LANES: usize> AsRef<[$type; LANES]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            #[inline]\n-            fn as_ref(&self) -> &[$type; LANES] {\n-                &self.0\n-            }\n-        }\n-\n-        impl<const LANES: usize> AsMut<[$type; LANES]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            #[inline]\n-            fn as_mut(&mut self) -> &mut [$type; LANES] {\n-                &mut self.0\n-            }\n-        }\n-\n-        // slice references\n-        impl<const LANES: usize> AsRef<[$type]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            #[inline]\n-            fn as_ref(&self) -> &[$type] {\n-                &self.0\n-            }\n-        }\n-\n-        impl<const LANES: usize> AsMut<[$type]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            #[inline]\n-            fn as_mut(&mut self) -> &mut [$type] {\n-                &mut self.0\n-            }\n-        }\n-\n-        // vector/array conversion\n-        impl<const LANES: usize> From<[$type; LANES]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            fn from(array: [$type; LANES]) -> Self {\n-                Self(array)\n-            }\n-        }\n-\n-        impl <const LANES: usize> From<$name<LANES>> for [$type; LANES] where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            fn from(vector: $name<LANES>) -> Self {\n-                vector.to_array()\n-            }\n-        }\n-\n-        impl_shuffle_2pow_lanes!{ $name }\n-    }\n-}"}]}