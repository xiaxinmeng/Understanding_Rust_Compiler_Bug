{"sha": "2fdbf075cf502431ca9fee6616331b32e34f25de", "node_id": "C_kwDOAAsO6NoAKDJmZGJmMDc1Y2Y1MDI0MzFjYTlmZWU2NjE2MzMxYjMyZTM0ZjI1ZGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-25T10:33:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-25T10:33:32Z"}, "message": "Auto merge of #99707 - JohnTitor:rollup-74rb8vq, r=JohnTitor\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #95040 (protect `std::io::Take::limit` from overflow in `read`)\n - #95916 (kmc-solid: Use `libc::abort` to abort a program)\n - #99494 (Use non-relocatable code in nofile-limit.rs test)\n - #99581 (Improve error messages involving `derive` and `packed`.)\n - #99643 (Add `sign-ext` target feature to the WASM target)\n - #99659 (Use `VecMap::get` in `ConstraintLocator::check`)\n - #99690 (add miri-track-caller to more intrinsic-exposing methods)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "add0764cba6c9fc11092ab9199a1a8cc4e3af598", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/add0764cba6c9fc11092ab9199a1a8cc4e3af598"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fdbf075cf502431ca9fee6616331b32e34f25de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fdbf075cf502431ca9fee6616331b32e34f25de", "html_url": "https://github.com/rust-lang/rust/commit/2fdbf075cf502431ca9fee6616331b32e34f25de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fdbf075cf502431ca9fee6616331b32e34f25de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f320a224e827b400be25966755a621779f797cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f320a224e827b400be25966755a621779f797cc", "html_url": "https://github.com/rust-lang/rust/commit/2f320a224e827b400be25966755a621779f797cc"}, {"sha": "d1e4342d118e2c9a6a3336970f1af76be0ad0920", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1e4342d118e2c9a6a3336970f1af76be0ad0920", "html_url": "https://github.com/rust-lang/rust/commit/d1e4342d118e2c9a6a3336970f1af76be0ad0920"}], "stats": {"total": 251, "additions": 140, "deletions": 111}, "files": [{"sha": "ecad0518533ec7ef0511b2da25e23d21dc2a7a75", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -249,6 +249,7 @@ const WASM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"bulk-memory\", Some(sym::wasm_target_feature)),\n     (\"mutable-globals\", Some(sym::wasm_target_feature)),\n     (\"reference-types\", Some(sym::wasm_target_feature)),\n+    (\"sign-ext\", Some(sym::wasm_target_feature)),\n ];\n \n const BPF_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[(\"alu32\", Some(sym::bpf_target_feature))];"}, {"sha": "c21c1efe99112609418f4111f5c08c863af97ad8", "filename": "compiler/rustc_mir_transform/src/check_packed_ref.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -36,13 +36,16 @@ fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     tcx.struct_span_lint_hir(UNALIGNED_REFERENCES, lint_hir_id, tcx.def_span(def_id), |lint| {\n         // FIXME: when we make this a hard error, this should have its\n         // own error code.\n-        let message = if tcx.generics_of(def_id).own_requires_monomorphization() {\n-            \"`#[derive]` can't be used on a `#[repr(packed)]` struct with \\\n-             type or const parameters (error E0133)\"\n+        let extra = if tcx.generics_of(def_id).own_requires_monomorphization() {\n+            \"with type or const parameters\"\n         } else {\n-            \"`#[derive]` can't be used on a `#[repr(packed)]` struct that \\\n-             does not derive Copy (error E0133)\"\n+            \"that does not derive `Copy`\"\n         };\n+        let message = format!(\n+            \"`{}` can't be derived on this `#[repr(packed)]` struct {} (error E0133)\",\n+            tcx.item_name(tcx.trait_id_of_impl(def_id.to_def_id()).expect(\"derived trait name\")),\n+            extra\n+        );\n         lint.build(message).emit();\n     });\n }"}, {"sha": "1d7406e00ad0a63ff9e6dadb2b49561932873609", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -538,9 +538,9 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n \n     impl ConstraintLocator<'_> {\n         #[instrument(skip(self), level = \"debug\")]\n-        fn check(&mut self, def_id: LocalDefId) {\n+        fn check(&mut self, item_def_id: LocalDefId) {\n             // Don't try to check items that cannot possibly constrain the type.\n-            if !self.tcx.has_typeck_results(def_id) {\n+            if !self.tcx.has_typeck_results(item_def_id) {\n                 debug!(\"no constraint: no typeck results\");\n                 return;\n             }\n@@ -555,26 +555,20 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n             // // because we again need to reveal `Foo` so we can check whether the\n             // // constant does not contain interior mutability.\n             // ```\n-            let tables = self.tcx.typeck(def_id);\n+            let tables = self.tcx.typeck(item_def_id);\n             if let Some(_) = tables.tainted_by_errors {\n                 self.found = Some(ty::OpaqueHiddenType { span: DUMMY_SP, ty: self.tcx.ty_error() });\n                 return;\n             }\n-            if tables.concrete_opaque_types.get(&self.def_id).is_none() {\n+            if !tables.concrete_opaque_types.contains_key(&self.def_id) {\n                 debug!(\"no constraints in typeck results\");\n                 return;\n             }\n             // Use borrowck to get the type with unerased regions.\n-            let concrete_opaque_types = &self.tcx.mir_borrowck(def_id).concrete_opaque_types;\n+            let concrete_opaque_types = &self.tcx.mir_borrowck(item_def_id).concrete_opaque_types;\n             debug!(?concrete_opaque_types);\n-            for &(def_id, concrete_type) in concrete_opaque_types {\n-                if def_id != self.def_id {\n-                    // Ignore constraints for other opaque types.\n-                    continue;\n-                }\n-\n+            if let Some(&concrete_type) = concrete_opaque_types.get(&self.def_id) {\n                 debug!(?concrete_type, \"found constraint\");\n-\n                 if let Some(prev) = self.found {\n                     if concrete_type.ty != prev.ty && !(concrete_type, prev).references_error() {\n                         prev.report_mismatch(&concrete_type, self.tcx);"}, {"sha": "81b6d5737ea753d9dd867e3a97f37fba3a22b5c9", "filename": "library/core/src/hint.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fcore%2Fsrc%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fcore%2Fsrc%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhint.rs?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -96,6 +96,7 @@ use crate::intrinsics;\n #[inline]\n #[stable(feature = \"unreachable\", since = \"1.27.0\")]\n #[rustc_const_stable(feature = \"const_unreachable_unchecked\", since = \"1.57.0\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub const unsafe fn unreachable_unchecked() -> ! {\n     // SAFETY: the safety contract for `intrinsics::unreachable` must\n     // be upheld by the caller."}, {"sha": "4a595902282db4e01e12c51a5d60a64df25c2bcc", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -2449,6 +2449,7 @@ pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -\n #[cfg_attr(not(bootstrap), rustc_allowed_through_unstable_modules)]\n #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n #[inline]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n     extern \"rust-intrinsic\" {\n         #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n@@ -2535,6 +2536,7 @@ pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: us\n #[cfg_attr(not(bootstrap), rustc_allowed_through_unstable_modules)]\n #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n #[inline]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n     extern \"rust-intrinsic\" {\n         #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]"}, {"sha": "6dc8563c421fc99ecac9bbb4e657af3af045a074", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -1124,6 +1124,7 @@ impl<T> fmt::Debug for Discriminant<T> {\n #[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"mem_discriminant\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub const fn discriminant<T>(v: &T) -> Discriminant<T> {\n     Discriminant(intrinsics::discriminant_value(v))\n }"}, {"sha": "a66de19bad0edb636f8f2f649cd607203c2a8c64", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -449,6 +449,7 @@ macro_rules! int_impl {\n                       without modifying the original\"]\n         #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n+        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n         pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_add`.\n@@ -517,6 +518,7 @@ macro_rules! int_impl {\n                       without modifying the original\"]\n         #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n+        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n         pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_sub`.\n@@ -585,6 +587,7 @@ macro_rules! int_impl {\n                       without modifying the original\"]\n         #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n+        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n         pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_mul`.\n@@ -757,6 +760,7 @@ macro_rules! int_impl {\n                       without modifying the original\"]\n         #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n+        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n         pub const unsafe fn unchecked_shl(self, rhs: Self) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_shl`.\n@@ -803,6 +807,7 @@ macro_rules! int_impl {\n                       without modifying the original\"]\n         #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n+        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n         pub const unsafe fn unchecked_shr(self, rhs: Self) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_shr`."}, {"sha": "73365544233eb40815a87bea16d6abf8f8fe4360", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -459,6 +459,7 @@ macro_rules! uint_impl {\n                       without modifying the original\"]\n         #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n+        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n         pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_add`.\n@@ -528,6 +529,7 @@ macro_rules! uint_impl {\n                       without modifying the original\"]\n         #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n+        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n         pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_sub`.\n@@ -574,6 +576,7 @@ macro_rules! uint_impl {\n                       without modifying the original\"]\n         #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n+        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n         pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_mul`.\n@@ -933,6 +936,7 @@ macro_rules! uint_impl {\n                       without modifying the original\"]\n         #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n+        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n         pub const unsafe fn unchecked_shl(self, rhs: Self) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_shl`.\n@@ -979,6 +983,7 @@ macro_rules! uint_impl {\n                       without modifying the original\"]\n         #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n+        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n         pub const unsafe fn unchecked_shr(self, rhs: Self) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_shr`."}, {"sha": "e289a8e6bd5f9dd83c3d25fe8dd684a94da02e8e", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -449,6 +449,7 @@ impl<T: ?Sized> *const T {\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n     #[inline(always)]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn offset(self, count: isize) -> *const T\n     where\n         T: Sized,\n@@ -471,6 +472,7 @@ impl<T: ?Sized> *const T {\n     #[inline(always)]\n     #[unstable(feature = \"pointer_byte_offsets\", issue = \"96283\")]\n     #[rustc_const_unstable(feature = \"const_pointer_byte_offsets\", issue = \"96283\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn byte_offset(self, count: isize) -> Self {\n         // SAFETY: the caller must uphold the safety contract for `offset`.\n         let this = unsafe { self.cast::<u8>().offset(count).cast::<()>() };\n@@ -641,6 +643,7 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"ptr_offset_from\", since = \"1.47.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"92980\")]\n     #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn offset_from(self, origin: *const T) -> isize\n     where\n         T: Sized,\n@@ -663,6 +666,7 @@ impl<T: ?Sized> *const T {\n     #[inline(always)]\n     #[unstable(feature = \"pointer_byte_offsets\", issue = \"96283\")]\n     #[rustc_const_unstable(feature = \"const_pointer_byte_offsets\", issue = \"96283\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn byte_offset_from(self, origin: *const T) -> isize {\n         // SAFETY: the caller must uphold the safety contract for `offset_from`.\n         unsafe { self.cast::<u8>().offset_from(origin.cast::<u8>()) }\n@@ -731,6 +735,7 @@ impl<T: ?Sized> *const T {\n     #[unstable(feature = \"ptr_sub_ptr\", issue = \"95892\")]\n     #[rustc_const_unstable(feature = \"const_ptr_sub_ptr\", issue = \"95892\")]\n     #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn sub_ptr(self, origin: *const T) -> usize\n     where\n         T: Sized,\n@@ -862,6 +867,7 @@ impl<T: ?Sized> *const T {\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n     #[inline(always)]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn add(self, count: usize) -> Self\n     where\n         T: Sized,\n@@ -884,6 +890,7 @@ impl<T: ?Sized> *const T {\n     #[inline(always)]\n     #[unstable(feature = \"pointer_byte_offsets\", issue = \"96283\")]\n     #[rustc_const_unstable(feature = \"const_pointer_byte_offsets\", issue = \"96283\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn byte_add(self, count: usize) -> Self {\n         // SAFETY: the caller must uphold the safety contract for `add`.\n         let this = unsafe { self.cast::<u8>().add(count).cast::<()>() };\n@@ -946,6 +953,7 @@ impl<T: ?Sized> *const T {\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n     #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn sub(self, count: usize) -> Self\n     where\n         T: Sized,\n@@ -969,6 +977,7 @@ impl<T: ?Sized> *const T {\n     #[inline(always)]\n     #[unstable(feature = \"pointer_byte_offsets\", issue = \"96283\")]\n     #[rustc_const_unstable(feature = \"const_pointer_byte_offsets\", issue = \"96283\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn byte_sub(self, count: usize) -> Self {\n         // SAFETY: the caller must uphold the safety contract for `sub`.\n         let this = unsafe { self.cast::<u8>().sub(count).cast::<()>() };\n@@ -1205,6 +1214,7 @@ impl<T: ?Sized> *const T {\n     #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn copy_to(self, dest: *mut T, count: usize)\n     where\n         T: Sized,\n@@ -1224,6 +1234,7 @@ impl<T: ?Sized> *const T {\n     #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n     where\n         T: Sized,"}, {"sha": "fc3dd2a9b25a9efd646ec0143265b028e702321c", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -461,6 +461,7 @@ impl<T: ?Sized> *mut T {\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n     #[inline(always)]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn offset(self, count: isize) -> *mut T\n     where\n         T: Sized,\n@@ -485,6 +486,7 @@ impl<T: ?Sized> *mut T {\n     #[inline(always)]\n     #[unstable(feature = \"pointer_byte_offsets\", issue = \"96283\")]\n     #[rustc_const_unstable(feature = \"const_pointer_byte_offsets\", issue = \"96283\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn byte_offset(self, count: isize) -> Self {\n         // SAFETY: the caller must uphold the safety contract for `offset`.\n         let this = unsafe { self.cast::<u8>().offset(count).cast::<()>() };\n@@ -824,6 +826,7 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"ptr_offset_from\", since = \"1.47.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"92980\")]\n     #[inline(always)]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn offset_from(self, origin: *const T) -> isize\n     where\n         T: Sized,\n@@ -844,6 +847,7 @@ impl<T: ?Sized> *mut T {\n     #[inline(always)]\n     #[unstable(feature = \"pointer_byte_offsets\", issue = \"96283\")]\n     #[rustc_const_unstable(feature = \"const_pointer_byte_offsets\", issue = \"96283\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn byte_offset_from(self, origin: *const T) -> isize {\n         // SAFETY: the caller must uphold the safety contract for `offset_from`.\n         unsafe { self.cast::<u8>().offset_from(origin.cast::<u8>()) }\n@@ -913,6 +917,7 @@ impl<T: ?Sized> *mut T {\n     #[unstable(feature = \"ptr_sub_ptr\", issue = \"95892\")]\n     #[rustc_const_unstable(feature = \"const_ptr_sub_ptr\", issue = \"95892\")]\n     #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn sub_ptr(self, origin: *const T) -> usize\n     where\n         T: Sized,\n@@ -976,6 +981,7 @@ impl<T: ?Sized> *mut T {\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n     #[inline(always)]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn add(self, count: usize) -> Self\n     where\n         T: Sized,\n@@ -998,6 +1004,7 @@ impl<T: ?Sized> *mut T {\n     #[inline(always)]\n     #[unstable(feature = \"pointer_byte_offsets\", issue = \"96283\")]\n     #[rustc_const_unstable(feature = \"const_pointer_byte_offsets\", issue = \"96283\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn byte_add(self, count: usize) -> Self {\n         // SAFETY: the caller must uphold the safety contract for `add`.\n         let this = unsafe { self.cast::<u8>().add(count).cast::<()>() };\n@@ -1060,6 +1067,7 @@ impl<T: ?Sized> *mut T {\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n     #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn sub(self, count: usize) -> Self\n     where\n         T: Sized,\n@@ -1083,6 +1091,7 @@ impl<T: ?Sized> *mut T {\n     #[inline(always)]\n     #[unstable(feature = \"pointer_byte_offsets\", issue = \"96283\")]\n     #[rustc_const_unstable(feature = \"const_pointer_byte_offsets\", issue = \"96283\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn byte_sub(self, count: usize) -> Self {\n         // SAFETY: the caller must uphold the safety contract for `sub`.\n         let this = unsafe { self.cast::<u8>().sub(count).cast::<()>() };\n@@ -1319,6 +1328,7 @@ impl<T: ?Sized> *mut T {\n     #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline(always)]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn copy_to(self, dest: *mut T, count: usize)\n     where\n         T: Sized,\n@@ -1338,6 +1348,7 @@ impl<T: ?Sized> *mut T {\n     #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline(always)]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n     where\n         T: Sized,\n@@ -1357,6 +1368,7 @@ impl<T: ?Sized> *mut T {\n     #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline(always)]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn copy_from(self, src: *const T, count: usize)\n     where\n         T: Sized,\n@@ -1376,6 +1388,7 @@ impl<T: ?Sized> *mut T {\n     #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline(always)]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn copy_from_nonoverlapping(self, src: *const T, count: usize)\n     where\n         T: Sized,"}, {"sha": "8801c670bc9795cf4179fa67d9178b26cafe315a", "filename": "library/panic_abort/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fpanic_abort%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fpanic_abort%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_abort%2Fsrc%2Flib.rs?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -37,12 +37,11 @@ pub unsafe fn __rust_start_panic(_payload: *mut &mut dyn BoxMeUp) -> u32 {\n     abort();\n \n     cfg_if::cfg_if! {\n-        if #[cfg(unix)] {\n+        if #[cfg(any(unix, target_os = \"solid_asp3\"))] {\n             unsafe fn abort() -> ! {\n                 libc::abort();\n             }\n         } else if #[cfg(any(target_os = \"hermit\",\n-                            target_os = \"solid_asp3\",\n                             all(target_vendor = \"fortanix\", target_env = \"sgx\")\n         ))] {\n             unsafe fn abort() -> ! {"}, {"sha": "18f7f6a35e98f8ba31d3ef807d04b92dc1480dec", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -2577,6 +2577,7 @@ impl<T: Read> Read for Take<T> {\n \n         let max = cmp::min(buf.len() as u64, self.limit) as usize;\n         let n = self.inner.read(&mut buf[..max])?;\n+        assert!(n as u64 <= self.limit, \"number of read bytes exceeds limit\");\n         self.limit -= n as u64;\n         Ok(n)\n     }"}, {"sha": "f357f33ec52c54b771d2e89ec45df7633a3c353c", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -583,6 +583,25 @@ fn test_write_all_vectored() {\n     }\n }\n \n+// Issue 94981\n+#[test]\n+#[should_panic = \"number of read bytes exceeds limit\"]\n+fn test_take_wrong_length() {\n+    struct LieAboutSize(bool);\n+\n+    impl Read for LieAboutSize {\n+        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+            // Lie about the read size at first time of read.\n+            if core::mem::take(&mut self.0) { Ok(buf.len() + 1) } else { Ok(buf.len()) }\n+        }\n+    }\n+\n+    let mut buffer = vec![0; 4];\n+    let mut reader = LieAboutSize(true).take(4);\n+    // Primed the `Limit` by lying about the read size.\n+    let _ = reader.read(&mut buffer[..]);\n+}\n+\n #[bench]\n fn bench_take_read(b: &mut test::Bencher) {\n     b.iter(|| {"}, {"sha": "8440d572cfbd3fe5d0e3eb3fd9325aa1d872c7c4", "filename": "library/std/src/sys/solid/abi/mod.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fabi%2Fmod.rs?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -4,32 +4,6 @@ mod fs;\n pub mod sockets;\n pub use self::fs::*;\n \n-#[inline(always)]\n-pub fn breakpoint_program_exited(tid: usize) {\n-    unsafe {\n-        match () {\n-            // SOLID_BP_PROGRAM_EXITED = 15\n-            #[cfg(target_arch = \"arm\")]\n-            () => core::arch::asm!(\"bkpt #15\", in(\"r0\") tid),\n-            #[cfg(target_arch = \"aarch64\")]\n-            () => core::arch::asm!(\"hlt #15\", in(\"x0\") tid),\n-        }\n-    }\n-}\n-\n-#[inline(always)]\n-pub fn breakpoint_abort() {\n-    unsafe {\n-        match () {\n-            // SOLID_BP_CSABORT = 16\n-            #[cfg(target_arch = \"arm\")]\n-            () => core::arch::asm!(\"bkpt #16\"),\n-            #[cfg(target_arch = \"aarch64\")]\n-            () => core::arch::asm!(\"hlt #16\"),\n-        }\n-    }\n-}\n-\n // `solid_types.h`\n pub use super::itron::abi::{ER, ER_ID, E_TMOUT, ID};\n "}, {"sha": "778a589d1b724434f38d6f90eb51c370039f6027", "filename": "library/std/src/sys/solid/mod.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -76,20 +76,9 @@ pub fn decode_error_kind(code: i32) -> crate::io::ErrorKind {\n     error::decode_error_kind(code)\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn abort_internal() -> ! {\n-    loop {\n-        abi::breakpoint_abort();\n-    }\n-}\n-\n-// This function is needed by the panic runtime. The symbol is named in\n-// pre-link args for the target specification, so keep that in sync.\n-#[cfg(not(test))]\n-#[no_mangle]\n-// NB. used by both libunwind and libpanic_abort\n-pub extern \"C\" fn __rust_abort() {\n-    abort_internal();\n+    unsafe { libc::abort() }\n }\n \n pub fn hashmap_random_keys() -> (u64, u64) {"}, {"sha": "b5649d6e0ffb0cb24c1606a78dd752374d4d47a3", "filename": "library/std/src/sys/solid/os.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -11,7 +11,7 @@ use crate::path::{self, PathBuf};\n use crate::sys_common::rwlock::StaticRwLock;\n use crate::vec;\n \n-use super::{abi, error, itron, memchr};\n+use super::{error, itron, memchr};\n \n // `solid` directly maps `errno`s to \u03bcITRON error codes.\n impl itron::error::ItronError {\n@@ -184,11 +184,8 @@ pub fn home_dir() -> Option<PathBuf> {\n     None\n }\n \n-pub fn exit(_code: i32) -> ! {\n-    let tid = itron::task::try_current_task_id().unwrap_or(0);\n-    loop {\n-        abi::breakpoint_program_exited(tid as usize);\n-    }\n+pub fn exit(code: i32) -> ! {\n+    rtabort!(\"exit({}) called\", code);\n }\n \n pub fn getpid() -> u32 {"}, {"sha": "3884e397764e75e504bd1f87c9ddc77746cd0f78", "filename": "src/test/ui/derives/deriving-with-repr-packed.rs", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.rs?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -1,29 +1,43 @@\n #![deny(unaligned_references)]\n \n-// check that derive on a packed struct with non-Copy fields\n-// correctly. This can't be made to work perfectly because\n-// we can't just use the field from the struct as it might\n-// not be aligned.\n+// Check that deriving certain builtin traits on certain packed structs cause\n+// errors. This happens when the derived trait would need to use a potentially\n+// misaligned reference. But there are two cases that are allowed:\n+// - If all the fields within the struct meet the required alignment: 1 for\n+//   `repr(packed)`, or `N` for `repr(packed(N))`.\n+// - If `Default` is the only trait derived, because it doesn't involve any\n+//   references.\n \n-#[derive(Copy, Clone, PartialEq, Eq)]\n-//~^ ERROR `#[derive]` can't be used\n+#[derive(Copy, Clone, Default, PartialEq, Eq)]\n+//~^ ERROR `Clone` can't be derived on this `#[repr(packed)]` struct with type or const parameters\n //~| hard error\n-//~^^^ ERROR `#[derive]` can't be used\n+//~^^^ ERROR `PartialEq` can't be derived on this `#[repr(packed)]` struct with type or const parameters\n //~| hard error\n #[repr(packed)]\n pub struct Foo<T>(T, T, T);\n \n-#[derive(PartialEq, Eq)]\n-//~^ ERROR `#[derive]` can't be used\n+#[derive(Default, Hash)]\n+//~^ ERROR `Hash` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy`\n //~| hard error\n #[repr(packed)]\n pub struct Bar(u32, u32, u32);\n \n-#[derive(PartialEq)]\n+// This one is fine because the field alignment is 1.\n+#[derive(Default, Hash)]\n+#[repr(packed)]\n+pub struct Bar2(u8, i8, bool);\n+\n+// This one is fine because the field alignment is 2, matching `packed(2)`.\n+#[derive(Default, Hash)]\n+#[repr(packed(2))]\n+pub struct Bar3(u16, i16, bool);\n+\n+// This one is fine because it's not packed.\n+#[derive(Debug, Default)]\n struct Y(usize);\n \n-#[derive(PartialEq)]\n-//~^ ERROR `#[derive]` can't be used\n+#[derive(Debug, Default)]\n+//~^ ERROR `Debug` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy`\n //~| hard error\n #[repr(packed)]\n struct X(Y);"}, {"sha": "1f98da5b70e9fe70f40651fa25515bc5d0d0bcca", "filename": "src/test/ui/derives/deriving-with-repr-packed.stderr", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -1,7 +1,7 @@\n-error: `#[derive]` can't be used on a `#[repr(packed)]` struct with type or const parameters (error E0133)\n-  --> $DIR/deriving-with-repr-packed.rs:8:16\n+error: `Clone` can't be derived on this `#[repr(packed)]` struct with type or const parameters (error E0133)\n+  --> $DIR/deriving-with-repr-packed.rs:11:16\n    |\n-LL | #[derive(Copy, Clone, PartialEq, Eq)]\n+LL | #[derive(Copy, Clone, Default, PartialEq, Eq)]\n    |                ^^^^^\n    |\n note: the lint level is defined here\n@@ -13,43 +13,43 @@ LL | #![deny(unaligned_references)]\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: `#[derive]` can't be used on a `#[repr(packed)]` struct with type or const parameters (error E0133)\n-  --> $DIR/deriving-with-repr-packed.rs:8:23\n+error: `PartialEq` can't be derived on this `#[repr(packed)]` struct with type or const parameters (error E0133)\n+  --> $DIR/deriving-with-repr-packed.rs:11:32\n    |\n-LL | #[derive(Copy, Clone, PartialEq, Eq)]\n-   |                       ^^^^^^^^^\n+LL | #[derive(Copy, Clone, Default, PartialEq, Eq)]\n+   |                                ^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: `#[derive]` can't be used on a `#[repr(packed)]` struct that does not derive Copy (error E0133)\n-  --> $DIR/deriving-with-repr-packed.rs:16:10\n+error: `Hash` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy` (error E0133)\n+  --> $DIR/deriving-with-repr-packed.rs:19:19\n    |\n-LL | #[derive(PartialEq, Eq)]\n-   |          ^^^^^^^^^\n+LL | #[derive(Default, Hash)]\n+   |                   ^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n-   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: this error originates in the derive macro `Hash` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: `#[derive]` can't be used on a `#[repr(packed)]` struct that does not derive Copy (error E0133)\n-  --> $DIR/deriving-with-repr-packed.rs:25:10\n+error: `Debug` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy` (error E0133)\n+  --> $DIR/deriving-with-repr-packed.rs:39:10\n    |\n-LL | #[derive(PartialEq)]\n-   |          ^^^^^^^^^\n+LL | #[derive(Debug, Default)]\n+   |          ^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n-   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 4 previous errors\n \n Future incompatibility report: Future breakage diagnostic:\n-error: `#[derive]` can't be used on a `#[repr(packed)]` struct with type or const parameters (error E0133)\n-  --> $DIR/deriving-with-repr-packed.rs:8:16\n+error: `Clone` can't be derived on this `#[repr(packed)]` struct with type or const parameters (error E0133)\n+  --> $DIR/deriving-with-repr-packed.rs:11:16\n    |\n-LL | #[derive(Copy, Clone, PartialEq, Eq)]\n+LL | #[derive(Copy, Clone, Default, PartialEq, Eq)]\n    |                ^^^^^\n    |\n note: the lint level is defined here\n@@ -62,11 +62,11 @@ LL | #![deny(unaligned_references)]\n    = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n Future breakage diagnostic:\n-error: `#[derive]` can't be used on a `#[repr(packed)]` struct with type or const parameters (error E0133)\n-  --> $DIR/deriving-with-repr-packed.rs:8:23\n+error: `PartialEq` can't be derived on this `#[repr(packed)]` struct with type or const parameters (error E0133)\n+  --> $DIR/deriving-with-repr-packed.rs:11:32\n    |\n-LL | #[derive(Copy, Clone, PartialEq, Eq)]\n-   |                       ^^^^^^^^^\n+LL | #[derive(Copy, Clone, Default, PartialEq, Eq)]\n+   |                                ^^^^^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/deriving-with-repr-packed.rs:1:9\n@@ -78,11 +78,11 @@ LL | #![deny(unaligned_references)]\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n Future breakage diagnostic:\n-error: `#[derive]` can't be used on a `#[repr(packed)]` struct that does not derive Copy (error E0133)\n-  --> $DIR/deriving-with-repr-packed.rs:16:10\n+error: `Hash` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy` (error E0133)\n+  --> $DIR/deriving-with-repr-packed.rs:19:19\n    |\n-LL | #[derive(PartialEq, Eq)]\n-   |          ^^^^^^^^^\n+LL | #[derive(Default, Hash)]\n+   |                   ^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/deriving-with-repr-packed.rs:1:9\n@@ -91,14 +91,14 @@ LL | #![deny(unaligned_references)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n-   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: this error originates in the derive macro `Hash` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n Future breakage diagnostic:\n-error: `#[derive]` can't be used on a `#[repr(packed)]` struct that does not derive Copy (error E0133)\n-  --> $DIR/deriving-with-repr-packed.rs:25:10\n+error: `Debug` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy` (error E0133)\n+  --> $DIR/deriving-with-repr-packed.rs:39:10\n    |\n-LL | #[derive(PartialEq)]\n-   |          ^^^^^^^^^\n+LL | #[derive(Debug, Default)]\n+   |          ^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/deriving-with-repr-packed.rs:1:9\n@@ -107,5 +107,5 @@ LL | #![deny(unaligned_references)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n-   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "3ddf8d6ef24054f8e05793ed9db13ae580bf156b", "filename": "src/test/ui/process/nofile-limit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fdbf075cf502431ca9fee6616331b32e34f25de/src%2Ftest%2Fui%2Fprocess%2Fnofile-limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdbf075cf502431ca9fee6616331b32e34f25de/src%2Ftest%2Fui%2Fprocess%2Fnofile-limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprocess%2Fnofile-limit.rs?ref=2fdbf075cf502431ca9fee6616331b32e34f25de", "patch": "@@ -6,7 +6,7 @@\n // dont-check-compiler-stderr\n // only-linux\n // no-prefer-dynamic\n-// compile-flags: -Ctarget-feature=+crt-static -Crpath=no\n+// compile-flags: -Ctarget-feature=+crt-static -Crpath=no -Crelocation-model=static\n #![feature(exit_status_error)]\n #![feature(rustc_private)]\n extern crate libc;"}]}