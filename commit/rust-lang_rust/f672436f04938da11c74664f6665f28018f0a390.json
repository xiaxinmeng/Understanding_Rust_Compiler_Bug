{"sha": "f672436f04938da11c74664f6665f28018f0a390", "node_id": "C_kwDOAAsO6NoAKGY2NzI0MzZmMDQ5MzhkYTExYzc0NjY0ZjY2NjVmMjgwMThmMGEzOTA", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-18T14:56:44Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-18T14:59:15Z"}, "message": "Handle structural traits more gracefully", "tree": {"sha": "8f5699361c3942acc22dada13d247a9f6cda647d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f5699361c3942acc22dada13d247a9f6cda647d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f672436f04938da11c74664f6665f28018f0a390", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f672436f04938da11c74664f6665f28018f0a390", "html_url": "https://github.com/rust-lang/rust/commit/f672436f04938da11c74664f6665f28018f0a390", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f672436f04938da11c74664f6665f28018f0a390/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34127c50803cc0a3c68f1f15480399e19d3813af", "url": "https://api.github.com/repos/rust-lang/rust/commits/34127c50803cc0a3c68f1f15480399e19d3813af", "html_url": "https://github.com/rust-lang/rust/commit/34127c50803cc0a3c68f1f15480399e19d3813af"}], "stats": {"total": 427, "additions": 212, "deletions": 215}, "files": [{"sha": "1ebcfd03c14ea1db6b6f790568f3de23466b695c", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 33, "deletions": 215, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/f672436f04938da11c74664f6665f28018f0a390/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f672436f04938da11c74664f6665f28018f0a390/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=f672436f04938da11c74664f6665f28018f0a390", "patch": "@@ -6,14 +6,15 @@ use super::assembly::{self, Candidate, CandidateSource};\n use super::infcx_ext::InferCtxtExt;\n use super::{EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{Movability, Mutability};\n use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::TraitPredicate;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::DUMMY_SP;\n \n+mod structural_traits;\n+\n impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     fn self_ty(self) -> Ty<'tcx> {\n         self.self_ty()\n@@ -85,11 +86,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n-        ecx.infcx.probe(|_| {\n-            let constituent_tys =\n-                instantiate_constituent_tys_for_auto_trait(ecx.infcx, goal.predicate.self_ty())?;\n-            ecx.evaluate_goal_for_constituent_tys_and_make_canonical_response(goal, constituent_tys)\n-        })\n+        ecx.probe_and_evaluate_goal_for_constituent_tys(\n+            goal,\n+            structural_traits::instantiate_constituent_tys_for_auto_trait,\n+        )\n     }\n \n     fn consider_trait_alias_candidate(\n@@ -112,44 +112,46 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n-        ecx.infcx.probe(|_| {\n-            let constituent_tys =\n-                instantiate_constituent_tys_for_sized_trait(ecx.infcx, goal.predicate.self_ty())?;\n-            ecx.evaluate_goal_for_constituent_tys_and_make_canonical_response(goal, constituent_tys)\n-        })\n+        ecx.probe_and_evaluate_goal_for_constituent_tys(\n+            goal,\n+            structural_traits::instantiate_constituent_tys_for_sized_trait,\n+        )\n     }\n \n     fn consider_builtin_copy_clone_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n-        ecx.infcx.probe(|_| {\n-            let constituent_tys = instantiate_constituent_tys_for_copy_clone_trait(\n-                ecx.infcx,\n-                goal.predicate.self_ty(),\n-            )?;\n-            ecx.evaluate_goal_for_constituent_tys_and_make_canonical_response(goal, constituent_tys)\n-        })\n+        ecx.probe_and_evaluate_goal_for_constituent_tys(\n+            goal,\n+            structural_traits::instantiate_constituent_tys_for_copy_clone_trait,\n+        )\n     }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n-    fn evaluate_goal_for_constituent_tys_and_make_canonical_response(\n+    /// Convenience function for traits that are structural, i.e. that only\n+    /// have nested subgoals that only change the self type. Unlike other\n+    /// evaluate-like helpers, this does a probe, so it doesn't need to be\n+    /// wrapped in one.\n+    fn probe_and_evaluate_goal_for_constituent_tys(\n         &mut self,\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n-        constituent_tys: Vec<Ty<'tcx>>,\n+        constituent_tys: impl Fn(&InferCtxt<'tcx>, Ty<'tcx>) -> Result<Vec<Ty<'tcx>>, NoSolution>,\n     ) -> QueryResult<'tcx> {\n-        self.evaluate_all_and_make_canonical_response(\n-            constituent_tys\n-                .into_iter()\n-                .map(|ty| {\n-                    goal.with(\n-                        self.tcx(),\n-                        ty::Binder::dummy(goal.predicate.with_self_ty(self.tcx(), ty)),\n-                    )\n-                })\n-                .collect(),\n-        )\n+        self.infcx.probe(|_| {\n+            self.evaluate_all_and_make_canonical_response(\n+                constituent_tys(self.infcx, goal.predicate.self_ty())?\n+                    .into_iter()\n+                    .map(|ty| {\n+                        goal.with(\n+                            self.tcx(),\n+                            ty::Binder::dummy(goal.predicate.with_self_ty(self.tcx(), ty)),\n+                        )\n+                    })\n+                    .collect(),\n+            )\n+        })\n     }\n \n     pub(super) fn compute_trait_goal(\n@@ -227,187 +229,3 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         candidate\n     }\n }\n-\n-// Calculates the constituent types of a type for `auto trait` purposes.\n-//\n-// For types with an \"existential\" binder, i.e. generator witnesses, we also\n-// instantiate the binder with placeholders eagerly.\n-fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n-    let tcx = infcx.tcx;\n-    match *ty.kind() {\n-        ty::Uint(_)\n-        | ty::Int(_)\n-        | ty::Bool\n-        | ty::Float(_)\n-        | ty::FnDef(..)\n-        | ty::FnPtr(_)\n-        | ty::Str\n-        | ty::Error(_)\n-        | ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n-        | ty::Never\n-        | ty::Char => Ok(vec![]),\n-\n-        ty::Placeholder(..)\n-        | ty::Dynamic(..)\n-        | ty::Param(..)\n-        | ty::Foreign(..)\n-        | ty::Alias(ty::Projection, ..)\n-        | ty::Bound(..)\n-        | ty::Infer(ty::TyVar(_)) => {\n-            // FIXME: Do we need to mark anything as ambiguous here? Yeah?\n-            Err(NoSolution)\n-        }\n-\n-        ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => bug!(),\n-\n-        ty::RawPtr(ty::TypeAndMut { ty: element_ty, .. }) | ty::Ref(_, element_ty, _) => {\n-            Ok(vec![element_ty])\n-        }\n-\n-        ty::Array(element_ty, _) | ty::Slice(element_ty) => Ok(vec![element_ty]),\n-\n-        ty::Tuple(ref tys) => {\n-            // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n-            Ok(tys.iter().collect())\n-        }\n-\n-        ty::Closure(_, ref substs) => Ok(vec![substs.as_closure().tupled_upvars_ty()]),\n-\n-        ty::Generator(_, ref substs, _) => {\n-            let generator_substs = substs.as_generator();\n-            Ok(vec![generator_substs.tupled_upvars_ty(), generator_substs.witness()])\n-        }\n-\n-        ty::GeneratorWitness(types) => {\n-            Ok(infcx.replace_bound_vars_with_placeholders(types).to_vec())\n-        }\n-\n-        // For `PhantomData<T>`, we pass `T`.\n-        ty::Adt(def, substs) if def.is_phantom_data() => Ok(vec![substs.type_at(0)]),\n-\n-        ty::Adt(def, substs) => Ok(def.all_fields().map(|f| f.ty(tcx, substs)).collect()),\n-\n-        ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n-            // We can resolve the `impl Trait` to its concrete type,\n-            // which enforces a DAG between the functions requiring\n-            // the auto trait bounds in question.\n-            Ok(vec![tcx.bound_type_of(def_id).subst(tcx, substs)])\n-        }\n-    }\n-}\n-\n-fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n-    match *ty.kind() {\n-        ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n-        | ty::Uint(_)\n-        | ty::Int(_)\n-        | ty::Bool\n-        | ty::Float(_)\n-        | ty::FnDef(..)\n-        | ty::FnPtr(_)\n-        | ty::RawPtr(..)\n-        | ty::Char\n-        | ty::Ref(..)\n-        | ty::Generator(..)\n-        | ty::GeneratorWitness(..)\n-        | ty::Array(..)\n-        | ty::Closure(..)\n-        | ty::Never\n-        | ty::Dynamic(_, _, ty::DynStar)\n-        | ty::Error(_) => Ok(vec![]),\n-\n-        ty::Str\n-        | ty::Slice(_)\n-        | ty::Dynamic(..)\n-        | ty::Foreign(..)\n-        | ty::Alias(..)\n-        | ty::Param(_) => Err(NoSolution),\n-\n-        ty::Infer(ty::TyVar(_)) => bug!(\"FIXME: ambiguous\"),\n-\n-        ty::Placeholder(..)\n-        | ty::Bound(..)\n-        | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => bug!(),\n-\n-        ty::Tuple(tys) => Ok(tys.to_vec()),\n-\n-        ty::Adt(def, substs) => {\n-            let sized_crit = def.sized_constraint(infcx.tcx);\n-            Ok(sized_crit\n-                .0\n-                .iter()\n-                .map(|ty| sized_crit.rebind(*ty).subst(infcx.tcx, substs))\n-                .collect())\n-        }\n-    }\n-}\n-\n-fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n-    match *ty.kind() {\n-        ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n-        | ty::FnDef(..)\n-        | ty::FnPtr(_)\n-        | ty::Error(_) => Ok(vec![]),\n-\n-        // Implementations are provided in core\n-        ty::Uint(_)\n-        | ty::Int(_)\n-        | ty::Bool\n-        | ty::Float(_)\n-        | ty::Char\n-        | ty::RawPtr(..)\n-        | ty::Never\n-        | ty::Ref(_, _, Mutability::Not)\n-        | ty::Array(..) => Err(NoSolution),\n-\n-        ty::Dynamic(..)\n-        | ty::Str\n-        | ty::Slice(_)\n-        | ty::Generator(_, _, Movability::Static)\n-        | ty::Foreign(..)\n-        | ty::Ref(_, _, Mutability::Mut)\n-        | ty::Adt(_, _)\n-        | ty::Alias(_, _)\n-        | ty::Param(_) => Err(NoSolution),\n-\n-        ty::Infer(ty::TyVar(_)) => bug!(\"FIXME: ambiguous\"),\n-\n-        ty::Placeholder(..)\n-        | ty::Bound(..)\n-        | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => bug!(),\n-\n-        ty::Tuple(tys) => Ok(tys.to_vec()),\n-\n-        ty::Closure(_, substs) => match *substs.as_closure().tupled_upvars_ty().kind() {\n-            ty::Tuple(tys) => Ok(tys.to_vec()),\n-            ty::Infer(ty::TyVar(_)) => bug!(\"FIXME: ambiguous\"),\n-            _ => bug!(),\n-        },\n-\n-        ty::Generator(_, substs, Movability::Movable) => {\n-            if infcx.tcx.features().generator_clone {\n-                let generator = substs.as_generator();\n-                match *generator.tupled_upvars_ty().kind() {\n-                    ty::Tuple(tys) => Ok(tys.iter().chain([generator.witness()]).collect()),\n-                    ty::Infer(ty::TyVar(_)) => bug!(\"FIXME: ambiguous\"),\n-                    _ => bug!(),\n-                }\n-            } else {\n-                Err(NoSolution)\n-            }\n-        }\n-\n-        ty::GeneratorWitness(types) => {\n-            Ok(infcx.replace_bound_vars_with_placeholders(types).to_vec())\n-        }\n-    }\n-}"}, {"sha": "bbc0c77253278aa208011e3b9a470bc2d89078d2", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/f672436f04938da11c74664f6665f28018f0a390/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f672436f04938da11c74664f6665f28018f0a390/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=f672436f04938da11c74664f6665f28018f0a390", "patch": "@@ -0,0 +1,179 @@\n+use rustc_hir::{Movability, Mutability};\n+use rustc_infer::{infer::InferCtxt, traits::query::NoSolution};\n+use rustc_middle::ty::{self, Ty};\n+\n+// Calculates the constituent types of a type for `auto trait` purposes.\n+//\n+// For types with an \"existential\" binder, i.e. generator witnesses, we also\n+// instantiate the binder with placeholders eagerly.\n+pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n+    let tcx = infcx.tcx;\n+    match *ty.kind() {\n+        ty::Uint(_)\n+        | ty::Int(_)\n+        | ty::Bool\n+        | ty::Float(_)\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::Str\n+        | ty::Error(_)\n+        | ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n+        | ty::Never\n+        | ty::Char => Ok(vec![]),\n+\n+        ty::Placeholder(..)\n+        | ty::Dynamic(..)\n+        | ty::Param(..)\n+        | ty::Foreign(..)\n+        | ty::Alias(ty::Projection, ..)\n+        | ty::Bound(..)\n+        | ty::Infer(ty::TyVar(_)) => {\n+            // FIXME: Do we need to mark anything as ambiguous here? Yeah?\n+            Err(NoSolution)\n+        }\n+\n+        ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => bug!(),\n+\n+        ty::RawPtr(ty::TypeAndMut { ty: element_ty, .. }) | ty::Ref(_, element_ty, _) => {\n+            Ok(vec![element_ty])\n+        }\n+\n+        ty::Array(element_ty, _) | ty::Slice(element_ty) => Ok(vec![element_ty]),\n+\n+        ty::Tuple(ref tys) => {\n+            // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n+            Ok(tys.iter().collect())\n+        }\n+\n+        ty::Closure(_, ref substs) => Ok(vec![substs.as_closure().tupled_upvars_ty()]),\n+\n+        ty::Generator(_, ref substs, _) => {\n+            let generator_substs = substs.as_generator();\n+            Ok(vec![generator_substs.tupled_upvars_ty(), generator_substs.witness()])\n+        }\n+\n+        ty::GeneratorWitness(types) => {\n+            Ok(infcx.replace_bound_vars_with_placeholders(types).to_vec())\n+        }\n+\n+        // For `PhantomData<T>`, we pass `T`.\n+        ty::Adt(def, substs) if def.is_phantom_data() => Ok(vec![substs.type_at(0)]),\n+\n+        ty::Adt(def, substs) => Ok(def.all_fields().map(|f| f.ty(tcx, substs)).collect()),\n+\n+        ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n+            // We can resolve the `impl Trait` to its concrete type,\n+            // which enforces a DAG between the functions requiring\n+            // the auto trait bounds in question.\n+            Ok(vec![tcx.bound_type_of(def_id).subst(tcx, substs)])\n+        }\n+    }\n+}\n+\n+pub(super) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n+    match *ty.kind() {\n+        ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n+        | ty::Uint(_)\n+        | ty::Int(_)\n+        | ty::Bool\n+        | ty::Float(_)\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::RawPtr(..)\n+        | ty::Char\n+        | ty::Ref(..)\n+        | ty::Generator(..)\n+        | ty::GeneratorWitness(..)\n+        | ty::Array(..)\n+        | ty::Closure(..)\n+        | ty::Never\n+        | ty::Dynamic(_, _, ty::DynStar)\n+        | ty::Error(_) => Ok(vec![]),\n+\n+        ty::Str\n+        | ty::Slice(_)\n+        | ty::Dynamic(..)\n+        | ty::Foreign(..)\n+        | ty::Alias(..)\n+        | ty::Param(_) => Err(NoSolution),\n+\n+        ty::Infer(ty::TyVar(_)) => bug!(\"FIXME: ambiguous\"),\n+\n+        ty::Placeholder(..)\n+        | ty::Bound(..)\n+        | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => bug!(),\n+\n+        ty::Tuple(tys) => Ok(tys.to_vec()),\n+\n+        ty::Adt(def, substs) => {\n+            let sized_crit = def.sized_constraint(infcx.tcx);\n+            Ok(sized_crit\n+                .0\n+                .iter()\n+                .map(|ty| sized_crit.rebind(*ty).subst(infcx.tcx, substs))\n+                .collect())\n+        }\n+    }\n+}\n+\n+pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n+    match *ty.kind() {\n+        ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::Error(_) => Ok(vec![]),\n+\n+        // Implementations are provided in core\n+        ty::Uint(_)\n+        | ty::Int(_)\n+        | ty::Bool\n+        | ty::Float(_)\n+        | ty::Char\n+        | ty::RawPtr(..)\n+        | ty::Never\n+        | ty::Ref(_, _, Mutability::Not)\n+        | ty::Array(..) => Err(NoSolution),\n+\n+        ty::Dynamic(..)\n+        | ty::Str\n+        | ty::Slice(_)\n+        | ty::Generator(_, _, Movability::Static)\n+        | ty::Foreign(..)\n+        | ty::Ref(_, _, Mutability::Mut)\n+        | ty::Adt(_, _)\n+        | ty::Alias(_, _)\n+        | ty::Param(_) => Err(NoSolution),\n+\n+        ty::Infer(ty::TyVar(_)) => bug!(\"FIXME: ambiguous\"),\n+\n+        ty::Placeholder(..)\n+        | ty::Bound(..)\n+        | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => bug!(),\n+\n+        ty::Tuple(tys) => Ok(tys.to_vec()),\n+\n+        ty::Closure(_, substs) => Ok(vec![substs.as_closure().tupled_upvars_ty()]),\n+\n+        ty::Generator(_, substs, Movability::Movable) => {\n+            if infcx.tcx.features().generator_clone {\n+                let generator = substs.as_generator();\n+                Ok(vec![generator.tupled_upvars_ty(), generator.witness()])\n+            } else {\n+                Err(NoSolution)\n+            }\n+        }\n+\n+        ty::GeneratorWitness(types) => {\n+            Ok(infcx.replace_bound_vars_with_placeholders(types).to_vec())\n+        }\n+    }\n+}"}]}