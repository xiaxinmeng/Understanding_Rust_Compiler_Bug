{"sha": "9d5d97b55d6487ee23b805bc1acbaa0669b82116", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNWQ5N2I1NWQ2NDg3ZWUyM2I4MDViYzFhY2JhYTA2NjliODIxMTY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-15T06:05:01Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-19T19:59:40Z"}, "message": "Remove a large amount of deprecated functionality\n\nSpring cleaning is here! In the Fall! This commit removes quite a large amount\nof deprecated functionality from the standard libraries. I tried to ensure that\nonly old deprecated functionality was removed.\n\nThis is removing lots and lots of deprecated features, so this is a breaking\nchange. Please consult the deprecation messages of the deleted code to see how\nto migrate code forward if it still needs migration.\n\n[breaking-change]", "tree": {"sha": "b72dcf7045e331e94ea0f8658d088ab42d917935", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b72dcf7045e331e94ea0f8658d088ab42d917935"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d5d97b55d6487ee23b805bc1acbaa0669b82116", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d5d97b55d6487ee23b805bc1acbaa0669b82116", "html_url": "https://github.com/rust-lang/rust/commit/9d5d97b55d6487ee23b805bc1acbaa0669b82116", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d5d97b55d6487ee23b805bc1acbaa0669b82116/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb169d5543c84e11038ba2d07b538ec88fb49ca6", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb169d5543c84e11038ba2d07b538ec88fb49ca6", "html_url": "https://github.com/rust-lang/rust/commit/fb169d5543c84e11038ba2d07b538ec88fb49ca6"}], "stats": {"total": 5618, "additions": 1352, "deletions": 4266}, "files": [{"sha": "e751084addd77d72323b52a9c857ec20d934be15", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -475,12 +475,6 @@ impl<T> DList<T> {\n         Items{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n     }\n \n-    /// Deprecated: use `iter_mut`.\n-    #[deprecated = \"use iter_mut\"]\n-    pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a, T> {\n-        self.iter_mut()\n-    }\n-\n     /// Provides a forward iterator with mutable references.\n     #[inline]\n     pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n@@ -496,12 +490,6 @@ impl<T> DList<T> {\n         }\n     }\n \n-    /// Deprecated: use `into_iter`.\n-    #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(self) -> MoveItems<T> {\n-        self.into_iter()\n-    }\n-\n     /// Consumes the list into an iterator yielding elements by value.\n     #[inline]\n     pub fn into_iter(self) -> MoveItems<T> {\n@@ -870,7 +858,8 @@ mod tests {\n         let mut m = list_from(v.as_slice());\n         m.append(list_from(u.as_slice()));\n         check_links(&m);\n-        let sum = v.append(u.as_slice());\n+        let mut sum = v;\n+        sum.push_all(u.as_slice());\n         assert_eq!(sum.len(), m.len());\n         for elt in sum.into_iter() {\n             assert_eq!(m.pop_front(), Some(elt))"}, {"sha": "e1806dae31dbe56b7595111a23cf6cea39a32a6e", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -502,40 +502,6 @@ pub trait Deque<T> : MutableSeq<T> {\n     /// ```\n     fn push_front(&mut self, elt: T);\n \n-    /// Inserts an element last in the sequence.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```ignore\n-    /// use std::collections::{DList, Deque};\n-    ///\n-    /// let mut d = DList::new();\n-    /// d.push_back(1i);\n-    /// d.push_back(2i);\n-    /// assert_eq!(d.front(), Some(&1i));\n-    /// ```\n-    #[deprecated = \"use the `push` method\"]\n-    fn push_back(&mut self, elt: T) { self.push(elt) }\n-\n-    /// Removes the last element and returns it, or `None` if the sequence is\n-    /// empty.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```ignore\n-    /// use std::collections::{RingBuf, Deque};\n-    ///\n-    /// let mut d = RingBuf::new();\n-    /// d.push_back(1i);\n-    /// d.push_back(2i);\n-    ///\n-    /// assert_eq!(d.pop_back(), Some(2i));\n-    /// assert_eq!(d.pop_back(), Some(1i));\n-    /// assert_eq!(d.pop_back(), None);\n-    /// ```\n-    #[deprecated = \"use the `pop` method\"]\n-    fn pop_back(&mut self) -> Option<T> { self.pop() }\n-\n     /// Removes the first element and returns it, or `None` if the sequence is\n     /// empty.\n     ///"}, {"sha": "16e04b93777f293be22eb9fe64b039376fd45d61", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -269,9 +269,6 @@ impl<T: Ord> PriorityQueue<T> {\n         if self.is_empty() { None } else { Some(&self.data[0]) }\n     }\n \n-    #[deprecated=\"renamed to `top`\"]\n-    pub fn maybe_top<'a>(&'a self) -> Option<&'a T> { self.top() }\n-\n     /// Returns the number of elements the queue can hold without reallocating.\n     ///\n     /// # Example\n@@ -341,9 +338,6 @@ impl<T: Ord> PriorityQueue<T> {\n         }\n     }\n \n-    #[deprecated=\"renamed to `pop`\"]\n-    pub fn maybe_pop(&mut self) -> Option<T> { self.pop() }\n-\n     /// Pushes an item onto the queue.\n     ///\n     /// # Example\n@@ -417,14 +411,6 @@ impl<T: Ord> PriorityQueue<T> {\n         }\n     }\n \n-    #[allow(dead_code)]\n-    #[deprecated=\"renamed to `into_vec`\"]\n-    fn to_vec(self) -> Vec<T> { self.into_vec() }\n-\n-    #[allow(dead_code)]\n-    #[deprecated=\"renamed to `into_sorted_vec`\"]\n-    fn to_sorted_vec(self) -> Vec<T> { self.into_sorted_vec() }\n-\n     /// Consumes the `PriorityQueue` and returns the underlying vector\n     /// in arbitrary order.\n     ///"}, {"sha": "e32e8145d172e2087edb08907062510b275da049", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 42, "deletions": 66, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -19,6 +19,7 @@ use core::cmp;\n use core::default::Default;\n use core::fmt;\n use core::iter;\n+use core::slice;\n use std::hash::{Writer, Hash};\n \n use {Deque, Mutable, MutableSeq};\n@@ -132,32 +133,6 @@ impl<T> RingBuf<T> {\n               elts: Vec::from_fn(cmp::max(MINIMUM_CAPACITY, n), |_| None)}\n     }\n \n-    /// Retrieve an element in the `RingBuf` by index.\n-    ///\n-    /// Fails if there is no element with the given index.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// #![allow(deprecated)]\n-    ///\n-    /// use std::collections::RingBuf;\n-    ///\n-    /// let mut buf = RingBuf::new();\n-    /// buf.push(3i);\n-    /// buf.push(4);\n-    /// buf.push(5);\n-    /// assert_eq!(buf.get(1), &4);\n-    /// ```\n-    #[deprecated = \"prefer using indexing, e.g., ringbuf[0]\"]\n-    pub fn get<'a>(&'a self, i: uint) -> &'a T {\n-        let idx = self.raw_index(i);\n-        match self.elts[idx] {\n-            None => fail!(),\n-            Some(ref v) => v\n-        }\n-    }\n-\n     /// Retrieves an element in the `RingBuf` by index.\n     ///\n     /// Fails if there is no element with the given index.\n@@ -250,12 +225,6 @@ impl<T> RingBuf<T> {\n         Items{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts.as_slice()}\n     }\n \n-    /// Deprecated: use `iter_mut`\n-    #[deprecated = \"use iter_mut\"]\n-    pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a, T> {\n-        self.iter_mut()\n-    }\n-\n     /// Returns a front-to-back iterator which returns mutable references.\n     ///\n     /// # Example\n@@ -285,16 +254,20 @@ impl<T> RingBuf<T> {\n             //    0 to end_index\n             let (temp, remaining1) = self.elts.split_at_mut(start_index);\n             let (remaining2, _) = temp.split_at_mut(end_index);\n-            MutItems { remaining1: remaining1,\n-                                 remaining2: remaining2,\n-                                 nelts: self.nelts }\n+            MutItems {\n+                remaining1: remaining1.iter_mut(),\n+                remaining2: remaining2.iter_mut(),\n+                nelts: self.nelts,\n+            }\n         } else {\n             // Items to iterate goes from start_index to end_index:\n             let (empty, elts) = self.elts.split_at_mut(0);\n             let remaining1 = elts[mut start_index..end_index];\n-            MutItems { remaining1: remaining1,\n-                                 remaining2: empty,\n-                                 nelts: self.nelts }\n+            MutItems {\n+                remaining1: remaining1.iter_mut(),\n+                remaining2: empty.iter_mut(),\n+                nelts: self.nelts,\n+            }\n         }\n     }\n }\n@@ -356,26 +329,26 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n \n /// `RingBuf` mutable iterator.\n pub struct MutItems<'a, T:'a> {\n-    remaining1: &'a mut [Option<T>],\n-    remaining2: &'a mut [Option<T>],\n+    remaining1: slice::MutItems<'a, Option<T>>,\n+    remaining2: slice::MutItems<'a, Option<T>>,\n     nelts: uint,\n }\n \n impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n     #[inline]\n-    #[allow(deprecated)] // mut_shift_ref\n     fn next(&mut self) -> Option<&'a mut T> {\n         if self.nelts == 0 {\n             return None;\n         }\n-        let r = if self.remaining1.len() > 0 {\n-            &mut self.remaining1\n-        } else {\n-            assert!(self.remaining2.len() > 0);\n-            &mut self.remaining2\n-        };\n         self.nelts -= 1;\n-        Some(r.mut_shift_ref().unwrap().get_mut_ref())\n+        match self.remaining1.next() {\n+            Some(ptr) => return Some(ptr.as_mut().unwrap()),\n+            None => {}\n+        }\n+        match self.remaining2.next() {\n+            Some(ptr) => return Some(ptr.as_mut().unwrap()),\n+            None => unreachable!(),\n+        }\n     }\n \n     #[inline]\n@@ -386,19 +359,19 @@ impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n \n impl<'a, T> DoubleEndedIterator<&'a mut T> for MutItems<'a, T> {\n     #[inline]\n-    #[allow(deprecated)] // mut_shift_ref\n     fn next_back(&mut self) -> Option<&'a mut T> {\n         if self.nelts == 0 {\n             return None;\n         }\n-        let r = if self.remaining2.len() > 0 {\n-            &mut self.remaining2\n-        } else {\n-            assert!(self.remaining1.len() > 0);\n-            &mut self.remaining1\n-        };\n         self.nelts -= 1;\n-        Some(r.mut_pop_ref().unwrap().get_mut_ref())\n+        match self.remaining2.next_back() {\n+            Some(ptr) => return Some(ptr.as_mut().unwrap()),\n+            None => {}\n+        }\n+        match self.remaining1.next_back() {\n+            Some(ptr) => return Some(ptr.as_mut().unwrap()),\n+            None => unreachable!(),\n+        }\n     }\n }\n \n@@ -484,9 +457,12 @@ impl<S: Writer, A: Hash<S>> Hash<S> for RingBuf<A> {\n \n impl<A> Index<uint, A> for RingBuf<A> {\n     #[inline]\n-    #[allow(deprecated)]\n     fn index<'a>(&'a self, i: &uint) -> &'a A {\n-        self.get(*i)\n+        let idx = self.raw_index(*i);\n+        match self.elts[idx] {\n+            None => fail!(),\n+            Some(ref v) => v,\n+        }\n     }\n }\n \n@@ -576,14 +552,14 @@ mod tests {\n         assert_eq!(d.len(), 3u);\n         d.push_front(1);\n         assert_eq!(d.len(), 4u);\n-        debug!(\"{}\", d.get(0));\n-        debug!(\"{}\", d.get(1));\n-        debug!(\"{}\", d.get(2));\n-        debug!(\"{}\", d.get(3));\n-        assert_eq!(*d.get(0), 1);\n-        assert_eq!(*d.get(1), 2);\n-        assert_eq!(*d.get(2), 3);\n-        assert_eq!(*d.get(3), 4);\n+        debug!(\"{}\", d[0]);\n+        debug!(\"{}\", d[1]);\n+        debug!(\"{}\", d[2]);\n+        debug!(\"{}\", d[3]);\n+        assert_eq!(d[0], 1);\n+        assert_eq!(d[1], 2);\n+        assert_eq!(d[2], 3);\n+        assert_eq!(d[3], 4);\n     }\n \n     #[cfg(test)]"}, {"sha": "d061e60a42265d95f97e298a2c34f377225a8897", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 34, "deletions": 207, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -270,23 +270,6 @@ impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n pub trait CloneableVector<T> {\n     /// Copies `self` into a new `Vec`.\n     fn to_vec(&self) -> Vec<T>;\n-\n-    /// Deprecated. Use `to_vec`.\n-    #[deprecated = \"Replaced by `to_vec`\"]\n-    fn to_owned(&self) -> Vec<T> {\n-        self.to_vec()\n-    }\n-\n-    /// Converts `self` into an owned vector, not making a copy if possible.\n-    /// Deprecated. Use 'to_vec'\n-    #[deprecated = \"Replaced by `to_vec`\"]\n-    fn into_vec(self) -> Vec<T>;\n-\n-    /// Deprecated. Use `to_vec`\n-    #[deprecated = \"Replaced by `to_vec`\"]\n-    fn into_owned(self) -> Vec<T> {\n-        self.to_vec()\n-    }\n }\n \n impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n@@ -297,9 +280,6 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n         vector.push_all(*self);\n         vector\n     }\n-\n-    #[inline(always)]\n-    fn into_vec(self) -> Vec<T> { self.to_vec() }\n }\n \n #[experimental]\n@@ -920,25 +900,6 @@ mod tests {\n         a.as_mut_slice().tail_mut();\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_tailn() {\n-        let mut a = vec![11i, 12, 13];\n-        let b: &mut [int] = &mut [11, 12, 13];\n-        assert!(a.tailn(0) == b);\n-        a = vec![11i, 12, 13];\n-        let b: &mut [int] = &mut [13];\n-        assert!(a.tailn(2) == b);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    #[allow(deprecated)]\n-    fn test_tailn_empty() {\n-        let a: Vec<int> = vec![];\n-        a.tailn(2);\n-    }\n-\n     #[test]\n     fn test_init() {\n         let mut a = vec![11i];\n@@ -973,25 +934,6 @@ mod tests {\n         a.as_mut_slice().init_mut();\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_initn() {\n-        let mut a = vec![11i, 12, 13];\n-        let b: &[int] = &[11, 12, 13];\n-        assert_eq!(a.as_slice().initn(0), b);\n-        a = vec![11i, 12, 13];\n-        let b: &[int] = &[11];\n-        assert_eq!(a.as_slice().initn(2), b);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    #[allow(deprecated)]\n-    fn test_initn_empty() {\n-        let a: Vec<int> = vec![];\n-        a.as_slice().initn(2);\n-    }\n-\n     #[test]\n     fn test_last() {\n         let mut a = vec![];\n@@ -1156,20 +1098,6 @@ mod tests {\n         assert_eq!(v[2], 4u);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_grow_set() {\n-        let mut v = vec![1i, 2, 3];\n-        v.grow_set(4u, &4, 5);\n-        let v = v.as_slice();\n-        assert_eq!(v.len(), 5u);\n-        assert_eq!(v[0], 1);\n-        assert_eq!(v[1], 2);\n-        assert_eq!(v[2], 3);\n-        assert_eq!(v[3], 4);\n-        assert_eq!(v[4], 5);\n-    }\n-\n     #[test]\n     fn test_truncate() {\n         let mut v = vec![box 6i,box 5,box 4];\n@@ -1385,49 +1313,48 @@ mod tests {\n     }\n \n     #[test]\n-    #[allow(deprecated)]\n-    fn test_bsearch_elem() {\n-        assert_eq!([1i,2,3,4,5].bsearch_elem(&5), Some(4));\n-        assert_eq!([1i,2,3,4,5].bsearch_elem(&4), Some(3));\n-        assert_eq!([1i,2,3,4,5].bsearch_elem(&3), Some(2));\n-        assert_eq!([1i,2,3,4,5].bsearch_elem(&2), Some(1));\n-        assert_eq!([1i,2,3,4,5].bsearch_elem(&1), Some(0));\n+    fn test_binary_search_elem() {\n+        assert_eq!([1i,2,3,4,5].binary_search_elem(&5).found(), Some(4));\n+        assert_eq!([1i,2,3,4,5].binary_search_elem(&4).found(), Some(3));\n+        assert_eq!([1i,2,3,4,5].binary_search_elem(&3).found(), Some(2));\n+        assert_eq!([1i,2,3,4,5].binary_search_elem(&2).found(), Some(1));\n+        assert_eq!([1i,2,3,4,5].binary_search_elem(&1).found(), Some(0));\n \n-        assert_eq!([2i,4,6,8,10].bsearch_elem(&1), None);\n-        assert_eq!([2i,4,6,8,10].bsearch_elem(&5), None);\n-        assert_eq!([2i,4,6,8,10].bsearch_elem(&4), Some(1));\n-        assert_eq!([2i,4,6,8,10].bsearch_elem(&10), Some(4));\n+        assert_eq!([2i,4,6,8,10].binary_search_elem(&1).found(), None);\n+        assert_eq!([2i,4,6,8,10].binary_search_elem(&5).found(), None);\n+        assert_eq!([2i,4,6,8,10].binary_search_elem(&4).found(), Some(1));\n+        assert_eq!([2i,4,6,8,10].binary_search_elem(&10).found(), Some(4));\n \n-        assert_eq!([2i,4,6,8].bsearch_elem(&1), None);\n-        assert_eq!([2i,4,6,8].bsearch_elem(&5), None);\n-        assert_eq!([2i,4,6,8].bsearch_elem(&4), Some(1));\n-        assert_eq!([2i,4,6,8].bsearch_elem(&8), Some(3));\n+        assert_eq!([2i,4,6,8].binary_search_elem(&1).found(), None);\n+        assert_eq!([2i,4,6,8].binary_search_elem(&5).found(), None);\n+        assert_eq!([2i,4,6,8].binary_search_elem(&4).found(), Some(1));\n+        assert_eq!([2i,4,6,8].binary_search_elem(&8).found(), Some(3));\n \n-        assert_eq!([2i,4,6].bsearch_elem(&1), None);\n-        assert_eq!([2i,4,6].bsearch_elem(&5), None);\n-        assert_eq!([2i,4,6].bsearch_elem(&4), Some(1));\n-        assert_eq!([2i,4,6].bsearch_elem(&6), Some(2));\n+        assert_eq!([2i,4,6].binary_search_elem(&1).found(), None);\n+        assert_eq!([2i,4,6].binary_search_elem(&5).found(), None);\n+        assert_eq!([2i,4,6].binary_search_elem(&4).found(), Some(1));\n+        assert_eq!([2i,4,6].binary_search_elem(&6).found(), Some(2));\n \n-        assert_eq!([2i,4].bsearch_elem(&1), None);\n-        assert_eq!([2i,4].bsearch_elem(&5), None);\n-        assert_eq!([2i,4].bsearch_elem(&2), Some(0));\n-        assert_eq!([2i,4].bsearch_elem(&4), Some(1));\n+        assert_eq!([2i,4].binary_search_elem(&1).found(), None);\n+        assert_eq!([2i,4].binary_search_elem(&5).found(), None);\n+        assert_eq!([2i,4].binary_search_elem(&2).found(), Some(0));\n+        assert_eq!([2i,4].binary_search_elem(&4).found(), Some(1));\n \n-        assert_eq!([2i].bsearch_elem(&1), None);\n-        assert_eq!([2i].bsearch_elem(&5), None);\n-        assert_eq!([2i].bsearch_elem(&2), Some(0));\n+        assert_eq!([2i].binary_search_elem(&1).found(), None);\n+        assert_eq!([2i].binary_search_elem(&5).found(), None);\n+        assert_eq!([2i].binary_search_elem(&2).found(), Some(0));\n \n-        assert_eq!([].bsearch_elem(&1i), None);\n-        assert_eq!([].bsearch_elem(&5i), None);\n+        assert_eq!([].binary_search_elem(&1i).found(), None);\n+        assert_eq!([].binary_search_elem(&5i).found(), None);\n \n-        assert!([1i,1,1,1,1].bsearch_elem(&1) != None);\n-        assert!([1i,1,1,1,2].bsearch_elem(&1) != None);\n-        assert!([1i,1,1,2,2].bsearch_elem(&1) != None);\n-        assert!([1i,1,2,2,2].bsearch_elem(&1) != None);\n-        assert_eq!([1i,2,2,2,2].bsearch_elem(&1), Some(0));\n+        assert!([1i,1,1,1,1].binary_search_elem(&1).found() != None);\n+        assert!([1i,1,1,1,2].binary_search_elem(&1).found() != None);\n+        assert!([1i,1,1,2,2].binary_search_elem(&1).found() != None);\n+        assert!([1i,1,2,2,2].binary_search_elem(&1).found() != None);\n+        assert_eq!([1i,2,2,2,2].binary_search_elem(&1).found(), Some(0));\n \n-        assert_eq!([1i,2,3,4,5].bsearch_elem(&6), None);\n-        assert_eq!([1i,2,3,4,5].bsearch_elem(&0), None);\n+        assert_eq!([1i,2,3,4,5].binary_search_elem(&6).found(), None);\n+        assert_eq!([1i,2,3,4,5].binary_search_elem(&0).found(), None);\n     }\n \n     #[test]\n@@ -1544,26 +1471,6 @@ mod tests {\n         assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 0, 3]);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_shift() {\n-        let mut x = vec![1i, 2, 3];\n-        assert_eq!(x.shift(), Some(1));\n-        assert_eq!(&x, &vec![2i, 3]);\n-        assert_eq!(x.shift(), Some(2));\n-        assert_eq!(x.shift(), Some(3));\n-        assert_eq!(x.shift(), None);\n-        assert_eq!(x.len(), 0);\n-    }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_unshift() {\n-        let mut x = vec![1i, 2, 3];\n-        x.unshift(0);\n-        assert_eq!(x, vec![0, 1, 2, 3]);\n-    }\n-\n     #[test]\n     fn test_insert() {\n         let mut a = vec![1i, 2, 4];\n@@ -1689,17 +1596,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    #[should_fail]\n-    #[allow(deprecated)]\n-    fn test_copy_memory_oob() {\n-        unsafe {\n-            let mut a = [1i, 2, 3, 4];\n-            let b = [1i, 2, 3, 4, 5];\n-            a.copy_memory(b);\n-        }\n-    }\n-\n     #[test]\n     fn test_total_ord() {\n         let c: &[int] = &[1, 2, 3];\n@@ -2005,19 +1901,6 @@ mod tests {\n         assert!(a == [1i,2,6,7,5]);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_copy_from() {\n-        let mut a = [1i,2,3,4,5];\n-        let b = [6i,7,8];\n-        assert_eq!(a.copy_from(b), 3);\n-        assert!(a == [6i,7,8,4,5]);\n-        let mut c = [7i,2,8,1];\n-        let d = [3i,1,4,1,5,9];\n-        assert_eq!(c.copy_from(d), 4);\n-        assert!(c == [3i,1,4,1]);\n-    }\n-\n     #[test]\n     fn test_reverse_part() {\n         let mut values = [1i,2,3,4,5];\n@@ -2198,34 +2081,6 @@ mod tests {\n         assert!(b\"foobar\".ends_with(empty));\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_shift_ref() {\n-        let mut x: &[int] = [1, 2, 3, 4, 5];\n-        let h = x.shift_ref();\n-        assert_eq!(*h.unwrap(), 1);\n-        assert_eq!(x.len(), 4);\n-        assert_eq!(x[0], 2);\n-        assert_eq!(x[3], 5);\n-\n-        let mut y: &[int] = [];\n-        assert_eq!(y.shift_ref(), None);\n-    }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_pop_ref() {\n-        let mut x: &[int] = [1, 2, 3, 4, 5];\n-        let h = x.pop_ref();\n-        assert_eq!(*h.unwrap(), 5);\n-        assert_eq!(x.len(), 4);\n-        assert_eq!(x[0], 1);\n-        assert_eq!(x[3], 4);\n-\n-        let mut y: &[int] = [];\n-        assert!(y.pop_ref().is_none());\n-    }\n-\n     #[test]\n     fn test_mut_splitator() {\n         let mut xs = [0i,1,0,2,3,0,0,4,5,0];\n@@ -2292,34 +2147,6 @@ mod tests {\n         let _it = v.chunks_mut(0);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_mut_shift_ref() {\n-        let mut x: &mut [int] = [1, 2, 3, 4, 5];\n-        let h = x.mut_shift_ref();\n-        assert_eq!(*h.unwrap(), 1);\n-        assert_eq!(x.len(), 4);\n-        assert_eq!(x[0], 2);\n-        assert_eq!(x[3], 5);\n-\n-        let mut y: &mut [int] = [];\n-        assert!(y.mut_shift_ref().is_none());\n-    }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_mut_pop_ref() {\n-        let mut x: &mut [int] = [1, 2, 3, 4, 5];\n-        let h = x.mut_pop_ref();\n-        assert_eq!(*h.unwrap(), 5);\n-        assert_eq!(x.len(), 4);\n-        assert_eq!(x[0], 1);\n-        assert_eq!(x[3], 4);\n-\n-        let mut y: &mut [int] = [];\n-        assert!(y.mut_pop_ref().is_none());\n-    }\n-\n     #[test]\n     fn test_mut_last() {\n         let mut x = [1i, 2, 3, 4, 5];"}, {"sha": "498f86a8bf1e41e493c9679ec9d6c42f314c1579", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -199,29 +199,6 @@ impl<V> SmallIntMap<V> {\n         SmallIntMap { v: Vec::with_capacity(capacity) }\n     }\n \n-    /// Retrieves a value for the given key.\n-    /// See [`find`](../trait.Map.html#tymethod.find) for a non-failing alternative.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the key is not present.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![allow(deprecated)]\n-    ///\n-    /// use std::collections::SmallIntMap;\n-    ///\n-    /// let mut map = SmallIntMap::new();\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.get(&1), &\"a\");\n-    /// ```\n-    #[deprecated = \"prefer using indexing, e.g., map[0]\"]\n-    pub fn get<'a>(&'a self, key: &uint) -> &'a V {\n-        self.find(key).expect(\"key not present\")\n-    }\n-\n     /// Returns an iterator visiting all keys in ascending order by the keys.\n     /// The iterator's element type is `uint`.\n     pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n@@ -260,12 +237,6 @@ impl<V> SmallIntMap<V> {\n         }\n     }\n \n-    /// Deprecated: use `iter_mut`\n-    #[deprecated = \"use iter_mut\"]\n-    pub fn mut_iter<'r>(&'r mut self) -> MutEntries<'r, V> {\n-        self.iter_mut()\n-    }\n-\n     /// Returns an iterator visiting all key-value pairs in ascending order by the keys,\n     /// with mutable references to the values.\n     /// The iterator's element type is `(uint, &'r mut V)`.\n@@ -296,14 +267,6 @@ impl<V> SmallIntMap<V> {\n         }\n     }\n \n-    /// Deprecated: use `into_iter` instead.\n-    #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(&mut self)\n-        -> FilterMap<(uint, Option<V>), (uint, V),\n-                Enumerate<vec::MoveItems<Option<V>>>> {\n-        self.into_iter()\n-    }\n-\n     /// Returns an iterator visiting all key-value pairs in ascending order by\n     /// the keys, emptying (but not consuming) the original `SmallIntMap`.\n     /// The iterator's element type is `(uint, &'r V)`.\n@@ -437,9 +400,8 @@ impl<V> Extendable<(uint, V)> for SmallIntMap<V> {\n \n impl<V> Index<uint, V> for SmallIntMap<V> {\n     #[inline]\n-    #[allow(deprecated)]\n     fn index<'a>(&'a self, i: &uint) -> &'a V {\n-        self.get(i)\n+        self.find(i).expect(\"key not present\")\n     }\n }\n "}, {"sha": "901f8add73c1aee5acb6cbe06e2bc370528b3e7e", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -58,7 +58,6 @@ use core::default::Default;\n use core::fmt;\n use core::cmp;\n use core::iter::AdditiveIterator;\n-use core::mem;\n use core::prelude::{Char, Clone, Collection, Eq, Equiv, ImmutableSlice};\n use core::prelude::{Iterator, MutableSlice, None, Option, Ord, Ordering};\n use core::prelude::{PartialEq, PartialOrd, Result, AsSlice, Some, Tuple2};\n@@ -67,7 +66,6 @@ use core::prelude::{range};\n use {Deque, MutableSeq};\n use hash;\n use ringbuf::RingBuf;\n-use slice::CloneableVector;\n use string::String;\n use unicode;\n use vec::Vec;\n@@ -85,31 +83,6 @@ pub use unicode::str::{UnicodeStrSlice, Words, Graphemes, GraphemeIndices};\n Section: Creating a string\n */\n \n-/// Deprecated. Replaced by `String::from_utf8`.\n-#[deprecated = \"Replaced by `String::from_utf8`\"]\n-pub fn from_utf8_owned(vv: Vec<u8>) -> Result<String, Vec<u8>> {\n-    String::from_utf8(vv)\n-}\n-\n-/// Deprecated. Replaced by `String::from_byte`.\n-#[deprecated = \"Replaced by String::from_byte\"]\n-pub fn from_byte(b: u8) -> String {\n-    assert!(b < 128u8);\n-    String::from_char(1, b as char)\n-}\n-\n-/// Deprecated. Use `String::from_char` or `char::to_string()` instead.\n-#[deprecated = \"use String::from_char or char.to_string()\"]\n-pub fn from_char(ch: char) -> String {\n-    String::from_char(1, ch)\n-}\n-\n-/// Deprecated. Replaced by `String::from_chars`.\n-#[deprecated = \"use String::from_chars instead\"]\n-pub fn from_chars(chs: &[char]) -> String {\n-    chs.iter().map(|c| *c).collect()\n-}\n-\n /// Methods for vectors of strings.\n pub trait StrVector {\n     /// Concatenates a vector of strings.\n@@ -427,18 +400,6 @@ pub fn replace(s: &str, from: &str, to: &str) -> String {\n Section: Misc\n */\n \n-/// Deprecated. Use `String::from_utf16`.\n-#[deprecated = \"Replaced by String::from_utf16\"]\n-pub fn from_utf16(v: &[u16]) -> Option<String> {\n-    String::from_utf16(v)\n-}\n-\n-/// Deprecated. Use `String::from_utf16_lossy`.\n-#[deprecated = \"Replaced by String::from_utf16_lossy\"]\n-pub fn from_utf16_lossy(v: &[u16]) -> String {\n-    String::from_utf16_lossy(v)\n-}\n-\n // Return the initial codepoint accumulator for the first byte.\n // The first byte is special, only want bottom 5 bits for width 2, 4 bits\n // for width 3, and 3 bits for width 4\n@@ -451,12 +412,6 @@ macro_rules! utf8_acc_cont_byte(\n     ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n )\n \n-/// Deprecated. Use `String::from_utf8_lossy`.\n-#[deprecated = \"Replaced by String::from_utf8_lossy\"]\n-pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n-    String::from_utf8_lossy(v)\n-}\n-\n /*\n Section: MaybeOwned\n */\n@@ -644,38 +599,8 @@ impl<'a> fmt::Show for MaybeOwned<'a> {\n \n /// Unsafe string operations.\n pub mod raw {\n-    use string;\n-    use string::String;\n-    use vec::Vec;\n-\n-    use MutableSeq;\n-\n     pub use core::str::raw::{from_utf8, c_str_to_static_slice, slice_bytes};\n     pub use core::str::raw::{slice_unchecked};\n-\n-    /// Deprecated. Replaced by `string::raw::from_buf_len`\n-    #[deprecated = \"Use string::raw::from_buf_len\"]\n-    pub unsafe fn from_buf_len(buf: *const u8, len: uint) -> String {\n-        string::raw::from_buf_len(buf, len)\n-    }\n-\n-    /// Deprecated. Use `string::raw::from_buf`\n-    #[deprecated = \"Use string::raw::from_buf\"]\n-    pub unsafe fn from_c_str(c_string: *const i8) -> String {\n-        string::raw::from_buf(c_string as *const u8)\n-    }\n-\n-    /// Deprecated. Replaced by `string::raw::from_utf8`\n-    #[deprecated = \"Use string::raw::from_utf8\"]\n-    pub unsafe fn from_utf8_owned(v: Vec<u8>) -> String {\n-        string::raw::from_utf8(v)\n-    }\n-\n-    /// Deprecated. Use `string::raw::from_utf8`\n-    #[deprecated = \"Use string::raw::from_utf8\"]\n-    pub unsafe fn from_byte(u: u8) -> String {\n-        string::raw::from_utf8(vec![u])\n-    }\n }\n \n /*\n@@ -687,12 +612,6 @@ pub trait StrAllocating: Str {\n     /// Converts `self` into a `String`, not making a copy if possible.\n     fn into_string(self) -> String;\n \n-    #[allow(missing_doc)]\n-    #[deprecated = \"replaced by .into_string()\"]\n-    fn into_owned(self) -> String {\n-        self.into_string()\n-    }\n-\n     /// Escapes each char in `s` with `char::escape_default`.\n     fn escape_default(&self) -> String {\n         let me = self.as_slice();\n@@ -750,21 +669,6 @@ pub trait StrAllocating: Str {\n         result\n     }\n \n-    #[allow(missing_doc)]\n-    #[deprecated = \"obsolete, use `to_string`\"]\n-    #[inline]\n-    fn to_owned(&self) -> String {\n-        unsafe {\n-            mem::transmute(self.as_slice().as_bytes().to_vec())\n-        }\n-    }\n-\n-    /// Converts to a vector of `u16` encoded as UTF-16.\n-    #[deprecated = \"use `utf16_units` instead\"]\n-    fn to_utf16(&self) -> Vec<u16> {\n-        self.as_slice().utf16_units().collect::<Vec<u16>>()\n-    }\n-\n     /// Given a string, makes a new string with repeated copies of it.\n     fn repeat(&self, nn: uint) -> String {\n         let me = self.as_slice();"}, {"sha": "fa45dee7cdea7c2756b692add3cf3ef9d5d59ec9", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 218, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -84,20 +84,6 @@ impl String {\n         String { vec: string.as_bytes().to_vec() }\n     }\n \n-    /// Deprecated. Replaced by `string::raw::from_parts`\n-    #[inline]\n-    #[deprecated = \"Replaced by string::raw::from_parts\"]\n-    pub unsafe fn from_raw_parts(length: uint, capacity: uint, ptr: *mut u8) -> String {\n-        raw::from_parts(ptr, length, capacity)\n-    }\n-\n-    /// Deprecated.\n-    #[deprecated = \"obsoleted by the removal of ~str\"]\n-    #[inline]\n-    pub fn from_owned_str(string: String) -> String {\n-        string\n-    }\n-\n     /// Returns the vector as a string buffer, if possible, taking care not to\n     /// copy it.\n     ///\n@@ -327,26 +313,6 @@ impl String {\n         self.vec\n     }\n \n-    /// Pushes the given `String` onto this buffer then returns `self` so that it can be\n-    /// used again.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let s = String::from_str(\"hello\");\n-    /// let big = s.append(\" \").append(\"world\").append(\"!\");\n-    /// // s has now been moved and cannot be used\n-    ///\n-    /// assert_eq!(big.as_slice(), \"hello world!\");\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"use .push_str() instead\"]\n-    pub fn append(mut self, second: &str) -> String {\n-        self.push_str(second);\n-        self\n-    }\n-\n     /// Creates a string buffer by repeating a character `length` times.\n     ///\n     /// # Example\n@@ -373,25 +339,6 @@ impl String {\n         buf\n     }\n \n-    /// Converts a byte to a UTF-8 string.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails with invalid UTF-8 (i.e., the byte is greater than 127).\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![allow(deprecated)]\n-    /// let s = String::from_byte(104);\n-    /// assert_eq!(s.as_slice(), \"h\");\n-    /// ```\n-    #[deprecated = \"use str::from_utf8 with a slice of one byte instead\"]\n-    pub fn from_byte(b: u8) -> String {\n-        assert!(b < 128u8);\n-        String::from_char(1, b as char)\n-    }\n-\n     /// Pushes the given string onto this string buffer.\n     ///\n     /// # Example\n@@ -424,21 +371,6 @@ impl String {\n         }\n     }\n \n-    /// Returns the number of bytes that this string buffer can hold without reallocating.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let s = String::with_capacity(10);\n-    /// assert!(s.byte_capacity() >= 10);\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"renamed to .capacity()\"]\n-    pub fn byte_capacity(&self) -> uint {\n-        self.vec.capacity()\n-    }\n-\n     /// Returns the number of bytes that this string buffer can hold without reallocating.\n     ///\n     /// # Example\n@@ -512,13 +444,6 @@ impl String {\n         self.vec.shrink_to_fit()\n     }\n \n-    /// Deprecated, use .push() instead.\n-    #[inline]\n-    #[deprecated = \"renamed to .push()\"]\n-    pub fn push_char(&mut self, ch: char) {\n-        self.push(ch)\n-    }\n-\n     /// Adds the given character to the end of the string.\n     ///\n     /// # Example\n@@ -549,26 +474,6 @@ impl String {\n         }\n     }\n \n-    /// Pushes the given bytes onto this string buffer.\n-    /// This is unsafe because it does not check\n-    /// to ensure that the resulting string will be valid UTF-8.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let mut s = String::new();\n-    /// unsafe {\n-    ///     s.push_bytes([104, 101, 108, 108, 111]);\n-    /// }\n-    /// assert_eq!(s.as_slice(), \"hello\");\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"call .as_mut_vec() and push onto that\"]\n-    pub unsafe fn push_bytes(&mut self, bytes: &[u8]) {\n-        self.vec.push_all(bytes)\n-    }\n-\n     /// Works with the underlying buffer as a byte slice.\n     ///\n     /// # Example\n@@ -584,31 +489,6 @@ impl String {\n         self.vec.as_slice()\n     }\n \n-    /// Works with the underlying buffer as a mutable byte slice.\n-    ///\n-    /// This is unsafe because it does not check\n-    /// to ensure that the resulting string will be valid UTF-8.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let mut s = String::from_str(\"hello\");\n-    /// unsafe {\n-    ///     let bytes = s.as_mut_bytes();\n-    ///     bytes[1] = 51;\n-    ///     bytes[4] = 48;\n-    /// }\n-    /// let b: &[_] = &[104, 51, 108, 108, 48];\n-    /// assert_eq!(s.as_bytes(), b);\n-    /// assert_eq!(s.as_slice(), \"h3ll0\")\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"call .as_mut_vec().as_mut_slice() instead\"]\n-    pub unsafe fn as_mut_bytes<'a>(&'a mut self) -> &'a mut [u8] {\n-        self.vec.as_mut_slice()\n-    }\n-\n     /// Shortens a string to the specified length.\n     ///\n     /// # Failure\n@@ -630,63 +510,6 @@ impl String {\n         self.vec.truncate(new_len)\n     }\n \n-    /// Appends a byte to this string buffer.\n-    ///\n-    /// This is unsafe because it does not check\n-    /// to ensure that the resulting string will be valid UTF-8.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let mut s = String::from_str(\"hell\");\n-    /// unsafe {\n-    ///     s.push_byte(111);\n-    /// }\n-    /// assert_eq!(s.as_slice(), \"hello\");\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"call .as_mut_vec().push() instead\"]\n-    pub unsafe fn push_byte(&mut self, byte: u8) {\n-        self.vec.push(byte)\n-    }\n-\n-    /// Removes the last byte from the string buffer and returns it.\n-    /// Returns `None` if this string buffer is empty.\n-    ///\n-    /// This is unsafe because it does not check\n-    /// to ensure that the resulting string will be valid UTF-8.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let mut s = String::from_str(\"foo\");\n-    /// unsafe {\n-    ///     assert_eq!(s.pop_byte(), Some(111));\n-    ///     assert_eq!(s.pop_byte(), Some(111));\n-    ///     assert_eq!(s.pop_byte(), Some(102));\n-    ///     assert_eq!(s.pop_byte(), None);\n-    /// }\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"call .as_mut_vec().pop() instead\"]\n-    pub unsafe fn pop_byte(&mut self) -> Option<u8> {\n-        let len = self.len();\n-        if len == 0 {\n-            return None\n-        }\n-\n-        let byte = self.as_bytes()[len - 1];\n-        self.vec.set_len(len - 1);\n-        Some(byte)\n-    }\n-\n-    /// Deprecated. Renamed to `pop`.\n-    #[inline]\n-    #[deprecated = \"renamed to .pop()\"]\n-    pub fn pop_char(&mut self) -> Option<char> { self.pop() }\n-\n     /// Removes the last character from the string buffer and returns it.\n     /// Returns `None` if this string buffer is empty.\n     ///\n@@ -714,35 +537,6 @@ impl String {\n         Some(ch)\n     }\n \n-    /// Removes the first byte from the string buffer and returns it.\n-    /// Returns `None` if this string buffer is empty.\n-    ///\n-    /// This is unsafe because it does not check\n-    /// to ensure that the resulting string will be valid UTF-8.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let mut s = String::from_str(\"foo\");\n-    /// unsafe {\n-    ///     assert_eq!(s.shift_byte(), Some(102));\n-    ///     assert_eq!(s.shift_byte(), Some(111));\n-    ///     assert_eq!(s.shift_byte(), Some(111));\n-    ///     assert_eq!(s.shift_byte(), None);\n-    /// }\n-    /// ```\n-    #[deprecated = \"call .as_mut_vec().remove(0)\"]\n-    pub unsafe fn shift_byte(&mut self) -> Option<u8> {\n-        self.vec.remove(0)\n-    }\n-\n-    /// Deprecated, call `remove(0)` instead\n-    #[deprecated = \"call .remove(0) instead\"]\n-    pub fn shift_char(&mut self) -> Option<char> {\n-        self.remove(0)\n-    }\n-\n     /// Removes the character from the string buffer at byte position `idx` and\n     /// returns it. Returns `None` if `idx` is out of bounds.\n     ///\n@@ -1251,18 +1045,6 @@ mod tests {\n         assert_eq!(data.as_slice(), \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n     }\n \n-    #[test]\n-    #[allow(deprecated)] // use remove(0) instead\n-    fn test_shift_char() {\n-        let mut data = String::from_str(\"\ud852\udf62\u20ac\u00a2b\u534e\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n-        assert_eq!(data.shift_char().unwrap(), '\ud852\udf62'); // 4 bytes\n-        assert_eq!(data.shift_char().unwrap(), '\u20ac'); // 3 bytes\n-        assert_eq!(data.shift_char().unwrap(), '\u00a2'); // 2 bytes\n-        assert_eq!(data.shift_char().unwrap(), 'b'); // 1 bytes\n-        assert_eq!(data.shift_char().unwrap(), '\u534e');\n-        assert_eq!(data.as_slice(), \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n-    }\n-\n     #[test]\n     fn test_str_truncate() {\n         let mut s = String::from_str(\"12345\");"}, {"sha": "39362bf1fdc0090ef2142277a3b64d3c6fb7532a", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -361,12 +361,6 @@ impl<K: Ord, V> TreeMap<K, V> {\n         RevEntries{iter: self.iter()}\n     }\n \n-    /// Deprecated: use `iter_mut`.\n-    #[deprecated = \"use iter_mut\"]\n-    pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n-        self.iter_mut()\n-    }\n-\n     /// Gets a lazy forward iterator over the key-value pairs in the\n     /// map, with the values being mutable.\n     ///\n@@ -398,12 +392,6 @@ impl<K: Ord, V> TreeMap<K, V> {\n         }\n     }\n \n-    /// Deprecated: use `rev_iter_mut`.\n-    #[deprecated = \"use rev_iter_mut\"]\n-    pub fn mut_rev_iter<'a>(&'a mut self) -> RevMutEntries<'a, K, V> {\n-        self.rev_iter_mut()\n-    }\n-\n     /// Gets a lazy reverse iterator over the key-value pairs in the\n     /// map, with the values being mutable.\n     ///\n@@ -430,12 +418,6 @@ impl<K: Ord, V> TreeMap<K, V> {\n         RevMutEntries{iter: self.iter_mut()}\n     }\n \n-    /// Deprecated: use `into_iter`.\n-    #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(self) -> MoveEntries<K, V> {\n-        self.into_iter()\n-    }\n-\n     /// Gets a lazy iterator that consumes the treemap.\n     ///\n     /// # Example\n@@ -494,12 +476,6 @@ impl<K, V> TreeMap<K, V> {\n         tree_find_with(&self.root, f)\n     }\n \n-    /// Deprecated: use `find_with_mut`.\n-    #[deprecated = \"use find_with_mut\"]\n-    pub fn find_mut_with<'a>(&'a mut self, f:|&K| -> Ordering) -> Option<&'a mut V> {\n-        self.find_with_mut(f)\n-    }\n-\n     /// Returns the value for which `f(key)` returns `Equal`. `f` is invoked\n     /// with current key and guides tree navigation. That means `f` should\n     /// be aware of natural ordering of the tree.\n@@ -626,12 +602,6 @@ impl<K: Ord, V> TreeMap<K, V> {\n         }\n     }\n \n-    /// Deprecated: use `lower_bound_mut`.\n-    #[deprecated = \"use lower_bound_mut\"]\n-    pub fn mut_lower_bound<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n-        self.lower_bound_mut(k)\n-    }\n-\n     /// Returns a lazy value iterator to the first key-value pair (with\n     /// the value being mutable) whose key is not less than `k`.\n     ///\n@@ -666,12 +636,6 @@ impl<K: Ord, V> TreeMap<K, V> {\n         bound_setup!(self.iter_mut_for_traversal(), k, true)\n     }\n \n-    /// Deprecated: use `upper_bound_mut`.\n-    #[deprecated = \"use upper_bound_mut\"]\n-    pub fn mut_upper_bound<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n-        self.upper_bound_mut(k)\n-    }\n-\n     /// Returns a lazy iterator to the first key-value pair (with the\n     /// value being mutable) whose key is greater than `k`.\n     ///\n@@ -1204,12 +1168,6 @@ impl<T: Ord> TreeSet<T> {\n         RevSetItems{iter: self.map.rev_iter()}\n     }\n \n-    /// Deprecated: use `into_iter`.\n-    #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(self) -> MoveSetItems<T> {\n-        self.into_iter()\n-    }\n-\n     /// Creates a consuming iterator, that is, one that moves each value out of the\n     /// set in ascending order. The set cannot be used after calling this.\n     ///"}, {"sha": "1b5c5dbc0a20bab1cc080dd369a8fabbcb4d2361", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -268,12 +268,6 @@ impl<T> TrieMap<T> {\n         iter\n     }\n \n-    /// Deprecated: use `iter_mut`.\n-    #[deprecated = \"use iter_mut\"]\n-    pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, T> {\n-        self.iter_mut()\n-    }\n-\n     /// Gets an iterator over the key-value pairs in the map, with the\n     /// ability to mutate the values.\n     ///\n@@ -439,12 +433,6 @@ impl<T> TrieMap<T> {\n                mutability = mut)\n     }\n \n-    /// Deprecated: use `lower_bound_mut`.\n-    #[deprecated = \"use lower_bound_mut\"]\n-    pub fn mut_lower_bound<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> {\n-        self.lower_bound_mut(key)\n-    }\n-\n     /// Gets an iterator pointing to the first key-value pair whose key is not less than `key`.\n     /// If all keys in the map are less than `key` an empty iterator is returned.\n     ///\n@@ -470,12 +458,6 @@ impl<T> TrieMap<T> {\n         self.bound_mut(key, false)\n     }\n \n-    /// Deprecated: use `upper_bound_mut`.\n-    #[deprecated = \"use upper_bound_mut\"]\n-    pub fn mut_upper_bound<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> {\n-        self.upper_bound_mut(key)\n-    }\n-\n     /// Gets an iterator pointing to the first key-value pair whose key is greater than `key`.\n     /// If all keys in the map are not greater than `key` an empty iterator is returned.\n     ///"}, {"sha": "e608a7d22dcf5e8a8fe33bf3fbf969974157ae93", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 9, "deletions": 191, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -275,19 +275,6 @@ impl<T> Vec<T> {\n }\n \n impl<T: Clone> Vec<T> {\n-    /// Deprecated, call `extend` instead.\n-    #[inline]\n-    #[deprecated = \"this function has been deprecated in favor of extend()\"]\n-    pub fn append(mut self, second: &[T]) -> Vec<T> {\n-        self.push_all(second);\n-        self\n-    }\n-\n-    /// Deprecated, call `to_vec()` instead\n-    #[inline]\n-    #[deprecated = \"this function has been deprecated in favor of to_vec()\"]\n-    pub fn from_slice(values: &[T]) -> Vec<T> { values.to_vec() }\n-\n     /// Constructs a `Vec` with copies of a value.\n     ///\n     /// Creates a `Vec` with `length` copies of `value`.\n@@ -366,31 +353,6 @@ impl<T: Clone> Vec<T> {\n         }\n     }\n \n-    /// Sets the value of a vector element at a given index, growing the vector\n-    /// as needed.\n-    ///\n-    /// Sets the element at position `index` to `value`. If `index` is past the\n-    /// end of the vector, expands the vector by replicating `initval` to fill\n-    /// the intervening space.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let mut vec = vec![\"a\", \"b\", \"c\"];\n-    /// vec.grow_set(1, &(\"fill\"), \"d\");\n-    /// vec.grow_set(4, &(\"fill\"), \"e\");\n-    /// assert_eq!(vec, vec![\"a\", \"d\", \"c\", \"fill\", \"e\"]);\n-    /// ```\n-    #[deprecated = \"call .grow() and .push() manually instead\"]\n-    pub fn grow_set(&mut self, index: uint, initval: &T, value: T) {\n-        let l = self.len();\n-        if index >= l {\n-            self.grow(index - l + 1u, initval.clone());\n-        }\n-        *self.get_mut(index) = value;\n-    }\n-\n     /// Partitions a vector based on a predicate.\n     ///\n     /// Clones the elements of the vector, partitioning them into two `Vec`s\n@@ -447,9 +409,8 @@ impl<T:Clone> Clone for Vec<T> {\n #[experimental = \"waiting on Index stability\"]\n impl<T> Index<uint,T> for Vec<T> {\n     #[inline]\n-    #[allow(deprecated)] // allow use of get\n     fn index<'a>(&'a self, index: &uint) -> &'a T {\n-        self.get(*index)\n+        &self.as_slice()[*index]\n     }\n }\n \n@@ -721,14 +682,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Deprecated, call `push` instead\n-    #[inline]\n-    #[deprecated = \"call .push() instead\"]\n-    pub fn append_one(mut self, x: T) -> Vec<T> {\n-        self.push(x);\n-        self\n-    }\n-\n     /// Shorten a vector, dropping excess elements.\n     ///\n     /// If `len` is greater than the vector's current length, this has no\n@@ -754,6 +707,14 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Deprecated, use `.extend(other.into_iter())`\n+    #[inline]\n+    #[deprecated = \"use .extend(other.into_iter())\"]\n+    #[cfg(stage0)]\n+    pub fn push_all_move(&mut self, other: Vec<T>) {\n+            self.extend(other.into_iter());\n+    }\n+\n     /// Returns a mutable slice of the elements of `self`.\n     ///\n     /// # Example\n@@ -775,12 +736,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Deprecated: use `into_iter`.\n-    #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(self) -> MoveItems<T> {\n-        self.into_iter()\n-    }\n-\n     /// Creates a consuming iterator, that is, one that moves each\n     /// value out of the vector (from start to end). The vector cannot\n     /// be used after calling this.\n@@ -830,26 +785,6 @@ impl<T> Vec<T> {\n         self.len = len;\n     }\n \n-    /// Returns a reference to the value at index `index`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if `index` is out of bounds\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![allow(deprecated)]\n-    ///\n-    /// let vec = vec![1i, 2, 3];\n-    /// assert!(vec.get(1) == &2);\n-    /// ```\n-    #[deprecated=\"prefer using indexing, e.g., vec[0]\"]\n-    #[inline]\n-    pub fn get<'a>(&'a self, index: uint) -> &'a T {\n-        &self.as_slice()[index]\n-    }\n-\n     /// Returns a mutable reference to the value at index `index`.\n     ///\n     /// # Failure\n@@ -885,12 +820,6 @@ impl<T> Vec<T> {\n         self.as_slice().iter()\n     }\n \n-    /// Deprecated: use `iter_mut`.\n-    #[deprecated = \"use iter_mut\"]\n-    pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a,T> {\n-        self.iter_mut()\n-    }\n-\n     /// Returns an iterator over mutable references to the elements of the\n     /// vector in order.\n     ///\n@@ -963,25 +892,6 @@ impl<T> Vec<T> {\n         self[].tail()\n     }\n \n-    /// Returns all but the first `n' elements of a vector.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails when there are fewer than `n` elements in the vector.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![allow(deprecated)]\n-    /// let vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec.tailn(2) == [3, 4]);\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"use slice_from\"]\n-    pub fn tailn<'a>(&'a self, n: uint) -> &'a [T] {\n-        self[n..]\n-    }\n-\n     /// Returns a reference to the last element of a vector, or `None` if it is\n     /// empty.\n     ///\n@@ -996,12 +906,6 @@ impl<T> Vec<T> {\n         self[].last()\n     }\n \n-    /// Deprecated: use `last_mut`.\n-    #[deprecated = \"use last_mut\"]\n-    pub fn mut_last<'a>(&'a mut self) -> Option<&'a mut T> {\n-        self.last_mut()\n-    }\n-\n     /// Returns a mutable reference to the last element of a vector, or `None`\n     /// if it is empty.\n     ///\n@@ -1047,48 +951,6 @@ impl<T> Vec<T> {\n         self.pop()\n     }\n \n-    /// Prepends an element to the vector.\n-    ///\n-    /// # Warning\n-    ///\n-    /// This is an O(n) operation as it requires copying every element in the\n-    /// vector.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```ignore\n-    /// let mut vec = vec![1i, 2, 3];\n-    /// vec.unshift(4);\n-    /// assert_eq!(vec, vec![4, 1, 2, 3]);\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"use insert(0, ...)\"]\n-    pub fn unshift(&mut self, element: T) {\n-        self.insert(0, element)\n-    }\n-\n-    /// Removes the first element from a vector and returns it, or `None` if\n-    /// the vector is empty.\n-    ///\n-    /// # Warning\n-    ///\n-    /// This is an O(n) operation as it requires copying every element in the\n-    /// vector.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![allow(deprecated)]\n-    /// let mut vec = vec![1i, 2, 3];\n-    /// assert!(vec.shift() == Some(1));\n-    /// assert_eq!(vec, vec![2, 3]);\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"use remove(0)\"]\n-    pub fn shift(&mut self) -> Option<T> {\n-        self.remove(0)\n-    }\n-\n     /// Inserts an element at position `index` within the vector, shifting all\n     /// elements after position `i` one position to the right.\n     ///\n@@ -1167,32 +1029,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Takes ownership of the vector `other`, moving all elements into\n-    /// the current vector. This does not copy any elements, and it is\n-    /// illegal to use the `other` vector after calling this method\n-    /// (because it is moved here).\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let mut vec = vec![box 1i];\n-    /// vec.push_all_move(vec![box 2, box 3, box 4]);\n-    /// assert_eq!(vec, vec![box 1, box 2, box 3, box 4]);\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"use .extend(other.into_iter())\"]\n-    pub fn push_all_move(&mut self, other: Vec<T>) {\n-        self.extend(other.into_iter());\n-    }\n-\n-    /// Deprecated: use `slice_mut`.\n-    #[deprecated = \"use slice_mut\"]\n-    pub fn mut_slice<'a>(&'a mut self, start: uint, end: uint)\n-                         -> &'a mut [T] {\n-        self[mut start..end]\n-    }\n-\n     /// Returns a mutable slice of `self` between `start` and `end`.\n     ///\n     /// # Failure\n@@ -1212,12 +1048,6 @@ impl<T> Vec<T> {\n         self[mut start..end]\n     }\n \n-    /// Deprecated: use \"slice_from_mut\".\n-    #[deprecated = \"use slice_from_mut\"]\n-    pub fn mut_slice_from<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        self[mut start..]\n-    }\n-\n     /// Returns a mutable slice of `self` from `start` to the end of the `Vec`.\n     ///\n     /// # Failure\n@@ -1235,12 +1065,6 @@ impl<T> Vec<T> {\n         self[mut start..]\n     }\n \n-    /// Deprecated: use `slice_to_mut`.\n-    #[deprecated = \"use slice_to_mut\"]\n-    pub fn mut_slice_to<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        self[mut ..end]\n-    }\n-\n     /// Returns a mutable slice of `self` from the start of the `Vec` to `end`.\n     ///\n     /// # Failure\n@@ -1258,12 +1082,6 @@ impl<T> Vec<T> {\n         self[mut ..end]\n     }\n \n-    /// Deprecated: use `split_at_mut`.\n-    #[deprecated = \"use split_at_mut\"]\n-    pub fn mut_split_at<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n-        self.split_at_mut(mid)\n-    }\n-\n     /// Returns a pair of mutable slices that divides the `Vec` at an index.\n     ///\n     /// The first will contain all indices from `[0, mid)` (excluding"}, {"sha": "021f575b0aceaa4deef2e8c3749ce901a19c0c7b", "filename": "src/libcore/any.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -76,11 +76,6 @@ use option::{Option, Some, None};\n use raw::TraitObject;\n use intrinsics::TypeId;\n \n-/// A type with no inhabitants\n-#[deprecated = \"this type is being removed, define a type locally if \\\n-                necessary\"]\n-pub enum Void { }\n-\n ///////////////////////////////////////////////////////////////////////////////\n // Any trait\n ///////////////////////////////////////////////////////////////////////////////\n@@ -117,13 +112,6 @@ pub trait AnyRefExt<'a> {\n     /// `None` if it isn't.\n     #[unstable = \"naming conventions around acquiring references may change\"]\n     fn downcast_ref<T: 'static>(self) -> Option<&'a T>;\n-\n-    /// Returns some reference to the boxed value if it is of type `T`, or\n-    /// `None` if it isn't.\n-    #[deprecated = \"this function has been renamed to `downcast_ref`\"]\n-    fn as_ref<T: 'static>(self) -> Option<&'a T> {\n-        self.downcast_ref::<T>()\n-    }\n }\n \n #[stable]\n@@ -166,13 +154,6 @@ pub trait AnyMutRefExt<'a> {\n     /// `None` if it isn't.\n     #[unstable = \"naming conventions around acquiring references may change\"]\n     fn downcast_mut<T: 'static>(self) -> Option<&'a mut T>;\n-\n-    /// Returns some mutable reference to the boxed value if it is of type `T`, or\n-    /// `None` if it isn't.\n-    #[deprecated = \"this function has been renamed to `downcast_mut`\"]\n-    fn as_mut<T: 'static>(self) -> Option<&'a mut T> {\n-        self.downcast_mut::<T>()\n-    }\n }\n \n #[stable]"}, {"sha": "505dc18348011c51016752d0477161a4b11ad632", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -178,20 +178,6 @@ impl PartialOrd for Ordering {\n     }\n }\n \n-/// Combine orderings, lexically.\n-///\n-/// For example for a type `(int, int)`, two comparisons could be done.\n-/// If the first ordering is different, the first ordering is all that must be returned.\n-/// If the first ordering is equal, then second ordering is returned.\n-#[inline]\n-#[deprecated = \"Just call .cmp() on a tuple\"]\n-pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n-    match o1 {\n-        Equal => o2,\n-        _ => o1\n-    }\n-}\n-\n /// Trait for values that can be compared for a sort-order.\n ///\n /// PartialOrd only requires implementation of the `partial_cmp` method,"}, {"sha": "e2a4fdfe79bf171cc2e80c7f6225b688f2e7e691", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -428,27 +428,6 @@ pub trait Iterator<A> {\n         ByRef{iter: self}\n     }\n \n-    /// Apply a function to each element, or stop iterating if the\n-    /// function returns `false`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust,ignore\n-    /// range(0u, 5).advance(|x| {print!(\"{} \", x); true});\n-    /// ```\n-    #[deprecated = \"use the `all` method instead\"]\n-    #[inline]\n-    fn advance(&mut self, f: |A| -> bool) -> bool {\n-        loop {\n-            match self.next() {\n-                Some(x) => {\n-                    if !f(x) { return false; }\n-                }\n-                None => { return true; }\n-            }\n-        }\n-    }\n-\n     /// Loops through the entire iterator, collecting all of the elements into\n     /// a container implementing `FromIterator`.\n     ///"}, {"sha": "677bc91d9dd3b23f40717d87a7fcff3467f115e6", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -20,9 +20,6 @@ by the compiler automatically for the types to which they apply.\n \n */\n \n-#[deprecated = \"This has been renamed to Sync\"]\n-pub use self::Sync as Share;\n-\n /// Types able to be transferred across task boundaries.\n #[lang=\"send\"]\n pub trait Send for Sized? {"}, {"sha": "62a4fbd2e08cdc5a3c1e287b94d0d601bfd19e83", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -104,13 +104,6 @@ pub mod clone;\n pub mod default;\n pub mod collections;\n \n-#[deprecated = \"all functionality now lives in `std::cell`\"]\n-/// Deprecated module in favor of `std::cell`\n-pub mod ty {\n-    #[deprecated = \"this type has been renamed to `UnsafeCell`\"]\n-    pub use cell::UnsafeCell as Unsafe;\n-}\n-\n /* Core types and methods on primitives */\n \n pub mod any;"}, {"sha": "97b3554b1e1ba3455e3ea2cccb9bc89370d04b67", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -14,7 +14,6 @@\n //! types, initializing and manipulating memory.\n \n use intrinsics;\n-use num::Int;\n use ptr;\n \n pub use intrinsics::transmute;\n@@ -43,26 +42,6 @@ pub fn size_of_val<T>(_val: &T) -> uint {\n     size_of::<T>()\n }\n \n-/// Deprecated, this function will be removed soon\n-#[inline]\n-#[deprecated = \"this function will be removed soon\"]\n-pub fn nonzero_size_of<T>() -> uint {\n-    match size_of::<T>() {\n-        0 => 1,\n-        n => n,\n-    }\n-}\n-\n-/// Deprecated, this function will be removed soon\n-#[inline]\n-#[deprecated = \"this function will be removed soon\"]\n-pub fn nonzero_size_of_val<T>(val: &T) -> uint {\n-    match size_of_val::<T>(val) {\n-        0 => 1,\n-        n => n,\n-    }\n-}\n-\n /// Returns the ABI-required minimum alignment of a type\n ///\n /// This is the alignment used for struct fields. It may be smaller\n@@ -107,16 +86,6 @@ pub fn align_of_val<T>(_val: &T) -> uint {\n     align_of::<T>()\n }\n \n-/// Deprecated, this function has been renamed to align_of\n-#[inline]\n-#[deprecated = \"use mem::align_of instead\"]\n-pub fn pref_align_of<T>() -> uint { align_of::<T>() }\n-\n-/// Deprecated, this function has been renamed to align_of_val\n-#[inline]\n-#[deprecated = \"use mem::align_of_val instead\"]\n-pub fn pref_align_of_val<T>(val: &T) -> uint { align_of_val(val) }\n-\n /// Create a value initialized to zero.\n ///\n /// This function is similar to allocating space for a a local variable and\n@@ -134,11 +103,6 @@ pub unsafe fn zeroed<T>() -> T {\n     intrinsics::init()\n }\n \n-/// Deprecated, use zeroed() instead\n-#[inline]\n-#[deprecated = \"this function has been renamed to zeroed()\"]\n-pub unsafe fn init<T>() -> T { zeroed() }\n-\n /// Create an uninitialized value.\n ///\n /// Care must be taken when using this function, if the type `T` has a\n@@ -153,116 +117,6 @@ pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::uninit()\n }\n \n-/// Deprecated, use `uninitialized` instead.\n-#[inline]\n-#[deprecated = \"this function has been renamed to `uninitialized`\"]\n-pub unsafe fn uninit<T>() -> T {\n-    intrinsics::uninit()\n-}\n-\n-/// Unsafely overwrite a memory location with the given value without destroying\n-/// the old value.\n-///\n-/// This operation is unsafe because it does not destroy the previous value\n-/// contained at the location `dst`. This could leak allocations or resources,\n-/// so care must be taken to previously deallocate the value at `dst`.\n-#[inline]\n-#[deprecated = \"use ptr::write\"]\n-pub unsafe fn overwrite<T>(dst: *mut T, src: T) {\n-    intrinsics::move_val_init(&mut *dst, src)\n-}\n-\n-/// Deprecated, use `overwrite` instead\n-#[inline]\n-#[deprecated = \"this function has been renamed to overwrite()\"]\n-pub unsafe fn move_val_init<T>(dst: &mut T, src: T) {\n-    ptr::write(dst, src)\n-}\n-\n-/// Convert an u16 to little endian from the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::to_le` instead\"]\n-pub fn to_le16(x: u16) -> u16 { x.to_le() }\n-\n-/// Convert an u32 to little endian from the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::to_le` instead\"]\n-pub fn to_le32(x: u32) -> u32 { x.to_le() }\n-\n-/// Convert an u64 to little endian from the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::to_le` instead\"]\n-pub fn to_le64(x: u64) -> u64 { x.to_le() }\n-\n-/// Convert an u16 to big endian from the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::to_be` instead\"]\n-pub fn to_be16(x: u16) -> u16 { x.to_be() }\n-\n-/// Convert an u32 to big endian from the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::to_be` instead\"]\n-pub fn to_be32(x: u32) -> u32 { x.to_be() }\n-\n-/// Convert an u64 to big endian from the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::to_be` instead\"]\n-pub fn to_be64(x: u64) -> u64 { x.to_be() }\n-\n-/// Convert an u16 from little endian to the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::from_le` instead\"]\n-pub fn from_le16(x: u16) -> u16 { Int::from_le(x) }\n-\n-/// Convert an u32 from little endian to the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::from_le` instead\"]\n-pub fn from_le32(x: u32) -> u32 { Int::from_le(x) }\n-\n-/// Convert an u64 from little endian to the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::from_le` instead\"]\n-pub fn from_le64(x: u64) -> u64 { Int::from_le(x) }\n-\n-/// Convert an u16 from big endian to the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::from_be` instead\"]\n-pub fn from_be16(x: u16) -> u16 { Int::from_be(x) }\n-\n-/// Convert an u32 from big endian to the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::from_be` instead\"]\n-pub fn from_be32(x: u32) -> u32 { Int::from_be(x) }\n-\n-/// Convert an u64 from big endian to the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::from_be` instead\"]\n-pub fn from_be64(x: u64) -> u64 { Int::from_be(x) }\n-\n /// Swap the values at two mutable locations of the same type, without\n /// deinitialising or copying either one.\n #[inline]"}, {"sha": "5b34cab611a56a372cd69a7654a757ef27ac2b34", "filename": "src/libcore/option.rs", "status": "modified", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -482,33 +482,6 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Deprecated.\n-    ///\n-    /// Applies a function to the contained value or does nothing.\n-    /// Returns true if the contained value was mutated.\n-    #[deprecated = \"removed due to lack of use\"]\n-    pub fn mutate(&mut self, f: |T| -> T) -> bool {\n-        if self.is_some() {\n-            *self = Some(f(self.take().unwrap()));\n-            true\n-        } else { false }\n-    }\n-\n-    /// Deprecated.\n-    ///\n-    /// Applies a function to the contained value or sets it to a default.\n-    /// Returns true if the contained value was mutated, or false if set to the default.\n-    #[deprecated = \"removed due to lack of use\"]\n-    pub fn mutate_or_set(&mut self, def: T, f: |T| -> T) -> bool {\n-        if self.is_some() {\n-            *self = Some(f(self.take().unwrap()));\n-            true\n-        } else {\n-            *self = Some(def);\n-            false\n-        }\n-    }\n-\n     /////////////////////////////////////////////////////////////////////////\n     // Iterator constructors\n     /////////////////////////////////////////////////////////////////////////\n@@ -530,12 +503,6 @@ impl<T> Option<T> {\n         Item{opt: self.as_ref()}\n     }\n \n-    /// Deprecated: use `iter_mut`\n-    #[deprecated = \"use iter_mut\"]\n-    pub fn mut_iter<'r>(&'r mut self) -> Item<&'r mut T> {\n-        self.iter_mut()\n-    }\n-\n     /// Returns a mutable iterator over the possibly contained value.\n     ///\n     /// # Example\n@@ -557,12 +524,6 @@ impl<T> Option<T> {\n         Item{opt: self.as_mut()}\n     }\n \n-    /// Deprecated: use `into_iter`.\n-    #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(self) -> Item<T> {\n-        self.into_iter()\n-    }\n-\n     /// Returns a consuming iterator over the possibly contained value.\n     ///\n     /// # Example\n@@ -713,100 +674,6 @@ impl<T> Option<T> {\n     pub fn take(&mut self) -> Option<T> {\n         mem::replace(self, None)\n     }\n-\n-    /// Deprecated.\n-    ///\n-    /// Filters an optional value using a given function.\n-    #[inline(always)]\n-    #[deprecated = \"removed due to lack of use\"]\n-    pub fn filtered(self, f: |t: &T| -> bool) -> Option<T> {\n-        match self {\n-            Some(x) => if f(&x) { Some(x) } else { None },\n-            None => None\n-        }\n-    }\n-\n-    /// Deprecated.\n-    ///\n-    /// Applies a function zero or more times until the result is `None`.\n-    #[inline]\n-    #[deprecated = \"removed due to lack of use\"]\n-    pub fn while_some(self, f: |v: T| -> Option<T>) {\n-        let mut opt = self;\n-        loop {\n-            match opt {\n-                Some(x) => opt = f(x),\n-                None => break\n-            }\n-        }\n-    }\n-\n-    /////////////////////////////////////////////////////////////////////////\n-    // Common special cases\n-    /////////////////////////////////////////////////////////////////////////\n-\n-    /// Deprecated: use `take().unwrap()` instead.\n-    ///\n-    /// The option dance. Moves a value out of an option type and returns it,\n-    /// replacing the original with `None`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value equals `None`.\n-    #[inline]\n-    #[deprecated = \"use take().unwrap() instead\"]\n-    pub fn take_unwrap(&mut self) -> T {\n-        match self.take() {\n-            Some(x) => x,\n-            None => fail!(\"called `Option::take_unwrap()` on a `None` value\")\n-        }\n-    }\n-\n-    /// Deprecated: use `as_ref().unwrap()` instead.\n-    ///\n-    /// Gets an immutable reference to the value inside an option.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value equals `None`\n-    ///\n-    /// # Safety note\n-    ///\n-    /// In general, because this function may fail, its use is discouraged\n-    /// (calling `get` on `None` is akin to dereferencing a null pointer).\n-    /// Instead, prefer to use pattern matching and handle the `None`\n-    /// case explicitly.\n-    #[inline]\n-    #[deprecated = \"use .as_ref().unwrap() instead\"]\n-    pub fn get_ref<'a>(&'a self) -> &'a T {\n-        match *self {\n-            Some(ref x) => x,\n-            None => fail!(\"called `Option::get_ref()` on a `None` value\"),\n-        }\n-    }\n-\n-    /// Deprecated: use `as_mut().unwrap()` instead.\n-    ///\n-    /// Gets a mutable reference to the value inside an option.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value equals `None`\n-    ///\n-    /// # Safety note\n-    ///\n-    /// In general, because this function may fail, its use is discouraged\n-    /// (calling `get` on `None` is akin to dereferencing a null pointer).\n-    /// Instead, prefer to use pattern matching and handle the `None`\n-    /// case explicitly.\n-    #[inline]\n-    #[deprecated = \"use .as_mut().unwrap() instead\"]\n-    pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n-        match *self {\n-            Some(ref mut x) => x,\n-            None => fail!(\"called `Option::get_mut_ref()` on a `None` value\"),\n-        }\n-    }\n }\n \n impl<T: Default> Option<T> {\n@@ -908,13 +775,6 @@ impl<A> ExactSize<A> for Item<A> {}\n // Free functions\n /////////////////////////////////////////////////////////////////////////////\n \n-/// Deprecated: use `Iterator::collect` instead.\n-#[inline]\n-#[deprecated = \"use Iterator::collect instead\"]\n-pub fn collect<T, Iter: Iterator<Option<T>>, V: FromIterator<T>>(mut iter: Iter) -> Option<V> {\n-    iter.collect()\n-}\n-\n impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// Takes each element in the `Iterator`: if it is `None`, no further\n     /// elements are taken, and the `None` is returned. Should no `None` occur, a"}, {"sha": "f0cd8402b1424384c46102d37041d8251a65d206", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -90,7 +90,6 @@\n use mem;\n use clone::Clone;\n use intrinsics;\n-use iter::range;\n use option::{Some, None, Option};\n \n use cmp::{PartialEq, Eq, PartialOrd, Equiv, Ordering, Less, Equal, Greater};\n@@ -113,10 +112,6 @@ pub use intrinsics::set_memory;\n #[unstable = \"may need a different name after pending changes to pointer types\"]\n pub fn null<T>() -> *const T { 0 as *const T }\n \n-/// Deprecated: use `null_mut`.\n-#[deprecated = \"use null_mut\"]\n-pub fn mut_null<T>() -> *mut T { null_mut() }\n-\n /// Create an unsafe mutable null pointer.\n ///\n /// # Example\n@@ -203,59 +198,6 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n     intrinsics::move_val_init(&mut *dst, src)\n }\n \n-/// Given a *const *const T (pointer to an array of pointers),\n-/// iterate through each *const T, up to the provided `len`,\n-/// passing to the provided callback function\n-#[deprecated = \"old-style iteration. use a loop and RawPtr::offset\"]\n-pub unsafe fn array_each_with_len<T>(arr: *const *const T, len: uint,\n-                                     cb: |*const T|) {\n-    if arr.is_null() {\n-        fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n-    }\n-    //let start_ptr = *arr;\n-    for e in range(0, len) {\n-        let n = arr.offset(e as int);\n-        cb(*n);\n-    }\n-}\n-\n-/// Given a null-pointer-terminated *const *const T (pointer to\n-/// an array of pointers), iterate through each *const T,\n-/// passing to the provided callback function\n-///\n-/// # Safety Note\n-///\n-/// This will only work with a null-terminated\n-/// pointer array.\n-#[deprecated = \"old-style iteration. use a loop and RawPtr::offset\"]\n-#[allow(deprecated)]\n-pub unsafe fn array_each<T>(arr: *const  *const T, cb: |*const T|) {\n-    if arr.is_null()  {\n-        fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n-    }\n-    let len = buf_len(arr);\n-    array_each_with_len(arr, len, cb);\n-}\n-\n-/// Return the offset of the first null pointer in `buf`.\n-#[inline]\n-#[deprecated = \"use a loop and RawPtr::offset\"]\n-#[allow(deprecated)]\n-pub unsafe fn buf_len<T>(buf: *const *const T) -> uint {\n-    position(buf, |i| *i == null())\n-}\n-\n-/// Return the first offset `i` such that `f(buf[i]) == true`.\n-#[inline]\n-#[deprecated = \"old-style iteration. use a loop and RawPtr::offset\"]\n-pub unsafe fn position<T>(buf: *const T, f: |&T| -> bool) -> uint {\n-    let mut i = 0;\n-    loop {\n-        if f(&(*buf.offset(i as int))) { return i; }\n-        else { i += 1; }\n-    }\n-}\n-\n /// Methods on raw pointers\n pub trait RawPtr<T> {\n     /// Returns the null pointer.\n@@ -280,12 +222,6 @@ pub trait RawPtr<T> {\n     /// the returned value could be pointing to invalid memory.\n     unsafe fn as_ref<'a>(&self) -> Option<&'a T>;\n \n-    /// A synonym for `as_ref`, except with incorrect lifetime semantics\n-    #[deprecated=\"Use `as_ref` instead\"]\n-    unsafe fn to_option<'a>(&'a self) -> Option<&'a T> {\n-        mem::transmute(self.as_ref())\n-    }\n-\n     /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n     /// the object, or one-byte-past-the-end.  `count` is in units of T; e.g. a\n     /// `count` of 3 represents a pointer offset of `3 * sizeof::<T>()` bytes."}, {"sha": "27bb649d1d99bfaa5c43a89675ea1c002d7307cc", "filename": "src/libcore/result.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -566,12 +566,6 @@ impl<T, E> Result<T, E> {\n         Item{opt: self.as_ref().ok()}\n     }\n \n-    /// Deprecated: use `iter_mut`.\n-    #[deprecated = \"use iter_mut\"]\n-    pub fn mut_iter<'r>(&'r mut self) -> Item<&'r mut T> {\n-        self.iter_mut()\n-    }\n-\n     /// Returns a mutable iterator over the possibly contained value.\n     ///\n     /// # Example\n@@ -593,12 +587,6 @@ impl<T, E> Result<T, E> {\n         Item{opt: self.as_mut().ok()}\n     }\n \n-    /// Deprecated: `use into_iter`.\n-    #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(self) -> Item<T> {\n-        self.into_iter()\n-    }\n-\n     /// Returns a consuming iterator over the possibly contained value.\n     ///\n     /// # Example\n@@ -771,13 +759,6 @@ impl<T, E> Result<T, E> {\n             Err(e) => op(e)\n         }\n     }\n-\n-    /// Deprecated name for `unwrap_or_else()`.\n-    #[deprecated = \"replaced by .unwrap_or_else()\"]\n-    #[inline]\n-    pub fn unwrap_or_handle(self, op: |E| -> T) -> T {\n-        self.unwrap_or_else(op)\n-    }\n }\n \n impl<T, E: Show> Result<T, E> {\n@@ -902,14 +883,6 @@ impl<A> ExactSize<A> for Item<A> {}\n // Free functions\n /////////////////////////////////////////////////////////////////////////////\n \n-/// Deprecated: use `Iterator::collect`.\n-#[inline]\n-#[deprecated = \"use Iterator::collect instead\"]\n-pub fn collect<T, E, Iter: Iterator<Result<T, E>>, V: FromIterator<T>>(mut iter: Iter)\n-                                                                       -> Result<V, E> {\n-    iter.collect()\n-}\n-\n impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// Takes each element in the `Iterator`: if it is an `Err`, no further\n     /// elements are taken, and the `Err` is returned. Should no `Err` occur, a\n@@ -984,16 +957,3 @@ pub fn fold<T,\n     }\n     Ok(init)\n }\n-\n-/// Deprecated.\n-///\n-/// Perform a trivial fold operation over the result values\n-/// from an iterator.\n-///\n-/// If an `Err` is encountered, it is immediately returned.\n-/// Otherwise, a simple `Ok(())` is returned.\n-#[inline]\n-#[deprecated = \"use fold instead\"]\n-pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> {\n-    fold(iterator, (), |_, _| ())\n-}"}, {"sha": "6b24592b17f43ed6856585d2eec1cb452100770b", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 8, "deletions": 277, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -176,27 +176,14 @@ pub trait ImmutableSlice<'a, T> {\n     #[unstable = \"name may change\"]\n     fn tail(&self) -> &'a [T];\n \n-    /// Returns all but the first `n' elements of a slice.\n-    #[deprecated = \"use slice_from\"]\n-    fn tailn(&self, n: uint) -> &'a [T];\n-\n     /// Returns all but the last element of a slice.\n     #[unstable = \"name may change\"]\n     fn init(&self) -> &'a [T];\n \n-    /// Returns all but the last `n' elements of a slice.\n-    #[deprecated = \"use slice_to but note the arguments are different\"]\n-    fn initn(&self, n: uint) -> &'a [T];\n-\n     /// Returns the last element of a slice, or `None` if it is empty.\n     #[unstable = \"name may change\"]\n     fn last(&self) -> Option<&'a T>;\n \n-    /// Returns a pointer to the element at the given index, without doing\n-    /// bounds checking.\n-    #[deprecated = \"renamed to `unsafe_get`\"]\n-    unsafe fn unsafe_ref(self, index: uint) -> &'a T;\n-\n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n     #[unstable]\n@@ -212,10 +199,6 @@ pub trait ImmutableSlice<'a, T> {\n     #[unstable]\n     fn as_ptr(&self) -> *const T;\n \n-    /// Deprecated: use `binary_search`.\n-    #[deprecated = \"use binary_search\"]\n-    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;\n-\n     /// Binary search a sorted slice with a comparator function.\n     ///\n     /// The comparator function should implement an order consistent\n@@ -251,44 +234,6 @@ pub trait ImmutableSlice<'a, T> {\n     /// ```\n     #[unstable = \"waiting on unboxed closures\"]\n     fn binary_search(&self, f: |&T| -> Ordering) -> BinarySearchResult;\n-\n-    /**\n-     * Returns an immutable reference to the first element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None }\n-     *     let head = &self[0];\n-     *     *self = self[1..];\n-     *     Some(head)\n-     * ```\n-     *\n-     * Returns `None` if vector is empty\n-     */\n-    #[deprecated = \"find some other way. sorry\"]\n-    fn shift_ref(&mut self) -> Option<&'a T>;\n-\n-    /**\n-     * Returns an immutable reference to the last element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None; }\n-     *     let tail = &self[self.len() - 1];\n-     *     *self = self[..self.len() - 1];\n-     *     Some(tail)\n-     * ```\n-     *\n-     * Returns `None` if slice is empty.\n-     */\n-    #[deprecated = \"find some other way. sorry\"]\n-    fn pop_ref(&mut self) -> Option<&'a T>;\n }\n \n #[unstable]\n@@ -388,32 +333,16 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     #[inline]\n     fn tail(&self) -> &'a [T] { (*self)[1..] }\n \n-    #[inline]\n-    #[deprecated = \"use slice_from\"]\n-    fn tailn(&self, n: uint) -> &'a [T] { (*self)[n..] }\n-\n     #[inline]\n     fn init(&self) -> &'a [T] {\n         (*self)[..self.len() - 1]\n     }\n \n-    #[inline]\n-    #[deprecated = \"use slice_to but note the arguments are different\"]\n-    fn initn(&self, n: uint) -> &'a [T] {\n-        (*self)[..self.len() - n]\n-    }\n-\n     #[inline]\n     fn last(&self) -> Option<&'a T> {\n         if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n     }\n \n-    #[inline]\n-    #[deprecated = \"renamed to `unsafe_get`\"]\n-    unsafe fn unsafe_ref(self, index: uint) -> &'a T {\n-        transmute(self.repr().data.offset(index as int))\n-    }\n-\n     #[inline]\n     unsafe fn unsafe_get(self, index: uint) -> &'a T {\n         transmute(self.repr().data.offset(index as int))\n@@ -424,27 +353,6 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n         self.repr().data\n     }\n \n-\n-    #[deprecated = \"use binary_search\"]\n-    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> {\n-        let mut base : uint = 0;\n-        let mut lim : uint = self.len();\n-\n-        while lim != 0 {\n-            let ix = base + (lim >> 1);\n-            match f(&self[ix]) {\n-                Equal => return Some(ix),\n-                Less => {\n-                    base = ix + 1;\n-                    lim -= 1;\n-                }\n-                Greater => ()\n-            }\n-            lim >>= 1;\n-        }\n-        return None;\n-    }\n-\n     #[unstable]\n     fn binary_search(&self, f: |&T| -> Ordering) -> BinarySearchResult {\n         let mut base : uint = 0;\n@@ -464,26 +372,6 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n         }\n         return NotFound(base);\n     }\n-\n-    fn shift_ref(&mut self) -> Option<&'a T> {\n-        unsafe {\n-            let s: &mut RawSlice<T> = transmute(self);\n-            match raw::shift_ptr(s) {\n-                Some(p) => Some(&*p),\n-                None => None\n-            }\n-        }\n-    }\n-\n-    fn pop_ref(&mut self) -> Option<&'a T> {\n-        unsafe {\n-            let s: &mut RawSlice<T> = transmute(self);\n-            match raw::pop_ptr(s) {\n-                Some(p) => Some(&*p),\n-                None => None\n-            }\n-        }\n-    }\n }\n \n \n@@ -557,12 +445,6 @@ pub trait MutableSlice<'a, T> {\n     /// Primarily intended for getting a &mut [T] from a [T, ..N].\n     fn as_mut_slice(self) -> &'a mut [T];\n \n-    /// Deprecated: use `slice_mut`.\n-    #[deprecated = \"use slice_mut\"]\n-    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n-        self.slice_mut(start, end)\n-    }\n-\n     /// Returns a mutable subslice spanning the interval [`start`, `end`).\n     ///\n     /// Fails when the end of the new slice lies beyond the end of the\n@@ -572,12 +454,6 @@ pub trait MutableSlice<'a, T> {\n     #[unstable = \"waiting on final error conventions\"]\n     fn slice_mut(self, start: uint, end: uint) -> &'a mut [T];\n \n-    /// Deprecated: use `slice_from_mut`.\n-    #[deprecated = \"use slice_from_mut\"]\n-    fn mut_slice_from(self, start: uint) -> &'a mut [T] {\n-        self.slice_from_mut(start)\n-    }\n-\n     /// Returns a mutable subslice from `start` to the end of the slice.\n     ///\n     /// Fails when `start` is strictly greater than the length of the original slice.\n@@ -586,12 +462,6 @@ pub trait MutableSlice<'a, T> {\n     #[unstable = \"waiting on final error conventions\"]\n     fn slice_from_mut(self, start: uint) -> &'a mut [T];\n \n-    /// Deprecated: use `slice_to_mut`.\n-    #[deprecated = \"use slice_to_mut\"]\n-    fn mut_slice_to(self, end: uint) -> &'a mut [T] {\n-        self.slice_to_mut(end)\n-    }\n-\n     /// Returns a mutable subslice from the start of the slice to `end`.\n     ///\n     /// Fails when `end` is strictly greater than the length of the original slice.\n@@ -600,12 +470,6 @@ pub trait MutableSlice<'a, T> {\n     #[unstable = \"waiting on final error conventions\"]\n     fn slice_to_mut(self, end: uint) -> &'a mut [T];\n \n-    /// Deprecated: use `iter_mut`.\n-    #[deprecated = \"use iter_mut\"]\n-    fn mut_iter(self) -> MutItems<'a, T> {\n-        self.iter_mut()\n-    }\n-\n     /// Returns an iterator that allows modifying each value\n     #[unstable = \"waiting on iterator type name conventions\"]\n     fn iter_mut(self) -> MutItems<'a, T>;\n@@ -622,22 +486,10 @@ pub trait MutableSlice<'a, T> {\n     #[unstable = \"name may change\"]\n     fn init_mut(self) -> &'a mut [T];\n \n-    /// Deprecated: use `last_mut`.\n-    #[deprecated = \"use last_mut\"]\n-    fn mut_last(self) -> Option<&'a mut T> {\n-        self.last_mut()\n-    }\n-\n     /// Returns a mutable pointer to the last item in the slice.\n     #[unstable = \"name may change\"]\n     fn last_mut(self) -> Option<&'a mut T>;\n \n-    /// Deprecated: use `split_mut`.\n-    #[deprecated = \"use split_mut\"]\n-    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T> {\n-        self.split_mut(pred)\n-    }\n-\n     /// Returns an iterator over mutable subslices separated by elements that\n     /// match `pred`.  The matched element is not contained in the subslices.\n     #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n@@ -656,12 +508,6 @@ pub trait MutableSlice<'a, T> {\n     #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n     fn rsplitn_mut(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>>;\n \n-    /// Deprecated: use `chunks_mut`.\n-    #[deprecated = \"use chunks_mut\"]\n-    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T> {\n-        self.chunks_mut(chunk_size)\n-    }\n-\n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n     /// The chunks are mutable and do not overlap. If `chunk_size` does\n     /// not divide the length of the slice, then the last chunk will not\n@@ -673,44 +519,6 @@ pub trait MutableSlice<'a, T> {\n     #[unstable = \"waiting on iterator type name conventions\"]\n     fn chunks_mut(self, chunk_size: uint) -> MutChunks<'a, T>;\n \n-    /**\n-     * Returns a mutable reference to the first element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None; }\n-     *     let head = &mut self[0];\n-     *     *self = self[mut 1..];\n-     *     Some(head)\n-     * ```\n-     *\n-     * Returns `None` if slice is empty\n-     */\n-    #[deprecated = \"use iter_mut\"]\n-    fn mut_shift_ref(&mut self) -> Option<&'a mut T>;\n-\n-    /**\n-     * Returns a mutable reference to the last element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None; }\n-     *     let tail = &mut self[self.len() - 1];\n-     *     *self = self[mut ..self.len() - 1];\n-     *     Some(tail)\n-     * ```\n-     *\n-     * Returns `None` if slice is empty.\n-     */\n-    #[deprecated = \"use iter_mut\"]\n-    fn mut_pop_ref(&mut self) -> Option<&'a mut T>;\n-\n     /// Swaps two elements in a slice.\n     ///\n     /// Fails if `a` or `b` are out of bounds.\n@@ -730,12 +538,6 @@ pub trait MutableSlice<'a, T> {\n     #[unstable = \"waiting on final error conventions\"]\n     fn swap(self, a: uint, b: uint);\n \n-    /// Deprecated: use `split_at_mut`.\n-    #[deprecated = \"use split_at_mut\"]\n-    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n-        self.split_at_mut(mid)\n-    }\n-\n     /// Divides one `&mut` into two at an index.\n     ///\n     /// The first will contain all indices from `[0, mid)` (excluding\n@@ -783,12 +585,6 @@ pub trait MutableSlice<'a, T> {\n     #[experimental = \"may be moved to iterators instead\"]\n     fn reverse(self);\n \n-    /// Deprecated: use `unsafe_mut`.\n-    #[deprecated = \"use unsafe_mut\"]\n-    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T {\n-        self.unsafe_mut(index)\n-    }\n-\n     /// Returns an unsafe mutable pointer to the element in index\n     #[experimental = \"waiting on unsafe conventions\"]\n     unsafe fn unsafe_mut(self, index: uint) -> &'a mut T;\n@@ -803,18 +599,6 @@ pub trait MutableSlice<'a, T> {\n     #[inline]\n     #[unstable]\n     fn as_mut_ptr(self) -> *mut T;\n-\n-    /// Deprecated: use `*foo.as_mut_ptr().offset(index) = val` instead.\n-    #[deprecated = \"use `*foo.as_mut_ptr().offset(index) = val`\"]\n-    unsafe fn unsafe_set(self, index: uint, val: T);\n-\n-    /// Deprecated: use `ptr::write(foo.as_mut_ptr().offset(i), val)` instead.\n-    #[deprecated = \"use `ptr::write(foo.as_mut_ptr().offset(i), val)`\"]\n-    unsafe fn init_elem(self, i: uint, val: T);\n-\n-    /// Deprecated: use `as_mut_ptr` and `ptr::copy_memory` instead.\n-    #[deprecated = \"use as_mut_ptr and ptr::copy_memory\"]\n-    unsafe fn copy_memory(self, src: &[T]);\n }\n \n #[experimental = \"trait is experimental\"]\n@@ -920,30 +704,6 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n         MutChunks { v: self, chunk_size: chunk_size }\n     }\n \n-    fn mut_shift_ref(&mut self) -> Option<&'a mut T> {\n-        unsafe {\n-            let s: &mut RawSlice<T> = transmute(self);\n-            match raw::shift_ptr(s) {\n-                // FIXME #13933: this `&` -> `&mut` cast is a little\n-                // dubious\n-                Some(p) => Some(&mut *(p as *mut _)),\n-                None => None,\n-            }\n-        }\n-    }\n-\n-    fn mut_pop_ref(&mut self) -> Option<&'a mut T> {\n-        unsafe {\n-            let s: &mut RawSlice<T> = transmute(self);\n-            match raw::pop_ptr(s) {\n-                // FIXME #13933: this `&` -> `&mut` cast is a little\n-                // dubious\n-                Some(p) => Some(&mut *(p as *mut _)),\n-                None => None,\n-            }\n-        }\n-    }\n-\n     fn swap(self, a: uint, b: uint) {\n         unsafe {\n             // Can't take two mutable loans from one vector, so instead just cast\n@@ -977,23 +737,6 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n     fn as_mut_ptr(self) -> *mut T {\n         self.repr().data as *mut T\n     }\n-\n-    #[inline]\n-    unsafe fn unsafe_set(self, index: uint, val: T) {\n-        *self.unsafe_mut(index) = val;\n-    }\n-\n-    #[inline]\n-    unsafe fn init_elem(self, i: uint, val: T) {\n-        ptr::write(&mut (*self.as_mut_ptr().offset(i as int)), val);\n-    }\n-\n-    #[inline]\n-    unsafe fn copy_memory(self, src: &[T]) {\n-        let len_src = src.len();\n-        assert!(self.len() >= len_src);\n-        ptr::copy_nonoverlapping_memory(self.as_mut_ptr(), src.as_ptr(), len_src)\n-    }\n }\n \n /// Extension methods for slices containing `PartialEq` elements.\n@@ -1048,10 +791,6 @@ impl<'a,T:PartialEq> ImmutablePartialEqSlice<T> for &'a [T] {\n /// Extension methods for slices containing `Ord` elements.\n #[unstable = \"may merge with other traits\"]\n pub trait ImmutableOrdSlice<T: Ord> {\n-    /// Deprecated: use `binary_search_elem`.\n-    #[deprecated = \"use binary_search_elem\"]\n-    fn bsearch_elem(&self, x: &T) -> Option<uint>;\n-\n     /// Binary search a sorted slice for a given element.\n     ///\n     /// If the value is found then `Found` is returned, containing the\n@@ -1082,12 +821,6 @@ pub trait ImmutableOrdSlice<T: Ord> {\n \n #[unstable = \"trait is unstable\"]\n impl<'a, T: Ord> ImmutableOrdSlice<T> for &'a [T] {\n-    #[deprecated = \"use binary_search_elem\"]\n-    #[allow(deprecated)]\n-    fn bsearch_elem(&self, x: &T) -> Option<uint> {\n-        self.bsearch(|p| p.cmp(x))\n-    }\n-\n     #[unstable]\n     fn binary_search_elem(&self, x: &T) -> BinarySearchResult {\n         self.binary_search(|p| p.cmp(x))\n@@ -1097,12 +830,6 @@ impl<'a, T: Ord> ImmutableOrdSlice<T> for &'a [T] {\n /// Trait for &[T] where T is Cloneable\n #[unstable = \"may merge with other traits\"]\n pub trait MutableCloneableSlice<T> {\n-    /// Copies as many elements from `src` as it can into `self` (the\n-    /// shorter of `self.len()` and `src.len()`). Returns the number\n-    /// of elements copied.\n-    #[deprecated = \"renamed to clone_from_slice\"]\n-    fn copy_from(self, s: &[T]) -> uint { self.clone_from_slice(s) }\n-\n     /// Copies as many elements from `src` as it can into `self` (the\n     /// shorter of `self.len()` and `src.len()`). Returns the number\n     /// of elements copied.\n@@ -1780,7 +1507,7 @@ pub mod raw {\n pub mod bytes {\n     use collections::Collection;\n     use ptr;\n-    use slice::MutableSlice;\n+    use slice::{ImmutableSlice, MutableSlice};\n \n     /// A trait for operations on mutable `[u8]`s.\n     pub trait MutableByteVector {\n@@ -1801,10 +1528,14 @@ pub mod bytes {\n     /// `src` and `dst` must not overlap. Fails if the length of `dst`\n     /// is less than the length of `src`.\n     #[inline]\n-    #[allow(deprecated)]\n     pub fn copy_memory(dst: &mut [u8], src: &[u8]) {\n-        // Bound checks are done at .copy_memory.\n-        unsafe { dst.copy_memory(src) }\n+        let len_src = src.len();\n+        assert!(dst.len() >= len_src);\n+        unsafe {\n+            ptr::copy_nonoverlapping_memory(dst.as_mut_ptr(),\n+                                            src.as_ptr(),\n+                                            len_src);\n+        }\n     }\n }\n "}, {"sha": "59ce73fe40da5c3f13a81f9fd00f9323da6358fd", "filename": "src/libcoretest/cmp.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcoretest%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcoretest%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcmp.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::cmp::lexical_ordering;\n use core::cmp::{ partial_min, partial_max };\n \n #[test]\n@@ -42,21 +41,6 @@ fn test_ordering_order() {\n     assert_eq!(Greater.cmp(&Less), Greater);\n }\n \n-#[test]\n-#[allow(deprecated)]\n-fn test_lexical_ordering() {\n-    fn t(o1: Ordering, o2: Ordering, e: Ordering) {\n-        assert_eq!(lexical_ordering(o1, o2), e);\n-    }\n-\n-    let xs = [Less, Equal, Greater];\n-    for &o in xs.iter() {\n-        t(Less, o, Less);\n-        t(Equal, o, o);\n-        t(Greater, o, Greater);\n-     }\n-}\n-\n #[test]\n fn test_partial_min() {\n     use core::f64::NAN;"}, {"sha": "71e9270fe4b0cba6df22453a51f7f3533e51477e", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 6, "deletions": 47, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -130,21 +130,6 @@ fn test_or_else() {\n     assert_eq!(x.or_else(|| None), None);\n }\n \n-#[test]\n-#[allow(deprecated)]\n-fn test_option_while_some() {\n-    let mut i = 0i;\n-    Some(10i).while_some(|j| {\n-        i += 1;\n-        if j > 0 {\n-            Some(j-1)\n-        } else {\n-            None\n-        }\n-    });\n-    assert_eq!(i, 11);\n-}\n-\n #[test]\n fn test_unwrap() {\n     assert_eq!(Some(1i).unwrap(), 1);\n@@ -184,15 +169,6 @@ fn test_unwrap_or_else() {\n     assert_eq!(x.unwrap_or_else(|| 2), 2);\n }\n \n-#[test]\n-#[allow(deprecated)]\n-fn test_filtered() {\n-    let some_stuff = Some(42i);\n-    let modified_stuff = some_stuff.filtered(|&x| {x < 10});\n-    assert_eq!(some_stuff.unwrap(), 42);\n-    assert!(modified_stuff.is_none());\n-}\n-\n #[test]\n fn test_iter() {\n     let val = 5i;\n@@ -244,39 +220,22 @@ fn test_ord() {\n }\n \n #[test]\n-#[allow(deprecated)]\n-fn test_mutate() {\n-    let mut x = Some(3i);\n-    assert!(x.mutate(|i| i+1));\n-    assert_eq!(x, Some(4i));\n-    assert!(x.mutate_or_set(0, |i| i+1));\n-    assert_eq!(x, Some(5i));\n-    x = None;\n-    assert!(!x.mutate(|i| i+1));\n-    assert_eq!(x, None);\n-    assert!(!x.mutate_or_set(0i, |i| i+1));\n-    assert_eq!(x, Some(0i));\n-}\n-\n-#[test]\n-#[allow(deprecated)]\n fn test_collect() {\n-    let v: Option<Vec<int>> = collect(range(0i, 0)\n-                                      .map(|_| Some(0i)));\n+    let v: Option<Vec<int>> = range(0i, 0).map(|_| Some(0i)).collect();\n     assert!(v == Some(vec![]));\n \n-    let v: Option<Vec<int>> = collect(range(0i, 3)\n-                                      .map(|x| Some(x)));\n+    let v: Option<Vec<int>> = range(0i, 3).map(|x| Some(x)).collect();\n     assert!(v == Some(vec![0, 1, 2]));\n \n-    let v: Option<Vec<int>> = collect(range(0i, 3)\n-                                      .map(|x| if x > 1 { None } else { Some(x) }));\n+    let v: Option<Vec<int>> = range(0i, 3).map(|x| {\n+        if x > 1 { None } else { Some(x) }\n+    }).collect();\n     assert!(v == None);\n \n     // test that it does not take more elements than it needs\n     let mut functions = [|| Some(()), || None, || fail!()];\n \n-    let v: Option<Vec<()>> = collect(functions.iter_mut().map(|f| (*f)()));\n+    let v: Option<Vec<()>> = functions.iter_mut().map(|f| (*f)()).collect();\n \n     assert!(v == None);\n }"}, {"sha": "db3580e5d0c4252aff037326eac8f7bd0ad6afd8", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 13, "deletions": 119, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -7,12 +7,9 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![allow(deprecated)]\n+\n use core::ptr::*;\n-use libc::c_char;\n use core::mem;\n-use libc;\n-use std::c_str::CString;\n \n #[test]\n fn test() {\n@@ -39,49 +36,22 @@ fn test() {\n \n         copy_memory(v1.as_mut_ptr().offset(1),\n                     v0.as_ptr().offset(1), 1);\n-        assert!((*v1.get(0) == 0u16 &&\n-                 *v1.get(1) == 32001u16 &&\n-                 *v1.get(2) == 0u16));\n+        assert!((v1[0] == 0u16 &&\n+                 v1[1] == 32001u16 &&\n+                 v1[2] == 0u16));\n         copy_memory(v1.as_mut_ptr(),\n                     v0.as_ptr().offset(2), 1);\n-        assert!((*v1.get(0) == 32002u16 &&\n-                 *v1.get(1) == 32001u16 &&\n-                 *v1.get(2) == 0u16));\n+        assert!((v1[0] == 32002u16 &&\n+                 v1[1] == 32001u16 &&\n+                 v1[2] == 0u16));\n         copy_memory(v1.as_mut_ptr().offset(2),\n                     v0.as_ptr(), 1u);\n-        assert!((*v1.get(0) == 32002u16 &&\n-                 *v1.get(1) == 32001u16 &&\n-                 *v1.get(2) == 32000u16));\n+        assert!((v1[0] == 32002u16 &&\n+                 v1[1] == 32001u16 &&\n+                 v1[2] == 32000u16));\n     }\n }\n \n-#[test]\n-fn test_position() {\n-    use libc::c_char;\n-\n-    \"hello\".with_c_str(|p| {\n-        unsafe {\n-            assert!(2u == position(p, |c| *c == 'l' as c_char));\n-            assert!(4u == position(p, |c| *c == 'o' as c_char));\n-            assert!(5u == position(p, |c| *c == 0 as c_char));\n-        }\n-    })\n-}\n-\n-#[test]\n-fn test_buf_len() {\n-    \"hello\".with_c_str(|p0| {\n-        \"there\".with_c_str(|p1| {\n-            \"thing\".with_c_str(|p2| {\n-                let v = vec![p0, p1, p2, null()];\n-                unsafe {\n-                    assert_eq!(buf_len(v.as_ptr()), 3u);\n-                }\n-            })\n-        })\n-    })\n-}\n-\n #[test]\n fn test_is_null() {\n     let p: *const int = null();\n@@ -92,7 +62,7 @@ fn test_is_null() {\n     assert!(!q.is_null());\n     assert!(q.is_not_null());\n \n-    let mp: *mut int = mut_null();\n+    let mp: *mut int = null_mut();\n     assert!(mp.is_null());\n     assert!(!mp.is_not_null());\n \n@@ -110,7 +80,7 @@ fn test_as_ref() {\n         let q: *const int = &2;\n         assert_eq!(q.as_ref().unwrap(), &2);\n \n-        let p: *mut int = mut_null();\n+        let p: *mut int = null_mut();\n         assert_eq!(p.as_ref(), None);\n \n         let q: *mut int = &mut 2;\n@@ -128,7 +98,7 @@ fn test_as_ref() {\n #[test]\n fn test_as_mut() {\n     unsafe {\n-        let p: *mut int = mut_null();\n+        let p: *mut int = null_mut();\n         assert!(p.as_mut() == None);\n \n         let q: *mut int = &mut 2;\n@@ -193,82 +163,6 @@ fn test_ptr_subtraction() {\n     }\n }\n \n-#[test]\n-fn test_ptr_array_each_with_len() {\n-    unsafe {\n-        let one = \"oneOne\".to_c_str();\n-        let two = \"twoTwo\".to_c_str();\n-        let three = \"threeThree\".to_c_str();\n-        let arr = vec![\n-            one.as_ptr(),\n-            two.as_ptr(),\n-            three.as_ptr()\n-        ];\n-        let expected_arr = [\n-            one, two, three\n-        ];\n-\n-        let mut ctr = 0;\n-        let mut iteration_count = 0;\n-        array_each_with_len(arr.as_ptr(), arr.len(), |e| {\n-                let actual = CString::new(e, false);\n-                assert_eq!(actual.as_str(), expected_arr[ctr].as_str());\n-                ctr += 1;\n-                iteration_count += 1;\n-            });\n-        assert_eq!(iteration_count, 3u);\n-    }\n-}\n-\n-#[test]\n-fn test_ptr_array_each() {\n-    unsafe {\n-        let one = \"oneOne\".to_c_str();\n-        let two = \"twoTwo\".to_c_str();\n-        let three = \"threeThree\".to_c_str();\n-        let arr = vec![\n-            one.as_ptr(),\n-            two.as_ptr(),\n-            three.as_ptr(),\n-            // fake a null terminator\n-            null()\n-        ];\n-        let expected_arr = [\n-            one, two, three\n-        ];\n-\n-        let arr_ptr = arr.as_ptr();\n-        let mut ctr = 0u;\n-        let mut iteration_count = 0u;\n-        array_each(arr_ptr, |e| {\n-                let actual = CString::new(e, false);\n-                assert_eq!(actual.as_str(), expected_arr[ctr].as_str());\n-                ctr += 1;\n-                iteration_count += 1;\n-            });\n-        assert_eq!(iteration_count, 3);\n-    }\n-}\n-\n-#[test]\n-#[should_fail]\n-fn test_ptr_array_each_with_len_null_ptr() {\n-    unsafe {\n-        array_each_with_len(0 as *const *const libc::c_char, 1, |e| {\n-            CString::new(e, false).as_str().unwrap();\n-        });\n-    }\n-}\n-#[test]\n-#[should_fail]\n-fn test_ptr_array_each_null_ptr() {\n-    unsafe {\n-        array_each(0 as *const *const libc::c_char, |e| {\n-            CString::new(e, false).as_str().unwrap();\n-        });\n-    }\n-}\n-\n #[test]\n fn test_set_memory() {\n     let mut xs = [0u8, ..20];"}, {"sha": "1cb72bd9eac78b3cca4d5def36e2602a4fe928e8", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 6, "deletions": 29, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::result::{collect, fold, fold_};\n use core::iter::range;\n \n pub fn op1() -> Result<int, &'static str> { Ok(666) }\n@@ -69,47 +68,25 @@ pub fn test_impl_map_err() {\n }\n \n #[test]\n-#[allow(deprecated)]\n fn test_collect() {\n-    let v: Result<Vec<int>, ()> = collect(range(0i, 0).map(|_| Ok::<int, ()>(0)));\n+    let v: Result<Vec<int>, ()> = range(0i, 0).map(|_| Ok::<int, ()>(0)).collect();\n     assert!(v == Ok(vec![]));\n \n-    let v: Result<Vec<int>, ()> = collect(range(0i, 3).map(|x| Ok::<int, ()>(x)));\n+    let v: Result<Vec<int>, ()> = range(0i, 3).map(|x| Ok::<int, ()>(x)).collect();\n     assert!(v == Ok(vec![0, 1, 2]));\n \n-    let v: Result<Vec<int>, int> = collect(range(0i, 3)\n-                                           .map(|x| if x > 1 { Err(x) } else { Ok(x) }));\n+    let v: Result<Vec<int>, int> = range(0i, 3).map(|x| {\n+        if x > 1 { Err(x) } else { Ok(x) }\n+    }).collect();\n     assert!(v == Err(2));\n \n     // test that it does not take more elements than it needs\n     let mut functions = [|| Ok(()), || Err(1i), || fail!()];\n \n-    let v: Result<Vec<()>, int> = collect(functions.iter_mut().map(|f| (*f)()));\n+    let v: Result<Vec<()>, int> = functions.iter_mut().map(|f| (*f)()).collect();\n     assert!(v == Err(1));\n }\n \n-#[test]\n-#[allow(deprecated)] // we know fold_ is deprecated\n-fn test_fold() {\n-    assert_eq!(fold_(range(0i, 0)\n-                    .map(|_| Ok::<(), ()>(()))),\n-               Ok(()));\n-    assert_eq!(fold(range(0i, 3)\n-                    .map(|x| Ok::<int, ()>(x)),\n-                    0, |a, b| a + b),\n-               Ok(3));\n-    assert_eq!(fold_(range(0i, 3)\n-                    .map(|x| if x > 1 { Err(x) } else { Ok(()) })),\n-               Err(2));\n-\n-    // test that it does not take more elements than it needs\n-    let mut functions = [|| Ok(()), || Err(1i), || fail!()];\n-\n-    assert_eq!(fold_(functions.iter_mut()\n-                    .map(|f| (*f)())),\n-               Err(1));\n-}\n-\n #[test]\n pub fn test_fmt_default() {\n     let ok: Result<int, &'static str> = Ok(100);"}, {"sha": "c7659dc1b9fd7f9cee21308cabd9aa37ed45255e", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -127,14 +127,6 @@ impl<'a,T:Clone> CloneableVector<T> for MaybeOwnedVector<'a,T> {\n     fn to_vec(&self) -> Vec<T> {\n         self.as_slice().to_vec()\n     }\n-\n-    /// Convert `self` into an owned slice, not making a copy if possible.\n-    fn into_vec(self) -> Vec<T> {\n-        match self {\n-            Growable(v) => v.as_slice().to_vec(),\n-            Borrowed(v) => v.to_vec(),\n-        }\n-    }\n }\n \n impl<'a, T: Clone> Clone for MaybeOwnedVector<'a, T> {"}, {"sha": "b592ba477c2a16bfcdfafce0246306c305db35e4", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -89,7 +89,7 @@ impl BasicLoop {\n     fn idle(&mut self) {\n         match self.idle {\n             Some(ref mut idle) => {\n-                if self.idle_active.get_ref().load(atomic::SeqCst) {\n+                if self.idle_active.as_ref().unwrap().load(atomic::SeqCst) {\n                     idle.call();\n                 }\n             }\n@@ -98,7 +98,7 @@ impl BasicLoop {\n     }\n \n     fn has_idle(&self) -> bool {\n-        self.idle.is_some() && self.idle_active.get_ref().load(atomic::SeqCst)\n+        self.idle.is_some() && self.idle_active.as_ref().unwrap().load(atomic::SeqCst)\n     }\n }\n "}, {"sha": "6ba29cf5a3d7ef898a6c3e75b0fee722d7a84791", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -193,7 +193,7 @@ impl Scheduler {\n         // Before starting our first task, make sure the idle callback\n         // is active. As we do not start in the sleep state this is\n         // important.\n-        self.idle_callback.get_mut_ref().resume();\n+        self.idle_callback.as_mut().unwrap().resume();\n \n         // Now, as far as all the scheduler state is concerned, we are inside\n         // the \"scheduler\" context. The scheduler immediately hands over control\n@@ -213,10 +213,10 @@ impl Scheduler {\n         // cleaning up the memory it uses. As we didn't actually call\n         // task.run() on the scheduler task we never get through all\n         // the cleanup code it runs.\n-        rtdebug!(\"stopping scheduler {}\", stask.sched.get_ref().sched_id());\n+        rtdebug!(\"stopping scheduler {}\", stask.sched.as_ref().unwrap().sched_id());\n \n         // Should not have any messages\n-        let message = stask.sched.get_mut_ref().message_queue.pop();\n+        let message = stask.sched.as_mut().unwrap().message_queue.pop();\n         rtassert!(match message { msgq::Empty => true, _ => false });\n \n         stask.task.take().unwrap().drop();\n@@ -279,7 +279,7 @@ impl Scheduler {\n \n         // Assume that we need to continue idling unless we reach the\n         // end of this function without performing an action.\n-        self.idle_callback.get_mut_ref().resume();\n+        self.idle_callback.as_mut().unwrap().resume();\n \n         // First we check for scheduler messages, these are higher\n         // priority than regular tasks.\n@@ -333,12 +333,12 @@ impl Scheduler {\n             let handle = sched.make_handle();\n             sched.sleeper_list.push(handle);\n             // Since we are sleeping, deactivate the idle callback.\n-            sched.idle_callback.get_mut_ref().pause();\n+            sched.idle_callback.as_mut().unwrap().pause();\n         } else {\n             rtdebug!(\"not sleeping, already doing so or no_sleep set\");\n             // We may not be sleeping, but we still need to deactivate\n             // the idle callback.\n-            sched.idle_callback.get_mut_ref().pause();\n+            sched.idle_callback.as_mut().unwrap().pause();\n         }\n \n         // Finished a cycle without using the Scheduler. Place it back\n@@ -633,7 +633,7 @@ impl Scheduler {\n         unsafe {\n \n             let sched: &mut Scheduler =\n-                mem::transmute(&**next_task.sched.get_mut_ref());\n+                mem::transmute(&**next_task.sched.as_mut().unwrap());\n \n             let current_task: &mut GreenTask = match sched.cleanup_job {\n                 Some(CleanupJob { task: ref mut task, .. }) => &mut **task,\n@@ -661,7 +661,7 @@ impl Scheduler {\n         let mut current_task: Box<GreenTask> = unsafe {\n             mem::transmute(current_task_dupe)\n         };\n-        current_task.sched.get_mut_ref().run_cleanup_job();\n+        current_task.sched.as_mut().unwrap().run_cleanup_job();\n \n         // See the comments in switch_running_tasks_and_then for why a lock\n         // is acquired here. This is the resumption points and the \"bounce\"\n@@ -682,9 +682,9 @@ impl Scheduler {\n         -> (&'a mut Context, &'a mut Context)\n     {\n         let current_task_context =\n-            &mut current_task.coroutine.get_mut_ref().saved_context;\n+            &mut current_task.coroutine.as_mut().unwrap().saved_context;\n         let next_task_context =\n-                &mut next_task.coroutine.get_mut_ref().saved_context;\n+                &mut next_task.coroutine.as_mut().unwrap().saved_context;\n         unsafe {\n             (mem::transmute(current_task_context),\n              mem::transmute(next_task_context))\n@@ -1050,7 +1050,7 @@ mod test {\n         let mut task = Local::borrow(None::<Task>);\n         match task.maybe_take_runtime::<GreenTask>() {\n             Some(green) => {\n-                let ret = green.sched.get_ref().sched_id();\n+                let ret = green.sched.as_ref().unwrap().sched_id();\n                 task.put_runtime(green);\n                 return ret;\n             }\n@@ -1190,8 +1190,8 @@ mod test {\n             fn on_appropriate_sched() -> bool {\n                 use task::{TypeGreen, TypeSched, HomeSched};\n                 let task = GreenTask::convert(Local::take());\n-                let sched_id = task.sched.get_ref().sched_id();\n-                let run_any = task.sched.get_ref().run_anything;\n+                let sched_id = task.sched.as_ref().unwrap().sched_id();\n+                let run_any = task.sched.as_ref().unwrap().run_anything;\n                 let ret = match task.task_type {\n                     TypeGreen(Some(AnySched)) => {\n                         run_any"}, {"sha": "b6bd8c3cec4a735d315cb425cab6450cb2417956", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -100,7 +100,7 @@ extern fn bootstrap_green_task(task: uint, code: *mut (), env: *mut ()) -> ! {\n \n     // First code after swap to this new context. Run our cleanup job\n     task.pool_id = {\n-        let sched = task.sched.get_mut_ref();\n+        let sched = task.sched.as_mut().unwrap();\n         sched.run_cleanup_job();\n         sched.task_state.increment();\n         sched.pool_id\n@@ -179,7 +179,7 @@ impl GreenTask {\n \n         let mut green = GreenTask::new(pool, stack_size, f);\n         {\n-            let task = green.task.get_mut_ref();\n+            let task = green.task.as_mut().unwrap();\n             task.name = name;\n             task.death.on_exit = on_exit;\n         }\n@@ -314,7 +314,7 @@ impl GreenTask {\n     fn reawaken_remotely(mut self: Box<GreenTask>) {\n         unsafe {\n             let mtx = &mut self.nasty_deschedule_lock as *mut NativeMutex;\n-            let handle = self.handle.get_mut_ref() as *mut SchedHandle;\n+            let handle = self.handle.as_mut().unwrap() as *mut SchedHandle;\n             let _guard = (*mtx).lock();\n             (*handle).send(RunOnce(self));\n         }\n@@ -460,7 +460,7 @@ impl Runtime for GreenTask {\n         //\n         // Upon returning, our task is back in TLS and we're good to return.\n         let sibling = {\n-            let sched = bomb.inner.get_mut_ref().sched.get_mut_ref();\n+            let sched = bomb.inner.as_mut().unwrap().sched.as_mut().unwrap();\n             GreenTask::configure(&mut sched.stack_pool, opts, f)\n         };\n         let mut me = bomb.inner.take().unwrap();\n@@ -470,7 +470,7 @@ impl Runtime for GreenTask {\n \n     // Local I/O is provided by the scheduler's event loop\n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> {\n-        match self.sched.get_mut_ref().event_loop.io() {\n+        match self.sched.as_mut().unwrap().event_loop.io() {\n             Some(io) => Some(rtio::LocalIo::new(io)),\n             None => None,\n         }"}, {"sha": "d40438e4272a3bd0f69892b7e8537d3938cb803c", "filename": "src/libnative/io/addrinfo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -11,7 +11,7 @@\n use libc::{c_char, c_int};\n use libc;\n use std::mem;\n-use std::ptr::{null, mut_null};\n+use std::ptr::{null, null_mut};\n use std::rt::rtio;\n use std::rt::rtio::IoError;\n \n@@ -38,16 +38,16 @@ impl GetAddrInfoRequest {\n                 ai_socktype: 0,\n                 ai_protocol: 0,\n                 ai_addrlen: 0,\n-                ai_canonname: mut_null(),\n-                ai_addr: mut_null(),\n-                ai_next: mut_null()\n+                ai_canonname: null_mut(),\n+                ai_addr: null_mut(),\n+                ai_next: null_mut()\n             }\n         });\n \n         let hint_ptr = hint.as_ref().map_or(null(), |x| {\n             x as *const libc::addrinfo\n         });\n-        let mut res = mut_null();\n+        let mut res = null_mut();\n \n         // Make the call\n         let s = unsafe {"}, {"sha": "eed3df28b8f33885e260b2761d1a84dd2519dcf5", "filename": "src/libnative/io/c_windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Fio%2Fc_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Fio%2Fc_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_windows.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -141,8 +141,8 @@ pub mod compat {\n     // layer (after it's loaded) shouldn't be any slower than a regular DLL\n     // call.\n     unsafe fn store_func(ptr: *mut uint, module: &str, symbol: &str, fallback: uint) {\n-        let module: Vec<u16> = module.utf16_units().collect();\n-        let module = module.append_one(0);\n+        let mut module: Vec<u16> = module.utf16_units().collect();\n+        module.push(0);\n         symbol.with_c_str(|symbol| {\n             let handle = GetModuleHandleW(module.as_ptr());\n             let func: uint = transmute(GetProcAddress(handle, symbol));"}, {"sha": "eb4d4f22132d08ed2237150d40fe6e4909c960a1", "filename": "src/libnative/io/file_windows.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Fio%2Ffile_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Fio%2Ffile_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_windows.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -253,7 +253,11 @@ impl Drop for Inner {\n \n pub fn to_utf16(s: &CString) -> IoResult<Vec<u16>> {\n     match s.as_str() {\n-        Some(s) => Ok(s.utf16_units().collect::<Vec<u16>>().append_one(0)),\n+        Some(s) => Ok({\n+            let mut s = s.utf16_units().collect::<Vec<u16>>();\n+            s.push(0);\n+            s\n+        }),\n         None => Err(IoError {\n             code: libc::ERROR_INVALID_NAME as uint,\n             extra: 0,"}, {"sha": "d1368ad31f475336b27f9c77d246d5e2a19eb2f9", "filename": "src/libnative/io/helper_thread.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Fio%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Fio%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fhelper_thread.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -22,13 +22,14 @@\n \n #![macro_escape]\n \n+use std::cell::UnsafeCell;\n use std::mem;\n use std::rt::bookkeeping;\n use std::rt::mutex::StaticNativeMutex;\n use std::rt;\n-use std::cell::UnsafeCell;\n+use std::task::TaskBuilder;\n \n-use task;\n+use NativeTaskBuilder;\n \n /// A structure for management of a helper thread.\n ///\n@@ -86,7 +87,7 @@ impl<M: Send> Helper<M> {\n                 *self.signal.get() = send as uint;\n \n                 let t = f();\n-                task::spawn(proc() {\n+                TaskBuilder::new().native().spawn(proc() {\n                     bookkeeping::decrement();\n                     helper(receive, rx, t);\n                     self.lock.lock().signal()"}, {"sha": "bc08ede39f7695ec80accd63bb11ea6c1a34b397", "filename": "src/libnative/io/pipe_windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Fio%2Fpipe_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Fio%2Fpipe_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_windows.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -359,7 +359,7 @@ impl rtio::RtioPipe for UnixStream {\n \n         let mut bytes_read = 0;\n         let mut overlapped: libc::OVERLAPPED = unsafe { mem::zeroed() };\n-        overlapped.hEvent = self.read.get_ref().handle();\n+        overlapped.hEvent = self.read.as_ref().unwrap().handle();\n \n         // Pre-flight check to see if the reading half has been closed. This\n         // must be done before issuing the ReadFile request, but after we\n@@ -431,7 +431,7 @@ impl rtio::RtioPipe for UnixStream {\n \n         let mut offset = 0;\n         let mut overlapped: libc::OVERLAPPED = unsafe { mem::zeroed() };\n-        overlapped.hEvent = self.write.get_ref().handle();\n+        overlapped.hEvent = self.write.as_ref().unwrap().handle();\n \n         while offset < buf.len() {\n             let mut bytes_written = 0;"}, {"sha": "b94d81cff95b8f9b9e6208ca88e1d3ba94493681", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -350,8 +350,8 @@ fn spawn_process_os(cfg: ProcessConfig,\n                         lpSecurityDescriptor: ptr::null_mut(),\n                         bInheritHandle: 1,\n                     };\n-                    let filename: Vec<u16> = \"NUL\".utf16_units().collect();\n-                    let filename = filename.append_one(0);\n+                    let mut filename: Vec<u16> = \"NUL\".utf16_units().collect();\n+                    filename.push(0);\n                     *slot = libc::CreateFileW(filename.as_ptr(),\n                                               access,\n                                               libc::FILE_SHARE_READ |\n@@ -396,7 +396,7 @@ fn spawn_process_os(cfg: ProcessConfig,\n         with_envp(cfg.env, |envp| {\n             with_dirp(cfg.cwd, |dirp| {\n                 let mut cmd_str: Vec<u16> = cmd_str.as_slice().utf16_units().collect();\n-                cmd_str = cmd_str.append_one(0);\n+                cmd_str.push(0);\n                 let created = CreateProcessW(ptr::null(),\n                                              cmd_str.as_mut_ptr(),\n                                              ptr::null_mut(),\n@@ -473,7 +473,7 @@ fn make_command_line(prog: &CString, args: &[CString]) -> String {\n     append_arg(&mut cmd, prog.as_str()\n                              .expect(\"expected program name to be utf-8 encoded\"));\n     for arg in args.iter() {\n-        cmd.push_char(' ');\n+        cmd.push(' ');\n         append_arg(&mut cmd, arg.as_str()\n                                 .expect(\"expected argument to be utf-8 encoded\"));\n     }\n@@ -485,14 +485,14 @@ fn make_command_line(prog: &CString, args: &[CString]) -> String {\n         // it will be dropped entirely when parsed on the other end.\n         let quote = arg.chars().any(|c| c == ' ' || c == '\\t') || arg.len() == 0;\n         if quote {\n-            cmd.push_char('\"');\n+            cmd.push('\"');\n         }\n         let argvec: Vec<char> = arg.chars().collect();\n         for i in range(0u, argvec.len()) {\n             append_char_at(cmd, &argvec, i);\n         }\n         if quote {\n-            cmd.push_char('\"');\n+            cmd.push('\"');\n         }\n     }\n \n@@ -508,11 +508,11 @@ fn make_command_line(prog: &CString, args: &[CString]) -> String {\n                     cmd.push_str(\"\\\\\\\\\");\n                 } else {\n                     // Pass other backslashes through unescaped.\n-                    cmd.push_char('\\\\');\n+                    cmd.push('\\\\');\n                 }\n             }\n             c => {\n-                cmd.push_char(c);\n+                cmd.push(c);\n             }\n         }\n     }\n@@ -817,9 +817,8 @@ fn with_dirp<T>(d: Option<&CString>, cb: |*const u16| -> T) -> T {\n       Some(dir) => {\n           let dir_str = dir.as_str()\n                            .expect(\"expected workingdirectory to be utf-8 encoded\");\n-          let dir_str: Vec<u16> = dir_str.utf16_units().collect();\n-          let dir_str = dir_str.append_one(0);\n-\n+          let mut dir_str: Vec<u16> = dir_str.utf16_units().collect();\n+          dir_str.push(0);\n           cb(dir_str.as_ptr())\n       },\n       None => cb(ptr::null())"}, {"sha": "6f57a5e88ba14f1c337cd0a9a26417b18d31cdea", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -115,7 +115,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n     // signals the first requests in the queue, possible re-enqueueing it.\n     fn signal(active: &mut Vec<Box<Inner>>,\n               dead: &mut Vec<(uint, Box<Inner>)>) {\n-        let mut timer = match active.shift() {\n+        let mut timer = match active.remove(0) {\n             Some(timer) => timer, None => return\n         };\n         let mut cb = timer.cb.take().unwrap();\n@@ -137,15 +137,15 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n             let now = now();\n             // If this request has already expired, then signal it and go\n             // through another iteration\n-            if active.get(0).target <= now {\n+            if active[0].target <= now {\n                 signal(&mut active, &mut dead);\n                 continue;\n             }\n \n             // The actual timeout listed in the requests array is an\n             // absolute date, so here we translate the absolute time to a\n             // relative time.\n-            let tm = active.get(0).target - now;\n+            let tm = active[0].target - now;\n             timeout.tv_sec = (tm / 1000) as libc::time_t;\n             timeout.tv_usec = ((tm % 1000) * 1000) as libc::suseconds_t;\n             &mut timeout as *mut libc::timeval"}, {"sha": "cf2a0f9dda444d93cf1d4c566113ddcd5f72953e", "filename": "src/libnative/io/tty_windows.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Fio%2Ftty_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Fio%2Ftty_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftty_windows.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -36,7 +36,7 @@ use libc::types::os::arch::extra::LPCVOID;\n use std::io::MemReader;\n use std::ptr;\n use std::rt::rtio::{IoResult, IoError, RtioTTY};\n-use std::str::{from_utf16, from_utf8};\n+use std::str::from_utf8;\n \n fn invalid_encoding() -> IoError {\n     IoError {\n@@ -103,7 +103,7 @@ impl RtioTTY for WindowsTTY {\n                 _ => (),\n             };\n             utf16.truncate(num as uint);\n-            let utf8 = match from_utf16(utf16.as_slice()) {\n+            let utf8 = match String::from_utf16(utf16.as_slice()) {\n                 Some(utf8) => utf8.into_bytes(),\n                 None => return Err(invalid_encoding()),\n             };\n@@ -115,7 +115,9 @@ impl RtioTTY for WindowsTTY {\n \n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let utf16 = match from_utf8(buf) {\n-            Some(utf8) => utf8.to_utf16(),\n+            Some(utf8) => {\n+                utf8.as_slice().utf16_units().collect::<Vec<u16>>()\n+            }\n             None => return Err(invalid_encoding()),\n         };\n         let mut num: DWORD = 0;"}, {"sha": "656c7e4103c6eb29d0281b3de3625153f3addca8", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -56,7 +56,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![deny(unused_result, unused_must_use)]\n-#![allow(non_camel_case_types, deprecated)]\n+#![allow(non_camel_case_types)]\n #![allow(unknown_features)]\n #![feature(default_type_params, lang_items, slicing_syntax)]\n "}, {"sha": "48e2c440dfc7b2cd0aaeface25a353a8697c784a", "filename": "src/libnative/task.rs", "status": "modified", "additions": 44, "deletions": 56, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -26,7 +26,6 @@ use std::rt::thread::Thread;\n use std::rt;\n \n use io;\n-use task;\n use std::task::{TaskBuilder, Spawner};\n \n /// Creates a new Task which is ready to execute as a 1:1 task.\n@@ -48,61 +47,49 @@ fn ops() -> Box<Ops> {\n     }\n }\n \n-/// Spawns a function with the default configuration\n-#[deprecated = \"use the native method of NativeTaskBuilder instead\"]\n-pub fn spawn(f: proc():Send) {\n-    spawn_opts(TaskOpts { name: None, stack_size: None, on_exit: None }, f)\n-}\n-\n-/// Spawns a new task given the configuration options and a procedure to run\n-/// inside the task.\n-#[deprecated = \"use the native method of NativeTaskBuilder instead\"]\n-pub fn spawn_opts(opts: TaskOpts, f: proc():Send) {\n-    let TaskOpts { name, stack_size, on_exit } = opts;\n-\n-    let mut task = box Task::new();\n-    task.name = name;\n-    task.death.on_exit = on_exit;\n-\n-    let stack = stack_size.unwrap_or(rt::min_stack());\n-    let task = task;\n-    let ops = ops();\n-\n-    // Note that this increment must happen *before* the spawn in order to\n-    // guarantee that if this task exits it will always end up waiting for the\n-    // spawned task to exit.\n-    let token = bookkeeping::increment();\n-\n-    // Spawning a new OS thread guarantees that __morestack will never get\n-    // triggered, but we must manually set up the actual stack bounds once this\n-    // function starts executing. This raises the lower limit by a bit because\n-    // by the time that this function is executing we've already consumed at\n-    // least a little bit of stack (we don't know the exact byte address at\n-    // which our stack started).\n-    Thread::spawn_stack(stack, proc() {\n-        let something_around_the_top_of_the_stack = 1;\n-        let addr = &something_around_the_top_of_the_stack as *const int;\n-        let my_stack = addr as uint;\n-        unsafe {\n-            stack::record_os_managed_stack_bounds(my_stack - stack + 1024, my_stack);\n-        }\n-        let mut ops = ops;\n-        ops.stack_bounds = (my_stack - stack + 1024, my_stack);\n-\n-        let mut f = Some(f);\n-        let mut task = task;\n-        task.put_runtime(ops);\n-        drop(task.run(|| { f.take().unwrap()() }).destroy());\n-        drop(token);\n-    })\n-}\n-\n /// A spawner for native tasks\n pub struct NativeSpawner;\n \n impl Spawner for NativeSpawner {\n     fn spawn(self, opts: TaskOpts, f: proc():Send) {\n-        spawn_opts(opts, f)\n+        let TaskOpts { name, stack_size, on_exit } = opts;\n+\n+        let mut task = box Task::new();\n+        task.name = name;\n+        task.death.on_exit = on_exit;\n+\n+        let stack = stack_size.unwrap_or(rt::min_stack());\n+        let task = task;\n+        let ops = ops();\n+\n+        // Note that this increment must happen *before* the spawn in order to\n+        // guarantee that if this task exits it will always end up waiting for\n+        // the spawned task to exit.\n+        let token = bookkeeping::increment();\n+\n+        // Spawning a new OS thread guarantees that __morestack will never get\n+        // triggered, but we must manually set up the actual stack bounds once\n+        // this function starts executing. This raises the lower limit by a bit\n+        // because by the time that this function is executing we've already\n+        // consumed at least a little bit of stack (we don't know the exact byte\n+        // address at which our stack started).\n+        Thread::spawn_stack(stack, proc() {\n+            let something_around_the_top_of_the_stack = 1;\n+            let addr = &something_around_the_top_of_the_stack as *const int;\n+            let my_stack = addr as uint;\n+            unsafe {\n+                stack::record_os_managed_stack_bounds(my_stack - stack + 1024,\n+                                                      my_stack);\n+            }\n+            let mut ops = ops;\n+            ops.stack_bounds = (my_stack - stack + 1024, my_stack);\n+\n+            let mut f = Some(f);\n+            let mut task = task;\n+            task.put_runtime(ops);\n+            drop(task.run(|| { f.take().unwrap()() }).destroy());\n+            drop(token);\n+        })\n     }\n }\n \n@@ -270,7 +257,7 @@ impl rt::Runtime for Ops {\n         cur_task.put_runtime(self);\n         Local::put(cur_task);\n \n-        task::spawn_opts(opts, f);\n+        NativeSpawner.spawn(opts, f);\n     }\n \n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> {\n@@ -283,8 +270,9 @@ mod tests {\n     use std::rt::local::Local;\n     use std::rt::task::{Task, TaskOpts};\n     use std::task;\n-    use std::task::TaskBuilder;\n-    use super::{spawn, spawn_opts, Ops, NativeTaskBuilder};\n+    use std::task::{TaskBuilder, Spawner};\n+\n+    use super::{Ops, NativeTaskBuilder, NativeSpawner};\n \n     #[test]\n     fn smoke() {\n@@ -312,7 +300,7 @@ mod tests {\n         opts.stack_size = Some(20 * 4096);\n         let (tx, rx) = channel();\n         opts.on_exit = Some(proc(r) tx.send(r));\n-        spawn_opts(opts, proc() {});\n+        NativeSpawner.spawn(opts, proc() {});\n         assert!(rx.recv().is_ok());\n     }\n \n@@ -321,7 +309,7 @@ mod tests {\n         let mut opts = TaskOpts::new();\n         let (tx, rx) = channel();\n         opts.on_exit = Some(proc(r) tx.send(r));\n-        spawn_opts(opts, proc() { fail!() });\n+        NativeSpawner.spawn(opts, proc() { fail!() });\n         assert!(rx.recv().is_err());\n     }\n "}, {"sha": "3d83012cecbf09e0257a0bcf223285f7e9b538b5", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -377,10 +377,10 @@ impl Isaac64Rng {\n                                 let x = *self.mem.unsafe_get(base + mr_offset);\n                                 a = mix + *self.mem.unsafe_get(base + m2_offset);\n                                 let y = ind!(x) + a + b;\n-                                self.mem.unsafe_set(base + mr_offset, y);\n+                                *self.mem.unsafe_mut(base + mr_offset) = y;\n \n                                 b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                                self.rsl.unsafe_set(base + mr_offset, b);\n+                                *self.rsl.unsafe_mut(base + mr_offset) = b;\n                             }\n                         }}\n                     );\n@@ -394,10 +394,10 @@ impl Isaac64Rng {\n                                 let x = *self.mem.unsafe_get(base + mr_offset);\n                                 a = mix + *self.mem.unsafe_get(base + m2_offset);\n                                 let y = ind!(x) + a + b;\n-                                self.mem.unsafe_set(base + mr_offset, y);\n+                                *self.mem.unsafe_mut(base + mr_offset) = y;\n \n                                 b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                                self.rsl.unsafe_set(base + mr_offset, b);\n+                                *self.rsl.unsafe_mut(base + mr_offset) = b;\n                             }\n                         }}\n                     );"}, {"sha": "ebaa0349f5b72a221823a8b092aecc2117224ffa", "filename": "src/librand/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -239,12 +239,6 @@ pub trait Rng {\n         }\n     }\n \n-    /// Deprecated name for `choose()`.\n-    #[deprecated = \"replaced by .choose()\"]\n-    fn choose_option<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n-        self.choose(values)\n-    }\n-\n     /// Shuffle a mutable slice in place.\n     ///\n     /// # Example"}, {"sha": "d47ca892b13b1ec22378a8ccff0790b30aff5cc5", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 16, "deletions": 37, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -129,8 +129,6 @@ pub const RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: uint =\n pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {\n-    use syntax::crateid::CrateId;\n-\n     let validate = |s: String, span: Option<Span>| {\n         creader::validate_crate_name(sess, s.as_slice(), span);\n         s\n@@ -168,25 +166,6 @@ pub fn find_crate_name(sess: Option<&Session>,\n         Some((attr, s)) => return validate(s.get().to_string(), Some(attr.span)),\n         None => {}\n     }\n-    let crate_id = attrs.iter().find(|at| at.check_name(\"crate_id\"))\n-                        .and_then(|at| at.value_str().map(|s| (at, s)))\n-                        .and_then(|(at, s)| {\n-                            from_str::<CrateId>(s.get()).map(|id| (at, id))\n-                        });\n-    match crate_id {\n-        Some((attr, id)) => {\n-            match sess {\n-                Some(sess) => {\n-                    sess.span_warn(attr.span, \"the #[crate_id] attribute is \\\n-                                               deprecated for the \\\n-                                               #[crate_name] attribute\");\n-                }\n-                None => {}\n-            }\n-            return validate(id.name, Some(attr.span))\n-        }\n-        None => {}\n-    }\n     match *input {\n         FileInput(ref path) => {\n             match path.filestem_str() {\n@@ -274,18 +253,18 @@ pub fn sanitize(s: &str) -> String {\n \n             // '.' doesn't occur in types and functions, so reuse it\n             // for ':' and '-'\n-            '-' | ':' => result.push_char('.'),\n+            '-' | ':' => result.push('.'),\n \n             // These are legal symbols\n             'a' ... 'z'\n             | 'A' ... 'Z'\n             | '0' ... '9'\n-            | '_' | '.' | '$' => result.push_char(c),\n+            | '_' | '.' | '$' => result.push(c),\n \n             _ => {\n                 let mut tstr = String::new();\n-                char::escape_unicode(c, |c| tstr.push_char(c));\n-                result.push_char('$');\n+                char::escape_unicode(c, |c| tstr.push(c));\n+                result.push('$');\n                 result.push_str(tstr.as_slice().slice_from(1));\n             }\n         }\n@@ -334,7 +313,7 @@ pub fn mangle<PI: Iterator<PathElem>>(mut path: PI,\n         None => {}\n     }\n \n-    n.push_char('E'); // End name-sequence.\n+    n.push('E'); // End name-sequence.\n     n\n }\n \n@@ -360,9 +339,9 @@ pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n     let extra2 = id % EXTRA_CHARS.len();\n     let id = id / EXTRA_CHARS.len();\n     let extra3 = id % EXTRA_CHARS.len();\n-    hash.push_char(EXTRA_CHARS.as_bytes()[extra1] as char);\n-    hash.push_char(EXTRA_CHARS.as_bytes()[extra2] as char);\n-    hash.push_char(EXTRA_CHARS.as_bytes()[extra3] as char);\n+    hash.push(EXTRA_CHARS.as_bytes()[extra1] as char);\n+    hash.push(EXTRA_CHARS.as_bytes()[extra2] as char);\n+    hash.push(EXTRA_CHARS.as_bytes()[extra3] as char);\n \n     exported_name(path, hash.as_slice())\n }\n@@ -838,8 +817,8 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n                 sess.note(str::from_utf8(output.as_slice()).unwrap());\n                 sess.abort_if_errors();\n             }\n-            debug!(\"linker stderr:\\n{}\", str::from_utf8_owned(prog.error).unwrap());\n-            debug!(\"linker stdout:\\n{}\", str::from_utf8_owned(prog.output).unwrap());\n+            debug!(\"linker stderr:\\n{}\", String::from_utf8(prog.error).unwrap());\n+            debug!(\"linker stdout:\\n{}\", String::from_utf8(prog.output).unwrap());\n         },\n         Err(e) => {\n             sess.err(format!(\"could not exec the linker `{}`: {}\",\n@@ -1088,7 +1067,7 @@ fn link_args(cmd: &mut Command,\n             cmd.args([\"-dynamiclib\", \"-Wl,-dylib\"]);\n \n             if sess.opts.cg.rpath {\n-                let mut v = Vec::from_slice(\"-Wl,-install_name,@rpath/\".as_bytes());\n+                let mut v = \"-Wl,-install_name,@rpath/\".as_bytes().to_vec();\n                 v.push_all(out_filename.filename().unwrap());\n                 cmd.arg(v.as_slice());\n             }\n@@ -1247,9 +1226,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n     // involves just passing the right -l flag.\n \n     let data = if dylib {\n-        trans.crate_formats.get(&config::CrateTypeDylib)\n+        &trans.crate_formats[config::CrateTypeDylib]\n     } else {\n-        trans.crate_formats.get(&config::CrateTypeExecutable)\n+        &trans.crate_formats[config::CrateTypeExecutable]\n     };\n \n     // Invoke get_used_crates to ensure that we get a topological sorting of\n@@ -1260,7 +1239,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         // We may not pass all crates through to the linker. Some crates may\n         // appear statically in an existing dylib, meaning we'll pick up all the\n         // symbols from the dylib.\n-        let kind = match *data.get(cnum as uint - 1) {\n+        let kind = match data[cnum as uint - 1] {\n             Some(t) => t,\n             None => continue\n         };\n@@ -1279,7 +1258,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n     // Converts a library file-stem into a cc -l argument\n     fn unlib<'a>(config: &config::Config, stem: &'a [u8]) -> &'a [u8] {\n         if stem.starts_with(\"lib\".as_bytes()) && config.os != abi::OsWindows {\n-            stem.tailn(3)\n+            stem[3..]\n         } else {\n             stem\n         }\n@@ -1362,7 +1341,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         let dir = cratepath.dirname();\n         if !dir.is_empty() { cmd.arg(\"-L\").arg(dir); }\n \n-        let mut v = Vec::from_slice(\"-l\".as_bytes());\n+        let mut v = \"-l\".as_bytes().to_vec();\n         v.push_all(unlib(&sess.targ_cfg, cratepath.filestem().unwrap()));\n         cmd.arg(v.as_slice());\n     }"}, {"sha": "1f44808275f6cf961913060b9978dd79f75b87c7", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -487,7 +487,9 @@ pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n     if sess.opts.test {\n         append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n     }\n-    user_cfg.into_iter().collect::<Vec<_>>().append(default_cfg.as_slice())\n+    let mut v = user_cfg.into_iter().collect::<Vec<_>>();\n+    v.push_all(default_cfg.as_slice());\n+    v\n }\n \n pub fn get_os(triple: &str) -> Option<abi::Os> {"}, {"sha": "f6aab6ef4777765817f9dbd02ecc140504153cd5", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -284,7 +284,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             if cfg!(windows) {\n                 _old_path = os::getenv(\"PATH\").unwrap_or(_old_path);\n                 let mut new_path = sess.host_filesearch().get_dylib_search_paths();\n-                new_path.push_all_move(os::split_paths(_old_path.as_slice()));\n+                new_path.extend(os::split_paths(_old_path.as_slice()).into_iter());\n                 os::setenv(\"PATH\", os::join_paths(new_path.as_slice()).unwrap());\n             }\n             let cfg = syntax::ext::expand::ExpansionConfig {\n@@ -569,7 +569,7 @@ pub fn phase_6_link_output(sess: &Session,\n                            outputs: &OutputFilenames) {\n     let old_path = os::getenv(\"PATH\").unwrap_or_else(||String::new());\n     let mut new_path = os::split_paths(old_path.as_slice());\n-    new_path.push_all_move(sess.host_filesearch().get_tools_search_paths());\n+    new_path.extend(sess.host_filesearch().get_tools_search_paths().into_iter());\n     os::setenv(\"PATH\", os::join_paths(new_path.as_slice()).unwrap());\n \n     time(sess.time_passes(), \"linking\", (), |_|\n@@ -818,17 +818,6 @@ pub fn build_output_filenames(input: &Input,\n             // If a crate name is present, we use it as the link name\n             let stem = sess.opts.crate_name.clone().or_else(|| {\n                 attr::find_crate_name(attrs).map(|n| n.get().to_string())\n-            }).or_else(|| {\n-                // NB: this clause can be removed once #[crate_id] is no longer\n-                // deprecated.\n-                //\n-                // Also note that this will be warned about later so we don't\n-                // warn about it here.\n-                use syntax::crateid::CrateId;\n-                attrs.iter().find(|at| at.check_name(\"crate_id\"))\n-                     .and_then(|at| at.value_str())\n-                     .and_then(|s| from_str::<CrateId>(s.get()))\n-                     .map(|id| id.name)\n             }).unwrap_or(input.filestem());\n \n             OutputFilenames {"}, {"sha": "4a2e209f56282a26fc2929a6fd404612cd002175", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -43,7 +43,7 @@ static BUG_REPORT_URL: &'static str =\n     \"http://doc.rust-lang.org/complement-bugreport.html\";\n \n fn run_compiler(args: &[String]) {\n-    let matches = match handle_options(Vec::from_slice(args)) {\n+    let matches = match handle_options(args.to_vec()) {\n         Some(matches) => matches,\n         None => return\n     };\n@@ -76,7 +76,7 @@ fn run_compiler(args: &[String]) {\n             early_error(\"no input filename given\");\n         }\n         1u => {\n-            let ifile = matches.free.get(0).as_slice();\n+            let ifile = matches.free[0].as_slice();\n             if ifile == \"-\" {\n                 let contents = io::stdin().read_to_end().unwrap();\n                 let src = String::from_utf8(contents).unwrap();\n@@ -216,7 +216,9 @@ Available lint options:\n         .map(|&s| s.name.width(true))\n         .max().unwrap_or(0);\n     let padded = |x: &str| {\n-        \" \".repeat(max_name_len - x.char_len()).append(x)\n+        let mut s = \" \".repeat(max_name_len - x.char_len());\n+        s.push_str(x);\n+        s\n     };\n \n     println!(\"Lint checks provided by rustc:\\n\");\n@@ -240,7 +242,9 @@ Available lint options:\n         .map(|&(s, _)| s.width(true))\n         .max().unwrap_or(0);\n     let padded = |x: &str| {\n-        \" \".repeat(max_name_len - x.char_len()).append(x)\n+        let mut s = \" \".repeat(max_name_len - x.char_len());\n+        s.push_str(x);\n+        s\n     };\n \n     println!(\"Lint groups provided by rustc:\\n\");\n@@ -313,7 +317,7 @@ fn describe_codegen_flags() {\n /// returns None.\n pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     // Throw away the first argument, the name of the binary\n-    let _binary = args.shift().unwrap();\n+    let _binary = args.remove(0).unwrap();\n \n     if args.is_empty() {\n         usage();"}, {"sha": "19cd03f10a781738859532c4e84d1bd39e861f34", "filename": "src/librustc/driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fdriver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fdriver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fpretty.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -434,10 +434,8 @@ pub fn pretty_print_input(sess: Session,\n     };\n \n     let src_name = driver::source_name(input);\n-    let src = Vec::from_slice(sess.codemap()\n-                                  .get_filemap(src_name.as_slice())\n-                                  .src\n-                                  .as_bytes());\n+    let src = sess.codemap().get_filemap(src_name.as_slice())\n+                            .src.as_bytes().to_vec();\n     let mut rdr = MemReader::new(src);\n \n     let out = match ofile {"}, {"sha": "390648eab2e54985a730d3e0702c2bc579ae838f", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -28,7 +28,6 @@ This API is completely unstable and subject to change.\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![allow(deprecated)]\n #![feature(default_type_params, globs, if_let, import_shadowing, macro_rules, phase, quote)]\n #![feature(slicing_syntax, struct_variant, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "2205dc42d47d63be81bafae1746996aaf7e1776d", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -883,7 +883,7 @@ impl NonSnakeCase {\n                         buf = String::new();\n                     }\n                     last_upper = ch.is_uppercase();\n-                    buf.push_char(ch.to_lowercase());\n+                    buf.push(ch.to_lowercase());\n                 }\n                 words.push(buf);\n             }\n@@ -1062,7 +1062,7 @@ impl UnusedParens {\n \n                 ast::ExprMethodCall(_, _, ref exprs) => {\n                     // X { y: 1 }.bar(...)\n-                    contains_exterior_struct_lit(&**exprs.get(0))\n+                    contains_exterior_struct_lit(&*exprs[0])\n                 }\n \n                 _ => false\n@@ -1220,7 +1220,7 @@ impl UnusedMut {\n         let used_mutables = cx.tcx.used_mut_nodes.borrow();\n         for (_, v) in mutables.iter() {\n             if !v.iter().any(|e| used_mutables.contains(e)) {\n-                cx.span_lint(UNUSED_MUT, cx.tcx.map.span(*v.get(0)),\n+                cx.span_lint(UNUSED_MUT, cx.tcx.map.span(v[0]),\n                              \"variable does not need to be mutable\");\n             }\n         }"}, {"sha": "1107e44be3b03d1d89706a51ebee0773a7fdeee4", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -141,7 +141,7 @@ impl LintStore {\n                 self.levels.insert(id, (lint.default_level, Default));\n             }\n         }\n-        self.passes.get_mut_ref().push(pass);\n+        self.passes.as_mut().unwrap().push(pass);\n     }\n \n     pub fn register_group(&mut self, sess: Option<&Session>,"}, {"sha": "7ec74eb1c3faf2977c9cb5ae588c0ee61cd0e4b4", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -93,8 +93,9 @@ pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem>\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    (vec!(ast_map::PathMod(token::intern(cdata.name.as_slice())))).append(\n-        path.as_slice())\n+    let mut r = vec![ast_map::PathMod(token::intern(cdata.name.as_slice()))];\n+    r.push_all(path.as_slice());\n+    r\n }\n \n pub enum found_ast<'ast> {"}, {"sha": "1d1012d9e4f04e037c3c4ef4d740bca17d879e40", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -95,7 +95,7 @@ impl CStore {\n     }\n \n     pub fn get_crate_data(&self, cnum: ast::CrateNum) -> Rc<crate_metadata> {\n-        self.metas.borrow().get(&cnum).clone()\n+        (*self.metas.borrow())[cnum].clone()\n     }\n \n     pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> Svh {"}, {"sha": "456cf93d9b5c50363ec52da3eacb3b4a6b042fa0", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -643,7 +643,7 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeI\n                                 -> csearch::found_ast<'tcx> {\n     debug!(\"Looking up item: {}\", id);\n     let item_doc = lookup_item(id, cdata.data());\n-    let path = Vec::from_slice(item_path(item_doc).init());\n+    let path = item_path(item_doc).init().to_vec();\n     match decode_inlined_item(cdata, tcx, path, item_doc) {\n         Ok(ii) => csearch::found(ii),\n         Err(path) => {"}, {"sha": "9106adcd3ef38c39f530385bea02484af5e298bf", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -347,9 +347,9 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                 encode_index(rbml_w, idx, write_i64);\n             }\n         }\n-        if vi.get(i).disr_val != disr_val {\n-            encode_disr_val(ecx, rbml_w, vi.get(i).disr_val);\n-            disr_val = vi.get(i).disr_val;\n+        if (*vi)[i].disr_val != disr_val {\n+            encode_disr_val(ecx, rbml_w, (*vi)[i].disr_val);\n+            disr_val = (*vi)[i].disr_val;\n         }\n         encode_bounds_and_type(rbml_w, ecx,\n                                &lookup_item_type(ecx.tcx, def_id));\n@@ -401,7 +401,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n     match ecx.tcx.inherent_impls.borrow().find(&exp.def_id) {\n         Some(implementations) => {\n             for base_impl_did in implementations.iter() {\n-                for &method_did in impl_items.get(base_impl_did).iter() {\n+                for &method_did in (*impl_items)[*base_impl_did].iter() {\n                     let impl_item = ty::impl_or_trait_item(\n                         ecx.tcx,\n                         method_did.def_id());\n@@ -515,7 +515,7 @@ fn each_auxiliary_node_id(item: &Item, callback: |NodeId| -> bool) -> bool {\n             // If this is a newtype struct, return the constructor.\n             match struct_def.ctor_id {\n                 Some(ctor_id) if struct_def.fields.len() > 0 &&\n-                        struct_def.fields.get(0).node.kind.is_unnamed() => {\n+                        struct_def.fields[0].node.kind.is_unnamed() => {\n                     continue_ = callback(ctor_id);\n                 }\n                 _ => {}\n@@ -912,7 +912,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n     encode_stability(rbml_w, stab);\n \n     let elem = ast_map::PathName(associated_type.ident.name);\n-    encode_path(rbml_w, impl_path.chain(Some(elem).move_iter()));\n+    encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n \n     match typedef_opt {\n         None => {}\n@@ -1229,7 +1229,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n         let impl_items = tcx.impl_items.borrow();\n-        let items = impl_items.get(&def_id);\n+        let items = &(*impl_items)[def_id];\n \n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n@@ -1277,7 +1277,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let num_implemented_methods = ast_items.len();\n         for (i, &trait_item_def_id) in items.iter().enumerate() {\n             let ast_item = if i < num_implemented_methods {\n-                Some(ast_items.get(i))\n+                Some(&ast_items[i])\n             } else {\n                 None\n             };\n@@ -1421,7 +1421,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 ty::TypeTraitItem(associated_type) => {\n                     let elem = ast_map::PathName(associated_type.ident.name);\n                     encode_path(rbml_w,\n-                                path.clone().chain(Some(elem).move_iter()));\n+                                path.clone().chain(Some(elem).into_iter()));\n \n                     encode_family(rbml_w, 'y');\n \n@@ -1431,8 +1431,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             encode_parent_sort(rbml_w, 't');\n \n-            let trait_item = ms.get(i);\n-            match ms.get(i) {\n+            let trait_item = &ms[i];\n+            match &ms[i] {\n                 &RequiredMethod(ref tm) => {\n                     encode_attributes(rbml_w, tm.attrs.as_slice());\n                     encode_item_sort(rbml_w, 'r');"}, {"sha": "36e04d84aa9d620656ca29945f8ea6074e5e2809", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -418,11 +418,11 @@ impl<'a> Context<'a> {\n                 (file.slice(rlib_prefix.len(), file.len() - \".rlib\".len()),\n                  true)\n             } else if dypair.map_or(false, |(_, suffix)| {\n-                file.starts_with(dylib_prefix.get_ref().as_slice()) &&\n+                file.starts_with(dylib_prefix.as_ref().unwrap().as_slice()) &&\n                 file.ends_with(suffix)\n             }) {\n                 let (_, suffix) = dypair.unwrap();\n-                let dylib_prefix = dylib_prefix.get_ref().as_slice();\n+                let dylib_prefix = dylib_prefix.as_ref().unwrap().as_slice();\n                 (file.slice(dylib_prefix.len(), file.len() - suffix.len()),\n                  false)\n             } else {\n@@ -553,7 +553,7 @@ impl<'a> Context<'a> {\n                                            self.crate_name).as_slice());\n                 self.sess.span_note(self.span,\n                                     format!(r\"candidate #1: {}\",\n-                                            ret.get_ref()\n+                                            ret.as_ref().unwrap()\n                                                .display()).as_slice());\n                 error = 1;\n                 ret = None;"}, {"sha": "6fbdceea37f9dd55fe75c8775b17bfc38bcd8add", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -123,9 +123,9 @@ fn data_log_string(data: &[u8], pos: uint) -> String {\n     for i in range(pos, data.len()) {\n         let c = data[i];\n         if c > 0x20 && c <= 0x7F {\n-            buf.push_char(c as char);\n+            buf.push(c as char);\n         } else {\n-            buf.push_char('.');\n+            buf.push('.');\n         }\n     }\n     buf.push_str(\">>\");\n@@ -339,7 +339,7 @@ fn parse_str(st: &mut PState, term: char) -> String {\n     let mut result = String::new();\n     while peek(st) != term {\n         unsafe {\n-            result.push_bytes([next_byte(st)])\n+            result.as_mut_vec().push_all([next_byte(st)])\n         }\n     }\n     next(st);"}, {"sha": "f72d14ba68aae2c07e03f65f1d279c453c13957e", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -1517,7 +1517,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         fn type_string(doc: rbml::Doc) -> String {\n             let mut str = String::new();\n             for i in range(doc.start, doc.end) {\n-                str.push_char(doc.data[i] as char);\n+                str.push(doc.data[i] as char);\n             }\n             str\n         }"}, {"sha": "887c6bc3e3fdfb48c34e3424fe5bb43c4f368b84", "filename": "src/librustc/middle/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -98,7 +98,7 @@ fn group_errors_with_same_origin(errors: &Vec<MoveError>)\n         for ge in grouped_errors.iter_mut() {\n             if move_from_id == ge.move_from.id && error.move_to.is_some() {\n                 debug!(\"appending move_to to list\");\n-                ge.move_to_places.push_all_move(move_to);\n+                ge.move_to_places.extend(move_to.into_iter());\n                 return\n             }\n         }"}, {"sha": "aab7fe8f31edc38e214e91a2eb94d8405133d980", "filename": "src/librustc/middle/borrowck/graphviz.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -91,14 +91,15 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n             saw_some = true;\n             true\n         });\n-        set.append(\"}\")\n+        set.push_str(\"}\");\n+        set\n     }\n \n     fn dataflow_loans_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {\n         let dfcx = &self.analysis_data.loans;\n         let loan_index_to_path = |loan_index| {\n             let all_loans = &self.analysis_data.all_loans;\n-            all_loans.get(loan_index).loan_path()\n+            all_loans[loan_index].loan_path()\n         };\n         self.build_set(e, cfgidx, dfcx, loan_index_to_path)\n     }\n@@ -108,7 +109,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n         let move_index_to_path = |move_index| {\n             let move_data = &self.analysis_data.move_data.move_data;\n             let moves = move_data.moves.borrow();\n-            let the_move = moves.get(move_index);\n+            let the_move = &(*moves)[move_index];\n             move_data.path_loan_path(the_move.path)\n         };\n         self.build_set(e, cfgidx, dfcx, move_index_to_path)\n@@ -119,7 +120,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n         let assign_index_to_path = |assign_index| {\n             let move_data = &self.analysis_data.move_data.move_data;\n             let assignments = move_data.var_assignments.borrow();\n-            let assignment = assignments.get(assign_index);\n+            let assignment = &(*assignments)[assign_index];\n             move_data.path_loan_path(assignment.path)\n         };\n         self.build_set(e, cfgidx, dfcx, assign_index_to_path)"}, {"sha": "850c6008706c88eee2226ab2d031ca11c2abbe5e", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -825,11 +825,11 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 match fname {\n                     mc::NamedField(fname) => {\n-                        out.push_char('.');\n+                        out.push('.');\n                         out.push_str(token::get_name(fname).get());\n                     }\n                     mc::PositionalField(idx) => {\n-                        out.push_char('.');\n+                        out.push('.');\n                         out.push_str(idx.to_string().as_slice());\n                     }\n                 }\n@@ -841,7 +841,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n \n             LpExtend(ref lp_base, _, LpDeref(_)) => {\n-                out.push_char('*');\n+                out.push('*');\n                 self.append_loan_path_to_string(&**lp_base, out);\n             }\n         }"}, {"sha": "5f3c46fcf4cd5f8287a5668c5181e97d899225db", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -192,23 +192,23 @@ impl MoveData {\n     }\n \n     pub fn path_loan_path(&self, index: MovePathIndex) -> Rc<LoanPath> {\n-        self.paths.borrow().get(index.get()).loan_path.clone()\n+        (*self.paths.borrow())[index.get()].loan_path.clone()\n     }\n \n     fn path_parent(&self, index: MovePathIndex) -> MovePathIndex {\n-        self.paths.borrow().get(index.get()).parent\n+        (*self.paths.borrow())[index.get()].parent\n     }\n \n     fn path_first_move(&self, index: MovePathIndex) -> MoveIndex {\n-        self.paths.borrow().get(index.get()).first_move\n+        (*self.paths.borrow())[index.get()].first_move\n     }\n \n     fn path_first_child(&self, index: MovePathIndex) -> MovePathIndex {\n-        self.paths.borrow().get(index.get()).first_child\n+        (*self.paths.borrow())[index.get()].first_child\n     }\n \n     fn path_next_sibling(&self, index: MovePathIndex) -> MovePathIndex {\n-        self.paths.borrow().get(index.get()).next_sibling\n+        (*self.paths.borrow())[index.get()].next_sibling\n     }\n \n     fn set_path_first_move(&self,\n@@ -225,7 +225,7 @@ impl MoveData {\n \n     fn move_next_move(&self, index: MoveIndex) -> MoveIndex {\n         //! Type safe indexing operator\n-        self.moves.borrow().get(index.get()).next_move\n+        (*self.moves.borrow())[index.get()].next_move\n     }\n \n     fn is_var_path(&self, index: MovePathIndex) -> bool {\n@@ -434,12 +434,12 @@ impl MoveData {\n             match *path.loan_path {\n                 LpVar(id) => {\n                     let kill_id = tcx.region_maps.var_scope(id);\n-                    let path = *self.path_map.borrow().get(&path.loan_path);\n+                    let path = (*self.path_map.borrow())[path.loan_path];\n                     self.kill_moves(path, kill_id, dfcx_moves);\n                 }\n                 LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }) => {\n                     let kill_id = closure_to_block(closure_expr_id, tcx);\n-                    let path = *self.path_map.borrow().get(&path.loan_path);\n+                    let path = (*self.path_map.borrow())[path.loan_path];\n                     self.kill_moves(path, kill_id, dfcx_moves);\n                 }\n                 LpExtend(..) => {}\n@@ -580,7 +580,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n         for loan_path_index in self.move_data.path_map.borrow().find(&*loan_path).iter() {\n             self.dfcx_moves.each_gen_bit(id, |move_index| {\n                 let the_move = self.move_data.moves.borrow();\n-                let the_move = the_move.get(move_index);\n+                let the_move = (*the_move)[move_index];\n                 if the_move.path == **loan_path_index {\n                     ret = Some(the_move.kind);\n                     false\n@@ -625,7 +625,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n \n         self.dfcx_moves.each_bit_on_entry(id, |index| {\n             let the_move = self.move_data.moves.borrow();\n-            let the_move = the_move.get(index);\n+            let the_move = &(*the_move)[index];\n             let moved_path = the_move.path;\n             if base_indices.iter().any(|x| x == &moved_path) {\n                 // Scenario 1 or 2: `loan_path` or some base path of\n@@ -675,7 +675,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n \n         self.dfcx_assign.each_bit_on_entry(id, |index| {\n             let assignment = self.move_data.var_assignments.borrow();\n-            let assignment = assignment.get(index);\n+            let assignment = &(*assignment)[index];\n             if assignment.path == loan_path_index && !f(assignment) {\n                 false\n             } else {"}, {"sha": "4b55a0b26098bafecd3bcd75c46c02d55588e7ec", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -424,7 +424,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => {\n-                self.call(expr, pred, &**args.get(0), args.slice_from(1).iter().map(|e| &**e))\n+                self.call(expr, pred, &*args[0], args.slice_from(1).iter().map(|e| &**e))\n             }\n \n             ast::ExprIndex(ref l, ref r) |"}, {"sha": "bc48e476aec071a6fd1e439e040780831e382876", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -41,9 +41,9 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n             s.as_slice().chars().rev().take(2).collect();\n         last_two.reverse();\n         if last_two.as_slice() != ['\\\\', 'l'] {\n-            s = s.append(\"\\\\l\");\n+            s.push_str(\"\\\\l\");\n         }\n-        s.to_string()\n+        s\n     } else {\n         s\n     }\n@@ -76,16 +76,15 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n         let mut put_one = false;\n         for (i, &node_id) in e.data.exiting_scopes.iter().enumerate() {\n             if put_one {\n-                label = label.append(\",\\\\l\");\n+                label.push_str(\",\\\\l\");\n             } else {\n                 put_one = true;\n             }\n             let s = self.ast_map.node_to_string(node_id);\n             // left-aligns the lines\n             let s = replace_newline_with_backslash_l(s);\n-            label = label.append(format!(\"exiting scope_{} {}\",\n-                                         i,\n-                                         s.as_slice()).as_slice());\n+            label.push_str(format!(\"exiting scope_{} {}\", i,\n+                                   s.as_slice()).as_slice());\n         }\n         dot::EscStr(label.into_maybe_owned())\n     }"}, {"sha": "7ffe5f42a5cce15fe1c1e8bd9b96f7f14941fb2b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -66,7 +66,7 @@ impl<'a> fmt::Show for Matrix<'a> {\n         let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0u);\n         assert!(m.iter().all(|row| row.len() == column_count));\n         let column_widths: Vec<uint> = range(0, column_count).map(|col| {\n-            pretty_printed_matrix.iter().map(|row| row.get(col).len()).max().unwrap_or(0u)\n+            pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0u)\n         }).collect();\n \n         let total_width = column_widths.iter().map(|n| *n).sum() + column_count * 3 + 1;\n@@ -76,7 +76,7 @@ impl<'a> fmt::Show for Matrix<'a> {\n             try!(write!(f, \"+\"));\n             for (column, pat_str) in row.into_iter().enumerate() {\n                 try!(write!(f, \" \"));\n-                f.width = Some(*column_widths.get(column));\n+                f.width = Some(column_widths[column]);\n                 try!(f.pad(pat_str.as_slice()));\n                 try!(write!(f, \" +\"));\n             }\n@@ -269,7 +269,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[(Vec<P<Pat>>, Option<&Expr>)], source\n                             } else {\n                                 // find the first arm pattern so we can use its span\n                                 let &(ref first_arm_pats, _) = &arms[0];\n-                                let first_pat = first_arm_pats.get(0);\n+                                let first_pat = &first_arm_pats[0];\n                                 let span = first_pat.span;\n                                 span_err!(cx.tcx.sess, span, E0162, \"irrefutable if-let pattern\");\n                                 printed_if_let_err = true;\n@@ -279,7 +279,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[(Vec<P<Pat>>, Option<&Expr>)], source\n                         MatchWhileLetDesugar => {\n                             // find the first arm pattern so we can use its span\n                             let &(ref first_arm_pats, _) = &arms[0];\n-                            let first_pat = first_arm_pats.get(0);\n+                            let first_pat = &first_arm_pats[0];\n                             let span = first_pat.span;\n                             span_err!(cx.tcx.sess, span, E0165, \"irrefutable while-let pattern\");\n                         },\n@@ -475,7 +475,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n                        left_ty: ty::t, max_slice_length: uint) -> Option<Constructor> {\n     let used_constructors: Vec<Constructor> = rows.iter()\n-        .flat_map(|row| pat_constructors(cx, *row.get(0), left_ty, max_slice_length).into_iter())\n+        .flat_map(|row| pat_constructors(cx, row[0], left_ty, max_slice_length).into_iter())\n         .collect();\n     all_constructors(cx, left_ty, max_slice_length)\n         .into_iter()\n@@ -538,11 +538,11 @@ fn is_useful(cx: &MatchCheckCtxt,\n             LeaveOutWitness => Useful\n         };\n     }\n-    if rows.get(0).len() == 0u {\n+    if rows[0].len() == 0u {\n         return NotUseful;\n     }\n-    let real_pat = match rows.iter().find(|r| r.get(0).id != DUMMY_NODE_ID) {\n-        Some(r) => raw_pat(*r.get(0)),\n+    let real_pat = match rows.iter().find(|r| (*r)[0].id != DUMMY_NODE_ID) {\n+        Some(r) => raw_pat(r[0]),\n         None if v.len() == 0 => return NotUseful,\n         None => v[0]\n     };\n@@ -552,7 +552,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n         ty::pat_ty(cx.tcx, &*real_pat)\n     };\n \n-    let max_slice_length = rows.iter().filter_map(|row| match row.get(0).node {\n+    let max_slice_length = rows.iter().filter_map(|row| match row[0].node {\n         PatVec(ref before, _, ref after) => Some(before.len() + after.len()),\n         _ => None\n     }).max().map_or(0, |v| v + 1);\n@@ -583,7 +583,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n             Some(constructor) => {\n                 let matrix = rows.iter().filter_map(|r| {\n                     if pat_is_binding_or_wild(&cx.tcx.def_map, raw_pat(r[0])) {\n-                        Some(Vec::from_slice(r.tail()))\n+                        Some(r.tail().to_vec())\n                     } else {\n                         None\n                     }\n@@ -883,7 +883,11 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             None\n         }\n     };\n-    head.map(|head| head.append(r[..col]).append(r[col + 1..]))\n+    head.map(|mut head| {\n+        head.push_all(r[..col]);\n+        head.push_all(r[col + 1..]);\n+        head\n+    })\n }\n \n fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {"}, {"sha": "d5557dfeeff1a37463ab675f9e504a53dcc3f6b2", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -418,7 +418,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 let bits = self.kills.slice_mut(start, end);\n                 debug!(\"{:s} add_kills_from_flow_exits flow_exit={} bits={} [before]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n-                bits.copy_from(orig_kills.as_slice());\n+                bits.clone_from_slice(orig_kills.as_slice());\n                 debug!(\"{:s} add_kills_from_flow_exits flow_exit={} bits={} [after]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n             }\n@@ -484,7 +484,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n             let (start, end) = self.dfcx.compute_id_range(node_index);\n \n             // Initialize local bitvector with state on-entry.\n-            in_out.copy_from(self.dfcx.on_entry.slice(start, end));\n+            in_out.clone_from_slice(self.dfcx.on_entry.slice(start, end));\n \n             // Compute state on-exit by applying transfer function to\n             // state on-entry.\n@@ -550,13 +550,13 @@ fn bits_to_string(words: &[uint]) -> String {\n     for &word in words.iter() {\n         let mut v = word;\n         for _ in range(0u, uint::BYTES) {\n-            result.push_char(sep);\n+            result.push(sep);\n             result.push_str(format!(\"{:02x}\", v & 0xFF).as_slice());\n             v >>= 8;\n             sep = '-';\n         }\n     }\n-    result.push_char(']');\n+    result.push(']');\n     return result\n }\n "}, {"sha": "513d65c335d0f9c0b57c91fc27dc5e8cdf6181be", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -157,8 +157,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_field_pattern_match(&mut self, lhs: &ast::Pat, pats: &[ast::FieldPat]) {\n-        let id = match self.tcx.def_map.borrow().get(&lhs.id) {\n-            &def::DefVariant(_, id, _) => id,\n+        let id = match (*self.tcx.def_map.borrow())[lhs.id] {\n+            def::DefVariant(_, id, _) => id,\n             _ => {\n                 match ty::ty_to_def_id(ty::node_id_to_type(self.tcx,\n                                                            lhs.id)) {\n@@ -494,7 +494,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             None => (),\n             Some(impl_list) => {\n                 for impl_did in impl_list.iter() {\n-                    for item_did in impl_items.get(impl_did).iter() {\n+                    for item_did in (*impl_items)[*impl_did].iter() {\n                         if self.live_symbols.contains(&item_did.def_id()\n                                                                .node) {\n                             return true;"}, {"sha": "d4c8335d8e55f5cb2057259cb6e4903100a2ac40", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         match expr.node {\n             ast::ExprMethodCall(_, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                let base_type = self.tcx.method_map.borrow().get(&method_call).ty;\n+                let base_type = (*self.tcx.method_map.borrow())[method_call].ty;\n                 debug!(\"effect: method call case, base type is {}\",\n                        ppaux::ty_to_string(self.tcx, base_type));\n                 if type_is_unsafe_function(base_type) {"}, {"sha": "c413eb67a73ac05ba34641f3e5ef0ed276c003ed", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -738,7 +738,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                 None => {}\n                 Some(method_ty) => {\n                     let cmt = return_if_err!(self.mc.cat_expr_autoderefd(expr, i));\n-                    let self_ty = *ty::ty_fn_args(method_ty).get(0);\n+                    let self_ty = ty::ty_fn_args(method_ty)[0];\n                     let (m, r) = match ty::get(self_ty).sty {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,"}, {"sha": "4775f945f5c1f7f0952175e53547a818359db9af", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -146,11 +146,11 @@ impl<N,E> Graph<N,E> {\n     }\n \n     pub fn node_data<'a>(&'a self, idx: NodeIndex) -> &'a N {\n-        &self.nodes.get(idx.get()).data\n+        &self.nodes[idx.get()].data\n     }\n \n     pub fn node<'a>(&'a self, idx: NodeIndex) -> &'a Node<N> {\n-        self.nodes.get(idx.get())\n+        &self.nodes[idx.get()]\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -167,9 +167,9 @@ impl<N,E> Graph<N,E> {\n         let idx = self.next_edge_index();\n \n         // read current first of the list of edges from each node\n-        let source_first = self.nodes.get(source.get())\n+        let source_first = self.nodes[source.get()]\n                                      .first_edge[Outgoing.repr];\n-        let target_first = self.nodes.get(target.get())\n+        let target_first = self.nodes[target.get()]\n                                      .first_edge[Incoming.repr];\n \n         // create the new edge, with the previous firsts from each node\n@@ -193,27 +193,27 @@ impl<N,E> Graph<N,E> {\n     }\n \n     pub fn edge_data<'a>(&'a self, idx: EdgeIndex) -> &'a E {\n-        &self.edges.get(idx.get()).data\n+        &self.edges[idx.get()].data\n     }\n \n     pub fn edge<'a>(&'a self, idx: EdgeIndex) -> &'a Edge<E> {\n-        self.edges.get(idx.get())\n+        &self.edges[idx.get()]\n     }\n \n     pub fn first_adjacent(&self, node: NodeIndex, dir: Direction) -> EdgeIndex {\n         //! Accesses the index of the first edge adjacent to `node`.\n         //! This is useful if you wish to modify the graph while walking\n         //! the linked list of edges.\n \n-        self.nodes.get(node.get()).first_edge[dir.repr]\n+        self.nodes[node.get()].first_edge[dir.repr]\n     }\n \n     pub fn next_adjacent(&self, edge: EdgeIndex, dir: Direction) -> EdgeIndex {\n         //! Accesses the next edge in a given direction.\n         //! This is useful if you wish to modify the graph while walking\n         //! the linked list of edges.\n \n-        self.edges.get(edge.get()).next_edge[dir.repr]\n+        self.edges[edge.get()].next_edge[dir.repr]\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -257,7 +257,7 @@ impl<N,E> Graph<N,E> {\n \n         let mut edge_idx = self.first_adjacent(node, dir);\n         while edge_idx != InvalidEdgeIndex {\n-            let edge = self.edges.get(edge_idx.get());\n+            let edge = &self.edges[edge_idx.get()];\n             if !f(edge_idx, edge) {\n                 return false;\n             }"}, {"sha": "d7707be58bb58b5aa93388f48a4d247f64f0608b", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n                         match ty::get(typ).sty {\n                             ty_bare_fn(ref bare_fn_ty)\n                                     if bare_fn_ty.abi == RustIntrinsic => {\n-                                let from = *bare_fn_ty.sig.inputs.get(0);\n+                                let from = bare_fn_ty.sig.inputs[0];\n                                 let to = bare_fn_ty.sig.output;\n                                 self.check_transmute(expr.span, from, to, expr.id);\n                             }"}, {"sha": "f2d1a5e1d927243d17a099a802286afc97ee7b21", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -76,9 +76,9 @@ impl LanguageItems {\n     }\n \n     pub fn require(&self, it: LangItem) -> Result<ast::DefId, String> {\n-        match self.items.get(it as uint) {\n-            &Some(id) => Ok(id),\n-            &None => {\n+        match self.items[it as uint] {\n+            Some(id) => Ok(id),\n+            None => {\n                 Err(format!(\"requires `{}` lang_item\",\n                             LanguageItems::item_name(it as uint)))\n             }\n@@ -113,7 +113,7 @@ impl LanguageItems {\n     $(\n         #[allow(dead_code)]\n         pub fn $method(&self) -> Option<ast::DefId> {\n-            *self.items.get($variant as uint)\n+            self.items[$variant as uint]\n         }\n     )*\n }\n@@ -162,12 +162,12 @@ impl<'a> LanguageItemCollector<'a> {\n     pub fn collect_item(&mut self, item_index: uint,\n                         item_def_id: ast::DefId, span: Span) {\n         // Check for duplicates.\n-        match self.items.items.get(item_index) {\n-            &Some(original_def_id) if original_def_id != item_def_id => {\n+        match self.items.items[item_index] {\n+            Some(original_def_id) if original_def_id != item_def_id => {\n                 span_err!(self.session, span, E0152,\n                     \"duplicate entry for `{}`\", LanguageItems::item_name(item_index));\n             }\n-            &Some(_) | &None => {\n+            Some(_) | None => {\n                 // OK.\n             }\n         }"}, {"sha": "63e9a80adc61aa3aad273224ad662c84a01e8a65", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -327,11 +327,11 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n     }\n \n     fn variable_name(&self, var: Variable) -> String {\n-        match self.var_kinds.get(var.get()) {\n-            &Local(LocalInfo { ident: nm, .. }) | &Arg(_, nm) => {\n+        match self.var_kinds[var.get()] {\n+            Local(LocalInfo { ident: nm, .. }) | Arg(_, nm) => {\n                 token::get_ident(nm).get().to_string()\n             },\n-            &ImplicitRet => \"<implicit-ret>\".to_string()\n+            ImplicitRet => \"<implicit-ret>\".to_string()\n         }\n     }\n \n@@ -340,7 +340,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n     }\n \n     fn lnk(&self, ln: LiveNode) -> LiveNodeKind {\n-        *self.lnks.get(ln.get())\n+        self.lnks[ln.get()]\n     }\n }\n \n@@ -647,7 +647,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn live_on_entry(&self, ln: LiveNode, var: Variable)\n                       -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n-        let reader = self.users.get(self.idx(ln, var)).reader;\n+        let reader = self.users[self.idx(ln, var)].reader;\n         if reader.is_valid() {Some(self.ir.lnk(reader))} else {None}\n     }\n \n@@ -656,25 +656,25 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     */\n     fn live_on_exit(&self, ln: LiveNode, var: Variable)\n                     -> Option<LiveNodeKind> {\n-        let successor = *self.successors.get(ln.get());\n+        let successor = self.successors[ln.get()];\n         self.live_on_entry(successor, var)\n     }\n \n     fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n         assert!(ln.is_valid());\n-        self.users.get(self.idx(ln, var)).used\n+        self.users[self.idx(ln, var)].used\n     }\n \n     fn assigned_on_entry(&self, ln: LiveNode, var: Variable)\n                          -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n-        let writer = self.users.get(self.idx(ln, var)).writer;\n+        let writer = self.users[self.idx(ln, var)].writer;\n         if writer.is_valid() {Some(self.ir.lnk(writer))} else {None}\n     }\n \n     fn assigned_on_exit(&self, ln: LiveNode, var: Variable)\n                         -> Option<LiveNodeKind> {\n-        let successor = *self.successors.get(ln.get());\n+        let successor = self.successors[ln.get()];\n         self.assigned_on_entry(successor, var)\n     }\n \n@@ -736,10 +736,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         {\n             let wr = &mut wr as &mut io::Writer;\n             write!(wr, \"[ln({}) of kind {} reads\", ln.get(), self.ir.lnk(ln));\n-            self.write_vars(wr, ln, |idx| self.users.get(idx).reader);\n+            self.write_vars(wr, ln, |idx| self.users[idx].reader);\n             write!(wr, \"  writes\");\n-            self.write_vars(wr, ln, |idx| self.users.get(idx).writer);\n-            write!(wr, \"  precedes {}]\", self.successors.get(ln.get()).to_string());\n+            self.write_vars(wr, ln, |idx| self.users[idx].writer);\n+            write!(wr, \"  precedes {}]\", self.successors[ln.get()].to_string());\n         }\n         str::from_utf8(wr.unwrap().as_slice()).unwrap().to_string()\n     }\n@@ -762,7 +762,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         *self.successors.get_mut(ln.get()) = succ_ln;\n \n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n-            *this.users.get_mut(idx) = *this.users.get(succ_idx)\n+            *this.users.get_mut(idx) = this.users[succ_idx]\n         });\n         debug!(\"init_from_succ(ln={}, succ={})\",\n                self.ln_str(ln), self.ln_str(succ_ln));\n@@ -777,11 +777,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         let mut changed = false;\n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n-            changed |= copy_if_invalid(this.users.get(succ_idx).reader,\n+            changed |= copy_if_invalid(this.users[succ_idx].reader,\n                                        &mut this.users.get_mut(idx).reader);\n-            changed |= copy_if_invalid(this.users.get(succ_idx).writer,\n+            changed |= copy_if_invalid(this.users[succ_idx].writer,\n                                        &mut this.users.get_mut(idx).writer);\n-            if this.users.get(succ_idx).used && !this.users.get(idx).used {\n+            if this.users[succ_idx].used && !this.users[idx].used {\n                 this.users.get_mut(idx).used = true;\n                 changed = true;\n             }"}, {"sha": "9bd3f49eea6ba6c1372dd84374b243ff5bb19f9c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -500,7 +500,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n \n           ast::ExprPath(_) => {\n-            let def = *self.tcx().def_map.borrow().get(&expr.id);\n+            let def = (*self.tcx().def_map.borrow())[expr.id];\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n@@ -597,7 +597,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                   }\n                   ty::ty_unboxed_closure(closure_id, _) => {\n                       let unboxed_closures = self.typer.unboxed_closures().borrow();\n-                      let kind = unboxed_closures.get(&closure_id).kind;\n+                      let kind = (*unboxed_closures)[closure_id].kind;\n                       let mode = self.typer.capture_mode(fn_node_id);\n                       self.cat_upvar(id, span, var_id, fn_node_id, kind, mode, true)\n                   }\n@@ -953,7 +953,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             Some(method_ty) => {\n                 let ref_ty = ty::ty_fn_ret(method_ty);\n                 base_cmt = self.cat_rvalue_node(elt.id(), elt.span(), ref_ty);\n-                *ty::ty_fn_args(method_ty).get(0)\n+                ty::ty_fn_args(method_ty)[0]\n             }\n             None => {\n                 match ty::array_element_ty(base_cmt.ty) {"}, {"sha": "138c671ceb66bf06333436b9878eb3137a2108c4", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -348,7 +348,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         // crate module gets processed as well.\n         if self.prev_exported {\n             assert!(self.exp_map2.contains_key(&id), \"wut {}\", id);\n-            for export in self.exp_map2.get(&id).iter() {\n+            for export in self.exp_map2[id].iter() {\n                 if is_local(export.def_id) {\n                     self.reexports.insert(export.def_id.node);\n                 }\n@@ -524,7 +524,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             // if we've reached the root, then everything was allowable and this\n             // access is public.\n             if closest_private_id == ast::CRATE_NODE_ID { return Allowable }\n-            closest_private_id = *self.parents.get(&closest_private_id);\n+            closest_private_id = self.parents[closest_private_id];\n \n             // If we reached the top, then we were public all the way down and\n             // we can allow this access.\n@@ -542,7 +542,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     /// whether the node is accessible by the current module that iteration is\n     /// inside.\n     fn private_accessible(&self, id: ast::NodeId) -> bool {\n-        let parent = *self.parents.get(&id);\n+        let parent = self.parents[id];\n         debug!(\"privacy - accessible parent {}\", self.nodestr(parent));\n \n         // After finding `did`'s closest private member, we roll ourselves back\n@@ -566,7 +566,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 _ => {}\n             }\n \n-            cur = *self.parents.get(&cur);\n+            cur = self.parents[cur];\n         }\n     }\n \n@@ -658,7 +658,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 debug!(\"privacy - check named field {} in struct {}\", ident.name, id);\n                 fields.iter().find(|f| f.name == ident.name).unwrap()\n             }\n-            UnnamedField(idx) => fields.get(idx)\n+            UnnamedField(idx) => &fields[idx]\n         };\n         if field.vis == ast::Public ||\n             (is_local(field.id) && self.private_accessible(field.id.node)) {\n@@ -734,7 +734,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                                            name).as_slice())\n             };\n \n-            match *self.last_private_map.get(&path_id) {\n+            match self.last_private_map[path_id] {\n                 resolve::LastMod(resolve::AllPublic) => {},\n                 resolve::LastMod(resolve::DependsOn(def)) => {\n                     self.report_error(ck_public(def));"}, {"sha": "4506cd7e463497c6e414b382bc4f62b138570ac0", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n             }\n             ast::ExprMethodCall(..) => {\n                 let method_call = typeck::MethodCall::expr(expr.id);\n-                match self.tcx.method_map.borrow().get(&method_call).origin {\n+                match (*self.tcx.method_map.borrow())[method_call].origin {\n                     typeck::MethodStatic(def_id) => {\n                         if is_local(def_id) {\n                             if self.def_id_represents_local_inlined_item(def_id) {"}, {"sha": "7c16196f5c2168d927ee7d18d7e9b54c5134fad7", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -334,7 +334,7 @@ impl RegionMaps {\n         // where they diverge.  If one vector is a suffix of the other,\n         // then the corresponding scope is a superscope of the other.\n \n-        if *a_ancestors.get(a_index) != *b_ancestors.get(b_index) {\n+        if a_ancestors[a_index] != b_ancestors[b_index] {\n             return None;\n         }\n \n@@ -345,8 +345,8 @@ impl RegionMaps {\n             if b_index == 0u { return Some(scope_b); }\n             a_index -= 1u;\n             b_index -= 1u;\n-            if *a_ancestors.get(a_index) != *b_ancestors.get(b_index) {\n-                return Some(*a_ancestors.get(a_index + 1u));\n+            if a_ancestors[a_index] != b_ancestors[b_index] {\n+                return Some(a_ancestors[a_index + 1]);\n             }\n         }\n "}, {"sha": "eaec715a6a7e4015caa18fe1d9ae6e05ae54d529", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -1307,11 +1307,13 @@ impl<'a> Resolver<'a> {\n \n                 // If this is a newtype or unit-like struct, define a name\n                 // in the value namespace as well\n-                ctor_id.while_some(|cid| {\n-                    name_bindings.define_value(DefStruct(local_def(cid)), sp,\n-                                               is_public);\n-                    None\n-                });\n+                match ctor_id {\n+                    Some(cid) => {\n+                        name_bindings.define_value(DefStruct(local_def(cid)),\n+                                                   sp, is_public);\n+                    }\n+                    None => {}\n+                }\n \n                 // Record the def ID and fields of this struct.\n                 let named_fields = struct_def.fields.iter().filter_map(|f| {\n@@ -1644,7 +1646,7 @@ impl<'a> Resolver<'a> {\n                                         }\n                                     };\n                                     let module_path = module_path.as_slice().init();\n-                                    (Vec::from_slice(module_path), name)\n+                                    (module_path.to_vec(), name)\n                                 }\n                             };\n                             self.build_import_directive(\n@@ -2232,7 +2234,7 @@ impl<'a> Resolver<'a> {\n         let import_count = imports.len();\n         while module.resolved_import_count.get() < import_count {\n             let import_index = module.resolved_import_count.get();\n-            let import_directive = imports.get(import_index);\n+            let import_directive = &(*imports)[import_index];\n             match self.resolve_import_for_module(module.clone(),\n                                                  import_directive) {\n                 Failed(err) => {\n@@ -3669,15 +3671,15 @@ impl<'a> Resolver<'a> {\n         if index != import_count {\n             let sn = self.session\n                          .codemap()\n-                         .span_to_snippet(imports.get(index).span)\n+                         .span_to_snippet((*imports)[index].span)\n                          .unwrap();\n             if sn.as_slice().contains(\"::\") {\n-                self.resolve_error(imports.get(index).span,\n+                self.resolve_error((*imports)[index].span,\n                                    \"unresolved import\");\n             } else {\n                 let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n                                   sn.as_slice().slice(0, sn.len()));\n-                self.resolve_error(imports.get(index).span, err.as_slice());\n+                self.resolve_error((*imports)[index].span, err.as_slice());\n             }\n         }\n \n@@ -3905,12 +3907,17 @@ impl<'a> Resolver<'a> {\n                             def = DefUpvar(node_id, function_id, last_proc_body_id);\n \n                             let mut seen = self.freevars_seen.borrow_mut();\n-                            let seen = seen.find_or_insert(function_id, NodeSet::new());\n+                            let seen = match seen.entry(function_id) {\n+                                Occupied(v) => v.into_mut(),\n+                                Vacant(v) => v.set(NodeSet::new()),\n+                            };\n                             if seen.contains(&node_id) {\n                                 continue;\n                             }\n-                            self.freevars.borrow_mut().find_or_insert(function_id, vec![])\n-                                         .push(Freevar { def: prev_def, span: span });\n+                            match self.freevars.borrow_mut().entry(function_id) {\n+                                Occupied(v) => v.into_mut(),\n+                                Vacant(v) => v.set(vec![]),\n+                            }.push(Freevar { def: prev_def, span: span });\n                             seen.insert(node_id);\n                         }\n                         MethodRibKind(item_id, _) => {\n@@ -4714,7 +4721,7 @@ impl<'a> Resolver<'a> {\n         if arm.pats.len() == 0 {\n             return\n         }\n-        let map_0 = self.binding_mode_map(&**arm.pats.get(0));\n+        let map_0 = self.binding_mode_map(&*arm.pats[0]);\n         for (i, p) in arm.pats.iter().enumerate() {\n             let map_i = self.binding_mode_map(&**p);\n \n@@ -5695,18 +5702,18 @@ impl<'a> Resolver<'a> {\n         for (i, other) in maybes.iter().enumerate() {\n             *values.get_mut(i) = name.lev_distance(other.get());\n \n-            if *values.get(i) <= *values.get(smallest) {\n+            if values[i] <= values[smallest] {\n                 smallest = i;\n             }\n         }\n \n         if values.len() > 0 &&\n-            *values.get(smallest) != uint::MAX &&\n-            *values.get(smallest) < name.len() + 2 &&\n-            *values.get(smallest) <= max_distance &&\n-            name != maybes.get(smallest).get() {\n+            values[smallest] != uint::MAX &&\n+            values[smallest] < name.len() + 2 &&\n+            values[smallest] <= max_distance &&\n+            name != maybes[smallest].get() {\n \n-            Some(maybes.get(smallest).get().to_string())\n+            Some(maybes[smallest].get().to_string())\n \n         } else {\n             None"}, {"sha": "eda4c241f86cf4211a0f40f9fb44c91c7869e5c7", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -399,7 +399,7 @@ impl<'a> LifetimeContext<'a> {\n \n     fn check_lifetime_defs(&mut self, lifetimes: &Vec<ast::LifetimeDef>) {\n         for i in range(0, lifetimes.len()) {\n-            let lifetime_i = lifetimes.get(i);\n+            let lifetime_i = &lifetimes[i];\n \n             let special_idents = [special_idents::static_lifetime];\n             for lifetime in lifetimes.iter() {\n@@ -413,7 +413,7 @@ impl<'a> LifetimeContext<'a> {\n             }\n \n             for j in range(i + 1, lifetimes.len()) {\n-                let lifetime_j = lifetimes.get(j);\n+                let lifetime_j = &lifetimes[j];\n \n                 if lifetime_i.lifetime.name == lifetime_j.lifetime.name {\n                     self.sess.span_err("}, {"sha": "dd9601f1c3cfab28f074b011a70c0bfdce86465f", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -208,7 +208,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.bug(format!(\"def_map has no key for {} in lookup_type_ref\",\n                                   ref_id).as_slice());\n         }\n-        let def = *self.analysis.ty_cx.def_map.borrow().get(&ref_id);\n+        let def = (*self.analysis.ty_cx.def_map.borrow())[ref_id];\n         match def {\n             def::DefPrimTy(_) => None,\n             _ => Some(def.def_id()),\n@@ -221,7 +221,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.span_bug(span, format!(\"def_map has no key for {} in lookup_def_kind\",\n                                              ref_id).as_slice());\n         }\n-        let def = *def_map.get(&ref_id);\n+        let def = (*def_map)[ref_id];\n         match def {\n             def::DefMod(_) |\n             def::DefForeignMod(_) => Some(recorder::ModRef),\n@@ -261,7 +261,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             let span_utils = self.span;\n             for &(id, ref p, _, _) in self.collected_paths.iter() {\n                 let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n-                    *self.analysis.ty_cx.node_types.borrow().get(&(id as uint)));\n+                    (*self.analysis.ty_cx.node_types.borrow())[id as uint]);\n                 // get the span only for the name of the variable (I hope the path is only ever a\n                 // variable name, but who knows?)\n                 self.fmt.formal_str(p.span,\n@@ -302,7 +302,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                 },\n                                 None => {}\n                             }\n-                            result.append(\">::\")\n+                            result.push_str(\">::\");\n+                            result\n                         }\n                         _ => {\n                             self.sess.span_bug(method.span,\n@@ -326,8 +327,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     scope_id = def_id.node;\n                     match self.analysis.ty_cx.map.get(def_id.node) {\n                         NodeItem(_) => {\n-                            let result = ty::item_path_str(&self.analysis.ty_cx, def_id);\n-                            result.append(\"::\")\n+                            let mut result = ty::item_path_str(&self.analysis.ty_cx, def_id);\n+                            result.push_str(\"::\");\n+                            result\n                         }\n                         _ => {\n                             self.sess.span_bug(method.span,\n@@ -350,12 +352,16 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         // record the decl for this def (if it has one)\n         let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n                                              ast_util::local_def(method.id))\n-            .filtered(|def_id| {\n-                match *def_id {\n+            .and_then(|def_id| {\n+                if match def_id {\n                     ty::MethodTraitItemId(def_id) => {\n                         method.id != 0 && def_id.node == 0\n                     }\n                     ty::TypeTraitItemId(_) => false,\n+                } {\n+                    Some(def_id)\n+                } else {\n+                    None\n                 }\n             });\n         let decl_id = match decl_id {\n@@ -421,7 +427,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 let name = get_ident(ident);\n                 let qualname = format!(\"{}::{}\", qualname, name);\n                 let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n-                    *self.analysis.ty_cx.node_types.borrow().get(&(field.node.id as uint)));\n+                    (*self.analysis.ty_cx.node_types.borrow())[field.node.id as uint]);\n                 match self.span.sub_span_before_token(field.span, token::COLON) {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n                                                          Some(sub_span),\n@@ -590,7 +596,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for variant in enum_definition.variants.iter() {\n             let name = get_ident(variant.node.name);\n             let name = name.get();\n-            let qualname = qualname.clone().append(\"::\").append(name);\n+            let mut qualname = qualname.clone();\n+            qualname.push_str(\"::\");\n+            qualname.push_str(name);\n             let val = self.span.snippet(variant.span);\n             match variant.node.kind {\n                 ast::TupleVariantKind(ref args) => {\n@@ -758,7 +766,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                format!(\"def_map has no key for {} in visit_expr\",\n                                        ex.id).as_slice());\n         }\n-        let def = def_map.get(&ex.id);\n+        let def = &(*def_map)[ex.id];\n         let sub_span = self.span.span_for_last_ident(ex.span);\n         match *def {\n             def::DefUpvar(..) |\n@@ -796,7 +804,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                  .ty_cx\n                                                  .impl_items\n                                                  .borrow();\n-                            Some(impl_items.get(&def_id)\n+                            Some((*impl_items)[def_id]\n                                            .iter()\n                                            .find(|mr| {\n                                             ty::impl_or_trait_item(\n@@ -897,7 +905,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                            ex: &ast::Expr,\n                            args: &Vec<P<ast::Expr>>) {\n         let method_map = self.analysis.ty_cx.method_map.borrow();\n-        let method_callee = method_map.get(&typeck::MethodCall::expr(ex.id));\n+        let method_callee = &(*method_map)[typeck::MethodCall::expr(ex.id)];\n         let (def_id, decl_id) = match method_callee.origin {\n             typeck::MethodStatic(def_id) |\n             typeck::MethodStaticUnboxedClosure(def_id) => {\n@@ -1116,7 +1124,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                                            ast_util::local_def(method_type.id)) {\n                     Some(def_id) => {\n                         scope_id = def_id.node;\n-                        ty::item_path_str(&self.analysis.ty_cx, def_id).append(\"::\")\n+                        let mut s = ty::item_path_str(&self.analysis.ty_cx, def_id);\n+                        s.push_str(\"::\");\n+                        s\n                     },\n                     None => {\n                         self.sess.span_bug(method_type.span,\n@@ -1347,7 +1357,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     return\n                 }\n \n-                let id = String::from_str(\"$\").append(ex.id.to_string().as_slice());\n+                let mut id = String::from_str(\"$\");\n+                id.push_str(ex.id.to_string().as_slice());\n                 self.process_formals(&decl.inputs, id.as_slice());\n \n                 // walk arg and return types\n@@ -1399,7 +1410,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                    format!(\"def_map has no key for {} in visit_arm\",\n                                            id).as_slice());\n             }\n-            let def = def_map.get(&id);\n+            let def = &(*def_map)[id];\n             match *def {\n                 def::DefLocal(id)  => self.fmt.variable_str(p.span,\n                                                             sub_span,\n@@ -1449,7 +1460,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         for &(id, ref p, ref immut, _) in self.collected_paths.iter() {\n             let value = if *immut { value.to_string() } else { \"<mutable>\".to_string() };\n             let types = self.analysis.ty_cx.node_types.borrow();\n-            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, *types.get(&(id as uint)));\n+            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, (*types)[id as uint]);\n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?).\n             let sub_span = self.span.span_for_last_ident(p.span);"}, {"sha": "9dd2e8d143770514ee3fb078674e68d379dee9ed", "filename": "src/librustc/middle/save/recorder.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Frecorder.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -165,12 +165,18 @@ impl<'a> FmtStrs<'a> {\n         let pairs = fields.iter().zip(values);\n         let mut strs = pairs.map(|(f, v)| format!(\",{},\\\"{}\\\"\", f, escape(\n             if *f == \"qualname\" {\n-                self.krate.clone().append(\"::\").append(v)\n+                let mut n = self.krate.clone();\n+                n.push_str(\"::\");\n+                n.push_str(v);\n+                n\n             } else {\n                 String::from_str(v)\n             }\n         )));\n-        Some(strs.fold(String::new(), |s, ss| s.append(ss.as_slice())))\n+        Some(strs.fold(String::new(), |mut s, ss| {\n+            s.push_str(ss.as_slice());\n+            s\n+        }))\n     }\n \n     pub fn record_without_span(&mut self,\n@@ -195,8 +201,10 @@ impl<'a> FmtStrs<'a> {\n             None => return,\n         };\n \n-        let result = String::from_str(label);\n-        self.recorder.record(result.append(values_str.as_slice()).append(\"\\n\").as_slice());\n+        let mut result = String::from_str(label);\n+        result.push_str(values_str.as_slice());\n+        result.push_str(\"\\n\");\n+        self.recorder.record(result.as_slice());\n     }\n \n     pub fn record_with_span(&mut self,\n@@ -252,7 +260,9 @@ impl<'a> FmtStrs<'a> {\n         // the local case they can be overridden in one block and there is no nice way\n         // to refer to such a scope in english, so we just hack it by appending the\n         // variable def's node id\n-        let qualname = String::from_str(name).append(\"$\").append(id.to_string().as_slice());\n+        let mut qualname = String::from_str(name);\n+        qualname.push_str(\"$\");\n+        qualname.push_str(id.to_string().as_slice());\n         self.check_and_record(Variable,\n                               span,\n                               sub_span,\n@@ -267,7 +277,9 @@ impl<'a> FmtStrs<'a> {\n                       fn_name: &str,\n                       name: &str,\n                       typ: &str) {\n-        let qualname = String::from_str(fn_name).append(\"::\").append(name);\n+        let mut qualname = String::from_str(fn_name);\n+        qualname.push_str(\"::\");\n+        qualname.push_str(name);\n         self.check_and_record(Variable,\n                               span,\n                               sub_span,"}, {"sha": "54ae4d124f61f3c8c951e24572179da7a534b7de", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -315,8 +315,8 @@ impl<T> VecPerParamSpace<T> {\n         let type_limit = t.len();\n         let self_limit = t.len() + s.len();\n         let mut content = t;\n-        content.push_all_move(s);\n-        content.push_all_move(f);\n+        content.extend(s.into_iter());\n+        content.extend(f.into_iter());\n         VecPerParamSpace {\n             type_limit: type_limit,\n             self_limit: self_limit,"}, {"sha": "aca7054018dc6e1f2a7ca217107416114896401f", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -31,7 +31,6 @@ use middle::ty_fold::TypeFoldable;\n use std::cell::RefCell;\n use std::collections::hashmap::HashMap;\n use std::rc::Rc;\n-use std::result;\n use syntax::ast;\n use util::ppaux::Repr;\n \n@@ -1221,18 +1220,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                            nested: Vec<ty::t>)\n                            -> VtableBuiltinData<Obligation>\n     {\n-        let obligations =\n-            result::collect(\n-                nested\n-                    .iter()\n-                    .map(|&t| {\n-                        util::obligation_for_builtin_bound(\n-                            self.tcx(),\n-                            obligation.cause,\n-                            bound,\n-                            obligation.recursion_depth + 1,\n-                            t)\n-                    }));\n+        let obligations = nested.iter().map(|&t| {\n+            util::obligation_for_builtin_bound(\n+                self.tcx(),\n+                obligation.cause,\n+                bound,\n+                obligation.recursion_depth + 1,\n+                t)\n+        }).collect::<Result<_, _>>();\n         let obligations = match obligations {\n             Ok(o) => o,\n             Err(ErrorReported) => Vec::new()\n@@ -1302,7 +1297,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 |br| self.infcx.next_region_var(\n                          infer::LateBoundRegion(obligation.cause.span, br)));\n \n-        let arguments_tuple = *new_signature.inputs.get(0);\n+        let arguments_tuple = new_signature.inputs[0];\n         let trait_ref = Rc::new(ty::TraitRef {\n             def_id: obligation.trait_ref.def_id,\n             substs: Substs::new_trait("}, {"sha": "9ee2c3aa14907a62af334d681632ecedd18a6c54", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -110,7 +110,7 @@ impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef>> for Supertraits<'cx, 'tcx> {\n     fn next(&mut self) -> Option<Rc<ty::TraitRef>> {\n         loop {\n             // Extract next item from top-most stack frame, if any.\n-            let next_trait = match self.stack.mut_last() {\n+            let next_trait = match self.stack.last_mut() {\n                 None => {\n                     // No more stack frames. Done.\n                     return None;\n@@ -121,8 +121,7 @@ impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef>> for Supertraits<'cx, 'tcx> {\n                         // Still more supertraits left in the top stack frame.\n                         entry.position += 1;\n \n-                        let next_trait =\n-                            (*entry.supertraits.get(p)).clone();\n+                        let next_trait = entry.supertraits[p].clone();\n                         Some(next_trait)\n                     } else {\n                         None"}, {"sha": "be02b6a1c81fee592c8b294dbfb7a7b00a58f028", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -369,7 +369,7 @@ impl<'a, 'p, 'blk, 'tcx> Repr for Match<'a, 'p, 'blk, 'tcx> {\n \n fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     for br in m.iter() {\n-        match br.pats.get(col).node {\n+        match br.pats[col].node {\n             ast::PatIdent(_, _, Some(_)) => return true,\n             _ => ()\n         }\n@@ -391,7 +391,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     m.iter().map(|br| {\n         let mut bound_ptrs = br.bound_ptrs.clone();\n-        let mut pat = *br.pats.get(col);\n+        let mut pat = br.pats[col];\n         loop {\n             pat = match pat.node {\n                 ast::PatIdent(_, ref path, Some(ref inner)) => {\n@@ -430,7 +430,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     m.iter().filter_map(|br| {\n         e(br.pats.as_slice()).map(|pats| {\n-            let this = *br.pats.get(col);\n+            let this = br.pats[col];\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n                 ast::PatIdent(_, ref path, None) => {\n@@ -476,7 +476,9 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Collect all of the matches that can match against anything.\n     enter_match(bcx, dm, m, col, val, |pats| {\n         if pat_is_binding_or_wild(dm, &*pats[col]) {\n-            Some(Vec::from_slice(pats[..col]).append(pats[col + 1..]))\n+            let mut r = pats[..col].to_vec();\n+            r.push_all(pats[col + 1..]);\n+            Some(r)\n         } else {\n             None\n         }\n@@ -561,7 +563,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let mut found: Vec<Opt> = vec![];\n     for br in m.iter() {\n-        let cur = *br.pats.get(col);\n+        let cur = br.pats[col];\n         let opt = match cur.node {\n             ast::PatLit(ref l) => ConstantValue(ConstantExpr(&**l)),\n             ast::PatIdent(..) | ast::PatEnum(..) | ast::PatStruct(..) => {\n@@ -672,7 +674,7 @@ fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n macro_rules! any_pat (\n     ($m:expr, $col:expr, $pattern:pat) => (\n         ($m).iter().any(|br| {\n-            match br.pats.get($col).node {\n+            match br.pats[$col].node {\n                 $pattern => true,\n                 _ => false\n             }\n@@ -690,7 +692,7 @@ fn any_region_pat(m: &[Match], col: uint) -> bool {\n \n fn any_irrefutable_adt_pat(tcx: &ty::ctxt, m: &[Match], col: uint) -> bool {\n     m.iter().any(|br| {\n-        let pat = *br.pats.get(col);\n+        let pat = br.pats[col];\n         match pat.node {\n             ast::PatTup(_) => true,\n             ast::PatStruct(..) => {\n@@ -967,7 +969,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         None => {\n             let data = &m[0].data;\n             for &(ref ident, ref value_ptr) in m[0].bound_ptrs.iter() {\n-                let llmatch = data.bindings_map.get(ident).llmatch;\n+                let llmatch = data.bindings_map[*ident].llmatch;\n                 call_lifetime_start(bcx, llmatch);\n                 Store(bcx, *value_ptr, llmatch);\n             }\n@@ -999,12 +1001,13 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n     let dm = &tcx.def_map;\n \n-    let vals_left = Vec::from_slice(vals[0u..col]).append(vals[col + 1u..vals.len()]);\n+    let mut vals_left = vals[0u..col].to_vec();\n+    vals_left.push_all(vals[col + 1u..]);\n     let ccx = bcx.fcx.ccx;\n \n     // Find a real id (we're adding placeholder wildcard patterns, but\n     // each column is guaranteed to have at least one real pattern)\n-    let pat_id = m.iter().map(|br| br.pats.get(col).id)\n+    let pat_id = m.iter().map(|br| br.pats[col].id)\n                          .find(|&id| id != DUMMY_NODE_ID)\n                          .unwrap_or(DUMMY_NODE_ID);\n \n@@ -1041,7 +1044,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                         &check_match::Single, col,\n                                         field_vals.len())\n             );\n-            let vals = field_vals.append(vals_left.as_slice());\n+            let mut vals = field_vals;\n+            vals.push_all(vals_left.as_slice());\n             compile_submatch(bcx, pats.as_slice(), vals.as_slice(), chk, has_genuine_default);\n             return;\n         }\n@@ -1055,7 +1059,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let mut test_val = val;\n     debug!(\"test_val={}\", bcx.val_to_string(test_val));\n     if opts.len() > 0u {\n-        match *opts.get(0) {\n+        match opts[0] {\n             ConstantValue(_) | ConstantRange(_, _) => {\n                 test_val = load_if_immediate(bcx, val, left_ty);\n                 kind = if ty::type_is_integral(left_ty) {\n@@ -1194,7 +1198,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             ConstantValue(_) | ConstantRange(_, _) => ()\n         }\n         let opt_ms = enter_opt(opt_cx, pat_id, dm, m, opt, col, size, val);\n-        let opt_vals = unpacked.append(vals_left.as_slice());\n+        let mut opt_vals = unpacked;\n+        opt_vals.push_all(vals_left.as_slice());\n         compile_submatch(opt_cx,\n                          opt_ms.as_slice(),\n                          opt_vals.as_slice(),\n@@ -1358,7 +1363,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     let arm_datas: Vec<ArmData> = arms.iter().map(|arm| ArmData {\n         bodycx: fcx.new_id_block(\"case_body\", arm.body.id),\n         arm: arm,\n-        bindings_map: create_bindings_map(bcx, &**arm.pats.get(0), discr_expr, &*arm.body)\n+        bindings_map: create_bindings_map(bcx, &*arm.pats[0], discr_expr, &*arm.body)\n     }).collect();\n \n     let mut static_inliner = StaticInliner::new(scope_cx.tcx());\n@@ -1654,7 +1659,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                     val);\n                     for sub_pat in sub_pats.iter() {\n                         for (i, &argval) in args.vals.iter().enumerate() {\n-                            bcx = bind_irrefutable_pat(bcx, &**sub_pat.get(i),\n+                            bcx = bind_irrefutable_pat(bcx, &*sub_pat[i],\n                                                        argval, cleanup_scope);\n                         }\n                     }"}, {"sha": "802ca56fd3bf651126eb8fb6d557a4f60d6ad072", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -224,7 +224,7 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                 // Equivalent to a struct/tuple/newtype.\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n-                let mut ftys = cases.get(0).tys.clone();\n+                let mut ftys = cases[0].tys.clone();\n                 if dtor { ftys.push(ty::mk_bool()); }\n                 return Univariant(mk_struct(cx, ftys.as_slice(), false, t),\n                                   dtor);\n@@ -234,23 +234,23 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                 // Nullable pointer optimization\n                 let mut discr = 0;\n                 while discr < 2 {\n-                    if cases.get(1 - discr).is_zerolen(cx, t) {\n-                        let st = mk_struct(cx, cases.get(discr).tys.as_slice(),\n+                    if cases[1 - discr].is_zerolen(cx, t) {\n+                        let st = mk_struct(cx, cases[discr].tys.as_slice(),\n                                            false, t);\n-                        match cases.get(discr).find_ptr() {\n+                        match cases[discr].find_ptr() {\n                             Some(ThinPointer(_)) if st.fields.len() == 1 => {\n                                 return RawNullablePointer {\n                                     nndiscr: discr as Disr,\n-                                    nnty: *st.fields.get(0),\n-                                    nullfields: cases.get(1 - discr).tys.clone()\n+                                    nnty: st.fields[0],\n+                                    nullfields: cases[1 - discr].tys.clone()\n                                 };\n                             }\n                             Some(ptrfield) => {\n                                 return StructWrappedNullablePointer {\n                                     nndiscr: discr as Disr,\n                                     nonnull: st,\n                                     ptrfield: ptrfield,\n-                                    nullfields: cases.get(1 - discr).tys.clone()\n+                                    nullfields: cases[1 - discr].tys.clone()\n                                 };\n                             }\n                             None => { }\n@@ -267,7 +267,8 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             let ity = range_to_inttype(cx, hint, &bounds);\n \n             let fields : Vec<_> = cases.iter().map(|c| {\n-                let mut ftys = vec!(ty_of_inttype(ity)).append(c.tys.as_slice());\n+                let mut ftys = vec!(ty_of_inttype(ity));\n+                ftys.push_all(c.tys.as_slice());\n                 if dtor { ftys.push(ty::mk_bool()); }\n                 mk_struct(cx, ftys.as_slice(), false, t)\n             }).collect();\n@@ -369,7 +370,7 @@ fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool, scapegoat: ty::t) -\n         align: machine::llalign_of_min(cx, llty_rec),\n         sized: sized,\n         packed: packed,\n-        fields: Vec::from_slice(tys),\n+        fields: tys.to_vec(),\n     }\n }\n \n@@ -745,7 +746,7 @@ pub fn trans_set_discr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr) {\n         General(ity, ref cases, dtor) => {\n             if dtor {\n                 let ptr = trans_field_ptr(bcx, r, val, discr,\n-                                          cases.get(discr as uint).fields.len() - 2);\n+                                          cases[discr as uint].fields.len() - 2);\n                 Store(bcx, C_u8(bcx.ccx(), 1), ptr);\n             }\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n@@ -769,7 +770,7 @@ pub fn trans_set_discr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr) {\n                 let (llptrptr, llptrty) = match ptrfield {\n                     ThinPointer(field) =>\n                         (GEPi(bcx, val, [0, field]),\n-                         type_of::type_of(bcx.ccx(), *nonnull.fields.get(field))),\n+                         type_of::type_of(bcx.ccx(), nonnull.fields[field])),\n                     FatPointer(field, pair) => {\n                         let v = GEPi(bcx, val, [0, field, pair]);\n                         (v, val_ty(v).element_type())\n@@ -800,7 +801,7 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n         General(_, ref cases, dtor) => {\n-            cases.get(discr as uint).fields.len() - 1 - (if dtor { 1 } else { 0 })\n+            cases[discr as uint].fields.len() - 1 - (if dtor { 1 } else { 0 })\n         }\n         RawNullablePointer { nndiscr, ref nullfields, .. } => {\n             if discr == nndiscr { 1 } else { nullfields.len() }\n@@ -827,13 +828,13 @@ pub fn trans_field_ptr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr,\n             struct_field_ptr(bcx, st, val, ix, false)\n         }\n         General(_, ref cases, _) => {\n-            struct_field_ptr(bcx, cases.get(discr as uint), val, ix + 1, true)\n+            struct_field_ptr(bcx, &cases[discr as uint], val, ix + 1, true)\n         }\n         RawNullablePointer { nndiscr, ref nullfields, .. } |\n         StructWrappedNullablePointer { nndiscr, ref nullfields, .. } if discr != nndiscr => {\n             // The unit-like case might have a nonzero number of unit-like fields.\n             // (e.d., Result of Either with (), as one side.)\n-            let ty = type_of::type_of(bcx.ccx(), *nullfields.get(ix));\n+            let ty = type_of::type_of(bcx.ccx(), nullfields[ix]);\n             assert_eq!(machine::llsize_of_alloc(bcx.ccx(), ty), 0);\n             // The contents of memory at this pointer can't matter, but use\n             // the value that's \"reasonable\" in case of pointer comparison.\n@@ -965,14 +966,14 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n             C_integral(ll_inttype(ccx, ity), discr as u64, true)\n         }\n         General(ity, ref cases, _) => {\n-            let case = cases.get(discr as uint);\n+            let case = &cases[discr as uint];\n             let max_sz = cases.iter().map(|x| x.size).max().unwrap();\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n-            let contents = build_const_struct(ccx,\n-                                              case,\n-                                              (vec!(lldiscr)).append(vals).as_slice());\n-            C_struct(ccx, contents.append([padding(ccx, max_sz - case.size)]).as_slice(),\n-                     false)\n+            let mut f = vec![lldiscr];\n+            f.push_all(vals);\n+            let mut contents = build_const_struct(ccx, case, f.as_slice());\n+            contents.push_all([padding(ccx, max_sz - case.size)]);\n+            C_struct(ccx, contents.as_slice(), false)\n         }\n         Univariant(ref st, _dro) => {\n             assert!(discr == 0);"}, {"sha": "04237a2d44925d6f4a6fd70aca43e64639d96939", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -62,7 +62,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     }).collect::<Vec<_>>();\n \n     // Now the input operands\n-    let inputs = ia.inputs.iter().map(|&(ref c, ref input)| {\n+    let mut inputs = ia.inputs.iter().map(|&(ref c, ref input)| {\n         constraints.push((*c).clone());\n \n         let in_datum = unpack_datum!(bcx, expr::trans(bcx, &**input));\n@@ -73,7 +73,8 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n                                     cleanup::CustomScope(temp_scope),\n                                     callee::DontAutorefArg)\n         })\n-    }).collect::<Vec<_>>().append(ext_inputs.as_slice());\n+    }).collect::<Vec<_>>();\n+    inputs.push_all(ext_inputs.as_slice());\n \n     // no failure occurred preparing operands, no need to cleanup\n     fcx.pop_custom_cleanup_scope(temp_scope);\n@@ -95,7 +96,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n \n     // Add the clobbers to our constraints list\n     if clobbers.len() != 0 && constraints.len() != 0 {\n-        constraints.push_char(',');\n+        constraints.push(',');\n         constraints.push_str(clobbers.as_slice());\n     } else {\n         constraints.push_str(clobbers.as_slice());\n@@ -109,7 +110,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     let output_type = if num_outputs == 0 {\n         Type::void(bcx.ccx())\n     } else if num_outputs == 1 {\n-        *output_types.get(0)\n+        output_types[0]\n     } else {\n         Type::struct_(bcx.ccx(), output_types.as_slice(), false)\n     };\n@@ -134,7 +135,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n \n     // Again, based on how many outputs we have\n     if num_outputs == 1 {\n-        Store(bcx, r, *outputs.get(0));\n+        Store(bcx, r, outputs[0]);\n     } else {\n         for (i, o) in outputs.iter().enumerate() {\n             let v = ExtractValue(bcx, r, i);"}, {"sha": "239193ab79a93d99a6bd2c15dab20dfbb3ad3f74", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -259,7 +259,7 @@ pub fn self_type_for_unboxed_closure(ccx: &CrateContext,\n                                                       closure_id,\n                                                       ty::ReStatic);\n     let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n-    let unboxed_closure = unboxed_closures.get(&closure_id);\n+    let unboxed_closure = &(*unboxed_closures)[closure_id];\n     match unboxed_closure.kind {\n         ty::FnUnboxedClosureKind => {\n             ty::mk_imm_rptr(ccx.tcx(), ty::ReStatic, unboxed_closure_type)\n@@ -274,7 +274,7 @@ pub fn self_type_for_unboxed_closure(ccx: &CrateContext,\n pub fn kind_for_unboxed_closure(ccx: &CrateContext, closure_id: ast::DefId)\n                                 -> ty::UnboxedClosureKind {\n     let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n-    unboxed_closures.get(&closure_id).kind\n+    (*unboxed_closures)[closure_id].kind\n }\n \n pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n@@ -287,7 +287,7 @@ pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n         }\n         ty::ty_unboxed_closure(closure_did, _) => {\n             let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n-            let unboxed_closure = unboxed_closures.get(&closure_did);\n+            let unboxed_closure = &(*unboxed_closures)[closure_did];\n             let function_type = unboxed_closure.closure_type.clone();\n             let self_type = self_type_for_unboxed_closure(ccx, closure_did);\n             let llenvironment_type = type_of_explicit_arg(ccx, self_type);\n@@ -771,7 +771,7 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n           match adt::trans_switch(cx, &*repr, av) {\n               (_match::Single, None) => {\n-                  cx = iter_variant(cx, &*repr, av, &**variants.get(0),\n+                  cx = iter_variant(cx, &*repr, av, &*(*variants)[0],\n                                     substs, f);\n               }\n               (_match::Switch, Some(lldiscrim_a)) => {\n@@ -2121,7 +2121,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n                                      ({} bytes) than the next largest (ignoring padding)\",\n                                     largest).as_slice());\n \n-        ccx.sess().span_note(enum_def.variants.get(largest_index).span,\n+        ccx.sess().span_note(enum_def.variants[largest_index].span,\n                              \"this variant is the largest\");\n     }\n }\n@@ -2353,7 +2353,7 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n         ty::ty_bare_fn(ref f) => (f.sig.clone(), f.abi, false),\n         ty::ty_unboxed_closure(closure_did, _) => {\n             let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n-            let ref function_type = unboxed_closures.get(&closure_did)\n+            let ref function_type = (*unboxed_closures)[closure_did]\n                                                     .closure_type;\n \n             (function_type.sig.clone(), RustCall, true)\n@@ -2381,11 +2381,14 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n             }\n         },\n         ty::ty_bare_fn(_) if abi == RustCall => {\n-            let inputs = vec![fn_sig.inputs[0]];\n+            let mut inputs = vec![fn_sig.inputs[0]];\n \n             match ty::get(fn_sig.inputs[1]).sty {\n                 ty::ty_nil => inputs,\n-                ty::ty_tup(ref t_in) => inputs.append(t_in.as_slice()),\n+                ty::ty_tup(ref t_in) => {\n+                    inputs.push_all(t_in.as_slice());\n+                    inputs\n+                }\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         }\n@@ -2904,13 +2907,11 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n \n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let metadata = encoder::encode_metadata(encode_parms, krate);\n-    let compressed = Vec::from_slice(encoder::metadata_encoding_version)\n-                     .append(match flate::deflate_bytes(metadata.as_slice()) {\n-                         Some(compressed) => compressed,\n-                         None => {\n-                             cx.sess().fatal(\"failed to compress metadata\")\n-                         }\n-                     }.as_slice());\n+    let mut compressed = encoder::metadata_encoding_version.to_vec();\n+    compressed.push_all(match flate::deflate_bytes(metadata.as_slice()) {\n+        Some(compressed) => compressed,\n+        None => cx.sess().fatal(\"failed to compress metadata\"),\n+    }.as_slice());\n     let llmeta = C_bytes_in_context(cx.metadata_llcx(), compressed.as_slice());\n     let llconst = C_struct_in_context(cx.metadata_llcx(), [llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\","}, {"sha": "81428937e4b1f3d179ccc1fe5dcb3625d26f11ac", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -72,13 +72,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let mut s = String::from_str(\".\");\n                 i = 0u;\n                 while i < len {\n-                    i = *mm.get(&v[i]);\n-                    s.push_char('/');\n+                    i = mm[v[i]];\n+                    s.push('/');\n                     s.push_str(v[i]);\n                     i += 1u;\n                 }\n \n-                s.push_char('/');\n+                s.push('/');\n                 s.push_str(category);\n \n                 let n = match h.find(&s) {"}, {"sha": "1b8a354259ad785977df301be29db8335658ca6b", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -316,7 +316,7 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n                 tys.push(Type::i64(ccx));\n             }\n             SSEFv => {\n-                let vec_len = llvec_len(cls.tailn(i + 1u));\n+                let vec_len = llvec_len(cls[i + 1u..]);\n                 let vec_ty = Type::vector(&Type::f32(ccx), (vec_len * 2u) as u64);\n                 tys.push(vec_ty);\n                 i += vec_len;"}, {"sha": "d610a80347baffa8d6ac5aeff1c57cd8dbbece43", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -260,7 +260,7 @@ pub fn trans_unboxing_shim(bcx: Block,\n     let tcx = bcx.tcx();\n \n     // Transform the self type to `Box<self_type>`.\n-    let self_type = *fty.sig.inputs.get(0);\n+    let self_type = fty.sig.inputs[0];\n     let boxed_self_type = ty::mk_uniq(tcx, self_type);\n     let boxed_function_type = ty::FnSig {\n         binder_id: fty.sig.binder_id,\n@@ -332,9 +332,9 @@ pub fn trans_unboxing_shim(bcx: Block,\n     let arg_scope = fcx.push_custom_cleanup_scope();\n     let arg_scope_id = cleanup::CustomScope(arg_scope);\n     let boxed_arg_types = ty::ty_fn_args(boxed_function_type);\n-    let boxed_self_type = *boxed_arg_types.get(0);\n+    let boxed_self_type = boxed_arg_types[0];\n     let arg_types = ty::ty_fn_args(function_type);\n-    let self_type = *arg_types.get(0);\n+    let self_type = arg_types[0];\n     let boxed_self_kind = arg_kind(&fcx, boxed_self_type);\n \n     // Create a datum for self.\n@@ -541,7 +541,7 @@ pub fn trans_fn_ref_with_substs(\n             let ref_ty = match node {\n                 ExprId(id) => node_id_type(bcx, id),\n                 MethodCall(method_call) => {\n-                    let t = bcx.tcx().method_map.borrow().get(&method_call).ty;\n+                    let t = (*bcx.tcx().method_map.borrow())[method_call].ty;\n                     monomorphize_type(bcx, t)\n                 }\n             };\n@@ -628,7 +628,7 @@ pub fn trans_method_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_ex={})\", call_ex.repr(bcx.tcx()));\n     let method_call = MethodCall::expr(call_ex.id);\n-    let method_ty = bcx.tcx().method_map.borrow().get(&method_call).ty;\n+    let method_ty = (*bcx.tcx().method_map.borrow())[method_call].ty;\n     trans_call_inner(\n         bcx,\n         Some(common::expr_info(call_ex)),\n@@ -915,7 +915,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n         let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &*arg_exprs[0]));\n         llargs.push(unpack_result!(bcx, {\n             trans_arg_datum(bcx,\n-                            *arg_tys.get(0),\n+                            arg_tys[0],\n                             arg_datum,\n                             arg_cleanup_scope,\n                             DontAutorefArg)\n@@ -940,7 +940,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n             for i in range(0, field_types.len()) {\n                 let arg_datum = tuple_lvalue_datum.get_element(\n                     bcx,\n-                    *field_types.get(i),\n+                    field_types[i],\n                     |srcval| {\n                         adt::trans_field_ptr(bcx, repr_ptr, srcval, 0, i)\n                     });\n@@ -976,15 +976,15 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n         let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_exprs[0]));\n         llargs.push(unpack_result!(bcx, {\n             trans_arg_datum(bcx,\n-                            *arg_tys.get(0),\n+                            arg_tys[0],\n                             arg_datum,\n                             arg_cleanup_scope,\n                             DontAutorefArg)\n         }))\n     }\n \n     // Now untuple the rest of the arguments.\n-    let tuple_type = *arg_tys.get(1);\n+    let tuple_type = arg_tys[1];\n     match ty::get(tuple_type).sty {\n         ty::ty_tup(ref field_types) => {\n             for (i, &field_type) in field_types.iter().enumerate() {\n@@ -1050,7 +1050,7 @@ pub fn trans_args<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                     assert!(variadic);\n                     expr_ty_adjusted(cx, &**arg_expr)\n                 } else {\n-                    *arg_tys.get(i)\n+                    arg_tys[i]\n                 };\n \n                 let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &**arg_expr));\n@@ -1073,15 +1073,15 @@ pub fn trans_args<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n             assert!(!variadic);\n \n             llargs.push(unpack_result!(bcx, {\n-                trans_arg_datum(bcx, *arg_tys.get(0), lhs,\n+                trans_arg_datum(bcx, arg_tys[0], lhs,\n                                 arg_cleanup_scope,\n                                 DontAutorefArg)\n             }));\n \n             assert_eq!(arg_tys.len(), 1 + rhs.len());\n-            for (rhs, rhs_id) in rhs.move_iter() {\n+            for (rhs, rhs_id) in rhs.into_iter() {\n                 llargs.push(unpack_result!(bcx, {\n-                    trans_arg_datum(bcx, *arg_tys.get(1), rhs,\n+                    trans_arg_datum(bcx, arg_tys[1], rhs,\n                                     arg_cleanup_scope,\n                                     DoAutorefArg(rhs_id))\n                 }));"}, {"sha": "827df48071af9221da0309ad38bed8b90d62e80d", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -549,7 +549,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n     fn is_valid_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool {\n         let scopes = self.scopes.borrow();\n         custom_scope.index < scopes.len() &&\n-            scopes.get(custom_scope.index).kind.is_temp()\n+            (*scopes)[custom_scope.index].kind.is_temp()\n     }\n \n     fn trans_scope_cleanups(&self, // cannot borrow self, will recurse"}, {"sha": "d620b037549430b33a95cdd9cc9afd4f9b70579c", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -473,7 +473,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n         closure_id).unwrap();\n \n     let unboxed_closures = bcx.tcx().unboxed_closures.borrow();\n-    let function_type = unboxed_closures.get(&closure_id)\n+    let function_type = (*unboxed_closures)[closure_id]\n                                         .closure_type\n                                         .clone();\n     let function_type = ty::mk_closure(bcx.tcx(), function_type);"}, {"sha": "945345425b3911759299669b356d701f13683c59", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -59,9 +59,9 @@ fn type_is_newtype_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n             fields.len() == 1 &&\n-                fields.get(0).ident.name ==\n+                fields[0].ident.name ==\n                     token::special_idents::unnamed_field.name &&\n-                type_is_immediate(ccx, fields.get(0).mt.ty)\n+                type_is_immediate(ccx, fields[0].mt.ty)\n         }\n         _ => false\n     }\n@@ -914,7 +914,7 @@ pub fn node_id_substs(bcx: Block,\n             ty::node_id_item_substs(tcx, id).substs\n         }\n         MethodCall(method_call) => {\n-            tcx.method_map.borrow().get(&method_call).substs.clone()\n+            (*tcx.method_map.borrow())[method_call].substs.clone()\n         }\n     };\n "}, {"sha": "399d2a0ec28059387840019c90e58478411d4f95", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -311,7 +311,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr) -> (ValueRef, ty::t) {\n fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n     let map_list = |exprs: &[P<ast::Expr>]| {\n         exprs.iter().map(|e| const_expr(cx, &**e).val0())\n-             .fold(Vec::new(), |l, val| l.append_one(val))\n+             .fold(Vec::new(), |mut l, val| { l.push(val); l })\n     };\n     unsafe {\n         let _icx = push_ctxt(\"const_expr\");"}, {"sha": "b2611987f04ea3f9c50bc512e90aa74be4fa2cbd", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -291,10 +291,9 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     // Set up the method call (to `.next()`).\n     let method_call = MethodCall::expr(loop_info.id);\n-    let method_type = loopback_bcx_in.tcx()\n+    let method_type = (*loopback_bcx_in.tcx()\n                                      .method_map\n-                                     .borrow()\n-                                     .get(&method_call)\n+                                     .borrow())[method_call]\n                                      .ty;\n     let method_type = monomorphize_type(loopback_bcx_in, method_type);\n     let method_result_type = ty::ty_fn_ret(method_type);"}, {"sha": "f2c965924cd191b44c434ea70b2789e076bb4841", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 52, "deletions": 54, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -348,7 +348,7 @@ impl TypeMap {\n         };\n \n         let mut unique_type_id = String::with_capacity(256);\n-        unique_type_id.push_char('{');\n+        unique_type_id.push('{');\n \n         match ty::get(type_).sty {\n             ty::ty_nil      |\n@@ -380,13 +380,13 @@ impl TypeMap {\n                 }\n             },\n             ty::ty_uniq(inner_type) => {\n-                unique_type_id.push_char('~');\n+                unique_type_id.push('~');\n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n                 unique_type_id.push_str(inner_type_id.as_slice());\n             },\n             ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n-                unique_type_id.push_char('*');\n+                unique_type_id.push('*');\n                 if mutbl == ast::MutMutable {\n                     unique_type_id.push_str(\"mut\");\n                 }\n@@ -396,7 +396,7 @@ impl TypeMap {\n                 unique_type_id.push_str(inner_type_id.as_slice());\n             },\n             ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n-                unique_type_id.push_char('&');\n+                unique_type_id.push('&');\n                 if mutbl == ast::MutMutable {\n                     unique_type_id.push_str(\"mut\");\n                 }\n@@ -443,7 +443,7 @@ impl TypeMap {\n                     let parameter_type_id =\n                         self.get_unique_type_id_as_string(parameter_type_id);\n                     unique_type_id.push_str(parameter_type_id.as_slice());\n-                    unique_type_id.push_char(',');\n+                    unique_type_id.push(',');\n                 }\n \n                 if sig.variadic {\n@@ -474,7 +474,7 @@ impl TypeMap {\n             }\n         };\n \n-        unique_type_id.push_char('}');\n+        unique_type_id.push('}');\n \n         // Trim to size before storing permanently\n         unique_type_id.shrink_to_fit();\n@@ -489,8 +489,6 @@ impl TypeMap {\n                                   def_id: ast::DefId,\n                                   substs: &subst::Substs,\n                                   output: &mut String) {\n-            use std::num::ToStrRadix;\n-\n             // First, find out the 'real' def_id of the type. Items inlined from\n             // other crates have to be mapped back to their source.\n             let source_def_id = if def_id.krate == ast::LOCAL_CRATE {\n@@ -515,24 +513,24 @@ impl TypeMap {\n \n             output.push_str(crate_hash.as_str());\n             output.push_str(\"/\");\n-            output.push_str(def_id.node.to_str_radix(16).as_slice());\n+            output.push_str(format!(\"{:x}\", def_id.node).as_slice());\n \n             // Maybe check that there is no self type here.\n \n             let tps = substs.types.get_slice(subst::TypeSpace);\n             if tps.len() > 0 {\n-                output.push_char('<');\n+                output.push('<');\n \n                 for &type_parameter in tps.iter() {\n                     let param_type_id =\n                         type_map.get_unique_type_id_of_type(cx, type_parameter);\n                     let param_type_id =\n                         type_map.get_unique_type_id_as_string(param_type_id);\n                     output.push_str(param_type_id.as_slice());\n-                    output.push_char(',');\n+                    output.push(',');\n                 }\n \n-                output.push_char('>');\n+                output.push('>');\n             }\n         }\n     }\n@@ -571,7 +569,7 @@ impl TypeMap {\n             let parameter_type_id =\n                 self.get_unique_type_id_as_string(parameter_type_id);\n             unique_type_id.push_str(parameter_type_id.as_slice());\n-            unique_type_id.push_char(',');\n+            unique_type_id.push(',');\n         }\n \n         if sig.variadic {\n@@ -584,7 +582,7 @@ impl TypeMap {\n         let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n         unique_type_id.push_str(return_type_id.as_slice());\n \n-        unique_type_id.push_char(':');\n+        unique_type_id.push(':');\n \n         for bound in bounds.builtin_bounds.iter() {\n             match bound {\n@@ -593,7 +591,7 @@ impl TypeMap {\n                 ty::BoundCopy => unique_type_id.push_str(\"Copy\"),\n                 ty::BoundSync => unique_type_id.push_str(\"Sync\"),\n             };\n-            unique_type_id.push_char('+');\n+            unique_type_id.push('+');\n         }\n     }\n \n@@ -1402,7 +1400,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             return create_DIArray(DIB(cx), []);\n         }\n \n-        name_to_append_suffix_to.push_char('<');\n+        name_to_append_suffix_to.push('<');\n \n         // The list to be filled with template parameters:\n         let mut template_params: Vec<DIDescriptor> =\n@@ -1483,7 +1481,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             }\n         }\n \n-        name_to_append_suffix_to.push_char('>');\n+        name_to_append_suffix_to.push('>');\n \n         return create_DIArray(DIB(cx), template_params.as_slice());\n     }\n@@ -1526,7 +1524,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n                             // prepend \"./\" if necessary\n                             let dotdot = b\"..\";\n                             let prefix = &[dotdot[0], ::std::path::SEP_BYTE];\n-                            let mut path_bytes = Vec::from_slice(p.as_vec());\n+                            let mut path_bytes = p.as_vec().to_vec();\n \n                             if path_bytes.slice_to(2) != prefix &&\n                                path_bytes.slice_to(2) != dotdot {\n@@ -1927,7 +1925,7 @@ impl StructMemberDescriptionFactory {\n         }\n \n         let field_size = if self.is_simd {\n-            machine::llsize_of_alloc(cx, type_of::type_of(cx, self.fields.get(0).mt.ty)) as uint\n+            machine::llsize_of_alloc(cx, type_of::type_of(cx, self.fields[0].mt.ty)) as uint\n         } else {\n             0xdeadbeef\n         };\n@@ -2038,7 +2036,7 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n                            UNKNOWN_SCOPE_METADATA),\n         tuple_llvm_type,\n         TupleMDF(TupleMemberDescriptionFactory {\n-            component_types: Vec::from_slice(component_types),\n+            component_types: component_types.to_vec(),\n             span: span,\n         })\n     )\n@@ -2081,7 +2079,7 @@ impl EnumMemberDescriptionFactory {\n                             describe_enum_variant(cx,\n                                                   self.enum_type,\n                                                   struct_def,\n-                                                  &**self.variants.get(i),\n+                                                  &*(*self.variants)[i],\n                                                   discriminant_info,\n                                                   self.containing_scope,\n                                                   self.span);\n@@ -2114,7 +2112,7 @@ impl EnumMemberDescriptionFactory {\n                         describe_enum_variant(cx,\n                                               self.enum_type,\n                                               struct_def,\n-                                              &**self.variants.get(0),\n+                                              &*(*self.variants)[0],\n                                               NoDiscriminant,\n                                               self.containing_scope,\n                                               self.span);\n@@ -2143,7 +2141,7 @@ impl EnumMemberDescriptionFactory {\n                 // DWARF representation of enums uniform.\n \n                 // First create a description of the artificial wrapper struct:\n-                let non_null_variant = self.variants.get(non_null_variant_index as uint);\n+                let non_null_variant = &(*self.variants)[non_null_variant_index as uint];\n                 let non_null_variant_ident = non_null_variant.name;\n                 let non_null_variant_name = token::get_ident(non_null_variant_ident);\n \n@@ -2160,7 +2158,7 @@ impl EnumMemberDescriptionFactory {\n                 // MemberDescription of the struct's single field.\n                 let sole_struct_member_description = MemberDescription {\n                     name: match non_null_variant.arg_names {\n-                        Some(ref names) => token::get_ident(*names.get(0)).get().to_string(),\n+                        Some(ref names) => token::get_ident(names[0]).get().to_string(),\n                         None => \"\".to_string()\n                     },\n                     llvm_type: non_null_llvm_type,\n@@ -2190,7 +2188,7 @@ impl EnumMemberDescriptionFactory {\n                 // Encode the information about the null variant in the union\n                 // member's name.\n                 let null_variant_index = (1 - non_null_variant_index) as uint;\n-                let null_variant_ident = self.variants.get(null_variant_index).name;\n+                let null_variant_ident = (*self.variants)[null_variant_index].name;\n                 let null_variant_name = token::get_ident(null_variant_ident);\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n                                                 0u,\n@@ -2216,7 +2214,7 @@ impl EnumMemberDescriptionFactory {\n                     describe_enum_variant(cx,\n                                           self.enum_type,\n                                           struct_def,\n-                                          &**self.variants.get(nndiscr as uint),\n+                                          &*(*self.variants)[nndiscr as uint],\n                                           OptimizedDiscriminant(ptrfield),\n                                           self.containing_scope,\n                                           self.span);\n@@ -2232,7 +2230,7 @@ impl EnumMemberDescriptionFactory {\n                 // Encode the information about the null variant in the union\n                 // member's name.\n                 let null_variant_index = (1 - nndiscr) as uint;\n-                let null_variant_ident = self.variants.get(null_variant_index).name;\n+                let null_variant_ident = (*self.variants)[null_variant_index].name;\n                 let null_variant_name = token::get_ident(null_variant_ident);\n                 let discrfield = match ptrfield {\n                     adt::ThinPointer(field) => format!(\"{}\", field),\n@@ -2706,14 +2704,14 @@ fn vec_slice_metadata(cx: &CrateContext,\n     let member_descriptions = [\n         MemberDescription {\n             name: \"data_ptr\".to_string(),\n-            llvm_type: *member_llvm_types.get(0),\n+            llvm_type: member_llvm_types[0],\n             type_metadata: element_type_metadata,\n             offset: ComputedMemberOffset,\n             flags: FLAGS_NONE\n         },\n         MemberDescription {\n             name: \"length\".to_string(),\n-            llvm_type: *member_llvm_types.get(1),\n+            llvm_type: member_llvm_types[1],\n             type_metadata: type_metadata(cx, ty::mk_uint(), span),\n             offset: ComputedMemberOffset,\n             flags: FLAGS_NONE\n@@ -3081,14 +3079,14 @@ fn bytes_to_bits(bytes: u64) -> u64 {\n \n #[inline]\n fn debug_context<'a>(cx: &'a CrateContext) -> &'a CrateDebugContext {\n-    let debug_context: &'a CrateDebugContext = cx.dbg_cx().get_ref();\n+    let debug_context: &'a CrateDebugContext = cx.dbg_cx().as_ref().unwrap();\n     debug_context\n }\n \n #[inline]\n #[allow(non_snake_case)]\n fn DIB(cx: &CrateContext) -> DIBuilderRef {\n-    cx.dbg_cx().get_ref().builder\n+    cx.dbg_cx().as_ref().unwrap().builder\n }\n \n fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n@@ -3576,7 +3574,7 @@ fn populate_scope_map(cx: &CrateContext,\n                 // same binding names.\n \n                 for arm_ref in arms.iter() {\n-                    let arm_span = arm_ref.pats.get(0).span;\n+                    let arm_span = arm_ref.pats[0].span;\n \n                     with_new_scope(cx,\n                                    arm_span,\n@@ -3671,22 +3669,22 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n             push_type_params(cx, substs, output);\n         },\n         ty::ty_tup(ref component_types) => {\n-            output.push_char('(');\n+            output.push('(');\n             for &component_type in component_types.iter() {\n                 push_debuginfo_type_name(cx, component_type, true, output);\n                 output.push_str(\", \");\n             }\n-            output.pop_char();\n-            output.pop_char();\n-            output.push_char(')');\n+            output.pop();\n+            output.pop();\n+            output.push(')');\n         },\n         ty::ty_uniq(inner_type) => {\n             output.push_str(\"Box<\");\n             push_debuginfo_type_name(cx, inner_type, true, output);\n-            output.push_char('>');\n+            output.push('>');\n         },\n         ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n-            output.push_char('*');\n+            output.push('*');\n             match mutbl {\n                 ast::MutImmutable => output.push_str(\"const \"),\n                 ast::MutMutable => output.push_str(\"mut \"),\n@@ -3695,15 +3693,15 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n             push_debuginfo_type_name(cx, inner_type, true, output);\n         },\n         ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n-            output.push_char('&');\n+            output.push('&');\n             if mutbl == ast::MutMutable {\n                 output.push_str(\"mut \");\n             }\n \n             push_debuginfo_type_name(cx, inner_type, true, output);\n         },\n         ty::ty_vec(inner_type, optional_length) => {\n-            output.push_char('[');\n+            output.push('[');\n             push_debuginfo_type_name(cx, inner_type, true, output);\n \n             match optional_length {\n@@ -3713,7 +3711,7 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n                 None => { /* nothing to do */ }\n             };\n \n-            output.push_char(']');\n+            output.push(']');\n         },\n         ty::ty_trait(ref trait_data) => {\n             push_item_name(cx, trait_data.def_id, false, output);\n@@ -3737,8 +3735,8 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n                     output.push_str(\", \");\n                 }\n-                output.pop_char();\n-                output.pop_char();\n+                output.pop();\n+                output.pop();\n             }\n \n             if sig.variadic {\n@@ -3749,7 +3747,7 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n                 }\n             }\n \n-            output.push_char(')');\n+            output.push(')');\n \n             if !ty::type_is_nil(sig.output) {\n                 output.push_str(\" -> \");\n@@ -3791,8 +3789,8 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n                     output.push_str(\", \");\n                 }\n-                output.pop_char();\n-                output.pop_char();\n+                output.pop();\n+                output.pop();\n             }\n \n             if sig.variadic {\n@@ -3803,7 +3801,7 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n                 }\n             }\n \n-            output.push_char(param_list_closing_char);\n+            output.push(param_list_closing_char);\n \n             if !ty::type_is_nil(sig.output) {\n                 output.push_str(\" -> \");\n@@ -3845,8 +3843,8 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n                     cx.sess().bug(\"debuginfo: Encountered empty item path!\");\n                 }\n \n-                output.pop_char();\n-                output.pop_char();\n+                output.pop();\n+                output.pop();\n             } else {\n                 let name = token::get_name(path.last()\n                                                .expect(\"debuginfo: Empty item path?\")\n@@ -3868,17 +3866,17 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n             return;\n         }\n \n-        output.push_char('<');\n+        output.push('<');\n \n         for &type_parameter in substs.types.iter() {\n             push_debuginfo_type_name(cx, type_parameter, true, output);\n             output.push_str(\", \");\n         }\n \n-        output.pop_char();\n-        output.pop_char();\n+        output.pop();\n+        output.pop();\n \n-        output.push_char('>');\n+        output.push('>');\n     }\n }\n \n@@ -3909,7 +3907,7 @@ impl NamespaceTreeNode {\n         fill_nested(self, &mut name);\n         name.push_str(format!(\"{}\", item_name.len()).as_slice());\n         name.push_str(item_name);\n-        name.push_char('E');\n+        name.push('E');\n         name\n     }\n }"}, {"sha": "d638286a9c5bd9244db04f8bcfcc5bb04c7d6d8d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -1079,7 +1079,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprMethodCall(_, _, ref args) => {\n             callee::trans_method_call(bcx,\n                                       expr,\n-                                      &**args.get(0),\n+                                      &*args[0],\n                                       callee::ArgExprs(args.as_slice()),\n                                       dest)\n         }\n@@ -1787,7 +1787,7 @@ fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    rhs: Vec<(Datum<Expr>, ast::NodeId)>,\n                                    dest: Option<Dest>)\n                                    -> Result<'blk, 'tcx> {\n-    let method_ty = bcx.tcx().method_map.borrow().get(&method_call).ty;\n+    let method_ty = (*bcx.tcx().method_map.borrow())[method_call].ty;\n     callee::trans_call_inner(bcx,\n                              Some(expr_info(expr)),\n                              monomorphize_type(bcx, method_ty),\n@@ -1808,11 +1808,10 @@ fn trans_overloaded_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                          dest: Option<Dest>)\n                                          -> Block<'blk, 'tcx> {\n     let method_call = MethodCall::expr(expr.id);\n-    let method_type = bcx.tcx()\n-                         .method_map\n-                         .borrow()\n-                         .get(&method_call)\n-                         .ty;\n+    let method_type = (*bcx.tcx()\n+                           .method_map\n+                           .borrow())[method_call]\n+                           .ty;\n     let mut all_args = vec!(callee);\n     all_args.extend(args.iter().map(|e| &**e));\n     unpack_result!(bcx,"}, {"sha": "406ccc56a62389c017d62b609db73812d299940a", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -321,8 +321,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n \n         // Does Rust pass this argument by pointer?\n-        let rust_indirect = type_of::arg_is_indirect(ccx,\n-                                                     *passed_arg_tys.get(i));\n+        let rust_indirect = type_of::arg_is_indirect(ccx, passed_arg_tys[i]);\n \n         debug!(\"argument {}, llarg_rust={}, rust_indirect={}, arg_ty={}\",\n                i,\n@@ -335,9 +334,9 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         if !rust_indirect {\n             let scratch =\n                 base::alloca(bcx,\n-                             type_of::type_of(ccx, *passed_arg_tys.get(i)),\n+                             type_of::type_of(ccx, passed_arg_tys[i]),\n                              \"__arg\");\n-            base::store_ty(bcx, llarg_rust, scratch, *passed_arg_tys.get(i));\n+            base::store_ty(bcx, llarg_rust, scratch, passed_arg_tys[i]);\n             llarg_rust = scratch;\n         }\n \n@@ -358,7 +357,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let llarg_foreign = if foreign_indirect {\n             llarg_rust\n         } else {\n-            if ty::type_is_bool(*passed_arg_tys.get(i)) {\n+            if ty::type_is_bool(passed_arg_tys[i]) {\n                 let val = LoadRangeAssert(bcx, llarg_rust, 0, 2, llvm::False);\n                 Trunc(bcx, val, Type::i1(bcx.ccx()))\n             } else {\n@@ -746,10 +745,10 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         // Careful to adapt for cases where the native convention uses\n         // a pointer and Rust does not or vice versa.\n         for i in range(0, tys.fn_sig.inputs.len()) {\n-            let rust_ty = *tys.fn_sig.inputs.get(i);\n-            let llrust_ty = *tys.llsig.llarg_tys.get(i);\n+            let rust_ty = tys.fn_sig.inputs[i];\n+            let llrust_ty = tys.llsig.llarg_tys[i];\n             let rust_indirect = type_of::arg_is_indirect(ccx, rust_ty);\n-            let llforeign_arg_ty = *tys.fn_ty.arg_tys.get(i);\n+            let llforeign_arg_ty = tys.fn_ty.arg_tys[i];\n             let foreign_indirect = llforeign_arg_ty.is_indirect();\n \n             if llforeign_arg_ty.is_ignore() {"}, {"sha": "8fc3426e372996d48105a81a171dd9a650ef2f02", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -262,9 +262,9 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   // use the fake info.\n                   info.unwrap_or(C_null(Type::i8p(bcx.ccx()))),\n                   GEPi(bcx, scratch.val, [0, abi::slice_elt_len]));\n-            PointerCast(variant_cx, scratch.val, *params.get(0))\n+            PointerCast(variant_cx, scratch.val, params[0])\n         } else {\n-            PointerCast(variant_cx, value, *params.get(0))\n+            PointerCast(variant_cx, value, params[0])\n         };\n         let args = vec!(self_arg);\n "}, {"sha": "e81844efad30ccac238046637ac3df8c3fe0b60e", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -259,11 +259,11 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             let mode = appropriate_rvalue_mode(ccx, tp_ty);\n             let src = Datum {\n-                val: *llargs.get(1),\n+                val: llargs[1],\n                 ty: tp_ty,\n                 kind: Rvalue::new(mode)\n             };\n-            bcx = src.store_to(bcx, *llargs.get(0));\n+            bcx = src.store_to(bcx, llargs[0]);\n             C_nil(ccx)\n         }\n         (_, \"get_tydesc\") => {\n@@ -307,130 +307,130 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n             C_bool(ccx, ty::type_contents(ccx.tcx(), tp_ty).owns_managed())\n         }\n         (_, \"offset\") => {\n-            let ptr = *llargs.get(0);\n-            let offset = *llargs.get(1);\n+            let ptr = llargs[0];\n+            let offset = llargs[1];\n             InBoundsGEP(bcx, ptr, [offset])\n         }\n \n         (_, \"copy_nonoverlapping_memory\") => {\n             copy_intrinsic(bcx, false, false, *substs.types.get(FnSpace, 0),\n-                           *llargs.get(0), *llargs.get(1), *llargs.get(2))\n+                           llargs[0], llargs[1], llargs[2])\n         }\n         (_, \"copy_memory\") => {\n             copy_intrinsic(bcx, true, false, *substs.types.get(FnSpace, 0),\n-                           *llargs.get(0), *llargs.get(1), *llargs.get(2))\n+                           llargs[0], llargs[1], llargs[2])\n         }\n         (_, \"set_memory\") => {\n             memset_intrinsic(bcx, false, *substs.types.get(FnSpace, 0),\n-                             *llargs.get(0), *llargs.get(1), *llargs.get(2))\n+                             llargs[0], llargs[1], llargs[2])\n         }\n \n         (_, \"volatile_copy_nonoverlapping_memory\") => {\n             copy_intrinsic(bcx, false, true, *substs.types.get(FnSpace, 0),\n-                           *llargs.get(0), *llargs.get(1), *llargs.get(2))\n+                           llargs[0], llargs[1], llargs[2])\n         }\n         (_, \"volatile_copy_memory\") => {\n             copy_intrinsic(bcx, true, true, *substs.types.get(FnSpace, 0),\n-                           *llargs.get(0), *llargs.get(1), *llargs.get(2))\n+                           llargs[0], llargs[1], llargs[2])\n         }\n         (_, \"volatile_set_memory\") => {\n             memset_intrinsic(bcx, true, *substs.types.get(FnSpace, 0),\n-                             *llargs.get(0), *llargs.get(1), *llargs.get(2))\n+                             llargs[0], llargs[1], llargs[2])\n         }\n         (_, \"volatile_load\") => {\n-            VolatileLoad(bcx, *llargs.get(0))\n+            VolatileLoad(bcx, llargs[0])\n         },\n         (_, \"volatile_store\") => {\n-            VolatileStore(bcx, *llargs.get(1), *llargs.get(0));\n+            VolatileStore(bcx, llargs[1], llargs[0]);\n             C_nil(ccx)\n         },\n \n-        (_, \"ctlz8\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\", *llargs.get(0)),\n-        (_, \"ctlz16\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\", *llargs.get(0)),\n-        (_, \"ctlz32\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i32\", *llargs.get(0)),\n-        (_, \"ctlz64\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i64\", *llargs.get(0)),\n-        (_, \"cttz8\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i8\", *llargs.get(0)),\n-        (_, \"cttz16\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i16\", *llargs.get(0)),\n-        (_, \"cttz32\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i32\", *llargs.get(0)),\n-        (_, \"cttz64\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i64\", *llargs.get(0)),\n+        (_, \"ctlz8\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\", llargs[0]),\n+        (_, \"ctlz16\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\", llargs[0]),\n+        (_, \"ctlz32\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i32\", llargs[0]),\n+        (_, \"ctlz64\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i64\", llargs[0]),\n+        (_, \"cttz8\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i8\", llargs[0]),\n+        (_, \"cttz16\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i16\", llargs[0]),\n+        (_, \"cttz32\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i32\", llargs[0]),\n+        (_, \"cttz64\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i64\", llargs[0]),\n \n         (_, \"i8_add_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i8\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"i16_add_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i16\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"i32_add_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i32\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"i64_add_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i64\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n \n         (_, \"u8_add_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i8\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"u16_add_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i16\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"u32_add_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i32\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"u64_add_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i64\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n \n         (_, \"i8_sub_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i8\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"i16_sub_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i16\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"i32_sub_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i32\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"i64_sub_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i64\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n \n         (_, \"u8_sub_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i8\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"u16_sub_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i16\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"u32_sub_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i32\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"u64_sub_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i64\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n \n         (_, \"i8_mul_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i8\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"i16_mul_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i16\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"i32_mul_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i32\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"i64_mul_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i64\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n \n         (_, \"u8_mul_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i8\", ret_ty,\n-                                    *llargs.get(0), *llargs.get(1)),\n+                                    llargs[0], llargs[1]),\n         (_, \"u16_mul_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i16\", ret_ty,\n-                                    *llargs.get(0), *llargs.get(1)),\n+                                    llargs[0], llargs[1]),\n         (_, \"u32_mul_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i32\", ret_ty,\n-                                    *llargs.get(0), *llargs.get(1)),\n+                                    llargs[0], llargs[1]),\n         (_, \"u64_mul_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i64\", ret_ty,\n-                                    *llargs.get(0), *llargs.get(1)),\n+                                    llargs[0], llargs[1]),\n \n         (_, \"return_address\") => {\n             if !fcx.caller_expects_out_pointer {\n@@ -452,7 +452,7 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n             let order = if split.len() == 2 {\n                 llvm::SequentiallyConsistent\n             } else {\n-                match *split.get(2) {\n+                match split[2] {\n                     \"relaxed\" => llvm::Monotonic,\n                     \"acq\"     => llvm::Acquire,\n                     \"rel\"     => llvm::Release,\n@@ -461,7 +461,7 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n                 }\n             };\n \n-            match *split.get(1) {\n+            match split[1] {\n                 \"cxchg\" => {\n                     // See include/llvm/IR/Instructions.h for their implementation\n                     // of this, I assume that it's good enough for us to use for\n@@ -480,8 +480,8 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n                             llvm::SequentiallyConsistent\n                     };\n \n-                    let res = AtomicCmpXchg(bcx, *llargs.get(0), *llargs.get(1),\n-                                            *llargs.get(2), order,\n+                    let res = AtomicCmpXchg(bcx, llargs[0], llargs[1],\n+                                            llargs[2], order,\n                                             strongest_failure_ordering);\n                     if unsafe { llvm::LLVMVersionMinor() >= 5 } {\n                         ExtractValue(bcx, res, 0)\n@@ -491,10 +491,10 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n                 }\n \n                 \"load\" => {\n-                    AtomicLoad(bcx, *llargs.get(0), order)\n+                    AtomicLoad(bcx, llargs[0], order)\n                 }\n                 \"store\" => {\n-                    AtomicStore(bcx, *llargs.get(1), *llargs.get(0), order);\n+                    AtomicStore(bcx, llargs[1], llargs[0], order);\n                     C_nil(ccx)\n                 }\n \n@@ -520,7 +520,7 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n                         _ => ccx.sess().fatal(\"unknown atomic operation\")\n                     };\n \n-                    AtomicRMW(bcx, atom_op, *llargs.get(0), *llargs.get(1), order)\n+                    AtomicRMW(bcx, atom_op, llargs[0], llargs[1], order)\n                 }\n             }\n "}, {"sha": "fef2ead9883d135dcef457d1b80f544a0ea7627c", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -718,7 +718,7 @@ fn emit_vtable_methods(bcx: Block,\n                     debug!(\"(making impl vtable) method has self or type \\\n                             params: {}\",\n                            token::get_ident(ident));\n-                    Some(C_null(Type::nil(ccx).ptr_to())).move_iter()\n+                    Some(C_null(Type::nil(ccx).ptr_to())).into_iter()\n                 } else {\n                     let mut fn_ref = trans_fn_ref_with_substs(\n                         bcx,\n@@ -732,11 +732,11 @@ fn emit_vtable_methods(bcx: Block,\n                                                      m_id,\n                                                      substs.clone());\n                     }\n-                    Some(fn_ref).move_iter()\n+                    Some(fn_ref).into_iter()\n                 }\n             }\n             ty::TypeTraitItem(_) => {\n-                None.move_iter()\n+                None.into_iter()\n             }\n         }\n     }).collect()"}, {"sha": "dbaebd07b0220ffc05f25398129f791ddfdece2b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -2042,7 +2042,7 @@ pub fn simd_type(cx: &ctxt, ty: t) -> t {\n     match get(ty).sty {\n         ty_struct(did, ref substs) => {\n             let fields = lookup_struct_fields(cx, did);\n-            lookup_field_type(cx, did, fields.get(0).id, substs)\n+            lookup_field_type(cx, did, fields[0].id, substs)\n         }\n         _ => fail!(\"simd_type called on invalid type\")\n     }\n@@ -2501,12 +2501,12 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                             if variants.len() == 2 {\n                                 let mut data_idx = 0;\n \n-                                if variants.get(0).args.len() == 0 {\n+                                if variants[0].args.len() == 0 {\n                                     data_idx = 1;\n                                 }\n \n-                                if variants.get(data_idx).args.len() == 1 {\n-                                    match get(*variants.get(data_idx).args.get(0)).sty {\n+                                if variants[data_idx].args.len() == 1 {\n+                                    match get(variants[data_idx].args[0]).sty {\n                                         ty_bare_fn(..) => { res = res - TC::ReachesFfiUnsafe; }\n                                         _ => { }\n                                     }\n@@ -2530,7 +2530,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 assert_eq!(p.def_id.krate, ast::LOCAL_CRATE);\n \n                 let ty_param_defs = cx.ty_param_defs.borrow();\n-                let tp_def = ty_param_defs.get(&p.def_id.node);\n+                let tp_def = &(*ty_param_defs)[p.def_id.node];\n                 kind_bounds_to_contents(\n                     cx,\n                     tp_def.bounds.builtin_bounds,\n@@ -4032,8 +4032,7 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n \n pub fn trait_item(cx: &ctxt, trait_did: ast::DefId, idx: uint)\n                   -> ImplOrTraitItem {\n-    let method_def_id = ty::trait_item_def_ids(cx, trait_did).get(idx)\n-                                                             .def_id();\n+    let method_def_id = (*ty::trait_item_def_ids(cx, trait_did))[idx].def_id();\n     impl_or_trait_item(cx, method_def_id)\n }\n "}, {"sha": "d29720e1a1a95553278348f64f2a7079402095a9", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -156,7 +156,7 @@ pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                         Some(v) => {\n                             let mut m = String::new();\n                             let len = v.len();\n-                            for (i, (name, n)) in v.move_iter().enumerate() {\n+                            for (i, (name, n)) in v.into_iter().enumerate() {\n                                 m.push_str(if n == 1 {\n                                     format!(\"`{}`\", name)\n                                 } else {\n@@ -194,9 +194,7 @@ pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     ty::ReStatic\n                 }\n \n-                Ok(rs) => {\n-                    *rs.get(0)\n-                }\n+                Ok(rs) => rs[0],\n             }\n         }\n     };\n@@ -1251,7 +1249,7 @@ fn determine_explicit_self_category<'tcx, AC: AstConv<'tcx>,\n                         self_info.explicit_self.span,\n                         self_info.untransformed_self_ty,\n                         tm.ty,\n-                        || \"not a valid type for `self`\".to_owned());\n+                        || \"not a valid type for `self`\".to_string());\n                     return ty::ByReferenceExplicitSelfCategory(region,\n                                                                tm.mutbl)\n                 }\n@@ -1263,7 +1261,7 @@ fn determine_explicit_self_category<'tcx, AC: AstConv<'tcx>,\n                         self_info.explicit_self.span,\n                         self_info.untransformed_self_ty,\n                         typ,\n-                        || \"not a valid type for `self`\".to_owned());\n+                        || \"not a valid type for `self`\".to_string());\n                     return ty::ByBoxExplicitSelfCategory\n                 }\n                 _ => {\n@@ -1301,7 +1299,7 @@ pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n             // no guarantee that the correct number of expected args\n             // were supplied\n             if i < e.inputs.len() {\n-                Some(*e.inputs.get(i))\n+                Some(e.inputs[i])\n             } else {\n                 None\n             }\n@@ -1357,7 +1355,7 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n         partition_bounds(this.tcx(), span, ast_bound_refs.as_slice());\n \n     if !trait_bounds.is_empty() {\n-        let b = trait_bounds.get(0);\n+        let b = &trait_bounds[0];\n         this.tcx().sess.span_err(\n             b.path.span,\n             format!(\"only the builtin traits can be used \\\n@@ -1453,7 +1451,7 @@ pub fn compute_opt_region_bound(tcx: &ty::ctxt,\n     // Determine whether there is exactly one unique region in the set\n     // of derived region bounds. If so, use that. Otherwise, report an\n     // error.\n-    let r = *derived_region_bounds.get(0);\n+    let r = derived_region_bounds[0];\n     if derived_region_bounds.slice_from(1).iter().any(|r1| r != *r1) {\n         tcx.sess.span_err(\n             span,"}, {"sha": "455300ecd3bad5fcdfa7d4c5607f5184ee1ed263", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -45,7 +45,7 @@ pub fn check_match(fcx: &FnCtxt,\n     for arm in arms.iter() {\n         let mut pcx = pat_ctxt {\n             fcx: fcx,\n-            map: pat_id_map(&tcx.def_map, &**arm.pats.get(0)),\n+            map: pat_id_map(&tcx.def_map, &*arm.pats[0]),\n         };\n \n         for p in arm.pats.iter() { check_pat(&mut pcx, &**p, discrim_ty);}\n@@ -322,7 +322,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n             }\n             Some(&(index, ref mut used)) => {\n                 *used = true;\n-                let class_field = class_fields.get(index).clone();\n+                let class_field = class_fields[index].clone();\n                 let field_type = ty::lookup_field_type(tcx,\n                                                        class_id,\n                                                        class_field.id,\n@@ -496,7 +496,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n           }\n         }\n \n-        let canon_id = *pcx.map.get(&path1.node);\n+        let canon_id = pcx.map[path1.node];\n         if canon_id != pat.id {\n             let ct = fcx.local_ty(pat.span, canon_id);\n             demand::eqtype(fcx, pat.span, ct, typ);\n@@ -528,7 +528,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         match *structure {\n             ty::ty_struct(cid, ref substs) => {\n                 // Verify that the pattern named the right structure.\n-                let item_did = tcx.def_map.borrow().get(&pat.id).def_id();\n+                let item_did = (*tcx.def_map.borrow())[pat.id].def_id();\n                 match ty::ty_to_def_id(ty::lookup_item_type(tcx, item_did).ty) {\n                     Some(struct_did) if struct_did != cid => {\n                         span_err!(tcx.sess, path.span, E0032,\n@@ -599,7 +599,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         match *s {\n             ty::ty_tup(ref ex_elts) if e_count == ex_elts.len() => {\n                 for (i, elt) in elts.iter().enumerate() {\n-                    check_pat(pcx, &**elt, *ex_elts.get(i));\n+                    check_pat(pcx, &**elt, ex_elts[i]);\n                 }\n                 fcx.write_ty(pat.id, expected);\n             }"}, {"sha": "798e4acd2910ec0fa5d79c49a3fe7bf426f9e951", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -276,7 +276,7 @@ fn construct_transformed_self_ty_for_object(\n             ty::mk_uniq(tcx, tr)\n         }\n         ByReferenceExplicitSelfCategory(..) | ByBoxExplicitSelfCategory => {\n-            let transformed_self_ty = *method_ty.fty.sig.inputs.get(0);\n+            let transformed_self_ty = method_ty.fty.sig.inputs[0];\n             match ty::get(transformed_self_ty).sty {\n                 ty::ty_rptr(r, mt) => { // must be SelfRegion\n                     let r = r.subst(tcx, rcvr_substs); // handle Early-Bound lifetime\n@@ -490,7 +490,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         let impl_items = self.tcx().impl_items.borrow();\n         for impl_infos in self.tcx().trait_impls.borrow().find(&trait_did).iter() {\n             for impl_did in impl_infos.borrow().iter() {\n-                let items = impl_items.get(impl_did);\n+                let items = &(*impl_items)[*impl_did];\n                 self.push_candidates_from_impl(*impl_did,\n                                                items.as_slice(),\n                                                true);\n@@ -521,7 +521,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             trait_did: DefId,\n             closure_did: DefId,\n             closure_function_type: &ClosureTy) {\n-        let trait_item = ty::trait_items(self.tcx(), trait_did).get(0)\n+        let trait_item = (*ty::trait_items(self.tcx(), trait_did))[0]\n                                                                .clone();\n         let method = match trait_item {\n             ty::MethodTraitItem(method) => method,\n@@ -538,7 +538,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         }\n \n         // Get the tupled type of the arguments.\n-        let arguments_type = *closure_function_type.sig.inputs.get(0);\n+        let arguments_type = closure_function_type.sig.inputs[0];\n         let return_type = closure_function_type.sig.output;\n \n         let closure_region =\n@@ -552,7 +552,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             rcvr_substs: subst::Substs::new_trait(\n                 vec![arguments_type, return_type],\n                 vec![],\n-                *self.fcx.infcx().next_ty_vars(1).get(0)),\n+                self.fcx.infcx().next_ty_vars(1)[0]),\n             method_ty: method,\n             origin: MethodStaticUnboxedClosure(closure_did),\n         });\n@@ -733,7 +733,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 }\n             }) {\n                 Some(pos) => {\n-                    let method = match *trait_items.get(pos) {\n+                    let method = match (*trait_items)[pos] {\n                         ty::MethodTraitItem(ref method) => (*method).clone(),\n                         ty::TypeTraitItem(_) => {\n                             tcx.sess.bug(\"typechecking associated type as \\\n@@ -771,7 +771,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         let impl_items = self.tcx().impl_items.borrow();\n         for impl_infos in self.tcx().inherent_impls.borrow().find(&did).iter() {\n             for impl_did in impl_infos.iter() {\n-                let items = impl_items.get(impl_did);\n+                let items = &(*impl_items)[*impl_did];\n                 self.push_candidates_from_impl(*impl_did,\n                                                items.as_slice(),\n                                                false);\n@@ -1211,7 +1211,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n             // return something so we don't get errors for every mutability\n             return Some(MethodCallee {\n-                origin: relevant_candidates.get(0).origin.clone(),\n+                origin: relevant_candidates[0].origin.clone(),\n                 ty: ty::mk_err(),\n                 substs: subst::Substs::empty()\n             });\n@@ -1225,7 +1225,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             }\n         }\n \n-        Some(self.confirm_candidate(rcvr_ty, relevant_candidates.get(0)))\n+        Some(self.confirm_candidate(rcvr_ty, &relevant_candidates[0]))\n     }\n \n     fn filter_candidates(&self, rcvr_ty: ty::t, candidates: &[Candidate]) -> Vec<Candidate> {\n@@ -1299,7 +1299,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     \"incorrect number of type parameters given for this method\");\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else {\n-                Vec::from_slice(self.supplied_tps)\n+                self.supplied_tps.to_vec()\n             }\n         };\n \n@@ -1329,7 +1329,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 let args = fn_sig.inputs.slice_from(1).iter().map(|t| {\n                     t.subst(tcx, &all_substs)\n                 });\n-                Some(*fn_sig.inputs.get(0)).into_iter().chain(args).collect()\n+                Some(fn_sig.inputs[0]).into_iter().chain(args).collect()\n             }\n             _ => fn_sig.inputs.subst(tcx, &all_substs)\n         };\n@@ -1348,7 +1348,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             tcx, &fn_sig,\n             |br| self.fcx.infcx().next_region_var(\n                 infer::LateBoundRegion(self.span, br)));\n-        let transformed_self_ty = *fn_sig.inputs.get(0);\n+        let transformed_self_ty = fn_sig.inputs[0];\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n             sig: fn_sig,\n             fn_style: bare_fn_ty.fn_style,\n@@ -1394,7 +1394,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             _ => return,\n         };\n \n-        match ty::get(*sig.inputs.get(0)).sty {\n+        match ty::get(sig.inputs[0]).sty {\n             ty::ty_rptr(_, ty::mt {\n                 ty: _,\n                 mutbl: ast::MutMutable,"}, {"sha": "ba9045d0fade50f9a0ae306347d021b336df85a0", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -1059,8 +1059,8 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     let trait_to_skol_substs =\n         trait_to_impl_substs\n         .subst(tcx, &impl_to_skol_substs)\n-        .with_method(Vec::from_slice(skol_tps.get_slice(subst::FnSpace)),\n-                     Vec::from_slice(skol_regions.get_slice(subst::FnSpace)));\n+        .with_method(skol_tps.get_slice(subst::FnSpace).to_vec(),\n+                     skol_regions.get_slice(subst::FnSpace).to_vec());\n \n     // Check region bounds.\n     if !check_region_bounds_on_impl_method(tcx,\n@@ -2601,7 +2601,7 @@ fn check_argument_types<'a>(fcx: &FnCtxt,\n \n             if is_block == check_blocks {\n                 debug!(\"checking the argument\");\n-                let mut formal_ty = *formal_tys.get(i);\n+                let mut formal_ty = formal_tys[i];\n \n                 match deref_args {\n                     DoDerefArgs => {\n@@ -3304,7 +3304,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 fcx.ccx.tcx.sess.span_bug(expr.span,\n                                           \"can't make anon regions here?!\")\n             }\n-            Ok(regions) => *regions.get(0),\n+            Ok(regions) => regions[0],\n         };\n         let closure_type = ty::mk_unboxed_closure(fcx.ccx.tcx,\n                                                   local_def(expr.id),\n@@ -3646,7 +3646,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 let mut missing_fields = Vec::new();\n                 for class_field in field_types.iter() {\n                     let name = class_field.name;\n-                    let (_, seen) = *class_field_map.get(&name);\n+                    let (_, seen) = class_field_map[name];\n                     if !seen {\n                         missing_fields.push(\n                             format!(\"`{}`\", token::get_name(name).get()))\n@@ -3874,7 +3874,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                     ty::ty_struct(did, ref substs) => {\n                                         let fields = ty::struct_fields(fcx.tcx(), did, substs);\n                                         fields.len() == 1\n-                                        && fields.get(0).ident ==\n+                                        && fields[0].ident ==\n                                         token::special_idents::unnamed_field\n                                     }\n                                     _ => false\n@@ -4261,7 +4261,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         let elt_ts = elts.iter().enumerate().map(|(i, e)| {\n             let t = match flds {\n                 Some(ref fs) if i < fs.len() => {\n-                    let ety = *fs.get(i);\n+                    let ety = fs[i];\n                     check_expr_coercable_to_type(fcx, &**e, ety);\n                     ety\n                 }\n@@ -4766,7 +4766,7 @@ pub fn check_const(ccx: &CrateCtxt,\n     let inh = static_inherited_fields(ccx);\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n-    let declty = fcx.ccx.tcx.tcache.borrow().get(&local_def(id)).ty;\n+    let declty = (*fcx.ccx.tcx.tcache.borrow())[local_def(id)].ty;\n     check_const_with_ty(&fcx, sp, e, declty);\n }\n \n@@ -4856,7 +4856,7 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n                 span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\");\n                 return;\n             }\n-            let e = ty::lookup_field_type(tcx, did, fields.get(0).id, substs);\n+            let e = ty::lookup_field_type(tcx, did, fields[0].id, substs);\n             if !fields.iter().all(\n                          |f| ty::lookup_field_type(tcx, did, f.id, substs) == e) {\n                 span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\");\n@@ -5517,7 +5517,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n \n         //We only care about the operation here\n-        match *split.get(1) {\n+        match split[1] {\n             \"cxchg\" => (1, vec!(ty::mk_mut_ptr(tcx, param(ccx, 0)),\n                                 param(ccx, 0),\n                                 param(ccx, 0)),"}, {"sha": "76074120c0edb27d0cba7141e08926a419f19f7e", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -641,7 +641,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         }\n \n         ast::ExprMethodCall(_, _, ref args) => {\n-            constrain_call(rcx, expr, Some(&**args.get(0)),\n+            constrain_call(rcx, expr, Some(&*args[0]),\n                            args.slice_from(1).iter().map(|e| &**e), false);\n \n             visit::walk_expr(rcx, expr);\n@@ -1200,7 +1200,7 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n                 // Treat overloaded autoderefs as if an AutoRef adjustment\n                 // was applied on the base type, as that is always the case.\n                 let fn_sig = ty::ty_fn_sig(method.ty);\n-                let self_ty = *fn_sig.inputs.get(0);\n+                let self_ty = fn_sig.inputs[0];\n                 let (m, r) = match ty::get(self_ty).sty {\n                     ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                     _ => rcx.tcx().sess.span_bug(deref_expr.span,"}, {"sha": "7906e0101ee16d1acb3804f31248571fc1f7d4f7", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -434,12 +434,12 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         };\n \n         for &impl_did in trait_impls.borrow().iter() {\n-            let items = impl_items.get(&impl_did);\n+            let items = &(*impl_items)[impl_did];\n             if items.len() < 1 {\n                 // We'll error out later. For now, just don't ICE.\n                 continue;\n             }\n-            let method_def_id = *items.get(0);\n+            let method_def_id = items[0];\n \n             let self_type = self.get_self_type_for_implementation(impl_did);\n             match ty::get(self_type.ty).sty {\n@@ -524,10 +524,10 @@ fn subst_receiver_types_in_method_ty(tcx: &ty::ctxt,\n     for &space in [subst::TypeSpace, subst::SelfSpace].iter() {\n         method_generics.types.replace(\n             space,\n-            Vec::from_slice(impl_poly_type.generics.types.get_slice(space)));\n+            impl_poly_type.generics.types.get_slice(space).to_vec());\n         method_generics.regions.replace(\n             space,\n-            Vec::from_slice(impl_poly_type.generics.regions.get_slice(space)));\n+            impl_poly_type.generics.regions.get_slice(space).to_vec());\n     }\n \n     debug!(\"subst_receiver_types_in_method_ty: method_generics={}\","}, {"sha": "2ffb90861bf3381b4d99078f149bcb7527d350f5", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -1298,11 +1298,11 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                 write_ty_to_tcx(tcx, ctor_id, selfty);\n \n                 tcx.tcache.borrow_mut().insert(local_def(ctor_id), pty);\n-            } else if struct_def.fields.get(0).node.kind.is_unnamed() {\n+            } else if struct_def.fields[0].node.kind.is_unnamed() {\n                 // Tuple-like.\n                 let inputs: Vec<_> = struct_def.fields.iter().map(\n-                        |field| tcx.tcache.borrow().get(\n-                            &local_def(field.node.id)).ty).collect();\n+                        |field| (*tcx.tcache.borrow())[\n+                            local_def(field.node.id)].ty).collect();\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n                                                 ctor_id,\n                                                 inputs.as_slice(),\n@@ -2124,8 +2124,8 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n                                      unboxed_fn_ty_bounds } =\n         astconv::partition_bounds(this.tcx(), span, all_bounds.as_slice());\n \n-    let unboxed_fn_ty_bounds = unboxed_fn_ty_bounds.move_iter().map(|b| {\n-        let trait_id = this.tcx().def_map.borrow().get(&b.ref_id).def_id();\n+    let unboxed_fn_ty_bounds = unboxed_fn_ty_bounds.into_iter().map(|b| {\n+        let trait_id = (*this.tcx().def_map.borrow())[b.ref_id].def_id();\n         let mut kind = None;\n         for &(lang_item, this_kind) in [\n             (this.tcx().lang_items.fn_trait(), ast::FnUnboxedClosureKind),\n@@ -2170,7 +2170,7 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n         .chain(unboxed_fn_ty_bounds)\n         .collect();\n     let region_bounds: Vec<ty::Region> =\n-        region_bounds.move_iter()\n+        region_bounds.into_iter()\n         .map(|r| ast_region_to_region(this.tcx(), r))\n         .collect();\n     ty::ParamBounds {"}, {"sha": "15c4830646d593f440d954faf96794616e55086d", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -52,7 +52,6 @@ use middle::typeck::infer::type_variable::{RelationDir, EqTo,\n use middle::ty_fold::{TypeFoldable};\n use util::ppaux::Repr;\n \n-use std::result;\n \n use syntax::ast::{Onceness, FnStyle};\n use syntax::ast;\n@@ -89,11 +88,10 @@ pub trait Combine<'tcx> {\n                                                              bs.len())));\n         }\n \n-        try!(result::fold_(as_\n-                          .iter()\n-                          .zip(bs.iter())\n-                          .map(|(a, b)| self.equate().tys(*a, *b))));\n-        Ok(Vec::from_slice(as_))\n+        try!(as_.iter().zip(bs.iter())\n+                .map(|(a, b)| self.equate().tys(*a, *b))\n+                .collect::<cres<Vec<ty::t>>>());\n+        Ok(as_.to_vec())\n     }\n \n     fn substs(&self,\n@@ -342,8 +340,8 @@ pub fn super_fn_sigs<'tcx, C: Combine<'tcx>>(this: &C,\n                                        b_args: &[ty::t])\n                                        -> cres<Vec<ty::t>> {\n         if a_args.len() == b_args.len() {\n-            result::collect(a_args.iter().zip(b_args.iter())\n-                            .map(|(a, b)| this.args(*a, *b)))\n+            a_args.iter().zip(b_args.iter())\n+                  .map(|(a, b)| this.args(*a, *b)).collect()\n         } else {\n             Err(ty::terr_arg_count)\n         }\n@@ -537,9 +535,10 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n \n       (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) => {\n         if as_.len() == bs.len() {\n-            result::collect(as_.iter().zip(bs.iter())\n-                            .map(|(a, b)| this.tys(*a, *b)))\n-                    .and_then(|ts| Ok(ty::mk_tup(tcx, ts)) )\n+            as_.iter().zip(bs.iter())\n+               .map(|(a, b)| this.tys(*a, *b))\n+               .collect::<Result<_, _>>()\n+               .map(|ts| ty::mk_tup(tcx, ts))\n         } else {\n             Err(ty::terr_tuple_size(\n                 expected_found(this, as_.len(), bs.len())))"}, {"sha": "c3ed70f4cb7b1b357f09a313f6e38d3e0fdca533", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -256,7 +256,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n             }\n         }\n         if !same_regions.is_empty() {\n-            let common_scope_id = same_regions.get(0).scope_id;\n+            let common_scope_id = same_regions[0].scope_id;\n             for sr in same_regions.iter() {\n                 // Since ProcessedErrors is used to reconstruct the function\n                 // declaration, we want to make sure that they are, in fact,\n@@ -1003,7 +1003,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 names.push(lt_name);\n             }\n             names.sort();\n-            let name = token::str_to_ident(names.get(0).as_slice()).name;\n+            let name = token::str_to_ident(names[0].as_slice()).name;\n             return (name_to_dummy_lifetime(name), Kept);\n         }\n         return (self.life_giver.give_lifetime(), Fresh);\n@@ -1209,7 +1209,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         let mut new_ty = P(ty.clone());\n         let mut ty_queue = vec!(ty);\n         while !ty_queue.is_empty() {\n-            let cur_ty = ty_queue.shift().unwrap();\n+            let cur_ty = ty_queue.remove(0).unwrap();\n             match cur_ty.node {\n                 ast::TyRptr(lt_opt, ref mut_ty) => {\n                     let rebuild = match lt_opt {\n@@ -1768,7 +1768,7 @@ impl LifeGiver {\n             let (n, r) = (counter/26 + 1, counter % 26);\n             let letter: char = from_u32((r+97) as u32).unwrap();\n             for _ in range(0, n) {\n-                s.push_char(letter);\n+                s.push(letter);\n             }\n             s\n         }"}, {"sha": "b4704b2a27c97f5d959d16a6173b4e92399fd5e9", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -255,7 +255,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     pub fn commit(&self, snapshot: RegionSnapshot) {\n         debug!(\"RegionVarBindings: commit({})\", snapshot.length);\n         assert!(self.undo_log.borrow().len() > snapshot.length);\n-        assert!(*self.undo_log.borrow().get(snapshot.length) == OpenSnapshot);\n+        assert!((*self.undo_log.borrow())[snapshot.length] == OpenSnapshot);\n \n         let mut undo_log = self.undo_log.borrow_mut();\n         if snapshot.length == 0 {\n@@ -269,7 +269,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         debug!(\"RegionVarBindings: rollback_to({})\", snapshot);\n         let mut undo_log = self.undo_log.borrow_mut();\n         assert!(undo_log.len() > snapshot.length);\n-        assert!(*undo_log.get(snapshot.length) == OpenSnapshot);\n+        assert!((*undo_log)[snapshot.length] == OpenSnapshot);\n         while undo_log.len() > snapshot.length + 1 {\n             match undo_log.pop().unwrap() {\n                 OpenSnapshot => {\n@@ -529,7 +529,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         match *self.values.borrow() {\n             None => {\n                 self.tcx.sess.span_bug(\n-                    self.var_origins.borrow().get(rid.index).span(),\n+                    (*self.var_origins.borrow())[rid.index].span(),\n                     \"attempt to resolve region variable before values have \\\n                      been computed!\")\n             }\n@@ -608,7 +608,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let mut result_index = 0;\n         while result_index < result_set.len() {\n             // nb: can't use uint::range() here because result_set grows\n-            let r = *result_set.get(result_index);\n+            let r = result_set[result_index];\n             debug!(\"result_index={}, r={}\", result_index, r);\n \n             for undo_entry in\n@@ -636,13 +636,13 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                             ReFree(a), ReInfer(ReVar(b)));\n                     }\n                     &AddVerify(i) => {\n-                        match self.verifys.borrow().get(i) {\n-                            &VerifyRegSubReg(_, a, b) => {\n+                        match (*self.verifys.borrow())[i] {\n+                            VerifyRegSubReg(_, a, b) => {\n                                 consider_adding_bidirectional_edges(\n                                     &mut result_set, r,\n                                     a, b);\n                             }\n-                            &VerifyParamBound(_, _, a, ref bs) => {\n+                            VerifyParamBound(_, _, a, ref bs) => {\n                                 for &b in bs.iter() {\n                                     consider_adding_bidirectional_edges(\n                                         &mut result_set, r,\n@@ -727,7 +727,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n           (ReInfer(ReVar(v_id)), _) | (_, ReInfer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n-                self.var_origins.borrow().get(v_id.index).span(),\n+                (*self.var_origins.borrow())[v_id.index].span(),\n                 format!(\"lub_concrete_regions invoked with \\\n                          non-concrete regions: {}, {}\",\n                         a,\n@@ -834,7 +834,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             (ReInfer(ReVar(v_id)), _) |\n             (_, ReInfer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n-                    self.var_origins.borrow().get(v_id.index).span(),\n+                    (*self.var_origins.borrow())[v_id.index].span(),\n                     format!(\"glb_concrete_regions invoked with \\\n                              non-concrete regions: {}, {}\",\n                             a,\n@@ -1269,7 +1269,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     if opt_graph.is_none() {\n                         opt_graph = Some(self.construct_graph());\n                     }\n-                    let graph = opt_graph.get_ref();\n+                    let graph = opt_graph.as_ref().unwrap();\n \n                     let node_vid = RegionVid { index: idx };\n                     match var_data[idx].classification {\n@@ -1370,7 +1370,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n                     errors.push(SubSupConflict(\n-                        self.var_origins.borrow().get(node_idx.index).clone(),\n+                        (*self.var_origins.borrow())[node_idx.index].clone(),\n                         lower_bound.origin.clone(),\n                         lower_bound.region,\n                         upper_bound.origin.clone(),\n@@ -1381,7 +1381,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n \n         self.tcx.sess.span_bug(\n-            self.var_origins.borrow().get(node_idx.index).span(),\n+            (*self.var_origins.borrow())[node_idx.index].span(),\n             format!(\"collect_error_for_expanding_node() could not find error \\\n                     for var {}, lower_bounds={}, upper_bounds={}\",\n                     node_idx,\n@@ -1414,7 +1414,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                   Ok(_) => {}\n                   Err(_) => {\n                     errors.push(SupSupConflict(\n-                        self.var_origins.borrow().get(node_idx.index).clone(),\n+                        (*self.var_origins.borrow())[node_idx.index].clone(),\n                         upper_bound_1.origin.clone(),\n                         upper_bound_1.region,\n                         upper_bound_2.origin.clone(),\n@@ -1426,7 +1426,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n \n         self.tcx.sess.span_bug(\n-            self.var_origins.borrow().get(node_idx.index).span(),\n+            (*self.var_origins.borrow())[node_idx.index].span(),\n             format!(\"collect_error_for_contracting_node() could not find error \\\n                      for var {}, upper_bounds={}\",\n                     node_idx,\n@@ -1578,7 +1578,7 @@ fn normalize(values: &Vec<VarValue>, r: ty::Region) -> ty::Region {\n }\n \n fn lookup(values: &Vec<VarValue>, rid: ty::RegionVid) -> ty::Region {\n-    match *values.get(rid.index) {\n+    match values[rid.index] {\n         Value(r) => r,\n         NoValue => ReEmpty, // No constraints, return ty::ReEmpty\n         ErrorValue => ReStatic, // Previously reported error."}, {"sha": "20e550f3f306c62b82da10d7d0195d9b180ec9ba", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -657,7 +657,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             // variance not yet inferred, so return a symbolic\n             // variance.\n             let InferredIndex(index) = self.inferred_index(param_def_id.node);\n-            self.terms_cx.inferred_infos.get(index).term\n+            self.terms_cx.inferred_infos[index].term\n         } else {\n             // Parameter on an item defined within another crate:\n             // variance already inferred, just look it up.\n@@ -980,15 +980,14 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                 let Constraint { inferred, variance: term } = *constraint;\n                 let InferredIndex(inferred) = inferred;\n                 let variance = self.evaluate(term);\n-                let old_value = *self.solutions.get(inferred);\n+                let old_value = self.solutions[inferred];\n                 let new_value = glb(variance, old_value);\n                 if old_value != new_value {\n                     debug!(\"Updating inferred {} (node {}) \\\n                             from {} to {} due to {}\",\n                             inferred,\n                             self.terms_cx\n-                                .inferred_infos\n-                                .get(inferred)\n+                                .inferred_infos[inferred]\n                                 .param_id,\n                             old_value,\n                             new_value,\n@@ -1017,14 +1016,14 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         let mut index = 0;\n         let num_inferred = self.terms_cx.num_inferred();\n         while index < num_inferred {\n-            let item_id = inferred_infos.get(index).item_id;\n+            let item_id = inferred_infos[index].item_id;\n             let mut types = VecPerParamSpace::empty();\n             let mut regions = VecPerParamSpace::empty();\n \n             while index < num_inferred &&\n-                  inferred_infos.get(index).item_id == item_id {\n-                let info = inferred_infos.get(index);\n-                let variance = *solutions.get(index);\n+                  inferred_infos[index].item_id == item_id {\n+                let info = inferred_infos[index];\n+                let variance = solutions[index];\n                 debug!(\"Index {} Info {} / {} / {} Variance {}\",\n                        index, info.index, info.kind, info.space, variance);\n                 match info.kind {\n@@ -1074,7 +1073,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             }\n \n             InferredTerm(InferredIndex(index)) => {\n-                *self.solutions.get(index)\n+                self.solutions[index]\n             }\n         }\n     }"}, {"sha": "921cd7a4107c91bb0da52e07c7292e8fcc5c084d", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -77,8 +77,8 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n         Some(addl_plugins) => {\n             // Add in the additional plugins requested by the frontend\n             let Plugins { macros: addl_macros, registrars: addl_registrars } = addl_plugins;\n-            plugins.macros.push_all_move(addl_macros);\n-            plugins.registrars.push_all_move(addl_registrars);\n+            plugins.macros.extend(addl_macros.into_iter());\n+            plugins.registrars.extend(addl_registrars.into_iter());\n         }\n         None => ()\n     }"}, {"sha": "ed38f6f871d792792056d71a236690daa391f830", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -139,7 +139,7 @@ pub fn can_reach<S,H:Hasher<S>,T:Eq+Clone+Hash<S>>(\n     let mut queue = vec!(source);\n     let mut i = 0;\n     while i < queue.len() {\n-        match edges_map.find(queue.get(i)) {\n+        match edges_map.find(&queue[i]) {\n             Some(edges) => {\n                 for target in edges.iter() {\n                     if *target == destination {"}, {"sha": "a20a988c881dd3798f00c76a319c84ad30e4e188", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -270,7 +270,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n             ast::NormalFn => {}\n             _ => {\n                 s.push_str(fn_style.to_string().as_slice());\n-                s.push_char(' ');\n+                s.push(' ');\n             }\n         };\n \n@@ -282,7 +282,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n \n         match ident {\n             Some(i) => {\n-                s.push_char(' ');\n+                s.push(' ');\n                 s.push_str(token::get_ident(i).get());\n             }\n             _ => { }\n@@ -307,7 +307,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n             ast::NormalFn => {}\n             _ => {\n                 s.push_str(cty.fn_style.to_string().as_slice());\n-                s.push_char(' ');\n+                s.push(' ');\n             }\n         };\n \n@@ -330,7 +330,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n             }\n         }\n \n-        s.into_owned()\n+        s\n     }\n \n     fn push_sig_to_string(cx: &ctxt,\n@@ -339,13 +339,13 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n                        ket: char,\n                        sig: &ty::FnSig,\n                        bounds: &str) {\n-        s.push_char(bra);\n+        s.push(bra);\n         let strs: Vec<String> = sig.inputs.iter().map(|a| fn_input_to_string(cx, *a)).collect();\n         s.push_str(strs.connect(\", \").as_slice());\n         if sig.variadic {\n             s.push_str(\", ...\");\n         }\n-        s.push_char(ket);\n+        s.push(ket);\n \n         if !bounds.is_empty() {\n             s.push_str(\":\");\n@@ -355,7 +355,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n         if ty::get(sig.output).sty != ty_nil {\n             s.push_str(\" -> \");\n             if ty::type_is_bot(sig.output) {\n-                s.push_char('!');\n+                s.push('!');\n             } else {\n                 s.push_str(ty_to_string(cx, sig.output).as_slice());\n             }\n@@ -670,10 +670,10 @@ impl Repr for ty::BuiltinBounds {\n         let mut res = Vec::new();\n         for b in self.iter() {\n             res.push(match b {\n-                ty::BoundSend => \"Send\".to_owned(),\n-                ty::BoundSized => \"Sized\".to_owned(),\n-                ty::BoundCopy => \"Copy\".to_owned(),\n-                ty::BoundSync => \"Sync\".to_owned(),\n+                ty::BoundSend => \"Send\".to_string(),\n+                ty::BoundSized => \"Sized\".to_string(),\n+                ty::BoundCopy => \"Copy\".to_string(),\n+                ty::BoundSync => \"Sync\".to_string(),\n             });\n         }\n         res.connect(\"+\")\n@@ -1007,10 +1007,10 @@ impl Repr for ty::BuiltinBound {\n impl UserString for ty::BuiltinBound {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n         match *self {\n-            ty::BoundSend => \"Send\".to_owned(),\n-            ty::BoundSized => \"Sized\".to_owned(),\n-            ty::BoundCopy => \"Copy\".to_owned(),\n-            ty::BoundSync => \"Sync\".to_owned(),\n+            ty::BoundSend => \"Send\".to_string(),\n+            ty::BoundSized => \"Sized\".to_string(),\n+            ty::BoundCopy => \"Copy\".to_string(),\n+            ty::BoundSync => \"Sync\".to_string(),\n         }\n     }\n }"}, {"sha": "7a7c8f8d94f72da590b5e53f2b9a19253e42c90f", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -94,7 +94,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n     }\n \n     pub fn get<'a>(&'a self, index: uint) -> &'a T {\n-        self.values.get(index)\n+        &self.values[index]\n     }\n \n     pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n@@ -133,7 +133,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n \n         // Invariant established by start_snapshot():\n         assert!(\n-            match *self.undo_log.get(snapshot.length) {\n+            match self.undo_log[snapshot.length] {\n                 OpenSnapshot => true,\n                 _ => false\n             });"}, {"sha": "ca8a6cd0c401073993e21f3f6ceed63269feea42", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -708,9 +708,11 @@ impl fmt::Show for ModuleSummary {\n             let path = context.connect(\"::\");\n \n             try!(write!(f, \"<tr>\"));\n-            try!(write!(f, \"<td><a href='{}'>{}</a></td>\",\n-                        Vec::from_slice(context.slice_from(1))\n-                            .append_one(\"index.html\").connect(\"/\"),\n+            try!(write!(f, \"<td><a href='{}'>{}</a></td>\", {\n+                            let mut url = context.slice_from(1).to_vec();\n+                            url.push(\"index.html\");\n+                            url.connect(\"/\")\n+                        },\n                         path));\n             try!(write!(f, \"<td class='summary-column'>\"));\n             try!(write!(f, \"<span class='summary Stable' \\"}, {"sha": "6e515f611986e70ad8a9ac59b37bc95a0a64eb35", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -1147,7 +1147,7 @@ impl Context {\n                         cx.layout.krate)\n             } else {\n                 format!(\"API documentation for the Rust `{}` {} in crate `{}`.\",\n-                        it.name.get_ref(), tyname, cx.layout.krate)\n+                        it.name.as_ref().unwrap(), tyname, cx.layout.krate)\n             };\n             let keywords = make_item_keywords(it);\n             let page = layout::Page {\n@@ -1332,7 +1332,7 @@ impl<'a> fmt::Show for Item<'a> {\n             }\n         }\n         try!(write!(fmt, \"<a class='{}' href=''>{}</a>\",\n-                    shortty(self.item), self.item.name.get_ref().as_slice()));\n+                    shortty(self.item), self.item.name.as_ref().unwrap().as_slice()));\n \n         // Write stability level\n         try!(write!(fmt, \"<wbr>{}\", Stability(&self.item.stability)));\n@@ -1395,12 +1395,12 @@ impl<'a> fmt::Show for Item<'a> {\n fn item_path(item: &clean::Item) -> String {\n     match item.inner {\n         clean::ModuleItem(..) => {\n-            format!(\"{}/index.html\", item.name.get_ref())\n+            format!(\"{}/index.html\", item.name.as_ref().unwrap())\n         }\n         _ => {\n             format!(\"{}.{}.html\",\n                     shortty(item).to_static_str(),\n-                    *item.name.get_ref())\n+                    *item.name.as_ref().unwrap())\n         }\n     }\n }\n@@ -1560,7 +1560,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 ConciseStability(&myitem.stability),\n                 VisSpace(myitem.visibility),\n                 MutableSpace(s.mutability),\n-                *myitem.name.get_ref(),\n+                *myitem.name.as_ref().unwrap(),\n                 s.type_,\n                 Initializer(s.expr.as_slice(), Item { cx: cx, item: myitem }),\n                 Markdown(blank(myitem.doc_value()))));\n@@ -1574,7 +1574,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 \",\n                 ConciseStability(&myitem.stability),\n                 VisSpace(myitem.visibility),\n-                *myitem.name.get_ref(),\n+                *myitem.name.as_ref().unwrap(),\n                 s.type_,\n                 Initializer(s.expr.as_slice(), Item { cx: cx, item: myitem }),\n                 Markdown(blank(myitem.doc_value()))));\n@@ -1611,7 +1611,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                         <td class='docblock short'>{}</td>\n                     </tr>\n                 \",\n-                *myitem.name.get_ref(),\n+                *myitem.name.as_ref().unwrap(),\n                 Markdown(shorter(myitem.doc_value())),\n                 class = shortty(myitem),\n                 href = item_path(myitem),\n@@ -1630,7 +1630,7 @@ fn item_function(w: &mut fmt::Formatter, it: &clean::Item,\n                     {name}{generics}{decl}{where_clause}</pre>\",\n            vis = VisSpace(it.visibility),\n            fn_style = FnStyleSpace(f.fn_style),\n-           name = it.name.get_ref().as_slice(),\n+           name = it.name.as_ref().unwrap().as_slice(),\n            generics = f.generics,\n            where_clause = WhereClause(&f.generics),\n            decl = f.decl));\n@@ -1651,7 +1651,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     // Output the trait definition\n     try!(write!(w, \"<pre class='rust trait'>{}trait {}{}{}{} \",\n                   VisSpace(it.visibility),\n-                  it.name.get_ref().as_slice(),\n+                  it.name.as_ref().unwrap().as_slice(),\n                   t.generics,\n                   bounds,\n                   WhereClause(&t.generics)));\n@@ -1700,7 +1700,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                   -> fmt::Result {\n         try!(write!(w, \"<h3 id='{}.{}' class='method'>{}<code>\",\n                     shortty(m.item()),\n-                    *m.item().name.get_ref(),\n+                    *m.item().name.as_ref().unwrap(),\n                     ConciseStability(&m.item().stability)));\n         try!(render_method(w, m.item()));\n         try!(write!(w, \"</code></h3>\"));\n@@ -1753,11 +1753,11 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 path = if ast_util::is_local(it.def_id) {\n                     cx.current.connect(\"/\")\n                 } else {\n-                    let path = cache.external_paths.get(&it.def_id);\n+                    let path = &cache.external_paths[it.def_id];\n                     path.slice_to(path.len() - 1).connect(\"/\")\n                 },\n                 ty = shortty(it).to_static_str(),\n-                name = *it.name.get_ref()));\n+                name = *it.name.as_ref().unwrap()));\n     Ok(())\n }\n \n@@ -1772,7 +1772,7 @@ fn render_method(w: &mut fmt::Formatter, meth: &clean::Item) -> fmt::Result {\n                    _ => \"\",\n                },\n                ty = shortty(it),\n-               name = it.name.get_ref().as_slice(),\n+               name = it.name.as_ref().unwrap().as_slice(),\n                generics = *g,\n                decl = Method(selfty, d),\n                where_clause = WhereClause(g))\n@@ -1816,7 +1816,7 @@ fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                     try!(write!(w, \"<tr><td id='structfield.{name}'>\\\n                                       {stab}<code>{name}</code></td><td>\",\n                                   stab = ConciseStability(&field.stability),\n-                                  name = field.name.get_ref().as_slice()));\n+                                  name = field.name.as_ref().unwrap().as_slice()));\n                     try!(document(w, field));\n                     try!(write!(w, \"</td></tr>\"));\n                 }\n@@ -1832,7 +1832,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n              e: &clean::Enum) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust enum'>{}enum {}{}{}\",\n                   VisSpace(it.visibility),\n-                  it.name.get_ref().as_slice(),\n+                  it.name.as_ref().unwrap().as_slice(),\n                   e.generics,\n                   WhereClause(&e.generics)));\n     if e.variants.len() == 0 && !e.variants_stripped {\n@@ -1885,7 +1885,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n         for variant in e.variants.iter() {\n             try!(write!(w, \"<tr><td id='variant.{name}'>{stab}<code>{name}</code></td><td>\",\n                           stab = ConciseStability(&variant.stability),\n-                          name = variant.name.get_ref().as_slice()));\n+                          name = variant.name.as_ref().unwrap().as_slice()));\n             try!(document(w, variant));\n             match variant.inner {\n                 clean::VariantItem(ref var) => {\n@@ -1906,8 +1906,8 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n                                 try!(write!(w, \"<tr><td \\\n                                                   id='variant.{v}.field.{f}'>\\\n                                                   <code>{f}</code></td><td>\",\n-                                              v = variant.name.get_ref().as_slice(),\n-                                              f = field.name.get_ref().as_slice()));\n+                                              v = variant.name.as_ref().unwrap().as_slice(),\n+                                              f = field.name.as_ref().unwrap().as_slice()));\n                                 try!(document(w, field));\n                                 try!(write!(w, \"</td></tr>\"));\n                             }\n@@ -1936,7 +1936,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n     try!(write!(w, \"{}{}{}\",\n                   VisSpace(it.visibility),\n                   if structhead {\"struct \"} else {\"\"},\n-                  it.name.get_ref().as_slice()));\n+                  it.name.as_ref().unwrap().as_slice()));\n     match g {\n         Some(g) => try!(write!(w, \"{}{}\", *g, WhereClause(g))),\n         None => {}\n@@ -1953,7 +1953,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                     clean::StructFieldItem(clean::TypedStructField(ref ty)) => {\n                         try!(write!(w, \"    {}{}: {},\\n{}\",\n                                       VisSpace(field.visibility),\n-                                      field.name.get_ref().as_slice(),\n+                                      field.name.as_ref().unwrap().as_slice(),\n                                       *ty,\n                                       tab));\n                     }\n@@ -2042,7 +2042,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n     fn doctraititem(w: &mut fmt::Formatter, item: &clean::Item, dox: bool)\n                     -> fmt::Result {\n         try!(write!(w, \"<h4 id='method.{}' class='method'>{}<code>\",\n-                    *item.name.get_ref(),\n+                    *item.name.as_ref().unwrap(),\n                     ConciseStability(&item.stability)));\n         try!(render_method(w, item));\n         try!(write!(w, \"</code></h4>\\n\"));\n@@ -2096,7 +2096,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n fn item_typedef(w: &mut fmt::Formatter, it: &clean::Item,\n                 t: &clean::Typedef) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust typedef'>type {}{} = {};</pre>\",\n-                  it.name.get_ref().as_slice(),\n+                  it.name.as_ref().unwrap().as_slice(),\n                   t.generics,\n                   t.type_));\n \n@@ -2231,5 +2231,5 @@ fn get_basic_keywords() -> &'static str {\n }\n \n fn make_item_keywords(it: &clean::Item) -> String {\n-    format!(\"{}, {}\", get_basic_keywords(), it.name.get_ref())\n+    format!(\"{}, {}\", get_basic_keywords(), it.name.as_ref().unwrap())\n }"}, {"sha": "3138c9be99247ab5fb88e1ccd75f5ddd394ead9d", "filename": "src/librustrt/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -125,8 +125,8 @@ mod imp {\n             let saved_value = take();\n \n             let expected = vec![\n-                Vec::from_slice(b\"happy\"),\n-                Vec::from_slice(b\"today?\"),\n+                b\"happy\".to_vec(),\n+                b\"today?\".to_vec(),\n             ];\n \n             put(expected.clone());"}, {"sha": "a4129fe35067a46c92106089ba6e12cb1f4ac423", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -204,30 +204,6 @@ impl CString {\n         self.buf as *mut _\n     }\n \n-    /// Calls a closure with a reference to the underlying `*libc::c_char`.\n-    #[deprecated=\"use `.as_ptr()`\"]\n-    pub fn with_ref<T>(&self, f: |*const libc::c_char| -> T) -> T {\n-        f(self.buf)\n-    }\n-\n-    /// Calls a closure with a mutable reference to the underlying `*libc::c_char`.\n-    #[deprecated=\"use `.as_mut_ptr()`\"]\n-    pub fn with_mut_ref<T>(&mut self, f: |*mut libc::c_char| -> T) -> T {\n-        f(self.buf as *mut libc::c_char)\n-    }\n-\n-    /// Returns true if the CString is a null.\n-    #[deprecated=\"a CString cannot be null\"]\n-    pub fn is_null(&self) -> bool {\n-        self.buf.is_null()\n-    }\n-\n-    /// Returns true if the CString is not null.\n-    #[deprecated=\"a CString cannot be null\"]\n-    pub fn is_not_null(&self) -> bool {\n-        self.buf.is_not_null()\n-    }\n-\n     /// Returns whether or not the `CString` owns the buffer.\n     pub fn owns_buffer(&self) -> bool {\n         self.owns_buffer_"}, {"sha": "73b4773fb3ff948f129da4229e9ef840b75f2c8e", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -406,14 +406,6 @@ impl<'a> Encoder<'a> {\n         }\n         m.unwrap()\n     }\n-\n-    /// Encode the specified struct into a json str\n-    ///\n-    /// Note: this function is deprecated. Consider using `json::encode` instead.\n-    #[deprecated = \"Replaced by `json::encode`\"]\n-    pub fn str_encode<T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> string::String {\n-        encode(object)\n-    }\n }\n \n impl<'a> ::Encoder<io::IoError> for Encoder<'a> {"}, {"sha": "07be15486fdbc0355f5c945b7897be9e0298cfc5", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 51, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -25,13 +25,6 @@ use string::{mod, String};\n use to_string::IntoStr;\n use vec::Vec;\n \n-#[deprecated=\"this trait has been renamed to `AsciiExt`\"]\n-pub use self::AsciiExt as StrAsciiExt;\n-\n-#[deprecated=\"this trait has been renamed to `OwnedAsciiExt`\"]\n-pub use self::OwnedAsciiExt as OwnedStrAsciiExt;\n-\n-\n /// Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero.\n #[deriving(Clone, PartialEq, PartialOrd, Ord, Eq, Hash)]\n pub struct Ascii { chr: u8 }\n@@ -49,26 +42,12 @@ impl Ascii {\n         self.chr as char\n     }\n \n-    #[inline]\n-    #[allow(missing_doc)]\n-    #[deprecated=\"renamed to `to_lowercase`\"]\n-    pub fn to_lower(self) -> Ascii {\n-        self.to_lowercase()\n-    }\n-\n     /// Convert to lowercase.\n     #[inline]\n     pub fn to_lowercase(self) -> Ascii {\n         Ascii{chr: ASCII_LOWER_MAP[self.chr as uint]}\n     }\n \n-    /// Deprecated: use `to_uppercase`\n-    #[inline]\n-    #[deprecated=\"renamed to `to_uppercase`\"]\n-    pub fn to_upper(self) -> Ascii {\n-        self.to_uppercase()\n-    }\n-\n     /// Convert to uppercase.\n     #[inline]\n     pub fn to_uppercase(self) -> Ascii {\n@@ -83,13 +62,6 @@ impl Ascii {\n \n     // the following methods are like ctype, and the implementation is inspired by musl\n \n-    #[inline]\n-    #[allow(missing_doc)]\n-    #[deprecated=\"renamed to `is_alphabetic`\"]\n-    pub fn is_alpha(&self) -> bool {\n-        self.is_alphabetic()\n-    }\n-\n     /// Check if the character is a letter (a-z, A-Z)\n     #[inline]\n     pub fn is_alphabetic(&self) -> bool {\n@@ -102,13 +74,6 @@ impl Ascii {\n         self.chr >= 0x30 && self.chr <= 0x39\n     }\n \n-    #[inline]\n-    #[allow(missing_doc)]\n-    #[deprecated=\"renamed to `is_alphanumeric`\"]\n-    pub fn is_alnum(&self) -> bool {\n-        self.is_alphanumeric()\n-    }\n-\n     /// Check if the character is a letter or number\n     #[inline]\n     pub fn is_alphanumeric(&self) -> bool {\n@@ -139,26 +104,12 @@ impl Ascii {\n         (self.chr - 0x20) < 0x5F\n     }\n \n-    /// Deprecated: use `to_lowercase`\n-    #[inline]\n-    #[deprecated=\"renamed to `is_lowercase`\"]\n-    pub fn is_lower(&self) -> bool {\n-        self.is_lowercase()\n-    }\n-\n     /// Checks if the character is lowercase\n     #[inline]\n     pub fn is_lowercase(&self) -> bool {\n         (self.chr - b'a') < 26\n     }\n \n-    #[inline]\n-    #[allow(missing_doc)]\n-    #[deprecated=\"renamed to `is_uppercase`\"]\n-    pub fn is_upper(&self) -> bool {\n-        self.is_uppercase()\n-    }\n-\n     /// Checks if the character is uppercase\n     #[inline]\n     pub fn is_uppercase(&self) -> bool {\n@@ -581,7 +532,6 @@ mod tests {\n     use prelude::*;\n     use super::*;\n     use char::from_u32;\n-    use vec::Vec;\n     use str::StrSlice;\n \n     macro_rules! v2ascii (\n@@ -590,7 +540,7 @@ mod tests {\n     )\n \n     macro_rules! vec2ascii (\n-        ($($e:expr),*) => (Vec::from_slice([$(Ascii{chr:$e}),*]));\n+        ($($e:expr),*) => ([$(Ascii{chr:$e}),*].to_vec());\n     )\n \n     #[test]"}, {"sha": "ac0d117e02a114d732ebd7633dab0136b315ac4f", "filename": "src/libstd/collections/hashmap/map.rs", "status": "modified", "additions": 2, "deletions": 304, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -22,7 +22,7 @@ use iter;\n use mem::replace;\n use mem;\n use num;\n-use ops::{Deref, DerefMut};\n+use ops::Deref;\n use option::{Some, None, Option};\n use result::{Ok, Err};\n use ops::Index;\n@@ -425,25 +425,6 @@ impl<K, V, M> SearchResult<K, V, M> {\n     }\n }\n \n-/// A newtyped mutable reference to the hashmap that allows e.g. Deref to be\n-/// implemented without making changes to the visible interface of HashMap.\n-/// Used internally because it's accepted by the search functions above.\n-struct MapMutRef<'a, K: 'a, V: 'a, H: 'a> {\n-    map_ref: &'a mut HashMap<K, V, H>\n-}\n-\n-impl<'a, K, V, H> Deref<RawTable<K, V>> for MapMutRef<'a, K, V, H> {\n-    fn deref(&self) -> &RawTable<K, V> {\n-        &self.map_ref.table\n-    }\n-}\n-\n-impl<'a, K, V, H> DerefMut<RawTable<K, V>> for MapMutRef<'a, K, V, H> {\n-    fn deref_mut(&mut self) -> &mut RawTable<K, V> {\n-        &mut self.map_ref.table\n-    }\n-}\n-\n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     fn make_hash<X: Hash<S>>(&self, x: &X) -> SafeHash {\n         table::make_hash(&self.hasher, x)\n@@ -847,253 +828,6 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Inserts an element which has already been hashed, returning a reference\n-    /// to that element inside the hashtable. This is more efficient that using\n-    /// `insert`, since the key will not be rehashed.\n-    fn insert_hashed(&mut self, hash: SafeHash, k: K, v: V) -> &mut V {\n-        let potential_new_size = self.table.size() + 1;\n-        self.make_some_room(potential_new_size);\n-        self.insert_hashed_nocheck(hash, k, v)\n-    }\n-\n-    /// Deprecated: use `entry` as follows instead:\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hashmap::{Occupied, Vacant};\n-    ///\n-    /// let mut map = HashMap::new();\n-    ///\n-    /// let result = match map.entry(\"a\") {\n-    ///     Vacant(entry) => entry.set(1i),\n-    ///     Occupied(entry) => entry.into_mut(),\n-    /// };\n-    /// assert_eq!(*result, 1);\n-    /// ```\n-    ///\n-    /// Return the value corresponding to the key in the map, or insert\n-    /// and return the value if it doesn't exist.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![allow(deprecated)]\n-    /// use std::collections::HashMap;\n-    /// let mut map = HashMap::new();\n-    ///\n-    /// // Insert 1i with key \"a\"\n-    /// assert_eq!(*map.find_or_insert(\"a\", 1i), 1);\n-    ///\n-    /// // Find the existing key\n-    /// assert_eq!(*map.find_or_insert(\"a\", -2), 1);\n-    /// ```\n-    #[deprecated = \"use entry instead\"]\n-    #[allow(deprecated)]\n-    pub fn find_or_insert(&mut self, k: K, v: V) -> &mut V {\n-        self.find_with_or_insert_with(k, v, |_k, _v, _a| (), |_k, a| a)\n-    }\n-\n-    /// Deprecated: use `entry` as follows instead:\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hashmap::{Occupied, Vacant};\n-    ///\n-    /// let mut map = HashMap::new();\n-    ///\n-    /// let result = match map.entry(\"a\") {\n-    ///     Vacant(entry) => entry.set(1i),\n-    ///     Occupied(entry) => entry.into_mut(),\n-    /// };\n-    /// assert_eq!(*result, 1);\n-    /// ```\n-    ///\n-    /// Return the value corresponding to the key in the map, or create,\n-    /// insert, and return a new value if it doesn't exist.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![allow(deprecated)]\n-    /// use std::collections::HashMap;\n-    /// let mut map = HashMap::new();\n-    ///\n-    /// // Insert 10 with key 2\n-    /// assert_eq!(*map.find_or_insert_with(2i, |&key| 5 * key as uint), 10u);\n-    ///\n-    /// // Find the existing key\n-    /// assert_eq!(*map.find_or_insert_with(2, |&key| key as uint), 10);\n-    /// ```\n-    #[deprecated = \"use entry instead\"]\n-    #[allow(deprecated)]\n-    pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: |&K| -> V)\n-                               -> &'a mut V {\n-        self.find_with_or_insert_with(k, (), |_k, _v, _a| (), |k, _a| f(k))\n-    }\n-\n-    /// Deprecated: use `entry` as follows instead:\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hashmap::{Occupied, Vacant};\n-    ///\n-    /// let mut map = HashMap::new();\n-    ///\n-    /// let result = match map.entry(\"a\") {\n-    ///     Vacant(entry) => entry.set(1u),\n-    ///     Occupied(mut entry) => {\n-    ///         *entry.get_mut() += 1;\n-    ///         entry.into_mut()\n-    ///     }\n-    /// };\n-    /// assert_eq!(*result, 1);\n-    /// ```\n-    ///\n-    /// Insert a key-value pair into the map if the key is not already present.\n-    /// Otherwise, modify the existing value for the key.\n-    /// Returns the new or modified value for the key.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![allow(deprecated)]\n-    /// use std::collections::HashMap;\n-    /// let mut map = HashMap::new();\n-    ///\n-    /// // Insert 2 with key \"a\"\n-    /// assert_eq!(*map.insert_or_update_with(\"a\", 2u, |_key, val| *val = 3), 2);\n-    ///\n-    /// // Update and return the existing value\n-    /// assert_eq!(*map.insert_or_update_with(\"a\", 9, |_key, val| *val = 7), 7);\n-    /// assert_eq!(map[\"a\"], 7);\n-    /// ```\n-    #[deprecated = \"use entry instead\"]\n-    pub fn insert_or_update_with<'a>(\n-                                 &'a mut self,\n-                                 k: K,\n-                                 v: V,\n-                                 f: |&K, &mut V|)\n-                                 -> &'a mut V {\n-        let potential_new_size = self.table.size() + 1;\n-        self.make_some_room(potential_new_size);\n-\n-        let hash = self.make_hash(&k);\n-        self.insert_or_replace_with(hash, k, v, |kref, vref, _v| f(kref, vref))\n-    }\n-\n-    /// Deprecated: use `entry` as follows instead:\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hashmap::{Occupied, Vacant};\n-    ///\n-    /// let mut map = HashMap::new();\n-    ///\n-    /// let result = match map.entry(\"a\") {\n-    ///     Vacant(entry) => entry.set(1u),\n-    ///     Occupied(mut entry) => {\n-    ///         *entry.get_mut() += 1;\n-    ///         entry.into_mut()\n-    ///     }\n-    /// };\n-    /// assert_eq!(*result, 1);\n-    /// ```\n-    ///\n-    /// Modify and return the value corresponding to the key in the map, or\n-    /// insert and return a new value if it doesn't exist.\n-    ///\n-    /// This method allows for all insertion behaviours of a hashmap;\n-    /// see methods like\n-    /// [`insert`](../trait.MutableMap.html#tymethod.insert),\n-    /// [`find_or_insert`](#method.find_or_insert) and\n-    /// [`insert_or_update_with`](#method.insert_or_update_with)\n-    /// for less general and more friendly variations of this.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![allow(deprecated)]\n-    /// use std::collections::HashMap;\n-    ///\n-    /// // map some strings to vectors of strings\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a key\", vec![\"value\"]);\n-    /// map.insert(\"z key\", vec![\"value\"]);\n-    ///\n-    /// let new = vec![\"a key\", \"b key\", \"z key\"];\n-    ///\n-    /// for k in new.into_iter() {\n-    ///     map.find_with_or_insert_with(\n-    ///         k, \"new value\",\n-    ///         // if the key does exist either prepend or append this\n-    ///         // new value based on the first letter of the key.\n-    ///         |key, already, new| {\n-    ///             if key.as_slice().starts_with(\"z\") {\n-    ///                 already.insert(0, new);\n-    ///             } else {\n-    ///                 already.push(new);\n-    ///             }\n-    ///         },\n-    ///         // if the key doesn't exist in the map yet, add it in\n-    ///         // the obvious way.\n-    ///         |_k, v| vec![v]);\n-    /// }\n-    ///\n-    /// assert_eq!(map.len(), 3);\n-    /// assert_eq!(map[\"a key\"], vec![\"value\", \"new value\"]);\n-    /// assert_eq!(map[\"b key\"], vec![\"new value\"]);\n-    /// assert_eq!(map[\"z key\"], vec![\"new value\", \"value\"]);\n-    /// ```\n-    #[deprecated = \"use entry instead\"]\n-    pub fn find_with_or_insert_with<'a, A>(&'a mut self,\n-                                           k: K,\n-                                           a: A,\n-                                           found: |&K, &mut V, A|,\n-                                           not_found: |&K, A| -> V)\n-                                          -> &'a mut V\n-    {\n-        let hash = self.make_hash(&k);\n-        let this = MapMutRef { map_ref: self };\n-\n-        match search_hashed(this, &hash, &k) {\n-            FoundExisting(bucket) => {\n-                let (_, v_ref) = bucket.into_mut_refs();\n-                found(&k, v_ref, a);\n-                v_ref\n-            }\n-            TableRef(this) => {\n-                let v = not_found(&k, a);\n-                this.map_ref.insert_hashed(hash, k, v)\n-            }\n-        }\n-    }\n-\n-    /// Retrieves a value for the given key.\n-    /// See [`find`](../trait.Map.html#tymethod.find) for a non-failing alternative.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the key is not present.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![allow(deprecated)]\n-    ///\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1i);\n-    /// assert_eq!(map.get(&\"a\"), &1);\n-    /// ```\n-    #[deprecated = \"prefer indexing instead, e.g., map[key]\"]\n-    pub fn get<'a>(&'a self, k: &K) -> &'a V {\n-        match self.find(k) {\n-            Some(v) => v,\n-            None => fail!(\"no entry found for key\")\n-        }\n-    }\n-\n     /// Retrieves a mutable value for the given key.\n     /// See [`find_mut`](../trait.MutableMap.html#tymethod.find_mut) for a non-failing alternative.\n     ///\n@@ -1274,12 +1008,6 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         Entries { inner: self.table.iter() }\n     }\n \n-    /// Deprecated: use `iter_mut`.\n-    #[deprecated = \"use iter_mut\"]\n-    pub fn mut_iter(&mut self) -> MutEntries<K, V> {\n-        self.iter_mut()\n-    }\n-\n     /// An iterator visiting all key-value pairs in arbitrary order,\n     /// with mutable references to the values.\n     /// Iterator element type is `(&'a K, &'a mut V)`.\n@@ -1307,12 +1035,6 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         MutEntries { inner: self.table.iter_mut() }\n     }\n \n-    /// Deprecated: use `into_iter`.\n-    #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(self) -> MoveEntries<K, V> {\n-        self.into_iter()\n-    }\n-\n     /// Creates a consuming iterator, that is, one that moves each key-value\n     /// pair out of the map in arbitrary order. The map cannot be used after\n     /// calling this.\n@@ -1468,9 +1190,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H>\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Index<K, V> for HashMap<K, V, H> {\n     #[inline]\n-    #[allow(deprecated)]\n     fn index<'a>(&'a self, index: &K) -> &'a V {\n-        self.get(index)\n+        self.find(index).expect(\"no entry found for key\")\n     }\n }\n \n@@ -1929,29 +1650,6 @@ mod test_map {\n         assert_eq!(*m.find(&1).unwrap(), 2);\n     }\n \n-    #[test]\n-    #[allow(deprecated)] // insert_or_update_with\n-    fn test_update_with() {\n-        let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1i, 2i));\n-\n-        for i in range(1i, 1000) {\n-            assert_eq!(\n-                i + 2,\n-                *m.insert_or_update_with(i + 1, i + 2, |_k, _v| {\n-                    fail!(\"Key not yet present\");\n-                })\n-            );\n-            assert_eq!(\n-                i + 1,\n-                *m.insert_or_update_with(i, i + 3, |k, v| {\n-                    assert_eq!(*k, i);\n-                    assert_eq!(*v, i + 1);\n-                })\n-            );\n-        }\n-    }\n-\n     #[test]\n     fn test_conflict_remove() {\n         let mut m = HashMap::with_capacity(4);"}, {"sha": "53e60d553be5f6ce0ba3297b25dcefcf00cabab9", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -85,13 +85,6 @@ impl UdpSocket {\n         }\n     }\n \n-    #[allow(missing_doc)]\n-    #[deprecated = \"renamed to `recv_from`\"]\n-    pub fn recvfrom(&mut self, buf: &mut [u8])\n-                    -> IoResult<(uint, SocketAddr)> {\n-        self.recv_from(buf)\n-    }\n-\n     /// Sends data on the socket to the given address. Returns nothing on\n     /// success.\n     pub fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n@@ -101,12 +94,6 @@ impl UdpSocket {\n         }).map_err(IoError::from_rtio_error)\n     }\n \n-    #[allow(missing_doc)]\n-    #[deprecated = \"renamed to `send_to`\"]\n-    pub fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n-        self.send_to(buf, dst)\n-    }\n-\n     /// Creates a `UdpStream`, which allows use of the `Reader` and `Writer`\n     /// traits to receive and send data from the same address. This transfers\n     /// ownership of the socket to the stream.\n@@ -176,12 +163,6 @@ impl UdpSocket {\n         }.map_err(IoError::from_rtio_error)\n     }\n \n-    /// Sets the broadcast flag on or off\n-    #[deprecated=\"renamed to `set_broadcast`\"]\n-    pub fn set_broadast(&mut self, broadcast: bool) -> IoResult<()> {\n-        self.set_broadcast(broadcast)\n-    }\n-\n     /// Sets the read/write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`"}, {"sha": "c47cd02599485ff5b40ba14c6def549fa4a518af", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -134,7 +134,6 @@ extern crate rustrt;\n #[cfg(test)] pub use realstd::kinds;\n #[cfg(test)] pub use realstd::ops;\n #[cfg(test)] pub use realstd::cmp;\n-#[cfg(test)] pub use realstd::ty;\n #[cfg(test)] pub use realstd::boxed;\n \n \n@@ -159,13 +158,10 @@ pub use core::tuple;\n // FIXME #15320: primitive documentation needs top-level modules, this\n // should be `std::tuple::unit`.\n pub use core::unit;\n-#[cfg(not(test))] pub use core::ty;\n pub use core::result;\n pub use core::option;\n \n pub use alloc::boxed;\n-#[deprecated = \"use boxed instead\"]\n-pub use boxed as owned;\n \n pub use alloc::rc;\n "}, {"sha": "92db94c5e9a5ada1127861d38130012ad461fce3", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -333,29 +333,6 @@ pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n     r\n }\n \n-impl num::ToStrRadix for f32 {\n-    /// Converts a float to a string in a given radix\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * num - The float value\n-    /// * radix - The base to use\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n-    /// possible misinterpretation of the result at higher bases. If those values\n-    /// are expected, use `to_str_radix_special()` instead.\n-    #[inline]\n-    fn to_str_radix(&self, rdx: uint) -> String {\n-        let (r, special) = strconv::float_to_str_common(\n-            *self, rdx, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n-        if special { fail!(\"number has a special value, \\\n-                            try to_str_radix_special() if those are expected\") }\n-        r\n-    }\n-}\n-\n /// Convert a string in base 16 to a float.\n /// Accepts an optional binary exponent.\n ///"}, {"sha": "3635c3192db32a04d08c6ac95b6e830816b29778", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -341,29 +341,6 @@ pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n     r\n }\n \n-impl num::ToStrRadix for f64 {\n-    /// Converts a float to a string in a given radix\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * num - The float value\n-    /// * radix - The base to use\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if called on a special value like `inf`, `-inf` or `NAN` due to\n-    /// possible misinterpretation of the result at higher bases. If those values\n-    /// are expected, use `to_str_radix_special()` instead.\n-    #[inline]\n-    fn to_str_radix(&self, rdx: uint) -> String {\n-        let (r, special) = strconv::float_to_str_common(\n-            *self, rdx, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n-        if special { fail!(\"number has a special value, \\\n-                             try to_str_radix_special() if those are expected\") }\n-        r\n-    }\n-}\n-\n /// Convert a string in base 16 to a float.\n /// Accepts an optional binary exponent.\n ///"}, {"sha": "d7732b474dba808277a11ecf78a4b66b9faf5098", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"i16\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::i16::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "778f1c6748c262a4a56c4139ddd6ee0055a6721c", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"i32\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::i32::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "ae3d57eeac65db2e9616b70bda76879a0df5f749", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"i64\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::i64::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "8a3f379893c24d3a278f0c18d8b76b5968e7e65c", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"i8\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::i8::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "51af04b32d4fbf0e0411ff907e29b8facb3766fd", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"int\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::int::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "ca45b40e687a1d07bdb88dbe045ac6732441cfd6", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -51,52 +51,12 @@ impl FromStrRadix for $T {\n     }\n }\n \n-// String conversion functions and impl num -> str\n-\n-/// Convert to a string as a byte slice in a given base.\n-///\n-/// Use in place of x.to_string() when you do not need to store the string permanently\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![allow(deprecated)]\n-///\n-/// std::int::to_str_bytes(123, 10, |v| {\n-///     assert!(v == \"123\".as_bytes());\n-/// });\n-/// ```\n-#[inline]\n-#[deprecated = \"just use .to_string(), or a BufWriter with write! if you mustn't allocate\"]\n-pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n-    use io::{Writer, Seek};\n-    // The radix can be as low as 2, so we need at least 64 characters for a\n-    // base 2 number, and then we need another for a possible '-' character.\n-    let mut buf = [0u8, ..65];\n-    let amt = {\n-        let mut wr = ::io::BufWriter::new(buf);\n-        (write!(&mut wr, \"{}\", ::fmt::radix(n, radix as u8))).unwrap();\n-        wr.tell().unwrap() as uint\n-    };\n-    f(buf[..amt])\n-}\n-\n-#[deprecated = \"use fmt::radix\"]\n-impl ToStrRadix for $T {\n-    /// Convert to a string in a given base.\n-    #[inline]\n-    fn to_str_radix(&self, radix: uint) -> String {\n-        format!(\"{}\", ::fmt::radix(*self, radix as u8))\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n     use super::*;\n \n     use i32;\n-    use num::ToStrRadix;\n     use str::StrSlice;\n \n     #[test]\n@@ -142,16 +102,6 @@ mod tests {\n         assert!(parse_bytes(\"-9\".as_bytes(), 2u).is_none());\n     }\n \n-    #[test]\n-    fn test_to_string() {\n-        assert_eq!((0 as $T).to_str_radix(10u), \"0\".to_string());\n-        assert_eq!((1 as $T).to_str_radix(10u), \"1\".to_string());\n-        assert_eq!((-1 as $T).to_str_radix(10u), \"-1\".to_string());\n-        assert_eq!((127 as $T).to_str_radix(16u), \"7f\".to_string());\n-        assert_eq!((100 as $T).to_str_radix(10u), \"100\".to_string());\n-\n-    }\n-\n     #[test]\n     fn test_int_to_str_overflow() {\n         let mut i8_val: i8 = 127_i8;"}, {"sha": "564b6a25f7faf0d44b75cadebe81d15f68ccd2f8", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -17,7 +17,6 @@\n #![allow(missing_doc)]\n \n use option::Option;\n-use string::String;\n \n #[cfg(test)] use fmt::Show;\n \n@@ -111,12 +110,6 @@ pub trait FloatMath: Float {\n     fn atanh(self) -> Self;\n }\n \n-/// A generic trait for converting a value to a string with a radix (base)\n-#[deprecated = \"use fmt::radix\"]\n-pub trait ToStrRadix {\n-    fn to_str_radix(&self, radix: uint) -> String;\n-}\n-\n /// A generic trait for converting a string with a radix (base) to a value\n #[experimental = \"might need to return Result\"]\n pub trait FromStrRadix {"}, {"sha": "af66e6ca9349003891635ece3de9f761ec614592", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -20,7 +20,7 @@ use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n use num;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use option::{None, Option, Some};\n-use slice::{ImmutableSlice, MutableSlice};\n+use slice::{ImmutableSlice, MutableSlice, CloneableVector};\n use std::cmp::{PartialOrd, PartialEq};\n use str::StrSlice;\n use string::String;\n@@ -168,8 +168,7 @@ static NAN_BUF:     [u8, ..3] = [b'N', b'a', b'N'];\n  * # Failure\n  * - Fails if `radix` < 2 or `radix` > 36.\n  */\n-#[deprecated = \"format!() and friends should be favored instead\"]\n-pub fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8|) {\n+fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8|) {\n     assert!(2 <= radix && radix <= 36);\n \n     let _0: T = Zero::zero();\n@@ -257,7 +256,6 @@ pub fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f:\n  * - Fails if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n  *   between digit and exponent sign `'p'`.\n  */\n-#[allow(deprecated)]\n pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n                                   Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: T, radix: uint, negative_zero: bool,\n@@ -278,17 +276,17 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n     let _1: T = One::one();\n \n     match num.classify() {\n-        FPNaN => { return (Vec::from_slice(\"NaN\".as_bytes()), true); }\n+        FPNaN => { return (b\"NaN\".to_vec(), true); }\n         FPInfinite if num > _0 => {\n             return match sign {\n-                SignAll => (Vec::from_slice(\"+inf\".as_bytes()), true),\n-                _       => (Vec::from_slice(\"inf\".as_bytes()), true)\n+                SignAll => (b\"+inf\".to_vec(), true),\n+                _       => (b\"inf\".to_vec(), true)\n             };\n         }\n         FPInfinite if num < _0 => {\n             return match sign {\n-                SignNone => (Vec::from_slice(\"inf\".as_bytes()), true),\n-                _        => (Vec::from_slice(\"-inf\".as_bytes()), true),\n+                SignNone => (b\"inf\".to_vec(), true),\n+                _        => (b\"-inf\".to_vec(), true),\n             };\n         }\n         _ => {}\n@@ -413,18 +411,18 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n                     // If reached left end of number, have to\n                     // insert additional digit:\n                     if i < 0\n-                    || *buf.get(i as uint) == b'-'\n-                    || *buf.get(i as uint) == b'+' {\n+                    || buf[i as uint] == b'-'\n+                    || buf[i as uint] == b'+' {\n                         buf.insert((i + 1) as uint, value2ascii(1));\n                         break;\n                     }\n \n                     // Skip the '.'\n-                    if *buf.get(i as uint) == b'.' { i -= 1; continue; }\n+                    if buf[i as uint] == b'.' { i -= 1; continue; }\n \n                     // Either increment the digit,\n                     // or set to 0 if max and carry the 1.\n-                    let current_digit = ascii2value(*buf.get(i as uint));\n+                    let current_digit = ascii2value(buf[i as uint]);\n                     if current_digit < (radix - 1) {\n                         *buf.get_mut(i as uint) = value2ascii(current_digit+1);\n                         break;\n@@ -446,25 +444,25 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n         let mut i = buf_max_i;\n \n         // discover trailing zeros of fractional part\n-        while i > start_fractional_digits && *buf.get(i) == b'0' {\n+        while i > start_fractional_digits && buf[i] == b'0' {\n             i -= 1;\n         }\n \n         // Only attempt to truncate digits if buf has fractional digits\n         if i >= start_fractional_digits {\n             // If buf ends with '.', cut that too.\n-            if *buf.get(i) == b'.' { i -= 1 }\n+            if buf[i] == b'.' { i -= 1 }\n \n             // only resize buf if we actually remove digits\n             if i < buf_max_i {\n-                buf = Vec::from_slice(buf.slice(0, i + 1));\n+                buf = buf.slice(0, i + 1).to_vec();\n             }\n         }\n     } // If exact and trailing '.', just cut that\n     else {\n         let max_i = buf.len() - 1;\n-        if *buf.get(max_i) == b'.' {\n-            buf = Vec::from_slice(buf.slice(0, max_i));\n+        if buf[max_i] == b'.' {\n+            buf = buf.slice(0, max_i).to_vec();\n         }\n     }\n "}, {"sha": "bb619b5b2f59542cc65134bc8f58315039f202aa", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"u16\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::u16::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "754103ba5dab214375613fd6d7566e6bdd293433", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"u32\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::u32::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "da497d2cbe470e6b98684159f2f1739aaa73cc3c", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"u64\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::u64::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "bdfcdb2c5a5bceaa15d8d4ae5f5a4d4c6dbb48ec", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"u8\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::u8::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "5090219d3de65ce4a2bd1011e0601246c7a214b5", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"uint\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::uint::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "f9bc9eb539a13fed59f7ca0693b314a25dd1b505", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -82,35 +82,14 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n     f(buf[..amt])\n }\n \n-#[deprecated = \"use fmt::radix\"]\n-impl ToStrRadix for $T {\n-    /// Convert to a string in a given base.\n-    #[inline]\n-    fn to_str_radix(&self, radix: uint) -> String {\n-        format!(\"{}\", ::fmt::radix(*self, radix as u8))\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n     use super::*;\n \n-    use num::ToStrRadix;\n     use str::StrSlice;\n     use u16;\n \n-    #[test]\n-    pub fn test_to_string() {\n-        assert_eq!((0 as $T).to_str_radix(10u), \"0\".to_string());\n-        assert_eq!((1 as $T).to_str_radix(10u), \"1\".to_string());\n-        assert_eq!((2 as $T).to_str_radix(10u), \"2\".to_string());\n-        assert_eq!((11 as $T).to_str_radix(10u), \"11\".to_string());\n-        assert_eq!((11 as $T).to_str_radix(16u), \"b\".to_string());\n-        assert_eq!((255 as $T).to_str_radix(16u), \"ff\".to_string());\n-        assert_eq!((0xff as $T).to_str_radix(10u), \"255\".to_string());\n-    }\n-\n     #[test]\n     pub fn test_from_str() {\n         assert_eq!(from_str::<$T>(\"0\"), Some(0u as $T));\n@@ -199,18 +178,6 @@ mod tests {\n         assert_eq!(from_str::<u64>(\"0\"), Some(u64_val));\n         assert!(from_str::<u64>(\"-1\").is_none());\n     }\n-\n-    #[test]\n-    #[should_fail]\n-    pub fn to_str_radix1() {\n-        100u.to_str_radix(1u);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    pub fn to_str_radix37() {\n-        100u.to_str_radix(37u);\n-    }\n }\n \n ))"}, {"sha": "38e1e952f77e275bf7505c269dc4100e13c403c3", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -26,9 +26,6 @@ pub use core_sync::{RWLock, RWLockReadGuard, RWLockWriteGuard};\n pub use core_sync::{Semaphore, SemaphoreGuard};\n pub use core_sync::one::{Once, ONCE_INIT};\n \n-#[deprecated = \"use atomic instead\"]\n-pub use core_sync::atomic as atomics;\n-\n pub use self::future::Future;\n pub use self::task_pool::TaskPool;\n "}, {"sha": "1d1e6ae4febfdc8f8ffb514c41a8ca83b8d8bc62", "filename": "src/libstd/task.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -225,26 +225,6 @@ impl<S: Spawner> TaskBuilder<S> {\n         }\n     }\n \n-    /// Add a wrapper to the body of the spawned task.\n-    ///\n-    /// Before the task is spawned it is passed through a 'body generator'\n-    /// function that may perform local setup operations as well as wrap\n-    /// the task body in remote setup operations. With this the behavior\n-    /// of tasks can be extended in simple ways.\n-    ///\n-    /// This function augments the current body generator with a new body\n-    /// generator by applying the task body which results from the\n-    /// existing body generator to the new body generator.\n-    #[deprecated = \"this function will be removed soon\"]\n-    pub fn with_wrapper(mut self, wrapper: proc(v: proc():Send):Send -> proc():Send)\n-                        -> TaskBuilder<S> {\n-        self.gen_body = match self.gen_body.take() {\n-            Some(prev) => Some(proc(body) { wrapper(prev(body)) }),\n-            None => Some(wrapper)\n-        };\n-        self\n-    }\n-\n     // Where spawning actually happens (whether yielding a future or not)\n     fn spawn_internal(self, f: proc():Send,\n                       on_exit: Option<proc(Result<(), Box<Any + Send>>):Send>) {\n@@ -353,18 +333,6 @@ pub fn try_future<T:Send>(f: proc():Send -> T) -> Future<Result<T, Box<Any + Sen\n \n /* Lifecycle functions */\n \n-/// Read the name of the current task.\n-#[deprecated = \"Use `task::name()`.\"]\n-pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U {\n-    use rt::task::Task;\n-\n-    let task = Local::borrow(None::<Task>);\n-    match task.name {\n-        Some(ref name) => blk(Some(name.as_slice())),\n-        None => blk(None)\n-    }\n-}\n-\n /// Read the name of the current task.\n #[stable]\n pub fn name() -> Option<String> {\n@@ -446,20 +414,6 @@ mod test {\n         rx.recv();\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_with_wrapper() {\n-        let (tx, rx) = channel();\n-        TaskBuilder::new().with_wrapper(proc(body) {\n-            let result: proc():Send = proc() {\n-                body();\n-                tx.send(());\n-            };\n-            result\n-        }).spawn(proc() { });\n-        rx.recv();\n-    }\n-\n     #[test]\n     fn test_try_future() {\n         let result = TaskBuilder::new().try_future(proc() {});"}, {"sha": "1dc1f4b87f27cbdf2f2babfb810ac90f43072789", "filename": "src/libsync/comm/duplex.rs", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Flibsync%2Fcomm%2Fduplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Flibsync%2Fcomm%2Fduplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fduplex.rs?ref=fb169d5543c84e11038ba2d07b538ec88fb49ca6", "patch": "@@ -1,78 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Higher level communication abstractions.\n-\n-*/\n-\n-#![allow(missing_doc)]\n-#![allow(deprecated)]\n-#![deprecated = \"This type is replaced by having a pair of channels. This type \\\n-                 is not fully composable with other channels in terms of \\\n-                 or possible semantics on a duplex stream. It will be removed \\\n-                 soon\"]\n-\n-use core::prelude::*;\n-\n-use comm;\n-use comm::{Sender, Receiver, channel};\n-\n-/// An extension of `pipes::stream` that allows both sending and receiving.\n-pub struct DuplexStream<S, R> {\n-    tx: Sender<S>,\n-    rx: Receiver<R>,\n-}\n-\n-/// Creates a bidirectional stream.\n-pub fn duplex<S: Send, R: Send>() -> (DuplexStream<S, R>, DuplexStream<R, S>) {\n-    let (tx1, rx1) = channel();\n-    let (tx2, rx2) = channel();\n-    (DuplexStream { tx: tx1, rx: rx2 },\n-     DuplexStream { tx: tx2, rx: rx1 })\n-}\n-\n-// Allow these methods to be used without import:\n-impl<S:Send,R:Send> DuplexStream<S, R> {\n-    pub fn send(&self, x: S) {\n-        self.tx.send(x)\n-    }\n-    pub fn send_opt(&self, x: S) -> Result<(), S> {\n-        self.tx.send_opt(x)\n-    }\n-    pub fn recv(&self) -> R {\n-        self.rx.recv()\n-    }\n-    pub fn try_recv(&self) -> Result<R, comm::TryRecvError> {\n-        self.rx.try_recv()\n-    }\n-    pub fn recv_opt(&self) -> Result<R, ()> {\n-        self.rx.recv_opt()\n-    }\n-}\n-\n-#[allow(deprecated)]\n-#[cfg(test)]\n-mod test {\n-    use std::prelude::*;\n-    use comm::duplex;\n-\n-    #[test]\n-    pub fn duplex_stream_1() {\n-        let (left, right) = duplex();\n-\n-        left.send(\"abc\".to_string());\n-        right.send(123i);\n-\n-        assert!(left.recv() == 123);\n-        assert!(right.recv() == \"abc\".to_string());\n-    }\n-}"}, {"sha": "ddfd1088a41a844e8537b8074f8811796dc8c9e7", "filename": "src/libsync/comm/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsync%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsync%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fmod.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -333,7 +333,6 @@ use rustrt::local::Local;\n use rustrt::task::{Task, BlockedTask};\n \n pub use comm::select::{Select, Handle};\n-pub use comm::duplex::{DuplexStream, duplex};\n \n macro_rules! test (\n     { fn $name:ident() $b:block $(#[$a:meta])*} => (\n@@ -354,14 +353,13 @@ macro_rules! test (\n             $(#[$a])* #[test] fn native() {\n                 use native;\n                 let (tx, rx) = channel();\n-                native::task::spawn(proc() { tx.send(f()) });\n+                spawn(proc() { tx.send(f()) });\n                 rx.recv();\n             }\n         }\n     )\n )\n \n-mod duplex;\n mod oneshot;\n mod select;\n mod shared;\n@@ -1064,7 +1062,6 @@ impl<T: Send> Drop for Receiver<T> {\n mod test {\n     use std::prelude::*;\n \n-    use native;\n     use std::os;\n     use super::*;\n \n@@ -1224,7 +1221,7 @@ mod test {\n             tx3.send(());\n         });\n         rx1.recv();\n-        native::task::spawn(proc() {\n+        spawn(proc() {\n             for _ in range(0i, 40) {\n                 tx2.send(1);\n             }\n@@ -1238,7 +1235,7 @@ mod test {\n     fn recv_from_outside_runtime() {\n         let (tx, rx) = channel::<int>();\n         let (dtx, drx) = channel();\n-        native::task::spawn(proc() {\n+        spawn(proc() {\n             for _ in range(0i, 40) {\n                 assert_eq!(rx.recv(), 1);\n             }\n@@ -1256,12 +1253,12 @@ mod test {\n         let (tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n         let tx4 = tx3.clone();\n-        native::task::spawn(proc() {\n+        spawn(proc() {\n             assert_eq!(rx1.recv(), 1);\n             tx2.send(2);\n             tx4.send(());\n         });\n-        native::task::spawn(proc() {\n+        spawn(proc() {\n             tx1.send(1);\n             assert_eq!(rx2.recv(), 2);\n             tx3.send(());"}, {"sha": "b3b504f49ca3a84680da298c1cf0cdf3315e6beb", "filename": "src/libsync/mpmc_bounded_queue.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpmc_bounded_queue.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -167,7 +167,6 @@ impl<T: Send> Clone for Queue<T> {\n mod tests {\n     use std::prelude::*;\n     use super::Queue;\n-    use native;\n \n     #[test]\n     fn test() {\n@@ -180,7 +179,7 @@ mod tests {\n         for _ in range(0, nthreads) {\n             let q = q.clone();\n             let tx = tx.clone();\n-            native::task::spawn(proc() {\n+            spawn(proc() {\n                 let q = q;\n                 for i in range(0, nmsgs) {\n                     assert!(q.push(i));\n@@ -194,7 +193,7 @@ mod tests {\n             let (tx, rx) = channel();\n             completion_rxs.push(rx);\n             let q = q.clone();\n-            native::task::spawn(proc() {\n+            spawn(proc() {\n                 let q = q;\n                 let mut i = 0u;\n                 loop {"}, {"sha": "ac2acf3d7d4d2f0770f749e7814347e4ddda5291", "filename": "src/libsync/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsync%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsync%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpsc_queue.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -161,7 +161,6 @@ mod tests {\n \n     use alloc::arc::Arc;\n \n-    use native;\n     use super::{Queue, Data, Empty, Inconsistent};\n \n     #[test]\n@@ -186,7 +185,7 @@ mod tests {\n         for _ in range(0, nthreads) {\n             let tx = tx.clone();\n             let q = q.clone();\n-            native::task::spawn(proc() {\n+            spawn(proc() {\n                 for i in range(0, nmsgs) {\n                     q.push(i);\n                 }"}, {"sha": "7d191eab2d1578b5ef441b3596ad37a082676f0b", "filename": "src/libsync/mutex.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmutex.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -525,7 +525,6 @@ impl Drop for Mutex {\n mod test {\n     use std::prelude::*;\n     use super::{Mutex, StaticMutex, MUTEX_INIT};\n-    use native;\n \n     #[test]\n     fn smoke() {\n@@ -563,7 +562,7 @@ mod test {\n         let (tx, rx) = channel();\n         for _ in range(0, K) {\n             let tx2 = tx.clone();\n-            native::task::spawn(proc() { inc(); tx2.send(()); });\n+            spawn(proc() { inc(); tx2.send(()); });\n             let tx2 = tx.clone();\n             spawn(proc() { inc(); tx2.send(()); });\n         }"}, {"sha": "9cd64d46bad85e5175ffa37a17dd0ab3d59150f9", "filename": "src/libsync/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fspsc_queue.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -296,8 +296,6 @@ impl<T: Send> Drop for Queue<T> {\n mod test {\n     use std::prelude::*;\n \n-    use native;\n-\n     use super::{queue};\n \n     #[test]\n@@ -364,7 +362,7 @@ mod test {\n             let (consumer, mut producer) = queue(bound);\n \n             let (tx, rx) = channel();\n-            native::task::spawn(proc() {\n+            spawn(proc() {\n                 // Move the consumer to a local mutable slot\n                 let mut consumer = consumer;\n                 for _ in range(0u, 100000) {"}, {"sha": "60e4db405d7663507e88fb1a79b9f911d2d717a0", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -699,8 +699,12 @@ struct NodeCollector<'ast> {\n \n impl<'ast> NodeCollector<'ast> {\n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n-        self.map.grow_set(id as uint, &NotPresent, entry);\n         debug!(\"ast_map: {} => {}\", id, entry);\n+        let len = self.map.len();\n+        if id as uint >= len {\n+            self.map.grow(id as uint - len + 1, NotPresent);\n+        }\n+        *self.map.get_mut(id as uint) = entry;\n     }\n \n     fn insert(&mut self, id: NodeId, node: Node<'ast>) {"}, {"sha": "5626f0a8ad962ccc6588d13588f24df2b5d7a7be", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -202,7 +202,7 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n     let mut pretty = pprust::ty_to_string(ty);\n     match *trait_ref {\n         Some(ref trait_ref) => {\n-            pretty.push_char('.');\n+            pretty.push('.');\n             pretty.push_str(pprust::path_to_string(&trait_ref.path).as_slice());\n         }\n         None => {}"}, {"sha": "4df334a3f2c70cbee997387aba9f67c6f053466e", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -283,17 +283,17 @@ impl FileMap {\n     /// filemap.start_pos + newline_offset_relative_to_the_start_of_filemap.\n     pub fn next_line(&self, pos: BytePos) {\n         // the new charpos must be > the last one (or it's the first one).\n-        let mut lines = self.lines.borrow_mut();;\n+        let mut lines = self.lines.borrow_mut();\n         let line_len = lines.len();\n-        assert!(line_len == 0 || (*lines.get(line_len - 1) < pos))\n+        assert!(line_len == 0 || ((*lines)[line_len - 1] < pos))\n         lines.push(pos);\n     }\n \n     /// get a line from the list of pre-computed line-beginnings\n     ///\n     pub fn get_line(&self, line: int) -> String {\n         let lines = self.lines.borrow();\n-        let begin: BytePos = *lines.get(line as uint) - self.start_pos;\n+        let begin: BytePos = (*lines)[line as uint] - self.start_pos;\n         let begin = begin.to_uint();\n         let slice = self.src.as_slice().slice_from(begin);\n         match slice.find('\\n') {\n@@ -351,7 +351,7 @@ impl CodeMap {\n         // overflowing into the next filemap in case the last byte of span is also the last\n         // byte of filemap, which leads to incorrect results from CodeMap.span_to_*.\n         if src.len() > 0 && !src.as_slice().ends_with(\"\\n\") {\n-            src.push_char('\\n');\n+            src.push('\\n');\n         }\n \n         let filemap = Rc::new(FileMap {\n@@ -446,7 +446,7 @@ impl CodeMap {\n \n     pub fn lookup_byte_offset(&self, bpos: BytePos) -> FileMapAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);\n-        let fm = self.files.borrow().get(idx).clone();\n+        let fm = (*self.files.borrow())[idx].clone();\n         let offset = bpos - fm.start_pos;\n         FileMapAndBytePos {fm: fm, pos: offset}\n     }\n@@ -455,7 +455,7 @@ impl CodeMap {\n     pub fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos {\n         let idx = self.lookup_filemap_idx(bpos);\n         let files = self.files.borrow();\n-        let map = files.get(idx);\n+        let map = &(*files)[idx];\n \n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n@@ -480,34 +480,37 @@ impl CodeMap {\n \n     fn lookup_filemap_idx(&self, pos: BytePos) -> uint {\n         let files = self.files.borrow();\n-        let files = files;\n+        let files = &*files;\n         let len = files.len();\n         let mut a = 0u;\n         let mut b = len;\n         while b - a > 1u {\n             let m = (a + b) / 2u;\n-            if files.get(m).start_pos > pos {\n+            if files[m].start_pos > pos {\n                 b = m;\n             } else {\n                 a = m;\n             }\n         }\n-        // There can be filemaps with length 0. These have the same start_pos as the previous\n-        // filemap, but are not the filemaps we want (because they are length 0, they cannot\n-        // contain what we are looking for). So, rewind until we find a useful filemap.\n+        // There can be filemaps with length 0. These have the same start_pos as\n+        // the previous filemap, but are not the filemaps we want (because they\n+        // are length 0, they cannot contain what we are looking for). So,\n+        // rewind until we find a useful filemap.\n         loop {\n-            let lines = files.get(a).lines.borrow();\n+            let lines = files[a].lines.borrow();\n             let lines = lines;\n             if lines.len() > 0 {\n                 break;\n             }\n             if a == 0 {\n-                fail!(\"position {} does not resolve to a source location\", pos.to_uint());\n+                fail!(\"position {} does not resolve to a source location\",\n+                      pos.to_uint());\n             }\n             a -= 1;\n         }\n         if a >= len {\n-            fail!(\"position {} does not resolve to a source location\", pos.to_uint())\n+            fail!(\"position {} does not resolve to a source location\",\n+                  pos.to_uint())\n         }\n \n         return a;\n@@ -517,14 +520,14 @@ impl CodeMap {\n         let idx = self.lookup_filemap_idx(pos);\n \n         let files = self.files.borrow();\n-        let f = files.get(idx).clone();\n+        let f = (*files)[idx].clone();\n         let mut a = 0u;\n         {\n             let lines = f.lines.borrow();\n             let mut b = lines.len();\n             while b - a > 1u {\n                 let m = (a + b) / 2u;\n-                if *lines.get(m) > pos { b = m; } else { a = m; }\n+                if (*lines)[m] > pos { b = m; } else { a = m; }\n             }\n         }\n         FileMapAndLine {fm: f, line: a}\n@@ -534,7 +537,7 @@ impl CodeMap {\n         let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n         let line = a + 1u; // Line numbers start at 1\n         let chpos = self.bytepos_to_file_charpos(pos);\n-        let linebpos = *f.lines.borrow().get(a);\n+        let linebpos = (*f.lines.borrow())[a];\n         let linechpos = self.bytepos_to_file_charpos(linebpos);\n         debug!(\"byte pos {} is on the line at byte pos {}\",\n                pos, linebpos);\n@@ -704,7 +707,7 @@ mod test {\n \n         assert_eq!(file_lines.file.name, \"blork.rs\".to_string());\n         assert_eq!(file_lines.lines.len(), 1);\n-        assert_eq!(*file_lines.lines.get(0), 1u);\n+        assert_eq!(file_lines.lines[0], 1u);\n     }\n \n     #[test]"}, {"sha": "67605360a48cb665d1b4621aca5650012f4b174f", "filename": "src/libsyntax/crateid.rs", "status": "removed", "additions": 0, "deletions": 216, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=fb169d5543c84e11038ba2d07b538ec88fb49ca6", "patch": "@@ -1,216 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::fmt;\n-\n-/// CrateIds identify crates and include the crate name and optionally a path\n-/// and version. In the full form, they look like relative URLs. Example:\n-/// `github.com/rust-lang/rust#std:1.0` would be a package ID with a path of\n-/// `github.com/rust-lang/rust` and a crate name of `std` with a version of\n-/// `1.0`. If no crate name is given after the hash, the name is inferred to\n-/// be the last component of the path. If no version is given, it is inferred\n-/// to be `0.0`.\n-\n-use std::from_str::FromStr;\n-\n-#[deriving(Clone, PartialEq)]\n-pub struct CrateId {\n-    /// A path which represents the codes origin. By convention this is the\n-    /// URL, without `http://` or `https://` prefix, to the crate's repository\n-    pub path: String,\n-    /// The name of the crate.\n-    pub name: String,\n-    /// The version of the crate.\n-    pub version: Option<String>,\n-}\n-\n-impl fmt::Show for CrateId {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{}\", self.path));\n-        let version = match self.version {\n-            None => \"0.0\",\n-            Some(ref version) => version.as_slice(),\n-        };\n-        if self.path == self.name ||\n-                self.path\n-                    .as_slice()\n-                    .ends_with(format!(\"/{}\", self.name).as_slice()) {\n-            write!(f, \"#{}\", version)\n-        } else {\n-            write!(f, \"#{}:{}\", self.name, version)\n-        }\n-    }\n-}\n-\n-impl FromStr for CrateId {\n-    fn from_str(s: &str) -> Option<CrateId> {\n-        let pieces: Vec<&str> = s.splitn(1, '#').collect();\n-        let path = pieces.get(0).to_string();\n-\n-        if path.as_slice().starts_with(\"/\") || path.as_slice().ends_with(\"/\") ||\n-            path.as_slice().starts_with(\".\") || path.is_empty() {\n-            return None;\n-        }\n-\n-        let path_pieces: Vec<&str> = path.as_slice()\n-                                         .rsplitn(1, '/')\n-                                         .collect();\n-        let inferred_name = *path_pieces.get(0);\n-\n-        let (name, version) = if pieces.len() == 1 {\n-            (inferred_name.to_string(), None)\n-        } else {\n-            let hash_pieces: Vec<&str> = pieces.get(1)\n-                                               .splitn(1, ':')\n-                                               .collect();\n-            let (hash_name, hash_version) = if hash_pieces.len() == 1 {\n-                (\"\", *hash_pieces.get(0))\n-            } else {\n-                (*hash_pieces.get(0), *hash_pieces.get(1))\n-            };\n-\n-            let name = if !hash_name.is_empty() {\n-                hash_name.to_string()\n-            } else {\n-                inferred_name.to_string()\n-            };\n-\n-            let version = if !hash_version.is_empty() {\n-                if hash_version == \"0.0\" {\n-                    None\n-                } else {\n-                    Some(hash_version.to_string())\n-                }\n-            } else {\n-                None\n-            };\n-\n-            (name, version)\n-        };\n-\n-        Some(CrateId {\n-            path: path.to_string(),\n-            name: name,\n-            version: version,\n-        })\n-    }\n-}\n-\n-impl CrateId {\n-    pub fn version_or_default<'a>(&'a self) -> &'a str {\n-        match self.version {\n-            None => \"0.0\",\n-            Some(ref version) => version.as_slice(),\n-        }\n-    }\n-\n-    pub fn short_name_with_version(&self) -> String {\n-        format!(\"{}-{}\", self.name, self.version_or_default())\n-    }\n-\n-    pub fn matches(&self, other: &CrateId) -> bool {\n-        // FIXME: why does this not match on `path`?\n-        if self.name != other.name { return false }\n-        match (&self.version, &other.version) {\n-            (&Some(ref v1), &Some(ref v2)) => v1 == v2,\n-            _ => true,\n-        }\n-    }\n-}\n-\n-#[test]\n-fn bare_name() {\n-    let crateid: CrateId = from_str(\"foo\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"foo\".to_string());\n-    assert_eq!(crateid.version, None);\n-    assert_eq!(crateid.path, \"foo\".to_string());\n-}\n-\n-#[test]\n-fn bare_name_single_char() {\n-    let crateid: CrateId = from_str(\"f\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"f\".to_string());\n-    assert_eq!(crateid.version, None);\n-    assert_eq!(crateid.path, \"f\".to_string());\n-}\n-\n-#[test]\n-fn empty_crateid() {\n-    let crateid: Option<CrateId> = from_str(\"\");\n-    assert!(crateid.is_none());\n-}\n-\n-#[test]\n-fn simple_path() {\n-    let crateid: CrateId = from_str(\"example.com/foo/bar\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"bar\".to_string());\n-    assert_eq!(crateid.version, None);\n-    assert_eq!(crateid.path, \"example.com/foo/bar\".to_string());\n-}\n-\n-#[test]\n-fn simple_version() {\n-    let crateid: CrateId = from_str(\"foo#1.0\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"foo\".to_string());\n-    assert_eq!(crateid.version, Some(\"1.0\".to_string()));\n-    assert_eq!(crateid.path, \"foo\".to_string());\n-}\n-\n-#[test]\n-fn absolute_path() {\n-    let crateid: Option<CrateId> = from_str(\"/foo/bar\");\n-    assert!(crateid.is_none());\n-}\n-\n-#[test]\n-fn path_ends_with_slash() {\n-    let crateid: Option<CrateId> = from_str(\"foo/bar/\");\n-    assert!(crateid.is_none());\n-}\n-\n-#[test]\n-fn path_and_version() {\n-    let crateid: CrateId = from_str(\"example.com/foo/bar#1.0\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"bar\".to_string());\n-    assert_eq!(crateid.version, Some(\"1.0\".to_string()));\n-    assert_eq!(crateid.path, \"example.com/foo/bar\".to_string());\n-}\n-\n-#[test]\n-fn single_chars() {\n-    let crateid: CrateId = from_str(\"a/b#1\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"b\".to_string());\n-    assert_eq!(crateid.version, Some(\"1\".to_string()));\n-    assert_eq!(crateid.path, \"a/b\".to_string());\n-}\n-\n-#[test]\n-fn missing_version() {\n-    let crateid: CrateId = from_str(\"foo#\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"foo\".to_string());\n-    assert_eq!(crateid.version, None);\n-    assert_eq!(crateid.path, \"foo\".to_string());\n-}\n-\n-#[test]\n-fn path_and_name() {\n-    let crateid: CrateId = from_str(\"foo/rust-bar#bar:1.0\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"bar\".to_string());\n-    assert_eq!(crateid.version, Some(\"1.0\".to_string()));\n-    assert_eq!(crateid.path, \"foo/rust-bar\".to_string());\n-}\n-\n-#[test]\n-fn empty_name() {\n-    let crateid: CrateId = from_str(\"foo/bar#:1.0\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"bar\".to_string());\n-    assert_eq!(crateid.version, Some(\"1.0\".to_string()));\n-    assert_eq!(crateid.path, \"foo/bar\".to_string());\n-}"}, {"sha": "3da1b1f3175f273bda78c6c4d6ec84246ace6d70", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -446,7 +446,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n     if lines.lines.len() == 1u {\n         let lo = cm.lookup_char_pos(sp.lo);\n         let mut digits = 0u;\n-        let mut num = (*lines.lines.get(0) + 1u) / 10u;\n+        let mut num = (lines.lines[0] + 1u) / 10u;\n \n         // how many digits must be indent past?\n         while num > 0u { num /= 10u; digits += 1u; }\n@@ -458,18 +458,18 @@ fn highlight_lines(err: &mut EmitterWriter,\n         // part of the 'filename:line ' part of the previous line.\n         let skip = fm.name.len() + digits + 3u;\n         for _ in range(0, skip) {\n-            s.push_char(' ');\n+            s.push(' ');\n         }\n-        let orig = fm.get_line(*lines.lines.get(0) as int);\n+        let orig = fm.get_line(lines.lines[0] as int);\n         for pos in range(0u, left-skip) {\n             let cur_char = orig.as_bytes()[pos] as char;\n             // Whenever a tab occurs on the previous line, we insert one on\n             // the error-point-squiggly-line as well (instead of a space).\n             // That way the squiggly line will usually appear in the correct\n             // position.\n             match cur_char {\n-                '\\t' => s.push_char('\\t'),\n-                _ => s.push_char(' '),\n+                '\\t' => s.push('\\t'),\n+                _ => s.push(' '),\n             };\n         }\n         try!(write!(&mut err.dst, \"{}\", s));\n@@ -479,7 +479,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n             // the ^ already takes up one space\n             let num_squigglies = hi.col.to_uint()-lo.col.to_uint()-1u;\n             for _ in range(0, num_squigglies) {\n-                s.push_char('~');\n+                s.push('~');\n             }\n         }\n         try!(print_maybe_styled(err,\n@@ -523,10 +523,10 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n     let skip = last_line_start.len() + hi.col.to_uint() - 1;\n     let mut s = String::new();\n     for _ in range(0, skip) {\n-        s.push_char(' ');\n+        s.push(' ');\n     }\n-    s.push_char('^');\n-    s.push_char('\\n');\n+    s.push('^');\n+    s.push('\\n');\n     print_maybe_styled(w,\n                        s.as_slice(),\n                        term::attr::ForegroundColor(lvl.color()))"}, {"sha": "5cc2fe03618c46b25df24d5b333d26340f2771fe", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -495,7 +495,7 @@ impl<'a> ExtCtxt<'a> {\n \n     pub fn new_parser_from_tts(&self, tts: &[ast::TokenTree])\n         -> parser::Parser<'a> {\n-        parse::tts_to_parser(self.parse_sess, Vec::from_slice(tts), self.cfg())\n+        parse::tts_to_parser(self.parse_sess, tts.to_vec(), self.cfg())\n     }\n \n     pub fn codemap(&self) -> &'a CodeMap { &self.parse_sess.span_diagnostic.cm }"}, {"sha": "437efbf96f8589f49d0d0a1f2f86b10709420e40", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -618,7 +618,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                         ident: ast::Ident,\n                         mut args: Vec<P<ast::Expr>> ) -> P<ast::Expr> {\n         let id = Spanned { node: ident, span: span };\n-        args.unshift(expr);\n+        args.insert(0, expr);\n         self.expr(span, ast::ExprMethodCall(id, Vec::new(), args))\n     }\n     fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr> {"}, {"sha": "af7cd4157ecbc75fe67a037a182cdc916a8bfba2", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -35,7 +35,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                         accumulator.push_str(s.get());\n                     }\n                     ast::LitChar(c) => {\n-                        accumulator.push_char(c);\n+                        accumulator.push(c);\n                     }\n                     ast::LitInt(i, ast::UnsignedIntLit(_)) |\n                     ast::LitInt(i, ast::SignedIntLit(_, ast::Plus)) |"}, {"sha": "9748b5313457706587a0aee27f16e59415c6f652", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -80,7 +80,7 @@ fn cs_clone(\n         }\n     }\n \n-    if all_fields.len() >= 1 && all_fields.get(0).name.is_none() {\n+    if all_fields.len() >= 1 && all_fields[0].name.is_none() {\n         // enum-like\n         let subcalls = all_fields.iter().map(subcall).collect();\n         cx.expr_call_ident(trait_span, ctor_ident, subcalls)"}, {"sha": "2310a4460e26883882ffabfc273a480d37545dd3", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -447,10 +447,12 @@ impl<'a> TraitDef<'a> {\n         attr::mark_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n         let ident = ast_util::impl_pretty_name(&opt_trait_ref, &*self_type);\n+        let mut a = vec![attr];\n+        a.extend(self.attributes.iter().map(|a| a.clone()));\n         cx.item(\n             self.span,\n             ident,\n-            (vec!(attr)).append(self.attributes.as_slice()),\n+            a,\n             ast::ItemImpl(trait_generics,\n                           opt_trait_ref,\n                           self_type,\n@@ -943,8 +945,8 @@ impl<'a> MethodDef<'a> {\n                         // of them (using `field_index` tracked above).\n                         // That is the heart of the transposition.\n                         let others = self_pats_idents.iter().map(|fields| {\n-                            let &(_, _opt_ident, ref other_getter_expr) =\n-                                fields.get(field_index);\n+                            let (_, _opt_ident, ref other_getter_expr) =\n+                                fields[field_index];\n \n                             // All Self args have same variant, so\n                             // opt_idents are the same.  (Assert"}, {"sha": "322a84eaa2be0daa3c15f507f3a240aca92226f0", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -80,7 +80,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n         EnumMatching(_, _, ref fields) if fields.len() == 0 => {}\n \n         Struct(ref fields) | EnumMatching(_, _, ref fields) => {\n-            if fields.get(0).name.is_none() {\n+            if fields[0].name.is_none() {\n                 // tuple struct/\"normal\" variant\n \n                 format_string.push_str(\"(\");"}, {"sha": "39b710e0d5725779a8ce1348d5bc1769b730e7c7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -165,7 +165,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n \n             let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n             arms.push(pat_arm);\n-            arms.push_all_move(else_if_arms);\n+            arms.extend(else_if_arms.into_iter());\n             arms.push(else_arm);\n \n             let match_expr = fld.cx.expr(span, ast::ExprMatch(expr, arms, ast::MatchIfLetDesugar));\n@@ -257,7 +257,7 @@ fn expand_mac_invoc<T>(mac: ast::Mac, span: codemap::Span,\n                 // let compilation continue\n                 return None;\n             }\n-            let extname = pth.segments.get(0).identifier;\n+            let extname = pth.segments[0].identifier;\n             let extnamestr = token::get_ident(extname);\n             match fld.cx.syntax_env.find(&extname.name) {\n                 None => {\n@@ -505,7 +505,7 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n             node: MacInvocTT(ref pth, ref tts, _),\n             ..\n         }) => {\n-            (pth.segments.get(0).identifier, pth.span, (*tts).clone())\n+            (pth.segments[0].identifier, pth.span, (*tts).clone())\n         }\n         _ => fld.cx.span_bug(it.span, \"invalid item macro invocation\")\n     };\n@@ -695,7 +695,8 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n                         rename_fld.fold_pat(expanded_pat)\n                     };\n                     // add them to the existing pending renames:\n-                    fld.cx.syntax_env.info().pending_renames.push_all_move(new_pending_renames);\n+                    fld.cx.syntax_env.info().pending_renames\n+                          .extend(new_pending_renames.into_iter());\n                     Local {\n                         id: id,\n                         ty: expanded_ty,\n@@ -744,7 +745,7 @@ fn expand_arm(arm: ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n     }\n     // all of the pats must have the same set of bindings, so use the\n     // first one to extract them and generate new names:\n-    let idents = pattern_bindings(&**expanded_pats.get(0));\n+    let idents = pattern_bindings(&*expanded_pats[0]);\n     let new_renames = idents.into_iter().map(|id| (id, fresh_name(&id))).collect();\n     // apply the renaming, but only to the PatIdents:\n     let mut rename_pats_fld = PatIdentRenamer{renames:&new_renames};\n@@ -860,7 +861,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n             fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n             return DummyResult::raw_pat(span);\n         }\n-        let extname = pth.segments.get(0).identifier;\n+        let extname = pth.segments[0].identifier;\n         let extnamestr = token::get_ident(extname);\n         let marked_after = match fld.cx.syntax_env.find(&extname.name) {\n             None => {\n@@ -1022,7 +1023,7 @@ fn expand_method(m: P<ast::Method>, fld: &mut MacroExpander) -> SmallVector<P<as\n             };\n \n             // expand again if necessary\n-            let new_methods = new_methods.move_iter()\n+            let new_methods = new_methods.into_iter()\n                                   .flat_map(|m| fld.fold_method(m).into_iter()).collect();\n             fld.cx.bt_pop();\n             new_methods\n@@ -1610,8 +1611,8 @@ mod test {\n         // must be one check clause for each binding:\n         assert_eq!(bindings.len(),bound_connections.len());\n         for (binding_idx,shouldmatch) in bound_connections.iter().enumerate() {\n-            let binding_name = mtwt::resolve(*bindings.get(binding_idx));\n-            let binding_marks = mtwt::marksof(bindings.get(binding_idx).ctxt, invalid_name);\n+            let binding_name = mtwt::resolve(bindings[binding_idx]);\n+            let binding_marks = mtwt::marksof(bindings[binding_idx].ctxt, invalid_name);\n             // shouldmatch can't name varrefs that don't exist:\n             assert!((shouldmatch.len() == 0) ||\n                     (varrefs.len() > *shouldmatch.iter().max().unwrap()));\n@@ -1630,16 +1631,15 @@ mod test {\n                     let string = token::get_ident(final_varref_ident);\n                     println!(\"varref's first segment's string: \\\"{}\\\"\", string.get());\n                     println!(\"binding #{}: {}, resolves to {}\",\n-                             binding_idx, *bindings.get(binding_idx), binding_name);\n+                             binding_idx, bindings[binding_idx], binding_name);\n                     mtwt::with_sctable(|x| mtwt::display_sctable(x));\n                 };\n                 if shouldmatch.contains(&idx) {\n                     // it should be a path of length 1, and it should\n                     // be free-identifier=? or bound-identifier=? to the given binding\n                     assert_eq!(varref.segments.len(),1);\n-                    let varref_name = mtwt::resolve(varref.segments.get(0).identifier);\n-                    let varref_marks = mtwt::marksof(varref.segments\n-                                                           .get(0)\n+                    let varref_name = mtwt::resolve(varref.segments[0].identifier);\n+                    let varref_marks = mtwt::marksof(varref.segments[0]\n                                                            .identifier\n                                                            .ctxt,\n                                                      invalid_name);\n@@ -1654,7 +1654,7 @@ mod test {\n                         assert_eq!(varref_marks,binding_marks.clone());\n                     }\n                 } else {\n-                    let varref_name = mtwt::resolve(varref.segments.get(0).identifier);\n+                    let varref_name = mtwt::resolve(varref.segments[0].identifier);\n                     let fail = (varref.segments.len() == 1)\n                         && (varref_name == binding_name);\n                     // temp debugging:\n@@ -1696,19 +1696,19 @@ foo_module!()\n         // the xx binding should bind all of the xx varrefs:\n         for (idx,v) in varrefs.iter().filter(|p| {\n             p.segments.len() == 1\n-            && \"xx\" == token::get_ident(p.segments.get(0).identifier).get()\n+            && \"xx\" == token::get_ident(p.segments[0].identifier).get()\n         }).enumerate() {\n-            if mtwt::resolve(v.segments.get(0).identifier) != resolved_binding {\n+            if mtwt::resolve(v.segments[0].identifier) != resolved_binding {\n                 println!(\"uh oh, xx binding didn't match xx varref:\");\n                 println!(\"this is xx varref \\\\# {}\", idx);\n                 println!(\"binding: {}\", cxbind);\n                 println!(\"resolves to: {}\", resolved_binding);\n-                println!(\"varref: {}\", v.segments.get(0).identifier);\n+                println!(\"varref: {}\", v.segments[0].identifier);\n                 println!(\"resolves to: {}\",\n-                         mtwt::resolve(v.segments.get(0).identifier));\n+                         mtwt::resolve(v.segments[0].identifier));\n                 mtwt::with_sctable(|x| mtwt::display_sctable(x));\n             }\n-            assert_eq!(mtwt::resolve(v.segments.get(0).identifier),\n+            assert_eq!(mtwt::resolve(v.segments[0].identifier),\n                        resolved_binding);\n         };\n     }"}, {"sha": "87cd61c9b223718a9b9c418a1456ea4aeb1c75db", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -241,13 +241,13 @@ impl<'a, 'b> Context<'a, 'b> {\n                     return;\n                 }\n                 {\n-                    let arg_type = match self.arg_types.get(arg) {\n-                        &None => None,\n-                        &Some(ref x) => Some(x)\n+                    let arg_type = match self.arg_types[arg] {\n+                        None => None,\n+                        Some(ref x) => Some(x)\n                     };\n-                    self.verify_same(self.args.get(arg).span, &ty, arg_type);\n+                    self.verify_same(self.args[arg].span, &ty, arg_type);\n                 }\n-                if self.arg_types.get(arg).is_none() {\n+                if self.arg_types[arg].is_none() {\n                     *self.arg_types.get_mut(arg) = Some(ty);\n                 }\n             }\n@@ -544,7 +544,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         // of each variable because we don't want to move out of the arguments\n         // passed to this function.\n         for (i, e) in self.args.into_iter().enumerate() {\n-            let arg_ty = match self.arg_types.get(i).as_ref() {\n+            let arg_ty = match self.arg_types[i].as_ref() {\n                 Some(ty) => ty,\n                 None => continue // error already generated\n             };\n@@ -568,7 +568,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             let lname = self.ecx.ident_of(format!(\"__arg{}\",\n                                                   *name).as_slice());\n             pats.push(self.ecx.pat_ident(e.span, lname));\n-            *names.get_mut(*self.name_positions.get(name)) =\n+            *names.get_mut(self.name_positions[*name]) =\n                 Some(Context::format_arg(self.ecx, e.span, arg_ty,\n                                          self.ecx.expr_ident(e.span, lname)));\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n@@ -787,7 +787,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n             None => break\n         }\n     }\n-    match parser.errors.shift() {\n+    match parser.errors.remove(0) {\n         Some(error) => {\n             cx.ecx.span_err(cx.fmtsp,\n                             format!(\"invalid format string: {}\",\n@@ -804,7 +804,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     // Make sure that all arguments were used and all arguments have types.\n     for (i, ty) in cx.arg_types.iter().enumerate() {\n         if ty.is_none() {\n-            cx.ecx.span_err(cx.args.get(i).span, \"argument never used\");\n+            cx.ecx.span_err(cx.args[i].span, \"argument never used\");\n         }\n     }\n     for (name, e) in cx.names.iter() {"}, {"sha": "b4f8b9f82284980335fca8de2552bb61e951eac0", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -188,7 +188,7 @@ fn resolve_internal(id: Ident,\n     }\n \n     let resolved = {\n-        let result = *table.table.borrow().get(id.ctxt as uint);\n+        let result = (*table.table.borrow())[id.ctxt as uint];\n         match result {\n             EmptyCtxt => id.name,\n             // ignore marks here:\n@@ -232,7 +232,7 @@ fn marksof_internal(ctxt: SyntaxContext,\n     let mut result = Vec::new();\n     let mut loopvar = ctxt;\n     loop {\n-        let table_entry = *table.table.borrow().get(loopvar as uint);\n+        let table_entry = (*table.table.borrow())[loopvar as uint];\n         match table_entry {\n             EmptyCtxt => {\n                 return result;\n@@ -259,7 +259,7 @@ fn marksof_internal(ctxt: SyntaxContext,\n /// FAILS when outside is not a mark.\n pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n     with_sctable(|sctable| {\n-        match *sctable.table.borrow().get(ctxt as uint) {\n+        match (*sctable.table.borrow())[ctxt as uint] {\n             Mark(mrk, _) => mrk,\n             _ => fail!(\"can't retrieve outer mark when outside is not a mark\")\n         }\n@@ -330,7 +330,7 @@ mod tests {\n         let mut result = Vec::new();\n         loop {\n             let table = table.table.borrow();\n-            match *table.get(sc as uint) {\n+            match (*table)[sc as uint] {\n                 EmptyCtxt => {return result;},\n                 Mark(mrk,tail) => {\n                     result.push(M(mrk));\n@@ -355,9 +355,9 @@ mod tests {\n         assert_eq!(unfold_test_sc(test_sc.clone(),EMPTY_CTXT,&mut t),4);\n         {\n             let table = t.table.borrow();\n-            assert!(*table.get(2) == Mark(9,0));\n-            assert!(*table.get(3) == Rename(id(101,0),Name(14),2));\n-            assert!(*table.get(4) == Mark(3,3));\n+            assert!((*table)[2] == Mark(9,0));\n+            assert!((*table)[3] == Rename(id(101,0),Name(14),2));\n+            assert!((*table)[4] == Mark(3,3));\n         }\n         assert_eq!(refold_test_sc(4,&t),test_sc);\n     }\n@@ -376,8 +376,8 @@ mod tests {\n         assert_eq!(unfold_marks(vec!(3,7),EMPTY_CTXT,&mut t),3);\n         {\n             let table = t.table.borrow();\n-            assert!(*table.get(2) == Mark(7,0));\n-            assert!(*table.get(3) == Mark(3,2));\n+            assert!((*table)[2] == Mark(7,0));\n+            assert!((*table)[3] == Mark(3,2));\n         }\n     }\n "}, {"sha": "84775c12d641f7570ea422534afa7d76930a6f68", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -657,18 +657,20 @@ fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n \n         ast::TTNonterminal(sp, ident) => {\n \n-            // tt.push_all_move($ident.to_tokens(ext_cx))\n+            // tt.extend($ident.to_tokens(ext_cx).into_iter())\n \n             let e_to_toks =\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, ident),\n                                     id_ext(\"to_tokens\"),\n                                     vec!(cx.expr_ident(sp, id_ext(\"ext_cx\"))));\n+            let e_to_toks =\n+                cx.expr_method_call(sp, e_to_toks, id_ext(\"into_iter\"), vec![]);\n \n             let e_push =\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, id_ext(\"tt\")),\n-                                    id_ext(\"push_all_move\"),\n+                                    id_ext(\"extend\"),\n                                     vec!(e_to_toks));\n \n             vec!(cx.stmt_expr(e_push))\n@@ -680,7 +682,7 @@ fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> Vec<P<ast::Stmt>> {\n     let mut ss = Vec::new();\n     for tt in tts.iter() {\n-        ss.push_all_move(mk_tt(cx, sp, tt));\n+        ss.extend(mk_tt(cx, sp, tt).into_iter());\n     }\n     ss\n }\n@@ -742,7 +744,7 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let stmt_let_tt = cx.stmt_let(sp, true, id_ext(\"tt\"), cx.expr_vec_ng(sp));\n \n     let mut vector = vec!(stmt_let_sp, stmt_let_tt);\n-    vector.push_all_move(mk_tts(cx, sp, tts.as_slice()));\n+    vector.extend(mk_tts(cx, sp, tts.as_slice()).into_iter());\n     let block = cx.expr_block(\n         cx.block_all(sp,\n                      Vec::new(),"}, {"sha": "78fcd729aae1008223b17c4471a4e2b54d982723", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -286,7 +286,7 @@ pub fn parse(sess: &ParseSess,\n \n                         // Only touch the binders we have actually bound\n                         for idx in range(ei.match_lo, ei.match_hi) {\n-                            let sub = (*ei.matches.get(idx)).clone();\n+                            let sub = (ei.matches[idx]).clone();\n                             new_pos.matches\n                                    .get_mut(idx)\n                                    .push(Rc::new(MatchedSeq(sub, mk_sp(ei.sp_lo,\n@@ -321,7 +321,7 @@ pub fn parse(sess: &ParseSess,\n                     eof_eis.push(ei);\n                 }\n             } else {\n-                match ei.elts.get(idx).node.clone() {\n+                match ei.elts[idx].node.clone() {\n                   /* need to descend into sequence */\n                   MatchSeq(ref matchers, ref sep, zero_ok,\n                            match_idx_lo, match_idx_hi) => {\n@@ -388,7 +388,7 @@ pub fn parse(sess: &ParseSess,\n             if (bb_eis.len() > 0u && next_eis.len() > 0u)\n                 || bb_eis.len() > 1u {\n                 let nts = bb_eis.iter().map(|ei| {\n-                    match ei.elts.get(ei.idx).node {\n+                    match ei.elts[ei.idx].node {\n                       MatchNonterminal(bind, name, _) => {\n                         (format!(\"{} ('{}')\",\n                                 token::get_ident(name),\n@@ -413,7 +413,7 @@ pub fn parse(sess: &ParseSess,\n                 let mut rust_parser = Parser::new(sess, cfg.clone(), box rdr.clone());\n \n                 let mut ei = bb_eis.pop().unwrap();\n-                match ei.elts.get(ei.idx).node {\n+                match ei.elts[ei.idx].node {\n                   MatchNonterminal(_, name, idx) => {\n                     let name_string = token::get_ident(name);\n                     ei.matches.get_mut(idx).push(Rc::new(MatchedNonterminal("}, {"sha": "91db3a9d8df50a6b6200a16fb49b894fbb812a6b", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -255,12 +255,12 @@ pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n                                      argument_gram);\n \n     // Extract the arguments:\n-    let lhses = match **argument_map.get(&lhs_nm) {\n+    let lhses = match *argument_map[lhs_nm] {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n         _ => cx.span_bug(sp, \"wrong-structured lhs\")\n     };\n \n-    let rhses = match **argument_map.get(&rhs_nm) {\n+    let rhses = match *argument_map[rhs_nm] {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n         _ => cx.span_bug(sp, \"wrong-structured rhs\")\n     };"}, {"sha": "35ec37d842af1c6e56aeb703a249bdd96c505590", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -79,7 +79,7 @@ fn lookup_cur_matched_by_matched(r: &TtReader, start: Rc<NamedMatch>) -> Rc<Name\n                 // end of the line; duplicate henceforth\n                 ad.clone()\n             }\n-            MatchedSeq(ref ads, _) => ads.get(*idx).clone()\n+            MatchedSeq(ref ads, _) => ads[*idx].clone()\n         }\n     })\n }\n@@ -194,7 +194,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n         let t = {\n             let frame = r.stack.last().unwrap();\n             // FIXME(pcwalton): Bad copy.\n-            (*frame.forest.get(frame.idx)).clone()\n+            (*frame.forest)[frame.idx].clone()\n         };\n         match t {\n             TTDelim(tts) => {"}, {"sha": "5e29167bf1a293ecbe1b988970a23c838b5eac08", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -22,9 +22,10 @@ use ast::*;\n use ast;\n use ast_util;\n use codemap::{respan, Span, Spanned};\n+use owned_slice::OwnedSlice;\n use parse::token;\n use ptr::P;\n-use owned_slice::OwnedSlice;\n+use std::ptr;\n use util::small_vector::SmallVector;\n \n use std::rc::Rc;\n@@ -36,11 +37,10 @@ pub trait MoveMap<T> {\n \n impl<T> MoveMap<T> for Vec<T> {\n     fn move_map(mut self, f: |T| -> T) -> Vec<T> {\n-        use std::{mem, ptr};\n         for p in self.iter_mut() {\n             unsafe {\n                 // FIXME(#5016) this shouldn't need to zero to be safe.\n-                mem::move_val_init(p, f(ptr::read_and_zero(p)));\n+                ptr::write(p, f(ptr::read_and_zero(p)));\n             }\n         }\n         self\n@@ -935,7 +935,7 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n                 match *impl_item {\n                     MethodImplItem(ref x) => {\n                         for method in folder.fold_method((*x).clone())\n-                                            .move_iter() {\n+                                            .into_iter() {\n                             new_impl_items.push(MethodImplItem(method))\n                         }\n                     }\n@@ -963,23 +963,23 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n                     RequiredMethod(m) => {\n                             SmallVector::one(RequiredMethod(\n                                     folder.fold_type_method(m)))\n-                                .move_iter()\n+                                .into_iter()\n                     }\n                     ProvidedMethod(method) => {\n                         // the awkward collect/iter idiom here is because\n                         // even though an iter and a map satisfy the same\n                         // trait bound, they're not actually the same type, so\n                         // the method arms don't unify.\n                         let methods: SmallVector<ast::TraitItem> =\n-                            folder.fold_method(method).move_iter()\n+                            folder.fold_method(method).into_iter()\n                             .map(|m| ProvidedMethod(m)).collect();\n-                        methods.move_iter()\n+                        methods.into_iter()\n                     }\n                     TypeTraitItem(at) => {\n                         SmallVector::one(TypeTraitItem(P(\n                                     folder.fold_associated_type(\n                                         (*at).clone()))))\n-                            .move_iter()\n+                            .into_iter()\n                     }\n                 };\n                 r"}, {"sha": "4881be8996a8b5b8c892c465c48c3802c36d068b", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -26,7 +26,6 @@\n #![allow(unknown_features)]\n #![feature(macro_rules, globs, default_type_params, phase, slicing_syntax)]\n #![feature(quote, struct_variant, unsafe_destructor, import_shadowing)]\n-#![allow(deprecated)]\n \n extern crate arena;\n extern crate fmt_macros;\n@@ -61,7 +60,6 @@ pub mod ast_util;\n pub mod attr;\n pub mod codemap;\n pub mod config;\n-pub mod crateid;\n pub mod diagnostic;\n pub mod feature_gate;\n pub mod fold;"}, {"sha": "e5c37e5041abf43a984c2716fdc56d8c5bcdfe25", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -122,7 +122,7 @@ impl<T> Default for OwnedSlice<T> {\n \n impl<T: Clone> Clone for OwnedSlice<T> {\n     fn clone(&self) -> OwnedSlice<T> {\n-        OwnedSlice::from_vec(Vec::from_slice(self.as_slice()))\n+        OwnedSlice::from_vec(self.as_slice().to_vec())\n     }\n }\n "}, {"sha": "551d15048f10940aad35a62d3b68d10b62dd2695", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -64,21 +64,21 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n         let mut j = lines.len();\n         // first line of all-stars should be omitted\n         if lines.len() > 0 &&\n-                lines.get(0).as_slice().chars().all(|c| c == '*') {\n+                lines[0].as_slice().chars().all(|c| c == '*') {\n             i += 1;\n         }\n-        while i < j && lines.get(i).as_slice().trim().is_empty() {\n+        while i < j && lines[i].as_slice().trim().is_empty() {\n             i += 1;\n         }\n         // like the first, a last line of all stars should be omitted\n-        if j > i && lines.get(j - 1)\n+        if j > i && lines[j - 1]\n                          .as_slice()\n                          .chars()\n                          .skip(1)\n                          .all(|c| c == '*') {\n             j -= 1;\n         }\n-        while j > i && lines.get(j - 1).as_slice().trim().is_empty() {\n+        while j > i && lines[j - 1].as_slice().trim().is_empty() {\n             j -= 1;\n         }\n         return lines.slice(i, j).iter().map(|x| (*x).clone()).collect();\n@@ -252,7 +252,7 @@ fn read_block_comment(rdr: &mut StringReader,\n     // doc-comments are not really comments, they are attributes\n     if (rdr.curr_is('*') && !rdr.nextch_is('*')) || rdr.curr_is('!') {\n         while !(rdr.curr_is('*') && rdr.nextch_is('/')) && !rdr.is_eof() {\n-            curr_line.push_char(rdr.curr.unwrap());\n+            curr_line.push(rdr.curr.unwrap());\n             rdr.bump();\n         }\n         if !rdr.is_eof() {\n@@ -279,17 +279,17 @@ fn read_block_comment(rdr: &mut StringReader,\n                 curr_line = String::new();\n                 rdr.bump();\n             } else {\n-                curr_line.push_char(rdr.curr.unwrap());\n+                curr_line.push(rdr.curr.unwrap());\n                 if rdr.curr_is('/') && rdr.nextch_is('*') {\n                     rdr.bump();\n                     rdr.bump();\n-                    curr_line.push_char('*');\n+                    curr_line.push('*');\n                     level += 1;\n                 } else {\n                     if rdr.curr_is('*') && rdr.nextch_is('/') {\n                         rdr.bump();\n                         rdr.bump();\n-                        curr_line.push_char('/');\n+                        curr_line.push('/');\n                         level -= 1;\n                     } else { rdr.bump(); }\n                 }"}, {"sha": "55d071b8d6005151707bf60e461ca0ea64763cef", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -180,7 +180,7 @@ impl<'a> StringReader<'a> {\n     fn fatal_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) -> ! {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n-        char::escape_default(c, |c| m.push_char(c));\n+        char::escape_default(c, |c| m.push(c));\n         self.fatal_span_(from_pos, to_pos, m.as_slice());\n     }\n \n@@ -189,7 +189,7 @@ impl<'a> StringReader<'a> {\n     fn err_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n-        char::escape_default(c, |c| m.push_char(c));\n+        char::escape_default(c, |c| m.push(c));\n         self.err_span_(from_pos, to_pos, m.as_slice());\n     }\n \n@@ -1227,7 +1227,7 @@ impl<'a> StringReader<'a> {\n     fn read_to_eol(&mut self) -> String {\n         let mut val = String::new();\n         while !self.curr_is('\\n') && !self.is_eof() {\n-            val.push_char(self.curr.unwrap());\n+            val.push(self.curr.unwrap());\n             self.bump();\n         }\n         if self.curr_is('\\n') { self.bump(); }"}, {"sha": "f1baccfcd80204af2edc87c849e4e20a3f0e5c6c", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -455,7 +455,7 @@ pub fn str_lit(lit: &str) -> String {\n                             for _ in range(0, n - 1) { // we don't need to move past the first \\\n                                 chars.next();\n                             }\n-                            res.push_char(c);\n+                            res.push(c);\n                         }\n                     },\n                     '\\r' => {\n@@ -467,9 +467,9 @@ pub fn str_lit(lit: &str) -> String {\n                             fail!(\"lexer accepted bare CR\");\n                         }\n                         chars.next();\n-                        res.push_char('\\n');\n+                        res.push('\\n');\n                     }\n-                    c => res.push_char(c),\n+                    c => res.push(c),\n                 }\n             },\n             None => break\n@@ -497,9 +497,9 @@ pub fn raw_str_lit(lit: &str) -> String {\n                         fail!(\"lexer accepted bare CR\");\n                     }\n                     chars.next();\n-                    res.push_char('\\n');\n+                    res.push('\\n');\n                 } else {\n-                    res.push_char(c);\n+                    res.push(c);\n                 }\n             },\n             None => break"}, {"sha": "abab816bfeb96036c50a893f9236733a64e60d5b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -281,12 +281,13 @@ macro_rules! maybe_whole (\n )\n \n \n-fn maybe_append(lhs: Vec<Attribute> , rhs: Option<Vec<Attribute> >)\n-             -> Vec<Attribute> {\n+fn maybe_append(mut lhs: Vec<Attribute>, rhs: Option<Vec<Attribute>>)\n+                -> Vec<Attribute> {\n     match rhs {\n-        None => lhs,\n-        Some(ref attrs) => lhs.append(attrs.as_slice())\n+        Some(ref attrs) => lhs.extend(attrs.iter().map(|a| a.clone())),\n+        None => {}\n     }\n+    lhs\n }\n \n \n@@ -452,7 +453,8 @@ impl<'a> Parser<'a> {\n         } else if inedible.contains(&self.token) {\n             // leave it in the input\n         } else {\n-            let expected = edible.iter().map(|x| (*x).clone()).collect::<Vec<_>>().append(inedible);\n+            let mut expected = edible.iter().map(|x| x.clone()).collect::<Vec<_>>();\n+            expected.push_all(inedible);\n             let expect = tokens_to_string(expected.as_slice());\n             let actual = self.this_token_to_string();\n             self.fatal(\n@@ -496,8 +498,8 @@ impl<'a> Parser<'a> {\n         match e.node {\n             ExprPath(..) => {\n                 // might be unit-struct construction; check for recoverableinput error.\n-                let expected = edible.iter().map(|x| (*x).clone()).collect::<Vec<_>>()\n-                              .append(inedible);\n+                let mut expected = edible.iter().map(|x| x.clone()).collect::<Vec<_>>();\n+                expected.push_all(inedible);\n                 self.check_for_erroneous_unit_struct_expecting(\n                     expected.as_slice());\n             }\n@@ -517,8 +519,8 @@ impl<'a> Parser<'a> {\n         if self.last_token\n                .as_ref()\n                .map_or(false, |t| is_ident_or_path(&**t)) {\n-            let expected = edible.iter().map(|x| (*x).clone()).collect::<Vec<_>>()\n-                           .append(inedible.as_slice());\n+            let mut expected = edible.iter().map(|x| x.clone()).collect::<Vec<_>>();\n+            expected.push_all(inedible.as_slice());\n             self.check_for_erroneous_unit_struct_expecting(\n                 expected.as_slice());\n         }\n@@ -1335,7 +1337,8 @@ impl<'a> Parser<'a> {\n                     debug!(\"parse_trait_methods(): parsing provided method\");\n                     let (inner_attrs, body) =\n                         p.parse_inner_attrs_and_block();\n-                    let attrs = attrs.append(inner_attrs.as_slice());\n+                    let mut attrs = attrs;\n+                    attrs.push_all(inner_attrs.as_slice());\n                     ProvidedMethod(P(ast::Method {\n                         attrs: attrs,\n                         id: ast::DUMMY_NODE_ID,\n@@ -2119,7 +2122,7 @@ impl<'a> Parser<'a> {\n                             |p| p.parse_expr()\n                                 );\n                         let mut exprs = vec!(first_expr);\n-                        exprs.push_all_move(remaining_exprs);\n+                        exprs.extend(remaining_exprs.into_iter());\n                         ex = ExprVec(exprs);\n                     } else {\n                         // Vector with one element.\n@@ -2337,7 +2340,7 @@ impl<'a> Parser<'a> {\n                             );\n                             hi = self.last_span.hi;\n \n-                            es.unshift(e);\n+                            es.insert(0, e);\n                             let id = spanned(dot, hi, i);\n                             let nd = self.mk_method_call(id, tys, es);\n                             e = self.mk_expr(lo, hi, nd);\n@@ -2600,7 +2603,7 @@ impl<'a> Parser<'a> {\n                     self.parse_seq_to_before_end(&close_delim,\n                                                  seq_sep_none(),\n                                                  |p| p.parse_token_tree());\n-                result.push_all_move(trees);\n+                result.extend(trees.into_iter());\n \n                 // Parse the close delimiter.\n                 result.push(parse_any_tt_tok(self));\n@@ -3380,12 +3383,10 @@ impl<'a> Parser<'a> {\n                           _ => {\n                               if !enum_path.global &&\n                                     enum_path.segments.len() == 1 &&\n-                                    enum_path.segments\n-                                             .get(0)\n+                                    enum_path.segments[0]\n                                              .lifetimes\n                                              .len() == 0 &&\n-                                    enum_path.segments\n-                                             .get(0)\n+                                    enum_path.segments[0]\n                                              .types\n                                              .len() == 0 {\n                                   // it could still be either an enum\n@@ -3394,7 +3395,7 @@ impl<'a> Parser<'a> {\n                                   pat = PatIdent(BindByValue(MutImmutable),\n                                                  codemap::Spanned{\n                                                     span: enum_path.span,\n-                                                    node: enum_path.segments.get(0)\n+                                                    node: enum_path.segments[0]\n                                                            .identifier},\n                                                  None);\n                               } else {\n@@ -4256,7 +4257,7 @@ impl<'a> Parser<'a> {\n                         sep,\n                         parse_arg_fn\n                     );\n-                    fn_inputs.unshift(Arg::new_self(explicit_self_sp, mutbl_self, $self_id));\n+                    fn_inputs.insert(0, Arg::new_self(explicit_self_sp, mutbl_self, $self_id));\n                     fn_inputs\n                 }\n                 token::RPAREN => {\n@@ -4449,7 +4450,8 @@ impl<'a> Parser<'a> {\n                 self.parse_where_clause(&mut generics);\n                 let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n                 let body_span = body.span;\n-                let new_attrs = attrs.append(inner_attrs.as_slice());\n+                let mut new_attrs = attrs;\n+                new_attrs.push_all(inner_attrs.as_slice());\n                 (ast::MethDecl(ident,\n                                generics,\n                                abi,\n@@ -4490,7 +4492,7 @@ impl<'a> Parser<'a> {\n         let (inner_attrs, mut method_attrs) =\n             self.parse_inner_attrs_and_next();\n         while !self.eat(&token::RBRACE) {\n-            method_attrs.push_all_move(self.parse_outer_attributes());\n+            method_attrs.extend(self.parse_outer_attributes().into_iter());\n             let vis = self.parse_visibility();\n             if self.eat_keyword(keywords::Type) {\n                 impl_items.push(TypeImplItem(P(self.parse_typedef(\n@@ -4711,7 +4713,9 @@ impl<'a> Parser<'a> {\n         while self.token != term {\n             let mut attrs = self.parse_outer_attributes();\n             if first {\n-                attrs = attrs_remaining.clone().append(attrs.as_slice());\n+                let mut tmp = attrs_remaining.clone();\n+                tmp.push_all(attrs.as_slice());\n+                attrs = tmp;\n                 first = false;\n             }\n             debug!(\"parse_mod_items: parse_item_or_view_item(attrs={})\",\n@@ -4826,7 +4830,7 @@ impl<'a> Parser<'a> {\n                                   \"cannot declare a new module at this location\");\n                     let this_module = match self.mod_path_stack.last() {\n                         Some(name) => name.get().to_string(),\n-                        None => self.root_module_name.get_ref().clone(),\n+                        None => self.root_module_name.as_ref().unwrap().clone(),\n                     };\n                     self.span_note(id_sp,\n                                    format!(\"maybe move this module `{0}` \\\n@@ -5536,7 +5540,7 @@ impl<'a> Parser<'a> {\n             } else {\n                 s.push_str(\"priv\")\n             }\n-            s.push_char('`');\n+            s.push('`');\n             let last_span = self.last_span;\n             self.span_fatal(last_span, s.as_slice());\n         }\n@@ -5677,7 +5681,7 @@ impl<'a> Parser<'a> {\n           }\n           _ => ()\n         }\n-        let mut rename_to = *path.get(path.len() - 1u);\n+        let mut rename_to = path[path.len() - 1u];\n         let path = ast::Path {\n             span: mk_sp(lo, self.span.hi),\n             global: false,\n@@ -5705,7 +5709,8 @@ impl<'a> Parser<'a> {\n                                   mut extern_mod_allowed: bool,\n                                   macros_allowed: bool)\n                                   -> ParsedItemsAndViewItems {\n-        let mut attrs = first_item_attrs.append(self.parse_outer_attributes().as_slice());\n+        let mut attrs = first_item_attrs;\n+        attrs.push_all(self.parse_outer_attributes().as_slice());\n         // First, parse view items.\n         let mut view_items : Vec<ast::ViewItem> = Vec::new();\n         let mut items = Vec::new();\n@@ -5786,7 +5791,8 @@ impl<'a> Parser<'a> {\n     fn parse_foreign_items(&mut self, first_item_attrs: Vec<Attribute> ,\n                            macros_allowed: bool)\n         -> ParsedItemsAndViewItems {\n-        let mut attrs = first_item_attrs.append(self.parse_outer_attributes().as_slice());\n+        let mut attrs = first_item_attrs;\n+        attrs.push_all(self.parse_outer_attributes().as_slice());\n         let mut foreign_items = Vec::new();\n         loop {\n             match self.parse_foreign_item(attrs, macros_allowed) {"}, {"sha": "65efd4f00425b744f43ea8dc47226ee545aee653", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -134,12 +134,12 @@ pub fn buf_str(toks: Vec<Token>,\n             s.push_str(\", \");\n         }\n         s.push_str(format!(\"{}={}\",\n-                           szs.get(i),\n-                           tok_str(toks.get(i).clone())).as_slice());\n+                           szs[i],\n+                           tok_str(toks[i].clone())).as_slice());\n         i += 1u;\n         i %= n;\n     }\n-    s.push_char(']');\n+    s.push(']');\n     return s.into_string();\n }\n \n@@ -299,7 +299,7 @@ pub struct Printer {\n \n impl Printer {\n     pub fn last_token(&mut self) -> Token {\n-        (*self.token.get(self.right)).clone()\n+        self.token[self.right].clone()\n     }\n     // be very careful with this!\n     pub fn replace_last_token(&mut self, t: Token) {\n@@ -311,8 +311,8 @@ impl Printer {\n           Eof => {\n             if !self.scan_stack_empty {\n                 self.check_stack(0);\n-                let left = (*self.token.get(self.left)).clone();\n-                let left_size = *self.size.get(self.left);\n+                let left = self.token[self.left].clone();\n+                let left_size = self.size[self.left];\n                 try!(self.advance_left(left, left_size));\n             }\n             self.indent(0);\n@@ -388,14 +388,14 @@ impl Printer {\n             debug!(\"scan window is {}, longer than space on line ({})\",\n                    self.right_total - self.left_total, self.space);\n             if !self.scan_stack_empty {\n-                if self.left == *self.scan_stack.get(self.bottom) {\n+                if self.left == self.scan_stack[self.bottom] {\n                     debug!(\"setting {} to infinity and popping\", self.left);\n                     let scanned = self.scan_pop_bottom();\n                     *self.size.get_mut(scanned) = SIZE_INFINITY;\n                 }\n             }\n-            let left = (*self.token.get(self.left)).clone();\n-            let left_size = *self.size.get(self.left);\n+            let left = self.token[self.left].clone();\n+            let left_size = self.size[self.left];\n             try!(self.advance_left(left, left_size));\n             if self.left != self.right {\n                 try!(self.check_stream());\n@@ -416,7 +416,7 @@ impl Printer {\n     }\n     pub fn scan_pop(&mut self) -> uint {\n         assert!((!self.scan_stack_empty));\n-        let x = *self.scan_stack.get(self.top);\n+        let x = self.scan_stack[self.top];\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n         } else {\n@@ -426,11 +426,11 @@ impl Printer {\n     }\n     pub fn scan_top(&mut self) -> uint {\n         assert!((!self.scan_stack_empty));\n-        return *self.scan_stack.get(self.top);\n+        return self.scan_stack[self.top];\n     }\n     pub fn scan_pop_bottom(&mut self) -> uint {\n         assert!((!self.scan_stack_empty));\n-        let x = *self.scan_stack.get(self.bottom);\n+        let x = self.scan_stack[self.bottom];\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n         } else {\n@@ -458,8 +458,8 @@ impl Printer {\n             if self.left != self.right {\n                 self.left += 1u;\n                 self.left %= self.buf_len;\n-                let left = (*self.token.get(self.left)).clone();\n-                let left_size = *self.size.get(self.left);\n+                let left = self.token[self.left].clone();\n+                let left_size = self.size[self.left];\n                 try!(self.advance_left(left, left_size));\n             }\n             ret\n@@ -470,29 +470,28 @@ impl Printer {\n     pub fn check_stack(&mut self, k: int) {\n         if !self.scan_stack_empty {\n             let x = self.scan_top();\n-            match self.token.get(x) {\n-              &Begin(_) => {\n-                if k > 0 {\n+            match self.token[x] {\n+                Begin(_) => {\n+                    if k > 0 {\n+                        let popped = self.scan_pop();\n+                        *self.size.get_mut(popped) = self.size[x] +\n+                            self.right_total;\n+                        self.check_stack(k - 1);\n+                    }\n+                }\n+                End => {\n+                    // paper says + not =, but that makes no sense.\n                     let popped = self.scan_pop();\n-                    *self.size.get_mut(popped) = *self.size.get(x) +\n-                        self.right_total;\n-                    self.check_stack(k - 1);\n+                    *self.size.get_mut(popped) = 1;\n+                    self.check_stack(k + 1);\n                 }\n-              }\n-              &End => {\n-                // paper says + not =, but that makes no sense.\n-                let popped = self.scan_pop();\n-                *self.size.get_mut(popped) = 1;\n-                self.check_stack(k + 1);\n-              }\n-              _ => {\n-                let popped = self.scan_pop();\n-                *self.size.get_mut(popped) = *self.size.get(x) +\n-                    self.right_total;\n-                if k > 0 {\n-                    self.check_stack(k);\n+                _ => {\n+                    let popped = self.scan_pop();\n+                    *self.size.get_mut(popped) = self.size[x] + self.right_total;\n+                    if k > 0 {\n+                        self.check_stack(k);\n+                    }\n                 }\n-              }\n             }\n         }\n     }\n@@ -511,7 +510,7 @@ impl Printer {\n         let print_stack = &mut self.print_stack;\n         let n = print_stack.len();\n         if n != 0u {\n-            *print_stack.get(n - 1u)\n+            (*print_stack)[n - 1]\n         } else {\n             PrintStackElem {\n                 offset: 0,"}, {"sha": "26cf79ff8f956af1ff9880982d12e789ab245746", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -175,7 +175,7 @@ pub fn to_string(f: |&mut State| -> IoResult<()>) -> String {\n         let obj: TraitObject = mem::transmute_copy(&s.s.out);\n         let wr: Box<MemWriter> = mem::transmute(obj.data);\n         let result =\n-            String::from_utf8(Vec::from_slice(wr.get_ref().as_slice())).unwrap();\n+            String::from_utf8(wr.get_ref().as_slice().to_vec()).unwrap();\n         mem::forget(wr);\n         result.to_string()\n     }\n@@ -1466,7 +1466,7 @@ impl<'a> State<'a> {\n             }\n             ast::ExprMethodCall(ident, ref tys, ref args) => {\n                 let base_args = args.slice_from(1);\n-                try!(self.print_expr(&**args.get(0)));\n+                try!(self.print_expr(&*args[0]));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_ident(ident.node));\n                 if tys.len() > 0u {\n@@ -2144,7 +2144,7 @@ impl<'a> State<'a> {\n         for &explicit_self in opt_explicit_self.iter() {\n             let m = match explicit_self {\n                 &ast::SelfStatic => ast::MutImmutable,\n-                _ => match decl.inputs.get(0).pat.node {\n+                _ => match decl.inputs[0].pat.node {\n                     ast::PatIdent(ast::BindByValue(m), _, _) => m,\n                     _ => ast::MutImmutable\n                 }\n@@ -2319,7 +2319,7 @@ impl<'a> State<'a> {\n \n         try!(self.commasep(Inconsistent, ints.as_slice(), |s, &idx| {\n             if idx < generics.lifetimes.len() {\n-                let lifetime = generics.lifetimes.get(idx);\n+                let lifetime = &generics.lifetimes[idx];\n                 s.print_lifetime_def(lifetime)\n             } else {\n                 let idx = idx - generics.lifetimes.len();\n@@ -2663,14 +2663,14 @@ impl<'a> State<'a> {\n             ast::LitStr(ref st, style) => self.print_string(st.get(), style),\n             ast::LitByte(byte) => {\n                 let mut res = String::from_str(\"b'\");\n-                (byte as char).escape_default(|c| res.push_char(c));\n-                res.push_char('\\'');\n+                (byte as char).escape_default(|c| res.push(c));\n+                res.push('\\'');\n                 word(&mut self.s, res.as_slice())\n             }\n             ast::LitChar(ch) => {\n                 let mut res = String::from_str(\"'\");\n-                ch.escape_default(|c| res.push_char(c));\n-                res.push_char('\\'');\n+                ch.escape_default(|c| res.push(c));\n+                res.push('\\'');\n                 word(&mut self.s, res.as_slice())\n             }\n             ast::LitInt(i, t) => {\n@@ -2717,7 +2717,7 @@ impl<'a> State<'a> {\n         match self.literals {\n             Some(ref lits) => {\n                 while self.cur_cmnt_and_lit.cur_lit < lits.len() {\n-                    let ltrl = (*(*lits).get(self.cur_cmnt_and_lit.cur_lit)).clone();\n+                    let ltrl = (*lits)[self.cur_cmnt_and_lit.cur_lit].clone();\n                     if ltrl.pos > pos { return None; }\n                     self.cur_cmnt_and_lit.cur_lit += 1u;\n                     if ltrl.pos == pos { return Some(ltrl); }\n@@ -2749,7 +2749,7 @@ impl<'a> State<'a> {\n             comments::Mixed => {\n                 assert_eq!(cmnt.lines.len(), 1u);\n                 try!(zerobreak(&mut self.s));\n-                try!(word(&mut self.s, cmnt.lines.get(0).as_slice()));\n+                try!(word(&mut self.s, cmnt.lines[0].as_slice()));\n                 zerobreak(&mut self.s)\n             }\n             comments::Isolated => {\n@@ -2767,7 +2767,7 @@ impl<'a> State<'a> {\n             comments::Trailing => {\n                 try!(word(&mut self.s, \" \"));\n                 if cmnt.lines.len() == 1u {\n-                    try!(word(&mut self.s, cmnt.lines.get(0).as_slice()));\n+                    try!(word(&mut self.s, cmnt.lines[0].as_slice()));\n                     hardbreak(&mut self.s)\n                 } else {\n                     try!(self.ibox(0u));\n@@ -2813,7 +2813,7 @@ impl<'a> State<'a> {\n         match self.comments {\n             Some(ref cmnts) => {\n                 if self.cur_cmnt_and_lit.cur_cmnt < cmnts.len() {\n-                    Some((*cmnts.get(self.cur_cmnt_and_lit.cur_cmnt)).clone())\n+                    Some(cmnts[self.cur_cmnt_and_lit.cur_cmnt].clone())\n                 } else {\n                     None\n                 }"}, {"sha": "1b231ed861b893cce1b04b05a436a5c3ece7f91a", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -37,6 +37,7 @@\n use std::fmt;\n use std::fmt::Show;\n use std::hash::Hash;\n+use std::ptr;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// An owned smart pointer.\n@@ -61,11 +62,10 @@ impl<T: 'static> P<T> {\n \n     /// Transform the inner value, consuming `self` and producing a new `P<T>`.\n     pub fn map(mut self, f: |T| -> T) -> P<T> {\n-        use std::{mem, ptr};\n         unsafe {\n             let p = &mut *self.ptr;\n             // FIXME(#5016) this shouldn't need to zero to be safe.\n-            mem::move_val_init(p, f(ptr::read_and_zero(p)));\n+            ptr::write(p, f(ptr::read_and_zero(p)));\n         }\n         self\n     }"}, {"sha": "0f86fb751dae45771bd7394340065db8e8a2f3e3", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -100,7 +100,7 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n \n         // `extern crate` must be precede `use` items\n         mem::swap(&mut vis, &mut krate.module.view_items);\n-        krate.module.view_items.push_all_move(vis);\n+        krate.module.view_items.extend(vis.into_iter());\n \n         // don't add #![no_std] here, that will block the prelude injection later.\n         // Add it during the prelude injection instead.\n@@ -219,7 +219,7 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n             vis: ast::Inherited,\n             span: DUMMY_SP,\n         });\n-        view_items.push_all_move(uses);\n+        view_items.extend(uses.into_iter());\n \n         fold::noop_fold_mod(ast::Mod {\n             inner: inner,"}, {"sha": "ed2455d0a30680ebe1377dba46d2860c3a663d2b", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -67,7 +67,7 @@ impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n \n     pub fn get(&self, idx: Name) -> T {\n         let vect = self.vect.borrow();\n-        (*(*vect).get(idx.uint())).clone()\n+        (*vect)[idx.uint()].clone()\n     }\n \n     pub fn len(&self) -> uint {\n@@ -182,13 +182,13 @@ impl StrInterner {\n         let new_idx = Name(self.len() as u32);\n         // leave out of map to avoid colliding\n         let mut vect = self.vect.borrow_mut();\n-        let existing = (*vect.get(idx.uint())).clone();\n+        let existing = (*vect)[idx.uint()].clone();\n         vect.push(existing);\n         new_idx\n     }\n \n     pub fn get(&self, idx: Name) -> RcStr {\n-        (*self.vect.borrow().get(idx.uint())).clone()\n+        (*self.vect.borrow())[idx.uint()].clone()\n     }\n \n     pub fn len(&self) -> uint {"}, {"sha": "60ba5f6615b92e22dacdf67743b6748960d69f80", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -98,7 +98,7 @@ impl<T> SmallVector<T> {\n     pub fn get<'a>(&'a self, idx: uint) -> &'a T {\n         match self.repr {\n             One(ref v) if idx == 0 => v,\n-            Many(ref vs) => vs.get(idx),\n+            Many(ref vs) => &vs[idx],\n             _ => fail!(\"out of bounds access\")\n         }\n     }"}, {"sha": "12ab62267a363c1a5d4ff88ef7d0afdbe66d6d6f", "filename": "src/test/auxiliary/anon-extern-mod-cross-crate-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fanon-extern-mod-cross-crate-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fanon-extern-mod-cross-crate-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fanon-extern-mod-cross-crate-1.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"anonexternmod#0.1\"]\n+#![crate_name=\"anonexternmod\"]\n \n extern crate libc;\n "}, {"sha": "40a9a52061fe5a97066ce9f293e03bca142c7523", "filename": "src/test/auxiliary/cci_impl_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"cci_impl_lib\"]\n+#![crate_name=\"cci_impl_lib\"]\n \n pub trait uint_helpers {\n     fn to(&self, v: uint, f: |uint|);"}, {"sha": "84ade3572f95c158256735b2e897b3e7b3dda011", "filename": "src/test/auxiliary/cci_iter_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"cci_iter_lib\"]\n+#![crate_name=\"cci_iter_lib\"]\n \n #[inline]\n pub fn iter<T>(v: &[T], f: |&T|) {"}, {"sha": "67f55cca1e16b78b688cb35c84421306733a0982", "filename": "src/test/auxiliary/cci_no_inline_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"cci_no_inline_lib\"]\n+#![crate_name=\"cci_no_inline_lib\"]\n \n \n // same as cci_iter_lib, more-or-less, but not marked inline\n pub fn iter(v: Vec<uint> , f: |uint|) {\n     let mut i = 0u;\n     let n = v.len();\n     while i < n {\n-        f(*v.get(i));\n+        f(v[i]);\n         i += 1u;\n     }\n }"}, {"sha": "18162c5f756b8ed3644b742c22726d7eebf95973", "filename": "src/test/auxiliary/changing-crates-a1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fchanging-crates-a1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fchanging-crates-a1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fchanging-crates-a1.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n pub fn foo<T>() {}"}, {"sha": "a54dcbbbfc24538eadf991054b8794c708601e47", "filename": "src/test/auxiliary/changing-crates-a2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fchanging-crates-a2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fchanging-crates-a2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fchanging-crates-a2.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n pub fn foo<T>() { println!(\"hello!\"); }\n "}, {"sha": "81f924e29daa73f29bece01f2100224249b69714", "filename": "src/test/auxiliary/changing-crates-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fchanging-crates-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fchanging-crates-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fchanging-crates-b.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id = \"b\"]\n+#![crate_name = \"b\"]\n \n extern crate a;\n "}, {"sha": "f3d5bf2d65eeea578bc6b75980c963570f96c84f", "filename": "src/test/auxiliary/crate-method-reexport-grrrrrrr2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crate_method_reexport_grrrrrrr2\"]\n+#![crate_name=\"crate_method_reexport_grrrrrrr2\"]\n \n pub use name_pool::add;\n "}, {"sha": "473528c681e7fb9eda5cc1530c130c56ece3cef1", "filename": "src/test/auxiliary/crateresolve3-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve3-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve3-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve3-1.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateresolve3#0.1\"]\n+#![crate_name=\"crateresolve3#0.1\"]\n \n #![crate_type = \"lib\"]\n "}, {"sha": "1e95fa6b63903fcdcb7390d61670a468f303ce7d", "filename": "src/test/auxiliary/crateresolve3-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve3-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve3-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve3-2.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateresolve3#0.2\"]\n+#![crate_name=\"crateresolve3#0.2\"]\n \n #![crate_type = \"lib\"]\n "}, {"sha": "68a69f6dc9073c90c397b65be42581faa0bfa000", "filename": "src/test/auxiliary/crateresolve4a-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-1.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateresolve4a#0.1\"]\n+#![crate_name=\"crateresolve4a#0.1\"]\n #![crate_type = \"lib\"]\n \n pub fn f() -> int { 10 }"}, {"sha": "6e23fddbce7dffbe10a209840647f234ced818f0", "filename": "src/test/auxiliary/crateresolve4a-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-2.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateresolve4a#0.2\"]\n+#![crate_name=\"crateresolve4a#0.2\"]\n #![crate_type = \"lib\"]\n \n pub fn g() -> int { 20 }"}, {"sha": "843fd57ee40d745641e39eed9b50173e63e37d57", "filename": "src/test/auxiliary/crateresolve4b-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-1.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -10,7 +10,7 @@\n \n // aux-build:crateresolve4a-1.rs\n // aux-build:crateresolve4a-2.rs\n-#![crate_id=\"crateresolve4b#0.1\"]\n+#![crate_name=\"crateresolve4b#0.1\"]\n #![crate_type = \"lib\"]\n \n extern crate \"crateresolve4a#0.2\" as crateresolve4a;"}, {"sha": "28c89c79316e2a31f395c6703ed27a3cd0f0c92a", "filename": "src/test/auxiliary/crateresolve4b-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-2.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -10,7 +10,7 @@\n \n // aux-build:crateresolve4a-1.rs\n // aux-build:crateresolve4a-2.rs\n-#![crate_id=\"crateresolve4b#0.2\"]\n+#![crate_name=\"crateresolve4b#0.2\"]\n #![crate_type = \"lib\"]\n \n extern crate \"crateresolve4a#0.1\" as crateresolve4a;"}, {"sha": "223e4f50ae8acb03ccc8ad15df9d37d5e88d3bd3", "filename": "src/test/auxiliary/crateresolve5-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateresolve5#0.1\"]\n+#![crate_name=\"crateresolve5#0.1\"]\n \n #![crate_type = \"lib\"]\n "}, {"sha": "38740886b37ea18edb985fb03bc1eca85787be67", "filename": "src/test/auxiliary/crateresolve5-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateresolve5#0.2\"]\n+#![crate_name=\"crateresolve5#0.2\"]\n \n #![crate_type = \"lib\"]\n "}, {"sha": "5262d662971a43c82f573d45a57cd97e5ecfe9ba", "filename": "src/test/auxiliary/crateresolve8-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve8-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve8-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve8-1.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // default link meta for 'package_id' will be equal to filestem\n-#![crate_id=\"crateresolve8#0.1\"]\n+#![crate_name=\"crateresolve8#0.1\"]\n \n #![crate_type = \"lib\"]\n "}, {"sha": "4dba722971e3cd7e4cee8964147e841ab7c112ed", "filename": "src/test/auxiliary/crateresolve_calories-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-1.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateresolve_calories#0.1\"]\n+#![crate_name=\"crateresolve_calories#0.1\"]\n #![crate_type = \"lib\"]\n \n pub fn f() -> int { 100 }"}, {"sha": "c7e26c8f506d43f1ef5c466176266cefb727c474", "filename": "src/test/auxiliary/crateresolve_calories-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-2.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateresolve_calories#0.1\"]\n+#![crate_name=\"crateresolve_calories#0.1\"]\n #![crate_type = \"lib\"]\n \n pub fn f() -> int { 200 }"}, {"sha": "a5d672e3c0cf90d004d64151620c056751cb1c6a", "filename": "src/test/auxiliary/foreign_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"foreign_lib\"]\n+#![crate_name=\"foreign_lib\"]\n \n pub mod rustrt {\n     extern crate libc;"}, {"sha": "4016a76206be4e51aca898cf97bf3599bdb18ab3", "filename": "src/test/auxiliary/inherited_stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finherited_stability.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![crate_id=\"inherited_stability#0.1\"]\n+#![crate_name=\"inherited_stability\"]\n #![crate_type = \"lib\"]\n #![experimental]\n "}, {"sha": "dd1fdc2e4981f8903def8db742b4f9be0df56452", "filename": "src/test/auxiliary/inline_dtor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Finline_dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Finline_dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finline_dtor.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"inline_dtor#0.1\"]\n+#![crate_name=\"inline_dtor\"]\n \n pub struct Foo;\n "}, {"sha": "37edcdf7628988b6e7419de9a548723ae32be76e", "filename": "src/test/auxiliary/iss.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fiss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fiss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fiss.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"issue6919_3#0.1\"]\n+#![crate_name=\"issue6919_3\"]\n \n // part of issue-6919.rs\n "}, {"sha": "af6bb050ef5a0c9ece93c664d3cd91b0c4529040", "filename": "src/test/auxiliary/issue-2380.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2380.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"a\"]\n+#![crate_name=\"a\"]\n #![crate_type = \"lib\"]\n \n "}, {"sha": "fe1ef549d06acc107b6125e1a8e57ab31483f991", "filename": "src/test/auxiliary/issue-2414-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"a#0.1\"]\n+#![crate_name=\"a\"]\n #![crate_type = \"lib\"]\n \n type t1 = uint;"}, {"sha": "b1c95bcb4300fc1e23b97d9dffa6a5c381b99c66", "filename": "src/test/auxiliary/issue-2414-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue-2414-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue-2414-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2414-b.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-#![crate_id=\"b#0.1\"]\n+#![crate_name=\"b\"]\n #![crate_type = \"lib\"]\n \n extern crate a;"}, {"sha": "e3ce4e8f6565a942f1d6ab4239cb4aa508d01dfa", "filename": "src/test/auxiliary/issue-2526.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2526.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"issue_2526#0.2\"]\n+#![crate_name=\"issue_2526\"]\n #![crate_type = \"lib\"]\n \n #![feature(unsafe_destructor)]"}, {"sha": "e340331dbfd11206b5598f9680b942e1c4c77add", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"req\"]\n+#![crate_name=\"req\"]\n #![crate_type = \"lib\"]\n \n use std::cell::RefCell;\n@@ -19,7 +19,5 @@ pub type header_map = HashMap<String, Rc<RefCell<Vec<Rc<String>>>>>;\n \n // the unused ty param is necessary so this gets monomorphized\n pub fn request<T>(req: &header_map) {\n-  let _x = (**((**req.get(&\"METHOD\".to_string())).clone()).borrow()\n-                                                          .clone()\n-                                                          .get(0)).clone();\n+  let _x = req[\"METHOD\".to_string()].clone().borrow().clone()[0].clone();\n }"}, {"sha": "25eb67e0423005cc14f825f02faa287206604b48", "filename": "src/test/auxiliary/issue-3012-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue-3012-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue-3012-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-3012-1.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"socketlib\"]\n+#![crate_name=\"socketlib\"]\n #![crate_type = \"lib\"]\n \n pub mod socket {"}, {"sha": "a7c1633784d81cf813ff762534a03304ebed7368", "filename": "src/test/auxiliary/issue-4208-cc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue-4208-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue-4208-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-4208-cc.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"numeric#0.1\"]\n+#![crate_name=\"numeric\"]\n #![crate_type = \"lib\"]\n \n pub trait Trig<T> {"}, {"sha": "33b6d116c8a2d54926472a615d491e0581d289ec", "filename": "src/test/auxiliary/issue_2242_a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"a#0.1\"]\n+#![crate_name=\"a#0.1\"]\n #![crate_type = \"lib\"]\n \n trait to_strz {"}, {"sha": "31d119b20beaabf8d29dc7d05e524ad963cba00d", "filename": "src/test/auxiliary/issue_2242_c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"c#0.1\"]\n+#![crate_name=\"c#0.1\"]\n #![crate_type = \"lib\"]\n \n extern crate a;"}, {"sha": "91faace7a3f4d6b93064c4e3ab539a3b64ef74a0", "filename": "src/test/auxiliary/issue_3979_traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue_3979_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fissue_3979_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3979_traits.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"issue_3979_traits#0.1\"]\n+#![crate_name=\"issue_3979_traits\"]\n \n #![crate_type = \"lib\"]\n "}, {"sha": "181b651ef521c8cc5c700407593a1d5e603be308", "filename": "src/test/auxiliary/lint_output_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Flint_output_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Flint_output_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_output_format.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"lint_output_format#0.1\"]\n+#![crate_name=\"lint_output_format\"]\n #![crate_type = \"lib\"]\n \n #[deprecated]"}, {"sha": "06031eb6c6ccfee9b141a76604d947f607fd540c", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![crate_id=\"lint_stability#0.1\"]\n+#![crate_name=\"lint_stability\"]\n #![crate_type = \"lib\"]\n \n #![feature(macro_rules)]"}, {"sha": "1c26ac26d7cf3de07f223124ca8afeef3d30c1b6", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -51,7 +51,7 @@ fn expand_identity(cx: &mut ExtCtxt, _span: Span, tts: &[TokenTree])\n                    -> Box<MacResult+'static> {\n     // Parse an expression and emit it unchanged.\n     let mut parser = parse::new_parser_from_tts(cx.parse_sess(),\n-        cx.cfg(), Vec::from_slice(tts));\n+        cx.cfg(), tts.to_vec());\n     let expr = parser.parse_expr();\n     MacExpr::new(quote_expr!(&mut *cx, $expr))\n }"}, {"sha": "27befee6f07f5cea2b7efbf4722460668c1cc7eb", "filename": "src/test/auxiliary/static-function-pointer-aux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fstatic-function-pointer-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fstatic-function-pointer-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-function-pointer-aux.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"static-function-pointer-aux\"]\n+#![crate_name=\"static-function-pointer-aux\"]\n \n pub fn f(x: int) -> int { -x }\n "}, {"sha": "eef2fdbfea9d9114a1168b51e3b4bb6093d8f220", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"static_methods_crate#0.1\"]\n+#![crate_name=\"static_methods_crate\"]\n #![crate_type = \"lib\"]\n \n use std::int;"}, {"sha": "4ef8701030f47d1767e7f924f6cf3c94c741b2e2", "filename": "src/test/auxiliary/struct_variant_xc_aux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fstruct_variant_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fstruct_variant_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstruct_variant_xc_aux.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"struct_variant_xc_aux#0.1\"]\n+#![crate_name=\"struct_variant_xc_aux\"]\n #![crate_type = \"lib\"]\n \n #![feature(struct_variant)]"}, {"sha": "c035f1203f8e3927e27a4c6d5c9cd436fb434509", "filename": "src/test/auxiliary/svh-a-base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "614487c98171342a8cb4881f9ffc60139ad1be01", "filename": "src/test/auxiliary/svh-a-change-lit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "99506309a592e31a6aab080ac6db998636c7acd1", "filename": "src/test/auxiliary/svh-a-change-significant-cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "8ec4eaebbe8df974ced8614f2a46863bde7bc4b2", "filename": "src/test/auxiliary/svh-a-change-trait-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "ad120e12f86fb92d2381a8ba3eec42c36e1a22b0", "filename": "src/test/auxiliary/svh-a-change-type-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "c68c13c0991f2e7995a45c86d7ff806057ff677e", "filename": "src/test/auxiliary/svh-a-change-type-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "6c13e84a7febe933265e2448dee6c8e26b48f453", "filename": "src/test/auxiliary/svh-a-change-type-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "3d0973cb7ba1391d7f944656f5166d6feeb378b2", "filename": "src/test/auxiliary/svh-a-comment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "1ad9e5e1c0e3a9186eafc2dd7796620a385db97c", "filename": "src/test/auxiliary/svh-a-doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "6bd36b5a9b1c47839879bdc413c3746cc009e029", "filename": "src/test/auxiliary/svh-a-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "c035f1203f8e3927e27a4c6d5c9cd436fb434509", "filename": "src/test/auxiliary/svh-a-no-change.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "d67c8f4c181798ef84fa217709a2380a4f6ddef7", "filename": "src/test/auxiliary/svh-a-redundant-cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "73798f3787558ccef82259d69fd01f9a68d22243", "filename": "src/test/auxiliary/svh-a-whitespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "b8946fdc99553bbfbfa4fdc908e25a16cbd67dd2", "filename": "src/test/auxiliary/svh-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-b.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -16,7 +16,7 @@\n //! the change could affect the downstream crate content or not\n //! (#14132).\n \n-#![crate_id = \"b\"]\n+#![crate_name = \"b\"]\n \n extern crate a;\n "}, {"sha": "67fdac5df0330d38259a81a7087be887ce943327", "filename": "src/test/auxiliary/svh-uta-base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-uta-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-uta-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-uta-base.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -15,7 +15,7 @@\n //!\n //! This is the upstream crate.\n \n-#![crate_id = \"uta\"]\n+#![crate_name = \"uta\"]\n \n mod traits {\n     pub trait TraitA { fn val(&self) -> int { 2 } }"}, {"sha": "dfcf02c0ff500ab4327fae00f279cc174d818d8e", "filename": "src/test/auxiliary/svh-uta-change-use-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-uta-change-use-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-uta-change-use-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-uta-change-use-trait.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -15,7 +15,7 @@\n //!\n //! This is the upstream crate.\n \n-#![crate_id = \"uta\"]\n+#![crate_name = \"uta\"]\n \n mod traits {\n     pub trait TraitA { fn val(&self) -> int { 2 } }"}, {"sha": "eb3da985242be45b8b7ac34a7505b6da878a4c57", "filename": "src/test/auxiliary/svh-utb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-utb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Fsvh-utb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-utb.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -15,7 +15,7 @@\n //!\n //! This is the downstream crate.\n \n-#![crate_id = \"utb\"]\n+#![crate_name = \"utb\"]\n \n extern crate uta;\n "}, {"sha": "7424c21be3da0c6b05fd5f6b4091951002dc68c7", "filename": "src/test/auxiliary/trait_default_method_xc_aux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"trait_default_method_xc_aux\"]\n+#![crate_name=\"trait_default_method_xc_aux\"]\n \n pub struct Something { pub x: int }\n "}, {"sha": "404e2e31b05770560b83b9c657d3545f54a4cbaf", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -68,7 +68,7 @@ fn shift_push() {\n     let mut v2 = Vec::new();\n \n     while v1.len() > 0 {\n-        v2.push(v1.shift().unwrap());\n+        v2.push(v1.remove(0).unwrap());\n     }\n }\n \n@@ -93,9 +93,11 @@ fn vec_plus() {\n     while i < 1500 {\n         let rv = Vec::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n-            v.push_all_move(rv);\n+            v.extend(rv.into_iter());\n         } else {\n-            v = rv.clone().append(v.as_slice());\n+            let mut rv = rv.clone();\n+            rv.push_all(v.as_slice());\n+            v = rv;\n         }\n         i += 1;\n     }\n@@ -109,10 +111,14 @@ fn vec_append() {\n     while i < 1500 {\n         let rv = Vec::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n-            v = v.clone().append(rv.as_slice());\n+            let mut t = v.clone();\n+            t.push_all(rv.as_slice());\n+            v = t;\n         }\n         else {\n-            v = rv.clone().append(v.as_slice());\n+            let mut t = rv.clone();\n+            t.push_all(v.as_slice());\n+            v = t;\n         }\n         i += 1;\n     }"}, {"sha": "98113cb834767a61dc0d04403cbea148c95bff44", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -21,7 +21,7 @@ fn main() {\n         args.into_iter().collect()\n     };\n \n-    let n = from_str::<uint>(args.get(1).as_slice()).unwrap();\n+    let n = from_str::<uint>(args[1].as_slice()).unwrap();\n \n     for i in range(0u, n) {\n         let x = i.to_string();"}, {"sha": "1a9ffd68284868e967385b5c4822e2e4f92e11b5", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -72,8 +72,8 @@ fn main() {\n         args.clone().into_iter().collect()\n     };\n \n-    let num_tasks = from_str::<uint>(args.get(1).as_slice()).unwrap();\n-    let msg_per_task = from_str::<uint>(args.get(2).as_slice()).unwrap();\n+    let num_tasks = from_str::<uint>(args[1].as_slice()).unwrap();\n+    let msg_per_task = from_str::<uint>(args[2].as_slice()).unwrap();\n \n     let (mut num_chan, num_port) = init();\n "}, {"sha": "5e192a1479346e2eefc4830e0e0d7a322cb1b6ae", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -72,8 +72,8 @@ fn main() {\n         args.clone().into_iter().collect()\n     };\n \n-    let num_tasks = from_str::<uint>(args.get(1).as_slice()).unwrap();\n-    let msg_per_task = from_str::<uint>(args.get(2).as_slice()).unwrap();\n+    let num_tasks = from_str::<uint>(args[1].as_slice()).unwrap();\n+    let msg_per_task = from_str::<uint>(args[2].as_slice()).unwrap();\n \n     let (mut num_chan, num_port) = init();\n "}, {"sha": "e7a50382c9469a262dfbe09b373cb066831dcca0", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -31,6 +31,6 @@ fn main() {\n     } else {\n         args.into_iter().collect()\n     };\n-    let n = from_str::<int>(args.get(1).as_slice()).unwrap();\n+    let n = from_str::<int>(args[1].as_slice()).unwrap();\n     println!(\"Ack(3,{}): {}\\n\", n, ack(3, n));\n }"}, {"sha": "10c0d0a8044cb62a0de70b5518ee9f9f34b0ca94", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -27,6 +27,6 @@ fn main() {\n     } else {\n         args.into_iter().collect()\n     };\n-    let n = from_str::<int>(args.get(1).as_slice()).unwrap();\n+    let n = from_str::<int>(args[1].as_slice()).unwrap();\n     println!(\"{}\\n\", fib(n));\n }"}, {"sha": "5d77e27f948a1dc25abb51f5b66d1e31b5bf95a2", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -83,7 +83,7 @@ fn find(mm: &HashMap<Vec<u8> , uint>, key: String) -> uint {\n \n // given a map, increment the counter for a key\n fn update_freq(mm: &mut HashMap<Vec<u8> , uint>, key: &[u8]) {\n-    let key = Vec::from_slice(key);\n+    let key = key.to_vec();\n     let newval = match mm.pop(&key) {\n         Some(v) => v + 1,\n         None => 1\n@@ -103,7 +103,7 @@ fn windows_with_carry(bb: &[u8], nn: uint, it: |window: &[u8]|) -> Vec<u8> {\n       ii += 1u;\n    }\n \n-   return Vec::from_slice(bb[len - (nn - 1u)..len]);\n+   return bb[len - (nn - 1u)..len].to_vec();\n }\n \n fn make_sequence_processor(sz: uint,\n@@ -117,15 +117,14 @@ fn make_sequence_processor(sz: uint,\n \n    loop {\n \n-      line = from_parent.recv();\n-      if line == Vec::new() { break; }\n+       line = from_parent.recv();\n+       if line == Vec::new() { break; }\n \n-       carry = windows_with_carry(carry.append(line.as_slice()).as_slice(),\n-                                  sz,\n-                                  |window| {\n-         update_freq(&mut freqs, window);\n-         total += 1u;\n-      });\n+       carry.push_all(line.as_slice());\n+       carry = windows_with_carry(carry.as_slice(), sz, |window| {\n+           update_freq(&mut freqs, window);\n+           total += 1u;\n+       });\n    }\n \n    let buffer = match sz {\n@@ -149,7 +148,7 @@ fn main() {\n \n     let rdr = if os::getenv(\"RUST_BENCH\").is_some() {\n         let foo = include_bin!(\"shootout-k-nucleotide.data\");\n-        box MemReader::new(Vec::from_slice(foo)) as Box<Reader>\n+        box MemReader::new(foo.to_vec()) as Box<Reader>\n     } else {\n         box stdio::stdin() as Box<Reader>\n     };\n@@ -203,8 +202,8 @@ fn main() {\n                let line_bytes = line.as_bytes();\n \n                for (ii, _sz) in sizes.iter().enumerate() {\n-                   let lb = Vec::from_slice(line_bytes);\n-                   to_child.get(ii).send(lb);\n+                   let lb = line_bytes.to_vec();\n+                   to_child[ii].send(lb);\n                }\n            }\n \n@@ -215,11 +214,11 @@ fn main() {\n \n    // finish...\n    for (ii, _sz) in sizes.iter().enumerate() {\n-       to_child.get(ii).send(Vec::new());\n+       to_child[ii].send(Vec::new());\n    }\n \n    // now fetch and print result messages\n    for (ii, _sz) in sizes.iter().enumerate() {\n-       println!(\"{}\", from_child.get(ii).recv());\n+       println!(\"{}\", from_child[ii].recv());\n    }\n }"}, {"sha": "8486fa5b034d666003826d5adef95842fef96256", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -102,7 +102,7 @@ fn advance(bodies: &mut [Planet, ..N_BODIES], dt: f64, steps: int) {\n     for _ in range(0, steps) {\n         let mut b_slice = bodies.as_mut_slice();\n         loop {\n-            let bi = match b_slice.mut_shift_ref() {\n+            let bi = match shift_mut_ref(&mut b_slice) {\n                 Some(bi) => bi,\n                 None => break\n             };\n@@ -183,3 +183,21 @@ fn main() {\n \n     println!(\"{:.9f}\", energy(&bodies));\n }\n+\n+/// Pop a mutable reference off the head of a slice, mutating the slice to no\n+/// longer contain the mutable reference. This is a safe operation because the\n+/// two mutable borrows are entirely disjoint.\n+fn shift_mut_ref<'a, T>(r: &mut &'a mut [T]) -> Option<&'a mut T> {\n+    use std::mem;\n+    use std::raw::Repr;\n+\n+    if r.len() == 0 { return None }\n+    unsafe {\n+        let mut raw = r.repr();\n+        let ret = raw.data as *mut T;\n+        raw.data = raw.data.offset(1);\n+        raw.len -= 1;\n+        *r = mem::transmute(raw);\n+        Some(unsafe { &mut *ret })\n+    }\n+}"}, {"sha": "91b9e058e8feacee390c12f2963103fe8e698986", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -102,7 +102,7 @@ fn main() {\n     if opts.stress {\n         stress(2);\n     } else {\n-        let max = uint::parse_bytes(args.get(1).as_bytes(), 10u).unwrap() as\n+        let max = uint::parse_bytes(args[1].as_bytes(), 10u).unwrap() as\n             int;\n \n         let num_trials = 10;"}, {"sha": "2086980b016fcdbffee1287727937d86145b2ed1", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -25,7 +25,7 @@ fn append_sequential(min: uint, max: uint, map: &mut SmallIntMap<uint>) {\n \n fn check_sequential(min: uint, max: uint, map: &SmallIntMap<uint>) {\n     for i in range(min, max) {\n-        assert_eq!(*map.get(&i), i + 22u);\n+        assert_eq!(map[i], i + 22u);\n     }\n }\n \n@@ -38,8 +38,8 @@ fn main() {\n     } else {\n         args.into_iter().collect()\n     };\n-    let max = from_str::<uint>(args.get(1).as_slice()).unwrap();\n-    let rep = from_str::<uint>(args.get(2).as_slice()).unwrap();\n+    let max = from_str::<uint>(args[1].as_slice()).unwrap();\n+    let rep = from_str::<uint>(args[2].as_slice()).unwrap();\n \n     let mut checkf = 0.0;\n     let mut appendf = 0.0;"}, {"sha": "01c412c6d3195420ecb903608f56d782e34415bf", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -55,8 +55,8 @@ impl Sudoku {\n     pub fn equal(&self, other: &Sudoku) -> bool {\n         for row in range(0u8, 9u8) {\n             for col in range(0u8, 9u8) {\n-                if *self.grid.get(row as uint).get(col as uint) !=\n-                        *other.grid.get(row as uint).get(col as uint) {\n+                if self.grid[row as uint][col as uint] !=\n+                        other.grid[row as uint][col as uint] {\n                     return false;\n                 }\n             }\n@@ -77,10 +77,10 @@ impl Sudoku {\n                                        .collect();\n \n             if comps.len() == 3u {\n-                let row     = from_str::<uint>(*comps.get(0)).unwrap() as u8;\n-                let col     = from_str::<uint>(*comps.get(1)).unwrap() as u8;\n+                let row     = from_str::<uint>(comps[0]).unwrap() as u8;\n+                let col     = from_str::<uint>(comps[1]).unwrap() as u8;\n                 *g.get_mut(row as uint).get_mut(col as uint) =\n-                    from_str::<uint>(*comps.get(2)).unwrap() as u8;\n+                    from_str::<uint>(comps[2]).unwrap() as u8;\n             }\n             else {\n                 fail!(\"Invalid sudoku file\");\n@@ -91,11 +91,9 @@ impl Sudoku {\n \n     pub fn write(&self, writer: &mut io::Writer) {\n         for row in range(0u8, 9u8) {\n-            write!(writer, \"{}\", *self.grid.get(row as uint).get(0));\n+            write!(writer, \"{}\", self.grid[row as uint][0]);\n             for col in range(1u8, 9u8) {\n-                write!(writer, \" {}\", *self.grid\n-                                           .get(row as uint)\n-                                           .get(col as uint));\n+                write!(writer, \" {}\", self.grid[row as uint][col as uint]);\n             }\n             write!(writer, \"\\n\");\n          }\n@@ -106,7 +104,7 @@ impl Sudoku {\n         let mut work: Vec<(u8, u8)> = Vec::new(); /* queue of uncolored fields */\n         for row in range(0u8, 9u8) {\n             for col in range(0u8, 9u8) {\n-                let color = *self.grid.get(row as uint).get(col as uint);\n+                let color = self.grid[row as uint][col as uint];\n                 if color == 0u8 {\n                     work.push((row, col));\n                 }\n@@ -116,9 +114,9 @@ impl Sudoku {\n         let mut ptr = 0u;\n         let end = work.len();\n         while ptr < end {\n-            let (row, col) = *work.get(ptr);\n+            let (row, col) = work[ptr];\n             // is there another color to try?\n-            let the_color = *self.grid.get(row as uint).get(col as uint) +\n+            let the_color = self.grid[row as uint][col as uint] +\n                                 (1 as u8);\n             if self.next_color(row, col, the_color) {\n                 //  yes: advance work list\n@@ -151,22 +149,18 @@ impl Sudoku {\n     // find colors available in neighbourhood of (row, col)\n     fn drop_colors(&mut self, avail: &mut Colors, row: u8, col: u8) {\n         for idx in range(0u8, 9u8) {\n-            avail.remove(*self.grid\n-                              .get(idx as uint)\n-                              .get(col as uint)); /* check same column fields */\n-            avail.remove(*self.grid\n-                              .get(row as uint)\n-                              .get(idx as uint)); /* check same row fields */\n+            /* check same column fields */\n+            avail.remove(self.grid[idx as uint][col as uint]);\n+            /* check same row fields */\n+            avail.remove(self.grid[row as uint][idx as uint]);\n         }\n \n         // check same block fields\n         let row0 = (row / 3u8) * 3u8;\n         let col0 = (col / 3u8) * 3u8;\n         for alt_row in range(row0, row0 + 3u8) {\n             for alt_col in range(col0, col0 + 3u8) {\n-                avail.remove(*self.grid\n-                                  .get(alt_row as uint)\n-                                  .get(alt_col as uint));\n+                avail.remove(self.grid[alt_row as uint][alt_col as uint]);\n             }\n         }\n     }"}, {"sha": "bdeee5fb6e0bf6b6ca47968d72d630e5189ed6d7", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -78,21 +78,22 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n         let depth = depth - 1;\n \n         let st = match st {\n-          None => {\n-            State {\n-                unique: box Nil,\n-                vec: vec!(box Nil),\n-                res: r(box Nil)\n+            None => {\n+                State {\n+                    unique: box Nil,\n+                    vec: vec!(box Nil),\n+                    res: r(box Nil)\n+                }\n             }\n-          }\n-          Some(st) => {\n-            State {\n-                unique: box Cons((), box *st.unique),\n-                vec: st.vec.clone().append(\n-                        &[box Cons((), st.vec.last().unwrap().clone())]),\n-                res: r(box Cons((), st.res._l.clone()))\n+            Some(st) => {\n+                let mut v = st.vec.clone();\n+                v.push_all(&[box Cons((), st.vec.last().unwrap().clone())]);\n+                State {\n+                    unique: box Cons((), box *st.unique),\n+                    vec: v,\n+                    res: r(box Cons((), st.res._l.clone())),\n+                }\n             }\n-          }\n         };\n \n         recurse_or_fail(depth, Some(st));"}, {"sha": "9ebdbf0682d79d5e6e374e4bc54a80b413bf9da9", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -49,7 +49,7 @@ fn main() {\n     };\n \n     let (tx, rx) = channel();\n-    child_generation(from_str::<uint>(args.get(1).as_slice()).unwrap(), tx);\n+    child_generation(from_str::<uint>(args[1].as_slice()).unwrap(), tx);\n     if rx.recv_opt().is_err() {\n         fail!(\"it happened when we slumbered\");\n     }"}, {"sha": "533005b1fb38c0c98d31943e36868a8a1c690bc7", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -31,7 +31,7 @@ fn main() {\n     } else {\n         args.into_iter().collect()\n     };\n-    let n = from_str::<uint>(args.get(1).as_slice()).unwrap();\n+    let n = from_str::<uint>(args[1].as_slice()).unwrap();\n     let mut i = 0u;\n     while i < n { task::spawn(proc() f(n) ); i += 1u; }\n }"}, {"sha": "3ad17618fc0b31e33830f5ced682c7e7e69ff4e0", "filename": "src/test/compile-fail-fulldeps/syntax-extension-fourcc-bad-len.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-bad-len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-bad-len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-bad-len.rs?ref=fb169d5543c84e11038ba2d07b538ec88fb49ca6", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-stage1\n-// ignore-pretty\n-\n-#![feature(phase)]\n-\n-#[phase(plugin)]\n-extern crate fourcc;\n-\n-fn main() {\n-    let val = fourcc!(\"foo\"); //~ ERROR string literal with len != 4 in fourcc!\n-    let val2 = fourcc!(\"fooba\"); //~ ERROR string literal with len != 4 in fourcc!\n-}"}, {"sha": "4d425d9a2056a62f8e7cbf3b019d4a3bd7592e73", "filename": "src/test/compile-fail-fulldeps/syntax-extension-fourcc-invalid-endian.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-invalid-endian.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-invalid-endian.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-invalid-endian.rs?ref=fb169d5543c84e11038ba2d07b538ec88fb49ca6", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-stage1\n-// ignore-pretty\n-\n-#![feature(phase)]\n-\n-#[phase(plugin)]\n-extern crate fourcc;\n-\n-fn main() {\n-    let val = fourcc!(\"foo \", bork); //~ ERROR invalid endian directive in fourcc!\n-}"}, {"sha": "1a6d747c1e8368ee7c84ddec51a33e154c1ba00f", "filename": "src/test/compile-fail-fulldeps/syntax-extension-fourcc-non-ascii-str.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-non-ascii-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-non-ascii-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-non-ascii-str.rs?ref=fb169d5543c84e11038ba2d07b538ec88fb49ca6", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-stage1\n-// ignore-pretty\n-\n-#![feature(phase)]\n-\n-#[phase(plugin)]\n-extern crate fourcc;\n-\n-fn main() {\n-    let v = fourcc!(\"foo\u03bb\"); //~ ERROR fourcc! literal character out of range 0-255\n-}"}, {"sha": "885d8dd1ec326fcd76ca10634498807e6debb13f", "filename": "src/test/compile-fail-fulldeps/syntax-extension-fourcc-non-literal.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-non-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-non-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-non-literal.rs?ref=fb169d5543c84e11038ba2d07b538ec88fb49ca6", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-stage1\n-// ignore-pretty\n-\n-#![feature(phase)]\n-\n-#[phase(plugin)]\n-extern crate fourcc;\n-\n-fn main() {\n-    let val = fourcc!(foo); //~ ERROR non-literal in fourcc!\n-}"}, {"sha": "da1c0070715686c13e14238171bd70a9ed047019", "filename": "src/test/compile-fail-fulldeps/syntax-extension-fourcc-unsupported-literal.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-unsupported-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-unsupported-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-unsupported-literal.rs?ref=fb169d5543c84e11038ba2d07b538ec88fb49ca6", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-stage1\n-// ignore-pretty\n-\n-#![feature(phase)]\n-\n-#[phase(plugin)]\n-extern crate fourcc;\n-\n-fn main() {\n-    let val = fourcc!(45f32); //~ ERROR unsupported literal in fourcc!\n-}"}, {"sha": "191042f5f5639f6876b2c66e2e2cf664916a6417", "filename": "src/test/compile-fail-fulldeps/syntax-extension-hexfloat-bad-lits.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-hexfloat-bad-lits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-hexfloat-bad-lits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-hexfloat-bad-lits.rs?ref=fb169d5543c84e11038ba2d07b538ec88fb49ca6", "patch": "@@ -1,34 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-stage1\n-// ignore-pretty\n-\n-#![feature(phase)]\n-\n-#[phase(plugin)]\n-extern crate hexfloat;\n-\n-fn main() {\n-    hexfloat!(\"foo\");\n-    //~^ ERROR invalid hex float literal in hexfloat!: Expected '0'\n-    hexfloat!(\"0\");\n-    //~^ERROR invalid hex float literal in hexfloat!: Expected 'x'\n-    hexfloat!(\"0x\");\n-    //~^ERROR invalid hex float literal in hexfloat!: Expected '.'\n-    hexfloat!(\"0x.\");\n-    //~^ERROR invalid hex float literal in hexfloat!: Expected digits before or after decimal point\n-    hexfloat!(\"0x0.0\");\n-    //~^ERROR invalid hex float literal in hexfloat!: Expected 'p'\n-    hexfloat!(\"0x0.0p\");\n-    //~^ERROR invalid hex float literal in hexfloat!: Expected exponent digits\n-    hexfloat!(\"0x0.0p0f\");\n-    //~^ERROR invalid hex float literal in hexfloat!: Expected end of string\n-}"}, {"sha": "f0ace43ec9e8d34ad66d8b35c601feca8646d0b0", "filename": "src/test/compile-fail-fulldeps/syntax-extension-hexfloat-bad-types.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-hexfloat-bad-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-hexfloat-bad-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-hexfloat-bad-types.rs?ref=fb169d5543c84e11038ba2d07b538ec88fb49ca6", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-stage1\n-// ignore-pretty\n-\n-#![feature(phase)]\n-\n-#[phase(plugin)]\n-extern crate hexfloat;\n-\n-fn main() {\n-    hexfloat!(foo);\n-    //~^ ERROR non-literal in hexfloat!\n-    hexfloat!(0);\n-    //~^ ERROR unsupported literal in hexfloat!\n-    hexfloat!(\"0x0.p0\", invalid);\n-    //~^ ERROR invalid floating point type in hexfloat!\n-}"}, {"sha": "5bc2edba301342704c21b84a208811d1823d1290", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -17,7 +17,7 @@ fn a() {\n     let mut p = vec!(1);\n \n     // Create an immutable pointer into p's contents:\n-    let q: &int = p.get(0);\n+    let q: &int = &p[0];\n \n     *p.get_mut(0) = 5; //~ ERROR cannot borrow\n "}, {"sha": "31b5c44df66637a2206d76bc9a3dfe6181c76e79", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -18,13 +18,13 @@ fn takes_imm_elt(_v: &int, f: ||) {\n \n fn has_mut_vec_and_does_not_try_to_change_it() {\n     let mut v = vec!(1, 2, 3);\n-    takes_imm_elt(v.get(0), || {})\n+    takes_imm_elt(&v[0], || {})\n }\n \n fn has_mut_vec_but_tries_to_change_it() {\n     let mut v = vec!(1, 2, 3);\n     takes_imm_elt(\n-        v.get(0),\n+        &v[0],\n         || { //~ ERROR cannot borrow `v` as mutable\n             *v.get_mut(1) = 4;\n         })"}, {"sha": "d9d7a43d46c41e60a275763c7ef16d943b6a6805", "filename": "src/test/compile-fail/borrowck-overloaded-index-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-2.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -14,7 +14,7 @@ struct MyVec<T> {\n \n impl<T> Index<uint, T> for MyVec<T> {\n     fn index(&self, &i: &uint) -> &T {\n-        self.data.get(i)\n+        &self.data[i]\n     }\n }\n "}, {"sha": "9f1c1fdd7c79e5cd68a750a951adcfe417918d69", "filename": "src/test/compile-fail/deprecated-url.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Fcompile-fail%2Fdeprecated-url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Fcompile-fail%2Fdeprecated-url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecated-url.rs?ref=fb169d5543c84e11038ba2d07b538ec88fb49ca6", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-\n-#![deny(deprecated)]\n-\n-extern crate url;\n-\n-fn main() {\n-    let _ = url::Url::parse(\"http://example.com\");\n-    //~^ ERROR use of deprecated item: This is being removed. Use rust-url instead. http://servo.github.io/rust-url/\n-}"}, {"sha": "6dcf1fdee83028c5a4ceec06c42b6b51ec1b2622", "filename": "src/test/compile-fail/lub-if.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-if.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -16,14 +16,14 @@ pub fn opt_str0<'a>(maybestr: &'a Option<String>) -> &'a str {\n     if maybestr.is_none() {\n         \"(none)\"\n     } else {\n-        let s: &'a str = maybestr.get_ref().as_slice();\n+        let s: &'a str = maybestr.as_ref().unwrap().as_slice();\n         s\n     }\n }\n \n pub fn opt_str1<'a>(maybestr: &'a Option<String>) -> &'a str {\n     if maybestr.is_some() {\n-        let s: &'a str = maybestr.get_ref().as_slice();\n+        let s: &'a str = maybestr.as_ref().unwrap().as_slice();\n         s\n     } else {\n         \"(none)\"\n@@ -34,14 +34,14 @@ pub fn opt_str2<'a>(maybestr: &'a Option<String>) -> &'static str {\n     if maybestr.is_none() {\n         \"(none)\"\n     } else {\n-        let s: &'a str = maybestr.get_ref().as_slice();\n+        let s: &'a str = maybestr.as_ref().unwrap().as_slice();\n         s  //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to conflicting\n     }\n }\n \n pub fn opt_str3<'a>(maybestr: &'a Option<String>) -> &'static str {\n     if maybestr.is_some() {\n-        let s: &'a str = maybestr.get_ref().as_slice();\n+        let s: &'a str = maybestr.as_ref().unwrap().as_slice();\n         s  //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to conflicting\n     } else {\n         \"(none)\""}, {"sha": "c9efce0d68478009a4122987357c97d44ec6de4a", "filename": "src/test/compile-fail/moves-based-on-type-access-to-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -18,7 +18,7 @@ fn touch<A>(_a: &A) {}\n fn f20() {\n     let x = vec!(\"hi\".to_string());\n     consume(x.into_iter().next().unwrap());\n-    touch(x.get(0)); //~ ERROR use of moved value: `x`\n+    touch(&x[0]); //~ ERROR use of moved value: `x`\n }\n \n fn main() {}"}, {"sha": "1d6dc504ab43b7baaea5f1e4310a4660fd98a890", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -30,7 +30,7 @@ fn f20() {\n \n fn f21() {\n     let x = vec!(1i, 2, 3);\n-    let _y = (*x.get(0), 3i);\n+    let _y = (x[0], 3i);\n     touch(&x);\n }\n \n@@ -96,8 +96,8 @@ fn f110() {\n fn f120() {\n     let mut x = vec!(\"hi\".to_string(), \"ho\".to_string());\n     x.as_mut_slice().swap(0, 1);\n-    touch(x.get(0));\n-    touch(x.get(1));\n+    touch(&x[0]);\n+    touch(&x[1]);\n }\n \n fn main() {}"}, {"sha": "a07317176e410e48df90a758147dd5339999c90c", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -18,10 +18,10 @@ fn main() {\n     let arc_v = Arc::new(v);\n \n     task::spawn(proc() {\n-        assert_eq!(*arc_v.get(3), 4);\n+        assert_eq!((*arc_v)[3], 4);\n     });\n \n-    assert_eq!(*arc_v.get(2), 3);\n+    assert_eq!((*arc_v)[2], 3);\n \n     println!(\"{}\", *arc_v);\n }"}, {"sha": "9f33f35838e2794de43214b27caa748e406d1602", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -16,10 +16,10 @@ fn main() {\n     let arc_v = Arc::new(v);\n \n     task::spawn(proc() {\n-        assert_eq!(*arc_v.get(3), 4);\n+        assert_eq!((*arc_v)[3], 4);\n     });\n \n-    assert_eq!(*arc_v.get(2), 3); //~ ERROR use of moved value: `arc_v`\n+    assert_eq!((*arc_v)[2], 3); //~ ERROR use of moved value: `arc_v`\n \n     println!(\"{}\", *arc_v); //~ ERROR use of moved value: `arc_v`\n }"}, {"sha": "b639af617574cc8d874d570658f7c9e183fc5614", "filename": "src/test/compile-fail/ufcs-explicit-self-bad.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::owned::Box;\n-\n struct Foo {\n     f: int,\n }"}, {"sha": "33d3deb8733d506112ca306c0369cd42402741d0", "filename": "src/test/compile-fail/unresolved-extern-mod-suggestion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Funresolved-extern-mod-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Funresolved-extern-mod-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funresolved-extern-mod-suggestion.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate url;\n-use url; //~ ERROR unresolved import (maybe you meant `url::*`?)\n+extern crate core;\n+use core; //~ ERROR unresolved import (maybe you meant `core::*`?)\n \n fn main() {}"}, {"sha": "13eb6f860ba432c7b541e60eea284c4c9a3d207b", "filename": "src/test/compile-fail/writing-to-immutable-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -11,5 +11,5 @@\n \n fn main() {\n     let v: Vec<int> = vec!(1, 2, 3);\n-    *v.get(1) = 4; //~ ERROR cannot assign\n+    v[1] = 4; //~ ERROR cannot assign\n }"}, {"sha": "9123342f09a5c07edcc7e47f52a2fcb2563898d2", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -31,5 +31,5 @@ fn main() {\n            idx * mem::size_of::<uint>());\n \n     // This should fail.\n-    println!(\"ov1 0x{:x}\", *x.get(idx));\n+    println!(\"ov1 0x{:x}\", x[idx]);\n }"}, {"sha": "bf04789bbc7738ddbb8ee4e8e3012f8feaa3f8d6", "filename": "src/test/run-fail/glob-use-std.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-fail%2Fglob-use-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-fail%2Fglob-use-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fglob-use-std.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -20,7 +20,5 @@\n use std::*;\n \n fn main() {\n-    String::from_byte(b'a'); // avoid an unused import message\n-\n     fail!(\"fail works\")\n }"}, {"sha": "539d2adc7d45caebecf69f46893ac8648a6225db", "filename": "src/test/run-fail/issue-3029.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-fail%2Fissue-3029.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-fail%2Fissue-3029.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-3029.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -18,5 +18,5 @@ fn main() {\n     let mut x = Vec::new();\n     let y = vec!(3i);\n     fail!(\"so long\");\n-    x.push_all_move(y);\n+    x.extend(y.into_iter());\n }"}, {"sha": "281523a807ef8a368090ea951c329f7214bbadfb", "filename": "src/test/run-fail/vec-overrun.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-overrun.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -14,8 +14,8 @@\n fn main() {\n     let v: Vec<int> = vec!(10);\n     let x: uint = 0;\n-    assert_eq!(*v.get(x), 10);\n+    assert_eq!(v[x], 10);\n     // Bounds-check failure.\n \n-    assert_eq!(*v.get(x + 2), 20);\n+    assert_eq!(v[x + 2], 20);\n }"}, {"sha": "99dd473344a2bae9ba222c8e440f11bd56c39e54", "filename": "src/test/run-make/bootstrap-from-c-with-native/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"boot#0.1\"]\n+#![crate_name=\"boot\"]\n #![crate_type=\"dylib\"]\n \n extern crate native;"}, {"sha": "14baa8ca55a3978dccbdf65fcf6dcc43098a3957", "filename": "src/test/run-make/dep-info-custom/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Fdep-info-custom%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Fdep-info-custom%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fdep-info-custom%2Flib.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"foo#0.1\"]\n+#![crate_name=\"foo\"]\n \n pub mod foo;\n pub mod bar;"}, {"sha": "dd818cf87986da2bc2f558aa47597ce4bc0b5541", "filename": "src/test/run-make/libs-through-symlinks/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Flibs-through-symlinks%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Flibs-through-symlinks%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flibs-through-symlinks%2Ffoo.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -9,4 +9,4 @@\n // except according to those terms.\n \n #![crate_type = \"rlib\"]\n-#![crate_id = \"foo\"]\n+#![crate_name = \"foo\"]"}, {"sha": "0f6bd10b15d3fe57310f73745dcd7a138ef4e1f3", "filename": "src/test/run-make/lto-syntax-extension/main.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Flto-syntax-extension%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Flto-syntax-extension%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flto-syntax-extension%2Fmain.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -11,8 +11,9 @@\n #![feature(phase)]\n \n extern crate lib;\n-#[phase(plugin)] extern crate fourcc;\n+extern crate regex;\n+#[phase(plugin)] extern crate regex_macros;\n \n fn main() {\n-    fourcc!(\"1234\");\n+    regex!(\"1234\");\n }"}, {"sha": "dbfe920c85ba399fe11c78db684778359accfe9f", "filename": "src/test/run-make/many-crates-but-no-match/crateA1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA1.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateA\"]\n+#![crate_name=\"crateA\"]\n \n // Base crate\n pub fn func<T>() {}"}, {"sha": "857c36aee602585e9ccf06b0ddfc554b4a6c7ccb", "filename": "src/test/run-make/many-crates-but-no-match/crateA2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA2.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateA\"]\n+#![crate_name=\"crateA\"]\n \n // Base crate\n pub fn func<T>() { println!(\"hello\"); }"}, {"sha": "8b8dac5e862a17f5bd8debd0c5dfe9ff7dd667f6", "filename": "src/test/run-make/many-crates-but-no-match/crateA3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA3.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateA\"]\n+#![crate_name=\"crateA\"]\n \n // Base crate\n pub fn foo<T>() { println!(\"world!\"); }"}, {"sha": "c402da7987d5ad4433cf252580ce27d6c3773381", "filename": "src/test/run-make/rustdoc-hidden-line/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2Ffoo.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"foo#0.1\"]\n+#![crate_name=\"foo\"]\n \n /// The '# ' lines should be removed from the output, but the #[deriving] should be\n /// retained."}, {"sha": "d57a7164cdbcea135ea7d41436f5d9909a8d9bc6", "filename": "src/test/run-make/rustdoc-json/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Frustdoc-json%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Frustdoc-json%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-json%2Ffoo.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id = \"foo#0.1\"]\n+#![crate_name = \"foo\"]\n \n //! Very docs\n "}, {"sha": "499bcaff4d1845ed499d3e04f355608ea1c98bf8", "filename": "src/test/run-make/rustdoc-smoke/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Frustdoc-smoke%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Frustdoc-smoke%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-smoke%2Ffoo.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id = \"foo#0.1\"]\n+#![crate_name = \"foo\"]\n \n //! Very docs\n "}, {"sha": "2aa4264225c965b4c9f49f443cc07f4e2002af63", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -34,8 +34,8 @@ fn random_char() -> char {\n \n fn main() {\n     let args = os::args();\n-    let rustc = args.get(1).as_slice();\n-    let tmpdir = Path::new(args.get(2).as_slice());\n+    let rustc = args[1].as_slice();\n+    let tmpdir = Path::new(args[2].as_slice());\n \n     let main_file = tmpdir.join(\"unicode_input_multiple_files_main.rs\");\n     {"}, {"sha": "7b096d7d583a5e6f5126b7dd3c7d28c39daebb6e", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -33,8 +33,8 @@ fn random_char() -> char {\n \n fn main() {\n     let args = os::args();\n-    let rustc = args.get(1).as_slice();\n-    let tmpdir = Path::new(args.get(2).as_slice());\n+    let rustc = args[1].as_slice();\n+    let tmpdir = Path::new(args[2].as_slice());\n     let main_file = tmpdir.join(\"span_main.rs\");\n \n     for _ in range(0u, 100) {"}, {"sha": "b16975fe6eea7068f74f1ab4b702b1f7123663d5", "filename": "src/test/run-pass-fulldeps/syntax-extension-fourcc.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-fourcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-fourcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-fourcc.rs?ref=fb169d5543c84e11038ba2d07b538ec88fb49ca6", "patch": "@@ -1,43 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-stage1\n-// ignore-pretty\n-\n-#![feature(phase)]\n-\n-#[phase(plugin)]\n-extern crate fourcc;\n-\n-static static_val: u32 = fourcc!(\"foo \");\n-static static_val_be: u32 = fourcc!(\"foo \", big);\n-static static_val_le: u32 = fourcc!(\"foo \", little);\n-static static_val_target: u32 = fourcc!(\"foo \", target);\n-\n-fn main() {\n-    let val = fourcc!(\"foo \", big);\n-    assert_eq!(val, 0x666f6f20u32);\n-    assert_eq!(val, fourcc!(\"foo \"));\n-\n-    let val = fourcc!(\"foo \", little);\n-    assert_eq!(val, 0x206f6f66u32);\n-\n-    let val = fourcc!(\"foo \", target);\n-    let exp = if cfg!(target_endian = \"big\") { 0x666f6f20u32 } else { 0x206f6f66u32 };\n-    assert_eq!(val, exp);\n-\n-    assert_eq!(static_val_be, 0x666f6f20u32);\n-    assert_eq!(static_val, static_val_be);\n-    assert_eq!(static_val_le, 0x206f6f66u32);\n-    let exp = if cfg!(target_endian = \"big\") { 0x666f6f20u32 } else { 0x206f6f66u32 };\n-    assert_eq!(static_val_target, exp);\n-\n-    assert_eq!(fourcc!(\"\\xC0\\xFF\\xEE!\"), 0xC0FFEE21);\n-}"}, {"sha": "820606179bc1ecbc9684871b24383d74450210d2", "filename": "src/test/run-pass-fulldeps/syntax-extension-hexfloat.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-hexfloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb169d5543c84e11038ba2d07b538ec88fb49ca6/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-hexfloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-hexfloat.rs?ref=fb169d5543c84e11038ba2d07b538ec88fb49ca6", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-stage1\n-// ignore-pretty\n-\n-#![feature(phase)]\n-#[phase(plugin)]\n-extern crate hexfloat;\n-\n-pub fn main() {\n-    let a = hexfloat!(\"0x1.999999999999ap-4\");\n-    assert_eq!(a, 0.1f64);\n-    let b = hexfloat!(\"-0x1.fffp-4\", f32);\n-    assert_eq!(b, -0.12498474_f32);\n-    let c = hexfloat!(\"0x.12345p5\", f64);\n-    let d = hexfloat!(\"0x0.12345p5\", f64);\n-    assert_eq!(c,d);\n-    let f = hexfloat!(\"0x10.p4\", f32);\n-    let g = hexfloat!(\"0x10.0p4\", f32);\n-    assert_eq!(f,g);\n-}"}, {"sha": "0d90636ec91406159f57e9466918557545267336", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -41,7 +41,7 @@ fn length<A, T: iterable<A>>(x: T) -> uint {\n pub fn main() {\n     let x: Vec<int> = vec!(0,1,2,3);\n     // Call a method\n-    x.iterate(|y| { assert!(*x.get(*y as uint) == *y); true });\n+    x.iterate(|y| { assert!(x[*y as uint] == *y); true });\n     // Call a parameterized function\n     assert_eq!(length(x.clone()), x.len());\n     // Call a parameterized function, with type arguments that require"}, {"sha": "4962e9d0f22590c48a9bec95c5d7574ccf157fab", "filename": "src/test/run-pass/bare-fn-implements-fn-mut.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fbare-fn-implements-fn-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fbare-fn-implements-fn-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbare-fn-implements-fn-mut.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -25,8 +25,9 @@ fn call_g<G:FnMut<(String,String),String>>(mut g: G, x: String, y: String)\n     g(x, y)\n }\n \n-fn g(x: String, y: String) -> String {\n-    x.append(y.as_slice())\n+fn g(mut x: String, y: String) -> String {\n+    x.push_str(y.as_slice());\n+    x\n }\n \n fn main() {"}, {"sha": "e644c49366d44022f4f010622472c0b425861a7a", "filename": "src/test/run-pass/borrowck-mut-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -23,7 +23,7 @@ fn add_int(x: &mut Ints, v: int) {\n \n fn iter_ints(x: &Ints, f: |x: &int| -> bool) -> bool {\n     let l = x.values.len();\n-    range(0u, l).all(|i| f(x.values.get(i)))\n+    range(0u, l).all(|i| f(&x.values[i]))\n }\n \n pub fn main() {"}, {"sha": "432d022c69b779a2a6f05c66b6504fcb7506be56", "filename": "src/test/run-pass/call-closure-from-overloaded-op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fcall-closure-from-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fcall-closure-from-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcall-closure-from-overloaded-op.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -14,5 +14,5 @@ fn foo() -> int { 22 }\n pub fn main() {\n     let mut x: Vec<extern \"Rust\" fn() -> int> = Vec::new();\n     x.push(foo);\n-    assert_eq!((*x.get(0))(), 22);\n+    assert_eq!((x[0])(), 22);\n }"}, {"sha": "646eed5de7537b43dd6ec37bb9521ea2d95a5369", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-rcvr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -10,11 +10,11 @@\n \n \n fn bar(v: &mut [uint]) -> Vec<uint> {\n-    Vec::from_slice(v)\n+    v.to_vec()\n }\n \n fn bip(v: &[uint]) -> Vec<uint> {\n-    Vec::from_slice(v)\n+    v.to_vec()\n }\n \n pub fn main() {"}, {"sha": "8c0c0afa94ba7199db39bc965fe009475f226788", "filename": "src/test/run-pass/drop-with-type-ascription-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-1.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     let foo = \"hello\".to_string();\n     let foo: Vec<&str> = foo.as_slice().words().collect();\n-    let invalid_string = foo.get(0);\n+    let invalid_string = &foo[0];\n     assert_eq!(*invalid_string, \"hello\");\n }\n "}, {"sha": "f55f47bbc59dec9b9c253aae9ea0881f44f8eafb", "filename": "src/test/run-pass/drop-with-type-ascription-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-2.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -10,8 +10,8 @@\n \n fn main() {\n     let args = vec!(\"foobie\", \"asdf::asdf\");\n-    let arr: Vec<&str> = args.get(1).as_slice().split_str(\"::\").collect();\n-    assert_eq!(*arr.get(0), \"asdf\");\n-    assert_eq!(*arr.get(0), \"asdf\");\n+    let arr: Vec<&str> = args[1].as_slice().split_str(\"::\").collect();\n+    assert_eq!(arr[0], \"asdf\");\n+    assert_eq!(arr[0], \"asdf\");\n }\n "}, {"sha": "8172c16abf2a66ed8bbd465b1a6d0197263c48e6", "filename": "src/test/run-pass/expr-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-fn.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -17,7 +17,7 @@ fn test_int() {\n fn test_vec() {\n     fn f() -> Vec<int> { vec!(10, 11) }\n     let vect = f();\n-    assert_eq!(*vect.get(1), 11);\n+    assert_eq!(vect[1], 11);\n }\n \n fn test_generic() {"}, {"sha": "1f246581687b1317cf4bcfd3d2d6a5aa87676f0b", "filename": "src/test/run-pass/expr-match-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fexpr-match-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fexpr-match-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-fail.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -16,7 +16,7 @@ fn test_simple() {\n \n fn test_box() {\n     let r = match true { true => { vec!(10i) } false => { fail!() } };\n-    assert_eq!(*r.get(0), 10i);\n+    assert_eq!(r[0], 10i);\n }\n \n pub fn main() { test_simple(); test_box(); }"}, {"sha": "af6ca3c93d5cf915596cb6be0dc71eb6c145de2d", "filename": "src/test/run-pass/foreach-nested.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -17,8 +17,8 @@ pub fn main() {\n     two(|i| {\n         two(|j| { *a.get_mut(p as uint) = 10 * i + j; p += 1; })\n     });\n-    assert_eq!(*a.get(0), 0);\n-    assert_eq!(*a.get(1), 1);\n-    assert_eq!(*a.get(2), 10);\n-    assert_eq!(*a.get(3), 11);\n+    assert_eq!(a[0], 0);\n+    assert_eq!(a[1], 1);\n+    assert_eq!(a[2], 10);\n+    assert_eq!(a[3], 11);\n }"}, {"sha": "87afd1601f6bdbc19776242561dd3aad0cd8c841", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -52,7 +52,7 @@ mod map_reduce {\n             }\n             let (tx, rx) = channel();\n             println!(\"sending find_reducer\");\n-            ctrl.send(find_reducer(Vec::from_slice(key.as_bytes()), tx));\n+            ctrl.send(find_reducer(key.as_bytes().to_vec(), tx));\n             println!(\"receiving\");\n             let c = rx.recv();\n             println!(\"{}\", c);"}, {"sha": "047ff74035b0f3cffa60bc6f561010a48f61878a", "filename": "src/test/run-pass/issue-13304.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5d97b55d6487ee23b805bc1acbaa0669b82116/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13304.rs?ref=9d5d97b55d6487ee23b805bc1acbaa0669b82116", "patch": "@@ -29,7 +29,7 @@ fn parent() {\n     let args = args.as_slice();\n     let mut p = io::process::Command::new(args[0].as_slice())\n                                      .arg(\"child\").spawn().unwrap();\n-    p.stdin.get_mut_ref().write_str(\"test1\\ntest2\\ntest3\").unwrap();\n+    p.stdin.as_mut().unwrap().write_str(\"test1\\ntest2\\ntest3\").unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(out.status.success());\n     let s = str::from_utf8(out.output.as_slice()).unwrap();"}]}