{"sha": "d705ad28a0129ec52c686d3476b731590ca207b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MDVhZDI4YTAxMjllYzUyYzY4NmQzNDc2YjczMTU5MGNhMjA3Yjc=", "commit": {"author": {"name": "Josh White", "email": "jwhite927@gmail.com", "date": "2020-02-08T21:30:40Z"}, "committer": {"name": "Josh White", "email": "jwhite927@gmail.com", "date": "2020-02-08T21:30:40Z"}, "message": "Merge branch 'master' of https://github.com/jwhite927/rust into E0637", "tree": {"sha": "a01e215c90c75dbfe5bc044a5e8b52c3a9bfd2bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a01e215c90c75dbfe5bc044a5e8b52c3a9bfd2bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d705ad28a0129ec52c686d3476b731590ca207b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d705ad28a0129ec52c686d3476b731590ca207b7", "html_url": "https://github.com/rust-lang/rust/commit/d705ad28a0129ec52c686d3476b731590ca207b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d705ad28a0129ec52c686d3476b731590ca207b7/comments", "author": {"login": "jwhite927", "id": 48882175, "node_id": "MDQ6VXNlcjQ4ODgyMTc1", "avatar_url": "https://avatars.githubusercontent.com/u/48882175?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwhite927", "html_url": "https://github.com/jwhite927", "followers_url": "https://api.github.com/users/jwhite927/followers", "following_url": "https://api.github.com/users/jwhite927/following{/other_user}", "gists_url": "https://api.github.com/users/jwhite927/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwhite927/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwhite927/subscriptions", "organizations_url": "https://api.github.com/users/jwhite927/orgs", "repos_url": "https://api.github.com/users/jwhite927/repos", "events_url": "https://api.github.com/users/jwhite927/events{/privacy}", "received_events_url": "https://api.github.com/users/jwhite927/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwhite927", "id": 48882175, "node_id": "MDQ6VXNlcjQ4ODgyMTc1", "avatar_url": "https://avatars.githubusercontent.com/u/48882175?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwhite927", "html_url": "https://github.com/jwhite927", "followers_url": "https://api.github.com/users/jwhite927/followers", "following_url": "https://api.github.com/users/jwhite927/following{/other_user}", "gists_url": "https://api.github.com/users/jwhite927/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwhite927/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwhite927/subscriptions", "organizations_url": "https://api.github.com/users/jwhite927/orgs", "repos_url": "https://api.github.com/users/jwhite927/repos", "events_url": "https://api.github.com/users/jwhite927/events{/privacy}", "received_events_url": "https://api.github.com/users/jwhite927/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d54bb28b30d26688f71cff672c68ed4fe00ab1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d54bb28b30d26688f71cff672c68ed4fe00ab1e", "html_url": "https://github.com/rust-lang/rust/commit/9d54bb28b30d26688f71cff672c68ed4fe00ab1e"}, {"sha": "85ffd44d3d86214fc06be4add039e26f85261a2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/85ffd44d3d86214fc06be4add039e26f85261a2b", "html_url": "https://github.com/rust-lang/rust/commit/85ffd44d3d86214fc06be4add039e26f85261a2b"}], "stats": {"total": 1036, "additions": 884, "deletions": 152}, "files": [{"sha": "be9d832ed90f6b66800c7664640826110cb4dbbc", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -385,12 +385,14 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n                 }\n                 Some(Equal) => {\n                     self.is_empty = Some(true);\n+                    self.start = plus_n.clone();\n                     return Some(plus_n);\n                 }\n                 _ => {}\n             }\n         }\n \n+        self.start = self.end.clone();\n         self.is_empty = Some(true);\n         None\n     }\n@@ -477,12 +479,14 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n                 }\n                 Some(Equal) => {\n                     self.is_empty = Some(true);\n+                    self.end = minus_n.clone();\n                     return Some(minus_n);\n                 }\n                 _ => {}\n             }\n         }\n \n+        self.end = self.start.clone();\n         self.is_empty = Some(true);\n         None\n     }"}, {"sha": "6c0bc6bbbad2266cfbb5ce1c945d43643f952117", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -343,38 +343,21 @@ pub struct RangeInclusive<Idx> {\n     pub(crate) is_empty: Option<bool>,\n     // This field is:\n     //  - `None` when next() or next_back() was never called\n-    //  - `Some(false)` when `start <= end` assuming no overflow\n-    //  - `Some(true)` otherwise\n+    //  - `Some(false)` when `start < end`\n+    //  - `Some(true)` when `end < start`\n+    //  - `Some(false)` when `start == end` and the range hasn't yet completed iteration\n+    //  - `Some(true)` when `start == end` and the range has completed iteration\n     // The field cannot be a simple `bool` because the `..=` constructor can\n     // accept non-PartialOrd types, also we want the constructor to be const.\n }\n \n-trait RangeInclusiveEquality: Sized {\n-    fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool;\n-}\n-\n-impl<T> RangeInclusiveEquality for T {\n-    #[inline]\n-    default fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool {\n-        range.is_empty.unwrap_or_default()\n-    }\n-}\n-\n-impl<T: PartialOrd> RangeInclusiveEquality for T {\n-    #[inline]\n-    fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool {\n-        range.is_empty()\n-    }\n-}\n-\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<Idx: PartialEq> PartialEq for RangeInclusive<Idx> {\n     #[inline]\n     fn eq(&self, other: &Self) -> bool {\n         self.start == other.start\n             && self.end == other.end\n-            && RangeInclusiveEquality::canonicalized_is_empty(self)\n-                == RangeInclusiveEquality::canonicalized_is_empty(other)\n+            && self.is_exhausted() == other.is_exhausted()\n     }\n }\n \n@@ -386,7 +369,8 @@ impl<Idx: Hash> Hash for RangeInclusive<Idx> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.start.hash(state);\n         self.end.hash(state);\n-        RangeInclusiveEquality::canonicalized_is_empty(self).hash(state);\n+        // Ideally we would hash `is_exhausted` here as well, but there's no\n+        // way for us to call it.\n     }\n }\n \n@@ -485,6 +469,14 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     }\n }\n \n+impl<Idx: PartialEq<Idx>> RangeInclusive<Idx> {\n+    // Returns true if this is a range that started non-empty, and was iterated\n+    // to exhaustion.\n+    fn is_exhausted(&self) -> bool {\n+        Some(true) == self.is_empty && self.start == self.end\n+    }\n+}\n+\n impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///"}, {"sha": "e79a775325f4ac09dd9e10ea56716b76778a5b16", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 51, "deletions": 29, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -5584,21 +5584,18 @@ where\n \n #[doc(hidden)]\n // intermediate trait for specialization of slice's PartialOrd\n-trait SlicePartialOrd<B> {\n-    fn partial_compare(&self, other: &[B]) -> Option<Ordering>;\n+trait SlicePartialOrd: Sized {\n+    fn partial_compare(left: &[Self], right: &[Self]) -> Option<Ordering>;\n }\n \n-impl<A> SlicePartialOrd<A> for [A]\n-where\n-    A: PartialOrd,\n-{\n-    default fn partial_compare(&self, other: &[A]) -> Option<Ordering> {\n-        let l = cmp::min(self.len(), other.len());\n+impl<A: PartialOrd> SlicePartialOrd for A {\n+    default fn partial_compare(left: &[A], right: &[A]) -> Option<Ordering> {\n+        let l = cmp::min(left.len(), right.len());\n \n         // Slice to the loop iteration range to enable bound check\n         // elimination in the compiler\n-        let lhs = &self[..l];\n-        let rhs = &other[..l];\n+        let lhs = &left[..l];\n+        let rhs = &right[..l];\n \n         for i in 0..l {\n             match lhs[i].partial_cmp(&rhs[i]) {\n@@ -5607,36 +5604,61 @@ where\n             }\n         }\n \n-        self.len().partial_cmp(&other.len())\n+        left.len().partial_cmp(&right.len())\n     }\n }\n \n-impl<A> SlicePartialOrd<A> for [A]\n+// This is the impl that we would like to have. Unfortunately it's not sound.\n+// See `partial_ord_slice.rs`.\n+/*\n+impl<A> SlicePartialOrd for A\n where\n     A: Ord,\n {\n-    default fn partial_compare(&self, other: &[A]) -> Option<Ordering> {\n-        Some(SliceOrd::compare(self, other))\n+    default fn partial_compare(left: &[A], right: &[A]) -> Option<Ordering> {\n+        Some(SliceOrd::compare(left, right))\n+    }\n+}\n+*/\n+\n+impl<A: AlwaysApplicableOrd> SlicePartialOrd for A {\n+    fn partial_compare(left: &[A], right: &[A]) -> Option<Ordering> {\n+        Some(SliceOrd::compare(left, right))\n+    }\n+}\n+\n+trait AlwaysApplicableOrd: SliceOrd + Ord {}\n+\n+macro_rules! always_applicable_ord {\n+    ($([$($p:tt)*] $t:ty,)*) => {\n+        $(impl<$($p)*> AlwaysApplicableOrd for $t {})*\n     }\n }\n \n+always_applicable_ord! {\n+    [] u8, [] u16, [] u32, [] u64, [] u128, [] usize,\n+    [] i8, [] i16, [] i32, [] i64, [] i128, [] isize,\n+    [] bool, [] char,\n+    [T: ?Sized] *const T, [T: ?Sized] *mut T,\n+    [T: AlwaysApplicableOrd] &T,\n+    [T: AlwaysApplicableOrd] &mut T,\n+    [T: AlwaysApplicableOrd] Option<T>,\n+}\n+\n #[doc(hidden)]\n // intermediate trait for specialization of slice's Ord\n-trait SliceOrd<B> {\n-    fn compare(&self, other: &[B]) -> Ordering;\n+trait SliceOrd: Sized {\n+    fn compare(left: &[Self], right: &[Self]) -> Ordering;\n }\n \n-impl<A> SliceOrd<A> for [A]\n-where\n-    A: Ord,\n-{\n-    default fn compare(&self, other: &[A]) -> Ordering {\n-        let l = cmp::min(self.len(), other.len());\n+impl<A: Ord> SliceOrd for A {\n+    default fn compare(left: &[Self], right: &[Self]) -> Ordering {\n+        let l = cmp::min(left.len(), right.len());\n \n         // Slice to the loop iteration range to enable bound check\n         // elimination in the compiler\n-        let lhs = &self[..l];\n-        let rhs = &other[..l];\n+        let lhs = &left[..l];\n+        let rhs = &right[..l];\n \n         for i in 0..l {\n             match lhs[i].cmp(&rhs[i]) {\n@@ -5645,19 +5667,19 @@ where\n             }\n         }\n \n-        self.len().cmp(&other.len())\n+        left.len().cmp(&right.len())\n     }\n }\n \n // memcmp compares a sequence of unsigned bytes lexicographically.\n // this matches the order we want for [u8], but no others (not even [i8]).\n-impl SliceOrd<u8> for [u8] {\n+impl SliceOrd for u8 {\n     #[inline]\n-    fn compare(&self, other: &[u8]) -> Ordering {\n+    fn compare(left: &[Self], right: &[Self]) -> Ordering {\n         let order =\n-            unsafe { memcmp(self.as_ptr(), other.as_ptr(), cmp::min(self.len(), other.len())) };\n+            unsafe { memcmp(left.as_ptr(), right.as_ptr(), cmp::min(left.len(), right.len())) };\n         if order == 0 {\n-            self.len().cmp(&other.len())\n+            left.len().cmp(&right.len())\n         } else if order < 0 {\n             Less\n         } else {"}, {"sha": "734b3ba7c6bbaea9ad3bbce7f9c76f54d6a9d058", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -12,7 +12,7 @@ use self::pattern::{DoubleEndedSearcher, ReverseSearcher, SearchStep, Searcher};\n use crate::char;\n use crate::fmt::{self, Write};\n use crate::iter::{Chain, FlatMap, Flatten};\n-use crate::iter::{Cloned, Filter, FusedIterator, Map, TrustedLen, TrustedRandomAccess};\n+use crate::iter::{Copied, Filter, FusedIterator, Map, TrustedLen, TrustedRandomAccess};\n use crate::mem;\n use crate::ops::Try;\n use crate::option;\n@@ -750,7 +750,7 @@ impl<'a> CharIndices<'a> {\n /// [`str`]: ../../std/primitive.str.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone, Debug)]\n-pub struct Bytes<'a>(Cloned<slice::Iter<'a, u8>>);\n+pub struct Bytes<'a>(Copied<slice::Iter<'a, u8>>);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for Bytes<'_> {\n@@ -2778,7 +2778,7 @@ impl str {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn bytes(&self) -> Bytes<'_> {\n-        Bytes(self.as_bytes().iter().cloned())\n+        Bytes(self.as_bytes().iter().copied())\n     }\n \n     /// Splits a string slice by whitespace.\n@@ -3895,7 +3895,7 @@ impl str {\n             debug_assert_eq!(\n                 start, 0,\n                 \"The first search step from Searcher \\\n-                must include the first character\"\n+                 must include the first character\"\n             );\n             // SAFETY: `Searcher` is known to return valid indices.\n             unsafe { Some(self.get_unchecked(len..)) }\n@@ -3934,7 +3934,7 @@ impl str {\n                 end,\n                 self.len(),\n                 \"The first search step from ReverseSearcher \\\n-                must include the last character\"\n+                 must include the last character\"\n             );\n             // SAFETY: `Searcher` is known to return valid indices.\n             unsafe { Some(self.get_unchecked(..start)) }"}, {"sha": "5b41ef350657fe491dd7b6cbd34edb48ee3544b1", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -1956,11 +1956,19 @@ fn test_range_inclusive_exhaustion() {\n     assert_eq!(r.next(), None);\n     assert_eq!(r.next(), None);\n \n+    assert_eq!(*r.start(), 10);\n+    assert_eq!(*r.end(), 10);\n+    assert_ne!(r, 10..=10);\n+\n     let mut r = 10..=10;\n     assert_eq!(r.next_back(), Some(10));\n     assert!(r.is_empty());\n     assert_eq!(r.next_back(), None);\n \n+    assert_eq!(*r.start(), 10);\n+    assert_eq!(*r.end(), 10);\n+    assert_ne!(r, 10..=10);\n+\n     let mut r = 10..=12;\n     assert_eq!(r.next(), Some(10));\n     assert_eq!(r.next(), Some(11));\n@@ -2078,6 +2086,9 @@ fn test_range_inclusive_nth() {\n     assert_eq!((10..=15).nth(5), Some(15));\n     assert_eq!((10..=15).nth(6), None);\n \n+    let mut exhausted_via_next = 10_u8..=20;\n+    while exhausted_via_next.next().is_some() {}\n+\n     let mut r = 10_u8..=20;\n     assert_eq!(r.nth(2), Some(12));\n     assert_eq!(r, 13..=20);\n@@ -2087,6 +2098,7 @@ fn test_range_inclusive_nth() {\n     assert_eq!(ExactSizeIterator::is_empty(&r), false);\n     assert_eq!(r.nth(10), None);\n     assert_eq!(r.is_empty(), true);\n+    assert_eq!(r, exhausted_via_next);\n     assert_eq!(ExactSizeIterator::is_empty(&r), true);\n }\n \n@@ -2098,6 +2110,9 @@ fn test_range_inclusive_nth_back() {\n     assert_eq!((10..=15).nth_back(6), None);\n     assert_eq!((-120..=80_i8).nth_back(200), Some(-120));\n \n+    let mut exhausted_via_next_back = 10_u8..=20;\n+    while exhausted_via_next_back.next_back().is_some() {}\n+\n     let mut r = 10_u8..=20;\n     assert_eq!(r.nth_back(2), Some(18));\n     assert_eq!(r, 10..=17);\n@@ -2107,6 +2122,7 @@ fn test_range_inclusive_nth_back() {\n     assert_eq!(ExactSizeIterator::is_empty(&r), false);\n     assert_eq!(r.nth_back(10), None);\n     assert_eq!(r.is_empty(), true);\n+    assert_eq!(r, exhausted_via_next_back);\n     assert_eq!(ExactSizeIterator::is_empty(&r), true);\n }\n "}, {"sha": "c8bac5aebc6340a667ac7ff36d3eccef0147d635", "filename": "src/librustc_target/abi/call/aarch64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -6,7 +6,7 @@ where\n     Ty: TyLayoutMethods<'a, C> + Copy,\n     C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n {\n-    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         let size = arg.layout.size;\n \n         // Ensure we have at most four uniquely addressable members."}, {"sha": "59ec87e3c9e095c0aeafed053ad24c1049a50a0c", "filename": "src/librustc_target/abi/call/arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -7,7 +7,7 @@ where\n     Ty: TyLayoutMethods<'a, C> + Copy,\n     C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n {\n-    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         let size = arg.layout.size;\n \n         // Ensure we have at most four uniquely addressable members."}, {"sha": "e3cbf176c350eb6bf678dbf55ffa618ab5ae5302", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 104, "deletions": 59, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -219,26 +219,47 @@ impl CastTarget {\n     }\n }\n \n-/// Returns value from the `homogeneous_aggregate` test function.\n+/// Return value from the `homogeneous_aggregate` test function.\n #[derive(Copy, Clone, Debug)]\n pub enum HomogeneousAggregate {\n     /// Yes, all the \"leaf fields\" of this struct are passed in the\n     /// same way (specified in the `Reg` value).\n     Homogeneous(Reg),\n \n-    /// There are distinct leaf fields passed in different ways,\n-    /// or this is uninhabited.\n-    Heterogeneous,\n-\n     /// There are no leaf fields at all.\n     NoData,\n }\n \n+/// Error from the `homogeneous_aggregate` test function, indicating\n+/// there are distinct leaf fields passed in different ways,\n+/// or this is uninhabited.\n+#[derive(Copy, Clone, Debug)]\n+pub struct Heterogeneous;\n+\n impl HomogeneousAggregate {\n     /// If this is a homogeneous aggregate, returns the homogeneous\n     /// unit, else `None`.\n     pub fn unit(self) -> Option<Reg> {\n-        if let HomogeneousAggregate::Homogeneous(r) = self { Some(r) } else { None }\n+        match self {\n+            HomogeneousAggregate::Homogeneous(reg) => Some(reg),\n+            HomogeneousAggregate::NoData => None,\n+        }\n+    }\n+\n+    /// Try to combine two `HomogeneousAggregate`s, e.g. from two fields in\n+    /// the same `struct`. Only succeeds if only one of them has any data,\n+    /// or both units are identical.\n+    fn merge(self, other: HomogeneousAggregate) -> Result<HomogeneousAggregate, Heterogeneous> {\n+        match (self, other) {\n+            (x, HomogeneousAggregate::NoData) | (HomogeneousAggregate::NoData, x) => Ok(x),\n+\n+            (HomogeneousAggregate::Homogeneous(a), HomogeneousAggregate::Homogeneous(b)) => {\n+                if a != b {\n+                    return Err(Heterogeneous);\n+                }\n+                Ok(self)\n+            }\n+        }\n     }\n }\n \n@@ -250,8 +271,8 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n         }\n     }\n \n-    /// Returns `true` if this layout is an aggregate containing fields of only\n-    /// a single type (e.g., `(u32, u32)`). Such aggregates are often\n+    /// Returns `Homogeneous` if this layout is an aggregate containing fields of\n+    /// only a single type (e.g., `(u32, u32)`). Such aggregates are often\n     /// special-cased in ABIs.\n     ///\n     /// Note: We generally ignore fields of zero-sized type when computing\n@@ -260,94 +281,118 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n     /// This is public so that it can be used in unit tests, but\n     /// should generally only be relevant to the ABI details of\n     /// specific targets.\n-    pub fn homogeneous_aggregate<C>(&self, cx: &C) -> HomogeneousAggregate\n+    pub fn homogeneous_aggregate<C>(&self, cx: &C) -> Result<HomogeneousAggregate, Heterogeneous>\n     where\n         Ty: TyLayoutMethods<'a, C> + Copy,\n         C: LayoutOf<Ty = Ty, TyLayout = Self>,\n     {\n         match self.abi {\n-            Abi::Uninhabited => HomogeneousAggregate::Heterogeneous,\n+            Abi::Uninhabited => Err(Heterogeneous),\n \n             // The primitive for this algorithm.\n             Abi::Scalar(ref scalar) => {\n                 let kind = match scalar.value {\n                     abi::Int(..) | abi::Pointer => RegKind::Integer,\n                     abi::F32 | abi::F64 => RegKind::Float,\n                 };\n-                HomogeneousAggregate::Homogeneous(Reg { kind, size: self.size })\n+                Ok(HomogeneousAggregate::Homogeneous(Reg { kind, size: self.size }))\n             }\n \n             Abi::Vector { .. } => {\n                 assert!(!self.is_zst());\n-                HomogeneousAggregate::Homogeneous(Reg { kind: RegKind::Vector, size: self.size })\n+                Ok(HomogeneousAggregate::Homogeneous(Reg {\n+                    kind: RegKind::Vector,\n+                    size: self.size,\n+                }))\n             }\n \n             Abi::ScalarPair(..) | Abi::Aggregate { .. } => {\n-                let mut total = Size::ZERO;\n-                let mut result = None;\n-\n-                let is_union = match self.fields {\n-                    FieldPlacement::Array { count, .. } => {\n-                        if count > 0 {\n-                            return self.field(cx, 0).homogeneous_aggregate(cx);\n-                        } else {\n-                            return HomogeneousAggregate::NoData;\n-                        }\n-                    }\n-                    FieldPlacement::Union(_) => true,\n-                    FieldPlacement::Arbitrary { .. } => false,\n-                };\n+                // Helper for computing `homogenous_aggregate`, allowing a custom\n+                // starting offset (used below for handling variants).\n+                let from_fields_at =\n+                    |layout: Self,\n+                     start: Size|\n+                     -> Result<(HomogeneousAggregate, Size), Heterogeneous> {\n+                        let is_union = match layout.fields {\n+                            FieldPlacement::Array { count, .. } => {\n+                                assert_eq!(start, Size::ZERO);\n+\n+                                let result = if count > 0 {\n+                                    layout.field(cx, 0).homogeneous_aggregate(cx)?\n+                                } else {\n+                                    HomogeneousAggregate::NoData\n+                                };\n+                                return Ok((result, layout.size));\n+                            }\n+                            FieldPlacement::Union(_) => true,\n+                            FieldPlacement::Arbitrary { .. } => false,\n+                        };\n \n-                for i in 0..self.fields.count() {\n-                    if !is_union && total != self.fields.offset(i) {\n-                        return HomogeneousAggregate::Heterogeneous;\n-                    }\n+                        let mut result = HomogeneousAggregate::NoData;\n+                        let mut total = start;\n \n-                    let field = self.field(cx, i);\n+                        for i in 0..layout.fields.count() {\n+                            if !is_union && total != layout.fields.offset(i) {\n+                                return Err(Heterogeneous);\n+                            }\n \n-                    match (result, field.homogeneous_aggregate(cx)) {\n-                        (_, HomogeneousAggregate::NoData) => {\n-                            // Ignore fields that have no data\n-                        }\n-                        (_, HomogeneousAggregate::Heterogeneous) => {\n-                            // The field itself must be a homogeneous aggregate.\n-                            return HomogeneousAggregate::Heterogeneous;\n-                        }\n-                        // If this is the first field, record the unit.\n-                        (None, HomogeneousAggregate::Homogeneous(unit)) => {\n-                            result = Some(unit);\n-                        }\n-                        // For all following fields, the unit must be the same.\n-                        (Some(prev_unit), HomogeneousAggregate::Homogeneous(unit)) => {\n-                            if prev_unit != unit {\n-                                return HomogeneousAggregate::Heterogeneous;\n+                            let field = layout.field(cx, i);\n+\n+                            result = result.merge(field.homogeneous_aggregate(cx)?)?;\n+\n+                            // Keep track of the offset (without padding).\n+                            let size = field.size;\n+                            if is_union {\n+                                total = total.max(size);\n+                            } else {\n+                                total += size;\n                             }\n                         }\n-                    }\n \n-                    // Keep track of the offset (without padding).\n-                    let size = field.size;\n-                    if is_union {\n-                        total = total.max(size);\n-                    } else {\n-                        total += size;\n+                        Ok((result, total))\n+                    };\n+\n+                let (mut result, mut total) = from_fields_at(*self, Size::ZERO)?;\n+\n+                match &self.variants {\n+                    abi::Variants::Single { .. } => {}\n+                    abi::Variants::Multiple { variants, .. } => {\n+                        // Treat enum variants like union members.\n+                        // HACK(eddyb) pretend the `enum` field (discriminant)\n+                        // is at the start of every variant (otherwise the gap\n+                        // at the start of all variants would disqualify them).\n+                        //\n+                        // NB: for all tagged `enum`s (which include all non-C-like\n+                        // `enum`s with defined FFI representation), this will\n+                        // match the homogenous computation on the equivalent\n+                        // `struct { tag; union { variant1; ... } }` and/or\n+                        // `union { struct { tag; variant1; } ... }`\n+                        // (the offsets of variant fields should be identical\n+                        // between the two for either to be a homogenous aggregate).\n+                        let variant_start = total;\n+                        for variant_idx in variants.indices() {\n+                            let (variant_result, variant_total) =\n+                                from_fields_at(self.for_variant(cx, variant_idx), variant_start)?;\n+\n+                            result = result.merge(variant_result)?;\n+                            total = total.max(variant_total);\n+                        }\n                     }\n                 }\n \n                 // There needs to be no padding.\n                 if total != self.size {\n-                    HomogeneousAggregate::Heterogeneous\n+                    Err(Heterogeneous)\n                 } else {\n                     match result {\n-                        Some(reg) => {\n+                        HomogeneousAggregate::Homogeneous(_) => {\n                             assert_ne!(total, Size::ZERO);\n-                            HomogeneousAggregate::Homogeneous(reg)\n                         }\n-                        None => {\n+                        HomogeneousAggregate::NoData => {\n                             assert_eq!(total, Size::ZERO);\n-                            HomogeneousAggregate::NoData\n                         }\n                     }\n+                    Ok(result)\n                 }\n             }\n         }"}, {"sha": "93c4e97de10b94308b49b89c149f27f6a86d7fa2", "filename": "src/librustc_target/abi/call/powerpc64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -22,7 +22,7 @@ where\n     Ty: TyLayoutMethods<'a, C> + Copy,\n     C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n {\n-    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         // ELFv1 only passes one-member aggregates transparently.\n         // ELFv2 passes up to eight uniquely addressable members.\n         if (abi == ELFv1 && arg.layout.size > unit.size)"}, {"sha": "c80f8316feb72cde3352dc6d5ef522bc9008a80a", "filename": "src/librustc_target/abi/call/sparc64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -8,7 +8,7 @@ where\n     Ty: TyLayoutMethods<'a, C> + Copy,\n     C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n {\n-    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         // Ensure we have at most eight uniquely addressable members.\n         if arg.layout.size > unit.size.checked_mul(8, cx).unwrap() {\n             return None;"}, {"sha": "9aab64ef272b2ccd0c2f6ca808a35e228e6f6517", "filename": "src/librustc_target/abi/call/wasm32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -7,7 +7,7 @@ where\n     C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n {\n     if val.layout.is_aggregate() {\n-        if let Some(unit) = val.layout.homogeneous_aggregate(cx).unit() {\n+        if let Some(unit) = val.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()) {\n             let size = val.layout.size;\n             if unit.size == size {\n                 val.cast_to(Uniform { unit, total: size });"}, {"sha": "e776a8b3fe4a96d0f215100d6e210e2956ae80cc", "filename": "src/librustc_target/abi/call/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -100,7 +100,7 @@ where\n             };\n \n             // At this point we know this must be a primitive of sorts.\n-            let unit = arg.layout.homogeneous_aggregate(cx).unit().unwrap();\n+            let unit = arg.layout.homogeneous_aggregate(cx).unwrap().unit().unwrap();\n             assert_eq!(unit.size, arg.layout.size);\n             if unit.kind == RegKind::Float {\n                 continue;"}, {"sha": "4c192c46786befb34b17df34686d0a069c02bc06", "filename": "src/librustc_target/abi/call/x86_64.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -56,16 +56,24 @@ where\n \n             Abi::Vector { .. } => Class::Sse,\n \n-            Abi::ScalarPair(..) | Abi::Aggregate { .. } => match layout.variants {\n-                abi::Variants::Single { .. } => {\n-                    for i in 0..layout.fields.count() {\n-                        let field_off = off + layout.fields.offset(i);\n-                        classify(cx, layout.field(cx, i), cls, field_off)?;\n+            Abi::ScalarPair(..) | Abi::Aggregate { .. } => {\n+                for i in 0..layout.fields.count() {\n+                    let field_off = off + layout.fields.offset(i);\n+                    classify(cx, layout.field(cx, i), cls, field_off)?;\n+                }\n+\n+                match &layout.variants {\n+                    abi::Variants::Single { .. } => {}\n+                    abi::Variants::Multiple { variants, .. } => {\n+                        // Treat enum variants like union members.\n+                        for variant_idx in variants.indices() {\n+                            classify(cx, layout.for_variant(cx, variant_idx), cls, off)?;\n+                        }\n                     }\n-                    return Ok(());\n                 }\n-                abi::Variants::Multiple { .. } => return Err(Memory),\n-            },\n+\n+                return Ok(());\n+            }\n         };\n \n         // Fill in `cls` for scalars (Int/Sse) and vectors (Sse)."}, {"sha": "c1fe8b7743a8cc7751bfde7699a22abb33effe0f", "filename": "src/test/auxiliary/rust_test_helpers.c", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fauxiliary%2Frust_test_helpers.c", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fauxiliary%2Frust_test_helpers.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Frust_test_helpers.c?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -300,3 +300,87 @@ __int128 sub(__int128 a, __int128 b) {\n }\n \n #endif\n+\n+#define OPTION_TAG_NONE (0)\n+#define OPTION_TAG_SOME (1)\n+\n+struct U8TaggedEnumOptionU64 {\n+    uint8_t tag;\n+    union {\n+        uint64_t some;\n+    };\n+};\n+\n+struct U8TaggedEnumOptionU64\n+rust_dbg_new_some_u64(uint64_t some) {\n+    struct U8TaggedEnumOptionU64 r = {\n+        .tag = OPTION_TAG_SOME,\n+        .some = some,\n+    };\n+    return r;\n+}\n+\n+struct U8TaggedEnumOptionU64\n+rust_dbg_new_none_u64(void) {\n+    struct U8TaggedEnumOptionU64 r = {\n+        .tag = OPTION_TAG_NONE,\n+    };\n+    return r;\n+}\n+\n+int32_t\n+rust_dbg_unpack_option_u64(struct U8TaggedEnumOptionU64 o, uint64_t *into) {\n+    assert(into);\n+    switch (o.tag) {\n+    case OPTION_TAG_SOME:\n+        *into = o.some;\n+        return 1;\n+    case OPTION_TAG_NONE:\n+        return 0;\n+    default:\n+        assert(0 && \"unexpected tag\");\n+    }\n+}\n+\n+struct U8TaggedEnumOptionU64U64 {\n+    uint8_t tag;\n+    union {\n+        struct {\n+            uint64_t a;\n+            uint64_t b;\n+        } some;\n+    };\n+};\n+\n+struct U8TaggedEnumOptionU64U64\n+rust_dbg_new_some_u64u64(uint64_t a, uint64_t b) {\n+    struct U8TaggedEnumOptionU64U64 r = {\n+        .tag = OPTION_TAG_SOME,\n+        .some = { .a = a, .b = b },\n+    };\n+    return r;\n+}\n+\n+struct U8TaggedEnumOptionU64U64\n+rust_dbg_new_none_u64u64(void) {\n+    struct U8TaggedEnumOptionU64U64 r = {\n+        .tag = OPTION_TAG_NONE,\n+    };\n+    return r;\n+}\n+\n+int32_t\n+rust_dbg_unpack_option_u64u64(struct U8TaggedEnumOptionU64U64 o, uint64_t *a, uint64_t *b) {\n+    assert(a);\n+    assert(b);\n+    switch (o.tag) {\n+    case OPTION_TAG_SOME:\n+        *a = o.some.a;\n+        *b = o.some.b;\n+        return 1;\n+    case OPTION_TAG_NONE:\n+        return 0;\n+    default:\n+        assert(0 && \"unexpected tag\");\n+    }\n+}"}, {"sha": "5b5d620efe655f3e31f80d150beaabbeb6facd79", "filename": "src/test/run-make-fulldeps/arguments-non-c-like-enum/Makefile", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Farguments-non-c-like-enum%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Farguments-non-c-like-enum%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Farguments-non-c-like-enum%2FMakefile?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -0,0 +1,7 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) --crate-type=staticlib nonclike.rs\n+\t$(CC) test.c $(call STATICLIB,nonclike) $(call OUT_EXE,test) \\\n+\t\t$(EXTRACFLAGS) $(EXTRACXXFLAGS)\n+\t$(call RUN,test)"}, {"sha": "57c2c6127ed9cc01fa04dd8a9e49eeb6c9db20b0", "filename": "src/test/run-make-fulldeps/arguments-non-c-like-enum/nonclike.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Farguments-non-c-like-enum%2Fnonclike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Farguments-non-c-like-enum%2Fnonclike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Farguments-non-c-like-enum%2Fnonclike.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -0,0 +1,31 @@\n+#[repr(C, u8)]\n+pub enum TT {\n+    AA(u64, u64),\n+    BB,\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn tt_add(a: TT, b: TT) -> u64 {\n+    match (a, b) {\n+        (TT::AA(a1, b1), TT::AA(a2, b2)) => a1 + a2 + b1 + b2,\n+        (TT::AA(a1, b1), TT::BB) => a1 + b1,\n+        (TT::BB, TT::AA(a1, b1)) => a1 + b1,\n+        _ => 0,\n+    }\n+}\n+\n+#[repr(C, u8)]\n+pub enum T {\n+    A(u64),\n+    B,\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn t_add(a: T, b: T) -> u64 {\n+    match (a, b) {\n+        (T::A(a), T::A(b)) => a + b,\n+        (T::A(a), T::B) => a,\n+        (T::B, T::A(b)) => b,\n+        _ => 0,\n+    }\n+}"}, {"sha": "0a1621e49f2eeed5e86a2622355c74c345d74131", "filename": "src/test/run-make-fulldeps/arguments-non-c-like-enum/test.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Farguments-non-c-like-enum%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Farguments-non-c-like-enum%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Farguments-non-c-like-enum%2Ftest.c?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -0,0 +1,66 @@\n+#include <stdint.h>\n+#include <assert.h>\n+\n+#include <stdio.h>\n+\n+/* This is the code generated by cbindgen 0.12.1 for the `enum TT`\n+ * type in nonclike.rs . */\n+enum TT_Tag {\n+  AA,\n+  BB,\n+};\n+typedef uint8_t TT_Tag;\n+\n+typedef struct {\n+  uint64_t _0;\n+  uint64_t _1;\n+} AA_Body;\n+\n+typedef struct {\n+  TT_Tag tag;\n+  union {\n+    AA_Body aa;\n+  };\n+} TT;\n+\n+/* This is the code generated by cbindgen 0.12.1 for the `enum T` type\n+ * in nonclike.rs . */\n+enum T_Tag {\n+  A,\n+  B,\n+};\n+typedef uint8_t T_Tag;\n+\n+typedef struct {\n+  uint64_t _0;\n+} A_Body;\n+\n+typedef struct {\n+  T_Tag tag;\n+  union {\n+    A_Body a;\n+  };\n+} T;\n+\n+/* These symbols are defined by the Rust staticlib built from\n+ * nonclike.rs. */\n+extern uint64_t t_add(T a, T b);\n+extern uint64_t tt_add(TT a, TT b);\n+\n+int main(int argc, char *argv[]) {\n+  (void)argc; (void)argv;\n+\n+  /* This example works. */\n+  TT xx = { .tag = AA, .aa = { ._0 = 1, ._1 = 2 } };\n+  TT yy = { .tag = AA, .aa = { ._0 = 10, ._1 = 20 } };\n+  uint64_t rr = tt_add(xx, yy);\n+  assert(33 == rr);\n+\n+  /* This one used to return an incorrect result (see issue #68190). */\n+  T x = { .tag = A, .a = { ._0 = 1 } };\n+  T y = { .tag = A, .a = { ._0 = 10 } };\n+  uint64_t r = t_add(x, y);\n+  assert(11 == r);\n+\n+  return 0;\n+}"}, {"sha": "f3d9357865c168412f9105debed22437a64dab41", "filename": "src/test/run-make-fulldeps/pass-non-c-like-enum-to-c/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Fpass-non-c-like-enum-to-c%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Fpass-non-c-like-enum-to-c%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpass-non-c-like-enum-to-c%2FMakefile?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -0,0 +1,5 @@\n+-include ../tools.mk\n+\n+all: $(call NATIVE_STATICLIB,test)\n+\t$(RUSTC) nonclike.rs -L$(TMPDIR) -ltest\n+\t$(call RUN,nonclike)"}, {"sha": "517286a868d8ccd5600a41db5cff85b7eaf4320f", "filename": "src/test/run-make-fulldeps/pass-non-c-like-enum-to-c/nonclike.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Fpass-non-c-like-enum-to-c%2Fnonclike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Fpass-non-c-like-enum-to-c%2Fnonclike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpass-non-c-like-enum-to-c%2Fnonclike.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -0,0 +1,21 @@\n+#[repr(C, u8)]\n+pub enum TT {\n+    AA(u64, u64),\n+    BB,\n+}\n+\n+#[repr(C,u8)]\n+pub enum T {\n+    A(u64),\n+    B,\n+}\n+\n+extern \"C\" {\n+    pub fn t_add(a: T, b: T) -> u64;\n+    pub fn tt_add(a: TT, b: TT) -> u64;\n+}\n+\n+fn main() {\n+    assert_eq!(33, unsafe { tt_add(TT::AA(1,2), TT::AA(10,20)) });\n+    assert_eq!(11, unsafe { t_add(T::A(1), T::A(10)) });\n+}"}, {"sha": "99511b2530f0693979ed0ddaeb0d69e500759452", "filename": "src/test/run-make-fulldeps/pass-non-c-like-enum-to-c/test.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Fpass-non-c-like-enum-to-c%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Fpass-non-c-like-enum-to-c%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpass-non-c-like-enum-to-c%2Ftest.c?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -0,0 +1,85 @@\n+#include <stdint.h>\n+\n+/* This is the code generated by cbindgen 0.12.1 for the `enum TT`\n+ * type in nonclike.rs . */\n+enum TT_Tag {\n+  AA,\n+  BB,\n+};\n+typedef uint8_t TT_Tag;\n+\n+typedef struct {\n+  uint64_t _0;\n+  uint64_t _1;\n+} AA_Body;\n+\n+typedef struct {\n+  TT_Tag tag;\n+  union {\n+    AA_Body aa;\n+  };\n+} TT;\n+\n+/* This is the code generated by cbindgen 0.12.1 for the `enum T` type\n+ * in nonclike.rs . */\n+enum T_Tag {\n+  A,\n+  B,\n+};\n+typedef uint8_t T_Tag;\n+\n+typedef struct {\n+  uint64_t _0;\n+} A_Body;\n+\n+typedef struct {\n+  T_Tag tag;\n+  union {\n+    A_Body a;\n+  };\n+} T;\n+\n+uint64_t tt_add(TT a, TT b) {\n+  if (a.tag == AA && b.tag == AA) {\n+    return a.aa._0 + a.aa._1 + b.aa._0 + b.aa._1;\n+  } else if (a.tag == AA) {\n+    return a.aa._0 + a.aa._1;\n+  } else if (b.tag == BB) {\n+    return b.aa._0 + b.aa._1;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+uint64_t t_add(T a, T b) {\n+  if (a.tag == A && b.tag == A) {\n+    return a.a._0 + b.a._0;\n+  } else if (a.tag == AA) {\n+    return a.a._0;\n+  } else if (b.tag == BB) {\n+    return b.a._0;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+TT tt_new(uint64_t a, uint64_t b) {\n+  TT tt = {\n+    .tag = AA,\n+    .aa = {\n+      ._0 = a,\n+      ._1 = b,\n+    },\n+  };\n+  return tt;\n+}\n+\n+T t_new(uint64_t a) {\n+  T t = {\n+    .tag = A,\n+    .a = {\n+      ._0 = a,\n+    },\n+  };\n+  return t;\n+}"}, {"sha": "f3d9357865c168412f9105debed22437a64dab41", "filename": "src/test/run-make-fulldeps/return-non-c-like-enum-from-c/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum-from-c%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum-from-c%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum-from-c%2FMakefile?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -0,0 +1,5 @@\n+-include ../tools.mk\n+\n+all: $(call NATIVE_STATICLIB,test)\n+\t$(RUSTC) nonclike.rs -L$(TMPDIR) -ltest\n+\t$(call RUN,nonclike)"}, {"sha": "ea22a2a56e09b44b9d7243ac5d1bf48b2b4f4feb", "filename": "src/test/run-make-fulldeps/return-non-c-like-enum-from-c/nonclike.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum-from-c%2Fnonclike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum-from-c%2Fnonclike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum-from-c%2Fnonclike.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -0,0 +1,31 @@\n+#[repr(C, u8)]\n+pub enum TT {\n+    AA(u64, u64),\n+    BB,\n+}\n+\n+#[repr(C,u8)]\n+pub enum T {\n+    A(u64),\n+    B,\n+}\n+\n+extern \"C\" {\n+    pub fn t_new(a: u64) -> T;\n+    pub fn tt_new(a: u64, b: u64) -> TT;\n+}\n+\n+fn main() {\n+    if let TT::AA(a, b) = unsafe { tt_new(10, 11) } {\n+        assert_eq!(10, a);\n+        assert_eq!(11, b);\n+    } else {\n+        panic!(\"expected TT::AA\");\n+    }\n+\n+    if let T::A(a) = unsafe { t_new(10) } {\n+        assert_eq!(10, a);\n+    } else {\n+        panic!(\"expected T::A\");\n+    }\n+}"}, {"sha": "3ad135bab4a1e986c33ba940427ab52548d3688b", "filename": "src/test/run-make-fulldeps/return-non-c-like-enum-from-c/test.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum-from-c%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum-from-c%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum-from-c%2Ftest.c?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -0,0 +1,61 @@\n+#include <stdint.h>\n+\n+/* This is the code generated by cbindgen 0.12.1 for the `enum TT`\n+ * type in nonclike.rs . */\n+enum TT_Tag {\n+  AA,\n+  BB,\n+};\n+typedef uint8_t TT_Tag;\n+\n+typedef struct {\n+  uint64_t _0;\n+  uint64_t _1;\n+} AA_Body;\n+\n+typedef struct {\n+  TT_Tag tag;\n+  union {\n+    AA_Body aa;\n+  };\n+} TT;\n+\n+/* This is the code generated by cbindgen 0.12.1 for the `enum T` type\n+ * in nonclike.rs . */\n+enum T_Tag {\n+  A,\n+  B,\n+};\n+typedef uint8_t T_Tag;\n+\n+typedef struct {\n+  uint64_t _0;\n+} A_Body;\n+\n+typedef struct {\n+  T_Tag tag;\n+  union {\n+    A_Body a;\n+  };\n+} T;\n+\n+TT tt_new(uint64_t a, uint64_t b) {\n+  TT tt = {\n+    .tag = AA,\n+    .aa = {\n+      ._0 = a,\n+      ._1 = b,\n+    },\n+  };\n+  return tt;\n+}\n+\n+T t_new(uint64_t a) {\n+  T t = {\n+    .tag = A,\n+    .a = {\n+      ._0 = a,\n+    },\n+  };\n+  return t;\n+}"}, {"sha": "5b5d620efe655f3e31f80d150beaabbeb6facd79", "filename": "src/test/run-make-fulldeps/return-non-c-like-enum/Makefile", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum%2FMakefile?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -0,0 +1,7 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) --crate-type=staticlib nonclike.rs\n+\t$(CC) test.c $(call STATICLIB,nonclike) $(call OUT_EXE,test) \\\n+\t\t$(EXTRACFLAGS) $(EXTRACXXFLAGS)\n+\t$(call RUN,test)"}, {"sha": "de529cf641ab06d44a936add077782d2074f1054", "filename": "src/test/run-make-fulldeps/return-non-c-like-enum/nonclike.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum%2Fnonclike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum%2Fnonclike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum%2Fnonclike.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -0,0 +1,21 @@\n+#[repr(C, u8)]\n+pub enum TT {\n+    AA(u64, u64),\n+    BB,\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn tt_new(a: u64, b: u64) -> TT {\n+    TT::AA(a, b)\n+}\n+\n+#[repr(C,u8)]\n+pub enum T {\n+    A(u64),\n+    B,\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn t_new(a: u64) -> T {\n+    T::A(a)\n+}"}, {"sha": "afadd3c10c5ca0d51e5cacf18f3e937aaefdb76a", "filename": "src/test/run-make-fulldeps/return-non-c-like-enum/test.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum%2Ftest.c?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -0,0 +1,63 @@\n+#include <stdint.h>\n+#include <assert.h>\n+\n+/* This is the code generated by cbindgen 0.12.1 for the `enum TT`\n+ * type in nonclike.rs . */\n+enum TT_Tag {\n+  AA,\n+  BB,\n+};\n+typedef uint8_t TT_Tag;\n+\n+typedef struct {\n+  uint64_t _0;\n+  uint64_t _1;\n+} AA_Body;\n+\n+typedef struct {\n+  TT_Tag tag;\n+  union {\n+    AA_Body aa;\n+  };\n+} TT;\n+\n+/* This is the code generated by cbindgen 0.12.1 for the `enum T` type\n+ * in nonclike.rs . */\n+enum T_Tag {\n+  A,\n+  B,\n+};\n+typedef uint8_t T_Tag;\n+\n+typedef struct {\n+  uint64_t _0;\n+} A_Body;\n+\n+typedef struct {\n+  T_Tag tag;\n+  union {\n+    A_Body a;\n+  };\n+} T;\n+\n+/* These symbols are defined by the Rust staticlib built from\n+ * nonclike.rs. */\n+extern TT tt_new(uint64_t a, uint64_t b);\n+extern T t_new(uint64_t v);\n+\n+int main(int argc, char *argv[]) {\n+  (void)argc; (void)argv;\n+\n+  /* This example works. */\n+  TT tt = tt_new(10, 20);\n+  assert(AA == tt.tag);\n+  assert(10 == tt.aa._0);\n+  assert(20 == tt.aa._1);\n+\n+  /* This one used to segfault (see issue #68190). */\n+  T t = t_new(10);\n+  assert(A == t.tag);\n+  assert(10 == t.a._0);\n+\n+  return 0;\n+}"}, {"sha": "c87353b93a7c0ebc8e6982defbd2f2fc2d1a55cc", "filename": "src/test/ui/abi/abi-sysv64-arg-passing.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fui%2Fabi%2Fabi-sysv64-arg-passing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fui%2Fabi%2Fabi-sysv64-arg-passing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fabi%2Fabi-sysv64-arg-passing.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -92,6 +92,18 @@ mod tests {\n     #[derive(Copy, Clone)]\n     pub struct Floats { a: f64, b: u8, c: f64 }\n \n+    #[repr(C, u8)]\n+    pub enum U8TaggedEnumOptionU64U64 {\n+        None,\n+        Some(u64,u64),\n+    }\n+\n+    #[repr(C, u8)]\n+    pub enum U8TaggedEnumOptionU64 {\n+        None,\n+        Some(u64),\n+    }\n+\n     #[link(name = \"rust_test_helpers\", kind = \"static\")]\n     extern \"sysv64\" {\n         pub fn rust_int8_to_int32(_: i8) -> i32;\n@@ -125,6 +137,16 @@ mod tests {\n         ) -> f32;\n         pub fn rust_dbg_abi_1(q: Quad) -> Quad;\n         pub fn rust_dbg_abi_2(f: Floats) -> Floats;\n+        pub fn rust_dbg_new_some_u64u64(a: u64, b: u64) -> U8TaggedEnumOptionU64U64;\n+        pub fn rust_dbg_new_none_u64u64() -> U8TaggedEnumOptionU64U64;\n+        pub fn rust_dbg_unpack_option_u64u64(\n+            o: U8TaggedEnumOptionU64U64,\n+            a: *mut u64,\n+            b: *mut u64,\n+        ) -> i32;\n+        pub fn rust_dbg_new_some_u64(some: u64) -> U8TaggedEnumOptionU64;\n+        pub fn rust_dbg_new_none_u64() -> U8TaggedEnumOptionU64;\n+        pub fn rust_dbg_unpack_option_u64(o: U8TaggedEnumOptionU64, v: *mut u64) -> i32;\n     }\n \n     pub fn cabi_int_widening() {\n@@ -336,6 +358,63 @@ mod tests {\n         test1();\n         test2();\n     }\n+\n+    pub fn enum_passing_and_return_pair() {\n+        let some_u64u64 = unsafe { rust_dbg_new_some_u64u64(10, 20) };\n+        if let U8TaggedEnumOptionU64U64::Some(a, b) = some_u64u64 {\n+            assert_eq!(10, a);\n+            assert_eq!(20, b);\n+        } else {\n+            panic!(\"unexpected none\");\n+        }\n+\n+        let none_u64u64 = unsafe { rust_dbg_new_none_u64u64() };\n+        if let U8TaggedEnumOptionU64U64::Some(_,_) = none_u64u64 {\n+            panic!(\"unexpected some\");\n+        }\n+\n+        let mut a: u64 = 0;\n+        let mut b: u64 = 0;\n+        let r = unsafe {\n+            rust_dbg_unpack_option_u64u64(some_u64u64, &mut a as *mut _, &mut b as *mut _)\n+        };\n+        assert_eq!(1, r);\n+        assert_eq!(10, a);\n+        assert_eq!(20, b);\n+\n+        let mut a: u64 = 0;\n+        let mut b: u64 = 0;\n+        let r = unsafe {\n+            rust_dbg_unpack_option_u64u64(none_u64u64, &mut a as *mut _, &mut b as *mut _)\n+        };\n+        assert_eq!(0, r);\n+        assert_eq!(0, a);\n+        assert_eq!(0, b);\n+    }\n+\n+    pub fn enum_passing_and_return() {\n+        let some_u64 = unsafe { rust_dbg_new_some_u64(10) };\n+        if let U8TaggedEnumOptionU64::Some(v) = some_u64 {\n+            assert_eq!(10, v);\n+        } else {\n+            panic!(\"unexpected none\");\n+        }\n+\n+        let none_u64 = unsafe { rust_dbg_new_none_u64() };\n+        if let U8TaggedEnumOptionU64::Some(_) = none_u64 {\n+            panic!(\"unexpected some\");\n+        }\n+\n+        let mut target: u64 = 0;\n+        let r = unsafe { rust_dbg_unpack_option_u64(some_u64, &mut target as *mut _) };\n+        assert_eq!(1, r);\n+        assert_eq!(10, target);\n+\n+        let mut target: u64 = 0;\n+        let r = unsafe { rust_dbg_unpack_option_u64(none_u64, &mut target as *mut _) };\n+        assert_eq!(0, r);\n+        assert_eq!(0, target);\n+    }\n }\n \n #[cfg(target_arch = \"x86_64\")]\n@@ -359,6 +438,8 @@ fn main() {\n     issue_28676();\n     issue_62350();\n     struct_return();\n+    enum_passing_and_return_pair();\n+    enum_passing_and_return();\n }\n \n #[cfg(not(target_arch = \"x86_64\"))]"}, {"sha": "7eecd99dc016ae4a256cf5398f18fae718d1e009", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-c-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -20,7 +20,7 @@ pub struct Middle {\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type TestMiddle = Middle;\n-//~^ ERROR homogeneous_aggregate: Homogeneous\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous\n \n #[repr(C)]\n pub struct Final {\n@@ -31,6 +31,6 @@ pub struct Final {\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type TestFinal = Final;\n-//~^ ERROR homogeneous_aggregate: Homogeneous\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous\n \n fn main() { }"}, {"sha": "cd3fb5ca5ea402124e930cf29bd16f8042f6d053", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-c-struct.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.stderr?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -1,10 +1,10 @@\n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-c-struct.rs:22:1\n    |\n LL | pub type TestMiddle = Middle;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-c-struct.rs:33:1\n    |\n LL | pub type TestFinal = Final;"}, {"sha": "ec2c9b70224b5d4a8a31c375532da38284c668ed", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-repr-rust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -52,22 +52,22 @@ pub struct WithEmptyRustEnum {\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type Test1 = BaseCase;\n-//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type Test2 = WithPhantomData;\n-//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type Test3 = WithEmptyRustStruct;\n-//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type Test4 = WithTransitivelyEmptyRustStruct;\n-//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type Test5 = WithEmptyRustEnum;\n-//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n \n fn main() { }"}, {"sha": "ec2b08bf02d655a435129bb43427820d76d489de", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-repr-rust.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.stderr?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -1,28 +1,28 @@\n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:54:1\n    |\n LL | pub type Test1 = BaseCase;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:58:1\n    |\n LL | pub type Test2 = WithPhantomData;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:62:1\n    |\n LL | pub type Test3 = WithEmptyRustStruct;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:66:1\n    |\n LL | pub type Test4 = WithTransitivelyEmptyRustStruct;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:70:1\n    |\n LL | pub type Test5 = WithEmptyRustEnum;"}, {"sha": "1a662ba44677d647f0a3d7d634451650bd1fe624", "filename": "src/test/ui/layout/zero-sized-array-union.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -57,7 +57,7 @@ struct Baz1 {\n \n #[rustc_layout(homogeneous_aggregate)]\n type TestBaz1 = Baz1;\n-//~^ ERROR homogeneous_aggregate: Homogeneous\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous\n \n #[repr(C)]\n struct Baz2 {\n@@ -68,7 +68,7 @@ struct Baz2 {\n \n #[rustc_layout(homogeneous_aggregate)]\n type TestBaz2 = Baz2;\n-//~^ ERROR homogeneous_aggregate: Homogeneous\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous\n \n #[repr(C)]\n struct Baz3 {\n@@ -79,7 +79,7 @@ struct Baz3 {\n \n #[rustc_layout(homogeneous_aggregate)]\n type TestBaz3 = Baz3;\n-//~^ ERROR homogeneous_aggregate: Homogeneous\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous\n \n #[repr(C)]\n struct Baz4 {\n@@ -90,6 +90,6 @@ struct Baz4 {\n \n #[rustc_layout(homogeneous_aggregate)]\n type TestBaz4 = Baz4;\n-//~^ ERROR homogeneous_aggregate: Homogeneous\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous\n \n fn main() { }"}, {"sha": "43b1588266bb7cdd2f0c68a59af02c880672824b", "filename": "src/test/ui/layout/zero-sized-array-union.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.stderr?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -1,22 +1,22 @@\n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/zero-sized-array-union.rs:59:1\n    |\n LL | type TestBaz1 = Baz1;\n    | ^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/zero-sized-array-union.rs:70:1\n    |\n LL | type TestBaz2 = Baz2;\n    | ^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/zero-sized-array-union.rs:81:1\n    |\n LL | type TestBaz3 = Baz3;\n    | ^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/zero-sized-array-union.rs:92:1\n    |\n LL | type TestBaz4 = Baz4;"}, {"sha": "923dec892e0805b7797c7cd38cb138ec39043503", "filename": "src/test/ui/specialization/soundness/partial_eq_range_inclusive.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fui%2Fspecialization%2Fsoundness%2Fpartial_eq_range_inclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fui%2Fspecialization%2Fsoundness%2Fpartial_eq_range_inclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fsoundness%2Fpartial_eq_range_inclusive.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -0,0 +1,35 @@\n+// run-pass\n+\n+use std::cell::RefCell;\n+use std::cmp::Ordering;\n+\n+struct Evil<'a, 'b> {\n+    values: RefCell<Vec<&'a str>>,\n+    to_insert: &'b String,\n+}\n+\n+impl<'a, 'b> PartialEq for Evil<'a, 'b> {\n+    fn eq(&self, _other: &Self) -> bool {\n+        true\n+    }\n+}\n+\n+impl<'a> PartialOrd for Evil<'a, 'a> {\n+    fn partial_cmp(&self, _other: &Self) -> Option<Ordering> {\n+        self.values.borrow_mut().push(self.to_insert);\n+        None\n+    }\n+}\n+\n+fn main() {\n+    let e;\n+    let values;\n+    {\n+        let to_insert = String::from(\"Hello, world!\");\n+        e = Evil { values: RefCell::new(Vec::new()), to_insert: &to_insert };\n+        let range = &e..=&e;\n+        let _ = range == range;\n+        values = e.values;\n+    }\n+    assert_eq!(*values.borrow(), Vec::<&str>::new());\n+}"}, {"sha": "b9e80a48d33d337500728af052f2b383d96881f8", "filename": "src/test/ui/specialization/soundness/partial_ord_slice.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fui%2Fspecialization%2Fsoundness%2Fpartial_ord_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d705ad28a0129ec52c686d3476b731590ca207b7/src%2Ftest%2Fui%2Fspecialization%2Fsoundness%2Fpartial_ord_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fsoundness%2Fpartial_ord_slice.rs?ref=d705ad28a0129ec52c686d3476b731590ca207b7", "patch": "@@ -0,0 +1,42 @@\n+// Check that we aren't using unsound specialization in slice comparisons.\n+\n+// run-pass\n+\n+use std::cell::Cell;\n+use std::cmp::Ordering;\n+\n+struct Evil<'a, 'b>(Cell<(&'a [i32], &'b [i32])>);\n+\n+impl PartialEq for Evil<'_, '_> {\n+    fn eq(&self, _other: &Self) -> bool {\n+        true\n+    }\n+}\n+\n+impl Eq for Evil<'_, '_> {}\n+\n+impl PartialOrd for Evil<'_, '_> {\n+    fn partial_cmp(&self, _other: &Self) -> Option<Ordering> {\n+        Some(Ordering::Equal)\n+    }\n+}\n+\n+impl<'a> Ord for Evil<'a, 'a> {\n+    fn cmp(&self, _other: &Self) -> Ordering {\n+        let (a, b) = self.0.get();\n+        self.0.set((b, a));\n+        Ordering::Equal\n+    }\n+}\n+\n+fn main() {\n+    let x = &[1, 2, 3, 4];\n+    let u = {\n+        let a = Box::new([7, 8, 9, 10]);\n+        let y = [Evil(Cell::new((x, &*a)))];\n+        let _ = &y[..] <= &y[..];\n+        let [Evil(c)] = y;\n+        c.get().0\n+    };\n+    assert_eq!(u, &[1, 2, 3, 4]);\n+}"}]}