{"sha": "d46c728bcda687b1cf5f3bedca3d501e797b2a0f", "node_id": "C_kwDOAAsO6NoAKGQ0NmM3MjhiY2RhNjg3YjFjZjVmM2JlZGNhM2Q1MDFlNzk3YjJhMGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-04T01:06:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-04T01:06:54Z"}, "message": "Auto merge of #98446 - nnethercote:derive-no-match-destructuring, r=scottmcm\n\nDon't use match-destructuring for derived ops on structs.\n\nr? `@scottmcm`", "tree": {"sha": "35c1df3af2abd56bee0fed99dfe943ef2f3f0e4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35c1df3af2abd56bee0fed99dfe943ef2f3f0e4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d46c728bcda687b1cf5f3bedca3d501e797b2a0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d46c728bcda687b1cf5f3bedca3d501e797b2a0f", "html_url": "https://github.com/rust-lang/rust/commit/d46c728bcda687b1cf5f3bedca3d501e797b2a0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d46c728bcda687b1cf5f3bedca3d501e797b2a0f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2557603f320593be9d1c29a453c648e61e74d343", "url": "https://api.github.com/repos/rust-lang/rust/commits/2557603f320593be9d1c29a453c648e61e74d343", "html_url": "https://github.com/rust-lang/rust/commit/2557603f320593be9d1c29a453c648e61e74d343"}, {"sha": "ecc6e95ed44e438a86dbfff0a3f2b8d378ae3dde", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecc6e95ed44e438a86dbfff0a3f2b8d378ae3dde", "html_url": "https://github.com/rust-lang/rust/commit/ecc6e95ed44e438a86dbfff0a3f2b8d378ae3dde"}], "stats": {"total": 833, "additions": 394, "deletions": 439}, "files": [{"sha": "2a9e37081e09e48990e55186c87af928a0de17e1", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 81, "deletions": 46, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/d46c728bcda687b1cf5f3bedca3d501e797b2a0f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46c728bcda687b1cf5f3bedca3d501e797b2a0f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=d46c728bcda687b1cf5f3bedca3d501e797b2a0f", "patch": "@@ -66,7 +66,7 @@\n //!\n //! # \"`cs`\" functions\n //!\n-//! The `cs_...` functions (\"combine substructure) are designed to\n+//! The `cs_...` functions (\"combine substructure\") are designed to\n //! make life easier by providing some pre-made recipes for common\n //! threads; mostly calling the function being derived on all the\n //! arguments and then combining them back together in some way (or\n@@ -429,6 +429,7 @@ impl<'a> TraitDef<'a> {\n                         generics,\n                         from_scratch,\n                         use_temporaries,\n+                        is_packed,\n                     ),\n                     ast::ItemKind::Enum(ref enum_def, ref generics) => {\n                         // We ignore `use_temporaries` here, because\n@@ -448,6 +449,7 @@ impl<'a> TraitDef<'a> {\n                                 generics,\n                                 from_scratch,\n                                 use_temporaries,\n+                                is_packed,\n                             )\n                         } else {\n                             cx.span_err(mitem.span, \"this trait cannot be derived for unions\");\n@@ -729,6 +731,7 @@ impl<'a> TraitDef<'a> {\n         generics: &Generics,\n         from_scratch: bool,\n         use_temporaries: bool,\n+        is_packed: bool,\n     ) -> P<ast::Item> {\n         let field_tys: Vec<P<ast::Ty>> =\n             struct_def.fields().iter().map(|field| field.ty.clone()).collect();\n@@ -757,6 +760,7 @@ impl<'a> TraitDef<'a> {\n                         &self_args,\n                         &nonself_args,\n                         use_temporaries,\n+                        is_packed,\n                     )\n                 };\n \n@@ -945,6 +949,7 @@ impl<'a> MethodDef<'a> {\n         })\n     }\n \n+    /// The normal case uses field access.\n     /// ```\n     /// #[derive(PartialEq)]\n     /// # struct Dummy;\n@@ -953,33 +958,21 @@ impl<'a> MethodDef<'a> {\n     /// // equivalent to:\n     /// impl PartialEq for A {\n     ///     fn eq(&self, other: &A) -> bool {\n-    ///         match *self {\n-    ///             A {x: ref __self_0_0, y: ref __self_0_1} => {\n-    ///                 match *other {\n-    ///                     A {x: ref __self_1_0, y: ref __self_1_1} => {\n-    ///                         __self_0_0.eq(__self_1_0) && __self_0_1.eq(__self_1_1)\n-    ///                     }\n-    ///                 }\n-    ///             }\n-    ///         }\n+    ///         self.x == other.x && self.y == other.y\n     ///     }\n     /// }\n     /// ```\n-    /// or if A is repr(packed) - note fields are matched by-value\n-    /// instead of by-reference.\n+    /// But if the struct is `repr(packed)`, we can't use something like\n+    /// `&self.x` on a packed type (as required for e.g. `Debug` and `Hash`)\n+    /// because that might cause an unaligned ref. So we use let-destructuring\n+    /// instead.\n     /// ```\n     /// # struct A { x: i32, y: i32 }\n     /// impl PartialEq for A {\n     ///     fn eq(&self, other: &A) -> bool {\n-    ///         match *self {\n-    ///             A {x: __self_0_0, y: __self_0_1} => {\n-    ///                 match other {\n-    ///                     A {x: __self_1_0, y: __self_1_1} => {\n-    ///                         __self_0_0.eq(&__self_1_0) && __self_0_1.eq(&__self_1_1)\n-    ///                     }\n-    ///                 }\n-    ///             }\n-    ///         }\n+    ///         let Self { x: ref __self_0_0, y: ref __self_0_1 } = *self;\n+    ///         let Self { x: ref __self_1_0, y: ref __self_1_1 } = *other;\n+    ///         *__self_0_0 == *__self_1_0 && *__self_0_1 == *__self_1_1\n     ///     }\n     /// }\n     /// ```\n@@ -992,24 +985,33 @@ impl<'a> MethodDef<'a> {\n         self_args: &[P<Expr>],\n         nonself_args: &[P<Expr>],\n         use_temporaries: bool,\n+        is_packed: bool,\n     ) -> P<Expr> {\n         let mut raw_fields = Vec::new(); // Vec<[fields of self], [fields of next Self arg], [etc]>\n         let span = trait_.span;\n         let mut patterns = Vec::new();\n-        for i in 0..self_args.len() {\n-            // We could use `type_ident` instead of `Self`, but in the case of a type parameter\n-            // shadowing the struct name, that causes a second, unnecessary E0578 error. #97343\n-            let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n-            let (pat, ident_expr) = trait_.create_struct_pattern(\n-                cx,\n-                struct_path,\n-                struct_def,\n-                &format!(\"__self_{}\", i),\n-                ast::Mutability::Not,\n-                use_temporaries,\n-            );\n-            patterns.push(pat);\n-            raw_fields.push(ident_expr);\n+\n+        for (i, self_arg) in self_args.iter().enumerate() {\n+            let ident_exprs = if !is_packed {\n+                trait_.create_struct_field_accesses(cx, self_arg, struct_def)\n+            } else {\n+                // Get the pattern for the let-destructuring.\n+                //\n+                // We could use `type_ident` instead of `Self`, but in the case of a type parameter\n+                // shadowing the struct name, that causes a second, unnecessary E0578 error. #97343\n+                let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n+                let (pat, ident_exprs) = trait_.create_struct_pattern(\n+                    cx,\n+                    struct_path,\n+                    struct_def,\n+                    &format!(\"__self_{}\", i),\n+                    ast::Mutability::Not,\n+                    use_temporaries,\n+                );\n+                patterns.push(pat);\n+                ident_exprs\n+            };\n+            raw_fields.push(ident_exprs);\n         }\n \n         // transpose raw_fields\n@@ -1036,7 +1038,6 @@ impl<'a> MethodDef<'a> {\n             cx.span_bug(span, \"no `self` parameter for method in generic `derive`\")\n         };\n \n-        // body of the inner most destructuring match\n         let mut body = self.call_substructure_method(\n             cx,\n             trait_,\n@@ -1045,14 +1046,18 @@ impl<'a> MethodDef<'a> {\n             &Struct(struct_def, fields),\n         );\n \n-        // make a series of nested matches, to destructure the\n-        // structs. This is actually right-to-left, but it shouldn't\n-        // matter.\n-        for (arg_expr, pat) in iter::zip(self_args, patterns) {\n-            body = cx.expr_match(span, arg_expr.clone(), vec![cx.arm(span, pat.clone(), body)])\n-        }\n+        if !is_packed {\n+            body.span = span;\n+            body\n+        } else {\n+            // Do the let-destructuring.\n+            let mut stmts: Vec<_> = iter::zip(self_args, patterns)\n+                .map(|(arg_expr, pat)| cx.stmt_let_pat(span, pat, arg_expr.clone()))\n+                .collect();\n+            stmts.push(cx.stmt_expr(body));\n \n-        body\n+            cx.expr_block(cx.block(span, stmts))\n+        }\n     }\n \n     fn expand_static_struct_method_body(\n@@ -1522,8 +1527,6 @@ impl<'a> TraitDef<'a> {\n             paths.push(ident.with_span_pos(sp));\n             let val = cx.expr_path(cx.path_ident(sp, ident));\n             let val = if use_temporaries { val } else { cx.expr_deref(sp, val) };\n-            let val = cx.expr(sp, ast::ExprKind::Paren(val));\n-\n             ident_exprs.push((sp, struct_field.ident, val, &struct_field.attrs[..]));\n         }\n \n@@ -1555,6 +1558,39 @@ impl<'a> TraitDef<'a> {\n         (pattern, ident_exprs)\n     }\n \n+    fn create_struct_field_accesses(\n+        &self,\n+        cx: &mut ExtCtxt<'_>,\n+        mut self_arg: &P<Expr>,\n+        struct_def: &'a VariantData,\n+    ) -> Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])> {\n+        let mut ident_exprs = Vec::new();\n+        for (i, struct_field) in struct_def.fields().iter().enumerate() {\n+            let sp = struct_field.span.with_ctxt(self.span.ctxt());\n+\n+            // We don't the need the deref, if there is one.\n+            if let ast::ExprKind::Unary(ast::UnOp::Deref, inner) = &self_arg.kind {\n+                self_arg = inner;\n+            }\n+\n+            // Note: we must use `struct_field.span` rather than `span` in the\n+            // `unwrap_or_else` case otherwise the hygiene is wrong and we get\n+            // \"field `0` of struct `Point` is private\" errors on tuple\n+            // structs.\n+            let val = cx.expr(\n+                sp,\n+                ast::ExprKind::Field(\n+                    self_arg.clone(),\n+                    struct_field.ident.unwrap_or_else(|| {\n+                        Ident::from_str_and_span(&i.to_string(), struct_field.span)\n+                    }),\n+                ),\n+            );\n+            ident_exprs.push((sp, struct_field.ident, val, &struct_field.attrs[..]));\n+        }\n+        ident_exprs\n+    }\n+\n     fn create_enum_variant_pattern(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n@@ -1643,7 +1679,6 @@ where\n /// fields.\n /// When the `substructure` is an `EnumNonMatchingCollapsed`, the result of `enum_nonmatch_f`\n /// is returned. Statics may not be folded over.\n-/// See `cs_op` in `partial_ord.rs` for a model example.\n pub fn cs_fold1<F, B>(\n     use_foldl: bool,\n     f: F,"}, {"sha": "74e9bbeeeafe9f43b8a04ccbf4ebf2f1add85ece", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d46c728bcda687b1cf5f3bedca3d501e797b2a0f/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46c728bcda687b1cf5f3bedca3d501e797b2a0f/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=d46c728bcda687b1cf5f3bedca3d501e797b2a0f", "patch": "@@ -152,6 +152,19 @@ impl<'a> ExtCtxt<'a> {\n         ast::Stmt { id: ast::DUMMY_NODE_ID, span: expr.span, kind: ast::StmtKind::Expr(expr) }\n     }\n \n+    pub fn stmt_let_pat(&self, sp: Span, pat: P<ast::Pat>, ex: P<ast::Expr>) -> ast::Stmt {\n+        let local = P(ast::Local {\n+            pat,\n+            ty: None,\n+            id: ast::DUMMY_NODE_ID,\n+            kind: LocalKind::Init(ex),\n+            span: sp,\n+            attrs: AttrVec::new(),\n+            tokens: None,\n+        });\n+        self.stmt_local(local, sp)\n+    }\n+\n     pub fn stmt_let(&self, sp: Span, mutbl: bool, ident: Ident, ex: P<ast::Expr>) -> ast::Stmt {\n         self.stmt_let_ty(sp, mutbl, ident, None, ex)\n     }"}, {"sha": "b1ff480324f6b9ef4338bcf36ba5387421586d06", "filename": "src/test/mir-opt/combine_clone_of_primitives.{impl#0}-clone.InstCombine.diff", "status": "modified", "additions": 46, "deletions": 66, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d46c728bcda687b1cf5f3bedca3d501e797b2a0f/src%2Ftest%2Fmir-opt%2Fcombine_clone_of_primitives.%7Bimpl%230%7D-clone.InstCombine.diff", "raw_url": "https://github.com/rust-lang/rust/raw/d46c728bcda687b1cf5f3bedca3d501e797b2a0f/src%2Ftest%2Fmir-opt%2Fcombine_clone_of_primitives.%7Bimpl%230%7D-clone.InstCombine.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcombine_clone_of_primitives.%7Bimpl%230%7D-clone.InstCombine.diff?ref=d46c728bcda687b1cf5f3bedca3d501e797b2a0f", "patch": "@@ -4,98 +4,78 @@\n   fn <impl at $DIR/combine_clone_of_primitives.rs:6:10: 6:15>::clone(_1: &MyThing<T>) -> MyThing<T> {\n       debug self => _1;                    // in scope 0 at $DIR/combine_clone_of_primitives.rs:6:10: 6:15\n       let mut _0: MyThing<T>;              // return place in scope 0 at $DIR/combine_clone_of_primitives.rs:6:10: 6:15\n-      let _2: &T;                          // in scope 0 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n-      let _3: &u64;                        // in scope 0 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n-      let _4: &[f32; 3];                   // in scope 0 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n-      let mut _5: T;                       // in scope 0 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n-      let mut _6: &T;                      // in scope 0 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n-      let _7: &T;                          // in scope 0 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n-      let mut _8: u64;                     // in scope 0 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n-      let mut _9: &u64;                    // in scope 0 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n-      let _10: &u64;                       // in scope 0 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n-      let mut _11: [f32; 3];               // in scope 0 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n-      let mut _12: &[f32; 3];              // in scope 0 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n-      let _13: &[f32; 3];                  // in scope 0 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n-      scope 1 {\n-          debug __self_0_0 => _2;          // in scope 1 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n-          debug __self_0_1 => _3;          // in scope 1 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n-          debug __self_0_2 => _4;          // in scope 1 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n-      }\n+      let mut _2: T;                       // in scope 0 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n+      let mut _3: &T;                      // in scope 0 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n+      let _4: &T;                          // in scope 0 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n+      let mut _5: u64;                     // in scope 0 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n+      let mut _6: &u64;                    // in scope 0 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n+      let _7: &u64;                        // in scope 0 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n+      let mut _8: [f32; 3];                // in scope 0 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n+      let mut _9: &[f32; 3];               // in scope 0 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n+      let _10: &[f32; 3];                  // in scope 0 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n   \n       bb0: {\n           StorageLive(_2);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n-          _2 = &((*_1).0: T);              // scope 0 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n-          StorageLive(_3);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n-          _3 = &((*_1).1: u64);            // scope 0 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n-          StorageLive(_4);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n-          _4 = &((*_1).2: [f32; 3]);       // scope 0 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n-          StorageLive(_5);                 // scope 1 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n-          StorageLive(_6);                 // scope 1 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n-          StorageLive(_7);                 // scope 1 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n--         _7 = &(*_2);                     // scope 1 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n--         _6 = &(*_7);                     // scope 1 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n-+         _7 = _2;                         // scope 1 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n-+         _6 = _7;                         // scope 1 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n-          _5 = <T as Clone>::clone(move _6) -> bb1; // scope 1 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n+          StorageLive(_3);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n+          StorageLive(_4);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n+          _4 = &((*_1).0: T);              // scope 0 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n+-         _3 = &(*_4);                     // scope 0 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n++         _3 = _4;                         // scope 0 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n+          _2 = <T as Clone>::clone(move _3) -> bb1; // scope 0 at $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n                                            // mir::Constant\n                                            // + span: $DIR/combine_clone_of_primitives.rs:8:5: 8:9\n                                            // + literal: Const { ty: for<'r> fn(&'r T) -> T {<T as Clone>::clone}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb1: {\n-          StorageDead(_6);                 // scope 1 at $DIR/combine_clone_of_primitives.rs:8:8: 8:9\n-          StorageLive(_8);                 // scope 1 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n-          StorageLive(_9);                 // scope 1 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n-          StorageLive(_10);                // scope 1 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n--         _10 = &(*_3);                    // scope 1 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n--         _9 = &(*_10);                    // scope 1 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n--         _8 = <u64 as Clone>::clone(move _9) -> [return: bb2, unwind: bb4]; // scope 1 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n+          StorageDead(_3);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:8:8: 8:9\n+          StorageLive(_5);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n+          StorageLive(_6);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n+          StorageLive(_7);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n+          _7 = &((*_1).1: u64);            // scope 0 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n+-         _6 = &(*_7);                     // scope 0 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n+-         _5 = <u64 as Clone>::clone(move _6) -> [return: bb2, unwind: bb4]; // scope 0 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n -                                          // mir::Constant\n -                                          // + span: $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n -                                          // + literal: Const { ty: for<'r> fn(&'r u64) -> u64 {<u64 as Clone>::clone}, val: Value(Scalar(<ZST>)) }\n-+         _10 = _3;                        // scope 1 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n-+         _9 = _10;                        // scope 1 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n-+         _8 = (*_9);                      // scope 1 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n-+         goto -> bb2;                     // scope 1 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n++         _6 = _7;                         // scope 0 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n++         _5 = (*_6);                      // scope 0 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n++         goto -> bb2;                     // scope 0 at $DIR/combine_clone_of_primitives.rs:9:5: 9:11\n       }\n   \n       bb2: {\n-          StorageDead(_9);                 // scope 1 at $DIR/combine_clone_of_primitives.rs:9:10: 9:11\n-          StorageLive(_11);                // scope 1 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n-          StorageLive(_12);                // scope 1 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n-          StorageLive(_13);                // scope 1 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n--         _13 = &(*_4);                    // scope 1 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n--         _12 = &(*_13);                   // scope 1 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n--         _11 = <[f32; 3] as Clone>::clone(move _12) -> [return: bb3, unwind: bb4]; // scope 1 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n+          StorageDead(_6);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:9:10: 9:11\n+          StorageLive(_8);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n+          StorageLive(_9);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n+          StorageLive(_10);                // scope 0 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n+          _10 = &((*_1).2: [f32; 3]);      // scope 0 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n+-         _9 = &(*_10);                    // scope 0 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n+-         _8 = <[f32; 3] as Clone>::clone(move _9) -> [return: bb3, unwind: bb4]; // scope 0 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n -                                          // mir::Constant\n -                                          // + span: $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n -                                          // + literal: Const { ty: for<'r> fn(&'r [f32; 3]) -> [f32; 3] {<[f32; 3] as Clone>::clone}, val: Value(Scalar(<ZST>)) }\n-+         _13 = _4;                        // scope 1 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n-+         _12 = _13;                       // scope 1 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n-+         _11 = (*_12);                    // scope 1 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n-+         goto -> bb3;                     // scope 1 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n++         _9 = _10;                        // scope 0 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n++         _8 = (*_9);                      // scope 0 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n++         goto -> bb3;                     // scope 0 at $DIR/combine_clone_of_primitives.rs:10:5: 10:16\n       }\n   \n       bb3: {\n-          StorageDead(_12);                // scope 1 at $DIR/combine_clone_of_primitives.rs:10:15: 10:16\n-          Deinit(_0);                      // scope 1 at $DIR/combine_clone_of_primitives.rs:6:10: 6:15\n-          (_0.0: T) = move _5;             // scope 1 at $DIR/combine_clone_of_primitives.rs:6:10: 6:15\n-          (_0.1: u64) = move _8;           // scope 1 at $DIR/combine_clone_of_primitives.rs:6:10: 6:15\n-          (_0.2: [f32; 3]) = move _11;     // scope 1 at $DIR/combine_clone_of_primitives.rs:6:10: 6:15\n-          StorageDead(_13);                // scope 1 at $DIR/combine_clone_of_primitives.rs:6:14: 6:15\n-          StorageDead(_11);                // scope 1 at $DIR/combine_clone_of_primitives.rs:6:14: 6:15\n-          StorageDead(_10);                // scope 1 at $DIR/combine_clone_of_primitives.rs:6:14: 6:15\n-          StorageDead(_8);                 // scope 1 at $DIR/combine_clone_of_primitives.rs:6:14: 6:15\n-          StorageDead(_7);                 // scope 1 at $DIR/combine_clone_of_primitives.rs:6:14: 6:15\n-          StorageDead(_5);                 // scope 1 at $DIR/combine_clone_of_primitives.rs:6:14: 6:15\n-          StorageDead(_4);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:6:14: 6:15\n-          StorageDead(_3);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:6:14: 6:15\n+          StorageDead(_9);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:10:15: 10:16\n+          Deinit(_0);                      // scope 0 at $DIR/combine_clone_of_primitives.rs:6:10: 6:15\n+          (_0.0: T) = move _2;             // scope 0 at $DIR/combine_clone_of_primitives.rs:6:10: 6:15\n+          (_0.1: u64) = move _5;           // scope 0 at $DIR/combine_clone_of_primitives.rs:6:10: 6:15\n+          (_0.2: [f32; 3]) = move _8;      // scope 0 at $DIR/combine_clone_of_primitives.rs:6:10: 6:15\n+          StorageDead(_8);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:6:14: 6:15\n+          StorageDead(_5);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:6:14: 6:15\n           StorageDead(_2);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:6:14: 6:15\n+          StorageDead(_10);                // scope 0 at $DIR/combine_clone_of_primitives.rs:6:14: 6:15\n+          StorageDead(_7);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:6:14: 6:15\n+          StorageDead(_4);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:6:14: 6:15\n           return;                          // scope 0 at $DIR/combine_clone_of_primitives.rs:6:15: 6:15\n       }\n   \n       bb4 (cleanup): {\n-          drop(_5) -> bb5;                 // scope 1 at $DIR/combine_clone_of_primitives.rs:6:14: 6:15\n+          drop(_2) -> bb5;                 // scope 0 at $DIR/combine_clone_of_primitives.rs:6:14: 6:15\n       }\n   \n       bb5 (cleanup): {"}, {"sha": "65eb1008dd83bf47f0ae71c3fa691ec9bbe12a33", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.uses_crate.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d46c728bcda687b1cf5f3bedca3d501e797b2a0f/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/d46c728bcda687b1cf5f3bedca3d501e797b2a0f/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt?ref=d46c728bcda687b1cf5f3bedca3d501e797b2a0f", "patch": "@@ -36,12 +36,12 @@\n    22|      2|    println!(\"used_only_from_this_lib_crate_generic_function with {:?}\", arg);\n    23|      2|}\n   ------------------\n-  | used_crate::used_only_from_this_lib_crate_generic_function::<&str>:\n+  | used_crate::used_only_from_this_lib_crate_generic_function::<alloc::vec::Vec<i32>>:\n   |   21|      1|pub fn used_only_from_this_lib_crate_generic_function<T: Debug>(arg: T) {\n   |   22|      1|    println!(\"used_only_from_this_lib_crate_generic_function with {:?}\", arg);\n   |   23|      1|}\n   ------------------\n-  | used_crate::used_only_from_this_lib_crate_generic_function::<alloc::vec::Vec<i32>>:\n+  | used_crate::used_only_from_this_lib_crate_generic_function::<&str>:\n   |   21|      1|pub fn used_only_from_this_lib_crate_generic_function<T: Debug>(arg: T) {\n   |   22|      1|    println!(\"used_only_from_this_lib_crate_generic_function with {:?}\", arg);\n   |   23|      1|}"}, {"sha": "028ed9c230524dc88ac717c8962b1b13a620812c", "filename": "src/test/ui/deriving/deriving-all-codegen.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d46c728bcda687b1cf5f3bedca3d501e797b2a0f/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46c728bcda687b1cf5f3bedca3d501e797b2a0f/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.rs?ref=d46c728bcda687b1cf5f3bedca3d501e797b2a0f", "patch": "@@ -28,12 +28,17 @@ struct Point {\n     y: u32,\n }\n \n-// A long struct.\n+// A large struct.\n #[derive(Clone, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n struct Big {\n     b1: u32, b2: u32, b3: u32, b4: u32, b5: u32, b6: u32, b7: u32, b8:u32,\n }\n \n+// A packed tuple struct.\n+#[derive(Clone, Copy, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+#[repr(packed)]\n+struct Packed(u32);\n+\n // A C-like, fieldless enum.\n #[derive(Clone, Copy, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n enum Fieldless {"}, {"sha": "c24ed4237b8ee0fbc2ddf42c2d6f4aab6ca57fff", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 246, "deletions": 324, "changes": 570, "blob_url": "https://github.com/rust-lang/rust/blob/d46c728bcda687b1cf5f3bedca3d501e797b2a0f/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/d46c728bcda687b1cf5f3bedca3d501e797b2a0f/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=d46c728bcda687b1cf5f3bedca3d501e797b2a0f", "patch": "@@ -37,7 +37,7 @@ impl ::core::marker::Copy for Empty { }\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Empty {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        match *self { Self => ::core::fmt::Formatter::write_str(f, \"Empty\"), }\n+        ::core::fmt::Formatter::write_str(f, \"Empty\")\n     }\n }\n #[automatically_derived]\n@@ -49,18 +49,14 @@ impl ::core::default::Default for Empty {\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Empty {\n-    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        match *self { Self => {} }\n-    }\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () { {} }\n }\n impl ::core::marker::StructuralPartialEq for Empty {}\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Empty {\n     #[inline]\n-    fn eq(&self, other: &Empty) -> bool {\n-        match *other { Self => match *self { Self => true, }, }\n-    }\n+    fn eq(&self, other: &Empty) -> bool { true }\n }\n impl ::core::marker::StructuralEq for Empty {}\n #[automatically_derived]\n@@ -77,23 +73,15 @@ impl ::core::cmp::PartialOrd for Empty {\n     #[inline]\n     fn partial_cmp(&self, other: &Empty)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        match *other {\n-            Self =>\n-                match *self {\n-                    Self =>\n-                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                },\n-        }\n+        ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n     }\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Empty {\n     #[inline]\n     fn cmp(&self, other: &Empty) -> ::core::cmp::Ordering {\n-        match *other {\n-            Self => match *self { Self => ::core::cmp::Ordering::Equal, },\n-        }\n+        ::core::cmp::Ordering::Equal\n     }\n }\n \n@@ -121,11 +109,8 @@ impl ::core::marker::Copy for Point { }\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Point {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        match *self {\n-            Self { x: ref __self_0_0, y: ref __self_0_1 } =>\n-                ::core::fmt::Formatter::debug_struct_field2_finish(f, \"Point\",\n-                    \"x\", &&(*__self_0_0), \"y\", &&(*__self_0_1)),\n-        }\n+        ::core::fmt::Formatter::debug_struct_field2_finish(f, \"Point\", \"x\",\n+            &&self.x, \"y\", &&self.y)\n     }\n }\n #[automatically_derived]\n@@ -143,11 +128,9 @@ impl ::core::default::Default for Point {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Point {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        match *self {\n-            Self { x: ref __self_0_0, y: ref __self_0_1 } => {\n-                ::core::hash::Hash::hash(&(*__self_0_0), state);\n-                ::core::hash::Hash::hash(&(*__self_0_1), state)\n-            }\n+        {\n+            ::core::hash::Hash::hash(&self.x, state);\n+            ::core::hash::Hash::hash(&self.y, state)\n         }\n     }\n }\n@@ -157,25 +140,11 @@ impl ::core::marker::StructuralPartialEq for Point {}\n impl ::core::cmp::PartialEq for Point {\n     #[inline]\n     fn eq(&self, other: &Point) -> bool {\n-        match *other {\n-            Self { x: ref __self_1_0, y: ref __self_1_1 } =>\n-                match *self {\n-                    Self { x: ref __self_0_0, y: ref __self_0_1 } =>\n-                        (*__self_0_0) == (*__self_1_0) &&\n-                            (*__self_0_1) == (*__self_1_1),\n-                },\n-        }\n+        self.x == other.x && self.y == other.y\n     }\n     #[inline]\n     fn ne(&self, other: &Point) -> bool {\n-        match *other {\n-            Self { x: ref __self_1_0, y: ref __self_1_1 } =>\n-                match *self {\n-                    Self { x: ref __self_0_0, y: ref __self_0_1 } =>\n-                        (*__self_0_0) != (*__self_1_0) ||\n-                            (*__self_0_1) != (*__self_1_1),\n-                },\n-        }\n+        self.x != other.x || self.y != other.y\n     }\n }\n impl ::core::marker::StructuralEq for Point {}\n@@ -198,24 +167,16 @@ impl ::core::cmp::PartialOrd for Point {\n     #[inline]\n     fn partial_cmp(&self, other: &Point)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        match *other {\n-            Self { x: ref __self_1_0, y: ref __self_1_1 } =>\n-                match *self {\n-                    Self { x: ref __self_0_0, y: ref __self_0_1 } =>\n-                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),\n-                                &(*__self_1_0)) {\n-                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                =>\n-                                match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),\n-                                        &(*__self_1_1)) {\n-                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                        =>\n-                                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                                    cmp => cmp,\n-                                },\n-                            cmp => cmp,\n-                        },\n+        match ::core::cmp::PartialOrd::partial_cmp(&self.x, &other.x) {\n+            ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n+                match ::core::cmp::PartialOrd::partial_cmp(&self.y, &other.y)\n+                    {\n+                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                        =>\n+                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                    cmp => cmp,\n                 },\n+            cmp => cmp,\n         }\n     }\n }\n@@ -224,27 +185,19 @@ impl ::core::cmp::PartialOrd for Point {\n impl ::core::cmp::Ord for Point {\n     #[inline]\n     fn cmp(&self, other: &Point) -> ::core::cmp::Ordering {\n-        match *other {\n-            Self { x: ref __self_1_0, y: ref __self_1_1 } =>\n-                match *self {\n-                    Self { x: ref __self_0_0, y: ref __self_0_1 } =>\n-                        match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0))\n-                            {\n-                            ::core::cmp::Ordering::Equal =>\n-                                match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1))\n-                                    {\n-                                    ::core::cmp::Ordering::Equal =>\n-                                        ::core::cmp::Ordering::Equal,\n-                                    cmp => cmp,\n-                                },\n-                            cmp => cmp,\n-                        },\n+        match ::core::cmp::Ord::cmp(&self.x, &other.x) {\n+            ::core::cmp::Ordering::Equal =>\n+                match ::core::cmp::Ord::cmp(&self.y, &other.y) {\n+                    ::core::cmp::Ordering::Equal =>\n+                        ::core::cmp::Ordering::Equal,\n+                    cmp => cmp,\n                 },\n+            cmp => cmp,\n         }\n     }\n }\n \n-// A long struct.\n+// A large struct.\n struct Big {\n     b1: u32,\n     b2: u32,\n@@ -260,52 +213,30 @@ struct Big {\n impl ::core::clone::Clone for Big {\n     #[inline]\n     fn clone(&self) -> Big {\n-        match *self {\n-            Self {\n-                b1: ref __self_0_0,\n-                b2: ref __self_0_1,\n-                b3: ref __self_0_2,\n-                b4: ref __self_0_3,\n-                b5: ref __self_0_4,\n-                b6: ref __self_0_5,\n-                b7: ref __self_0_6,\n-                b8: ref __self_0_7 } =>\n-                Big {\n-                    b1: ::core::clone::Clone::clone(&(*__self_0_0)),\n-                    b2: ::core::clone::Clone::clone(&(*__self_0_1)),\n-                    b3: ::core::clone::Clone::clone(&(*__self_0_2)),\n-                    b4: ::core::clone::Clone::clone(&(*__self_0_3)),\n-                    b5: ::core::clone::Clone::clone(&(*__self_0_4)),\n-                    b6: ::core::clone::Clone::clone(&(*__self_0_5)),\n-                    b7: ::core::clone::Clone::clone(&(*__self_0_6)),\n-                    b8: ::core::clone::Clone::clone(&(*__self_0_7)),\n-                },\n+        Big {\n+            b1: ::core::clone::Clone::clone(&self.b1),\n+            b2: ::core::clone::Clone::clone(&self.b2),\n+            b3: ::core::clone::Clone::clone(&self.b3),\n+            b4: ::core::clone::Clone::clone(&self.b4),\n+            b5: ::core::clone::Clone::clone(&self.b5),\n+            b6: ::core::clone::Clone::clone(&self.b6),\n+            b7: ::core::clone::Clone::clone(&self.b7),\n+            b8: ::core::clone::Clone::clone(&self.b8),\n         }\n     }\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Big {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        match *self {\n-            Self {\n-                b1: ref __self_0_0,\n-                b2: ref __self_0_1,\n-                b3: ref __self_0_2,\n-                b4: ref __self_0_3,\n-                b5: ref __self_0_4,\n-                b6: ref __self_0_5,\n-                b7: ref __self_0_6,\n-                b8: ref __self_0_7 } => {\n-                let names: &'static _ =\n-                    &[\"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"b6\", \"b7\", \"b8\"];\n-                let values: &[&dyn ::core::fmt::Debug] =\n-                    &[&&(*__self_0_0), &&(*__self_0_1), &&(*__self_0_2),\n-                                &&(*__self_0_3), &&(*__self_0_4), &&(*__self_0_5),\n-                                &&(*__self_0_6), &&(*__self_0_7)];\n-                ::core::fmt::Formatter::debug_struct_fields_finish(f, \"Big\",\n-                    names, values)\n-            }\n+        {\n+            let names: &'static _ =\n+                &[\"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"b6\", \"b7\", \"b8\"];\n+            let values: &[&dyn ::core::fmt::Debug] =\n+                &[&&self.b1, &&self.b2, &&self.b3, &&self.b4, &&self.b5,\n+                            &&self.b6, &&self.b7, &&self.b8];\n+            ::core::fmt::Formatter::debug_struct_fields_finish(f, \"Big\",\n+                names, values)\n         }\n     }\n }\n@@ -330,25 +261,15 @@ impl ::core::default::Default for Big {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Big {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        match *self {\n-            Self {\n-                b1: ref __self_0_0,\n-                b2: ref __self_0_1,\n-                b3: ref __self_0_2,\n-                b4: ref __self_0_3,\n-                b5: ref __self_0_4,\n-                b6: ref __self_0_5,\n-                b7: ref __self_0_6,\n-                b8: ref __self_0_7 } => {\n-                ::core::hash::Hash::hash(&(*__self_0_0), state);\n-                ::core::hash::Hash::hash(&(*__self_0_1), state);\n-                ::core::hash::Hash::hash(&(*__self_0_2), state);\n-                ::core::hash::Hash::hash(&(*__self_0_3), state);\n-                ::core::hash::Hash::hash(&(*__self_0_4), state);\n-                ::core::hash::Hash::hash(&(*__self_0_5), state);\n-                ::core::hash::Hash::hash(&(*__self_0_6), state);\n-                ::core::hash::Hash::hash(&(*__self_0_7), state)\n-            }\n+        {\n+            ::core::hash::Hash::hash(&self.b1, state);\n+            ::core::hash::Hash::hash(&self.b2, state);\n+            ::core::hash::Hash::hash(&self.b3, state);\n+            ::core::hash::Hash::hash(&self.b4, state);\n+            ::core::hash::Hash::hash(&self.b5, state);\n+            ::core::hash::Hash::hash(&self.b6, state);\n+            ::core::hash::Hash::hash(&self.b7, state);\n+            ::core::hash::Hash::hash(&self.b8, state)\n         }\n     }\n }\n@@ -358,69 +279,17 @@ impl ::core::marker::StructuralPartialEq for Big {}\n impl ::core::cmp::PartialEq for Big {\n     #[inline]\n     fn eq(&self, other: &Big) -> bool {\n-        match *other {\n-            Self {\n-                b1: ref __self_1_0,\n-                b2: ref __self_1_1,\n-                b3: ref __self_1_2,\n-                b4: ref __self_1_3,\n-                b5: ref __self_1_4,\n-                b6: ref __self_1_5,\n-                b7: ref __self_1_6,\n-                b8: ref __self_1_7 } =>\n-                match *self {\n-                    Self {\n-                        b1: ref __self_0_0,\n-                        b2: ref __self_0_1,\n-                        b3: ref __self_0_2,\n-                        b4: ref __self_0_3,\n-                        b5: ref __self_0_4,\n-                        b6: ref __self_0_5,\n-                        b7: ref __self_0_6,\n-                        b8: ref __self_0_7 } =>\n-                        (*__self_0_0) == (*__self_1_0) &&\n-                                                    (*__self_0_1) == (*__self_1_1) &&\n-                                                (*__self_0_2) == (*__self_1_2) &&\n-                                            (*__self_0_3) == (*__self_1_3) &&\n-                                        (*__self_0_4) == (*__self_1_4) &&\n-                                    (*__self_0_5) == (*__self_1_5) &&\n-                                (*__self_0_6) == (*__self_1_6) &&\n-                            (*__self_0_7) == (*__self_1_7),\n-                },\n-        }\n+        self.b1 == other.b1 && self.b2 == other.b2 && self.b3 == other.b3 &&\n+                            self.b4 == other.b4 && self.b5 == other.b5 &&\n+                    self.b6 == other.b6 && self.b7 == other.b7 &&\n+            self.b8 == other.b8\n     }\n     #[inline]\n     fn ne(&self, other: &Big) -> bool {\n-        match *other {\n-            Self {\n-                b1: ref __self_1_0,\n-                b2: ref __self_1_1,\n-                b3: ref __self_1_2,\n-                b4: ref __self_1_3,\n-                b5: ref __self_1_4,\n-                b6: ref __self_1_5,\n-                b7: ref __self_1_6,\n-                b8: ref __self_1_7 } =>\n-                match *self {\n-                    Self {\n-                        b1: ref __self_0_0,\n-                        b2: ref __self_0_1,\n-                        b3: ref __self_0_2,\n-                        b4: ref __self_0_3,\n-                        b5: ref __self_0_4,\n-                        b6: ref __self_0_5,\n-                        b7: ref __self_0_6,\n-                        b8: ref __self_0_7 } =>\n-                        (*__self_0_0) != (*__self_1_0) ||\n-                                                    (*__self_0_1) != (*__self_1_1) ||\n-                                                (*__self_0_2) != (*__self_1_2) ||\n-                                            (*__self_0_3) != (*__self_1_3) ||\n-                                        (*__self_0_4) != (*__self_1_4) ||\n-                                    (*__self_0_5) != (*__self_1_5) ||\n-                                (*__self_0_6) != (*__self_1_6) ||\n-                            (*__self_0_7) != (*__self_1_7),\n-                },\n-        }\n+        self.b1 != other.b1 || self.b2 != other.b2 || self.b3 != other.b3 ||\n+                            self.b4 != other.b4 || self.b5 != other.b5 ||\n+                    self.b6 != other.b6 || self.b7 != other.b7 ||\n+            self.b8 != other.b8\n     }\n }\n impl ::core::marker::StructuralEq for Big {}\n@@ -449,63 +318,37 @@ impl ::core::cmp::PartialOrd for Big {\n     #[inline]\n     fn partial_cmp(&self, other: &Big)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        match *other {\n-            Self {\n-                b1: ref __self_1_0,\n-                b2: ref __self_1_1,\n-                b3: ref __self_1_2,\n-                b4: ref __self_1_3,\n-                b5: ref __self_1_4,\n-                b6: ref __self_1_5,\n-                b7: ref __self_1_6,\n-                b8: ref __self_1_7 } =>\n-                match *self {\n-                    Self {\n-                        b1: ref __self_0_0,\n-                        b2: ref __self_0_1,\n-                        b3: ref __self_0_2,\n-                        b4: ref __self_0_3,\n-                        b5: ref __self_0_4,\n-                        b6: ref __self_0_5,\n-                        b7: ref __self_0_6,\n-                        b8: ref __self_0_7 } =>\n-                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),\n-                                &(*__self_1_0)) {\n+        match ::core::cmp::PartialOrd::partial_cmp(&self.b1, &other.b1) {\n+            ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n+                match ::core::cmp::PartialOrd::partial_cmp(&self.b2,\n+                        &other.b2) {\n+                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                        =>\n+                        match ::core::cmp::PartialOrd::partial_cmp(&self.b3,\n+                                &other.b3) {\n                             ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n                                 =>\n-                                match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),\n-                                        &(*__self_1_1)) {\n+                                match ::core::cmp::PartialOrd::partial_cmp(&self.b4,\n+                                        &other.b4) {\n                                     ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n                                         =>\n-                                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_2),\n-                                                &(*__self_1_2)) {\n+                                        match ::core::cmp::PartialOrd::partial_cmp(&self.b5,\n+                                                &other.b5) {\n                                             ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n                                                 =>\n-                                                match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_3),\n-                                                        &(*__self_1_3)) {\n+                                                match ::core::cmp::PartialOrd::partial_cmp(&self.b6,\n+                                                        &other.b6) {\n                                                     ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n                                                         =>\n-                                                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_4),\n-                                                                &(*__self_1_4)) {\n+                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.b7,\n+                                                                &other.b7) {\n                                                             ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n                                                                 =>\n-                                                                match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_5),\n-                                                                        &(*__self_1_5)) {\n+                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.b8,\n+                                                                        &other.b8) {\n                                                                     ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n                                                                         =>\n-                                                                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_6),\n-                                                                                &(*__self_1_6)) {\n-                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                                                                =>\n-                                                                                match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_7),\n-                                                                                        &(*__self_1_7)) {\n-                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                                                                        =>\n-                                                                                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                                                                                    cmp => cmp,\n-                                                                                },\n-                                                                            cmp => cmp,\n-                                                                        },\n+                                                                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n                                                                     cmp => cmp,\n                                                                 },\n                                                             cmp => cmp,\n@@ -518,7 +361,9 @@ impl ::core::cmp::PartialOrd for Big {\n                                 },\n                             cmp => cmp,\n                         },\n+                    cmp => cmp,\n                 },\n+            cmp => cmp,\n         }\n     }\n }\n@@ -527,55 +372,23 @@ impl ::core::cmp::PartialOrd for Big {\n impl ::core::cmp::Ord for Big {\n     #[inline]\n     fn cmp(&self, other: &Big) -> ::core::cmp::Ordering {\n-        match *other {\n-            Self {\n-                b1: ref __self_1_0,\n-                b2: ref __self_1_1,\n-                b3: ref __self_1_2,\n-                b4: ref __self_1_3,\n-                b5: ref __self_1_4,\n-                b6: ref __self_1_5,\n-                b7: ref __self_1_6,\n-                b8: ref __self_1_7 } =>\n-                match *self {\n-                    Self {\n-                        b1: ref __self_0_0,\n-                        b2: ref __self_0_1,\n-                        b3: ref __self_0_2,\n-                        b4: ref __self_0_3,\n-                        b5: ref __self_0_4,\n-                        b6: ref __self_0_5,\n-                        b7: ref __self_0_6,\n-                        b8: ref __self_0_7 } =>\n-                        match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0))\n-                            {\n+        match ::core::cmp::Ord::cmp(&self.b1, &other.b1) {\n+            ::core::cmp::Ordering::Equal =>\n+                match ::core::cmp::Ord::cmp(&self.b2, &other.b2) {\n+                    ::core::cmp::Ordering::Equal =>\n+                        match ::core::cmp::Ord::cmp(&self.b3, &other.b3) {\n                             ::core::cmp::Ordering::Equal =>\n-                                match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1))\n-                                    {\n+                                match ::core::cmp::Ord::cmp(&self.b4, &other.b4) {\n                                     ::core::cmp::Ordering::Equal =>\n-                                        match ::core::cmp::Ord::cmp(&(*__self_0_2), &(*__self_1_2))\n-                                            {\n+                                        match ::core::cmp::Ord::cmp(&self.b5, &other.b5) {\n                                             ::core::cmp::Ordering::Equal =>\n-                                                match ::core::cmp::Ord::cmp(&(*__self_0_3), &(*__self_1_3))\n-                                                    {\n+                                                match ::core::cmp::Ord::cmp(&self.b6, &other.b6) {\n                                                     ::core::cmp::Ordering::Equal =>\n-                                                        match ::core::cmp::Ord::cmp(&(*__self_0_4), &(*__self_1_4))\n-                                                            {\n+                                                        match ::core::cmp::Ord::cmp(&self.b7, &other.b7) {\n                                                             ::core::cmp::Ordering::Equal =>\n-                                                                match ::core::cmp::Ord::cmp(&(*__self_0_5), &(*__self_1_5))\n-                                                                    {\n+                                                                match ::core::cmp::Ord::cmp(&self.b8, &other.b8) {\n                                                                     ::core::cmp::Ordering::Equal =>\n-                                                                        match ::core::cmp::Ord::cmp(&(*__self_0_6), &(*__self_1_6))\n-                                                                            {\n-                                                                            ::core::cmp::Ordering::Equal =>\n-                                                                                match ::core::cmp::Ord::cmp(&(*__self_0_7), &(*__self_1_7))\n-                                                                                    {\n-                                                                                    ::core::cmp::Ordering::Equal =>\n-                                                                                        ::core::cmp::Ordering::Equal,\n-                                                                                    cmp => cmp,\n-                                                                                },\n-                                                                            cmp => cmp,\n-                                                                        },\n+                                                                        ::core::cmp::Ordering::Equal,\n                                                                     cmp => cmp,\n                                                                 },\n                                                             cmp => cmp,\n@@ -588,7 +401,116 @@ impl ::core::cmp::Ord for Big {\n                                 },\n                             cmp => cmp,\n                         },\n+                    cmp => cmp,\n                 },\n+            cmp => cmp,\n+        }\n+    }\n+}\n+\n+// A packed tuple struct.\n+#[repr(packed)]\n+struct Packed(u32);\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::clone::Clone for Packed {\n+    #[inline]\n+    fn clone(&self) -> Packed {\n+        { let _: ::core::clone::AssertParamIsClone<u32>; *self }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::marker::Copy for Packed { }\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::fmt::Debug for Packed {\n+    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+        {\n+            let Self(__self_0_0) = *self;\n+            ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Packed\",\n+                &&__self_0_0)\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::default::Default for Packed {\n+    #[inline]\n+    fn default() -> Packed { Packed(::core::default::Default::default()) }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::hash::Hash for Packed {\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        {\n+            let Self(__self_0_0) = *self;\n+            { ::core::hash::Hash::hash(&__self_0_0, state) }\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralPartialEq for Packed {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialEq for Packed {\n+    #[inline]\n+    fn eq(&self, other: &Packed) -> bool {\n+        {\n+            let Self(__self_0_0) = *self;\n+            let Self(__self_1_0) = *other;\n+            __self_0_0 == __self_1_0\n+        }\n+    }\n+    #[inline]\n+    fn ne(&self, other: &Packed) -> bool {\n+        {\n+            let Self(__self_0_0) = *self;\n+            let Self(__self_1_0) = *other;\n+            __self_0_0 != __self_1_0\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralEq for Packed {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Eq for Packed {\n+    #[inline]\n+    #[doc(hidden)]\n+    #[no_coverage]\n+    fn assert_receiver_is_total_eq(&self) -> () {\n+        { let _: ::core::cmp::AssertParamIsEq<u32>; }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialOrd for Packed {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Packed)\n+        -> ::core::option::Option<::core::cmp::Ordering> {\n+        {\n+            let Self(__self_0_0) = *self;\n+            let Self(__self_1_0) = *other;\n+            match ::core::cmp::PartialOrd::partial_cmp(&__self_0_0,\n+                    &__self_1_0) {\n+                ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n+                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                cmp => cmp,\n+            }\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Ord for Packed {\n+    #[inline]\n+    fn cmp(&self, other: &Packed) -> ::core::cmp::Ordering {\n+        {\n+            let Self(__self_0_0) = *self;\n+            let Self(__self_1_0) = *other;\n+            match ::core::cmp::Ord::cmp(&__self_0_0, &__self_1_0) {\n+                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,\n+                cmp => cmp,\n+            }\n         }\n     }\n }\n@@ -738,10 +660,10 @@ impl ::core::fmt::Debug for Mixed {\n             (&Mixed::Q,) => ::core::fmt::Formatter::write_str(f, \"Q\"),\n             (&Mixed::R(ref __self_0),) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"R\",\n-                    &&(*__self_0)),\n+                    &&*__self_0),\n             (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },) =>\n                 ::core::fmt::Formatter::debug_struct_field2_finish(f, \"S\",\n-                    \"d1\", &&(*__self_0), \"d2\", &&(*__self_1)),\n+                    \"d1\", &&*__self_0, \"d2\", &&*__self_1),\n         }\n     }\n }\n@@ -759,13 +681,13 @@ impl ::core::hash::Hash for Mixed {\n             (&Mixed::R(ref __self_0),) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n-                ::core::hash::Hash::hash(&(*__self_0), state)\n+                ::core::hash::Hash::hash(&*__self_0, state)\n             }\n             (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n-                ::core::hash::Hash::hash(&(*__self_0), state);\n-                ::core::hash::Hash::hash(&(*__self_1), state)\n+                ::core::hash::Hash::hash(&*__self_0, state);\n+                ::core::hash::Hash::hash(&*__self_1, state)\n             }\n             _ => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n@@ -786,10 +708,10 @@ impl ::core::cmp::PartialEq for Mixed {\n             if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) {\n                         (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n-                            (*__self_0) == (*__arg_1_0),\n+                            *__self_0 == *__arg_1_0,\n                         (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n                             &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n-                            (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),\n+                            *__self_0 == *__arg_1_0 && *__self_1 == *__arg_1_1,\n                         _ => true,\n                     }\n                 } else { false }\n@@ -803,10 +725,10 @@ impl ::core::cmp::PartialEq for Mixed {\n             if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) {\n                         (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n-                            (*__self_0) != (*__arg_1_0),\n+                            *__self_0 != *__arg_1_0,\n                         (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n                             &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n-                            (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),\n+                            *__self_0 != *__arg_1_0 || *__self_1 != *__arg_1_1,\n                         _ => false,\n                     }\n                 } else { true }\n@@ -840,21 +762,21 @@ impl ::core::cmp::PartialOrd for Mixed {\n             if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) {\n                         (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n-                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),\n-                                    &(*__arg_1_0)) {\n+                            match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                                    &*__arg_1_0) {\n                                 ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n                                     =>\n                                     ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n                                 cmp => cmp,\n                             },\n                         (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n                             &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n-                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),\n-                                    &(*__arg_1_0)) {\n+                            match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                                    &*__arg_1_0) {\n                                 ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n                                     =>\n-                                    match ::core::cmp::PartialOrd::partial_cmp(&(*__self_1),\n-                                            &(*__arg_1_1)) {\n+                                    match ::core::cmp::PartialOrd::partial_cmp(&*__self_1,\n+                                            &*__arg_1_1) {\n                                         ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n                                             =>\n                                             ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n@@ -883,16 +805,16 @@ impl ::core::cmp::Ord for Mixed {\n             if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) {\n                         (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n-                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {\n+                            match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n                                 ::core::cmp::Ordering::Equal =>\n                                     ::core::cmp::Ordering::Equal,\n                                 cmp => cmp,\n                             },\n                         (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n                             &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n-                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {\n+                            match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n                                 ::core::cmp::Ordering::Equal =>\n-                                    match ::core::cmp::Ord::cmp(&(*__self_1), &(*__arg_1_1)) {\n+                                    match ::core::cmp::Ord::cmp(&*__self_1, &*__arg_1_1) {\n                                         ::core::cmp::Ordering::Equal =>\n                                             ::core::cmp::Ordering::Equal,\n                                         cmp => cmp,\n@@ -916,11 +838,11 @@ impl ::core::clone::Clone for Fielded {\n     fn clone(&self) -> Fielded {\n         match (&*self,) {\n             (&Fielded::X(ref __self_0),) =>\n-                Fielded::X(::core::clone::Clone::clone(&(*__self_0))),\n+                Fielded::X(::core::clone::Clone::clone(&*__self_0)),\n             (&Fielded::Y(ref __self_0),) =>\n-                Fielded::Y(::core::clone::Clone::clone(&(*__self_0))),\n+                Fielded::Y(::core::clone::Clone::clone(&*__self_0)),\n             (&Fielded::Z(ref __self_0),) =>\n-                Fielded::Z(::core::clone::Clone::clone(&(*__self_0))),\n+                Fielded::Z(::core::clone::Clone::clone(&*__self_0)),\n         }\n     }\n }\n@@ -931,13 +853,13 @@ impl ::core::fmt::Debug for Fielded {\n         match (&*self,) {\n             (&Fielded::X(ref __self_0),) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"X\",\n-                    &&(*__self_0)),\n+                    &&*__self_0),\n             (&Fielded::Y(ref __self_0),) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Y\",\n-                    &&(*__self_0)),\n+                    &&*__self_0),\n             (&Fielded::Z(ref __self_0),) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Z\",\n-                    &&(*__self_0)),\n+                    &&*__self_0),\n         }\n     }\n }\n@@ -949,17 +871,17 @@ impl ::core::hash::Hash for Fielded {\n             (&Fielded::X(ref __self_0),) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n-                ::core::hash::Hash::hash(&(*__self_0), state)\n+                ::core::hash::Hash::hash(&*__self_0, state)\n             }\n             (&Fielded::Y(ref __self_0),) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n-                ::core::hash::Hash::hash(&(*__self_0), state)\n+                ::core::hash::Hash::hash(&*__self_0, state)\n             }\n             (&Fielded::Z(ref __self_0),) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n-                ::core::hash::Hash::hash(&(*__self_0), state)\n+                ::core::hash::Hash::hash(&*__self_0, state)\n             }\n         }\n     }\n@@ -976,11 +898,11 @@ impl ::core::cmp::PartialEq for Fielded {\n             if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) {\n                         (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n-                            (*__self_0) == (*__arg_1_0),\n+                            *__self_0 == *__arg_1_0,\n                         (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n-                            (*__self_0) == (*__arg_1_0),\n+                            *__self_0 == *__arg_1_0,\n                         (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n-                            (*__self_0) == (*__arg_1_0),\n+                            *__self_0 == *__arg_1_0,\n                         _ => unsafe { ::core::intrinsics::unreachable() }\n                     }\n                 } else { false }\n@@ -994,11 +916,11 @@ impl ::core::cmp::PartialEq for Fielded {\n             if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) {\n                         (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n-                            (*__self_0) != (*__arg_1_0),\n+                            *__self_0 != *__arg_1_0,\n                         (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n-                            (*__self_0) != (*__arg_1_0),\n+                            *__self_0 != *__arg_1_0,\n                         (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n-                            (*__self_0) != (*__arg_1_0),\n+                            *__self_0 != *__arg_1_0,\n                         _ => unsafe { ::core::intrinsics::unreachable() }\n                     }\n                 } else { true }\n@@ -1032,24 +954,24 @@ impl ::core::cmp::PartialOrd for Fielded {\n             if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) {\n                         (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n-                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),\n-                                    &(*__arg_1_0)) {\n+                            match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                                    &*__arg_1_0) {\n                                 ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n                                     =>\n                                     ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n                                 cmp => cmp,\n                             },\n                         (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n-                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),\n-                                    &(*__arg_1_0)) {\n+                            match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                                    &*__arg_1_0) {\n                                 ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n                                     =>\n                                     ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n                                 cmp => cmp,\n                             },\n                         (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n-                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),\n-                                    &(*__arg_1_0)) {\n+                            match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                                    &*__arg_1_0) {\n                                 ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n                                     =>\n                                     ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n@@ -1075,19 +997,19 @@ impl ::core::cmp::Ord for Fielded {\n             if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) {\n                         (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n-                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {\n+                            match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n                                 ::core::cmp::Ordering::Equal =>\n                                     ::core::cmp::Ordering::Equal,\n                                 cmp => cmp,\n                             },\n                         (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n-                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {\n+                            match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n                                 ::core::cmp::Ordering::Equal =>\n                                     ::core::cmp::Ordering::Equal,\n                                 cmp => cmp,\n                             },\n                         (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n-                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {\n+                            match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n                                 ::core::cmp::Ordering::Equal =>\n                                     ::core::cmp::Ordering::Equal,\n                                 cmp => cmp,"}]}