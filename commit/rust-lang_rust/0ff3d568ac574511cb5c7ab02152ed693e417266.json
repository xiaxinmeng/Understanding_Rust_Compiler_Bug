{"sha": "0ff3d568ac574511cb5c7ab02152ed693e417266", "node_id": "C_kwDOAAsO6NoAKDBmZjNkNTY4YWM1NzQ1MTFjYjVjN2FiMDIxNTJlZDY5M2U0MTcyNjY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-04-02T13:40:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-02T13:40:08Z"}, "message": "Merge #11881\n\n11881: fix: Don't rely on lang items to find primitive impls r=flodiebold a=flodiebold\n\nrustc has removed the use of lang items to mark the primitive impls, so just look through the crate graph for them (this should be fine performance-wise since we cache the crates that contain these impls).\r\n\r\nFixes #11876.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "8abd962966283780a1a36cfccd9052302b9d17b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8abd962966283780a1a36cfccd9052302b9d17b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ff3d568ac574511cb5c7ab02152ed693e417266", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiSFI4CRBK7hj4Ov3rIwAAZbUIAAa7G4Paczk99g7s2VdvUzBc\n0Dyb6yvruGjXbvWJxzhhANCxtDG1B3FGyGhwlB3+HRLu8ruFMrt7EwzK5jOw/A2f\n6/FqyvCS15VMXDJ/S31NdFBseIqW0kTqr/SoHHmHnwt/+TWrLJFj+0tnDqOx3LmN\nIcnhZNPyDIwfvrI4G3f/3lKwIIgA17kL5KycCQfAP9qGzLchUwmXCCJecTLxzSzN\npDVM1Zntr3Oi9XIP6+rnvP+nw02tPdFZrtyuxnXs120P3dRACmdae3nUYsfX4kn7\nUrzetcAUTMjmIr4K9Eh+8uofYrdxuC2A692kLsqgbUqfqq5aKVpulcuX8nWfN9g=\n=yiYH\n-----END PGP SIGNATURE-----\n", "payload": "tree 8abd962966283780a1a36cfccd9052302b9d17b6\nparent 5fe366c649728c4af44ba7c306ba8d1223581a08\nparent b898808a35c8f38ec795187ed79ca13f4bdf7848\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1648906808 +0000\ncommitter GitHub <noreply@github.com> 1648906808 +0000\n\nMerge #11881\n\n11881: fix: Don't rely on lang items to find primitive impls r=flodiebold a=flodiebold\n\nrustc has removed the use of lang items to mark the primitive impls, so just look through the crate graph for them (this should be fine performance-wise since we cache the crates that contain these impls).\r\n\r\nFixes #11876.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ff3d568ac574511cb5c7ab02152ed693e417266", "html_url": "https://github.com/rust-lang/rust/commit/0ff3d568ac574511cb5c7ab02152ed693e417266", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ff3d568ac574511cb5c7ab02152ed693e417266/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fe366c649728c4af44ba7c306ba8d1223581a08", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fe366c649728c4af44ba7c306ba8d1223581a08", "html_url": "https://github.com/rust-lang/rust/commit/5fe366c649728c4af44ba7c306ba8d1223581a08"}, {"sha": "b898808a35c8f38ec795187ed79ca13f4bdf7848", "url": "https://api.github.com/repos/rust-lang/rust/commits/b898808a35c8f38ec795187ed79ca13f4bdf7848", "html_url": "https://github.com/rust-lang/rust/commit/b898808a35c8f38ec795187ed79ca13f4bdf7848"}], "stats": {"total": 182, "additions": 92, "deletions": 90}, "files": [{"sha": "de4c153590242523559bdd3bed90fca7e84a0d48", "filename": "crates/hir_ty/src/db.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0ff3d568ac574511cb5c7ab02152ed693e417266/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff3d568ac574511cb5c7ab02152ed693e417266/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdb.rs?ref=0ff3d568ac574511cb5c7ab02152ed693e417266", "patch": "@@ -3,6 +3,7 @@\n \n use std::sync::Arc;\n \n+use arrayvec::ArrayVec;\n use base_db::{impl_intern_key, salsa, CrateId, Upcast};\n use hir_def::{\n     db::DefDatabase, expr::ExprId, BlockId, ConstId, ConstParamId, DefWithBodyId, FunctionId,\n@@ -13,7 +14,7 @@ use la_arena::ArenaMap;\n use crate::{\n     chalk_db,\n     consteval::{ComputedExpr, ConstEvalError},\n-    method_resolution::{InherentImpls, TraitImpls},\n+    method_resolution::{InherentImpls, TraitImpls, TyFingerprint},\n     Binders, CallableDefId, FnDefId, GenericArg, ImplTraitId, InferenceResult, Interner, PolyFnSig,\n     QuantifiedWhereClause, ReturnTypeImplTraits, TraitRef, Ty, TyDefId, ValueTyDefId,\n };\n@@ -86,6 +87,12 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(InherentImpls::inherent_impls_in_block_query)]\n     fn inherent_impls_in_block(&self, block: BlockId) -> Option<Arc<InherentImpls>>;\n \n+    /// Collects all crates in the dependency graph that have impls for the\n+    /// given fingerprint. This is only used for primitive types; for\n+    /// user-defined types we just look at the crate where the type is defined.\n+    #[salsa::invoke(crate::method_resolution::inherent_impl_crates_query)]\n+    fn inherent_impl_crates(&self, krate: CrateId, fp: TyFingerprint) -> ArrayVec<CrateId, 2>;\n+\n     #[salsa::invoke(TraitImpls::trait_impls_in_crate_query)]\n     fn trait_impls_in_crate(&self, krate: CrateId) -> Arc<TraitImpls>;\n "}, {"sha": "d5285c1710604471fb08b5782fcb6fe7bbc0d0e6", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 45, "deletions": 55, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/0ff3d568ac574511cb5c7ab02152ed693e417266/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff3d568ac574511cb5c7ab02152ed693e417266/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=0ff3d568ac574511cb5c7ab02152ed693e417266", "patch": "@@ -8,9 +8,8 @@ use arrayvec::ArrayVec;\n use base_db::{CrateId, Edition};\n use chalk_ir::{cast::Cast, Mutability, UniverseIndex};\n use hir_def::{\n-    item_scope::ItemScope, lang_item::LangItemTarget, nameres::DefMap, AssocItemId, BlockId,\n-    ConstId, FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId,\n-    ModuleId, TraitId,\n+    item_scope::ItemScope, nameres::DefMap, AssocItemId, BlockId, ConstId, FunctionId,\n+    GenericDefId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId, ModuleId, TraitId,\n };\n use hir_expand::name::Name;\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -21,7 +20,7 @@ use crate::{\n     db::HirDatabase,\n     from_foreign_def_id,\n     infer::{unify::InferenceTable, Adjust, Adjustment, AutoBorrow, OverloadedDeref, PointerCast},\n-    primitive::{self, FloatTy, IntTy, UintTy},\n+    primitive::{FloatTy, IntTy, UintTy},\n     static_lifetime,\n     utils::all_super_traits,\n     AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, ForeignDefId, InEnvironment, Interner,\n@@ -337,6 +336,30 @@ impl InherentImpls {\n     }\n }\n \n+pub fn inherent_impl_crates_query(\n+    db: &dyn HirDatabase,\n+    krate: CrateId,\n+    fp: TyFingerprint,\n+) -> ArrayVec<CrateId, 2> {\n+    let _p = profile::span(\"inherent_impl_crates_query\");\n+    let mut res = ArrayVec::new();\n+    let crate_graph = db.crate_graph();\n+\n+    for krate in crate_graph.transitive_deps(krate) {\n+        if res.is_full() {\n+            // we don't currently look for or store more than two crates here,\n+            // so don't needlessly look at more crates than necessary.\n+            break;\n+        }\n+        let impls = db.inherent_impls_in_crate(krate);\n+        if impls.map.get(&fp).map_or(false, |v| !v.is_empty()) {\n+            res.push(krate);\n+        }\n+    }\n+\n+    res\n+}\n+\n fn collect_unnamed_consts<'a>(\n     db: &'a dyn HirDatabase,\n     scope: &'a ItemScope,\n@@ -370,63 +393,30 @@ pub fn def_crates(\n     ty: &Ty,\n     cur_crate: CrateId,\n ) -> Option<ArrayVec<CrateId, 2>> {\n-    // Types like slice can have inherent impls in several crates, (core and alloc).\n-    // The corresponding impls are marked with lang items, so we can use them to find the required crates.\n-    macro_rules! lang_item_crate {\n-            ($($name:expr),+ $(,)?) => {{\n-                let mut v = ArrayVec::<LangItemTarget, 2>::new();\n-                $(\n-                    v.extend(db.lang_item(cur_crate, $name.into()));\n-                )+\n-                v\n-            }};\n-        }\n-\n     let mod_to_crate_ids = |module: ModuleId| Some(iter::once(module.krate()).collect());\n \n-    let lang_item_targets = match ty.kind(Interner) {\n-        TyKind::Adt(AdtId(def_id), _) => {\n-            return mod_to_crate_ids(def_id.module(db.upcast()));\n-        }\n+    let fp = TyFingerprint::for_inherent_impl(ty);\n+\n+    match ty.kind(Interner) {\n+        TyKind::Adt(AdtId(def_id), _) => mod_to_crate_ids(def_id.module(db.upcast())),\n         TyKind::Foreign(id) => {\n-            return mod_to_crate_ids(\n-                from_foreign_def_id(*id).lookup(db.upcast()).module(db.upcast()),\n-            );\n-        }\n-        TyKind::Scalar(Scalar::Bool) => lang_item_crate!(\"bool\"),\n-        TyKind::Scalar(Scalar::Char) => lang_item_crate!(\"char\"),\n-        TyKind::Scalar(Scalar::Float(f)) => match f {\n-            // There are two lang items: one in libcore (fXX) and one in libstd (fXX_runtime)\n-            FloatTy::F32 => lang_item_crate!(\"f32\", \"f32_runtime\"),\n-            FloatTy::F64 => lang_item_crate!(\"f64\", \"f64_runtime\"),\n-        },\n-        &TyKind::Scalar(Scalar::Int(t)) => {\n-            lang_item_crate!(primitive::int_ty_to_string(t))\n+            mod_to_crate_ids(from_foreign_def_id(*id).lookup(db.upcast()).module(db.upcast()))\n         }\n-        &TyKind::Scalar(Scalar::Uint(t)) => {\n-            lang_item_crate!(primitive::uint_ty_to_string(t))\n-        }\n-        TyKind::Str => lang_item_crate!(\"str_alloc\", \"str\"),\n-        TyKind::Slice(_) => lang_item_crate!(\"slice_alloc\", \"slice\"),\n-        TyKind::Array(..) => lang_item_crate!(\"array\"),\n-        TyKind::Raw(Mutability::Not, _) => lang_item_crate!(\"const_ptr\"),\n-        TyKind::Raw(Mutability::Mut, _) => lang_item_crate!(\"mut_ptr\"),\n-        TyKind::Dyn(_) => {\n-            return ty.dyn_trait().and_then(|trait_| {\n-                mod_to_crate_ids(GenericDefId::TraitId(trait_).module(db.upcast()))\n-            });\n+        TyKind::Dyn(_) => ty\n+            .dyn_trait()\n+            .and_then(|trait_| mod_to_crate_ids(GenericDefId::TraitId(trait_).module(db.upcast()))),\n+        // for primitives, there may be impls in various places (core and alloc\n+        // mostly). We just check the whole crate graph for crates with impls\n+        // (cached behind a query).\n+        TyKind::Scalar(_)\n+        | TyKind::Str\n+        | TyKind::Slice(_)\n+        | TyKind::Array(..)\n+        | TyKind::Raw(..) => {\n+            Some(db.inherent_impl_crates(cur_crate, fp.expect(\"fingerprint for primitive\")))\n         }\n         _ => return None,\n-    };\n-    let res = lang_item_targets\n-        .into_iter()\n-        .filter_map(|it| match it {\n-            LangItemTarget::ImplDefId(it) => Some(it),\n-            _ => None,\n-        })\n-        .map(|it| it.lookup(db.upcast()).container.krate())\n-        .collect();\n-    Some(res)\n+    }\n }\n \n /// Look up the method with the given name."}, {"sha": "d97147541ad11abf11cf4be95a56781b49a2fb81", "filename": "crates/hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0ff3d568ac574511cb5c7ab02152ed693e417266/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff3d568ac574511cb5c7ab02152ed693e417266/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=0ff3d568ac574511cb5c7ab02152ed693e417266", "patch": "@@ -6,50 +6,55 @@ use super::{check_infer, check_no_mismatches, check_types};\n \n #[test]\n fn infer_slice_method() {\n-    check_infer(\n+    check_types(\n         r#\"\n-        #[lang = \"slice\"]\n-        impl<T> [T] {\n-            fn foo(&self) -> T {\n-                loop {}\n-            }\n-        }\n-\n-        #[lang = \"slice_alloc\"]\n-        impl<T> [T] {}\n+impl<T> [T] {\n+    fn foo(&self) -> T {\n+        loop {}\n+    }\n+}\n \n-        fn test(x: &[u8]) {\n-            <[_]>::foo(x);\n-        }\n+fn test(x: &[u8]) {\n+    <[_]>::foo(x);\n+  //^^^^^^^^^^^^^ u8\n+}\n         \"#,\n-        expect![[r#\"\n-            44..48 'self': &[T]\n-            55..78 '{     ...     }': T\n-            65..72 'loop {}': !\n-            70..72 '{}': ()\n-            130..131 'x': &[u8]\n-            140..162 '{     ...(x); }': ()\n-            146..156 '<[_]>::foo': fn foo<u8>(&[u8]) -> u8\n-            146..159 '<[_]>::foo(x)': u8\n-            157..158 'x': &[u8]\n-        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn cross_crate_primitive_method() {\n+    check_types(\n+        r#\"\n+//- /main.rs crate:main deps:other_crate\n+fn test() {\n+    let x = 1f32;\n+    x.foo();\n+} //^^^^^^^ f32\n+\n+//- /lib.rs crate:other_crate\n+mod foo {\n+    impl f32 {\n+        pub fn foo(self) -> f32 { 0. }\n+    }\n+}\n+\"#,\n     );\n }\n \n #[test]\n fn infer_array_inherent_impl() {\n     check_types(\n         r#\"\n-        #[lang = \"array\"]\n-        impl<T, const N: usize> [T; N] {\n-            fn foo(&self) -> T {\n-                loop {}\n-            }\n-        }\n-        fn test(x: &[u8; 0]) {\n-            <[_; 0]>::foo(x);\n-          //^^^^^^^^^^^^^^^^ u8\n-        }\n+impl<T, const N: usize> [T; N] {\n+    fn foo(&self) -> T {\n+        loop {}\n+    }\n+}\n+fn test(x: &[u8; 0]) {\n+    <[_; 0]>::foo(x);\n+  //^^^^^^^^^^^^^^^^ u8\n+}\n         \"#,\n     );\n }"}]}