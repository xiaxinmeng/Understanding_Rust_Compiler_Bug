{"sha": "8dd715ee5e462384668e3c83c17ee641e9776b64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkZDcxNWVlNWU0NjIzODQ2NjhlM2M4M2MxN2VlNjQxZTk3NzZiNjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-04T09:33:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-04T09:33:33Z"}, "message": "Auto merge of #51895 - nikomatsakis:move-self-trait-predicate-to-items, r=scalexm\n\nMove self trait predicate to items\n\nThis is a \"reimagination\" of @tmandry's PR #50183. The main effect is described in this comment from one of the commits:\n\n---\n\nBefore we had the following results for `predicates_of`:\n\n```rust\ntrait Foo { // predicates_of: Self: Foo\n  fn bar(); // predicates_of: Self: Foo (inherited from trait)\n}\n```\n\nNow we have removed the `Self: Foo` from the trait. However, we still\nadd it to the trait ITEM. This is because when people do things like\n`<T as Foo>::bar()`, they still need to prove that `T: Foo`, and\nhaving it in the `predicates_of` seems to be the cleanest way to\nensure that happens right now (otherwise, we'd need special case code\nin various places):\n\n```rust\ntrait Foo { // predicates_of: []\n  fn bar(); // predicates_of: Self: Foo\n}\n```\n\nHowever, we sometimes want to get the list of *just* the predicates\ntruly defined on a trait item (e.g., for chalk, but also for a few\nother bits of code). For that, we define `predicates_defined_on`,\nwhich does not contain the `Self: Foo` predicate yet, and we plumb\nthat through metadata and so forth.\n\n---\n\nI'm assigning @eddyb as the main reviewer, but I thought I might delegate to scalexm for this one in any case. I also want to post an alternative that I'll leave in the comments; it occurred to me as I was writing. =)\n\nr? @eddyb\ncc @scalexm @tmandry @leodasvacas", "tree": {"sha": "7174b02139c75cca14582615e9615758dd723971", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7174b02139c75cca14582615e9615758dd723971"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dd715ee5e462384668e3c83c17ee641e9776b64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dd715ee5e462384668e3c83c17ee641e9776b64", "html_url": "https://github.com/rust-lang/rust/commit/8dd715ee5e462384668e3c83c17ee641e9776b64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dd715ee5e462384668e3c83c17ee641e9776b64/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a739c51d108b1958a1c3e145588035c580e7973a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a739c51d108b1958a1c3e145588035c580e7973a", "html_url": "https://github.com/rust-lang/rust/commit/a739c51d108b1958a1c3e145588035c580e7973a"}, {"sha": "90ea49b891937eb7f121c1ded01ceacb66074e74", "url": "https://api.github.com/repos/rust-lang/rust/commits/90ea49b891937eb7f121c1ded01ceacb66074e74", "html_url": "https://github.com/rust-lang/rust/commit/90ea49b891937eb7f121c1ded01ceacb66074e74"}], "stats": {"total": 272, "additions": 205, "deletions": 67}, "files": [{"sha": "3c4472aef6bed3157d8013bb3d4b28696903724b", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=8dd715ee5e462384668e3c83c17ee641e9776b64", "patch": "@@ -504,6 +504,7 @@ define_dep_nodes!( <'tcx>\n     [] GenericsOfItem(DefId),\n     [] PredicatesOfItem(DefId),\n     [] ExplicitPredicatesOfItem(DefId),\n+    [] PredicatesDefinedOnItem(DefId),\n     [] InferredOutlivesOf(DefId),\n     [] InferredOutlivesCrate(CrateNum),\n     [] SuperPredicatesOfItem(DefId),"}, {"sha": "83128ba75d5827e25ef060703e1ffc20b02b2a15", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=8dd715ee5e462384668e3c83c17ee641e9776b64", "patch": "@@ -23,7 +23,6 @@ use hir::def_id::DefId;\n use lint;\n use traits;\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n-use ty::subst::Substs;\n use ty::util::ExplicitSelf;\n use std::borrow::Cow;\n use syntax::ast;\n@@ -173,10 +172,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         trait_def_id: DefId,\n         supertraits_only: bool) -> bool\n     {\n-        let trait_ref = ty::Binder::dummy(ty::TraitRef {\n-            def_id: trait_def_id,\n-            substs: Substs::identity_for_item(self, trait_def_id)\n-        });\n+        let trait_ref = ty::Binder::dummy(ty::TraitRef::identity(self, trait_def_id));\n         let predicates = if supertraits_only {\n             self.super_predicates_of(trait_def_id)\n         } else {\n@@ -391,10 +387,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n                     // Compute supertraits of current trait lazily.\n                     if supertraits.is_none() {\n-                        let trait_ref = ty::Binder::bind(ty::TraitRef {\n-                            def_id: trait_def_id,\n-                            substs: Substs::identity_for_item(self, trait_def_id)\n-                        });\n+                        let trait_ref = ty::Binder::bind(\n+                            ty::TraitRef::identity(self, trait_def_id),\n+                        );\n                         supertraits = Some(traits::supertraits(self, trait_ref).collect());\n                     }\n "}, {"sha": "40171345f558b6b2210364c22cbb582fe1454815", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=8dd715ee5e462384668e3c83c17ee641e9776b64", "patch": "@@ -1237,6 +1237,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let mut candidates: Vec<EvaluatedCandidate> =\n             candidates?.into_iter().filter_map(|c| c).collect();\n \n+        debug!(\"winnowed to {} candidates for {:?}: {:?}\",\n+               candidates.len(),\n+               stack,\n+               candidates);\n+\n         // If there are STILL multiple candidate, we can further\n         // reduce the list by dropping duplicates -- including\n         // resolving specializations."}, {"sha": "98042f6389db6c9ba5e9332d3fa3b034c5f84038", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=8dd715ee5e462384668e3c83c17ee641e9776b64", "patch": "@@ -2862,8 +2862,8 @@ fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n     // Compute the bounds on Self and the type parameters.\n \n-    let bounds = tcx.predicates_of(def_id).instantiate_identity(tcx);\n-    let predicates = bounds.predicates;\n+    let InstantiatedPredicates { predicates } =\n+        tcx.predicates_of(def_id).instantiate_identity(tcx);\n \n     // Finally, we have to normalize the bounds in the environment, in\n     // case they contain any associated type projections. This process"}, {"sha": "9ad93b4d5e233117ade9d905014c6f4c490c65e6", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=8dd715ee5e462384668e3c83c17ee641e9776b64", "patch": "@@ -101,11 +101,39 @@ define_queries! { <'tcx>\n     [] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n-    /// associated generics and predicates.\n+    /// associated generics.\n     [] fn generics_of: GenericsOfItem(DefId) -> &'tcx ty::Generics,\n+\n+    /// Maps from the def-id of an item (trait/struct/enum/fn) to the\n+    /// predicates (where clauses) that must be proven true in order\n+    /// to reference it. This is almost always the \"predicates query\"\n+    /// that you want.\n+    ///\n+    /// `predicates_of` builds on `predicates_defined_on` -- in fact,\n+    /// it is almost always the same as that query, except for the\n+    /// case of traits. For traits, `predicates_of` contains\n+    /// an additional `Self: Trait<...>` predicate that users don't\n+    /// actually write. This reflects the fact that to invoke the\n+    /// trait (e.g., via `Default::default`) you must supply types\n+    /// that actually implement the trait. (However, this extra\n+    /// predicate gets in the way of some checks, which are intended\n+    /// to operate over only the actual where-clauses written by the\n+    /// user.)\n     [] fn predicates_of: PredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n+\n+    /// Maps from the def-id of an item (trait/struct/enum/fn) to the\n+    /// predicates (where clauses) directly defined on it. This is\n+    /// equal to the `explicit_predicates_of` predicates plus the\n+    /// `inferred_outlives_of` predicates.\n+    [] fn predicates_defined_on: PredicatesDefinedOnItem(DefId) -> ty::GenericPredicates<'tcx>,\n+\n+    /// Returns the predicates written explicit by the user.\n     [] fn explicit_predicates_of: ExplicitPredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n \n+    /// Returns the inferred outlives predicates (e.g., for `struct\n+    /// Foo<'a, T> { x: &'a T }`, this would return `T: 'a`).\n+    [] fn inferred_outlives_of: InferredOutlivesOf(DefId) -> Lrc<Vec<ty::Predicate<'tcx>>>,\n+\n     /// Maps from the def-id of a trait to the list of\n     /// super-predicates. This is a subset of the full list of\n     /// predicates. We store these in a separate map because we must\n@@ -141,9 +169,6 @@ define_queries! { <'tcx>\n     /// (inferred) variance.\n     [] fn variances_of: ItemVariances(DefId) -> Lrc<Vec<ty::Variance>>,\n \n-    /// Maps from def-id of a type to its (inferred) outlives.\n-    [] fn inferred_outlives_of: InferredOutlivesOf(DefId) -> Lrc<Vec<ty::Predicate<'tcx>>>,\n-\n     /// Maps from def-id of a type to its (inferred) outlives.\n     [] fn inferred_outlives_crate: InferredOutlivesCrate(CrateNum)\n         -> Lrc<ty::CratePredicatesMap<'tcx>>,"}, {"sha": "9f802f7fdcd4241c4c6512c4861d789ccb41de27", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=8dd715ee5e462384668e3c83c17ee641e9776b64", "patch": "@@ -1074,6 +1074,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::TypeOfItem => { force!(type_of, def_id!()); }\n         DepKind::GenericsOfItem => { force!(generics_of, def_id!()); }\n         DepKind::PredicatesOfItem => { force!(predicates_of, def_id!()); }\n+        DepKind::PredicatesDefinedOnItem => { force!(predicates_defined_on, def_id!()); }\n         DepKind::ExplicitPredicatesOfItem => { force!(explicit_predicates_of, def_id!()); }\n         DepKind::InferredOutlivesOf => { force!(inferred_outlives_of, def_id!()); }\n         DepKind::InferredOutlivesCrate => { force!(inferred_outlives_crate, LOCAL_CRATE); }"}, {"sha": "f93da53e0436d16f69f8ee23e76ebc737793f98d", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=8dd715ee5e462384668e3c83c17ee641e9776b64", "patch": "@@ -614,6 +614,15 @@ impl<'tcx> TraitRef<'tcx> {\n         TraitRef { def_id: def_id, substs: substs }\n     }\n \n+    /// Returns a TraitRef of the form `P0: Foo<P1..Pn>` where `Pi`\n+    /// are the parameters defined on trait.\n+    pub fn identity<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId) -> TraitRef<'tcx> {\n+        TraitRef {\n+            def_id,\n+            substs: Substs::identity_for_item(tcx, def_id),\n+        }\n+    }\n+\n     pub fn self_ty(&self) -> Ty<'tcx> {\n         self.substs.type_at(0)\n     }"}, {"sha": "f118d22c54d3fcff49c5f993f483b5d6e8a01c8c", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=8dd715ee5e462384668e3c83c17ee641e9776b64", "patch": "@@ -518,10 +518,25 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         result\n     }\n \n+    /// True if `def_id` refers to a closure (e.g., `|x| x * 2`). Note\n+    /// that closures have a def-id, but the closure *expression* also\n+    /// has a `HirId` that is located within the context where the\n+    /// closure appears (and, sadly, a corresponding `NodeId`, since\n+    /// those are not yet phased out). The parent of the closure's\n+    /// def-id will also be the context where it appears.\n     pub fn is_closure(self, def_id: DefId) -> bool {\n         self.def_key(def_id).disambiguated_data.data == DefPathData::ClosureExpr\n     }\n \n+    /// True if `def_id` refers to a trait (e.g., `trait Foo { ... }`).\n+    pub fn is_trait(self, def_id: DefId) -> bool {\n+        if let DefPathData::Trait(_) = self.def_key(def_id).disambiguated_data.data {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     /// True if this def-id refers to the implicit constructor for\n     /// a tuple struct like `struct Foo(u32)`.\n     pub fn is_struct_constructor(self, def_id: DefId) -> bool {"}, {"sha": "20d9121668ba0b40893d6ad2f7f51897a5a24176", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=8dd715ee5e462384668e3c83c17ee641e9776b64", "patch": "@@ -107,6 +107,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         tcx.alloc_generics(cdata.get_generics(def_id.index, tcx.sess))\n     }\n     predicates_of => { cdata.get_predicates(def_id.index, tcx) }\n+    predicates_defined_on => { cdata.get_predicates_defined_on(def_id.index, tcx) }\n     super_predicates_of => { cdata.get_super_predicates(def_id.index, tcx) }\n     trait_def => {\n         tcx.alloc_trait_def(cdata.get_trait_def(def_id.index, tcx.sess))"}, {"sha": "d604ac819b83b6af6a1b123075a01a4b1ac227a9", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=8dd715ee5e462384668e3c83c17ee641e9776b64", "patch": "@@ -563,6 +563,13 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(item_id).predicates.unwrap().decode((self, tcx))\n     }\n \n+    pub fn get_predicates_defined_on(&self,\n+                                   item_id: DefIndex,\n+                                   tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                   -> ty::GenericPredicates<'tcx> {\n+        self.entry(item_id).predicates_defined_on.unwrap().decode((self, tcx))\n+    }\n+\n     pub fn get_super_predicates(&self,\n                                 item_id: DefIndex,\n                                 tcx: TyCtxt<'a, 'tcx, 'tcx>)"}, {"sha": "36f053e5aa9759e0cadcdd92e6bf502f57006621", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=8dd715ee5e462384668e3c83c17ee641e9776b64", "patch": "@@ -629,6 +629,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n+            predicates_defined_on: None,\n \n             mir: self.encode_optimized_mir(def_id),\n         }\n@@ -666,6 +667,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             variances: LazySeq::empty(),\n             generics: None,\n             predicates: None,\n+            predicates_defined_on: None,\n \n             mir: None\n         }\n@@ -706,6 +708,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             variances: LazySeq::empty(),\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n+            predicates_defined_on: None,\n \n             mir: None,\n         }\n@@ -763,6 +766,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n+            predicates_defined_on: None,\n \n             mir: self.encode_optimized_mir(def_id),\n         }\n@@ -780,6 +784,12 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         self.lazy(&tcx.predicates_of(def_id))\n     }\n \n+    fn encode_predicates_defined_on(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n+        debug!(\"IsolatedEncoder::encode_predicates_defined_on({:?})\", def_id);\n+        let tcx = self.tcx;\n+        self.lazy(&tcx.predicates_defined_on(def_id))\n+    }\n+\n     fn encode_info_for_trait_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n@@ -869,6 +879,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n+            predicates_defined_on: None,\n \n             mir: self.encode_optimized_mir(def_id),\n         }\n@@ -965,6 +976,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n+            predicates_defined_on: None,\n \n             mir: if mir { self.encode_optimized_mir(def_id) } else { None },\n         }\n@@ -1228,6 +1240,16 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 _ => None,\n             },\n \n+            // The only time that `predicates_defined_on` is used (on\n+            // an external item) is for traits, during chalk lowering,\n+            // so only encode it in that case as an efficiency\n+            // hack. (No reason not to expand it in the future if\n+            // necessary.)\n+            predicates_defined_on: match item.node {\n+                hir::ItemTrait(..) => Some(self.encode_predicates_defined_on(def_id)),\n+                _ => None, // not *wrong* for other kinds of items, but not needed\n+            },\n+\n             mir: match item.node {\n                 hir::ItemStatic(..) => {\n                     self.encode_optimized_mir(def_id)\n@@ -1278,6 +1300,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             variances: LazySeq::empty(),\n             generics: None,\n             predicates: None,\n+            predicates_defined_on: None,\n             mir: None,\n         }\n     }\n@@ -1305,6 +1328,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             variances: LazySeq::empty(),\n             generics: None,\n             predicates: None,\n+            predicates_defined_on: None,\n \n             mir: None,\n         }\n@@ -1349,6 +1373,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             variances: LazySeq::empty(),\n             generics: Some(self.encode_generics(def_id)),\n             predicates: None,\n+            predicates_defined_on: None,\n \n             mir: self.encode_optimized_mir(def_id),\n         }\n@@ -1376,6 +1401,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             variances: LazySeq::empty(),\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n+            predicates_defined_on: None,\n \n             mir: self.encode_optimized_mir(def_id),\n         }\n@@ -1577,6 +1603,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n+            predicates_defined_on: None,\n \n             mir: None,\n         }"}, {"sha": "a0b21e63ac560278af6995c962e70f777287bbc5", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=8dd715ee5e462384668e3c83c17ee641e9776b64", "patch": "@@ -273,6 +273,7 @@ pub struct Entry<'tcx> {\n     pub variances: LazySeq<ty::Variance>,\n     pub generics: Option<Lazy<ty::Generics>>,\n     pub predicates: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n+    pub predicates_defined_on: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n \n     pub mir: Option<Lazy<mir::Mir<'tcx>>>,\n }\n@@ -290,6 +291,7 @@ impl_stable_hash_for!(struct Entry<'tcx> {\n     variances,\n     generics,\n     predicates,\n+    predicates_defined_on,\n     mir\n });\n "}, {"sha": "27daebbf8c12d4b9cf90720b8f9f3f13f9cca298", "filename": "src/librustc_traits/lowering.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc_traits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc_traits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering.rs?ref=8dd715ee5e462384668e3c83c17ee641e9776b64", "patch": "@@ -15,7 +15,6 @@ use rustc::hir::{self, ImplPolarity};\n use rustc::traits::{Clause, Clauses, DomainGoal, Goal, PolyDomainGoal, ProgramClause,\n                     WhereClause, FromEnv, WellFormed};\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::Substs;\n use rustc::ty::{self, Slice, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use std::mem;\n@@ -225,10 +224,7 @@ fn program_clauses_for_trait<'a, 'tcx>(\n \n     // `Self: Trait<P1..Pn>`\n     let trait_pred = ty::TraitPredicate {\n-        trait_ref: ty::TraitRef {\n-            def_id,\n-            substs: Substs::identity_for_item(tcx, def_id),\n-        },\n+        trait_ref: ty::TraitRef::identity(tcx, def_id),\n     };\n \n     // `Implemented(Self: Trait<P1..Pn>)`\n@@ -256,10 +252,8 @@ fn program_clauses_for_trait<'a, 'tcx>(\n     // ```\n \n     // `FromEnv(WC) :- FromEnv(Self: Trait<P1..Pn>)`, for each where clause WC\n-    // FIXME: Remove the [1..] slice; this is a hack because the query\n-    // predicates_of currently includes the trait itself (`Self: Trait<P1..Pn>`).\n-    let where_clauses = &tcx.predicates_of(def_id).predicates;\n-    let implied_bound_clauses = where_clauses[1..]\n+    let where_clauses = &tcx.predicates_defined_on(def_id).predicates;\n+    let implied_bound_clauses = where_clauses\n         .into_iter()\n         .map(|wc| wc.lower())\n "}, {"sha": "85fdcd417ff9d830266d2fcd89634e0772f9228e", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=8dd715ee5e462384668e3c83c17ee641e9776b64", "patch": "@@ -364,15 +364,16 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n /// Checks where clauses and inline bounds that are declared on def_id.\n-fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-                                    fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n-                                    span: Span,\n-                                    def_id: DefId) {\n+fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n+    span: Span,\n+    def_id: DefId,\n+) {\n     use ty::subst::Subst;\n     use rustc::ty::TypeFoldable;\n \n-    let mut predicates = fcx.tcx.predicates_of(def_id);\n-    let mut substituted_predicates = Vec::new();\n+    let predicates = fcx.tcx.predicates_of(def_id);\n \n     let generics = tcx.generics_of(def_id);\n     let is_our_default = |def: &ty::GenericParamDef| {\n@@ -433,7 +434,7 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n         }\n     });\n     // Now we build the substituted predicates.\n-    for &pred in predicates.predicates.iter() {\n+    let default_obligations = predicates.predicates.iter().flat_map(|&pred| {\n         struct CountParams { params: FxHashSet<u32> }\n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for CountParams {\n             fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n@@ -455,21 +456,37 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n         let substituted_pred = pred.subst(fcx.tcx, substs);\n         // Don't check non-defaulted params, dependent defaults (including lifetimes)\n         // or preds with multiple params.\n-        if substituted_pred.references_error() || param_count.params.len() > 1\n-            || has_region {\n-            continue;\n-        }\n-        // Avoid duplication of predicates that contain no parameters, for example.\n-        if !predicates.predicates.contains(&substituted_pred) {\n-            substituted_predicates.push(substituted_pred);\n+        if {\n+            substituted_pred.references_error() || param_count.params.len() > 1\n+                || has_region\n+        } {\n+                None\n+        } else if predicates.predicates.contains(&substituted_pred) {\n+            // Avoid duplication of predicates that contain no parameters, for example.\n+            None\n+        } else {\n+            Some(substituted_pred)\n         }\n-    }\n+    }).map(|pred| {\n+        // convert each of those into an obligation. So if you have\n+        // something like `struct Foo<T: Copy = String>`, we would\n+        // take that predicate `T: Copy`, substitute to `String: Copy`\n+        // (actually that happens in the previous `flat_map` call),\n+        // and then try to prove it (in this case, we'll fail).\n+        //\n+        // Note the subtle difference from how we handle `predicates`\n+        // below: there, we are not trying to prove those predicates\n+        // to be *true* but merely *well-formed*.\n+        let pred = fcx.normalize_associated_types_in(span, &pred);\n+        let cause = traits::ObligationCause::new(span, fcx.body_id, traits::ItemObligation(def_id));\n+        traits::Obligation::new(cause, fcx.param_env, pred)\n+    });\n \n-    predicates.predicates.extend(substituted_predicates);\n     let predicates = predicates.instantiate_identity(fcx.tcx);\n     let predicates = fcx.normalize_associated_types_in(span, &predicates);\n \n-    let obligations =\n+    debug!(\"check_where_clauses: predicates={:?}\", predicates.predicates);\n+    let wf_obligations =\n         predicates.predicates\n                     .iter()\n                     .flat_map(|p| ty::wf::predicate_obligations(fcx,\n@@ -478,7 +495,8 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n                                                                 p,\n                                                                 span));\n \n-    for obligation in obligations {\n+    for obligation in wf_obligations.chain(default_obligations) {\n+        debug!(\"next obligation cause: {:?}\", obligation.cause);\n         fcx.register_predicate(obligation);\n     }\n }"}, {"sha": "94b17532cb7887af040b1c5d6743127857021c62", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=8dd715ee5e462384668e3c83c17ee641e9776b64", "patch": "@@ -67,6 +67,7 @@ pub fn provide(providers: &mut Providers) {\n         type_of,\n         generics_of,\n         predicates_of,\n+        predicates_defined_on,\n         explicit_predicates_of,\n         super_predicates_of,\n         type_param_predicates,\n@@ -274,10 +275,9 @@ fn type_param_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 ItemTrait(_, _, ref generics, ..) => {\n                     // Implied `Self: Trait` and supertrait bounds.\n                     if param_id == item_node_id {\n-                        result.predicates.push(ty::TraitRef {\n-                            def_id: item_def_id,\n-                            substs: Substs::identity_for_item(tcx, item_def_id)\n-                        }.to_predicate());\n+                        result.predicates.push(\n+                            ty::TraitRef::identity(tcx, item_def_id).to_predicate()\n+                        );\n                     }\n                     generics\n                 }\n@@ -1306,10 +1306,10 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n     })\n }\n \n-fn predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           def_id: DefId)\n-                           -> ty::GenericPredicates<'tcx> {\n-    let explicit = explicit_predicates_of(tcx, def_id);\n+fn predicates_defined_on<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   def_id: DefId)\n+                                   -> ty::GenericPredicates<'tcx> {\n+    let explicit = tcx.explicit_predicates_of(def_id);\n     let predicates = if tcx.sess.features_untracked().infer_outlives_requirements {\n         [&explicit.predicates[..], &tcx.inferred_outlives_of(def_id)[..]].concat()\n     } else { explicit.predicates };\n@@ -1320,9 +1320,35 @@ fn predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            def_id: DefId)\n                            -> ty::GenericPredicates<'tcx> {\n+    let ty::GenericPredicates { parent, mut predicates } =\n+        tcx.predicates_defined_on(def_id);\n+\n+    if tcx.is_trait(def_id) {\n+        // For traits, add `Self: Trait` predicate. This is\n+        // not part of the predicates that a user writes, but it\n+        // is something that one must prove in order to invoke a\n+        // method or project an associated type.\n+        //\n+        // In the chalk setup, this predicate is not part of the\n+        // \"predicates\" for a trait item. But it is useful in\n+        // rustc because if you directly (e.g.) invoke a trait\n+        // method like `Trait::method(...)`, you must naturally\n+        // prove that the trait applies to the types that were\n+        // used, and adding the predicate into this list ensures\n+        // that this is done.\n+        predicates.push(ty::TraitRef::identity(tcx, def_id).to_predicate());\n+    }\n+\n+    ty::GenericPredicates { parent, predicates }\n+}\n+\n+fn explicit_predicates_of<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+) -> ty::GenericPredicates<'tcx> {\n     use rustc::hir::map::*;\n     use rustc::hir::*;\n \n@@ -1337,7 +1363,10 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let icx = ItemCtxt::new(tcx, def_id);\n     let no_generics = hir::Generics::empty();\n     let ast_generics = match node {\n-        NodeTraitItem(item) => &item.generics,\n+        NodeTraitItem(item) => {\n+            &item.generics\n+        }\n+\n         NodeImplItem(item) => &item.generics,\n \n         NodeItem(item) => {\n@@ -1355,10 +1384,7 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 ItemUnion(_, ref generics) => generics,\n \n                 ItemTrait(_, _, ref generics, .., ref items) => {\n-                    is_trait = Some((ty::TraitRef {\n-                        def_id,\n-                        substs: Substs::identity_for_item(tcx, def_id)\n-                    }, items));\n+                    is_trait = Some((ty::TraitRef::identity(tcx, def_id), items));\n                     generics\n                 }\n                 ItemExistential(ref exist_ty) => {\n@@ -1405,12 +1431,8 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // and the explicit where-clauses, but to get the full set of predicates\n     // on a trait we need to add in the supertrait bounds and bounds found on\n     // associated types.\n-    if let Some((trait_ref, _)) = is_trait {\n+    if let Some((_trait_ref, _)) = is_trait {\n         predicates = tcx.super_predicates_of(def_id).predicates;\n-\n-        // Add in a predicate that `Self:Trait` (where `Trait` is the\n-        // current trait).  This is needed for builtin bounds.\n-        predicates.push(trait_ref.to_poly_trait_ref().to_predicate());\n     }\n \n     // In default impls, we can assume that the self type implements"}, {"sha": "812418a3053e99554784b49da3b316ff6b29efa9", "filename": "src/test/ui/chalkify/lower_env1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.stderr?ref=8dd715ee5e462384668e3c83c17ee641e9776b64", "patch": "@@ -4,7 +4,7 @@ error: program clause dump\n LL | #[rustc_dump_program_clauses] //~ ERROR program clause dump\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: FromEnv(Self: Bar) :- FromEnv(Self: Bar).\n+   = note: FromEnv(Self: Foo) :- FromEnv(Self: Bar).\n    = note: FromEnv(Self: Foo) :- FromEnv(Self: Bar).\n    = note: Implemented(Self: Bar) :- FromEnv(Self: Bar).\n \n@@ -14,7 +14,7 @@ error: program clause dump\n LL | #[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: FromEnv(Self: Bar) :- FromEnv(Self: Bar).\n+   = note: FromEnv(Self: Foo) :- FromEnv(Self: Bar).\n    = note: FromEnv(Self: Foo) :- FromEnv(Self: Bar).\n    = note: Implemented(Self: Bar) :- FromEnv(Self: Bar).\n    = note: Implemented(Self: Foo) :- FromEnv(Self: Foo)."}, {"sha": "f6d7086679a52560d98bc7accb128866ed5ed3ab", "filename": "src/test/ui/type-check-defaults.stderr", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Ftest%2Fui%2Ftype-check-defaults.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8dd715ee5e462384668e3c83c17ee641e9776b64/src%2Ftest%2Fui%2Ftype-check-defaults.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check-defaults.stderr?ref=8dd715ee5e462384668e3c83c17ee641e9776b64", "patch": "@@ -30,23 +30,35 @@ error[E0277]: the trait bound `std::string::String: std::marker::Copy` is not sa\n LL | struct Bounds<T:Copy=String>(T);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `std::string::String`\n    |\n-   = note: required by `std::marker::Copy`\n+note: required by `Bounds`\n+  --> $DIR/type-check-defaults.rs:21:1\n+   |\n+LL | struct Bounds<T:Copy=String>(T);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `std::string::String: std::marker::Copy` is not satisfied\n   --> $DIR/type-check-defaults.rs:24:1\n    |\n LL | struct WhereClause<T=String>(T) where T: Copy;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `std::string::String`\n    |\n-   = note: required by `std::marker::Copy`\n+note: required by `WhereClause`\n+  --> $DIR/type-check-defaults.rs:24:1\n+   |\n+LL | struct WhereClause<T=String>(T) where T: Copy;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `std::string::String: std::marker::Copy` is not satisfied\n   --> $DIR/type-check-defaults.rs:27:1\n    |\n LL | trait TraitBound<T:Copy=String> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `std::string::String`\n    |\n-   = note: required by `std::marker::Copy`\n+note: required by `TraitBound`\n+  --> $DIR/type-check-defaults.rs:27:1\n+   |\n+LL | trait TraitBound<T:Copy=String> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n   --> $DIR/type-check-defaults.rs:31:1\n@@ -68,7 +80,11 @@ LL | trait ProjectionPred<T:Iterator = IntoIter<i32>> where T::Item : Add<u8> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `i32 + u8`\n    |\n    = help: the trait `std::ops::Add<u8>` is not implemented for `i32`\n-   = note: required by `std::ops::Add`\n+note: required by `ProjectionPred`\n+  --> $DIR/type-check-defaults.rs:34:1\n+   |\n+LL | trait ProjectionPred<T:Iterator = IntoIter<i32>> where T::Item : Add<u8> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 7 previous errors\n "}]}