{"sha": "bf77850c8106a71b317fb6c707a28e00d258884c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmNzc4NTBjODEwNmE3MWIzMTdmYjZjNzA3YTI4ZTAwZDI1ODg4NGM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-03-11T09:22:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-11T09:22:09Z"}, "message": "Merge #3542\n\n3542: Renames work on struct field shorthands r=matklad a=m-n\n\nWhen renaming either a local or a struct field, struct field shorthands are now renamed correctly.\r\n\r\nHappy to refactor this if it doesn't fit the design of the code. Thanks for adding the suggestion of where to start on the issue.\r\n\r\nI wasn't sure if I should also look at the behavior of renaming when placing the cursor at the field shorthand; the following describes the behavior with this patch:\r\n\r\n```rust\r\n#[test]\r\nfn test_rename_field_shorthand_for_unspecified() {\r\n    // when renaming a shorthand, should we have a way to specify\r\n    // between renaming the field and the local?\r\n    //\r\n    // If not is this the correct default?\r\n    test_rename(\r\n        r#\"\r\nstruct Foo {\r\n    i: i32,\r\n}\r\n impl Foo {\r\n    fn new(i: i32) -> Self {\r\n        Self { i<|> }\r\n    }\r\n}\r\n\"#,\r\n        \"j\",\r\n        r#\"\r\nstruct Foo {\r\n    i: i32,\r\n}\r\n impl Foo {\r\n    fn new(j: i32) -> Self {\r\n        Self { i: j }\r\n    }\r\n}\r\n\"#,\r\n    );\r\n}\r\n```\r\nResolves #3431\n\nCo-authored-by: Matt Niemeir <matt.niemeir@gmail.com>", "tree": {"sha": "314afb27e80d7de8ccaf3f2eaa7b2e309de2e87f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/314afb27e80d7de8ccaf3f2eaa7b2e309de2e87f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf77850c8106a71b317fb6c707a28e00d258884c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeaK3BCRBK7hj4Ov3rIwAAdHIIADDB6HyjafgRvV/HNubZcZHZ\nU9TbBvSxLnknTwIASBzoOHLtDGa4PM/ZmmPTk+caabHXfBwb67cuS0fTmt+Y3hcR\nBuoz6NJkL3yStDwOMS2KV74pRmox4QQMXx+BZ7OXLgNI/+2gAMh6x4+ExP0OVuph\nhcKTdzIp2iGZBFSyxo8krUdv7s0lClaOvTayfJfiO2/7ewPE2abnCK6+wOGELVyF\ntU7Y01KDFPKfsqp7mCg6+5kQILUVaSHzQE8s4gbZCpTefLkKyemHDcBN/InEzlrI\n1zjmIiqhLGl5LYYFhhVM/78d0PBC5Pr9phlqw/HZcclypTerOqPAM9Bem1BTprI=\n=LlxR\n-----END PGP SIGNATURE-----\n", "payload": "tree 314afb27e80d7de8ccaf3f2eaa7b2e309de2e87f\nparent 0714a065d578e8b22b0451bfc64378c875fe858f\nparent 13ccbb2919dff8e98d0a242d9d6b7edd17a6bd2c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1583918529 +0000\ncommitter GitHub <noreply@github.com> 1583918529 +0000\n\nMerge #3542\n\n3542: Renames work on struct field shorthands r=matklad a=m-n\n\nWhen renaming either a local or a struct field, struct field shorthands are now renamed correctly.\r\n\r\nHappy to refactor this if it doesn't fit the design of the code. Thanks for adding the suggestion of where to start on the issue.\r\n\r\nI wasn't sure if I should also look at the behavior of renaming when placing the cursor at the field shorthand; the following describes the behavior with this patch:\r\n\r\n```rust\r\n#[test]\r\nfn test_rename_field_shorthand_for_unspecified() {\r\n    // when renaming a shorthand, should we have a way to specify\r\n    // between renaming the field and the local?\r\n    //\r\n    // If not is this the correct default?\r\n    test_rename(\r\n        r#\"\r\nstruct Foo {\r\n    i: i32,\r\n}\r\n impl Foo {\r\n    fn new(i: i32) -> Self {\r\n        Self { i<|> }\r\n    }\r\n}\r\n\"#,\r\n        \"j\",\r\n        r#\"\r\nstruct Foo {\r\n    i: i32,\r\n}\r\n impl Foo {\r\n    fn new(j: i32) -> Self {\r\n        Self { i: j }\r\n    }\r\n}\r\n\"#,\r\n    );\r\n}\r\n```\r\nResolves #3431\n\nCo-authored-by: Matt Niemeir <matt.niemeir@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf77850c8106a71b317fb6c707a28e00d258884c", "html_url": "https://github.com/rust-lang/rust/commit/bf77850c8106a71b317fb6c707a28e00d258884c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf77850c8106a71b317fb6c707a28e00d258884c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0714a065d578e8b22b0451bfc64378c875fe858f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0714a065d578e8b22b0451bfc64378c875fe858f", "html_url": "https://github.com/rust-lang/rust/commit/0714a065d578e8b22b0451bfc64378c875fe858f"}, {"sha": "13ccbb2919dff8e98d0a242d9d6b7edd17a6bd2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/13ccbb2919dff8e98d0a242d9d6b7edd17a6bd2c", "html_url": "https://github.com/rust-lang/rust/commit/13ccbb2919dff8e98d0a242d9d6b7edd17a6bd2c"}], "stats": {"total": 236, "additions": 210, "deletions": 26}, "files": [{"sha": "7d1190af9e972ae9578dcc3d407897228eac2c2f", "filename": "crates/ra_ide/src/references/rename.rs", "status": "modified", "additions": 187, "deletions": 21, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/bf77850c8106a71b317fb6c707a28e00d258884c/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf77850c8106a71b317fb6c707a28e00d258884c/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=bf77850c8106a71b317fb6c707a28e00d258884c", "patch": "@@ -9,7 +9,8 @@ use ra_syntax::{\n use ra_text_edit::TextEdit;\n \n use crate::{\n-    FileId, FilePosition, FileSystemEdit, RangeInfo, SourceChange, SourceFileEdit, TextRange,\n+    FilePosition, FileSystemEdit, RangeInfo, Reference, ReferenceKind, SourceChange,\n+    SourceFileEdit, TextRange,\n };\n \n use super::find_all_refs;\n@@ -46,12 +47,29 @@ fn find_name_and_module_at_offset(\n     Some((ast_name, ast_module))\n }\n \n-fn source_edit_from_file_id_range(\n-    file_id: FileId,\n-    range: TextRange,\n-    new_name: &str,\n-) -> SourceFileEdit {\n-    SourceFileEdit { file_id, edit: TextEdit::replace(range, new_name.into()) }\n+fn source_edit_from_reference(reference: Reference, new_name: &str) -> SourceFileEdit {\n+    let mut replacement_text = String::new();\n+    let file_id = reference.file_range.file_id;\n+    let range = match reference.kind {\n+        ReferenceKind::StructFieldShorthandForField => {\n+            replacement_text.push_str(new_name);\n+            replacement_text.push_str(\": \");\n+            TextRange::from_to(\n+                reference.file_range.range.start(),\n+                reference.file_range.range.start(),\n+            )\n+        }\n+        ReferenceKind::StructFieldShorthandForLocal => {\n+            replacement_text.push_str(\": \");\n+            replacement_text.push_str(new_name);\n+            TextRange::from_to(reference.file_range.range.end(), reference.file_range.range.end())\n+        }\n+        _ => {\n+            replacement_text.push_str(new_name);\n+            reference.file_range.range\n+        }\n+    };\n+    SourceFileEdit { file_id, edit: TextEdit::replace(range, replacement_text) }\n }\n \n fn rename_mod(\n@@ -99,13 +117,10 @@ fn rename_mod(\n     source_file_edits.push(edit);\n \n     if let Some(RangeInfo { range: _, info: refs }) = find_all_refs(sema.db, position, None) {\n-        let ref_edits = refs.references.into_iter().map(|reference| {\n-            source_edit_from_file_id_range(\n-                reference.file_range.file_id,\n-                reference.file_range.range,\n-                new_name,\n-            )\n-        });\n+        let ref_edits = refs\n+            .references\n+            .into_iter()\n+            .map(|reference| source_edit_from_reference(reference, new_name));\n         source_file_edits.extend(ref_edits);\n     }\n \n@@ -121,13 +136,7 @@ fn rename_reference(\n \n     let edit = refs\n         .into_iter()\n-        .map(|reference| {\n-            source_edit_from_file_id_range(\n-                reference.file_range.file_id,\n-                reference.file_range.range,\n-                new_name,\n-            )\n-        })\n+        .map(|reference| source_edit_from_reference(reference, new_name))\n         .collect::<Vec<_>>();\n \n     if edit.is_empty() {\n@@ -285,6 +294,163 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_rename_struct_field() {\n+        test_rename(\n+            r#\"\n+    struct Foo {\n+        i<|>: i32,\n+    }\n+\n+    impl Foo {\n+        fn new(i: i32) -> Self {\n+            Self { i: i }\n+        }\n+    }\n+    \"#,\n+            \"j\",\n+            r#\"\n+    struct Foo {\n+        j: i32,\n+    }\n+\n+    impl Foo {\n+        fn new(i: i32) -> Self {\n+            Self { j: i }\n+        }\n+    }\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_struct_field_for_shorthand() {\n+        test_rename(\n+            r#\"\n+    struct Foo {\n+        i<|>: i32,\n+    }\n+\n+    impl Foo {\n+        fn new(i: i32) -> Self {\n+            Self { i }\n+        }\n+    }\n+    \"#,\n+            \"j\",\n+            r#\"\n+    struct Foo {\n+        j: i32,\n+    }\n+\n+    impl Foo {\n+        fn new(i: i32) -> Self {\n+            Self { j: i }\n+        }\n+    }\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_local_for_field_shorthand() {\n+        test_rename(\n+            r#\"\n+    struct Foo {\n+        i: i32,\n+    }\n+\n+    impl Foo {\n+        fn new(i<|>: i32) -> Self {\n+            Self { i }\n+        }\n+    }\n+    \"#,\n+            \"j\",\n+            r#\"\n+    struct Foo {\n+        i: i32,\n+    }\n+\n+    impl Foo {\n+        fn new(j: i32) -> Self {\n+            Self { i: j }\n+        }\n+    }\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_field_shorthand_correct_struct() {\n+        test_rename(\n+            r#\"\n+    struct Foo {\n+        i<|>: i32,\n+    }\n+\n+    struct Bar {\n+        i: i32,\n+    }\n+\n+    impl Bar {\n+        fn new(i: i32) -> Self {\n+            Self { i }\n+        }\n+    }\n+    \"#,\n+            \"j\",\n+            r#\"\n+    struct Foo {\n+        j: i32,\n+    }\n+\n+    struct Bar {\n+        i: i32,\n+    }\n+\n+    impl Bar {\n+        fn new(i: i32) -> Self {\n+            Self { i }\n+        }\n+    }\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_shadow_local_for_struct_shorthand() {\n+        test_rename(\n+            r#\"\n+    struct Foo {\n+        i: i32,\n+    }\n+\n+    fn baz(i<|>: i32) -> Self {\n+         let x = Foo { i };\n+         {\n+             let i = 0;\n+             Foo { i }\n+         }\n+     }\n+    \"#,\n+            \"j\",\n+            r#\"\n+    struct Foo {\n+        i: i32,\n+    }\n+\n+    fn baz(j: i32) -> Self {\n+         let x = Foo { i: j };\n+         {\n+             let i = 0;\n+             Foo { i }\n+         }\n+     }\n+    \"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_rename_mod() {\n         let (analysis, position) = analysis_and_position("}, {"sha": "cf78d3e41ed58e650ef27084eede25e68cf16ff1", "filename": "crates/ra_ide_db/src/search.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bf77850c8106a71b317fb6c707a28e00d258884c/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf77850c8106a71b317fb6c707a28e00d258884c/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs?ref=bf77850c8106a71b317fb6c707a28e00d258884c", "patch": "@@ -17,7 +17,7 @@ use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n \n use crate::{\n-    defs::{classify_name_ref, Definition},\n+    defs::{classify_name_ref, Definition, NameRefClass},\n     RootDatabase,\n };\n \n@@ -30,6 +30,8 @@ pub struct Reference {\n \n #[derive(Debug, Clone, PartialEq)]\n pub enum ReferenceKind {\n+    StructFieldShorthandForField,\n+    StructFieldShorthandForLocal,\n     StructLiteral,\n     Other,\n }\n@@ -237,9 +239,8 @@ impl Definition {\n                 // FIXME: reuse sb\n                 // See https://github.com/rust-lang/rust/pull/68198#issuecomment-574269098\n \n-                if let Some(d) = classify_name_ref(&sema, &name_ref) {\n-                    let d = d.definition();\n-                    if &d == self {\n+                match classify_name_ref(&sema, &name_ref) {\n+                    Some(NameRefClass::Definition(def)) if &def == self => {\n                         let kind = if is_record_lit_name_ref(&name_ref)\n                             || is_call_expr_name_ref(&name_ref)\n                         {\n@@ -252,9 +253,26 @@ impl Definition {\n                         refs.push(Reference {\n                             file_range,\n                             kind,\n-                            access: reference_access(&d, &name_ref),\n+                            access: reference_access(&def, &name_ref),\n                         });\n                     }\n+                    Some(NameRefClass::FieldShorthand { local, field }) => {\n+                        match self {\n+                            Definition::StructField(_) if &field == self => refs.push(Reference {\n+                                file_range: sema.original_range(name_ref.syntax()),\n+                                kind: ReferenceKind::StructFieldShorthandForField,\n+                                access: reference_access(&field, &name_ref),\n+                            }),\n+                            Definition::Local(l) if &local == l => refs.push(Reference {\n+                                file_range: sema.original_range(name_ref.syntax()),\n+                                kind: ReferenceKind::StructFieldShorthandForLocal,\n+                                access: reference_access(&Definition::Local(local), &name_ref),\n+                            }),\n+\n+                            _ => {} // not a usage\n+                        };\n+                    }\n+                    _ => {} // not a usage\n                 }\n             }\n         }"}]}