{"sha": "c7fc332a2297c7b10ef8772378683bcef8d51c6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ZmMzMzJhMjI5N2M3YjEwZWY4NzcyMzc4NjgzYmNlZjhkNTFjNmI=", "commit": {"author": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-16T09:20:03Z"}, "committer": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-16T09:20:03Z"}, "message": "rollup merge of #18941: reem/better-task-pool", "tree": {"sha": "6545b5b0a0e5ef5a71fd6385fd3cf6c9048d3db4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6545b5b0a0e5ef5a71fd6385fd3cf6c9048d3db4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7fc332a2297c7b10ef8772378683bcef8d51c6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7fc332a2297c7b10ef8772378683bcef8d51c6b", "html_url": "https://github.com/rust-lang/rust/commit/c7fc332a2297c7b10ef8772378683bcef8d51c6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7fc332a2297c7b10ef8772378683bcef8d51c6b/comments", "author": null, "committer": null, "parents": [{"sha": "0d97b95d43248c7bf0aa408fa39567245e9b794d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d97b95d43248c7bf0aa408fa39567245e9b794d", "html_url": "https://github.com/rust-lang/rust/commit/0d97b95d43248c7bf0aa408fa39567245e9b794d"}, {"sha": "93c4942690753e982cbb4bf6667940da71c5d286", "url": "https://api.github.com/repos/rust-lang/rust/commits/93c4942690753e982cbb4bf6667940da71c5d286", "html_url": "https://github.com/rust-lang/rust/commit/93c4942690753e982cbb4bf6667940da71c5d286"}], "stats": {"total": 230, "additions": 167, "deletions": 63}, "files": [{"sha": "2682582d708a871084e040584c75ab7b2ae7e475", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 167, "deletions": 63, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/c7fc332a2297c7b10ef8772378683bcef8d51c6b/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7fc332a2297c7b10ef8772378683bcef8d51c6b/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=c7fc332a2297c7b10ef8772378683bcef8d51c6b", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -12,91 +12,195 @@\n \n use core::prelude::*;\n \n-use task;\n use task::spawn;\n-use vec::Vec;\n-use comm::{channel, Sender};\n+use comm::{channel, Sender, Receiver};\n+use sync::{Arc, Mutex};\n \n-enum Msg<T> {\n-    Execute(proc(&T):Send),\n-    Quit\n+struct Sentinel<'a> {\n+    jobs: &'a Arc<Mutex<Receiver<proc(): Send>>>,\n+    active: bool\n }\n \n-/// A task pool used to execute functions in parallel.\n-pub struct TaskPool<T> {\n-    channels: Vec<Sender<Msg<T>>>,\n-    next_index: uint,\n+impl<'a> Sentinel<'a> {\n+    fn new(jobs: &Arc<Mutex<Receiver<proc(): Send>>>) -> Sentinel {\n+        Sentinel {\n+            jobs: jobs,\n+            active: true\n+        }\n+    }\n+\n+    // Cancel and destroy this sentinel.\n+    fn cancel(mut self) {\n+        self.active = false;\n+    }\n }\n \n #[unsafe_destructor]\n-impl<T> Drop for TaskPool<T> {\n+impl<'a> Drop for Sentinel<'a> {\n     fn drop(&mut self) {\n-        for channel in self.channels.iter_mut() {\n-            channel.send(Quit);\n+        if self.active {\n+            spawn_in_pool(self.jobs.clone())\n         }\n     }\n }\n \n-impl<T> TaskPool<T> {\n-    /// Spawns a new task pool with `n_tasks` tasks. The provided\n-    /// `init_fn_factory` returns a function which, given the index of the\n-    /// task, should return local data to be kept around in that task.\n+/// A task pool used to execute functions in parallel.\n+///\n+/// Spawns `n` worker tasks and replenishes the pool if any worker tasks\n+/// panic.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// # use sync::TaskPool;\n+/// # use iter::AdditiveIterator;\n+///\n+/// let pool = TaskPool::new(4u);\n+///\n+/// let (tx, rx) = channel();\n+/// for _ in range(0, 8u) {\n+///     let tx = tx.clone();\n+///     pool.execute(proc() {\n+///         tx.send(1u);\n+///     });\n+/// }\n+///\n+/// assert_eq!(rx.iter().take(8u).sum(), 8u);\n+/// ```\n+pub struct TaskPool {\n+    // How the taskpool communicates with subtasks.\n+    //\n+    // This is the only such Sender, so when it is dropped all subtasks will\n+    // quit.\n+    jobs: Sender<proc(): Send>\n+}\n+\n+impl TaskPool {\n+    /// Spawns a new task pool with `tasks` tasks.\n     ///\n     /// # Panics\n     ///\n-    /// This function will panic if `n_tasks` is less than 1.\n-    pub fn new(n_tasks: uint,\n-               init_fn_factory: || -> proc(uint):Send -> T)\n-               -> TaskPool<T> {\n-        assert!(n_tasks >= 1);\n-\n-        let channels = Vec::from_fn(n_tasks, |i| {\n-            let (tx, rx) = channel::<Msg<T>>();\n-            let init_fn = init_fn_factory();\n-\n-            let task_body = proc() {\n-                let local_data = init_fn(i);\n-                loop {\n-                    match rx.recv() {\n-                        Execute(f) => f(&local_data),\n-                        Quit => break\n-                    }\n-                }\n-            };\n+    /// This function will panic if `tasks` is 0.\n+    pub fn new(tasks: uint) -> TaskPool {\n+        assert!(tasks >= 1);\n \n-            // Run on this scheduler.\n-            task::spawn(task_body);\n+        let (tx, rx) = channel::<proc(): Send>();\n+        let rx = Arc::new(Mutex::new(rx));\n \n-            tx\n-        });\n+        // Taskpool tasks.\n+        for _ in range(0, tasks) {\n+            spawn_in_pool(rx.clone());\n+        }\n \n-        return TaskPool {\n-            channels: channels,\n-            next_index: 0,\n-        };\n+        TaskPool { jobs: tx }\n     }\n \n-    /// Executes the function `f` on a task in the pool. The function\n-    /// receives a reference to the local data returned by the `init_fn`.\n-    pub fn execute(&mut self, f: proc(&T):Send) {\n-        self.channels[self.next_index].send(Execute(f));\n-        self.next_index += 1;\n-        if self.next_index == self.channels.len() { self.next_index = 0; }\n+    /// Executes the function `job` on a task in the pool.\n+    pub fn execute(&self, job: proc():Send) {\n+        self.jobs.send(job);\n     }\n }\n \n-#[test]\n-fn test_task_pool() {\n-    let f: || -> proc(uint):Send -> uint = || { proc(i) i };\n-    let mut pool = TaskPool::new(4, f);\n-    for _ in range(0u, 8) {\n-        pool.execute(proc(i) println!(\"Hello from thread {}!\", *i));\n-    }\n+fn spawn_in_pool(jobs: Arc<Mutex<Receiver<proc(): Send>>>) {\n+    spawn(proc() {\n+        // Will spawn a new task on panic unless it is cancelled.\n+        let sentinel = Sentinel::new(&jobs);\n+\n+        loop {\n+            let message = {\n+                // Only lock jobs for the time it takes\n+                // to get a job, not run it.\n+                let lock = jobs.lock();\n+                lock.recv_opt()\n+            };\n+\n+            match message {\n+                Ok(job) => job(),\n+\n+                // The Taskpool was dropped.\n+                Err(..) => break\n+            }\n+        }\n+\n+        sentinel.cancel();\n+    })\n }\n \n-#[test]\n-#[should_fail]\n-fn test_zero_tasks_panic() {\n-    let f: || -> proc(uint):Send -> uint = || { proc(i) i };\n-    TaskPool::new(0, f);\n+#[cfg(test)]\n+mod test {\n+    use core::prelude::*;\n+    use super::*;\n+    use comm::channel;\n+    use iter::range;\n+\n+    const TEST_TASKS: uint = 4u;\n+\n+    #[test]\n+    fn test_works() {\n+        use iter::AdditiveIterator;\n+\n+        let pool = TaskPool::new(TEST_TASKS);\n+\n+        let (tx, rx) = channel();\n+        for _ in range(0, TEST_TASKS) {\n+            let tx = tx.clone();\n+            pool.execute(proc() {\n+                tx.send(1u);\n+            });\n+        }\n+\n+        assert_eq!(rx.iter().take(TEST_TASKS).sum(), TEST_TASKS);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_zero_tasks_panic() {\n+        TaskPool::new(0);\n+    }\n+\n+    #[test]\n+    fn test_recovery_from_subtask_panic() {\n+        use iter::AdditiveIterator;\n+\n+        let pool = TaskPool::new(TEST_TASKS);\n+\n+        // Panic all the existing tasks.\n+        for _ in range(0, TEST_TASKS) {\n+            pool.execute(proc() { panic!() });\n+        }\n+\n+        // Ensure new tasks were spawned to compensate.\n+        let (tx, rx) = channel();\n+        for _ in range(0, TEST_TASKS) {\n+            let tx = tx.clone();\n+            pool.execute(proc() {\n+                tx.send(1u);\n+            });\n+        }\n+\n+        assert_eq!(rx.iter().take(TEST_TASKS).sum(), TEST_TASKS);\n+    }\n+\n+    #[test]\n+    fn test_should_not_panic_on_drop_if_subtasks_panic_after_drop() {\n+        use sync::{Arc, Barrier};\n+\n+        let pool = TaskPool::new(TEST_TASKS);\n+        let waiter = Arc::new(Barrier::new(TEST_TASKS + 1));\n+\n+        // Panic all the existing tasks in a bit.\n+        for _ in range(0, TEST_TASKS) {\n+            let waiter = waiter.clone();\n+            pool.execute(proc() {\n+                waiter.wait();\n+                panic!();\n+            });\n+        }\n+\n+        drop(pool);\n+\n+        // Kick off the failure.\n+        waiter.wait();\n+    }\n }\n+"}]}