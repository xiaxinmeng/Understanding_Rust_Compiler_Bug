{"sha": "2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiODJiN2U1MGE5ZWJiNTE0YWM1Y2YyYTBhNWI2NWFjM2Q5MmNlZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-05T13:12:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-05T13:12:56Z"}, "message": "Auto merge of #43554 - eddyb:apfloat, r=nikomatsakis\n\nAPFloat: Rewrite It In Rust and use it for deterministic floating-point CTFE.\n\nAs part of the CTFE initiative, we're forced to find a solution for floating-point operations.\nBy design, IEEE-754 does not explicitly define everything in a deterministic manner, and there is some variability between platforms, at the very least (e.g. NaN payloads).\n\nIf types are to evaluate constant expressions involving type (or in the future, const) generics, that evaluation needs to be *fully deterministic*, even across `rustc` host platforms.\nThat is, if `[T; T::X]` was used in a cross-compiled library, and the evaluation of `T::X` executed a floating-point operation, that operation has to be reproducible on *any other host*, only knowing `T` and the definition of the `X` associated const (as either AST or HIR).\n\nFailure to uphold those rules allows an associated type (e.g. `<Foo as Iterator>::Item`) to be seen as two (or more) different types, depending on the current host, and such type safety violations typically allow writing of a `transmute` in safe code, given enough generics.\n\nThe options considered by @rust-lang/compiler were:\n1. Ban floating-point operations in generic const-evaluation contexts\n2. Emulate floating-point operations in an uniformly deterministic fashion\n\nThe former option may seem appealing at first, but floating-point operations *are allowed today*, so they can't be banned wholesale, a distinction has to be made between the code that already works, and future generic contexts. *Moreover*, every computation that succeeded *has to be cached*, otherwise the generic case can be reproduced without any generics. IMO there are too many ways it can go wrong, and a single violation can be enough for an unsoundness hole.\nNot to mention we may end up really wanting floating-point operations *anyway*, in CTFE.\n\nI went with the latter option, and seeing how LLVM *already* has a library for this exact purpose (as it needs to perform optimizations independently of host floating-point capabilities), i.e. `APFloat`, that was what I ended up basing this PR on.\nBut having been burned by the low reusability of bindings that link to LLVM, and because I would *rather* the floating-point operations to be wrong than not deterministic or not memory-safe (`APFloat` does far more pointer juggling than I'm comfortable with), I decided to RIIR.\n\nThis way, we have a guarantee of *no* `unsafe` code, a bit more control over the where native floating-point might accidentally be involved, and non-LLVM backends can share it.\nI've also ported all the testcases over, *before* any functionality, to catch any mistakes.\n\nCurrently the PR replaces all CTFE operations to go through `apfloat::ieee::{Single,Double}`, keeping only the bits of the `f32` / `f64` memory representation in between operations.\nConverting from a string also double-checks that `core::num` and `apfloat` agree on the interpretation of a floating-point number literal, in case either of them has any bugs left around.\n\nr? @nikomatsakis\nf? @nagisa @est31\n\n<hr/>\n\nHuge thanks to @edef1c for first demoing usable `APFloat` bindings and to @chandlerc for fielding my questions on IRC about `APFloat` peculiarities (also upstreaming some bugfixes).", "tree": {"sha": "6ec0c9184fbc3866a35e6efc126285b8c4dc31f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ec0c9184fbc3866a35e6efc126285b8c4dc31f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "html_url": "https://github.com/rust-lang/rust/commit/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c7add7551fa093f655e76650a48564ac347c83a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c7add7551fa093f655e76650a48564ac347c83a", "html_url": "https://github.com/rust-lang/rust/commit/5c7add7551fa093f655e76650a48564ac347c83a"}, {"sha": "c457b26e33ccd83da9055acb19f6099e4a353a12", "url": "https://api.github.com/repos/rust-lang/rust/commits/c457b26e33ccd83da9055acb19f6099e4a353a12", "html_url": "https://github.com/rust-lang/rust/commit/c457b26e33ccd83da9055acb19f6099e4a353a12"}], "stats": {"total": 11795, "additions": 11641, "deletions": 154}, "files": [{"sha": "38ce7850453fc175811b10cd244e80cb18bf33c4", "filename": "src/Cargo.lock", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "patch": "@@ -1252,6 +1252,13 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_apfloat\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc_bitflags 0.0.0\",\n+]\n+\n [[package]]\n name = \"rustc_asan\"\n version = \"0.0.0\"\n@@ -1309,6 +1316,7 @@ dependencies = [\n name = \"rustc_const_math\"\n version = \"0.0.0\"\n dependencies = [\n+ \"rustc_apfloat 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n ]"}, {"sha": "6790c2ac7decec5e4887ef4a589e97b321a0d5b5", "filename": "src/librustc/ich/impls_const_math.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_const_math.rs?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "patch": "@@ -11,9 +11,9 @@\n //! This module contains `HashStable` implementations for various data types\n //! from `rustc_const_math` in no particular order.\n \n-impl_stable_hash_for!(enum ::rustc_const_math::ConstFloat {\n-    F32(val),\n-    F64(val)\n+impl_stable_hash_for!(struct ::rustc_const_math::ConstFloat {\n+    ty,\n+    bits\n });\n \n impl_stable_hash_for!(enum ::rustc_const_math::ConstInt {"}, {"sha": "b8f8488e3027357cddebb3a33b9ce3219b141452", "filename": "src/librustc_apfloat/Cargo.toml", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_apfloat%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_apfloat%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2FCargo.toml?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "patch": "@@ -0,0 +1,11 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_apfloat\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_apfloat\"\n+path = \"lib.rs\"\n+\n+[dependencies]\n+rustc_bitflags = { path = \"../librustc_bitflags\" }"}, {"sha": "3545a77c75de64cde2e5573409b254c6b0bf9734", "filename": "src/librustc_apfloat/ieee.rs", "status": "added", "additions": 2733, "deletions": 0, "changes": 2733, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "patch": "@@ -0,0 +1,2733 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use {Category, ExpInt, IEK_INF, IEK_NAN, IEK_ZERO};\n+use {Float, FloatConvert, ParseError, Round, Status, StatusAnd};\n+\n+use std::cmp::{self, Ordering};\n+use std::convert::TryFrom;\n+use std::fmt::{self, Write};\n+use std::marker::PhantomData;\n+use std::mem;\n+use std::ops::Neg;\n+\n+#[must_use]\n+pub struct IeeeFloat<S> {\n+    /// Absolute significand value (including the integer bit).\n+    sig: [Limb; 1],\n+\n+    /// The signed unbiased exponent of the value.\n+    exp: ExpInt,\n+\n+    /// What kind of floating point number this is.\n+    category: Category,\n+\n+    /// Sign bit of the number.\n+    sign: bool,\n+\n+    marker: PhantomData<S>,\n+}\n+\n+/// Fundamental unit of big integer arithmetic, but also\n+/// large to store the largest significands by itself.\n+type Limb = u128;\n+const LIMB_BITS: usize = 128;\n+fn limbs_for_bits(bits: usize) -> usize {\n+    (bits + LIMB_BITS - 1) / LIMB_BITS\n+}\n+\n+/// Enum that represents what fraction of the LSB truncated bits of an fp number\n+/// represent.\n+///\n+/// This essentially combines the roles of guard and sticky bits.\n+#[must_use]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum Loss {\n+    // Example of truncated bits:\n+    ExactlyZero, // 000000\n+    LessThanHalf, // 0xxxxx  x's not all zero\n+    ExactlyHalf, // 100000\n+    MoreThanHalf, // 1xxxxx  x's not all zero\n+}\n+\n+/// Represents floating point arithmetic semantics.\n+pub trait Semantics: Sized {\n+    /// Total number of bits in the in-memory format.\n+    const BITS: usize;\n+\n+    /// Number of bits in the significand. This includes the integer bit.\n+    const PRECISION: usize;\n+\n+    /// The largest E such that 2^E is representable; this matches the\n+    /// definition of IEEE 754.\n+    const MAX_EXP: ExpInt;\n+\n+    /// The smallest E such that 2^E is a normalized number; this\n+    /// matches the definition of IEEE 754.\n+    const MIN_EXP: ExpInt = -Self::MAX_EXP + 1;\n+\n+    /// The significand bit that marks NaN as quiet.\n+    const QNAN_BIT: usize = Self::PRECISION - 2;\n+\n+    /// The significand bitpattern to mark a NaN as quiet.\n+    /// NOTE: for X87DoubleExtended we need to set two bits instead of 2.\n+    const QNAN_SIGNIFICAND: Limb = 1 << Self::QNAN_BIT;\n+\n+    fn from_bits(bits: u128) -> IeeeFloat<Self> {\n+        assert!(Self::BITS > Self::PRECISION);\n+\n+        let sign = bits & (1 << (Self::BITS - 1));\n+        let exponent = (bits & !sign) >> (Self::PRECISION - 1);\n+        let mut r = IeeeFloat {\n+            sig: [bits & ((1 << (Self::PRECISION - 1)) - 1)],\n+            // Convert the exponent from its bias representation to a signed integer.\n+            exp: (exponent as ExpInt) - Self::MAX_EXP,\n+            category: Category::Zero,\n+            sign: sign != 0,\n+            marker: PhantomData,\n+        };\n+\n+        if r.exp == Self::MIN_EXP - 1 && r.sig == [0] {\n+            // Exponent, significand meaningless.\n+            r.category = Category::Zero;\n+        } else if r.exp == Self::MAX_EXP + 1 && r.sig == [0] {\n+            // Exponent, significand meaningless.\n+            r.category = Category::Infinity;\n+        } else if r.exp == Self::MAX_EXP + 1 && r.sig != [0] {\n+            // Sign, exponent, significand meaningless.\n+            r.category = Category::NaN;\n+        } else {\n+            r.category = Category::Normal;\n+            if r.exp == Self::MIN_EXP - 1 {\n+                // Denormal.\n+                r.exp = Self::MIN_EXP;\n+            } else {\n+                // Set integer bit.\n+                sig::set_bit(&mut r.sig, Self::PRECISION - 1);\n+            }\n+        }\n+\n+        r\n+    }\n+\n+    fn to_bits(x: IeeeFloat<Self>) -> u128 {\n+        assert!(Self::BITS > Self::PRECISION);\n+\n+        // Split integer bit from significand.\n+        let integer_bit = sig::get_bit(&x.sig, Self::PRECISION - 1);\n+        let mut significand = x.sig[0] & ((1 << (Self::PRECISION - 1)) - 1);\n+        let exponent = match x.category {\n+            Category::Normal => {\n+                if x.exp == Self::MIN_EXP && !integer_bit {\n+                    // Denormal.\n+                    Self::MIN_EXP - 1\n+                } else {\n+                    x.exp\n+                }\n+            }\n+            Category::Zero => {\n+                // FIXME(eddyb) Maybe we should guarantee an invariant instead?\n+                significand = 0;\n+                Self::MIN_EXP - 1\n+            }\n+            Category::Infinity => {\n+                // FIXME(eddyb) Maybe we should guarantee an invariant instead?\n+                significand = 0;\n+                Self::MAX_EXP + 1\n+            }\n+            Category::NaN => Self::MAX_EXP + 1,\n+        };\n+\n+        // Convert the exponent from a signed integer to its bias representation.\n+        let exponent = (exponent + Self::MAX_EXP) as u128;\n+\n+        ((x.sign as u128) << (Self::BITS - 1)) | (exponent << (Self::PRECISION - 1)) | significand\n+    }\n+}\n+\n+impl<S> Copy for IeeeFloat<S> {}\n+impl<S> Clone for IeeeFloat<S> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+macro_rules! ieee_semantics {\n+    ($($name:ident = $sem:ident($bits:tt : $exp_bits:tt)),*) => {\n+        $(pub struct $sem;)*\n+        $(pub type $name = IeeeFloat<$sem>;)*\n+        $(impl Semantics for $sem {\n+            const BITS: usize = $bits;\n+            const PRECISION: usize = ($bits - 1 - $exp_bits) + 1;\n+            const MAX_EXP: ExpInt = (1 << ($exp_bits - 1)) - 1;\n+        })*\n+    }\n+}\n+\n+ieee_semantics! {\n+    Half = HalfS(16:5),\n+    Single = SingleS(32:8),\n+    Double = DoubleS(64:11),\n+    Quad = QuadS(128:15)\n+}\n+\n+pub struct X87DoubleExtendedS;\n+pub type X87DoubleExtended = IeeeFloat<X87DoubleExtendedS>;\n+impl Semantics for X87DoubleExtendedS {\n+    const BITS: usize = 80;\n+    const PRECISION: usize = 64;\n+    const MAX_EXP: ExpInt = (1 << (15 - 1)) - 1;\n+\n+    /// For x87 extended precision, we want to make a NaN, not a\n+    /// pseudo-NaN. Maybe we should expose the ability to make\n+    /// pseudo-NaNs?\n+    const QNAN_SIGNIFICAND: Limb = 0b11 << Self::QNAN_BIT;\n+\n+    /// Integer bit is explicit in this format. Intel hardware (387 and later)\n+    /// does not support these bit patterns:\n+    ///  exponent = all 1's, integer bit 0, significand 0 (\"pseudoinfinity\")\n+    ///  exponent = all 1's, integer bit 0, significand nonzero (\"pseudoNaN\")\n+    ///  exponent = 0, integer bit 1 (\"pseudodenormal\")\n+    ///  exponent!=0 nor all 1's, integer bit 0 (\"unnormal\")\n+    /// At the moment, the first two are treated as NaNs, the second two as Normal.\n+    fn from_bits(bits: u128) -> IeeeFloat<Self> {\n+        let sign = bits & (1 << (Self::BITS - 1));\n+        let exponent = (bits & !sign) >> Self::PRECISION;\n+        let mut r = IeeeFloat {\n+            sig: [bits & ((1 << (Self::PRECISION - 1)) - 1)],\n+            // Convert the exponent from its bias representation to a signed integer.\n+            exp: (exponent as ExpInt) - Self::MAX_EXP,\n+            category: Category::Zero,\n+            sign: sign != 0,\n+            marker: PhantomData,\n+        };\n+\n+        if r.exp == Self::MIN_EXP - 1 && r.sig == [0] {\n+            // Exponent, significand meaningless.\n+            r.category = Category::Zero;\n+        } else if r.exp == Self::MAX_EXP + 1 && r.sig == [1 << (Self::PRECISION - 1)] {\n+            // Exponent, significand meaningless.\n+            r.category = Category::Infinity;\n+        } else if r.exp == Self::MAX_EXP + 1 && r.sig != [1 << (Self::PRECISION - 1)] {\n+            // Sign, exponent, significand meaningless.\n+            r.category = Category::NaN;\n+        } else {\n+            r.category = Category::Normal;\n+            if r.exp == Self::MIN_EXP - 1 {\n+                // Denormal.\n+                r.exp = Self::MIN_EXP;\n+            }\n+        }\n+\n+        r\n+    }\n+\n+    fn to_bits(x: IeeeFloat<Self>) -> u128 {\n+        // Get integer bit from significand.\n+        let integer_bit = sig::get_bit(&x.sig, Self::PRECISION - 1);\n+        let mut significand = x.sig[0] & ((1 << Self::PRECISION) - 1);\n+        let exponent = match x.category {\n+            Category::Normal => {\n+                if x.exp == Self::MIN_EXP && !integer_bit {\n+                    // Denormal.\n+                    Self::MIN_EXP - 1\n+                } else {\n+                    x.exp\n+                }\n+            }\n+            Category::Zero => {\n+                // FIXME(eddyb) Maybe we should guarantee an invariant instead?\n+                significand = 0;\n+                Self::MIN_EXP - 1\n+            }\n+            Category::Infinity => {\n+                // FIXME(eddyb) Maybe we should guarantee an invariant instead?\n+                significand = 1 << (Self::PRECISION - 1);\n+                Self::MAX_EXP + 1\n+            }\n+            Category::NaN => Self::MAX_EXP + 1,\n+        };\n+\n+        // Convert the exponent from a signed integer to its bias representation.\n+        let exponent = (exponent + Self::MAX_EXP) as u128;\n+\n+        ((x.sign as u128) << (Self::BITS - 1)) | (exponent << Self::PRECISION) | significand\n+    }\n+}\n+\n+float_common_impls!(IeeeFloat<S>);\n+\n+impl<S: Semantics> PartialEq for IeeeFloat<S> {\n+    fn eq(&self, rhs: &Self) -> bool {\n+        self.partial_cmp(rhs) == Some(Ordering::Equal)\n+    }\n+}\n+\n+impl<S: Semantics> PartialOrd for IeeeFloat<S> {\n+    fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {\n+        match (self.category, rhs.category) {\n+            (Category::NaN, _) |\n+            (_, Category::NaN) => None,\n+\n+            (Category::Infinity, Category::Infinity) => Some((!self.sign).cmp(&(!rhs.sign))),\n+\n+            (Category::Zero, Category::Zero) => Some(Ordering::Equal),\n+\n+            (Category::Infinity, _) |\n+            (Category::Normal, Category::Zero) => Some((!self.sign).cmp(&self.sign)),\n+\n+            (_, Category::Infinity) |\n+            (Category::Zero, Category::Normal) => Some(rhs.sign.cmp(&(!rhs.sign))),\n+\n+            (Category::Normal, Category::Normal) => {\n+                // Two normal numbers. Do they have the same sign?\n+                Some((!self.sign).cmp(&(!rhs.sign)).then_with(|| {\n+                    // Compare absolute values; invert result if negative.\n+                    let result = self.cmp_abs_normal(*rhs);\n+\n+                    if self.sign { result.reverse() } else { result }\n+                }))\n+            }\n+        }\n+    }\n+}\n+\n+impl<S> Neg for IeeeFloat<S> {\n+    type Output = Self;\n+    fn neg(mut self) -> Self {\n+        self.sign = !self.sign;\n+        self\n+    }\n+}\n+\n+/// Prints this value as a decimal string.\n+///\n+/// \\param precision The maximum number of digits of\n+///   precision to output. If there are fewer digits available,\n+///   zero padding will not be used unless the value is\n+///   integral and small enough to be expressed in\n+///   precision digits. 0 means to use the natural\n+///   precision of the number.\n+/// \\param width The maximum number of zeros to\n+///   consider inserting before falling back to scientific\n+///   notation. 0 means to always use scientific notation.\n+///\n+/// \\param alternate Indicate whether to remove the trailing zero in\n+///   fraction part or not. Also setting this parameter to true forces\n+///   producing of output more similar to default printf behavior.\n+///   Specifically the lower e is used as exponent delimiter and exponent\n+///   always contains no less than two digits.\n+///\n+/// Number       precision    width      Result\n+/// ------       ---------    -----      ------\n+/// 1.01E+4              5        2       10100\n+/// 1.01E+4              4        2       1.01E+4\n+/// 1.01E+4              5        1       1.01E+4\n+/// 1.01E-2              5        2       0.0101\n+/// 1.01E-2              4        2       0.0101\n+/// 1.01E-2              4        1       1.01E-2\n+impl<S: Semantics> fmt::Display for IeeeFloat<S> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let width = f.width().unwrap_or(3);\n+        let alternate = f.alternate();\n+\n+        match self.category {\n+            Category::Infinity => {\n+                if self.sign {\n+                    return f.write_str(\"-Inf\");\n+                } else {\n+                    return f.write_str(\"+Inf\");\n+                }\n+            }\n+\n+            Category::NaN => return f.write_str(\"NaN\"),\n+\n+            Category::Zero => {\n+                if self.sign {\n+                    f.write_char('-')?;\n+                }\n+\n+                if width == 0 {\n+                    if alternate {\n+                        f.write_str(\"0.0\")?;\n+                        if let Some(n) = f.precision() {\n+                            for _ in 1..n {\n+                                f.write_char('0')?;\n+                            }\n+                        }\n+                        f.write_str(\"e+00\")?;\n+                    } else {\n+                        f.write_str(\"0.0E+0\")?;\n+                    }\n+                } else {\n+                    f.write_char('0')?;\n+                }\n+                return Ok(());\n+            }\n+\n+            Category::Normal => {}\n+        }\n+\n+        if self.sign {\n+            f.write_char('-')?;\n+        }\n+\n+        // We use enough digits so the number can be round-tripped back to an\n+        // APFloat. The formula comes from \"How to Print Floating-Point Numbers\n+        // Accurately\" by Steele and White.\n+        // FIXME: Using a formula based purely on the precision is conservative;\n+        // we can print fewer digits depending on the actual value being printed.\n+\n+        // precision = 2 + floor(S::PRECISION / lg_2(10))\n+        let precision = f.precision().unwrap_or(2 + S::PRECISION * 59 / 196);\n+\n+        // Decompose the number into an APInt and an exponent.\n+        let mut exp = self.exp - (S::PRECISION as ExpInt - 1);\n+        let mut sig = vec![self.sig[0]];\n+\n+        // Ignore trailing binary zeros.\n+        let trailing_zeros = sig[0].trailing_zeros();\n+        let _: Loss = sig::shift_right(&mut sig, &mut exp, trailing_zeros as usize);\n+\n+        // Change the exponent from 2^e to 10^e.\n+        if exp == 0 {\n+            // Nothing to do.\n+        } else if exp > 0 {\n+            // Just shift left.\n+            let shift = exp as usize;\n+            sig.resize(limbs_for_bits(S::PRECISION + shift), 0);\n+            sig::shift_left(&mut sig, &mut exp, shift);\n+        } else {\n+            // exp < 0\n+            let mut texp = -exp as usize;\n+\n+            // We transform this using the identity:\n+            //   (N)(2^-e) == (N)(5^e)(10^-e)\n+\n+            // Multiply significand by 5^e.\n+            //   N * 5^0101 == N * 5^(1*1) * 5^(0*2) * 5^(1*4) * 5^(0*8)\n+            let mut sig_scratch = vec![];\n+            let mut p5 = vec![];\n+            let mut p5_scratch = vec![];\n+            while texp != 0 {\n+                if p5.is_empty() {\n+                    p5.push(5);\n+                } else {\n+                    p5_scratch.resize(p5.len() * 2, 0);\n+                    let _: Loss =\n+                        sig::mul(&mut p5_scratch, &mut 0, &p5, &p5, p5.len() * 2 * LIMB_BITS);\n+                    while p5_scratch.last() == Some(&0) {\n+                        p5_scratch.pop();\n+                    }\n+                    mem::swap(&mut p5, &mut p5_scratch);\n+                }\n+                if texp & 1 != 0 {\n+                    sig_scratch.resize(sig.len() + p5.len(), 0);\n+                    let _: Loss = sig::mul(\n+                        &mut sig_scratch,\n+                        &mut 0,\n+                        &sig,\n+                        &p5,\n+                        (sig.len() + p5.len()) * LIMB_BITS,\n+                    );\n+                    while sig_scratch.last() == Some(&0) {\n+                        sig_scratch.pop();\n+                    }\n+                    mem::swap(&mut sig, &mut sig_scratch);\n+                }\n+                texp >>= 1;\n+            }\n+        }\n+\n+        // Fill the buffer.\n+        let mut buffer = vec![];\n+\n+        // Ignore digits from the significand until it is no more\n+        // precise than is required for the desired precision.\n+        // 196/59 is a very slight overestimate of lg_2(10).\n+        let required = (precision * 196 + 58) / 59;\n+        let mut discard_digits = sig::omsb(&sig).saturating_sub(required) * 59 / 196;\n+        let mut in_trail = true;\n+        while !sig.is_empty() {\n+            // Perform short division by 10 to extract the rightmost digit.\n+            // rem <- sig % 10\n+            // sig <- sig / 10\n+            let mut rem = 0;\n+            for limb in sig.iter_mut().rev() {\n+                // We don't have an integer doubly wide than Limb,\n+                // so we have to split the divrem on two halves.\n+                const HALF_BITS: usize = LIMB_BITS / 2;\n+                let mut halves = [*limb & ((1 << HALF_BITS) - 1), *limb >> HALF_BITS];\n+                for half in halves.iter_mut().rev() {\n+                    *half |= rem << HALF_BITS;\n+                    rem = *half % 10;\n+                    *half /= 10;\n+                }\n+                *limb = halves[0] | (halves[1] << HALF_BITS);\n+            }\n+            // Reduce the sigificand to avoid wasting time dividing 0's.\n+            while sig.last() == Some(&0) {\n+                sig.pop();\n+            }\n+\n+            let digit = rem;\n+\n+            // Ignore digits we don't need.\n+            if discard_digits > 0 {\n+                discard_digits -= 1;\n+                exp += 1;\n+                continue;\n+            }\n+\n+            // Drop trailing zeros.\n+            if in_trail && digit == 0 {\n+                exp += 1;\n+            } else {\n+                in_trail = false;\n+                buffer.push(b'0' + digit as u8);\n+            }\n+        }\n+\n+        assert!(!buffer.is_empty(), \"no characters in buffer!\");\n+\n+        // Drop down to precision.\n+        // FIXME: don't do more precise calculations above than are required.\n+        if buffer.len() > precision {\n+            // The most significant figures are the last ones in the buffer.\n+            let mut first_sig = buffer.len() - precision;\n+\n+            // Round.\n+            // FIXME: this probably shouldn't use 'round half up'.\n+\n+            // Rounding down is just a truncation, except we also want to drop\n+            // trailing zeros from the new result.\n+            if buffer[first_sig - 1] < b'5' {\n+                while first_sig < buffer.len() && buffer[first_sig] == b'0' {\n+                    first_sig += 1;\n+                }\n+            } else {\n+                // Rounding up requires a decimal add-with-carry. If we continue\n+                // the carry, the newly-introduced zeros will just be truncated.\n+                for x in &mut buffer[first_sig..] {\n+                    if *x == b'9' {\n+                        first_sig += 1;\n+                    } else {\n+                        *x += 1;\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            exp += first_sig as ExpInt;\n+            buffer.drain(..first_sig);\n+\n+            // If we carried through, we have exactly one digit of precision.\n+            if buffer.is_empty() {\n+                buffer.push(b'1');\n+            }\n+        }\n+\n+        let digits = buffer.len();\n+\n+        // Check whether we should use scientific notation.\n+        let scientific = if width == 0 {\n+            true\n+        } else {\n+            if exp >= 0 {\n+                // 765e3 --> 765000\n+                //              ^^^\n+                // But we shouldn't make the number look more precise than it is.\n+                exp as usize > width || digits + exp as usize > precision\n+            } else {\n+                // Power of the most significant digit.\n+                let msd = exp + (digits - 1) as ExpInt;\n+                if msd >= 0 {\n+                    // 765e-2 == 7.65\n+                    false\n+                } else {\n+                    // 765e-5 == 0.00765\n+                    //           ^ ^^\n+                    -msd as usize > width\n+                }\n+            }\n+        };\n+\n+        // Scientific formatting is pretty straightforward.\n+        if scientific {\n+            exp += digits as ExpInt - 1;\n+\n+            f.write_char(buffer[digits - 1] as char)?;\n+            f.write_char('.')?;\n+            let truncate_zero = !alternate;\n+            if digits == 1 && truncate_zero {\n+                f.write_char('0')?;\n+            } else {\n+                for &d in buffer[..digits - 1].iter().rev() {\n+                    f.write_char(d as char)?;\n+                }\n+            }\n+            // Fill with zeros up to precision.\n+            if !truncate_zero && precision > digits - 1 {\n+                for _ in 0..precision - digits + 1 {\n+                    f.write_char('0')?;\n+                }\n+            }\n+            // For alternate we use lower 'e'.\n+            f.write_char(if alternate { 'e' } else { 'E' })?;\n+\n+            // Exponent always at least two digits if we do not truncate zeros.\n+            if truncate_zero {\n+                write!(f, \"{:+}\", exp)?;\n+            } else {\n+                write!(f, \"{:+03}\", exp)?;\n+            }\n+\n+            return Ok(());\n+        }\n+\n+        // Non-scientific, positive exponents.\n+        if exp >= 0 {\n+            for &d in buffer.iter().rev() {\n+                f.write_char(d as char)?;\n+            }\n+            for _ in 0..exp {\n+                f.write_char('0')?;\n+            }\n+            return Ok(());\n+        }\n+\n+        // Non-scientific, negative exponents.\n+        let unit_place = -exp as usize;\n+        if unit_place < digits {\n+            for &d in buffer[unit_place..].iter().rev() {\n+                f.write_char(d as char)?;\n+            }\n+            f.write_char('.')?;\n+            for &d in buffer[..unit_place].iter().rev() {\n+                f.write_char(d as char)?;\n+            }\n+        } else {\n+            f.write_str(\"0.\")?;\n+            for _ in digits..unit_place {\n+                f.write_char('0')?;\n+            }\n+            for &d in buffer.iter().rev() {\n+                f.write_char(d as char)?;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+impl<S: Semantics> fmt::Debug for IeeeFloat<S> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}({:?} | {}{:?} * 2^{})\",\n+               self, self.category,\n+               if self.sign { \"-\" } else { \"+\" },\n+               self.sig,\n+               self.exp)\n+    }\n+}\n+\n+impl<S: Semantics> Float for IeeeFloat<S> {\n+    const BITS: usize = S::BITS;\n+    const PRECISION: usize = S::PRECISION;\n+    const MAX_EXP: ExpInt = S::MAX_EXP;\n+    const MIN_EXP: ExpInt = S::MIN_EXP;\n+\n+    const ZERO: Self = IeeeFloat {\n+        sig: [0],\n+        exp: S::MIN_EXP - 1,\n+        category: Category::Zero,\n+        sign: false,\n+        marker: PhantomData,\n+    };\n+\n+    const INFINITY: Self = IeeeFloat {\n+        sig: [0],\n+        exp: S::MAX_EXP + 1,\n+        category: Category::Infinity,\n+        sign: false,\n+        marker: PhantomData,\n+    };\n+\n+    // FIXME(eddyb) remove when qnan becomes const fn.\n+    const NAN: Self = IeeeFloat {\n+        sig: [S::QNAN_SIGNIFICAND],\n+        exp: S::MAX_EXP + 1,\n+        category: Category::NaN,\n+        sign: false,\n+        marker: PhantomData,\n+    };\n+\n+    fn qnan(payload: Option<u128>) -> Self {\n+        IeeeFloat {\n+            sig: [\n+                S::QNAN_SIGNIFICAND |\n+                    payload.map_or(0, |payload| {\n+                        // Zero out the excess bits of the significand.\n+                        payload & ((1 << S::QNAN_BIT) - 1)\n+                    }),\n+            ],\n+            exp: S::MAX_EXP + 1,\n+            category: Category::NaN,\n+            sign: false,\n+            marker: PhantomData,\n+        }\n+    }\n+\n+    fn snan(payload: Option<u128>) -> Self {\n+        let mut snan = Self::qnan(payload);\n+\n+        // We always have to clear the QNaN bit to make it an SNaN.\n+        sig::clear_bit(&mut snan.sig, S::QNAN_BIT);\n+\n+        // If there are no bits set in the payload, we have to set\n+        // *something* to make it a NaN instead of an infinity;\n+        // conventionally, this is the next bit down from the QNaN bit.\n+        if snan.sig[0] & !S::QNAN_SIGNIFICAND == 0 {\n+            sig::set_bit(&mut snan.sig, S::QNAN_BIT - 1);\n+        }\n+\n+        snan\n+    }\n+\n+    fn largest() -> Self {\n+        // We want (in interchange format):\n+        //   exponent = 1..10\n+        //   significand = 1..1\n+        IeeeFloat {\n+            sig: [!0 & ((1 << S::PRECISION) - 1)],\n+            exp: S::MAX_EXP,\n+            category: Category::Normal,\n+            sign: false,\n+            marker: PhantomData,\n+        }\n+    }\n+\n+    // We want (in interchange format):\n+    //   exponent = 0..0\n+    //   significand = 0..01\n+    const SMALLEST: Self = IeeeFloat {\n+        sig: [1],\n+        exp: S::MIN_EXP,\n+        category: Category::Normal,\n+        sign: false,\n+        marker: PhantomData,\n+    };\n+\n+    fn smallest_normalized() -> Self {\n+        // We want (in interchange format):\n+        //   exponent = 0..0\n+        //   significand = 10..0\n+        IeeeFloat {\n+            sig: [1 << (S::PRECISION - 1)],\n+            exp: S::MIN_EXP,\n+            category: Category::Normal,\n+            sign: false,\n+            marker: PhantomData,\n+        }\n+    }\n+\n+    fn add_r(mut self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        let status = match (self.category, rhs.category) {\n+            (Category::Infinity, Category::Infinity) => {\n+                // Differently signed infinities can only be validly\n+                // subtracted.\n+                if self.sign != rhs.sign {\n+                    self = Self::NAN;\n+                    Status::INVALID_OP\n+                } else {\n+                    Status::OK\n+                }\n+            }\n+\n+            // Sign may depend on rounding mode; handled below.\n+            (_, Category::Zero) |\n+            (Category::NaN, _) |\n+            (Category::Infinity, Category::Normal) => Status::OK,\n+\n+            (Category::Zero, _) |\n+            (_, Category::NaN) |\n+            (_, Category::Infinity) => {\n+                self = rhs;\n+                Status::OK\n+            }\n+\n+            // This return code means it was not a simple case.\n+            (Category::Normal, Category::Normal) => {\n+                let loss = sig::add_or_sub(\n+                    &mut self.sig,\n+                    &mut self.exp,\n+                    &mut self.sign,\n+                    &mut [rhs.sig[0]],\n+                    rhs.exp,\n+                    rhs.sign,\n+                );\n+                let status;\n+                self = unpack!(status=, self.normalize(round, loss));\n+\n+                // Can only be zero if we lost no fraction.\n+                assert!(self.category != Category::Zero || loss == Loss::ExactlyZero);\n+\n+                status\n+            }\n+        };\n+\n+        // If two numbers add (exactly) to zero, IEEE 754 decrees it is a\n+        // positive zero unless rounding to minus infinity, except that\n+        // adding two like-signed zeroes gives that zero.\n+        if self.category == Category::Zero &&\n+            (rhs.category != Category::Zero || self.sign != rhs.sign)\n+        {\n+            self.sign = round == Round::TowardNegative;\n+        }\n+\n+        status.and(self)\n+    }\n+\n+    fn mul_r(mut self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        self.sign ^= rhs.sign;\n+\n+        match (self.category, rhs.category) {\n+            (Category::NaN, _) => {\n+                self.sign = false;\n+                Status::OK.and(self)\n+            }\n+\n+            (_, Category::NaN) => {\n+                self.sign = false;\n+                self.category = Category::NaN;\n+                self.sig = rhs.sig;\n+                Status::OK.and(self)\n+            }\n+\n+            (Category::Zero, Category::Infinity) |\n+            (Category::Infinity, Category::Zero) => Status::INVALID_OP.and(Self::NAN),\n+\n+            (_, Category::Infinity) |\n+            (Category::Infinity, _) => {\n+                self.category = Category::Infinity;\n+                Status::OK.and(self)\n+            }\n+\n+            (Category::Zero, _) |\n+            (_, Category::Zero) => {\n+                self.category = Category::Zero;\n+                Status::OK.and(self)\n+            }\n+\n+            (Category::Normal, Category::Normal) => {\n+                self.exp += rhs.exp;\n+                let mut wide_sig = [0; 2];\n+                let loss = sig::mul(\n+                    &mut wide_sig,\n+                    &mut self.exp,\n+                    &self.sig,\n+                    &rhs.sig,\n+                    S::PRECISION,\n+                );\n+                self.sig = [wide_sig[0]];\n+                let mut status;\n+                self = unpack!(status=, self.normalize(round, loss));\n+                if loss != Loss::ExactlyZero {\n+                    status |= Status::INEXACT;\n+                }\n+                status.and(self)\n+            }\n+        }\n+    }\n+\n+    fn mul_add_r(mut self, multiplicand: Self, addend: Self, round: Round) -> StatusAnd<Self> {\n+        // If and only if all arguments are normal do we need to do an\n+        // extended-precision calculation.\n+        if !self.is_finite_non_zero() || !multiplicand.is_finite_non_zero() || !addend.is_finite() {\n+            let mut status;\n+            self = unpack!(status=, self.mul_r(multiplicand, round));\n+\n+            // FS can only be Status::OK or Status::INVALID_OP. There is no more work\n+            // to do in the latter case. The IEEE-754R standard says it is\n+            // implementation-defined in this case whether, if ADDEND is a\n+            // quiet NaN, we raise invalid op; this implementation does so.\n+            //\n+            // If we need to do the addition we can do so with normal\n+            // precision.\n+            if status == Status::OK {\n+                self = unpack!(status=, self.add_r(addend, round));\n+            }\n+            return status.and(self);\n+        }\n+\n+        // Post-multiplication sign, before addition.\n+        self.sign ^= multiplicand.sign;\n+\n+        // Allocate space for twice as many bits as the original significand, plus one\n+        // extra bit for the addition to overflow into.\n+        assert!(limbs_for_bits(S::PRECISION * 2 + 1) <= 2);\n+        let mut wide_sig = sig::widening_mul(self.sig[0], multiplicand.sig[0]);\n+\n+        let mut loss = Loss::ExactlyZero;\n+        let mut omsb = sig::omsb(&wide_sig);\n+        self.exp += multiplicand.exp;\n+\n+        // Assume the operands involved in the multiplication are single-precision\n+        // FP, and the two multiplicants are:\n+        //     lhs = a23 . a22 ... a0 * 2^e1\n+        //     rhs = b23 . b22 ... b0 * 2^e2\n+        // the result of multiplication is:\n+        //     lhs = c48 c47 c46 . c45 ... c0 * 2^(e1+e2)\n+        // Note that there are three significant bits at the left-hand side of the\n+        // radix point: two for the multiplication, and an overflow bit for the\n+        // addition (that will always be zero at this point). Move the radix point\n+        // toward left by two bits, and adjust exponent accordingly.\n+        self.exp += 2;\n+\n+        if addend.is_non_zero() {\n+            // Normalize our MSB to one below the top bit to allow for overflow.\n+            let ext_precision = 2 * S::PRECISION + 1;\n+            if omsb != ext_precision - 1 {\n+                assert!(ext_precision > omsb);\n+                sig::shift_left(&mut wide_sig, &mut self.exp, (ext_precision - 1) - omsb);\n+            }\n+\n+            // The intermediate result of the multiplication has \"2 * S::PRECISION\"\n+            // signicant bit; adjust the addend to be consistent with mul result.\n+            let mut ext_addend_sig = [addend.sig[0], 0];\n+\n+            // Extend the addend significand to ext_precision - 1. This guarantees\n+            // that the high bit of the significand is zero (same as wide_sig),\n+            // so the addition will overflow (if it does overflow at all) into the top bit.\n+            sig::shift_left(\n+                &mut ext_addend_sig,\n+                &mut 0,\n+                ext_precision - 1 - S::PRECISION,\n+            );\n+            loss = sig::add_or_sub(\n+                &mut wide_sig,\n+                &mut self.exp,\n+                &mut self.sign,\n+                &mut ext_addend_sig,\n+                addend.exp + 1,\n+                addend.sign,\n+            );\n+\n+            omsb = sig::omsb(&wide_sig);\n+        }\n+\n+        // Convert the result having \"2 * S::PRECISION\" significant-bits back to the one\n+        // having \"S::PRECISION\" significant-bits. First, move the radix point from\n+        // poision \"2*S::PRECISION - 1\" to \"S::PRECISION - 1\". The exponent need to be\n+        // adjusted by \"2*S::PRECISION - 1\" - \"S::PRECISION - 1\" = \"S::PRECISION\".\n+        self.exp -= S::PRECISION as ExpInt + 1;\n+\n+        // In case MSB resides at the left-hand side of radix point, shift the\n+        // mantissa right by some amount to make sure the MSB reside right before\n+        // the radix point (i.e. \"MSB . rest-significant-bits\").\n+        if omsb > S::PRECISION {\n+            let bits = omsb - S::PRECISION;\n+            loss = sig::shift_right(&mut wide_sig, &mut self.exp, bits).combine(loss);\n+        }\n+\n+        self.sig[0] = wide_sig[0];\n+\n+        let mut status;\n+        self = unpack!(status=, self.normalize(round, loss));\n+        if loss != Loss::ExactlyZero {\n+            status |= Status::INEXACT;\n+        }\n+\n+        // If two numbers add (exactly) to zero, IEEE 754 decrees it is a\n+        // positive zero unless rounding to minus infinity, except that\n+        // adding two like-signed zeroes gives that zero.\n+        if self.category == Category::Zero && !status.intersects(Status::UNDERFLOW) &&\n+            self.sign != addend.sign\n+        {\n+            self.sign = round == Round::TowardNegative;\n+        }\n+\n+        status.and(self)\n+    }\n+\n+    fn div_r(mut self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        self.sign ^= rhs.sign;\n+\n+        match (self.category, rhs.category) {\n+            (Category::NaN, _) => {\n+                self.sign = false;\n+                Status::OK.and(self)\n+            }\n+\n+            (_, Category::NaN) => {\n+                self.category = Category::NaN;\n+                self.sig = rhs.sig;\n+                self.sign = false;\n+                Status::OK.and(self)\n+            }\n+\n+            (Category::Infinity, Category::Infinity) |\n+            (Category::Zero, Category::Zero) => Status::INVALID_OP.and(Self::NAN),\n+\n+            (Category::Infinity, _) |\n+            (Category::Zero, _) => Status::OK.and(self),\n+\n+            (Category::Normal, Category::Infinity) => {\n+                self.category = Category::Zero;\n+                Status::OK.and(self)\n+            }\n+\n+            (Category::Normal, Category::Zero) => {\n+                self.category = Category::Infinity;\n+                Status::DIV_BY_ZERO.and(self)\n+            }\n+\n+            (Category::Normal, Category::Normal) => {\n+                self.exp -= rhs.exp;\n+                let dividend = self.sig[0];\n+                let loss = sig::div(\n+                    &mut self.sig,\n+                    &mut self.exp,\n+                    &mut [dividend],\n+                    &mut [rhs.sig[0]],\n+                    S::PRECISION,\n+                );\n+                let mut status;\n+                self = unpack!(status=, self.normalize(round, loss));\n+                if loss != Loss::ExactlyZero {\n+                    status |= Status::INEXACT;\n+                }\n+                status.and(self)\n+            }\n+        }\n+    }\n+\n+    fn c_fmod(mut self, rhs: Self) -> StatusAnd<Self> {\n+        match (self.category, rhs.category) {\n+            (Category::NaN, _) |\n+            (Category::Zero, Category::Infinity) |\n+            (Category::Zero, Category::Normal) |\n+            (Category::Normal, Category::Infinity) => Status::OK.and(self),\n+\n+            (_, Category::NaN) => {\n+                self.sign = false;\n+                self.category = Category::NaN;\n+                self.sig = rhs.sig;\n+                Status::OK.and(self)\n+            }\n+\n+            (Category::Infinity, _) |\n+            (_, Category::Zero) => Status::INVALID_OP.and(Self::NAN),\n+\n+            (Category::Normal, Category::Normal) => {\n+                while self.is_finite_non_zero() && rhs.is_finite_non_zero() &&\n+                    self.cmp_abs_normal(rhs) != Ordering::Less\n+                {\n+                    let mut v = rhs.scalbn(self.ilogb() - rhs.ilogb());\n+                    if self.cmp_abs_normal(v) == Ordering::Less {\n+                        v = v.scalbn(-1);\n+                    }\n+                    v.sign = self.sign;\n+\n+                    let status;\n+                    self = unpack!(status=, self - v);\n+                    assert_eq!(status, Status::OK);\n+                }\n+                Status::OK.and(self)\n+            }\n+        }\n+    }\n+\n+    fn round_to_integral(self, round: Round) -> StatusAnd<Self> {\n+        // If the exponent is large enough, we know that this value is already\n+        // integral, and the arithmetic below would potentially cause it to saturate\n+        // to +/-Inf. Bail out early instead.\n+        if self.is_finite_non_zero() && self.exp + 1 >= S::PRECISION as ExpInt {\n+            return Status::OK.and(self);\n+        }\n+\n+        // The algorithm here is quite simple: we add 2^(p-1), where p is the\n+        // precision of our format, and then subtract it back off again. The choice\n+        // of rounding modes for the addition/subtraction determines the rounding mode\n+        // for our integral rounding as well.\n+        // NOTE: When the input value is negative, we do subtraction followed by\n+        // addition instead.\n+        assert!(S::PRECISION <= 128);\n+        let mut status;\n+        let magic_const = unpack!(status=, Self::from_u128(1 << (S::PRECISION - 1)));\n+        let magic_const = magic_const.copy_sign(self);\n+\n+        if status != Status::OK {\n+            return status.and(self);\n+        }\n+\n+        let mut r = self;\n+        r = unpack!(status=, r.add_r(magic_const, round));\n+        if status != Status::OK && status != Status::INEXACT {\n+            return status.and(self);\n+        }\n+\n+        // Restore the input sign to handle 0.0/-0.0 cases correctly.\n+        r.sub_r(magic_const, round).map(|r| r.copy_sign(self))\n+    }\n+\n+    fn next_up(mut self) -> StatusAnd<Self> {\n+        // Compute nextUp(x), handling each float category separately.\n+        match self.category {\n+            Category::Infinity => {\n+                if self.sign {\n+                    // nextUp(-inf) = -largest\n+                    Status::OK.and(-Self::largest())\n+                } else {\n+                    // nextUp(+inf) = +inf\n+                    Status::OK.and(self)\n+                }\n+            }\n+            Category::NaN => {\n+                // IEEE-754R 2008 6.2 Par 2: nextUp(sNaN) = qNaN. Set Invalid flag.\n+                // IEEE-754R 2008 6.2: nextUp(qNaN) = qNaN. Must be identity so we do not\n+                //                     change the payload.\n+                if self.is_signaling() {\n+                    // For consistency, propagate the sign of the sNaN to the qNaN.\n+                    Status::INVALID_OP.and(Self::NAN.copy_sign(self))\n+                } else {\n+                    Status::OK.and(self)\n+                }\n+            }\n+            Category::Zero => {\n+                // nextUp(pm 0) = +smallest\n+                Status::OK.and(Self::SMALLEST)\n+            }\n+            Category::Normal => {\n+                // nextUp(-smallest) = -0\n+                if self.is_smallest() && self.sign {\n+                    return Status::OK.and(-Self::ZERO);\n+                }\n+\n+                // nextUp(largest) == INFINITY\n+                if self.is_largest() && !self.sign {\n+                    return Status::OK.and(Self::INFINITY);\n+                }\n+\n+                // Excluding the integral bit. This allows us to test for binade boundaries.\n+                let sig_mask = (1 << (S::PRECISION - 1)) - 1;\n+\n+                // nextUp(normal) == normal + inc.\n+                if self.sign {\n+                    // If we are negative, we need to decrement the significand.\n+\n+                    // We only cross a binade boundary that requires adjusting the exponent\n+                    // if:\n+                    //   1. exponent != S::MIN_EXP. This implies we are not in the\n+                    //   smallest binade or are dealing with denormals.\n+                    //   2. Our significand excluding the integral bit is all zeros.\n+                    let crossing_binade_boundary = self.exp != S::MIN_EXP &&\n+                        self.sig[0] & sig_mask == 0;\n+\n+                    // Decrement the significand.\n+                    //\n+                    // We always do this since:\n+                    //   1. If we are dealing with a non-binade decrement, by definition we\n+                    //   just decrement the significand.\n+                    //   2. If we are dealing with a normal -> normal binade decrement, since\n+                    //   we have an explicit integral bit the fact that all bits but the\n+                    //   integral bit are zero implies that subtracting one will yield a\n+                    //   significand with 0 integral bit and 1 in all other spots. Thus we\n+                    //   must just adjust the exponent and set the integral bit to 1.\n+                    //   3. If we are dealing with a normal -> denormal binade decrement,\n+                    //   since we set the integral bit to 0 when we represent denormals, we\n+                    //   just decrement the significand.\n+                    sig::decrement(&mut self.sig);\n+\n+                    if crossing_binade_boundary {\n+                        // Our result is a normal number. Do the following:\n+                        // 1. Set the integral bit to 1.\n+                        // 2. Decrement the exponent.\n+                        sig::set_bit(&mut self.sig, S::PRECISION - 1);\n+                        self.exp -= 1;\n+                    }\n+                } else {\n+                    // If we are positive, we need to increment the significand.\n+\n+                    // We only cross a binade boundary that requires adjusting the exponent if\n+                    // the input is not a denormal and all of said input's significand bits\n+                    // are set. If all of said conditions are true: clear the significand, set\n+                    // the integral bit to 1, and increment the exponent. If we have a\n+                    // denormal always increment since moving denormals and the numbers in the\n+                    // smallest normal binade have the same exponent in our representation.\n+                    let crossing_binade_boundary = !self.is_denormal() &&\n+                        self.sig[0] & sig_mask == sig_mask;\n+\n+                    if crossing_binade_boundary {\n+                        self.sig = [0];\n+                        sig::set_bit(&mut self.sig, S::PRECISION - 1);\n+                        assert_ne!(\n+                            self.exp,\n+                            S::MAX_EXP,\n+                            \"We can not increment an exponent beyond the MAX_EXP \\\n+                             allowed by the given floating point semantics.\"\n+                        );\n+                        self.exp += 1;\n+                    } else {\n+                        sig::increment(&mut self.sig);\n+                    }\n+                }\n+                Status::OK.and(self)\n+            }\n+        }\n+    }\n+\n+    fn from_bits(input: u128) -> Self {\n+        // Dispatch to semantics.\n+        S::from_bits(input)\n+    }\n+\n+    fn from_u128_r(input: u128, round: Round) -> StatusAnd<Self> {\n+        IeeeFloat {\n+            sig: [input],\n+            exp: S::PRECISION as ExpInt - 1,\n+            category: Category::Normal,\n+            sign: false,\n+            marker: PhantomData,\n+        }.normalize(round, Loss::ExactlyZero)\n+    }\n+\n+    fn from_str_r(mut s: &str, mut round: Round) -> Result<StatusAnd<Self>, ParseError> {\n+        if s.is_empty() {\n+            return Err(ParseError(\"Invalid string length\"));\n+        }\n+\n+        // Handle special cases.\n+        match s {\n+            \"inf\" | \"INFINITY\" => return Ok(Status::OK.and(Self::INFINITY)),\n+            \"-inf\" | \"-INFINITY\" => return Ok(Status::OK.and(-Self::INFINITY)),\n+            \"nan\" | \"NaN\" => return Ok(Status::OK.and(Self::NAN)),\n+            \"-nan\" | \"-NaN\" => return Ok(Status::OK.and(-Self::NAN)),\n+            _ => {}\n+        }\n+\n+        // Handle a leading minus sign.\n+        let minus = s.starts_with(\"-\");\n+        if minus || s.starts_with(\"+\") {\n+            s = &s[1..];\n+            if s.is_empty() {\n+                return Err(ParseError(\"String has no digits\"));\n+            }\n+        }\n+\n+        // Adjust the rounding mode for the absolute value below.\n+        if minus {\n+            round = -round;\n+        }\n+\n+        let r = if s.starts_with(\"0x\") || s.starts_with(\"0X\") {\n+            s = &s[2..];\n+            if s.is_empty() {\n+                return Err(ParseError(\"Invalid string\"));\n+            }\n+            Self::from_hexadecimal_string(s, round)?\n+        } else {\n+            Self::from_decimal_string(s, round)?\n+        };\n+\n+        Ok(r.map(|r| if minus { -r } else { r }))\n+    }\n+\n+    fn to_bits(self) -> u128 {\n+        // Dispatch to semantics.\n+        S::to_bits(self)\n+    }\n+\n+    fn to_u128_r(self, width: usize, round: Round, is_exact: &mut bool) -> StatusAnd<u128> {\n+        // The result of trying to convert a number too large.\n+        let overflow = if self.sign {\n+            // Negative numbers cannot be represented as unsigned.\n+            0\n+        } else {\n+            // Largest unsigned integer of the given width.\n+            !0 >> (128 - width)\n+        };\n+\n+        *is_exact = false;\n+\n+        match self.category {\n+            Category::NaN => Status::INVALID_OP.and(0),\n+\n+            Category::Infinity => Status::INVALID_OP.and(overflow),\n+\n+            Category::Zero => {\n+                // Negative zero can't be represented as an int.\n+                *is_exact = !self.sign;\n+                Status::OK.and(0)\n+            }\n+\n+            Category::Normal => {\n+                let mut r = 0;\n+\n+                // Step 1: place our absolute value, with any fraction truncated, in\n+                // the destination.\n+                let truncated_bits = if self.exp < 0 {\n+                    // Our absolute value is less than one; truncate everything.\n+                    // For exponent -1 the integer bit represents .5, look at that.\n+                    // For smaller exponents leftmost truncated bit is 0.\n+                    S::PRECISION - 1 + (-self.exp) as usize\n+                } else {\n+                    // We want the most significant (exponent + 1) bits; the rest are\n+                    // truncated.\n+                    let bits = self.exp as usize + 1;\n+\n+                    // Hopelessly large in magnitude?\n+                    if bits > width {\n+                        return Status::INVALID_OP.and(overflow);\n+                    }\n+\n+                    if bits < S::PRECISION {\n+                        // We truncate (S::PRECISION - bits) bits.\n+                        r = self.sig[0] >> (S::PRECISION - bits);\n+                        S::PRECISION - bits\n+                    } else {\n+                        // We want at least as many bits as are available.\n+                        r = self.sig[0] << (bits - S::PRECISION);\n+                        0\n+                    }\n+                };\n+\n+                // Step 2: work out any lost fraction, and increment the absolute\n+                // value if we would round away from zero.\n+                let mut loss = Loss::ExactlyZero;\n+                if truncated_bits > 0 {\n+                    loss = Loss::through_truncation(&self.sig, truncated_bits);\n+                    if loss != Loss::ExactlyZero &&\n+                        self.round_away_from_zero(round, loss, truncated_bits)\n+                    {\n+                        r = r.wrapping_add(1);\n+                        if r == 0 {\n+                            return Status::INVALID_OP.and(overflow); // Overflow.\n+                        }\n+                    }\n+                }\n+\n+                // Step 3: check if we fit in the destination.\n+                if r > overflow {\n+                    return Status::INVALID_OP.and(overflow);\n+                }\n+\n+                if loss == Loss::ExactlyZero {\n+                    *is_exact = true;\n+                    Status::OK.and(r)\n+                } else {\n+                    Status::INEXACT.and(r)\n+                }\n+            }\n+        }\n+    }\n+\n+    fn cmp_abs_normal(self, rhs: Self) -> Ordering {\n+        assert!(self.is_finite_non_zero());\n+        assert!(rhs.is_finite_non_zero());\n+\n+        // If exponents are equal, do an unsigned comparison of the significands.\n+        self.exp.cmp(&rhs.exp).then_with(\n+            || sig::cmp(&self.sig, &rhs.sig),\n+        )\n+    }\n+\n+    fn bitwise_eq(self, rhs: Self) -> bool {\n+        if self.category != rhs.category || self.sign != rhs.sign {\n+            return false;\n+        }\n+\n+        if self.category == Category::Zero || self.category == Category::Infinity {\n+            return true;\n+        }\n+\n+        if self.is_finite_non_zero() && self.exp != rhs.exp {\n+            return false;\n+        }\n+\n+        self.sig == rhs.sig\n+    }\n+\n+    fn is_negative(self) -> bool {\n+        self.sign\n+    }\n+\n+    fn is_denormal(self) -> bool {\n+        self.is_finite_non_zero() && self.exp == S::MIN_EXP &&\n+            !sig::get_bit(&self.sig, S::PRECISION - 1)\n+    }\n+\n+    fn is_signaling(self) -> bool {\n+        // IEEE-754R 2008 6.2.1: A signaling NaN bit string should be encoded with the\n+        // first bit of the trailing significand being 0.\n+        self.is_nan() && !sig::get_bit(&self.sig, S::QNAN_BIT)\n+    }\n+\n+    fn category(self) -> Category {\n+        self.category\n+    }\n+\n+    fn get_exact_inverse(self) -> Option<Self> {\n+        // Special floats and denormals have no exact inverse.\n+        if !self.is_finite_non_zero() {\n+            return None;\n+        }\n+\n+        // Check that the number is a power of two by making sure that only the\n+        // integer bit is set in the significand.\n+        if self.sig != [1 << (S::PRECISION - 1)] {\n+            return None;\n+        }\n+\n+        // Get the inverse.\n+        let mut reciprocal = Self::from_u128(1).value;\n+        let status;\n+        reciprocal = unpack!(status=, reciprocal / self);\n+        if status != Status::OK {\n+            return None;\n+        }\n+\n+        // Avoid multiplication with a denormal, it is not safe on all platforms and\n+        // may be slower than a normal division.\n+        if reciprocal.is_denormal() {\n+            return None;\n+        }\n+\n+        assert!(reciprocal.is_finite_non_zero());\n+        assert_eq!(reciprocal.sig, [1 << (S::PRECISION - 1)]);\n+\n+        Some(reciprocal)\n+    }\n+\n+    fn ilogb(mut self) -> ExpInt {\n+        if self.is_nan() {\n+            return IEK_NAN;\n+        }\n+        if self.is_zero() {\n+            return IEK_ZERO;\n+        }\n+        if self.is_infinite() {\n+            return IEK_INF;\n+        }\n+        if !self.is_denormal() {\n+            return self.exp;\n+        }\n+\n+        let sig_bits = (S::PRECISION - 1) as ExpInt;\n+        self.exp += sig_bits;\n+        self = self.normalize(Round::NearestTiesToEven, Loss::ExactlyZero)\n+            .value;\n+        self.exp - sig_bits\n+    }\n+\n+    fn scalbn_r(mut self, exp: ExpInt, round: Round) -> Self {\n+        // If exp is wildly out-of-scale, simply adding it to self.exp will\n+        // overflow; clamp it to a safe range before adding, but ensure that the range\n+        // is large enough that the clamp does not change the result. The range we\n+        // need to support is the difference between the largest possible exponent and\n+        // the normalized exponent of half the smallest denormal.\n+\n+        let sig_bits = (S::PRECISION - 1) as i32;\n+        let max_change = S::MAX_EXP as i32 - (S::MIN_EXP as i32 - sig_bits) + 1;\n+\n+        // Clamp to one past the range ends to let normalize handle overflow.\n+        let exp_change = cmp::min(cmp::max(exp as i32, (-max_change - 1)), max_change);\n+        self.exp = self.exp.saturating_add(exp_change as ExpInt);\n+        self = self.normalize(round, Loss::ExactlyZero).value;\n+        if self.is_nan() {\n+            sig::set_bit(&mut self.sig, S::QNAN_BIT);\n+        }\n+        self\n+    }\n+\n+    fn frexp_r(mut self, exp: &mut ExpInt, round: Round) -> Self {\n+        *exp = self.ilogb();\n+\n+        // Quiet signalling nans.\n+        if *exp == IEK_NAN {\n+            sig::set_bit(&mut self.sig, S::QNAN_BIT);\n+            return self;\n+        }\n+\n+        if *exp == IEK_INF {\n+            return self;\n+        }\n+\n+        // 1 is added because frexp is defined to return a normalized fraction in\n+        // +/-[0.5, 1.0), rather than the usual +/-[1.0, 2.0).\n+        if *exp == IEK_ZERO {\n+            *exp = 0;\n+        } else {\n+            *exp += 1;\n+        }\n+        self.scalbn_r(-*exp, round)\n+    }\n+}\n+\n+impl<S: Semantics, T: Semantics> FloatConvert<IeeeFloat<T>> for IeeeFloat<S> {\n+    fn convert_r(self, round: Round, loses_info: &mut bool) -> StatusAnd<IeeeFloat<T>> {\n+        let mut r = IeeeFloat {\n+            sig: self.sig,\n+            exp: self.exp,\n+            category: self.category,\n+            sign: self.sign,\n+            marker: PhantomData,\n+        };\n+\n+        // x86 has some unusual NaNs which cannot be represented in any other\n+        // format; note them here.\n+        fn is_x87_double_extended<S: Semantics>() -> bool {\n+            S::QNAN_SIGNIFICAND == X87DoubleExtendedS::QNAN_SIGNIFICAND\n+        }\n+        let x87_special_nan = is_x87_double_extended::<S>() && !is_x87_double_extended::<T>() &&\n+            r.category == Category::NaN &&\n+            (r.sig[0] & S::QNAN_SIGNIFICAND) != S::QNAN_SIGNIFICAND;\n+\n+        // If this is a truncation of a denormal number, and the target semantics\n+        // has larger exponent range than the source semantics (this can happen\n+        // when truncating from PowerPC double-double to double format), the\n+        // right shift could lose result mantissa bits. Adjust exponent instead\n+        // of performing excessive shift.\n+        let mut shift = T::PRECISION as ExpInt - S::PRECISION as ExpInt;\n+        if shift < 0 && r.is_finite_non_zero() {\n+            let mut exp_change = sig::omsb(&r.sig) as ExpInt - S::PRECISION as ExpInt;\n+            if r.exp + exp_change < T::MIN_EXP {\n+                exp_change = T::MIN_EXP - r.exp;\n+            }\n+            if exp_change < shift {\n+                exp_change = shift;\n+            }\n+            if exp_change < 0 {\n+                shift -= exp_change;\n+                r.exp += exp_change;\n+            }\n+        }\n+\n+        // If this is a truncation, perform the shift.\n+        let mut loss = Loss::ExactlyZero;\n+        if shift < 0 && (r.is_finite_non_zero() || r.category == Category::NaN) {\n+            loss = sig::shift_right(&mut r.sig, &mut 0, -shift as usize);\n+        }\n+\n+        // If this is an extension, perform the shift.\n+        if shift > 0 && (r.is_finite_non_zero() || r.category == Category::NaN) {\n+            sig::shift_left(&mut r.sig, &mut 0, shift as usize);\n+        }\n+\n+        let status;\n+        if r.is_finite_non_zero() {\n+            r = unpack!(status=, r.normalize(round, loss));\n+            *loses_info = status != Status::OK;\n+        } else if r.category == Category::NaN {\n+            *loses_info = loss != Loss::ExactlyZero || x87_special_nan;\n+\n+            // For x87 extended precision, we want to make a NaN, not a special NaN if\n+            // the input wasn't special either.\n+            if !x87_special_nan && is_x87_double_extended::<T>() {\n+                sig::set_bit(&mut r.sig, T::PRECISION - 1);\n+            }\n+\n+            // gcc forces the Quiet bit on, which means (float)(double)(float_sNan)\n+            // does not give you back the same bits. This is dubious, and we\n+            // don't currently do it. You're really supposed to get\n+            // an invalid operation signal at runtime, but nobody does that.\n+            status = Status::OK;\n+        } else {\n+            *loses_info = false;\n+            status = Status::OK;\n+        }\n+\n+        status.and(r)\n+    }\n+}\n+\n+impl<S: Semantics> IeeeFloat<S> {\n+    /// Handle positive overflow. We either return infinity or\n+    /// the largest finite number. For negative overflow,\n+    /// negate the `round` argument before calling.\n+    fn overflow_result(round: Round) -> StatusAnd<Self> {\n+        match round {\n+            // Infinity?\n+            Round::NearestTiesToEven | Round::NearestTiesToAway | Round::TowardPositive => {\n+                (Status::OVERFLOW | Status::INEXACT).and(Self::INFINITY)\n+            }\n+            // Otherwise we become the largest finite number.\n+            Round::TowardNegative | Round::TowardZero => Status::INEXACT.and(Self::largest()),\n+        }\n+    }\n+\n+    /// Returns TRUE if, when truncating the current number, with BIT the\n+    /// new LSB, with the given lost fraction and rounding mode, the result\n+    /// would need to be rounded away from zero (i.e., by increasing the\n+    /// signficand). This routine must work for Category::Zero of both signs, and\n+    /// Category::Normal numbers.\n+    fn round_away_from_zero(&self, round: Round, loss: Loss, bit: usize) -> bool {\n+        // NaNs and infinities should not have lost fractions.\n+        assert!(self.is_finite_non_zero() || self.is_zero());\n+\n+        // Current callers never pass this so we don't handle it.\n+        assert_ne!(loss, Loss::ExactlyZero);\n+\n+        match round {\n+            Round::NearestTiesToAway => loss == Loss::ExactlyHalf || loss == Loss::MoreThanHalf,\n+            Round::NearestTiesToEven => {\n+                if loss == Loss::MoreThanHalf {\n+                    return true;\n+                }\n+\n+                // Our zeros don't have a significand to test.\n+                if loss == Loss::ExactlyHalf && self.category != Category::Zero {\n+                    return sig::get_bit(&self.sig, bit);\n+                }\n+\n+                false\n+            }\n+            Round::TowardZero => false,\n+            Round::TowardPositive => !self.sign,\n+            Round::TowardNegative => self.sign,\n+        }\n+    }\n+\n+    fn normalize(mut self, round: Round, mut loss: Loss) -> StatusAnd<Self> {\n+        if !self.is_finite_non_zero() {\n+            return Status::OK.and(self);\n+        }\n+\n+        // Before rounding normalize the exponent of Category::Normal numbers.\n+        let mut omsb = sig::omsb(&self.sig);\n+\n+        if omsb > 0 {\n+            // OMSB is numbered from 1. We want to place it in the integer\n+            // bit numbered PRECISION if possible, with a compensating change in\n+            // the exponent.\n+            let mut final_exp = self.exp.saturating_add(\n+                omsb as ExpInt - S::PRECISION as ExpInt,\n+            );\n+\n+            // If the resulting exponent is too high, overflow according to\n+            // the rounding mode.\n+            if final_exp > S::MAX_EXP {\n+                let round = if self.sign { -round } else { round };\n+                return Self::overflow_result(round).map(|r| r.copy_sign(self));\n+            }\n+\n+            // Subnormal numbers have exponent MIN_EXP, and their MSB\n+            // is forced based on that.\n+            if final_exp < S::MIN_EXP {\n+                final_exp = S::MIN_EXP;\n+            }\n+\n+            // Shifting left is easy as we don't lose precision.\n+            if final_exp < self.exp {\n+                assert_eq!(loss, Loss::ExactlyZero);\n+\n+                let exp_change = (self.exp - final_exp) as usize;\n+                sig::shift_left(&mut self.sig, &mut self.exp, exp_change);\n+\n+                return Status::OK.and(self);\n+            }\n+\n+            // Shift right and capture any new lost fraction.\n+            if final_exp > self.exp {\n+                let exp_change = (final_exp - self.exp) as usize;\n+                loss = sig::shift_right(&mut self.sig, &mut self.exp, exp_change).combine(loss);\n+\n+                // Keep OMSB up-to-date.\n+                omsb = omsb.saturating_sub(exp_change);\n+            }\n+        }\n+\n+        // Now round the number according to round given the lost\n+        // fraction.\n+\n+        // As specified in IEEE 754, since we do not trap we do not report\n+        // underflow for exact results.\n+        if loss == Loss::ExactlyZero {\n+            // Canonicalize zeros.\n+            if omsb == 0 {\n+                self.category = Category::Zero;\n+            }\n+\n+            return Status::OK.and(self);\n+        }\n+\n+        // Increment the significand if we're rounding away from zero.\n+        if self.round_away_from_zero(round, loss, 0) {\n+            if omsb == 0 {\n+                self.exp = S::MIN_EXP;\n+            }\n+\n+            // We should never overflow.\n+            assert_eq!(sig::increment(&mut self.sig), 0);\n+            omsb = sig::omsb(&self.sig);\n+\n+            // Did the significand increment overflow?\n+            if omsb == S::PRECISION + 1 {\n+                // Renormalize by incrementing the exponent and shifting our\n+                // significand right one. However if we already have the\n+                // maximum exponent we overflow to infinity.\n+                if self.exp == S::MAX_EXP {\n+                    self.category = Category::Infinity;\n+\n+                    return (Status::OVERFLOW | Status::INEXACT).and(self);\n+                }\n+\n+                let _: Loss = sig::shift_right(&mut self.sig, &mut self.exp, 1);\n+\n+                return Status::INEXACT.and(self);\n+            }\n+        }\n+\n+        // The normal case - we were and are not denormal, and any\n+        // significand increment above didn't overflow.\n+        if omsb == S::PRECISION {\n+            return Status::INEXACT.and(self);\n+        }\n+\n+        // We have a non-zero denormal.\n+        assert!(omsb < S::PRECISION);\n+\n+        // Canonicalize zeros.\n+        if omsb == 0 {\n+            self.category = Category::Zero;\n+        }\n+\n+        // The Category::Zero case is a denormal that underflowed to zero.\n+        (Status::UNDERFLOW | Status::INEXACT).and(self)\n+    }\n+\n+    fn from_hexadecimal_string(s: &str, round: Round) -> Result<StatusAnd<Self>, ParseError> {\n+        let mut r = IeeeFloat {\n+            sig: [0],\n+            exp: 0,\n+            category: Category::Normal,\n+            sign: false,\n+            marker: PhantomData,\n+        };\n+\n+        let mut any_digits = false;\n+        let mut has_exp = false;\n+        let mut bit_pos = LIMB_BITS as isize;\n+        let mut loss = None;\n+\n+        // Without leading or trailing zeros, irrespective of the dot.\n+        let mut first_sig_digit = None;\n+        let mut dot = s.len();\n+\n+        for (p, c) in s.char_indices() {\n+            // Skip leading zeros and any (hexa)decimal point.\n+            if c == '.' {\n+                if dot != s.len() {\n+                    return Err(ParseError(\"String contains multiple dots\"));\n+                }\n+                dot = p;\n+            } else if let Some(hex_value) = c.to_digit(16) {\n+                any_digits = true;\n+\n+                if first_sig_digit.is_none() {\n+                    if hex_value == 0 {\n+                        continue;\n+                    }\n+                    first_sig_digit = Some(p);\n+                }\n+\n+                // Store the number while we have space.\n+                bit_pos -= 4;\n+                if bit_pos >= 0 {\n+                    r.sig[0] |= (hex_value as Limb) << bit_pos;\n+                } else {\n+                    // If zero or one-half (the hexadecimal digit 8) are followed\n+                    // by non-zero, they're a little more than zero or one-half.\n+                    if let Some(ref mut loss) = loss {\n+                        if hex_value != 0 {\n+                            if *loss == Loss::ExactlyZero {\n+                                *loss = Loss::LessThanHalf;\n+                            }\n+                            if *loss == Loss::ExactlyHalf {\n+                                *loss = Loss::MoreThanHalf;\n+                            }\n+                        }\n+                    } else {\n+                        loss = Some(match hex_value {\n+                            0 => Loss::ExactlyZero,\n+                            1...7 => Loss::LessThanHalf,\n+                            8 => Loss::ExactlyHalf,\n+                            9...15 => Loss::MoreThanHalf,\n+                            _ => unreachable!(),\n+                        });\n+                    }\n+                }\n+            } else if c == 'p' || c == 'P' {\n+                if !any_digits {\n+                    return Err(ParseError(\"Significand has no digits\"));\n+                }\n+\n+                if dot == s.len() {\n+                    dot = p;\n+                }\n+\n+                let mut chars = s[p + 1..].chars().peekable();\n+\n+                // Adjust for the given exponent.\n+                let exp_minus = chars.peek() == Some(&'-');\n+                if exp_minus || chars.peek() == Some(&'+') {\n+                    chars.next();\n+                }\n+\n+                for c in chars {\n+                    if let Some(value) = c.to_digit(10) {\n+                        has_exp = true;\n+                        r.exp = r.exp.saturating_mul(10).saturating_add(value as ExpInt);\n+                    } else {\n+                        return Err(ParseError(\"Invalid character in exponent\"));\n+                    }\n+                }\n+                if !has_exp {\n+                    return Err(ParseError(\"Exponent has no digits\"));\n+                }\n+\n+                if exp_minus {\n+                    r.exp = -r.exp;\n+                }\n+\n+                break;\n+            } else {\n+                return Err(ParseError(\"Invalid character in significand\"));\n+            }\n+        }\n+        if !any_digits {\n+            return Err(ParseError(\"Significand has no digits\"));\n+        }\n+\n+        // Hex floats require an exponent but not a hexadecimal point.\n+        if !has_exp {\n+            return Err(ParseError(\"Hex strings require an exponent\"));\n+        }\n+\n+        // Ignore the exponent if we are zero.\n+        let first_sig_digit = match first_sig_digit {\n+            Some(p) => p,\n+            None => return Ok(Status::OK.and(Self::ZERO)),\n+        };\n+\n+        // Calculate the exponent adjustment implicit in the number of\n+        // significant digits and adjust for writing the significand starting\n+        // at the most significant nibble.\n+        let exp_adjustment = if dot > first_sig_digit {\n+            ExpInt::try_from(dot - first_sig_digit).unwrap()\n+        } else {\n+            -ExpInt::try_from(first_sig_digit - dot - 1).unwrap()\n+        };\n+        let exp_adjustment = exp_adjustment\n+            .saturating_mul(4)\n+            .saturating_sub(1)\n+            .saturating_add(S::PRECISION as ExpInt)\n+            .saturating_sub(LIMB_BITS as ExpInt);\n+        r.exp = r.exp.saturating_add(exp_adjustment);\n+\n+        Ok(r.normalize(round, loss.unwrap_or(Loss::ExactlyZero)))\n+    }\n+\n+    fn from_decimal_string(s: &str, round: Round) -> Result<StatusAnd<Self>, ParseError> {\n+        // Given a normal decimal floating point number of the form\n+        //\n+        //   dddd.dddd[eE][+-]ddd\n+        //\n+        // where the decimal point and exponent are optional, fill out the\n+        // variables below. Exponent is appropriate if the significand is\n+        // treated as an integer, and normalized_exp if the significand\n+        // is taken to have the decimal point after a single leading\n+        // non-zero digit.\n+        //\n+        // If the value is zero, first_sig_digit is None.\n+\n+        let mut any_digits = false;\n+        let mut dec_exp = 0i32;\n+\n+        // Without leading or trailing zeros, irrespective of the dot.\n+        let mut first_sig_digit = None;\n+        let mut last_sig_digit = 0;\n+        let mut dot = s.len();\n+\n+        for (p, c) in s.char_indices() {\n+            if c == '.' {\n+                if dot != s.len() {\n+                    return Err(ParseError(\"String contains multiple dots\"));\n+                }\n+                dot = p;\n+            } else if let Some(dec_value) = c.to_digit(10) {\n+                any_digits = true;\n+\n+                if dec_value != 0 {\n+                    if first_sig_digit.is_none() {\n+                        first_sig_digit = Some(p);\n+                    }\n+                    last_sig_digit = p;\n+                }\n+            } else if c == 'e' || c == 'E' {\n+                if !any_digits {\n+                    return Err(ParseError(\"Significand has no digits\"));\n+                }\n+\n+                if dot == s.len() {\n+                    dot = p;\n+                }\n+\n+                let mut chars = s[p + 1..].chars().peekable();\n+\n+                // Adjust for the given exponent.\n+                let exp_minus = chars.peek() == Some(&'-');\n+                if exp_minus || chars.peek() == Some(&'+') {\n+                    chars.next();\n+                }\n+\n+                any_digits = false;\n+                for c in chars {\n+                    if let Some(value) = c.to_digit(10) {\n+                        any_digits = true;\n+                        dec_exp = dec_exp.saturating_mul(10).saturating_add(value as i32);\n+                    } else {\n+                        return Err(ParseError(\"Invalid character in exponent\"));\n+                    }\n+                }\n+                if !any_digits {\n+                    return Err(ParseError(\"Exponent has no digits\"));\n+                }\n+\n+                if exp_minus {\n+                    dec_exp = -dec_exp;\n+                }\n+\n+                break;\n+            } else {\n+                return Err(ParseError(\"Invalid character in significand\"));\n+            }\n+        }\n+        if !any_digits {\n+            return Err(ParseError(\"Significand has no digits\"));\n+        }\n+\n+        // Test if we have a zero number allowing for non-zero exponents.\n+        let first_sig_digit = match first_sig_digit {\n+            Some(p) => p,\n+            None => return Ok(Status::OK.and(Self::ZERO)),\n+        };\n+\n+        // Adjust the exponents for any decimal point.\n+        if dot > last_sig_digit {\n+            dec_exp = dec_exp.saturating_add((dot - last_sig_digit - 1) as i32);\n+        } else {\n+            dec_exp = dec_exp.saturating_sub((last_sig_digit - dot) as i32);\n+        }\n+        let significand_digits = last_sig_digit - first_sig_digit + 1 -\n+            (dot > first_sig_digit && dot < last_sig_digit) as usize;\n+        let normalized_exp = dec_exp.saturating_add(significand_digits as i32 - 1);\n+\n+        // Handle the cases where exponents are obviously too large or too\n+        // small. Writing L for log 10 / log 2, a number d.ddddd*10^dec_exp\n+        // definitely overflows if\n+        //\n+        //       (dec_exp - 1) * L >= MAX_EXP\n+        //\n+        // and definitely underflows to zero where\n+        //\n+        //       (dec_exp + 1) * L <= MIN_EXP - PRECISION\n+        //\n+        // With integer arithmetic the tightest bounds for L are\n+        //\n+        //       93/28 < L < 196/59            [ numerator <= 256 ]\n+        //       42039/12655 < L < 28738/8651  [ numerator <= 65536 ]\n+\n+        // Check for MAX_EXP.\n+        if normalized_exp.saturating_sub(1).saturating_mul(42039) >= 12655 * S::MAX_EXP as i32 {\n+            // Overflow and round.\n+            return Ok(Self::overflow_result(round));\n+        }\n+\n+        // Check for MIN_EXP.\n+        if normalized_exp.saturating_add(1).saturating_mul(28738) <=\n+            8651 * (S::MIN_EXP as i32 - S::PRECISION as i32)\n+        {\n+            // Underflow to zero and round.\n+            let r = if round == Round::TowardPositive {\n+                IeeeFloat::SMALLEST\n+            } else {\n+                IeeeFloat::ZERO\n+            };\n+            return Ok((Status::UNDERFLOW | Status::INEXACT).and(r));\n+        }\n+\n+        // A tight upper bound on number of bits required to hold an\n+        // N-digit decimal integer is N * 196 / 59. Allocate enough space\n+        // to hold the full significand, and an extra limb required by\n+        // tcMultiplyPart.\n+        let max_limbs = limbs_for_bits(1 + 196 * significand_digits / 59);\n+        let mut dec_sig = Vec::with_capacity(max_limbs);\n+\n+        // Convert to binary efficiently - we do almost all multiplication\n+        // in a Limb. When this would overflow do we do a single\n+        // bignum multiplication, and then revert again to multiplication\n+        // in a Limb.\n+        let mut chars = s[first_sig_digit..last_sig_digit + 1].chars();\n+        loop {\n+            let mut val = 0;\n+            let mut multiplier = 1;\n+\n+            loop {\n+                let dec_value = match chars.next() {\n+                    Some('.') => continue,\n+                    Some(c) => c.to_digit(10).unwrap(),\n+                    None => break,\n+                };\n+\n+                multiplier *= 10;\n+                val = val * 10 + dec_value as Limb;\n+\n+                // The maximum number that can be multiplied by ten with any\n+                // digit added without overflowing a Limb.\n+                if multiplier > (!0 - 9) / 10 {\n+                    break;\n+                }\n+            }\n+\n+            // If we've consumed no digits, we're done.\n+            if multiplier == 1 {\n+                break;\n+            }\n+\n+            // Multiply out the current limb.\n+            let mut carry = val;\n+            for x in &mut dec_sig {\n+                let [low, mut high] = sig::widening_mul(*x, multiplier);\n+\n+                // Now add carry.\n+                let (low, overflow) = low.overflowing_add(carry);\n+                high += overflow as Limb;\n+\n+                *x = low;\n+                carry = high;\n+            }\n+\n+            // If we had carry, we need another limb (likely but not guaranteed).\n+            if carry > 0 {\n+                dec_sig.push(carry);\n+            }\n+        }\n+\n+        // Calculate pow(5, abs(dec_exp)) into `pow5_full`.\n+        // The *_calc Vec's are reused scratch space, as an optimization.\n+        let (pow5_full, mut pow5_calc, mut sig_calc, mut sig_scratch_calc) = {\n+            let mut power = dec_exp.abs() as usize;\n+\n+            const FIRST_EIGHT_POWERS: [Limb; 8] = [1, 5, 25, 125, 625, 3125, 15625, 78125];\n+\n+            let mut p5_scratch = vec![];\n+            let mut p5 = vec![FIRST_EIGHT_POWERS[4]];\n+\n+            let mut r_scratch = vec![];\n+            let mut r = vec![FIRST_EIGHT_POWERS[power & 7]];\n+            power >>= 3;\n+\n+            while power > 0 {\n+                // Calculate pow(5,pow(2,n+3)).\n+                p5_scratch.resize(p5.len() * 2, 0);\n+                let _: Loss = sig::mul(&mut p5_scratch, &mut 0, &p5, &p5, p5.len() * 2 * LIMB_BITS);\n+                while p5_scratch.last() == Some(&0) {\n+                    p5_scratch.pop();\n+                }\n+                mem::swap(&mut p5, &mut p5_scratch);\n+\n+                if power & 1 != 0 {\n+                    r_scratch.resize(r.len() + p5.len(), 0);\n+                    let _: Loss = sig::mul(\n+                        &mut r_scratch,\n+                        &mut 0,\n+                        &r,\n+                        &p5,\n+                        (r.len() + p5.len()) * LIMB_BITS,\n+                    );\n+                    while r_scratch.last() == Some(&0) {\n+                        r_scratch.pop();\n+                    }\n+                    mem::swap(&mut r, &mut r_scratch);\n+                }\n+\n+                power >>= 1;\n+            }\n+\n+            (r, r_scratch, p5, p5_scratch)\n+        };\n+\n+        // Attempt dec_sig * 10^dec_exp with increasing precision.\n+        let mut attempt = 1;\n+        loop {\n+            let calc_precision = (LIMB_BITS << attempt) - 1;\n+            attempt += 1;\n+\n+            let calc_normal_from_limbs = |sig: &mut Vec<Limb>,\n+                                          limbs: &[Limb]|\n+             -> StatusAnd<ExpInt> {\n+                sig.resize(limbs_for_bits(calc_precision), 0);\n+                let (mut loss, mut exp) = sig::from_limbs(sig, limbs, calc_precision);\n+\n+                // Before rounding normalize the exponent of Category::Normal numbers.\n+                let mut omsb = sig::omsb(sig);\n+\n+                assert_ne!(omsb, 0);\n+\n+                // OMSB is numbered from 1. We want to place it in the integer\n+                // bit numbered PRECISION if possible, with a compensating change in\n+                // the exponent.\n+                let final_exp = exp.saturating_add(omsb as ExpInt - calc_precision as ExpInt);\n+\n+                // Shifting left is easy as we don't lose precision.\n+                if final_exp < exp {\n+                    assert_eq!(loss, Loss::ExactlyZero);\n+\n+                    let exp_change = (exp - final_exp) as usize;\n+                    sig::shift_left(sig, &mut exp, exp_change);\n+\n+                    return Status::OK.and(exp);\n+                }\n+\n+                // Shift right and capture any new lost fraction.\n+                if final_exp > exp {\n+                    let exp_change = (final_exp - exp) as usize;\n+                    loss = sig::shift_right(sig, &mut exp, exp_change).combine(loss);\n+\n+                    // Keep OMSB up-to-date.\n+                    omsb = omsb.saturating_sub(exp_change);\n+                }\n+\n+                assert_eq!(omsb, calc_precision);\n+\n+                // Now round the number according to round given the lost\n+                // fraction.\n+\n+                // As specified in IEEE 754, since we do not trap we do not report\n+                // underflow for exact results.\n+                if loss == Loss::ExactlyZero {\n+                    return Status::OK.and(exp);\n+                }\n+\n+                // Increment the significand if we're rounding away from zero.\n+                if loss == Loss::MoreThanHalf || loss == Loss::ExactlyHalf && sig::get_bit(sig, 0) {\n+                    // We should never overflow.\n+                    assert_eq!(sig::increment(sig), 0);\n+                    omsb = sig::omsb(sig);\n+\n+                    // Did the significand increment overflow?\n+                    if omsb == calc_precision + 1 {\n+                        let _: Loss = sig::shift_right(sig, &mut exp, 1);\n+\n+                        return Status::INEXACT.and(exp);\n+                    }\n+                }\n+\n+                // The normal case - we were and are not denormal, and any\n+                // significand increment above didn't overflow.\n+                Status::INEXACT.and(exp)\n+            };\n+\n+            let status;\n+            let mut exp = unpack!(status=,\n+                calc_normal_from_limbs(&mut sig_calc, &dec_sig));\n+            let pow5_status;\n+            let pow5_exp = unpack!(pow5_status=,\n+                calc_normal_from_limbs(&mut pow5_calc, &pow5_full));\n+\n+            // Add dec_exp, as 10^n = 5^n * 2^n.\n+            exp += dec_exp as ExpInt;\n+\n+            let mut used_bits = S::PRECISION;\n+            let mut truncated_bits = calc_precision - used_bits;\n+\n+            let half_ulp_err1 = (status != Status::OK) as Limb;\n+            let (calc_loss, half_ulp_err2);\n+            if dec_exp >= 0 {\n+                exp += pow5_exp;\n+\n+                sig_scratch_calc.resize(sig_calc.len() + pow5_calc.len(), 0);\n+                calc_loss = sig::mul(\n+                    &mut sig_scratch_calc,\n+                    &mut exp,\n+                    &sig_calc,\n+                    &pow5_calc,\n+                    calc_precision,\n+                );\n+                mem::swap(&mut sig_calc, &mut sig_scratch_calc);\n+\n+                half_ulp_err2 = (pow5_status != Status::OK) as Limb;\n+            } else {\n+                exp -= pow5_exp;\n+\n+                sig_scratch_calc.resize(sig_calc.len(), 0);\n+                calc_loss = sig::div(\n+                    &mut sig_scratch_calc,\n+                    &mut exp,\n+                    &mut sig_calc,\n+                    &mut pow5_calc,\n+                    calc_precision,\n+                );\n+                mem::swap(&mut sig_calc, &mut sig_scratch_calc);\n+\n+                // Denormal numbers have less precision.\n+                if exp < S::MIN_EXP {\n+                    truncated_bits += (S::MIN_EXP - exp) as usize;\n+                    used_bits = calc_precision.saturating_sub(truncated_bits);\n+                }\n+                // Extra half-ulp lost in reciprocal of exponent.\n+                half_ulp_err2 = 2 *\n+                    (pow5_status != Status::OK || calc_loss != Loss::ExactlyZero) as Limb;\n+            }\n+\n+            // Both sig::mul and sig::div return the\n+            // result with the integer bit set.\n+            assert!(sig::get_bit(&sig_calc, calc_precision - 1));\n+\n+            // The error from the true value, in half-ulps, on multiplying two\n+            // floating point numbers, which differ from the value they\n+            // approximate by at most half_ulp_err1 and half_ulp_err2 half-ulps, is strictly less\n+            // than the returned value.\n+            //\n+            // See \"How to Read Floating Point Numbers Accurately\" by William D Clinger.\n+            assert!(\n+                half_ulp_err1 < 2 || half_ulp_err2 < 2 || (half_ulp_err1 + half_ulp_err2 < 8)\n+            );\n+\n+            let inexact = (calc_loss != Loss::ExactlyZero) as Limb;\n+            let half_ulp_err = if half_ulp_err1 + half_ulp_err2 == 0 {\n+                inexact * 2 // <= inexact half-ulps.\n+            } else {\n+                inexact + 2 * (half_ulp_err1 + half_ulp_err2)\n+            };\n+\n+            let ulps_from_boundary = {\n+                let bits = calc_precision - used_bits - 1;\n+\n+                let i = bits / LIMB_BITS;\n+                let limb = sig_calc[i] & (!0 >> (LIMB_BITS - 1 - bits % LIMB_BITS));\n+                let boundary = match round {\n+                    Round::NearestTiesToEven | Round::NearestTiesToAway => 1 << (bits % LIMB_BITS),\n+                    _ => 0,\n+                };\n+                if i == 0 {\n+                    let delta = limb.wrapping_sub(boundary);\n+                    cmp::min(delta, delta.wrapping_neg())\n+                } else if limb == boundary {\n+                    if !sig::is_all_zeros(&sig_calc[1..i]) {\n+                        !0 // A lot.\n+                    } else {\n+                        sig_calc[0]\n+                    }\n+                } else if limb == boundary.wrapping_sub(1) {\n+                    if sig_calc[1..i].iter().any(|&x| x.wrapping_neg() != 1) {\n+                        !0 // A lot.\n+                    } else {\n+                        sig_calc[0].wrapping_neg()\n+                    }\n+                } else {\n+                    !0 // A lot.\n+                }\n+            };\n+\n+            // Are we guaranteed to round correctly if we truncate?\n+            if ulps_from_boundary.saturating_mul(2) >= half_ulp_err {\n+                let mut r = IeeeFloat {\n+                    sig: [0],\n+                    exp,\n+                    category: Category::Normal,\n+                    sign: false,\n+                    marker: PhantomData,\n+                };\n+                sig::extract(&mut r.sig, &sig_calc, used_bits, calc_precision - used_bits);\n+                // If we extracted less bits above we must adjust our exponent\n+                // to compensate for the implicit right shift.\n+                r.exp += (S::PRECISION - used_bits) as ExpInt;\n+                let loss = Loss::through_truncation(&sig_calc, truncated_bits);\n+                return Ok(r.normalize(round, loss));\n+            }\n+        }\n+    }\n+}\n+\n+impl Loss {\n+    /// Combine the effect of two lost fractions.\n+    fn combine(self, less_significant: Loss) -> Loss {\n+        let mut more_significant = self;\n+        if less_significant != Loss::ExactlyZero {\n+            if more_significant == Loss::ExactlyZero {\n+                more_significant = Loss::LessThanHalf;\n+            } else if more_significant == Loss::ExactlyHalf {\n+                more_significant = Loss::MoreThanHalf;\n+            }\n+        }\n+\n+        more_significant\n+    }\n+\n+    /// Return the fraction lost were a bignum truncated losing the least\n+    /// significant `bits` bits.\n+    fn through_truncation(limbs: &[Limb], bits: usize) -> Loss {\n+        if bits == 0 {\n+            return Loss::ExactlyZero;\n+        }\n+\n+        let half_bit = bits - 1;\n+        let half_limb = half_bit / LIMB_BITS;\n+        let (half_limb, rest) = if half_limb < limbs.len() {\n+            (limbs[half_limb], &limbs[..half_limb])\n+        } else {\n+            (0, limbs)\n+        };\n+        let half = 1 << (half_bit % LIMB_BITS);\n+        let has_half = half_limb & half != 0;\n+        let has_rest = half_limb & (half - 1) != 0 || !sig::is_all_zeros(rest);\n+\n+        match (has_half, has_rest) {\n+            (false, false) => Loss::ExactlyZero,\n+            (false, true) => Loss::LessThanHalf,\n+            (true, false) => Loss::ExactlyHalf,\n+            (true, true) => Loss::MoreThanHalf,\n+        }\n+    }\n+}\n+\n+/// Implementation details of IeeeFloat significands, such as big integer arithmetic.\n+/// As a rule of thumb, no functions in this module should dynamically allocate.\n+mod sig {\n+    use std::cmp::Ordering;\n+    use std::mem;\n+    use super::{ExpInt, Limb, LIMB_BITS, limbs_for_bits, Loss};\n+\n+    pub(super) fn is_all_zeros(limbs: &[Limb]) -> bool {\n+        limbs.iter().all(|&l| l == 0)\n+    }\n+\n+    /// One, not zero, based MSB. That is, returns 0 for a zeroed significand.\n+    pub(super) fn omsb(limbs: &[Limb]) -> usize {\n+        for i in (0..limbs.len()).rev() {\n+            if limbs[i] != 0 {\n+                return (i + 1) * LIMB_BITS - limbs[i].leading_zeros() as usize;\n+            }\n+        }\n+\n+        0\n+    }\n+\n+    /// Comparison (unsigned) of two significands.\n+    pub(super) fn cmp(a: &[Limb], b: &[Limb]) -> Ordering {\n+        assert_eq!(a.len(), b.len());\n+        for (a, b) in a.iter().zip(b).rev() {\n+            match a.cmp(b) {\n+                Ordering::Equal => {}\n+                o => return o,\n+            }\n+        }\n+\n+        Ordering::Equal\n+    }\n+\n+    /// Extract the given bit.\n+    pub(super) fn get_bit(limbs: &[Limb], bit: usize) -> bool {\n+        limbs[bit / LIMB_BITS] & (1 << (bit % LIMB_BITS)) != 0\n+    }\n+\n+    /// Set the given bit.\n+    pub(super) fn set_bit(limbs: &mut [Limb], bit: usize) {\n+        limbs[bit / LIMB_BITS] |= 1 << (bit % LIMB_BITS);\n+    }\n+\n+    /// Clear the given bit.\n+    pub(super) fn clear_bit(limbs: &mut [Limb], bit: usize) {\n+        limbs[bit / LIMB_BITS] &= !(1 << (bit % LIMB_BITS));\n+    }\n+\n+    /// Shift `dst` left `bits` bits, subtract `bits` from its exponent.\n+    pub(super) fn shift_left(dst: &mut [Limb], exp: &mut ExpInt, bits: usize) {\n+        if bits > 0 {\n+            // Our exponent should not underflow.\n+            *exp = exp.checked_sub(bits as ExpInt).unwrap();\n+\n+            // Jump is the inter-limb jump; shift is is intra-limb shift.\n+            let jump = bits / LIMB_BITS;\n+            let shift = bits % LIMB_BITS;\n+\n+            for i in (0..dst.len()).rev() {\n+                let mut limb;\n+\n+                if i < jump {\n+                    limb = 0;\n+                } else {\n+                    // dst[i] comes from the two limbs src[i - jump] and, if we have\n+                    // an intra-limb shift, src[i - jump - 1].\n+                    limb = dst[i - jump];\n+                    if shift > 0 {\n+                        limb <<= shift;\n+                        if i >= jump + 1 {\n+                            limb |= dst[i - jump - 1] >> (LIMB_BITS - shift);\n+                        }\n+                    }\n+                }\n+\n+                dst[i] = limb;\n+            }\n+        }\n+    }\n+\n+    /// Shift `dst` right `bits` bits noting lost fraction.\n+    pub(super) fn shift_right(dst: &mut [Limb], exp: &mut ExpInt, bits: usize) -> Loss {\n+        let loss = Loss::through_truncation(dst, bits);\n+\n+        if bits > 0 {\n+            // Our exponent should not overflow.\n+            *exp = exp.checked_add(bits as ExpInt).unwrap();\n+\n+            // Jump is the inter-limb jump; shift is is intra-limb shift.\n+            let jump = bits / LIMB_BITS;\n+            let shift = bits % LIMB_BITS;\n+\n+            // Perform the shift. This leaves the most significant `bits` bits\n+            // of the result at zero.\n+            for i in 0..dst.len() {\n+                let mut limb;\n+\n+                if i + jump >= dst.len() {\n+                    limb = 0;\n+                } else {\n+                    limb = dst[i + jump];\n+                    if shift > 0 {\n+                        limb >>= shift;\n+                        if i + jump + 1 < dst.len() {\n+                            limb |= dst[i + jump + 1] << (LIMB_BITS - shift);\n+                        }\n+                    }\n+                }\n+\n+                dst[i] = limb;\n+            }\n+        }\n+\n+        loss\n+    }\n+\n+    /// Copy the bit vector of width `src_bits` from `src`, starting at bit SRC_LSB,\n+    /// to `dst`, such that the bit SRC_LSB becomes the least significant bit of `dst`.\n+    /// All high bits above `src_bits` in `dst` are zero-filled.\n+    pub(super) fn extract(dst: &mut [Limb], src: &[Limb], src_bits: usize, src_lsb: usize) {\n+        if src_bits == 0 {\n+            return;\n+        }\n+\n+        let dst_limbs = limbs_for_bits(src_bits);\n+        assert!(dst_limbs <= dst.len());\n+\n+        let src = &src[src_lsb / LIMB_BITS..];\n+        dst[..dst_limbs].copy_from_slice(&src[..dst_limbs]);\n+\n+        let shift = src_lsb % LIMB_BITS;\n+        let _: Loss = shift_right(&mut dst[..dst_limbs], &mut 0, shift);\n+\n+        // We now have (dst_limbs * LIMB_BITS - shift) bits from `src`\n+        // in `dst`.  If this is less that src_bits, append the rest, else\n+        // clear the high bits.\n+        let n = dst_limbs * LIMB_BITS - shift;\n+        if n < src_bits {\n+            let mask = (1 << (src_bits - n)) - 1;\n+            dst[dst_limbs - 1] |= (src[dst_limbs] & mask) << n % LIMB_BITS;\n+        } else if n > src_bits && src_bits % LIMB_BITS > 0 {\n+            dst[dst_limbs - 1] &= (1 << (src_bits % LIMB_BITS)) - 1;\n+        }\n+\n+        // Clear high limbs.\n+        for x in &mut dst[dst_limbs..] {\n+            *x = 0;\n+        }\n+    }\n+\n+    /// We want the most significant PRECISION bits of `src`. There may not\n+    /// be that many; extract what we can.\n+    pub(super) fn from_limbs(dst: &mut [Limb], src: &[Limb], precision: usize) -> (Loss, ExpInt) {\n+        let omsb = omsb(src);\n+\n+        if precision <= omsb {\n+            extract(dst, src, precision, omsb - precision);\n+            (\n+                Loss::through_truncation(src, omsb - precision),\n+                omsb as ExpInt - 1,\n+            )\n+        } else {\n+            extract(dst, src, omsb, 0);\n+            (Loss::ExactlyZero, precision as ExpInt - 1)\n+        }\n+    }\n+\n+    /// Increment in-place, return the carry flag.\n+    pub(super) fn increment(dst: &mut [Limb]) -> Limb {\n+        for x in dst {\n+            *x = x.wrapping_add(1);\n+            if *x != 0 {\n+                return 0;\n+            }\n+        }\n+\n+        1\n+    }\n+\n+    /// Decrement in-place, return the borrow flag.\n+    pub(super) fn decrement(dst: &mut [Limb]) -> Limb {\n+        for x in dst {\n+            *x = x.wrapping_sub(1);\n+            if *x != !0 {\n+                return 0;\n+            }\n+        }\n+\n+        1\n+    }\n+\n+    /// `a += b + c` where `c` is zero or one. Returns the carry flag.\n+    pub(super) fn add(a: &mut [Limb], b: &[Limb], mut c: Limb) -> Limb {\n+        assert!(c <= 1);\n+\n+        for (a, &b) in a.iter_mut().zip(b) {\n+            let (r, overflow) = a.overflowing_add(b);\n+            let (r, overflow2) = r.overflowing_add(c);\n+            *a = r;\n+            c = (overflow | overflow2) as Limb;\n+        }\n+\n+        c\n+    }\n+\n+    /// `a -= b + c` where `c` is zero or one. Returns the borrow flag.\n+    pub(super) fn sub(a: &mut [Limb], b: &[Limb], mut c: Limb) -> Limb {\n+        assert!(c <= 1);\n+\n+        for (a, &b) in a.iter_mut().zip(b) {\n+            let (r, overflow) = a.overflowing_sub(b);\n+            let (r, overflow2) = r.overflowing_sub(c);\n+            *a = r;\n+            c = (overflow | overflow2) as Limb;\n+        }\n+\n+        c\n+    }\n+\n+    /// `a += b` or `a -= b`. Does not preserve `b`.\n+    pub(super) fn add_or_sub(\n+        a_sig: &mut [Limb],\n+        a_exp: &mut ExpInt,\n+        a_sign: &mut bool,\n+        b_sig: &mut [Limb],\n+        b_exp: ExpInt,\n+        b_sign: bool,\n+    ) -> Loss {\n+        // Are we bigger exponent-wise than the RHS?\n+        let bits = *a_exp - b_exp;\n+\n+        // Determine if the operation on the absolute values is effectively\n+        // an addition or subtraction.\n+        // Subtraction is more subtle than one might naively expect.\n+        if *a_sign ^ b_sign {\n+            let (reverse, loss);\n+\n+            if bits == 0 {\n+                reverse = cmp(a_sig, b_sig) == Ordering::Less;\n+                loss = Loss::ExactlyZero;\n+            } else if bits > 0 {\n+                loss = shift_right(b_sig, &mut 0, (bits - 1) as usize);\n+                shift_left(a_sig, a_exp, 1);\n+                reverse = false;\n+            } else {\n+                loss = shift_right(a_sig, a_exp, (-bits - 1) as usize);\n+                shift_left(b_sig, &mut 0, 1);\n+                reverse = true;\n+            }\n+\n+            let borrow = (loss != Loss::ExactlyZero) as Limb;\n+            if reverse {\n+                // The code above is intended to ensure that no borrow is necessary.\n+                assert_eq!(sub(b_sig, a_sig, borrow), 0);\n+                a_sig.copy_from_slice(b_sig);\n+                *a_sign = !*a_sign;\n+            } else {\n+                // The code above is intended to ensure that no borrow is necessary.\n+                assert_eq!(sub(a_sig, b_sig, borrow), 0);\n+            }\n+\n+            // Invert the lost fraction - it was on the RHS and subtracted.\n+            match loss {\n+                Loss::LessThanHalf => Loss::MoreThanHalf,\n+                Loss::MoreThanHalf => Loss::LessThanHalf,\n+                _ => loss,\n+            }\n+        } else {\n+            let loss = if bits > 0 {\n+                shift_right(b_sig, &mut 0, bits as usize)\n+            } else {\n+                shift_right(a_sig, a_exp, -bits as usize)\n+            };\n+            // We have a guard bit; generating a carry cannot happen.\n+            assert_eq!(add(a_sig, b_sig, 0), 0);\n+            loss\n+        }\n+    }\n+\n+    /// `[low, high] = a * b`.\n+    ///\n+    /// This cannot overflow, because\n+    ///\n+    /// `(n - 1) * (n - 1) + 2 * (n - 1) == (n - 1) * (n + 1)`\n+    ///\n+    /// which is less than n^2.\n+    pub(super) fn widening_mul(a: Limb, b: Limb) -> [Limb; 2] {\n+        let mut wide = [0, 0];\n+\n+        if a == 0 || b == 0 {\n+            return wide;\n+        }\n+\n+        const HALF_BITS: usize = LIMB_BITS / 2;\n+\n+        let select = |limb, i| (limb >> (i * HALF_BITS)) & ((1 << HALF_BITS) - 1);\n+        for i in 0..2 {\n+            for j in 0..2 {\n+                let mut x = [select(a, i) * select(b, j), 0];\n+                shift_left(&mut x, &mut 0, (i + j) * HALF_BITS);\n+                assert_eq!(add(&mut wide, &x, 0), 0);\n+            }\n+        }\n+\n+        wide\n+    }\n+\n+    /// `dst = a * b` (for normal `a` and `b`). Returns the lost fraction.\n+    pub(super) fn mul<'a>(\n+        dst: &mut [Limb],\n+        exp: &mut ExpInt,\n+        mut a: &'a [Limb],\n+        mut b: &'a [Limb],\n+        precision: usize,\n+    ) -> Loss {\n+        // Put the narrower number on the `a` for less loops below.\n+        if a.len() > b.len() {\n+            mem::swap(&mut a, &mut b);\n+        }\n+\n+        for x in &mut dst[..b.len()] {\n+            *x = 0;\n+        }\n+\n+        for i in 0..a.len() {\n+            let mut carry = 0;\n+            for j in 0..b.len() {\n+                let [low, mut high] = widening_mul(a[i], b[j]);\n+\n+                // Now add carry.\n+                let (low, overflow) = low.overflowing_add(carry);\n+                high += overflow as Limb;\n+\n+                // And now `dst[i + j]`, and store the new low part there.\n+                let (low, overflow) = low.overflowing_add(dst[i + j]);\n+                high += overflow as Limb;\n+\n+                dst[i + j] = low;\n+                carry = high;\n+            }\n+            dst[i + b.len()] = carry;\n+        }\n+\n+        // Assume the operands involved in the multiplication are single-precision\n+        // FP, and the two multiplicants are:\n+        //     a = a23 . a22 ... a0 * 2^e1\n+        //     b = b23 . b22 ... b0 * 2^e2\n+        // the result of multiplication is:\n+        //     dst = c48 c47 c46 . c45 ... c0 * 2^(e1+e2)\n+        // Note that there are three significant bits at the left-hand side of the\n+        // radix point: two for the multiplication, and an overflow bit for the\n+        // addition (that will always be zero at this point). Move the radix point\n+        // toward left by two bits, and adjust exponent accordingly.\n+        *exp += 2;\n+\n+        // Convert the result having \"2 * precision\" significant-bits back to the one\n+        // having \"precision\" significant-bits. First, move the radix point from\n+        // poision \"2*precision - 1\" to \"precision - 1\". The exponent need to be\n+        // adjusted by \"2*precision - 1\" - \"precision - 1\" = \"precision\".\n+        *exp -= precision as ExpInt + 1;\n+\n+        // In case MSB resides at the left-hand side of radix point, shift the\n+        // mantissa right by some amount to make sure the MSB reside right before\n+        // the radix point (i.e. \"MSB . rest-significant-bits\").\n+        //\n+        // Note that the result is not normalized when \"omsb < precision\". So, the\n+        // caller needs to call IeeeFloat::normalize() if normalized value is\n+        // expected.\n+        let omsb = omsb(dst);\n+        if omsb <= precision {\n+            Loss::ExactlyZero\n+        } else {\n+            shift_right(dst, exp, omsb - precision)\n+        }\n+    }\n+\n+    /// `quotient = dividend / divisor`. Returns the lost fraction.\n+    /// Does not preserve `dividend` or `divisor`.\n+    pub(super) fn div(\n+        quotient: &mut [Limb],\n+        exp: &mut ExpInt,\n+        dividend: &mut [Limb],\n+        divisor: &mut [Limb],\n+        precision: usize,\n+    ) -> Loss {\n+        // Zero the quotient before setting bits in it.\n+        for x in &mut quotient[..limbs_for_bits(precision)] {\n+            *x = 0;\n+        }\n+\n+        // Normalize the divisor.\n+        let bits = precision - omsb(divisor);\n+        shift_left(divisor, &mut 0, bits);\n+        *exp += bits as ExpInt;\n+\n+        // Normalize the dividend.\n+        let bits = precision - omsb(dividend);\n+        shift_left(dividend, exp, bits);\n+\n+        // Ensure the dividend >= divisor initially for the loop below.\n+        // Incidentally, this means that the division loop below is\n+        // guaranteed to set the integer bit to one.\n+        if cmp(dividend, divisor) == Ordering::Less {\n+            shift_left(dividend, exp, 1);\n+            assert_ne!(cmp(dividend, divisor), Ordering::Less)\n+        }\n+\n+        // Long division.\n+        for bit in (0..precision).rev() {\n+            if cmp(dividend, divisor) != Ordering::Less {\n+                sub(dividend, divisor, 0);\n+                set_bit(quotient, bit);\n+            }\n+            shift_left(dividend, &mut 0, 1);\n+        }\n+\n+        // Figure out the lost fraction.\n+        match cmp(dividend, divisor) {\n+            Ordering::Greater => Loss::MoreThanHalf,\n+            Ordering::Equal => Loss::ExactlyHalf,\n+            Ordering::Less => {\n+                if is_all_zeros(dividend) {\n+                    Loss::ExactlyZero\n+                } else {\n+                    Loss::LessThanHalf\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "d9dbf787856520f2d508c1fa870898f6f2093325", "filename": "src/librustc_apfloat/lib.rs", "status": "added", "additions": 693, "deletions": 0, "changes": 693, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "patch": "@@ -0,0 +1,693 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Port of LLVM's APFloat software floating-point implementation from the\n+//! following C++ sources (please update commit hash when backporting):\n+//! https://github.com/llvm-mirror/llvm/tree/23efab2bbd424ed13495a420ad8641cb2c6c28f9\n+//! * `include/llvm/ADT/APFloat.h` -> `Float` and `FloatConvert` traits\n+//! * `lib/Support/APFloat.cpp` -> `ieee` and `ppc` modules\n+//! * `unittests/ADT/APFloatTest.cpp` -> `tests` directory\n+//!\n+//! The port contains no unsafe code, global state, or side-effects in general,\n+//! and the only allocations are in the conversion to/from decimal strings.\n+//!\n+//! Most of the API and the testcases are intact in some form or another,\n+//! with some ergonomic changes, such as idiomatic short names, returning\n+//! new values instead of mutating the receiver, and having separate method\n+//! variants that take a non-default rounding mode (with the suffix `_r`).\n+//! Comments have been preserved where possible, only slightly adapted.\n+//!\n+//! Instead of keeping a pointer to a configuration struct and inspecting it\n+//! dynamically on every operation, types (e.g. `ieee::Double`), traits\n+//! (e.g. `ieee::Semantics`) and associated constants are employed for\n+//! increased type safety and performance.\n+//!\n+//! On-heap bigints are replaced everywhere (except in decimal conversion),\n+//! with short arrays of `type Limb = u128` elements (instead of `u64`),\n+//! This allows fitting the largest supported significands in one integer\n+//! (`ieee::Quad` and `ppc::Fallback` use slightly less than 128 bits).\n+//! All of the functions in the `ieee::sig` module operate on slices.\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![crate_name = \"rustc_apfloat\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![deny(warnings)]\n+#![forbid(unsafe_code)]\n+\n+#![feature(const_fn)]\n+#![feature(i128_type)]\n+#![feature(slice_patterns)]\n+#![feature(try_from)]\n+\n+#[macro_use]\n+extern crate rustc_bitflags;\n+\n+use std::cmp::Ordering;\n+use std::fmt;\n+use std::ops::{Neg, Add, Sub, Mul, Div, Rem};\n+use std::ops::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign, BitOrAssign};\n+use std::str::FromStr;\n+\n+bitflags! {\n+    /// IEEE-754R 7: Default exception handling.\n+    ///\n+    /// UNDERFLOW or OVERFLOW are always returned or-ed with INEXACT.\n+    #[must_use]\n+    #[derive(Debug)]\n+    flags Status: u8 {\n+        const OK = 0x00,\n+        const INVALID_OP = 0x01,\n+        const DIV_BY_ZERO = 0x02,\n+        const OVERFLOW = 0x04,\n+        const UNDERFLOW = 0x08,\n+        const INEXACT = 0x10\n+    }\n+}\n+\n+impl BitOrAssign for Status {\n+    fn bitor_assign(&mut self, rhs: Self) {\n+        *self = *self | rhs;\n+    }\n+}\n+\n+#[must_use]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n+pub struct StatusAnd<T> {\n+    pub status: Status,\n+    pub value: T,\n+}\n+\n+impl Status {\n+    pub fn and<T>(self, value: T) -> StatusAnd<T> {\n+        StatusAnd {\n+            status: self,\n+            value,\n+        }\n+    }\n+}\n+\n+impl<T> StatusAnd<T> {\n+    fn map<F: FnOnce(T) -> U, U>(self, f: F) -> StatusAnd<U> {\n+        StatusAnd {\n+            status: self.status,\n+            value: f(self.value),\n+        }\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! unpack {\n+    ($status:ident|=, $e:expr) => {\n+        match $e {\n+            $crate::StatusAnd { status, value } => {\n+                $status |= status;\n+                value\n+            }\n+        }\n+    };\n+    ($status:ident=, $e:expr) => {\n+        match $e {\n+            $crate::StatusAnd { status, value } => {\n+                $status = status;\n+                value\n+            }\n+        }\n+    }\n+}\n+\n+/// Category of internally-represented number.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum Category {\n+    Infinity,\n+    NaN,\n+    Normal,\n+    Zero,\n+}\n+\n+/// IEEE-754R 4.3: Rounding-direction attributes.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum Round {\n+    NearestTiesToEven,\n+    TowardPositive,\n+    TowardNegative,\n+    TowardZero,\n+    NearestTiesToAway,\n+}\n+\n+impl Neg for Round {\n+    type Output = Round;\n+    fn neg(self) -> Round {\n+        match self {\n+            Round::TowardPositive => Round::TowardNegative,\n+            Round::TowardNegative => Round::TowardPositive,\n+            Round::NearestTiesToEven | Round::TowardZero | Round::NearestTiesToAway => self,\n+        }\n+    }\n+}\n+\n+/// A signed type to represent a floating point number's unbiased exponent.\n+pub type ExpInt = i16;\n+\n+// \\c ilogb error results.\n+pub const IEK_INF: ExpInt = ExpInt::max_value();\n+pub const IEK_NAN: ExpInt = ExpInt::min_value();\n+pub const IEK_ZERO: ExpInt = ExpInt::min_value() + 1;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct ParseError(pub &'static str);\n+\n+/// A self-contained host- and target-independent arbitrary-precision\n+/// floating-point software implementation.\n+///\n+/// `apfloat` uses significand bignum integer arithmetic as provided by functions\n+/// in the `ieee::sig`.\n+///\n+/// Written for clarity rather than speed, in particular with a view to use in\n+/// the front-end of a cross compiler so that target arithmetic can be correctly\n+/// performed on the host. Performance should nonetheless be reasonable,\n+/// particularly for its intended use. It may be useful as a base\n+/// implementation for a run-time library during development of a faster\n+/// target-specific one.\n+///\n+/// All 5 rounding modes in the IEEE-754R draft are handled correctly for all\n+/// implemented operations. Currently implemented operations are add, subtract,\n+/// multiply, divide, fused-multiply-add, conversion-to-float,\n+/// conversion-to-integer and conversion-from-integer. New rounding modes\n+/// (e.g. away from zero) can be added with three or four lines of code.\n+///\n+/// Four formats are built-in: IEEE single precision, double precision,\n+/// quadruple precision, and x87 80-bit extended double (when operating with\n+/// full extended precision). Adding a new format that obeys IEEE semantics\n+/// only requires adding two lines of code: a declaration and definition of the\n+/// format.\n+///\n+/// All operations return the status of that operation as an exception bit-mask,\n+/// so multiple operations can be done consecutively with their results or-ed\n+/// together. The returned status can be useful for compiler diagnostics; e.g.,\n+/// inexact, underflow and overflow can be easily diagnosed on constant folding,\n+/// and compiler optimizers can determine what exceptions would be raised by\n+/// folding operations and optimize, or perhaps not optimize, accordingly.\n+///\n+/// At present, underflow tininess is detected after rounding; it should be\n+/// straight forward to add support for the before-rounding case too.\n+///\n+/// The library reads hexadecimal floating point numbers as per C99, and\n+/// correctly rounds if necessary according to the specified rounding mode.\n+/// Syntax is required to have been validated by the caller.\n+///\n+/// It also reads decimal floating point numbers and correctly rounds according\n+/// to the specified rounding mode.\n+///\n+/// Non-zero finite numbers are represented internally as a sign bit, a 16-bit\n+/// signed exponent, and the significand as an array of integer limbs. After\n+/// normalization of a number of precision P the exponent is within the range of\n+/// the format, and if the number is not denormal the P-th bit of the\n+/// significand is set as an explicit integer bit. For denormals the most\n+/// significant bit is shifted right so that the exponent is maintained at the\n+/// format's minimum, so that the smallest denormal has just the least\n+/// significant bit of the significand set. The sign of zeros and infinities\n+/// is significant; the exponent and significand of such numbers is not stored,\n+/// but has a known implicit (deterministic) value: 0 for the significands, 0\n+/// for zero exponent, all 1 bits for infinity exponent. For NaNs the sign and\n+/// significand are deterministic, although not really meaningful, and preserved\n+/// in non-conversion operations. The exponent is implicitly all 1 bits.\n+///\n+/// `apfloat` does not provide any exception handling beyond default exception\n+/// handling. We represent Signaling NaNs via IEEE-754R 2008 6.2.1 should clause\n+/// by encoding Signaling NaNs with the first bit of its trailing significand as\n+/// 0.\n+///\n+/// Future work\n+/// ===========\n+///\n+/// Some features that may or may not be worth adding:\n+///\n+/// Optional ability to detect underflow tininess before rounding.\n+///\n+/// New formats: x87 in single and double precision mode (IEEE apart from\n+/// extended exponent range) (hard).\n+///\n+/// New operations: sqrt, nexttoward.\n+///\n+pub trait Float\n+    : Copy\n+    + Default\n+    + FromStr<Err = ParseError>\n+    + PartialOrd\n+    + fmt::Display\n+    + Neg<Output = Self>\n+    + AddAssign\n+    + SubAssign\n+    + MulAssign\n+    + DivAssign\n+    + RemAssign\n+    + Add<Output = StatusAnd<Self>>\n+    + Sub<Output = StatusAnd<Self>>\n+    + Mul<Output = StatusAnd<Self>>\n+    + Div<Output = StatusAnd<Self>>\n+    + Rem<Output = StatusAnd<Self>> {\n+    /// Total number of bits in the in-memory format.\n+    const BITS: usize;\n+\n+    /// Number of bits in the significand. This includes the integer bit.\n+    const PRECISION: usize;\n+\n+    /// The largest E such that 2^E is representable; this matches the\n+    /// definition of IEEE 754.\n+    const MAX_EXP: ExpInt;\n+\n+    /// The smallest E such that 2^E is a normalized number; this\n+    /// matches the definition of IEEE 754.\n+    const MIN_EXP: ExpInt;\n+\n+    /// Positive Zero.\n+    const ZERO: Self;\n+\n+    /// Positive Infinity.\n+    const INFINITY: Self;\n+\n+    /// NaN (Not a Number).\n+    // FIXME(eddyb) provide a default when qnan becomes const fn.\n+    const NAN: Self;\n+\n+    /// Factory for QNaN values.\n+    // FIXME(eddyb) should be const fn.\n+    fn qnan(payload: Option<u128>) -> Self;\n+\n+    /// Factory for SNaN values.\n+    // FIXME(eddyb) should be const fn.\n+    fn snan(payload: Option<u128>) -> Self;\n+\n+    /// Largest finite number.\n+    // FIXME(eddyb) should be const (but FloatPair::largest is nontrivial).\n+    fn largest() -> Self;\n+\n+    /// Smallest (by magnitude) finite number.\n+    /// Might be denormalized, which implies a relative loss of precision.\n+    const SMALLEST: Self;\n+\n+    /// Smallest (by magnitude) normalized finite number.\n+    // FIXME(eddyb) should be const (but FloatPair::smallest_normalized is nontrivial).\n+    fn smallest_normalized() -> Self;\n+\n+    // Arithmetic\n+\n+    fn add_r(self, rhs: Self, round: Round) -> StatusAnd<Self>;\n+    fn sub_r(self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        self.add_r(-rhs, round)\n+    }\n+    fn mul_r(self, rhs: Self, round: Round) -> StatusAnd<Self>;\n+    fn mul_add_r(self, multiplicand: Self, addend: Self, round: Round) -> StatusAnd<Self>;\n+    fn mul_add(self, multiplicand: Self, addend: Self) -> StatusAnd<Self> {\n+        self.mul_add_r(multiplicand, addend, Round::NearestTiesToEven)\n+    }\n+    fn div_r(self, rhs: Self, round: Round) -> StatusAnd<Self>;\n+    /// IEEE remainder.\n+    // This is not currently correct in all cases.\n+    fn ieee_rem(self, rhs: Self) -> StatusAnd<Self> {\n+        let mut v = self;\n+\n+        let status;\n+        v = unpack!(status=, v / rhs);\n+        if status == Status::DIV_BY_ZERO {\n+            return status.and(self);\n+        }\n+\n+        assert!(Self::PRECISION < 128);\n+\n+        let status;\n+        let x = unpack!(status=, v.to_i128_r(128, Round::NearestTiesToEven, &mut false));\n+        if status == Status::INVALID_OP {\n+            return status.and(self);\n+        }\n+\n+        let status;\n+        let mut v = unpack!(status=, Self::from_i128(x));\n+        assert_eq!(status, Status::OK); // should always work\n+\n+        let status;\n+        v = unpack!(status=, v * rhs);\n+        assert_eq!(status - Status::INEXACT, Status::OK); // should not overflow or underflow\n+\n+        let status;\n+        v = unpack!(status=, self - v);\n+        assert_eq!(status - Status::INEXACT, Status::OK); // likewise\n+\n+        if v.is_zero() {\n+            status.and(v.copy_sign(self)) // IEEE754 requires this\n+        } else {\n+            status.and(v)\n+        }\n+    }\n+    /// C fmod, or llvm frem.\n+    fn c_fmod(self, rhs: Self) -> StatusAnd<Self>;\n+    fn round_to_integral(self, round: Round) -> StatusAnd<Self>;\n+\n+    /// IEEE-754R 2008 5.3.1: nextUp.\n+    fn next_up(self) -> StatusAnd<Self>;\n+\n+    /// IEEE-754R 2008 5.3.1: nextDown.\n+    ///\n+    /// *NOTE* since nextDown(x) = -nextUp(-x), we only implement nextUp with\n+    /// appropriate sign switching before/after the computation.\n+    fn next_down(self) -> StatusAnd<Self> {\n+        (-self).next_up().map(|r| -r)\n+    }\n+\n+    fn abs(self) -> Self {\n+        if self.is_negative() { -self } else { self }\n+    }\n+    fn copy_sign(self, rhs: Self) -> Self {\n+        if self.is_negative() != rhs.is_negative() {\n+            -self\n+        } else {\n+            self\n+        }\n+    }\n+\n+    // Conversions\n+    fn from_bits(input: u128) -> Self;\n+    fn from_i128_r(input: i128, round: Round) -> StatusAnd<Self> {\n+        if input < 0 {\n+            Self::from_u128_r(-input as u128, -round).map(|r| -r)\n+        } else {\n+            Self::from_u128_r(input as u128, round)\n+        }\n+    }\n+    fn from_i128(input: i128) -> StatusAnd<Self> {\n+        Self::from_i128_r(input, Round::NearestTiesToEven)\n+    }\n+    fn from_u128_r(input: u128, round: Round) -> StatusAnd<Self>;\n+    fn from_u128(input: u128) -> StatusAnd<Self> {\n+        Self::from_u128_r(input, Round::NearestTiesToEven)\n+    }\n+    fn from_str_r(s: &str, round: Round) -> Result<StatusAnd<Self>, ParseError>;\n+    fn to_bits(self) -> u128;\n+\n+    /// Convert a floating point number to an integer according to the\n+    /// rounding mode. In case of an invalid operation exception,\n+    /// deterministic values are returned, namely zero for NaNs and the\n+    /// minimal or maximal value respectively for underflow or overflow.\n+    /// If the rounded value is in range but the floating point number is\n+    /// not the exact integer, the C standard doesn't require an inexact\n+    /// exception to be raised. IEEE-854 does require it so we do that.\n+    ///\n+    /// Note that for conversions to integer type the C standard requires\n+    /// round-to-zero to always be used.\n+    ///\n+    /// The *is_exact output tells whether the result is exact, in the sense\n+    /// that converting it back to the original floating point type produces\n+    /// the original value. This is almost equivalent to result==Status::OK,\n+    /// except for negative zeroes.\n+    fn to_i128_r(self, width: usize, round: Round, is_exact: &mut bool) -> StatusAnd<i128> {\n+        let status;\n+        if self.is_negative() {\n+            if self.is_zero() {\n+                // Negative zero can't be represented as an int.\n+                *is_exact = false;\n+            }\n+            let r = unpack!(status=, (-self).to_u128_r(width, -round, is_exact));\n+\n+            // Check for values that don't fit in the signed integer.\n+            if r > (1 << (width - 1)) {\n+                // Return the most negative integer for the given width.\n+                *is_exact = false;\n+                Status::INVALID_OP.and(-1 << (width - 1))\n+            } else {\n+                status.and(r.wrapping_neg() as i128)\n+            }\n+        } else {\n+            // Positive case is simpler, can pretend it's a smaller unsigned\n+            // integer, and `to_u128` will take care of all the edge cases.\n+            self.to_u128_r(width - 1, round, is_exact).map(\n+                |r| r as i128,\n+            )\n+        }\n+    }\n+    fn to_i128(self, width: usize) -> StatusAnd<i128> {\n+        self.to_i128_r(width, Round::TowardZero, &mut true)\n+    }\n+    fn to_u128_r(self, width: usize, round: Round, is_exact: &mut bool) -> StatusAnd<u128>;\n+    fn to_u128(self, width: usize) -> StatusAnd<u128> {\n+        self.to_u128_r(width, Round::TowardZero, &mut true)\n+    }\n+\n+    fn cmp_abs_normal(self, rhs: Self) -> Ordering;\n+\n+    /// Bitwise comparison for equality (QNaNs compare equal, 0!=-0).\n+    fn bitwise_eq(self, rhs: Self) -> bool;\n+\n+    // IEEE-754R 5.7.2 General operations.\n+\n+    /// Implements IEEE minNum semantics. Returns the smaller of the 2 arguments if\n+    /// both are not NaN. If either argument is a NaN, returns the other argument.\n+    fn min(self, other: Self) -> Self {\n+        if self.is_nan() {\n+            other\n+        } else if other.is_nan() {\n+            self\n+        } else if other.partial_cmp(&self) == Some(Ordering::Less) {\n+            other\n+        } else {\n+            self\n+        }\n+    }\n+\n+    /// Implements IEEE maxNum semantics. Returns the larger of the 2 arguments if\n+    /// both are not NaN. If either argument is a NaN, returns the other argument.\n+    fn max(self, other: Self) -> Self {\n+        if self.is_nan() {\n+            other\n+        } else if other.is_nan() {\n+            self\n+        } else if self.partial_cmp(&other) == Some(Ordering::Less) {\n+            other\n+        } else {\n+            self\n+        }\n+    }\n+\n+    /// IEEE-754R isSignMinus: Returns true if and only if the current value is\n+    /// negative.\n+    ///\n+    /// This applies to zeros and NaNs as well.\n+    fn is_negative(self) -> bool;\n+\n+    /// IEEE-754R isNormal: Returns true if and only if the current value is normal.\n+    ///\n+    /// This implies that the current value of the float is not zero, subnormal,\n+    /// infinite, or NaN following the definition of normality from IEEE-754R.\n+    fn is_normal(self) -> bool {\n+        !self.is_denormal() && self.is_finite_non_zero()\n+    }\n+\n+    /// Returns true if and only if the current value is zero, subnormal, or\n+    /// normal.\n+    ///\n+    /// This means that the value is not infinite or NaN.\n+    fn is_finite(self) -> bool {\n+        !self.is_nan() && !self.is_infinite()\n+    }\n+\n+    /// Returns true if and only if the float is plus or minus zero.\n+    fn is_zero(self) -> bool {\n+        self.category() == Category::Zero\n+    }\n+\n+    /// IEEE-754R isSubnormal(): Returns true if and only if the float is a\n+    /// denormal.\n+    fn is_denormal(self) -> bool;\n+\n+    /// IEEE-754R isInfinite(): Returns true if and only if the float is infinity.\n+    fn is_infinite(self) -> bool {\n+        self.category() == Category::Infinity\n+    }\n+\n+    /// Returns true if and only if the float is a quiet or signaling NaN.\n+    fn is_nan(self) -> bool {\n+        self.category() == Category::NaN\n+    }\n+\n+    /// Returns true if and only if the float is a signaling NaN.\n+    fn is_signaling(self) -> bool;\n+\n+    // Simple Queries\n+\n+    fn category(self) -> Category;\n+    fn is_non_zero(self) -> bool {\n+        !self.is_zero()\n+    }\n+    fn is_finite_non_zero(self) -> bool {\n+        self.is_finite() && !self.is_zero()\n+    }\n+    fn is_pos_zero(self) -> bool {\n+        self.is_zero() && !self.is_negative()\n+    }\n+    fn is_neg_zero(self) -> bool {\n+        self.is_zero() && self.is_negative()\n+    }\n+\n+    /// Returns true if and only if the number has the smallest possible non-zero\n+    /// magnitude in the current semantics.\n+    fn is_smallest(self) -> bool {\n+        Self::SMALLEST.copy_sign(self).bitwise_eq(self)\n+    }\n+\n+    /// Returns true if and only if the number has the largest possible finite\n+    /// magnitude in the current semantics.\n+    fn is_largest(self) -> bool {\n+        Self::largest().copy_sign(self).bitwise_eq(self)\n+    }\n+\n+    /// Returns true if and only if the number is an exact integer.\n+    fn is_integer(self) -> bool {\n+        // This could be made more efficient; I'm going for obviously correct.\n+        if !self.is_finite() {\n+            return false;\n+        }\n+        self.round_to_integral(Round::TowardZero).value.bitwise_eq(\n+            self,\n+        )\n+    }\n+\n+    /// If this value has an exact multiplicative inverse, return it.\n+    fn get_exact_inverse(self) -> Option<Self>;\n+\n+    /// Returns the exponent of the internal representation of the Float.\n+    ///\n+    /// Because the radix of Float is 2, this is equivalent to floor(log2(x)).\n+    /// For special Float values, this returns special error codes:\n+    ///\n+    ///   NaN -> \\c IEK_NAN\n+    ///   0   -> \\c IEK_ZERO\n+    ///   Inf -> \\c IEK_INF\n+    ///\n+    fn ilogb(self) -> ExpInt;\n+\n+    /// Returns: self * 2^exp for integral exponents.\n+    fn scalbn_r(self, exp: ExpInt, round: Round) -> Self;\n+    fn scalbn(self, exp: ExpInt) -> Self {\n+        self.scalbn_r(exp, Round::NearestTiesToEven)\n+    }\n+\n+    /// Equivalent of C standard library function.\n+    ///\n+    /// While the C standard says exp is an unspecified value for infinity and nan,\n+    /// this returns INT_MAX for infinities, and INT_MIN for NaNs (see `ilogb`).\n+    fn frexp_r(self, exp: &mut ExpInt, round: Round) -> Self;\n+    fn frexp(self, exp: &mut ExpInt) -> Self {\n+        self.frexp_r(exp, Round::NearestTiesToEven)\n+    }\n+}\n+\n+pub trait FloatConvert<T: Float>: Float {\n+    /// Convert a value of one floating point type to another.\n+    /// The return value corresponds to the IEEE754 exceptions. *loses_info\n+    /// records whether the transformation lost information, i.e. whether\n+    /// converting the result back to the original type will produce the\n+    /// original value (this is almost the same as return value==Status::OK,\n+    /// but there are edge cases where this is not so).\n+    fn convert_r(self, round: Round, loses_info: &mut bool) -> StatusAnd<T>;\n+    fn convert(self, loses_info: &mut bool) -> StatusAnd<T> {\n+        self.convert_r(Round::NearestTiesToEven, loses_info)\n+    }\n+}\n+\n+macro_rules! float_common_impls {\n+    ($ty:ident<$t:tt>) => {\n+        impl<$t> Default for $ty<$t> where Self: Float {\n+            fn default() -> Self {\n+                Self::ZERO\n+            }\n+        }\n+\n+        impl<$t> ::std::str::FromStr for $ty<$t> where Self: Float {\n+            type Err = ParseError;\n+            fn from_str(s: &str) -> Result<Self, ParseError> {\n+                Self::from_str_r(s, Round::NearestTiesToEven).map(|x| x.value)\n+            }\n+        }\n+\n+        // Rounding ties to the nearest even, by default.\n+\n+        impl<$t> ::std::ops::Add for $ty<$t> where Self: Float {\n+            type Output = StatusAnd<Self>;\n+            fn add(self, rhs: Self) -> StatusAnd<Self> {\n+                self.add_r(rhs, Round::NearestTiesToEven)\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::Sub for $ty<$t> where Self: Float {\n+            type Output = StatusAnd<Self>;\n+            fn sub(self, rhs: Self) -> StatusAnd<Self> {\n+                self.sub_r(rhs, Round::NearestTiesToEven)\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::Mul for $ty<$t> where Self: Float {\n+            type Output = StatusAnd<Self>;\n+            fn mul(self, rhs: Self) -> StatusAnd<Self> {\n+                self.mul_r(rhs, Round::NearestTiesToEven)\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::Div for $ty<$t> where Self: Float {\n+            type Output = StatusAnd<Self>;\n+            fn div(self, rhs: Self) -> StatusAnd<Self> {\n+                self.div_r(rhs, Round::NearestTiesToEven)\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::Rem for $ty<$t> where Self: Float {\n+            type Output = StatusAnd<Self>;\n+            fn rem(self, rhs: Self) -> StatusAnd<Self> {\n+                self.c_fmod(rhs)\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::AddAssign for $ty<$t> where Self: Float {\n+            fn add_assign(&mut self, rhs: Self) {\n+                *self = (*self + rhs).value;\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::SubAssign for $ty<$t> where Self: Float {\n+            fn sub_assign(&mut self, rhs: Self) {\n+                *self = (*self - rhs).value;\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::MulAssign for $ty<$t> where Self: Float {\n+            fn mul_assign(&mut self, rhs: Self) {\n+                *self = (*self * rhs).value;\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::DivAssign for $ty<$t> where Self: Float {\n+            fn div_assign(&mut self, rhs: Self) {\n+                *self = (*self / rhs).value;\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::RemAssign for $ty<$t> where Self: Float {\n+            fn rem_assign(&mut self, rhs: Self) {\n+                *self = (*self % rhs).value;\n+            }\n+        }\n+    }\n+}\n+\n+pub mod ieee;\n+pub mod ppc;"}, {"sha": "dec88eb62cc60ef94eecf6a5517544c35951dd08", "filename": "src/librustc_apfloat/ppc.rs", "status": "added", "additions": 461, "deletions": 0, "changes": 461, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_apfloat%2Fppc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_apfloat%2Fppc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fppc.rs?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "patch": "@@ -0,0 +1,461 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use {Category, ExpInt, Float, FloatConvert, Round, ParseError, Status, StatusAnd};\n+use ieee;\n+\n+use std::cmp::Ordering;\n+use std::fmt;\n+use std::ops::Neg;\n+\n+#[must_use]\n+#[derive(Copy, Clone, PartialEq, PartialOrd, Debug)]\n+pub struct DoubleFloat<F>(F, F);\n+pub type DoubleDouble = DoubleFloat<ieee::Double>;\n+\n+// These are legacy semantics for the Fallback, inaccrurate implementation of\n+// IBM double-double, if the accurate DoubleDouble doesn't handle the\n+// operation. It's equivalent to having an IEEE number with consecutive 106\n+// bits of mantissa and 11 bits of exponent.\n+//\n+// It's not equivalent to IBM double-double. For example, a legit IBM\n+// double-double, 1 + epsilon:\n+//\n+//   1 + epsilon = 1 + (1 >> 1076)\n+//\n+// is not representable by a consecutive 106 bits of mantissa.\n+//\n+// Currently, these semantics are used in the following way:\n+//\n+//   DoubleDouble -> (Double, Double) ->\n+//   DoubleDouble's Fallback -> IEEE operations\n+//\n+// FIXME: Implement all operations in DoubleDouble, and delete these\n+// semantics.\n+// FIXME(eddyb) This shouldn't need to be `pub`, it's only used in bounds.\n+pub struct FallbackS<F>(F);\n+type Fallback<F> = ieee::IeeeFloat<FallbackS<F>>;\n+impl<F: Float> ieee::Semantics for FallbackS<F> {\n+    // Forbid any conversion to/from bits.\n+    const BITS: usize = 0;\n+    const PRECISION: usize = F::PRECISION * 2;\n+    const MAX_EXP: ExpInt = F::MAX_EXP as ExpInt;\n+    const MIN_EXP: ExpInt = F::MIN_EXP as ExpInt + F::PRECISION as ExpInt;\n+}\n+\n+// Convert number to F. To avoid spurious underflows, we re-\n+// normalize against the F exponent range first, and only *then*\n+// truncate the mantissa. The result of that second conversion\n+// may be inexact, but should never underflow.\n+// FIXME(eddyb) This shouldn't need to be `pub`, it's only used in bounds.\n+pub struct FallbackExtendedS<F>(F);\n+type FallbackExtended<F> = ieee::IeeeFloat<FallbackExtendedS<F>>;\n+impl<F: Float> ieee::Semantics for FallbackExtendedS<F> {\n+    // Forbid any conversion to/from bits.\n+    const BITS: usize = 0;\n+    const PRECISION: usize = Fallback::<F>::PRECISION;\n+    const MAX_EXP: ExpInt = F::MAX_EXP as ExpInt;\n+}\n+\n+impl<F: Float> From<Fallback<F>> for DoubleFloat<F>\n+where\n+    F: FloatConvert<FallbackExtended<F>>,\n+    FallbackExtended<F>: FloatConvert<F>,\n+{\n+    fn from(x: Fallback<F>) -> Self {\n+        let mut status;\n+        let mut loses_info = false;\n+\n+        let extended: FallbackExtended<F> = unpack!(status=, x.convert(&mut loses_info));\n+        assert_eq!((status, loses_info), (Status::OK, false));\n+\n+        let a = unpack!(status=, extended.convert(&mut loses_info));\n+        assert_eq!(status - Status::INEXACT, Status::OK);\n+\n+        // If conversion was exact or resulted in a special case, we're done;\n+        // just set the second double to zero. Otherwise, re-convert back to\n+        // the extended format and compute the difference. This now should\n+        // convert exactly to double.\n+        let b = if a.is_finite_non_zero() && loses_info {\n+            let u: FallbackExtended<F> = unpack!(status=, a.convert(&mut loses_info));\n+            assert_eq!((status, loses_info), (Status::OK, false));\n+            let v = unpack!(status=, extended - u);\n+            assert_eq!(status, Status::OK);\n+            let v = unpack!(status=, v.convert(&mut loses_info));\n+            assert_eq!((status, loses_info), (Status::OK, false));\n+            v\n+        } else {\n+            F::ZERO\n+        };\n+\n+        DoubleFloat(a, b)\n+    }\n+}\n+\n+impl<F: FloatConvert<Self>> From<DoubleFloat<F>> for Fallback<F> {\n+    fn from(DoubleFloat(a, b): DoubleFloat<F>) -> Self {\n+        let mut status;\n+        let mut loses_info = false;\n+\n+        // Get the first F and convert to our format.\n+        let a = unpack!(status=, a.convert(&mut loses_info));\n+        assert_eq!((status, loses_info), (Status::OK, false));\n+\n+        // Unless we have a special case, add in second F.\n+        if a.is_finite_non_zero() {\n+            let b = unpack!(status=, b.convert(&mut loses_info));\n+            assert_eq!((status, loses_info), (Status::OK, false));\n+\n+            (a + b).value\n+        } else {\n+            a\n+        }\n+    }\n+}\n+\n+float_common_impls!(DoubleFloat<F>);\n+\n+impl<F: Float> Neg for DoubleFloat<F> {\n+    type Output = Self;\n+    fn neg(self) -> Self {\n+        if self.1.is_finite_non_zero() {\n+            DoubleFloat(-self.0, -self.1)\n+        } else {\n+            DoubleFloat(-self.0, self.1)\n+        }\n+    }\n+}\n+\n+impl<F: FloatConvert<Fallback<F>>> fmt::Display for DoubleFloat<F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&Fallback::from(*self), f)\n+    }\n+}\n+\n+impl<F: FloatConvert<Fallback<F>>> Float for DoubleFloat<F>\n+where\n+    Self: From<Fallback<F>>,\n+{\n+    const BITS: usize = F::BITS * 2;\n+    const PRECISION: usize = Fallback::<F>::PRECISION;\n+    const MAX_EXP: ExpInt = Fallback::<F>::MAX_EXP;\n+    const MIN_EXP: ExpInt = Fallback::<F>::MIN_EXP;\n+\n+    const ZERO: Self = DoubleFloat(F::ZERO, F::ZERO);\n+\n+    const INFINITY: Self = DoubleFloat(F::INFINITY, F::ZERO);\n+\n+    // FIXME(eddyb) remove when qnan becomes const fn.\n+    const NAN: Self = DoubleFloat(F::NAN, F::ZERO);\n+\n+    fn qnan(payload: Option<u128>) -> Self {\n+        DoubleFloat(F::qnan(payload), F::ZERO)\n+    }\n+\n+    fn snan(payload: Option<u128>) -> Self {\n+        DoubleFloat(F::snan(payload), F::ZERO)\n+    }\n+\n+    fn largest() -> Self {\n+        let status;\n+        let mut r = DoubleFloat(F::largest(), F::largest());\n+        r.1 = r.1.scalbn(-(F::PRECISION as ExpInt + 1));\n+        r.1 = unpack!(status=, r.1.next_down());\n+        assert_eq!(status, Status::OK);\n+        r\n+    }\n+\n+    const SMALLEST: Self = DoubleFloat(F::SMALLEST, F::ZERO);\n+\n+    fn smallest_normalized() -> Self {\n+        DoubleFloat(\n+            F::smallest_normalized().scalbn(F::PRECISION as ExpInt),\n+            F::ZERO,\n+        )\n+    }\n+\n+    // Implement addition, subtraction, multiplication and division based on:\n+    // \"Software for Doubled-Precision Floating-Point Computations\",\n+    // by Seppo Linnainmaa, ACM TOMS vol 7 no 3, September 1981, pages 272-283.\n+\n+    fn add_r(mut self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        match (self.category(), rhs.category()) {\n+            (Category::Infinity, Category::Infinity) => {\n+                if self.is_negative() != rhs.is_negative() {\n+                    Status::INVALID_OP.and(Self::NAN.copy_sign(self))\n+                } else {\n+                    Status::OK.and(self)\n+                }\n+            }\n+\n+            (_, Category::Zero) |\n+            (Category::NaN, _) |\n+            (Category::Infinity, Category::Normal) => Status::OK.and(self),\n+\n+            (Category::Zero, _) |\n+            (_, Category::NaN) |\n+            (_, Category::Infinity) => Status::OK.and(rhs),\n+\n+            (Category::Normal, Category::Normal) => {\n+                let mut status = Status::OK;\n+                let (a, aa, c, cc) = (self.0, self.1, rhs.0, rhs.1);\n+                let mut z = a;\n+                z = unpack!(status|=, z.add_r(c, round));\n+                if !z.is_finite() {\n+                    if !z.is_infinite() {\n+                        return status.and(DoubleFloat(z, F::ZERO));\n+                    }\n+                    status = Status::OK;\n+                    let a_cmp_c = a.cmp_abs_normal(c);\n+                    z = cc;\n+                    z = unpack!(status|=, z.add_r(aa, round));\n+                    if a_cmp_c == Ordering::Greater {\n+                        // z = cc + aa + c + a;\n+                        z = unpack!(status|=, z.add_r(c, round));\n+                        z = unpack!(status|=, z.add_r(a, round));\n+                    } else {\n+                        // z = cc + aa + a + c;\n+                        z = unpack!(status|=, z.add_r(a, round));\n+                        z = unpack!(status|=, z.add_r(c, round));\n+                    }\n+                    if !z.is_finite() {\n+                        return status.and(DoubleFloat(z, F::ZERO));\n+                    }\n+                    self.0 = z;\n+                    let mut zz = aa;\n+                    zz = unpack!(status|=, zz.add_r(cc, round));\n+                    if a_cmp_c == Ordering::Greater {\n+                        // self.1 = a - z + c + zz;\n+                        self.1 = a;\n+                        self.1 = unpack!(status|=, self.1.sub_r(z, round));\n+                        self.1 = unpack!(status|=, self.1.add_r(c, round));\n+                        self.1 = unpack!(status|=, self.1.add_r(zz, round));\n+                    } else {\n+                        // self.1 = c - z + a + zz;\n+                        self.1 = c;\n+                        self.1 = unpack!(status|=, self.1.sub_r(z, round));\n+                        self.1 = unpack!(status|=, self.1.add_r(a, round));\n+                        self.1 = unpack!(status|=, self.1.add_r(zz, round));\n+                    }\n+                } else {\n+                    // q = a - z;\n+                    let mut q = a;\n+                    q = unpack!(status|=, q.sub_r(z, round));\n+\n+                    // zz = q + c + (a - (q + z)) + aa + cc;\n+                    // Compute a - (q + z) as -((q + z) - a) to avoid temporary copies.\n+                    let mut zz = q;\n+                    zz = unpack!(status|=, zz.add_r(c, round));\n+                    q = unpack!(status|=, q.add_r(z, round));\n+                    q = unpack!(status|=, q.sub_r(a, round));\n+                    q = -q;\n+                    zz = unpack!(status|=, zz.add_r(q, round));\n+                    zz = unpack!(status|=, zz.add_r(aa, round));\n+                    zz = unpack!(status|=, zz.add_r(cc, round));\n+                    if zz.is_zero() && !zz.is_negative() {\n+                        return Status::OK.and(DoubleFloat(z, F::ZERO));\n+                    }\n+                    self.0 = z;\n+                    self.0 = unpack!(status|=, self.0.add_r(zz, round));\n+                    if !self.0.is_finite() {\n+                        self.1 = F::ZERO;\n+                        return status.and(self);\n+                    }\n+                    self.1 = z;\n+                    self.1 = unpack!(status|=, self.1.sub_r(self.0, round));\n+                    self.1 = unpack!(status|=, self.1.add_r(zz, round));\n+                }\n+                status.and(self)\n+            }\n+        }\n+    }\n+\n+    fn mul_r(mut self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        // Interesting observation: For special categories, finding the lowest\n+        // common ancestor of the following layered graph gives the correct\n+        // return category:\n+        //\n+        //    NaN\n+        //   /   \\\n+        // Zero  Inf\n+        //   \\   /\n+        //   Normal\n+        //\n+        // e.g. NaN * NaN = NaN\n+        //      Zero * Inf = NaN\n+        //      Normal * Zero = Zero\n+        //      Normal * Inf = Inf\n+        match (self.category(), rhs.category()) {\n+            (Category::NaN, _) => Status::OK.and(self),\n+\n+            (_, Category::NaN) => Status::OK.and(rhs),\n+\n+            (Category::Zero, Category::Infinity) |\n+            (Category::Infinity, Category::Zero) => Status::OK.and(Self::NAN),\n+\n+            (Category::Zero, _) |\n+            (Category::Infinity, _) => Status::OK.and(self),\n+\n+            (_, Category::Zero) |\n+            (_, Category::Infinity) => Status::OK.and(rhs),\n+\n+            (Category::Normal, Category::Normal) => {\n+                let mut status = Status::OK;\n+                let (a, b, c, d) = (self.0, self.1, rhs.0, rhs.1);\n+                // t = a * c\n+                let mut t = a;\n+                t = unpack!(status|=, t.mul_r(c, round));\n+                if !t.is_finite_non_zero() {\n+                    return status.and(DoubleFloat(t, F::ZERO));\n+                }\n+\n+                // tau = fmsub(a, c, t), that is -fmadd(-a, c, t).\n+                let mut tau = a;\n+                tau = unpack!(status|=, tau.mul_add_r(c, -t, round));\n+                // v = a * d\n+                let mut v = a;\n+                v = unpack!(status|=, v.mul_r(d, round));\n+                // w = b * c\n+                let mut w = b;\n+                w = unpack!(status|=, w.mul_r(c, round));\n+                v = unpack!(status|=, v.add_r(w, round));\n+                // tau += v + w\n+                tau = unpack!(status|=, tau.add_r(v, round));\n+                // u = t + tau\n+                let mut u = t;\n+                u = unpack!(status|=, u.add_r(tau, round));\n+\n+                self.0 = u;\n+                if !u.is_finite() {\n+                    self.1 = F::ZERO;\n+                } else {\n+                    // self.1 = (t - u) + tau\n+                    t = unpack!(status|=, t.sub_r(u, round));\n+                    t = unpack!(status|=, t.add_r(tau, round));\n+                    self.1 = t;\n+                }\n+                status.and(self)\n+            }\n+        }\n+    }\n+\n+    fn mul_add_r(self, multiplicand: Self, addend: Self, round: Round) -> StatusAnd<Self> {\n+        Fallback::from(self)\n+            .mul_add_r(Fallback::from(multiplicand), Fallback::from(addend), round)\n+            .map(Self::from)\n+    }\n+\n+    fn div_r(self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        Fallback::from(self).div_r(Fallback::from(rhs), round).map(\n+            Self::from,\n+        )\n+    }\n+\n+    fn c_fmod(self, rhs: Self) -> StatusAnd<Self> {\n+        Fallback::from(self).c_fmod(Fallback::from(rhs)).map(\n+            Self::from,\n+        )\n+    }\n+\n+    fn round_to_integral(self, round: Round) -> StatusAnd<Self> {\n+        Fallback::from(self).round_to_integral(round).map(\n+            Self::from,\n+        )\n+    }\n+\n+    fn next_up(self) -> StatusAnd<Self> {\n+        Fallback::from(self).next_up().map(Self::from)\n+    }\n+\n+    fn from_bits(input: u128) -> Self {\n+        let (a, b) = (input, input >> F::BITS);\n+        DoubleFloat(\n+            F::from_bits(a & ((1 << F::BITS) - 1)),\n+            F::from_bits(b & ((1 << F::BITS) - 1)),\n+        )\n+    }\n+\n+    fn from_u128_r(input: u128, round: Round) -> StatusAnd<Self> {\n+        Fallback::from_u128_r(input, round).map(Self::from)\n+    }\n+\n+    fn from_str_r(s: &str, round: Round) -> Result<StatusAnd<Self>, ParseError> {\n+        Fallback::from_str_r(s, round).map(|r| r.map(Self::from))\n+    }\n+\n+    fn to_bits(self) -> u128 {\n+        self.0.to_bits() | (self.1.to_bits() << F::BITS)\n+    }\n+\n+    fn to_u128_r(self, width: usize, round: Round, is_exact: &mut bool) -> StatusAnd<u128> {\n+        Fallback::from(self).to_u128_r(width, round, is_exact)\n+    }\n+\n+    fn cmp_abs_normal(self, rhs: Self) -> Ordering {\n+        self.0.cmp_abs_normal(rhs.0).then_with(|| {\n+            let result = self.1.cmp_abs_normal(rhs.1);\n+            if result != Ordering::Equal {\n+                let against = self.0.is_negative() ^ self.1.is_negative();\n+                let rhs_against = rhs.0.is_negative() ^ rhs.1.is_negative();\n+                (!against).cmp(&!rhs_against).then_with(|| if against {\n+                    result.reverse()\n+                } else {\n+                    result\n+                })\n+            } else {\n+                result\n+            }\n+        })\n+    }\n+\n+    fn bitwise_eq(self, rhs: Self) -> bool {\n+        self.0.bitwise_eq(rhs.0) && self.1.bitwise_eq(rhs.1)\n+    }\n+\n+    fn is_negative(self) -> bool {\n+        self.0.is_negative()\n+    }\n+\n+    fn is_denormal(self) -> bool {\n+        self.category() == Category::Normal &&\n+            (self.0.is_denormal() || self.0.is_denormal() ||\n+          // (double)(Hi + Lo) == Hi defines a normal number.\n+          !(self.0 + self.1).value.bitwise_eq(self.0))\n+    }\n+\n+    fn is_signaling(self) -> bool {\n+        self.0.is_signaling()\n+    }\n+\n+    fn category(self) -> Category {\n+        self.0.category()\n+    }\n+\n+    fn get_exact_inverse(self) -> Option<Self> {\n+        Fallback::from(self).get_exact_inverse().map(Self::from)\n+    }\n+\n+    fn ilogb(self) -> ExpInt {\n+        self.0.ilogb()\n+    }\n+\n+    fn scalbn_r(self, exp: ExpInt, round: Round) -> Self {\n+        DoubleFloat(self.0.scalbn_r(exp, round), self.1.scalbn_r(exp, round))\n+    }\n+\n+    fn frexp_r(self, exp: &mut ExpInt, round: Round) -> Self {\n+        let a = self.0.frexp_r(exp, round);\n+        let mut b = self.1;\n+        if self.category() == Category::Normal {\n+            b = b.scalbn_r(-*exp, round);\n+        }\n+        DoubleFloat(a, b)\n+    }\n+}"}, {"sha": "aff2076e038332ce77104c44fc8e048663627b14", "filename": "src/librustc_apfloat/tests/ieee.rs", "status": "added", "additions": 6891, "deletions": 0, "changes": 6891, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb"}, {"sha": "145c3ddc869dfc17c5307720a56fa6db4cbc07ab", "filename": "src/librustc_apfloat/tests/ppc.rs", "status": "added", "additions": 655, "deletions": 0, "changes": 655, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_apfloat%2Ftests%2Fppc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_apfloat%2Ftests%2Fppc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Ftests%2Fppc.rs?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "patch": "@@ -0,0 +1,655 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate rustc_apfloat;\n+\n+use rustc_apfloat::{Category, Float, Round};\n+use rustc_apfloat::ppc::DoubleDouble;\n+\n+use std::cmp::Ordering;\n+\n+#[test]\n+fn ppc_double_double() {\n+    let test = DoubleDouble::ZERO;\n+    let expected = \"0x0p+0\".parse::<DoubleDouble>().unwrap();\n+    assert!(test.is_zero());\n+    assert!(!test.is_negative());\n+    assert!(test.bitwise_eq(expected));\n+    assert_eq!(0, test.to_bits());\n+\n+    let test = -DoubleDouble::ZERO;\n+    let expected = \"-0x0p+0\".parse::<DoubleDouble>().unwrap();\n+    assert!(test.is_zero());\n+    assert!(test.is_negative());\n+    assert!(test.bitwise_eq(expected));\n+    assert_eq!(0x8000000000000000, test.to_bits());\n+\n+    let test = \"1.0\".parse::<DoubleDouble>().unwrap();\n+    assert_eq!(0x3ff0000000000000, test.to_bits());\n+\n+    // LDBL_MAX\n+    let test = \"1.79769313486231580793728971405301e+308\"\n+        .parse::<DoubleDouble>()\n+        .unwrap();\n+    assert_eq!(0x7c8ffffffffffffe_7fefffffffffffff, test.to_bits());\n+\n+    // LDBL_MIN\n+    let test = \"2.00416836000897277799610805135016e-292\"\n+        .parse::<DoubleDouble>()\n+        .unwrap();\n+    assert_eq!(0x0000000000000000_0360000000000000, test.to_bits());\n+}\n+\n+#[test]\n+fn ppc_double_double_add_special() {\n+    let data = [\n+        // (1 + 0) + (-1 + 0) = Category::Zero\n+        (\n+            0x3ff0000000000000,\n+            0xbff0000000000000,\n+            Category::Zero,\n+            Round::NearestTiesToEven,\n+        ),\n+        // LDBL_MAX + (1.1 >> (1023 - 106) + 0)) = Category::Infinity\n+        (\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            0x7948000000000000,\n+            Category::Infinity,\n+            Round::NearestTiesToEven,\n+        ),\n+        // FIXME: change the 4th 0x75effffffffffffe to 0x75efffffffffffff when\n+        // DoubleDouble's fallback is gone.\n+        // LDBL_MAX + (1.011111... >> (1023 - 106) + (1.1111111...0 >> (1023 -\n+        // 160))) = Category::Normal\n+        (\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            0x75effffffffffffe_7947ffffffffffff,\n+            Category::Normal,\n+            Round::NearestTiesToEven,\n+        ),\n+        // LDBL_MAX + (1.1 >> (1023 - 106) + 0)) = Category::Infinity\n+        (\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            Category::Infinity,\n+            Round::NearestTiesToEven,\n+        ),\n+        // NaN + (1 + 0) = Category::NaN\n+        (\n+            0x7ff8000000000000,\n+            0x3ff0000000000000,\n+            Category::NaN,\n+            Round::NearestTiesToEven,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected, round) in &data {\n+        {\n+            let mut a1 = DoubleDouble::from_bits(op1);\n+            let a2 = DoubleDouble::from_bits(op2);\n+            a1 = a1.add_r(a2, round).value;\n+\n+            assert_eq!(expected, a1.category(), \"{:#x} + {:#x}\", op1, op2);\n+        }\n+        {\n+            let a1 = DoubleDouble::from_bits(op1);\n+            let mut a2 = DoubleDouble::from_bits(op2);\n+            a2 = a2.add_r(a1, round).value;\n+\n+            assert_eq!(expected, a2.category(), \"{:#x} + {:#x}\", op2, op1);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_add() {\n+    let data = [\n+        // (1 + 0) + (1e-105 + 0) = (1 + 1e-105)\n+        (\n+            0x3ff0000000000000,\n+            0x3960000000000000,\n+            0x3960000000000000_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (1 + 0) + (1e-106 + 0) = (1 + 1e-106)\n+        (\n+            0x3ff0000000000000,\n+            0x3950000000000000,\n+            0x3950000000000000_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (1 + 1e-106) + (1e-106 + 0) = (1 + 1e-105)\n+        (\n+            0x3950000000000000_3ff0000000000000,\n+            0x3950000000000000,\n+            0x3960000000000000_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (1 + 0) + (epsilon + 0) = (1 + epsilon)\n+        (\n+            0x3ff0000000000000,\n+            0x0000000000000001,\n+            0x0000000000000001_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // FIXME: change 0xf950000000000000 to 0xf940000000000000, when\n+        // DoubleDouble's fallback is gone.\n+        // (DBL_MAX - 1 << (1023 - 105)) + (1 << (1023 - 53) + 0) = DBL_MAX +\n+        // 1.11111... << (1023 - 52)\n+        (\n+            0xf950000000000000_7fefffffffffffff,\n+            0x7c90000000000000,\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            Round::NearestTiesToEven,\n+        ),\n+        // FIXME: change 0xf950000000000000 to 0xf940000000000000, when\n+        // DoubleDouble's fallback is gone.\n+        // (1 << (1023 - 53) + 0) + (DBL_MAX - 1 << (1023 - 105)) = DBL_MAX +\n+        // 1.11111... << (1023 - 52)\n+        (\n+            0x7c90000000000000,\n+            0xf950000000000000_7fefffffffffffff,\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            Round::NearestTiesToEven,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected, round) in &data {\n+        {\n+            let mut a1 = DoubleDouble::from_bits(op1);\n+            let a2 = DoubleDouble::from_bits(op2);\n+            a1 = a1.add_r(a2, round).value;\n+\n+            assert_eq!(expected, a1.to_bits(), \"{:#x} + {:#x}\", op1, op2);\n+        }\n+        {\n+            let a1 = DoubleDouble::from_bits(op1);\n+            let mut a2 = DoubleDouble::from_bits(op2);\n+            a2 = a2.add_r(a1, round).value;\n+\n+            assert_eq!(expected, a2.to_bits(), \"{:#x} + {:#x}\", op2, op1);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_subtract() {\n+    let data = [\n+        // (1 + 0) - (-1e-105 + 0) = (1 + 1e-105)\n+        (\n+            0x3ff0000000000000,\n+            0xb960000000000000,\n+            0x3960000000000000_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (1 + 0) - (-1e-106 + 0) = (1 + 1e-106)\n+        (\n+            0x3ff0000000000000,\n+            0xb950000000000000,\n+            0x3950000000000000_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected, round) in &data {\n+        let mut a1 = DoubleDouble::from_bits(op1);\n+        let a2 = DoubleDouble::from_bits(op2);\n+        a1 = a1.sub_r(a2, round).value;\n+\n+        assert_eq!(expected, a1.to_bits(), \"{:#x} - {:#x}\", op1, op2);\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_multiply_special() {\n+    let data = [\n+        // Category::NaN * Category::NaN = Category::NaN\n+        (\n+            0x7ff8000000000000,\n+            0x7ff8000000000000,\n+            Category::NaN,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::NaN * Category::Zero = Category::NaN\n+        (\n+            0x7ff8000000000000,\n+            0,\n+            Category::NaN,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::NaN * Category::Infinity = Category::NaN\n+        (\n+            0x7ff8000000000000,\n+            0x7ff0000000000000,\n+            Category::NaN,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::NaN * Category::Normal = Category::NaN\n+        (\n+            0x7ff8000000000000,\n+            0x3ff0000000000000,\n+            Category::NaN,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::Infinity * Category::Infinity = Category::Infinity\n+        (\n+            0x7ff0000000000000,\n+            0x7ff0000000000000,\n+            Category::Infinity,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::Infinity * Category::Zero = Category::NaN\n+        (\n+            0x7ff0000000000000,\n+            0,\n+            Category::NaN,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::Infinity * Category::Normal = Category::Infinity\n+        (\n+            0x7ff0000000000000,\n+            0x3ff0000000000000,\n+            Category::Infinity,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::Zero * Category::Zero = Category::Zero\n+        (0, 0, Category::Zero, Round::NearestTiesToEven),\n+        // Category::Zero * Category::Normal = Category::Zero\n+        (\n+            0,\n+            0x3ff0000000000000,\n+            Category::Zero,\n+            Round::NearestTiesToEven,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected, round) in &data {\n+        {\n+            let mut a1 = DoubleDouble::from_bits(op1);\n+            let a2 = DoubleDouble::from_bits(op2);\n+            a1 = a1.mul_r(a2, round).value;\n+\n+            assert_eq!(expected, a1.category(), \"{:#x} * {:#x}\", op1, op2);\n+        }\n+        {\n+            let a1 = DoubleDouble::from_bits(op1);\n+            let mut a2 = DoubleDouble::from_bits(op2);\n+            a2 = a2.mul_r(a1, round).value;\n+\n+            assert_eq!(expected, a2.category(), \"{:#x} * {:#x}\", op2, op1);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_multiply() {\n+    let data = [\n+        // 1/3 * 3 = 1.0\n+        (\n+            0x3c75555555555556_3fd5555555555555,\n+            0x4008000000000000,\n+            0x3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (1 + epsilon) * (1 + 0) = Category::Zero\n+        (\n+            0x0000000000000001_3ff0000000000000,\n+            0x3ff0000000000000,\n+            0x0000000000000001_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (1 + epsilon) * (1 + epsilon) = 1 + 2 * epsilon\n+        (\n+            0x0000000000000001_3ff0000000000000,\n+            0x0000000000000001_3ff0000000000000,\n+            0x0000000000000002_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // -(1 + epsilon) * (1 + epsilon) = -1\n+        (\n+            0x0000000000000001_bff0000000000000,\n+            0x0000000000000001_3ff0000000000000,\n+            0xbff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (0.5 + 0) * (1 + 2 * epsilon) = 0.5 + epsilon\n+        (\n+            0x3fe0000000000000,\n+            0x0000000000000002_3ff0000000000000,\n+            0x0000000000000001_3fe0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (0.5 + 0) * (1 + epsilon) = 0.5\n+        (\n+            0x3fe0000000000000,\n+            0x0000000000000001_3ff0000000000000,\n+            0x3fe0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // __LDBL_MAX__ * (1 + 1 << 106) = inf\n+        (\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            0x3950000000000000_3ff0000000000000,\n+            0x7ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // __LDBL_MAX__ * (1 + 1 << 107) > __LDBL_MAX__, but not inf, yes =_=|||\n+        (\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            0x3940000000000000_3ff0000000000000,\n+            0x7c8fffffffffffff_7fefffffffffffff,\n+            Round::NearestTiesToEven,\n+        ),\n+        // __LDBL_MAX__ * (1 + 1 << 108) = __LDBL_MAX__\n+        (\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            0x3930000000000000_3ff0000000000000,\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            Round::NearestTiesToEven,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected, round) in &data {\n+        {\n+            let mut a1 = DoubleDouble::from_bits(op1);\n+            let a2 = DoubleDouble::from_bits(op2);\n+            a1 = a1.mul_r(a2, round).value;\n+\n+            assert_eq!(expected, a1.to_bits(), \"{:#x} * {:#x}\", op1, op2);\n+        }\n+        {\n+            let a1 = DoubleDouble::from_bits(op1);\n+            let mut a2 = DoubleDouble::from_bits(op2);\n+            a2 = a2.mul_r(a1, round).value;\n+\n+            assert_eq!(expected, a2.to_bits(), \"{:#x} * {:#x}\", op2, op1);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_divide() {\n+    // FIXME: Only a sanity check for now. Add more edge cases when the\n+    // double-double algorithm is implemented.\n+    let data = [\n+        // 1 / 3 = 1/3\n+        (\n+            0x3ff0000000000000,\n+            0x4008000000000000,\n+            0x3c75555555555556_3fd5555555555555,\n+            Round::NearestTiesToEven,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected, round) in &data {\n+        let mut a1 = DoubleDouble::from_bits(op1);\n+        let a2 = DoubleDouble::from_bits(op2);\n+        a1 = a1.div_r(a2, round).value;\n+\n+        assert_eq!(expected, a1.to_bits(), \"{:#x} / {:#x}\", op1, op2);\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_remainder() {\n+    let data = [\n+        // ieee_rem(3.0 + 3.0 << 53, 1.25 + 1.25 << 53) = (0.5 + 0.5 << 53)\n+        (\n+            0x3cb8000000000000_4008000000000000,\n+            0x3ca4000000000000_3ff4000000000000,\n+            0x3c90000000000000_3fe0000000000000,\n+        ),\n+        // ieee_rem(3.0 + 3.0 << 53, 1.75 + 1.75 << 53) = (-0.5 - 0.5 << 53)\n+        (\n+            0x3cb8000000000000_4008000000000000,\n+            0x3cac000000000000_3ffc000000000000,\n+            0xbc90000000000000_bfe0000000000000,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected) in &data {\n+        let a1 = DoubleDouble::from_bits(op1);\n+        let a2 = DoubleDouble::from_bits(op2);\n+        let result = a1.ieee_rem(a2).value;\n+\n+        assert_eq!(\n+            expected,\n+            result.to_bits(),\n+            \"ieee_rem({:#x}, {:#x})\",\n+            op1,\n+            op2\n+        );\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_mod() {\n+    let data = [\n+        // mod(3.0 + 3.0 << 53, 1.25 + 1.25 << 53) = (0.5 + 0.5 << 53)\n+        (\n+            0x3cb8000000000000_4008000000000000,\n+            0x3ca4000000000000_3ff4000000000000,\n+            0x3c90000000000000_3fe0000000000000,\n+        ),\n+        // mod(3.0 + 3.0 << 53, 1.75 + 1.75 << 53) = (1.25 + 1.25 << 53)\n+        // 0xbc98000000000000 doesn't seem right, but it's what we currently have.\n+        // FIXME: investigate\n+        (\n+            0x3cb8000000000000_4008000000000000,\n+            0x3cac000000000000_3ffc000000000000,\n+            0xbc98000000000000_3ff4000000000001,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected) in &data {\n+        let a1 = DoubleDouble::from_bits(op1);\n+        let a2 = DoubleDouble::from_bits(op2);\n+        let r = (a1 % a2).value;\n+\n+        assert_eq!(expected, r.to_bits(), \"fmod({:#x}, {:#x})\", op1, op2);\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_fma() {\n+    // Sanity check for now.\n+    let mut a = \"2\".parse::<DoubleDouble>().unwrap();\n+    a = a.mul_add(\n+        \"3\".parse::<DoubleDouble>().unwrap(),\n+        \"4\".parse::<DoubleDouble>().unwrap(),\n+    ).value;\n+    assert_eq!(\n+        Some(Ordering::Equal),\n+        \"10\".parse::<DoubleDouble>().unwrap().partial_cmp(&a)\n+    );\n+}\n+\n+#[test]\n+fn ppc_double_double_round_to_integral() {\n+    {\n+        let a = \"1.5\".parse::<DoubleDouble>().unwrap();\n+        let a = a.round_to_integral(Round::NearestTiesToEven).value;\n+        assert_eq!(\n+            Some(Ordering::Equal),\n+            \"2\".parse::<DoubleDouble>().unwrap().partial_cmp(&a)\n+        );\n+    }\n+    {\n+        let a = \"2.5\".parse::<DoubleDouble>().unwrap();\n+        let a = a.round_to_integral(Round::NearestTiesToEven).value;\n+        assert_eq!(\n+            Some(Ordering::Equal),\n+            \"2\".parse::<DoubleDouble>().unwrap().partial_cmp(&a)\n+        );\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_compare() {\n+    let data = [\n+        // (1 + 0) = (1 + 0)\n+        (\n+            0x3ff0000000000000,\n+            0x3ff0000000000000,\n+            Some(Ordering::Equal),\n+        ),\n+        // (1 + 0) < (1.00...1 + 0)\n+        (0x3ff0000000000000, 0x3ff0000000000001, Some(Ordering::Less)),\n+        // (1.00...1 + 0) > (1 + 0)\n+        (\n+            0x3ff0000000000001,\n+            0x3ff0000000000000,\n+            Some(Ordering::Greater),\n+        ),\n+        // (1 + 0) < (1 + epsilon)\n+        (\n+            0x3ff0000000000000,\n+            0x0000000000000001_3ff0000000000001,\n+            Some(Ordering::Less),\n+        ),\n+        // NaN != NaN\n+        (0x7ff8000000000000, 0x7ff8000000000000, None),\n+        // (1 + 0) != NaN\n+        (0x3ff0000000000000, 0x7ff8000000000000, None),\n+        // Inf = Inf\n+        (\n+            0x7ff0000000000000,\n+            0x7ff0000000000000,\n+            Some(Ordering::Equal),\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected) in &data {\n+        let a1 = DoubleDouble::from_bits(op1);\n+        let a2 = DoubleDouble::from_bits(op2);\n+        assert_eq!(\n+            expected,\n+            a1.partial_cmp(&a2),\n+            \"compare({:#x}, {:#x})\",\n+            op1,\n+            op2,\n+        );\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_bitwise_eq() {\n+    let data = [\n+        // (1 + 0) = (1 + 0)\n+        (0x3ff0000000000000, 0x3ff0000000000000, true),\n+        // (1 + 0) != (1.00...1 + 0)\n+        (0x3ff0000000000000, 0x3ff0000000000001, false),\n+        // NaN = NaN\n+        (0x7ff8000000000000, 0x7ff8000000000000, true),\n+        // NaN != NaN with a different bit pattern\n+        (\n+            0x7ff8000000000000,\n+            0x3ff0000000000000_7ff8000000000000,\n+            false,\n+        ),\n+        // Inf = Inf\n+        (0x7ff0000000000000, 0x7ff0000000000000, true),\n+    ];\n+\n+    for &(op1, op2, expected) in &data {\n+        let a1 = DoubleDouble::from_bits(op1);\n+        let a2 = DoubleDouble::from_bits(op2);\n+        assert_eq!(expected, a1.bitwise_eq(a2), \"{:#x} = {:#x}\", op1, op2);\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_change_sign() {\n+    let float = DoubleDouble::from_bits(0xbcb0000000000000_400f000000000000);\n+    {\n+        let actual = float.copy_sign(\"1\".parse::<DoubleDouble>().unwrap());\n+        assert_eq!(0xbcb0000000000000_400f000000000000, actual.to_bits());\n+    }\n+    {\n+        let actual = float.copy_sign(\"-1\".parse::<DoubleDouble>().unwrap());\n+        assert_eq!(0x3cb0000000000000_c00f000000000000, actual.to_bits());\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_factories() {\n+    assert_eq!(0, DoubleDouble::ZERO.to_bits());\n+    assert_eq!(\n+        0x7c8ffffffffffffe_7fefffffffffffff,\n+        DoubleDouble::largest().to_bits()\n+    );\n+    assert_eq!(0x0000000000000001, DoubleDouble::SMALLEST.to_bits());\n+    assert_eq!(\n+        0x0360000000000000,\n+        DoubleDouble::smallest_normalized().to_bits()\n+    );\n+    assert_eq!(\n+        0x0000000000000000_8000000000000000,\n+        (-DoubleDouble::ZERO).to_bits()\n+    );\n+    assert_eq!(\n+        0xfc8ffffffffffffe_ffefffffffffffff,\n+        (-DoubleDouble::largest()).to_bits()\n+    );\n+    assert_eq!(\n+        0x0000000000000000_8000000000000001,\n+        (-DoubleDouble::SMALLEST).to_bits()\n+    );\n+    assert_eq!(\n+        0x0000000000000000_8360000000000000,\n+        (-DoubleDouble::smallest_normalized()).to_bits()\n+    );\n+    assert!(DoubleDouble::SMALLEST.is_smallest());\n+    assert!(DoubleDouble::largest().is_largest());\n+}\n+\n+#[test]\n+fn ppc_double_double_is_denormal() {\n+    assert!(DoubleDouble::SMALLEST.is_denormal());\n+    assert!(!DoubleDouble::largest().is_denormal());\n+    assert!(!DoubleDouble::smallest_normalized().is_denormal());\n+    {\n+        // (4 + 3) is not normalized\n+        let data = 0x4008000000000000_4010000000000000;\n+        assert!(DoubleDouble::from_bits(data).is_denormal());\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_exact_inverse() {\n+    assert!(\n+        \"2.0\"\n+            .parse::<DoubleDouble>()\n+            .unwrap()\n+            .get_exact_inverse()\n+            .unwrap()\n+            .bitwise_eq(\"0.5\".parse::<DoubleDouble>().unwrap())\n+    );\n+}\n+\n+#[test]\n+fn ppc_double_double_scalbn() {\n+    // 3.0 + 3.0 << 53\n+    let input = 0x3cb8000000000000_4008000000000000;\n+    let result = DoubleDouble::from_bits(input).scalbn(1);\n+    // 6.0 + 6.0 << 53\n+    assert_eq!(0x3cc8000000000000_4018000000000000, result.to_bits());\n+}\n+\n+#[test]\n+fn ppc_double_double_frexp() {\n+    // 3.0 + 3.0 << 53\n+    let input = 0x3cb8000000000000_4008000000000000;\n+    let mut exp = 0;\n+    // 0.75 + 0.75 << 53\n+    let result = DoubleDouble::from_bits(input).frexp(&mut exp);\n+    assert_eq!(2, exp);\n+    assert_eq!(0x3c98000000000000_3fe8000000000000, result.to_bits());\n+}"}, {"sha": "eb45fd9c0e0a44246c9fd8e558bac1aac050e9cd", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "patch": "@@ -26,6 +26,7 @@ use rustc::util::nodemap::DefIdMap;\n \n use syntax::abi::Abi;\n use syntax::ast;\n+use syntax::attr;\n use rustc::hir::{self, Expr};\n use syntax_pos::Span;\n \n@@ -560,8 +561,15 @@ fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ty::TyUint(ast::UintTy::Us) => {\n             Ok(Integral(Usize(ConstUsize::new_truncating(v, tcx.sess.target.uint_type))))\n         },\n-        ty::TyFloat(ast::FloatTy::F64) => Ok(Float(F64(val.to_f64()))),\n-        ty::TyFloat(ast::FloatTy::F32) => Ok(Float(F32(val.to_f32()))),\n+        ty::TyFloat(fty) => {\n+            if let Some(i) = val.to_u128() {\n+                Ok(Float(ConstFloat::from_u128(i, fty)))\n+            } else {\n+                // The value must be negative, go through signed integers.\n+                let i = val.to_u128_unchecked() as i128;\n+                Ok(Float(ConstFloat::from_i128(i, fty)))\n+            }\n+        }\n         ty::TyRawPtr(_) => Err(ErrKind::UnimplementedConstVal(\"casting an address to a raw ptr\")),\n         ty::TyChar => match val {\n             U8(u) => Ok(Char(u as char)),\n@@ -574,30 +582,25 @@ fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               val: ConstFloat,\n                               ty: Ty<'tcx>) -> CastResult<'tcx> {\n+    let int_width = |ty| {\n+        ty::layout::Integer::from_attr(tcx, ty).size().bits() as usize\n+    };\n     match ty.sty {\n-        ty::TyInt(_) | ty::TyUint(_) => {\n-            let i = match val {\n-                F32(f) if f >= 0.0 => U128(f as u128),\n-                F64(f) if f >= 0.0 => U128(f as u128),\n-\n-                F32(f) => I128(f as i128),\n-                F64(f) => I128(f as i128)\n-            };\n-\n-            if let (I128(_), &ty::TyUint(_)) = (i, &ty.sty) {\n-                return Err(CannotCast);\n+        ty::TyInt(ity) => {\n+            if let Some(i) = val.to_i128(int_width(attr::SignedInt(ity))) {\n+                cast_const_int(tcx, I128(i), ty)\n+            } else {\n+                Err(CannotCast)\n+            }\n+        }\n+        ty::TyUint(uty) => {\n+            if let Some(i) = val.to_u128(int_width(attr::UnsignedInt(uty))) {\n+                cast_const_int(tcx, U128(i), ty)\n+            } else {\n+                Err(CannotCast)\n             }\n-\n-            cast_const_int(tcx, i, ty)\n         }\n-        ty::TyFloat(ast::FloatTy::F64) => Ok(Float(F64(match val {\n-            F32(f) => f as f64,\n-            F64(f) => f\n-        }))),\n-        ty::TyFloat(ast::FloatTy::F32) => Ok(Float(F32(match val {\n-            F64(f) => f as f32,\n-            F32(f) => f\n-        }))),\n+        ty::TyFloat(fty) => Ok(Float(val.convert(fty))),\n         _ => Err(CannotCast),\n     }\n }\n@@ -691,11 +694,7 @@ fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n \n fn parse_float<'tcx>(num: &str, fty: ast::FloatTy)\n                      -> Result<ConstFloat, ErrKind<'tcx>> {\n-    let val = match fty {\n-        ast::FloatTy::F32 => num.parse::<f32>().map(F32),\n-        ast::FloatTy::F64 => num.parse::<f64>().map(F64)\n-    };\n-    val.map_err(|_| {\n+    ConstFloat::from_str(num, fty).map_err(|_| {\n         // FIXME(#31407) this is only necessary because float parsing is buggy\n         UnimplementedConstVal(\"could not evaluate float literal (see issue #31407)\")\n     })"}, {"sha": "41310ede3e085a0928288779615792ea79dd8055", "filename": "src/librustc_const_math/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_const_math%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_const_math%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2FCargo.toml?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "patch": "@@ -9,5 +9,6 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n+rustc_apfloat = { path = \"../librustc_apfloat\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "719f6b6a7b3221965447d8370d5ae016e494586b", "filename": "src/librustc_const_math/float.rs", "status": "modified", "additions": 138, "deletions": 66, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_const_math%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_const_math%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ffloat.rs?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "patch": "@@ -9,102 +9,164 @@\n // except according to those terms.\n \n use std::cmp::Ordering;\n-use std::hash;\n-use std::mem::transmute;\n+use std::num::ParseFloatError;\n+\n+use syntax::ast;\n+\n+use rustc_apfloat::{Float, FloatConvert, Status};\n+use rustc_apfloat::ieee::{Single, Double};\n \n use super::err::*;\n \n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub enum ConstFloat {\n-    F32(f32),\n-    F64(f64)\n+// Note that equality for `ConstFloat` means that the it is the same\n+// constant, not that the rust values are equal. In particular, `NaN\n+// == NaN` (at least if it's the same NaN; distinct encodings for NaN\n+// are considering unequal).\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct ConstFloat {\n+    pub ty: ast::FloatTy,\n+\n+    // This is a bit inefficient but it makes conversions below more\n+    // ergonomic, and all of this will go away once `miri` is merged.\n+    pub bits: u128,\n }\n-pub use self::ConstFloat::*;\n \n impl ConstFloat {\n     /// Description of the type, not the value\n     pub fn description(&self) -> &'static str {\n-        match *self {\n-            F32(_) => \"f32\",\n-            F64(_) => \"f64\",\n-        }\n+        self.ty.ty_to_string()\n     }\n \n     pub fn is_nan(&self) -> bool {\n-        match *self {\n-            F32(f) => f.is_nan(),\n-            F64(f) => f.is_nan(),\n+        match self.ty {\n+            ast::FloatTy::F32 => Single::from_bits(self.bits).is_nan(),\n+            ast::FloatTy::F64 => Double::from_bits(self.bits).is_nan(),\n         }\n     }\n \n     /// Compares the values if they are of the same type\n     pub fn try_cmp(self, rhs: Self) -> Result<Ordering, ConstMathErr> {\n-        match (self, rhs) {\n-            (F64(a), F64(b))  => {\n+        match (self.ty, rhs.ty) {\n+            (ast::FloatTy::F64, ast::FloatTy::F64)  => {\n+                let a = Double::from_bits(self.bits);\n+                let b = Double::from_bits(rhs.bits);\n                 // This is pretty bad but it is the existing behavior.\n-                Ok(if a == b {\n-                    Ordering::Equal\n-                } else if a < b {\n-                    Ordering::Less\n-                } else {\n-                    Ordering::Greater\n-                })\n+                Ok(a.partial_cmp(&b).unwrap_or(Ordering::Greater))\n             }\n \n-            (F32(a), F32(b)) => {\n-                Ok(if a == b {\n-                    Ordering::Equal\n-                } else if a < b {\n-                    Ordering::Less\n-                } else {\n-                    Ordering::Greater\n-                })\n+            (ast::FloatTy::F32, ast::FloatTy::F32) => {\n+                let a = Single::from_bits(self.bits);\n+                let b = Single::from_bits(rhs.bits);\n+                Ok(a.partial_cmp(&b).unwrap_or(Ordering::Greater))\n             }\n \n             _ => Err(CmpBetweenUnequalTypes),\n         }\n     }\n-}\n \n-/// Note that equality for `ConstFloat` means that the it is the same\n-/// constant, not that the rust values are equal. In particular, `NaN\n-/// == NaN` (at least if it's the same NaN; distinct encodings for NaN\n-/// are considering unequal).\n-impl PartialEq for ConstFloat {\n-    fn eq(&self, other: &Self) -> bool {\n-        match (*self, *other) {\n-            (F64(a), F64(b)) => {\n-                unsafe{transmute::<_,u64>(a) == transmute::<_,u64>(b)}\n+    pub fn from_i128(input: i128, ty: ast::FloatTy) -> Self {\n+        let bits = match ty {\n+            ast::FloatTy::F32 => Single::from_i128(input).value.to_bits(),\n+            ast::FloatTy::F64 => Double::from_i128(input).value.to_bits()\n+        };\n+        ConstFloat { bits, ty }\n+    }\n+\n+    pub fn from_u128(input: u128, ty: ast::FloatTy) -> Self {\n+        let bits = match ty {\n+            ast::FloatTy::F32 => Single::from_u128(input).value.to_bits(),\n+            ast::FloatTy::F64 => Double::from_u128(input).value.to_bits()\n+        };\n+        ConstFloat { bits, ty }\n+    }\n+\n+    pub fn from_str(num: &str, ty: ast::FloatTy) -> Result<Self, ParseFloatError> {\n+        let bits = match ty {\n+            ast::FloatTy::F32 => {\n+                let rust_bits = num.parse::<f32>()?.to_bits() as u128;\n+                let apfloat = num.parse::<Single>().unwrap_or_else(|e| {\n+                    panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e);\n+                });\n+                let apfloat_bits = apfloat.to_bits();\n+                assert!(rust_bits == apfloat_bits,\n+                    \"apfloat::ieee::Single gave different result for `{}`: \\\n+                     {}({:#x}) vs Rust's {}({:#x})\",\n+                    num, apfloat, apfloat_bits,\n+                    Single::from_bits(rust_bits), rust_bits);\n+                apfloat_bits\n             }\n-            (F32(a), F32(b)) => {\n-                unsafe{transmute::<_,u32>(a) == transmute::<_,u32>(b)}\n+            ast::FloatTy::F64 => {\n+                let rust_bits = num.parse::<f64>()?.to_bits() as u128;\n+                let apfloat = num.parse::<Double>().unwrap_or_else(|e| {\n+                    panic!(\"apfloat::ieee::Double failed to parse `{}`: {:?}\", num, e);\n+                });\n+                let apfloat_bits = apfloat.to_bits();\n+                assert!(rust_bits == apfloat_bits,\n+                    \"apfloat::ieee::Double gave different result for `{}`: \\\n+                     {}({:#x}) vs Rust's {}({:#x})\",\n+                    num, apfloat, apfloat_bits,\n+                    Double::from_bits(rust_bits), rust_bits);\n+                apfloat_bits\n             }\n-            _ => false\n+        };\n+        Ok(ConstFloat { bits, ty })\n+    }\n+\n+    pub fn to_i128(self, width: usize) -> Option<i128> {\n+        assert!(width <= 128);\n+        let r = match self.ty {\n+            ast::FloatTy::F32 => Single::from_bits(self.bits).to_i128(width),\n+            ast::FloatTy::F64 => Double::from_bits(self.bits).to_i128(width)\n+        };\n+        if r.status.intersects(Status::INVALID_OP) {\n+            None\n+        } else {\n+            Some(r.value)\n         }\n     }\n-}\n \n-impl Eq for ConstFloat {}\n+    pub fn to_u128(self, width: usize) -> Option<u128> {\n+        assert!(width <= 128);\n+        let r = match self.ty {\n+            ast::FloatTy::F32 => Single::from_bits(self.bits).to_u128(width),\n+            ast::FloatTy::F64 => Double::from_bits(self.bits).to_u128(width)\n+        };\n+        if r.status.intersects(Status::INVALID_OP) {\n+            None\n+        } else {\n+            Some(r.value)\n+        }\n+    }\n \n-impl hash::Hash for ConstFloat {\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-        match *self {\n-            F64(a) => {\n-                unsafe { transmute::<_,u64>(a) }.hash(state)\n+    pub fn convert(self, to: ast::FloatTy) -> Self {\n+        let bits = match (self.ty, to) {\n+            (ast::FloatTy::F32, ast::FloatTy::F32) |\n+            (ast::FloatTy::F64, ast::FloatTy::F64) => return self,\n+\n+            (ast::FloatTy::F32, ast::FloatTy::F64) => {\n+                Double::to_bits(Single::from_bits(self.bits).convert(&mut false).value)\n             }\n-            F32(a) => {\n-                unsafe { transmute::<_,u32>(a) }.hash(state)\n+            (ast::FloatTy::F64, ast::FloatTy::F32) => {\n+                Single::to_bits(Double::from_bits(self.bits).convert(&mut false).value)\n             }\n-        }\n+        };\n+        ConstFloat { bits, ty: to }\n     }\n }\n \n impl ::std::fmt::Display for ConstFloat {\n     fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        match *self {\n-            F32(f) => write!(fmt, \"{}f32\", f),\n-            F64(f) => write!(fmt, \"{}f64\", f),\n+        match self.ty {\n+            ast::FloatTy::F32 => write!(fmt, \"{:#}\", Single::from_bits(self.bits))?,\n+            ast::FloatTy::F64 => write!(fmt, \"{:#}\", Double::from_bits(self.bits))?,\n         }\n+        write!(fmt, \"{}\", self.ty)\n+    }\n+}\n+\n+impl ::std::fmt::Debug for ConstFloat {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n+        ::std::fmt::Display::fmt(self, fmt)\n     }\n }\n \n@@ -113,11 +175,20 @@ macro_rules! derive_binop {\n         impl ::std::ops::$op for ConstFloat {\n             type Output = Result<Self, ConstMathErr>;\n             fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-                match (self, rhs) {\n-                    (F32(a), F32(b)) => Ok(F32(a.$func(b))),\n-                    (F64(a), F64(b)) => Ok(F64(a.$func(b))),\n-                    _ => Err(UnequalTypes(Op::$op)),\n-                }\n+                let bits = match (self.ty, rhs.ty) {\n+                    (ast::FloatTy::F32, ast::FloatTy::F32) =>{\n+                        let a = Single::from_bits(self.bits);\n+                        let b = Single::from_bits(rhs.bits);\n+                        a.$func(b).value.to_bits()\n+                    }\n+                    (ast::FloatTy::F64, ast::FloatTy::F64) => {\n+                        let a = Double::from_bits(self.bits);\n+                        let b = Double::from_bits(rhs.bits);\n+                        a.$func(b).value.to_bits()\n+                    }\n+                    _ => return Err(UnequalTypes(Op::$op)),\n+                };\n+                Ok(ConstFloat { bits, ty: self.ty })\n             }\n         }\n     }\n@@ -132,9 +203,10 @@ derive_binop!(Rem, rem);\n impl ::std::ops::Neg for ConstFloat {\n     type Output = Self;\n     fn neg(self) -> Self {\n-        match self {\n-            F32(f) => F32(-f),\n-            F64(f) => F64(-f),\n-        }\n+        let bits = match self.ty {\n+            ast::FloatTy::F32 => (-Single::from_bits(self.bits)).to_bits(),\n+            ast::FloatTy::F64 => (-Double::from_bits(self.bits)).to_bits(),\n+        };\n+        ConstFloat { bits, ty: self.ty }\n     }\n }"}, {"sha": "65471416e8007465ed3ad229f2a3fb1a910440e0", "filename": "src/librustc_const_math/int.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "patch": "@@ -211,48 +211,6 @@ impl ConstInt {\n         }\n     }\n \n-    pub fn to_f32(self) -> f32 {\n-        match self {\n-            I8(i) => i as f32,\n-            I16(i) => i as f32,\n-            I32(i) => i as f32,\n-            I64(i) => i as f32,\n-            I128(i) => i as f32,\n-            Isize(Is16(i)) => i as f32,\n-            Isize(Is32(i)) => i as f32,\n-            Isize(Is64(i)) => i as f32,\n-            U8(i) => i as f32,\n-            U16(i) => i as f32,\n-            U32(i) => i as f32,\n-            U64(i) => i as f32,\n-            U128(i) => i as f32,\n-            Usize(Us16(i)) => i as f32,\n-            Usize(Us32(i)) => i as f32,\n-            Usize(Us64(i)) => i as f32,\n-        }\n-    }\n-\n-    pub fn to_f64(self) -> f64 {\n-        match self {\n-            I8(i) => i as f64,\n-            I16(i) => i as f64,\n-            I32(i) => i as f64,\n-            I64(i) => i as f64,\n-            I128(i) => i as f64,\n-            Isize(Is16(i)) => i as f64,\n-            Isize(Is32(i)) => i as f64,\n-            Isize(Is64(i)) => i as f64,\n-            U8(i) => i as f64,\n-            U16(i) => i as f64,\n-            U32(i) => i as f64,\n-            U64(i) => i as f64,\n-            U128(i) => i as f64,\n-            Usize(Us16(i)) => i as f64,\n-            Usize(Us32(i)) => i as f64,\n-            Usize(Us64(i)) => i as f64,\n-        }\n-    }\n-\n     pub fn is_negative(&self) -> bool {\n         match *self {\n             I8(v) => v < 0,"}, {"sha": "3947edecb5aff20215fe82888e3e4534b5660ce4", "filename": "src/librustc_const_math/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "patch": "@@ -26,6 +26,8 @@\n #![feature(i128)]\n #![feature(i128_type)]\n \n+extern crate rustc_apfloat;\n+\n extern crate syntax;\n \n extern crate serialize as rustc_serialize; // used by deriving"}, {"sha": "20735af69e3786571d7fb6be8d4354340a609ba6", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "patch": "@@ -598,7 +598,6 @@ extern \"C\" {\n     // Operations on scalar constants\n     pub fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool) -> ValueRef;\n     pub fn LLVMConstIntOfArbitraryPrecision(IntTy: TypeRef, Wn: c_uint, Ws: *const u64) -> ValueRef;\n-    pub fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n     pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n     pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n     pub fn LLVMRustConstInt128Get(ConstantVal: ValueRef, SExt: bool,"}, {"sha": "e8032529b1fe4c54111becf6b30ecf0a6cc49ae2", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "patch": "@@ -844,8 +844,7 @@ fn create_imps(sess: &Session,\n             let imp = llvm::LLVMAddGlobal(llvm_module.llmod,\n                                           i8p_ty.to_ref(),\n                                           imp_name.as_ptr() as *const _);\n-            let init = llvm::LLVMConstBitCast(val, i8p_ty.to_ref());\n-            llvm::LLVMSetInitializer(imp, init);\n+            llvm::LLVMSetInitializer(imp, consts::ptrcast(val, i8p_ty));\n             llvm::LLVMRustSetLinkage(imp, llvm::Linkage::ExternalLinkage);\n         }\n     }"}, {"sha": "61766a3db2c9d9c53884afd2b4d7ed1779a86cbc", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "patch": "@@ -223,12 +223,6 @@ pub fn C_big_integral(t: Type, u: u128) -> ValueRef {\n     }\n }\n \n-pub fn C_floating_f64(f: f64, t: Type) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMConstReal(t.to_ref(), f)\n-    }\n-}\n-\n pub fn C_nil(ccx: &CrateContext) -> ValueRef {\n     C_struct(ccx, &[], false)\n }"}, {"sha": "310cd6fe9559d8942d4af168ee4603b76bec8fa0", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "patch": "@@ -36,6 +36,12 @@ pub fn ptrcast(val: ValueRef, ty: Type) -> ValueRef {\n     }\n }\n \n+pub fn bitcast(val: ValueRef, ty: Type) -> ValueRef {\n+    unsafe {\n+        llvm::LLVMConstBitCast(val, ty.to_ref())\n+    }\n+}\n+\n pub fn addr_of_mut(ccx: &CrateContext,\n                    cv: ValueRef,\n                    align: machine::llalign,"}, {"sha": "53469689bc7ddf20e853e5ff5a3e702cdd26a72c", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "patch": "@@ -11,7 +11,6 @@\n use llvm::{self, ValueRef};\n use rustc::middle::const_val::{ConstEvalErr, ConstVal, ErrKind};\n use rustc_const_math::ConstInt::*;\n-use rustc_const_math::ConstFloat::*;\n use rustc_const_math::{ConstInt, ConstMathErr};\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n@@ -27,7 +26,7 @@ use abi::{self, Abi};\n use callee;\n use builder::Builder;\n use common::{self, CrateContext, const_get_elt, val_ty};\n-use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral, C_big_integral};\n+use common::{C_array, C_bool, C_bytes, C_integral, C_big_integral, C_u32, C_u64};\n use common::{C_null, C_struct, C_str_slice, C_undef, C_uint, C_vector, is_undef};\n use common::const_to_opt_u128;\n use consts;\n@@ -37,6 +36,7 @@ use type_::Type;\n use value::Value;\n \n use syntax_pos::Span;\n+use syntax::ast;\n \n use std::fmt;\n use std::ptr;\n@@ -95,8 +95,13 @@ impl<'tcx> Const<'tcx> {\n                              -> Const<'tcx> {\n         let llty = type_of::type_of(ccx, ty);\n         let val = match cv {\n-            ConstVal::Float(F32(v)) => C_floating_f64(v as f64, llty),\n-            ConstVal::Float(F64(v)) => C_floating_f64(v, llty),\n+            ConstVal::Float(v) => {\n+                let bits = match v.ty {\n+                    ast::FloatTy::F32 => C_u32(ccx, v.bits as u32),\n+                    ast::FloatTy::F64 => C_u64(ccx, v.bits as u64)\n+                };\n+                consts::bitcast(bits, llty)\n+            }\n             ConstVal::Bool(v) => C_bool(ccx, v),\n             ConstVal::Integral(ref i) => return Const::from_constint(ccx, i),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),"}, {"sha": "81dd1932894fb326e944e6af5c035d9616fe38e4", "filename": "src/test/mir-opt/deaggregator_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs?ref=2b82b7e50a9ebb514ac5cf2a0a5b65ac3d92cefb", "patch": "@@ -25,7 +25,7 @@ fn main() {}\n // bb0: {\n //     _2 = _1;\n //     _3 = _2;\n-//     _0 = Baz { x: _3, y: const F32(0), z: const false };\n+//     _0 = Baz { x: _3, y: const 0f32, z: const false };\n //     return;\n // }\n // END rustc.node13.Deaggregator.before.mir\n@@ -34,7 +34,7 @@ fn main() {}\n //     _2 = _1;\n //     _3 = _2;\n //     (_0.0: usize) = _3;\n-//     (_0.1: f32) = const F32(0);\n+//     (_0.1: f32) = const 0f32;\n //     (_0.2: bool) = const false;\n //     return;\n // }"}]}