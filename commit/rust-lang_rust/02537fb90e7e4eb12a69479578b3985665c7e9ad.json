{"sha": "02537fb90e7e4eb12a69479578b3985665c7e9ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyNTM3ZmI5MGU3ZTRlYjEyYTY5NDc5NTc4YjM5ODU2NjVjN2U5YWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-09T08:23:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-09T08:23:53Z"}, "message": "Auto merge of #47761 - GuillaumeGomez:test-themes, r=Mark-Simulacrum\n\nTest themes\n\nr? @QuietMisdreavus\n\ncc @Mark-Simulacrum", "tree": {"sha": "6ca8be7d7d46adf8e8784b8f1dbe55a86eb205d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ca8be7d7d46adf8e8784b8f1dbe55a86eb205d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02537fb90e7e4eb12a69479578b3985665c7e9ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02537fb90e7e4eb12a69479578b3985665c7e9ad", "html_url": "https://github.com/rust-lang/rust/commit/02537fb90e7e4eb12a69479578b3985665c7e9ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02537fb90e7e4eb12a69479578b3985665c7e9ad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afa8acce251cda7ab1548640fdb769139a45f839", "url": "https://api.github.com/repos/rust-lang/rust/commits/afa8acce251cda7ab1548640fdb769139a45f839", "html_url": "https://github.com/rust-lang/rust/commit/afa8acce251cda7ab1548640fdb769139a45f839"}, {"sha": "dec9fab768e43a5c75456bb61c21701502db6de6", "url": "https://api.github.com/repos/rust-lang/rust/commits/dec9fab768e43a5c75456bb61c21701502db6de6", "html_url": "https://github.com/rust-lang/rust/commit/dec9fab768e43a5c75456bb61c21701502db6de6"}], "stats": {"total": 554, "additions": 546, "deletions": 8}, "files": [{"sha": "afe7f841f2571ff2439bdfa393d6b8ab8fe50d4e", "filename": "src/Cargo.lock", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=02537fb90e7e4eb12a69479578b3985665c7e9ad", "patch": "@@ -2217,6 +2217,10 @@ dependencies = [\n  \"tempdir 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"rustdoc-themes\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"rustdoc-tool\"\n version = \"0.0.0\""}, {"sha": "c03301852cd3b97de7ab1af12570ba23e1b331c7", "filename": "src/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=02537fb90e7e4eb12a69479578b3985665c7e9ad", "patch": "@@ -22,6 +22,7 @@ members = [\n   \"tools/rls\",\n   \"tools/rustfmt\",\n   \"tools/miri\",\n+  \"tools/rustdoc-themes\",\n   # FIXME(https://github.com/rust-lang/cargo/issues/4089): move these to exclude\n   \"tools/rls/test_data/bin_lib\",\n   \"tools/rls/test_data/borrow_error\","}, {"sha": "6c68ee18506bb14eab21aa03ff329f9d44f24454", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=02537fb90e7e4eb12a69479578b3985665c7e9ad", "patch": "@@ -258,7 +258,7 @@ impl<'a> Builder<'a> {\n                 test::HostCompiletest, test::Crate, test::CrateLibrustc, test::Rustdoc,\n                 test::Linkcheck, test::Cargotest, test::Cargo, test::Rls, test::Docs,\n                 test::ErrorIndex, test::Distcheck, test::Rustfmt, test::Miri, test::Clippy,\n-                test::RustdocJS),\n+                test::RustdocJS, test::RustdocTheme),\n             Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n             Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n                 doc::Standalone, doc::Std, doc::Test, doc::Rustc, doc::ErrorIndex, doc::Nomicon,"}, {"sha": "ede403491d7fcea4bc12ac3b38226c10b7c7623b", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=02537fb90e7e4eb12a69479578b3985665c7e9ad", "patch": "@@ -160,4 +160,3 @@ pub fn libtest_stamp(build: &Build, compiler: Compiler, target: Interned<String>\n pub fn librustc_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n     build.cargo_out(compiler, Mode::Librustc, target).join(\".librustc-check.stamp\")\n }\n-"}, {"sha": "eae8ec1311df7e27a17db51f8911db8cd3ecd9e4", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=02537fb90e7e4eb12a69479578b3985665c7e9ad", "patch": "@@ -113,7 +113,7 @@ impl Step for Linkcheck {\n \n         let _time = util::timeit();\n         try_run(build, builder.tool_cmd(Tool::Linkchecker)\n-                            .arg(build.out.join(host).join(\"doc\")));\n+                              .arg(build.out.join(host).join(\"doc\")));\n     }\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n@@ -424,6 +424,47 @@ fn path_for_cargo(builder: &Builder, compiler: Compiler) -> OsString {\n     env::join_paths(iter::once(path).chain(env::split_paths(&old_path))).expect(\"\")\n }\n \n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct RustdocTheme {\n+    pub compiler: Compiler,\n+}\n+\n+impl Step for RustdocTheme {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/rustdoc-themes\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n+\n+        run.builder.ensure(RustdocTheme {\n+            compiler: compiler,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        let rustdoc = builder.rustdoc(self.compiler.host);\n+        let mut cmd = builder.tool_cmd(Tool::RustdocTheme);\n+        cmd.arg(rustdoc.to_str().unwrap())\n+           .arg(builder.src.join(\"src/librustdoc/html/static/themes\").to_str().unwrap())\n+           .env(\"RUSTC_STAGE\", self.compiler.stage.to_string())\n+           .env(\"RUSTC_SYSROOT\", builder.sysroot(self.compiler))\n+           .env(\"RUSTDOC_LIBDIR\", builder.sysroot_libdir(self.compiler, self.compiler.host))\n+           .env(\"CFG_RELEASE_CHANNEL\", &builder.build.config.channel)\n+           .env(\"RUSTDOC_REAL\", builder.rustdoc(self.compiler.host))\n+           .env(\"RUSTDOC_CRATE_VERSION\", builder.build.rust_version())\n+           .env(\"RUSTC_BOOTSTRAP\", \"1\");\n+        if let Some(linker) = builder.build.linker(self.compiler.host) {\n+            cmd.env(\"RUSTC_TARGET_LINKER\", linker);\n+        }\n+        try_run(builder.build, &mut cmd);\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RustdocJS {\n     pub host: Interned<String>,"}, {"sha": "9036eb044b5a5677a86d58b15bb0b354de0a0aaf", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=02537fb90e7e4eb12a69479578b3985665c7e9ad", "patch": "@@ -260,6 +260,7 @@ tool!(\n     BuildManifest, \"src/tools/build-manifest\", \"build-manifest\", Mode::Libstd;\n     RemoteTestClient, \"src/tools/remote-test-client\", \"remote-test-client\", Mode::Libstd;\n     RustInstaller, \"src/tools/rust-installer\", \"fabricate\", Mode::Libstd;\n+    RustdocTheme, \"src/tools/rustdoc-themes\", \"rustdoc-themes\", Mode::Libstd;\n );\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]"}, {"sha": "b45c3bf8e5f4ef14226f9cd975864c1f8ddbe982", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=02537fb90e7e4eb12a69479578b3985665c7e9ad", "patch": "@@ -112,10 +112,13 @@ pre {\n }\n .content .highlighted a, .content .highlighted span { color: #eee !important; }\n .content .highlighted.trait { background-color: #013191; }\n+.content .highlighted.mod,\n+.content .highlighted.externcrate { background-color: #afc6e4; }\n .content .highlighted.mod { background-color: #803a1b; }\n .content .highlighted.externcrate { background-color: #396bac; }\n .content .highlighted.enum { background-color: #5b4e68; }\n .content .highlighted.struct { background-color: #194e9f; }\n+.content .highlighted.union { background-color: #b7bd49; }\n .content .highlighted.fn,\n .content .highlighted.method,\n .content .highlighted.tymethod { background-color: #4950ed; }"}, {"sha": "a72026c7d6b27b8426ae167de4631db004635183", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 48, "deletions": 5, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=02537fb90e7e4eb12a69479578b3985665c7e9ad", "patch": "@@ -91,6 +91,7 @@ pub mod plugins;\n pub mod visit_ast;\n pub mod visit_lib;\n pub mod test;\n+pub mod theme;\n \n use clean::AttributesExt;\n \n@@ -267,6 +268,11 @@ pub fn opts() -> Vec<RustcOptGroup> {\n                        \"additional themes which will be added to the generated docs\",\n                        \"FILES\")\n         }),\n+        unstable(\"theme-checker\", |o| {\n+            o.optmulti(\"\", \"theme-checker\",\n+                       \"check if given theme is valid\",\n+                       \"FILES\")\n+        }),\n     ]\n }\n \n@@ -316,6 +322,31 @@ pub fn main_args(args: &[String]) -> isize {\n         return 0;\n     }\n \n+    let to_check = matches.opt_strs(\"theme-checker\");\n+    if !to_check.is_empty() {\n+        let paths = theme::load_css_paths(include_bytes!(\"html/static/themes/main.css\"));\n+        let mut errors = 0;\n+\n+        println!(\"rustdoc: [theme-checker] Starting tests!\");\n+        for theme_file in to_check.iter() {\n+            print!(\" - Checking \\\"{}\\\"...\", theme_file);\n+            let (success, differences) = theme::test_theme_against(theme_file, &paths);\n+            if !differences.is_empty() || !success {\n+                println!(\" FAILED\");\n+                errors += 1;\n+                if !differences.is_empty() {\n+                    println!(\"{}\", differences.join(\"\\n\"));\n+                }\n+            } else {\n+                println!(\" OK\");\n+            }\n+        }\n+        if errors != 0 {\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n     if matches.free.is_empty() {\n         print_error(\"missing file operand\");\n         return 1;\n@@ -369,12 +400,24 @@ pub fn main_args(args: &[String]) -> isize {\n     }\n \n     let mut themes = Vec::new();\n-    for theme in matches.opt_strs(\"themes\").iter().map(|s| PathBuf::from(&s)) {\n-        if !theme.is_file() {\n-            eprintln!(\"rustdoc: option --themes arguments must all be files\");\n-            return 1;\n+    if matches.opt_present(\"themes\") {\n+        let paths = theme::load_css_paths(include_bytes!(\"html/static/themes/main.css\"));\n+\n+        for (theme_file, theme_s) in matches.opt_strs(\"themes\")\n+                                            .iter()\n+                                            .map(|s| (PathBuf::from(&s), s.to_owned())) {\n+            if !theme_file.is_file() {\n+                println!(\"rustdoc: option --themes arguments must all be files\");\n+                return 1;\n+            }\n+            let (success, ret) = theme::test_theme_against(&theme_file, &paths);\n+            if !success || !ret.is_empty() {\n+                println!(\"rustdoc: invalid theme: \\\"{}\\\"\", theme_s);\n+                println!(\"         Check what's wrong with the \\\"theme-checker\\\" option\");\n+                return 1;\n+            }\n+            themes.push(theme_file);\n         }\n-        themes.push(theme);\n     }\n \n     let external_html = match ExternalHtml::load("}, {"sha": "1e4f64f5c52c9edd51e538a637866d85a0f5879a", "filename": "src/librustdoc/theme.rs", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=02537fb90e7e4eb12a69479578b3985665c7e9ad", "patch": "@@ -0,0 +1,379 @@\n+// Copyright 2012-2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashSet;\n+use std::fs::File;\n+use std::hash::{Hash, Hasher};\n+use std::io::Read;\n+use std::path::Path;\n+\n+macro_rules! try_something {\n+    ($e:expr, $out:expr) => ({\n+        match $e {\n+            Ok(c) => c,\n+            Err(e) => {\n+                eprintln!(\"rustdoc: got an error: {}\", e);\n+                return $out;\n+            }\n+        }\n+    })\n+}\n+\n+#[derive(Debug, Clone, Eq)]\n+pub struct CssPath {\n+    pub name: String,\n+    pub children: HashSet<CssPath>,\n+}\n+\n+// This PartialEq implementation IS NOT COMMUTATIVE!!!\n+//\n+// The order is very important: the second object must have all first's rules.\n+// However, the first doesn't require to have all second's rules.\n+impl PartialEq for CssPath {\n+    fn eq(&self, other: &CssPath) -> bool {\n+        if self.name != other.name {\n+            false\n+        } else {\n+            for child in &self.children {\n+                if !other.children.iter().any(|c| child == c) {\n+                    return false;\n+                }\n+            }\n+            true\n+        }\n+    }\n+}\n+\n+impl Hash for CssPath {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.name.hash(state);\n+        for x in &self.children {\n+            x.hash(state);\n+        }\n+    }\n+}\n+\n+impl CssPath {\n+    fn new(name: String) -> CssPath {\n+        CssPath {\n+            name,\n+            children: HashSet::new(),\n+        }\n+    }\n+}\n+\n+/// All variants contain the position they occur.\n+#[derive(Debug, Clone, Copy)]\n+enum Events {\n+    StartLineComment(usize),\n+    StartComment(usize),\n+    EndComment(usize),\n+    InBlock(usize),\n+    OutBlock(usize),\n+}\n+\n+impl Events {\n+    fn get_pos(&self) -> usize {\n+        match *self {\n+            Events::StartLineComment(p) |\n+            Events::StartComment(p) |\n+            Events::EndComment(p) |\n+            Events::InBlock(p) |\n+            Events::OutBlock(p) => p,\n+        }\n+    }\n+\n+    fn is_comment(&self) -> bool {\n+        match *self {\n+            Events::StartLineComment(_) |\n+            Events::StartComment(_) |\n+            Events::EndComment(_) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+fn previous_is_line_comment(events: &[Events]) -> bool {\n+    if let Some(&Events::StartLineComment(_)) = events.last() {\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+fn is_line_comment(pos: usize, v: &[u8], events: &[Events]) -> bool {\n+    if let Some(&Events::StartComment(_)) = events.last() {\n+        return false;\n+    }\n+    pos + 1 < v.len() && v[pos + 1] == b'/'\n+}\n+\n+fn load_css_events(v: &[u8]) -> Vec<Events> {\n+    let mut pos = 0;\n+    let mut events = Vec::with_capacity(100);\n+\n+    while pos < v.len() - 1 {\n+        match v[pos] {\n+            b'/' if pos + 1 < v.len() && v[pos + 1] == b'*' => {\n+                events.push(Events::StartComment(pos));\n+                pos += 1;\n+            }\n+            b'/' if is_line_comment(pos, v, &events) => {\n+                events.push(Events::StartLineComment(pos));\n+                pos += 1;\n+            }\n+            b'\\n' if previous_is_line_comment(&events) => {\n+                events.push(Events::EndComment(pos));\n+            }\n+            b'*' if pos + 1 < v.len() && v[pos + 1] == b'/' => {\n+                events.push(Events::EndComment(pos + 2));\n+                pos += 1;\n+            }\n+            b'{' if !previous_is_line_comment(&events) => {\n+                if let Some(&Events::StartComment(_)) = events.last() {\n+                    pos += 1;\n+                    continue\n+                }\n+                events.push(Events::InBlock(pos + 1));\n+            }\n+            b'}' if !previous_is_line_comment(&events) => {\n+                if let Some(&Events::StartComment(_)) = events.last() {\n+                    pos += 1;\n+                    continue\n+                }\n+                events.push(Events::OutBlock(pos + 1));\n+            }\n+            _ => {}\n+        }\n+        pos += 1;\n+    }\n+    events\n+}\n+\n+fn get_useful_next(events: &[Events], pos: &mut usize) -> Option<Events> {\n+    while *pos < events.len() {\n+        if !events[*pos].is_comment() {\n+            return Some(events[*pos]);\n+        }\n+        *pos += 1;\n+    }\n+    None\n+}\n+\n+fn get_previous_positions(events: &[Events], mut pos: usize) -> Vec<usize> {\n+    let mut ret = Vec::with_capacity(3);\n+\n+    ret.push(events[pos].get_pos());\n+    if pos > 0 {\n+        pos -= 1;\n+    }\n+    loop {\n+        if pos < 1 || !events[pos].is_comment() {\n+            let x = events[pos].get_pos();\n+            if *ret.last().unwrap() != x {\n+                ret.push(x);\n+            } else {\n+                ret.push(0);\n+            }\n+            break\n+        }\n+        ret.push(events[pos].get_pos());\n+        pos -= 1;\n+    }\n+    if ret.len() & 1 != 0 && events[pos].is_comment() {\n+        ret.push(0);\n+    }\n+    ret.iter().rev().cloned().collect()\n+}\n+\n+fn build_rule(v: &[u8], positions: &[usize]) -> String {\n+    positions.chunks(2)\n+             .map(|x| ::std::str::from_utf8(&v[x[0]..x[1]]).unwrap_or(\"\"))\n+             .collect::<String>()\n+             .trim()\n+             .replace(\"\\n\", \" \")\n+             .replace(\"/\", \"\")\n+             .replace(\"\\t\", \" \")\n+             .replace(\"{\", \"\")\n+             .replace(\"}\", \"\")\n+             .split(\" \")\n+             .filter(|s| s.len() > 0)\n+             .collect::<Vec<&str>>()\n+             .join(\" \")\n+}\n+\n+fn inner(v: &[u8], events: &[Events], pos: &mut usize) -> HashSet<CssPath> {\n+    let mut paths = Vec::with_capacity(50);\n+\n+    while *pos < events.len() {\n+        if let Some(Events::OutBlock(_)) = get_useful_next(events, pos) {\n+            *pos += 1;\n+            break\n+        }\n+        if let Some(Events::InBlock(_)) = get_useful_next(events, pos) {\n+            paths.push(CssPath::new(build_rule(v, &get_previous_positions(events, *pos))));\n+            *pos += 1;\n+        }\n+        while let Some(Events::InBlock(_)) = get_useful_next(events, pos) {\n+            if let Some(ref mut path) = paths.last_mut() {\n+                for entry in inner(v, events, pos).iter() {\n+                    path.children.insert(entry.clone());\n+                }\n+            }\n+        }\n+        if let Some(Events::OutBlock(_)) = get_useful_next(events, pos) {\n+            *pos += 1;\n+        }\n+    }\n+    paths.iter().cloned().collect()\n+}\n+\n+pub fn load_css_paths(v: &[u8]) -> CssPath {\n+    let events = load_css_events(v);\n+    let mut pos = 0;\n+\n+    let mut parent = CssPath::new(\"parent\".to_owned());\n+    parent.children = inner(v, &events, &mut pos);\n+    parent\n+}\n+\n+pub fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>) {\n+    if against.name != other.name {\n+        return\n+    } else {\n+        for child in &against.children {\n+            let mut found = false;\n+            let mut found_working = false;\n+            let mut tmp = Vec::new();\n+\n+            for other_child in &other.children {\n+                if child.name == other_child.name {\n+                    if child != other_child {\n+                        get_differences(child, other_child, &mut tmp);\n+                    } else {\n+                        found_working = true;\n+                    }\n+                    found = true;\n+                    break\n+                }\n+            }\n+            if found == false {\n+                v.push(format!(\"  Missing \\\"{}\\\" rule\", child.name));\n+            } else if found_working == false {\n+                v.extend(tmp.iter().cloned());\n+            }\n+        }\n+    }\n+}\n+\n+pub fn test_theme_against<P: AsRef<Path>>(f: &P, against: &CssPath) -> (bool, Vec<String>) {\n+    let mut file = try_something!(File::open(f), (false, Vec::new()));\n+    let mut data = Vec::with_capacity(1000);\n+\n+    try_something!(file.read_to_end(&mut data), (false, Vec::new()));\n+    let paths = load_css_paths(&data);\n+    let mut ret = Vec::new();\n+    get_differences(against, &paths, &mut ret);\n+    (true, ret)\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn test_comments_in_rules() {\n+        let text = r#\"\n+rule a {}\n+\n+rule b, c\n+// a line comment\n+{}\n+\n+rule d\n+// another line comment\n+e {}\n+\n+rule f/* a multine\n+\n+comment*/{}\n+\n+rule g/* another multine\n+\n+comment*/h\n+\n+i {}\n+\n+rule j/*commeeeeent\n+\n+you like things like \"{}\" in there? :)\n+*/\n+end {}\"#;\n+\n+        let against = r#\"\n+rule a {}\n+\n+rule b, c {}\n+\n+rule d e {}\n+\n+rule f {}\n+\n+rule gh i {}\n+\n+rule j end {}\n+\"#;\n+\n+        let mut ret = Vec::new();\n+        get_differences(&load_css_paths(against.as_bytes()),\n+                        &load_css_paths(text.as_bytes()),\n+                        &mut ret);\n+        assert!(ret.is_empty());\n+    }\n+\n+    #[test]\n+    fn test_text() {\n+        let text = r#\"\n+a\n+/* sdfs\n+*/ b\n+c // sdf\n+d {}\n+\"#;\n+        let paths = load_css_paths(text.as_bytes());\n+        assert!(paths.children.contains(&CssPath::new(\"a b c d\".to_owned())));\n+    }\n+\n+    #[test]\n+    fn test_comparison() {\n+        let x = r#\"\n+a {\n+    b {\n+        c {}\n+    }\n+}\n+\"#;\n+\n+        let y = r#\"\n+a {\n+    b {}\n+}\n+\"#;\n+\n+        let against = load_css_paths(y.as_bytes());\n+        let other = load_css_paths(x.as_bytes());\n+\n+        let mut ret = Vec::new();\n+        get_differences(&against, &other, &mut ret);\n+        assert!(ret.is_empty());\n+        get_differences(&other, &against, &mut ret);\n+        assert_eq!(ret, vec![\"  Missing \\\"c\\\" rule\".to_owned()]);\n+    }\n+}"}, {"sha": "c0e2f527301beb57db6922c47b04a05eb50e74e0", "filename": "src/tools/rustdoc-themes/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2Ftools%2Frustdoc-themes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2Ftools%2Frustdoc-themes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-themes%2FCargo.toml?ref=02537fb90e7e4eb12a69479578b3985665c7e9ad", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"rustdoc-themes\"\n+version = \"0.1.0\"\n+authors = [\"Guillaume Gomez <guillaume1.gomez@gmail.com>\"]\n+\n+[[bin]]\n+name = \"rustdoc-themes\"\n+path = \"main.rs\""}, {"sha": "4028cb4e8b6edbaea83ecad7ed0fd9209bf66beb", "filename": "src/tools/rustdoc-themes/main.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2Ftools%2Frustdoc-themes%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02537fb90e7e4eb12a69479578b3985665c7e9ad/src%2Ftools%2Frustdoc-themes%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-themes%2Fmain.rs?ref=02537fb90e7e4eb12a69479578b3985665c7e9ad", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::env::args;\n+use std::fs::read_dir;\n+use std::path::Path;\n+use std::process::{Command, exit};\n+\n+const FILES_TO_IGNORE: &[&str] = &[\"main.css\"];\n+\n+fn get_folders<P: AsRef<Path>>(folder_path: P) -> Vec<String> {\n+    let mut ret = Vec::with_capacity(10);\n+\n+    for entry in read_dir(folder_path.as_ref()).expect(\"read_dir failed\") {\n+        let entry = entry.expect(\"Couldn't unwrap entry\");\n+        let path = entry.path();\n+\n+        if !path.is_file() {\n+            continue\n+        }\n+        let filename = path.file_name().expect(\"file_name failed\");\n+        if FILES_TO_IGNORE.iter().any(|x| x == &filename) {\n+            continue\n+        }\n+        ret.push(format!(\"{}\", path.display()));\n+    }\n+    ret\n+}\n+\n+fn main() {\n+    let argv: Vec<String> = args().collect();\n+\n+    if argv.len() < 3 {\n+        eprintln!(\"Needs rustdoc binary path\");\n+        exit(1);\n+    }\n+    let rustdoc_bin = &argv[1];\n+    let themes_folder = &argv[2];\n+    let themes = get_folders(&themes_folder);\n+    if themes.is_empty() {\n+        eprintln!(\"No theme found in \\\"{}\\\"...\", themes_folder);\n+        exit(1);\n+    }\n+    let status = Command::new(rustdoc_bin)\n+                        .args(&[\"-Z\", \"unstable-options\", \"--theme-checker\"])\n+                        .args(&themes)\n+                        .status()\n+                        .expect(\"failed to execute child\");\n+    if !status.success() {\n+        exit(1);\n+    }\n+}"}]}