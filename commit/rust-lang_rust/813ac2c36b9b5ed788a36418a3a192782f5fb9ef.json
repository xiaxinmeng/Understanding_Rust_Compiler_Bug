{"sha": "813ac2c36b9b5ed788a36418a3a192782f5fb9ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxM2FjMmMzNmI5YjVlZDc4OGEzNjQxOGEzYTE5Mjc4MmY1ZmI5ZWY=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-06T08:25:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-06T08:25:30Z"}, "message": "Rollup merge of #48432 - flip1995:lit_diag, r=oli-obk\n\nSuggest type for overflowing bin/hex-literals\n\nFixes #48073\n\nFor hexadecimal and binary literals, which overflow, it gives an additional note to the warning message, like in this [comment](https://github.com/rust-lang/rust/issues/48073#issuecomment-365370113).\n\nAdditionally it will suggest a type (`X < Y`):\n- `iX`: if literal fits in `uX` => `uX`, else => `iY`\n- `-iX` => `iY`\n- `uX` => `uY`\n\nExceptions: `isize`, `usize`. I don't think you can make a good suggestion here. The programmer has to figure it out on it's own in this case.\n\nr? @oli-obk", "tree": {"sha": "bd7922336d395548a9a4cc281aa533c08fe7b5ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd7922336d395548a9a4cc281aa533c08fe7b5ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/813ac2c36b9b5ed788a36418a3a192782f5fb9ef", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJanlB6CRBK7hj4Ov3rIwAAdHIIAE+DkWSwkHLos40FfxBdiDJ2\n98ODg+SBGzfJBXhIsAM9URXJe0sxXqA3S4vGAyM0hyDF8hZaCCiujZt65kl0xlNm\nkhtSDKRIHZmrIjI3oyl47jwXliMyA/euzZFwoQMpwnLmfhzFK6q++3hDGms+CGKI\nz0AEu2uN8v9Np+QwojB7084XwRSKttJDaVnTD+7fJFRMxGgMXkGNdDaYO/3dx4JW\nz8JW86QIiOXEh7VJqqT5nxTSNsE8eGoiWBtkNiF8U1s4DoXFNP6vXoY3y58MI0Y/\nKSobMmxacBj0s1Mhh+UrkhIpg0SZVInKPjx7cNc/fQu5vTa9kDWFaK0aB8uPl+I=\n=9HU1\n-----END PGP SIGNATURE-----\n", "payload": "tree bd7922336d395548a9a4cc281aa533c08fe7b5ba\nparent 43de95ca5b177bdb61a2ea8d8206a3234e75eff6\nparent fc33b2567cac0ae453807f4118872ab81a16ddf7\nauthor kennytm <kennytm@gmail.com> 1520324730 +0800\ncommitter GitHub <noreply@github.com> 1520324730 +0800\n\nRollup merge of #48432 - flip1995:lit_diag, r=oli-obk\n\nSuggest type for overflowing bin/hex-literals\n\nFixes #48073\n\nFor hexadecimal and binary literals, which overflow, it gives an additional note to the warning message, like in this [comment](https://github.com/rust-lang/rust/issues/48073#issuecomment-365370113).\n\nAdditionally it will suggest a type (`X < Y`):\n- `iX`: if literal fits in `uX` => `uX`, else => `iY`\n- `-iX` => `iY`\n- `uX` => `uY`\n\nExceptions: `isize`, `usize`. I don't think you can make a good suggestion here. The programmer has to figure it out on it's own in this case.\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/813ac2c36b9b5ed788a36418a3a192782f5fb9ef", "html_url": "https://github.com/rust-lang/rust/commit/813ac2c36b9b5ed788a36418a3a192782f5fb9ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/813ac2c36b9b5ed788a36418a3a192782f5fb9ef/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43de95ca5b177bdb61a2ea8d8206a3234e75eff6", "url": "https://api.github.com/repos/rust-lang/rust/commits/43de95ca5b177bdb61a2ea8d8206a3234e75eff6", "html_url": "https://github.com/rust-lang/rust/commit/43de95ca5b177bdb61a2ea8d8206a3234e75eff6"}, {"sha": "fc33b2567cac0ae453807f4118872ab81a16ddf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc33b2567cac0ae453807f4118872ab81a16ddf7", "html_url": "https://github.com/rust-lang/rust/commit/fc33b2567cac0ae453807f4118872ab81a16ddf7"}], "stats": {"total": 246, "additions": 238, "deletions": 8}, "files": [{"sha": "1c4bd0ff4c2ec1335ab7429dee64d7b96f00d42a", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 147, "deletions": 8, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/813ac2c36b9b5ed788a36418a3a192782f5fb9ef/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/813ac2c36b9b5ed788a36418a3a192782f5fb9ef/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=813ac2c36b9b5ed788a36418a3a192782f5fb9ef", "patch": "@@ -150,11 +150,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n \n                                 // Detect literal value out of range [min, max] inclusive\n                                 // avoiding use of -min to prevent overflow/panic\n-                                if (negative && v > max + 1) ||\n-                                   (!negative && v > max) {\n-                                    cx.span_lint(OVERFLOWING_LITERALS,\n-                                                 e.span,\n-                                                 &format!(\"literal out of range for {:?}\", t));\n+                                if (negative && v > max + 1) || (!negative && v > max) {\n+                                    if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n+                                        report_bin_hex_error(\n+                                            cx,\n+                                            e,\n+                                            ty::TyInt(t),\n+                                            repr_str,\n+                                            v,\n+                                            negative,\n+                                        );\n+                                        return;\n+                                    }\n+                                    cx.span_lint(\n+                                        OVERFLOWING_LITERALS,\n+                                        e.span,\n+                                        &format!(\"literal out of range for {:?}\", t),\n+                                    );\n                                     return;\n                                 }\n                             }\n@@ -191,9 +203,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                     }\n                                 }\n                             }\n-                            cx.span_lint(OVERFLOWING_LITERALS,\n-                                         e.span,\n-                                         &format!(\"literal out of range for {:?}\", t));\n+                            if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n+                                report_bin_hex_error(\n+                                    cx,\n+                                    e,\n+                                    ty::TyUint(t),\n+                                    repr_str,\n+                                    lit_val,\n+                                    false,\n+                                );\n+                                return;\n+                            }\n+                            cx.span_lint(\n+                                OVERFLOWING_LITERALS,\n+                                e.span,\n+                                &format!(\"literal out of range for {:?}\", t),\n+                            );\n                         }\n                     }\n                     ty::TyFloat(t) => {\n@@ -338,6 +363,120 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 _ => false,\n             }\n         }\n+\n+        fn get_bin_hex_repr(cx: &LateContext, lit: &ast::Lit) -> Option<String> {\n+            let src = cx.sess().codemap().span_to_snippet(lit.span).ok()?;\n+            let firstch = src.chars().next()?;\n+\n+            if firstch == '0' {\n+                match src.chars().nth(1) {\n+                    Some('x') | Some('b') => return Some(src),\n+                    _ => return None,\n+                }\n+            }\n+\n+            None\n+        }\n+\n+        // This function finds the next fitting type and generates a suggestion string.\n+        // It searches for fitting types in the following way (`X < Y`):\n+        //  - `iX`: if literal fits in `uX` => `uX`, else => `iY`\n+        //  - `-iX` => `iY`\n+        //  - `uX` => `uY`\n+        //\n+        // No suggestion for: `isize`, `usize`.\n+        fn get_type_suggestion<'a>(\n+            t: &ty::TypeVariants,\n+            val: u128,\n+            negative: bool,\n+        ) -> Option<String> {\n+            use syntax::ast::IntTy::*;\n+            use syntax::ast::UintTy::*;\n+            macro_rules! find_fit {\n+                ($ty:expr, $val:expr, $negative:expr,\n+                 $($type:ident => [$($utypes:expr),*] => [$($itypes:expr),*]),+) => {\n+                    {\n+                        let _neg = if negative { 1 } else { 0 };\n+                        match $ty {\n+                            $($type => {\n+                                $(if !negative && val <= uint_ty_range($utypes).1 {\n+                                    return Some(format!(\"{:?}\", $utypes))\n+                                })*\n+                                $(if val <= int_ty_range($itypes).1 as u128 + _neg {\n+                                    return Some(format!(\"{:?}\", $itypes))\n+                                })*\n+                                None\n+                            },)*\n+                            _ => None\n+                        }\n+                    }\n+                }\n+            }\n+            match t {\n+                &ty::TyInt(i) => find_fit!(i, val, negative,\n+                              I8 => [U8] => [I16, I32, I64, I128],\n+                              I16 => [U16] => [I32, I64, I128],\n+                              I32 => [U32] => [I64, I128],\n+                              I64 => [U64] => [I128],\n+                              I128 => [U128] => []),\n+                &ty::TyUint(u) => find_fit!(u, val, negative,\n+                              U8 => [U8, U16, U32, U64, U128] => [],\n+                              U16 => [U16, U32, U64, U128] => [],\n+                              U32 => [U32, U64, U128] => [],\n+                              U64 => [U64, U128] => [],\n+                              U128 => [U128] => []),\n+                _ => None,\n+            }\n+        }\n+\n+        fn report_bin_hex_error(\n+            cx: &LateContext,\n+            expr: &hir::Expr,\n+            ty: ty::TypeVariants,\n+            repr_str: String,\n+            val: u128,\n+            negative: bool,\n+        ) {\n+            let (t, actually) = match ty {\n+                ty::TyInt(t) => {\n+                    let bits = int_ty_bits(t, cx.sess().target.isize_ty);\n+                    let actually = (val << (128 - bits)) as i128 >> (128 - bits);\n+                    (format!(\"{:?}\", t), actually.to_string())\n+                }\n+                ty::TyUint(t) => {\n+                    let bits = uint_ty_bits(t, cx.sess().target.usize_ty);\n+                    let actually = (val << (128 - bits)) >> (128 - bits);\n+                    (format!(\"{:?}\", t), actually.to_string())\n+                }\n+                _ => bug!(),\n+            };\n+            let mut err = cx.struct_span_lint(\n+                OVERFLOWING_LITERALS,\n+                expr.span,\n+                &format!(\"literal out of range for {}\", t),\n+            );\n+            err.note(&format!(\n+                \"the literal `{}` (decimal `{}`) does not fit into \\\n+                 an `{}` and will become `{}{}`\",\n+                repr_str, val, t, actually, t\n+            ));\n+            if let Some(sugg_ty) =\n+                get_type_suggestion(&cx.tables.node_id_to_type(expr.hir_id).sty, val, negative)\n+            {\n+                if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n+                    let (sans_suffix, _) = repr_str.split_at(pos);\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\"consider using `{}` instead\", sugg_ty),\n+                        format!(\"{}{}\", sans_suffix, sugg_ty),\n+                    );\n+                } else {\n+                    err.help(&format!(\"consider using `{}` instead\", sugg_ty));\n+                }\n+            }\n+\n+            err.emit();\n+        }\n     }\n }\n "}, {"sha": "495989587e58571a61a97dbc320289dd3a5c3eae", "filename": "src/test/ui/lint/type-overflow.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/813ac2c36b9b5ed788a36418a3a192782f5fb9ef/src%2Ftest%2Fui%2Flint%2Ftype-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/813ac2c36b9b5ed788a36418a3a192782f5fb9ef/src%2Ftest%2Fui%2Flint%2Ftype-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ftype-overflow.rs?ref=813ac2c36b9b5ed788a36418a3a192782f5fb9ef", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+\n+#![feature(i128_type)]\n+\n+fn main() {\n+    let error = 255i8; //~WARNING literal out of range for i8\n+\n+    let ok = 0b1000_0001; // should be ok -> i32\n+    let ok = 0b0111_1111i8; // should be ok -> 127i8\n+\n+    let fail = 0b1000_0001i8; //~WARNING literal out of range for i8\n+\n+    let fail = 0x8000_0000_0000_0000i64; //~WARNING literal out of range for i64\n+\n+    let fail = 0x1_FFFF_FFFFu32; //~WARNING literal out of range for u32\n+\n+    let fail: i128 = 0x8000_0000_0000_0000_0000_0000_0000_0000;\n+    //~^ WARNING literal out of range for i128\n+\n+    let fail = 0x8FFF_FFFF_FFFF_FFFE; //~WARNING literal out of range for i32\n+\n+    let fail = -0b1111_1111i8; //~WARNING literal out of range for i8\n+}"}, {"sha": "d3fcb1335e20968e4ff28f98be747b39d32cdfbe", "filename": "src/test/ui/lint/type-overflow.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/813ac2c36b9b5ed788a36418a3a192782f5fb9ef/src%2Ftest%2Fui%2Flint%2Ftype-overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/813ac2c36b9b5ed788a36418a3a192782f5fb9ef/src%2Ftest%2Fui%2Flint%2Ftype-overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ftype-overflow.stderr?ref=813ac2c36b9b5ed788a36418a3a192782f5fb9ef", "patch": "@@ -0,0 +1,58 @@\n+warning: literal out of range for i8\n+  --> $DIR/type-overflow.rs:16:17\n+   |\n+LL |     let error = 255i8; //~WARNING literal out of range for i8\n+   |                 ^^^^^\n+   |\n+   = note: #[warn(overflowing_literals)] on by default\n+\n+warning: literal out of range for i8\n+  --> $DIR/type-overflow.rs:21:16\n+   |\n+LL |     let fail = 0b1000_0001i8; //~WARNING literal out of range for i8\n+   |                ^^^^^^^^^^^^^ help: consider using `u8` instead: `0b1000_0001u8`\n+   |\n+   = note: the literal `0b1000_0001i8` (decimal `129`) does not fit into an `i8` and will become `-127i8`\n+\n+warning: literal out of range for i64\n+  --> $DIR/type-overflow.rs:23:16\n+   |\n+LL |     let fail = 0x8000_0000_0000_0000i64; //~WARNING literal out of range for i64\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `u64` instead: `0x8000_0000_0000_0000u64`\n+   |\n+   = note: the literal `0x8000_0000_0000_0000i64` (decimal `9223372036854775808`) does not fit into an `i64` and will become `-9223372036854775808i64`\n+\n+warning: literal out of range for u32\n+  --> $DIR/type-overflow.rs:25:16\n+   |\n+LL |     let fail = 0x1_FFFF_FFFFu32; //~WARNING literal out of range for u32\n+   |                ^^^^^^^^^^^^^^^^ help: consider using `u64` instead: `0x1_FFFF_FFFFu64`\n+   |\n+   = note: the literal `0x1_FFFF_FFFFu32` (decimal `8589934591`) does not fit into an `u32` and will become `4294967295u32`\n+\n+warning: literal out of range for i128\n+  --> $DIR/type-overflow.rs:27:22\n+   |\n+LL |     let fail: i128 = 0x8000_0000_0000_0000_0000_0000_0000_0000;\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the literal `0x8000_0000_0000_0000_0000_0000_0000_0000` (decimal `170141183460469231731687303715884105728`) does not fit into an `i128` and will become `-170141183460469231731687303715884105728i128`\n+   = help: consider using `u128` instead\n+\n+warning: literal out of range for i32\n+  --> $DIR/type-overflow.rs:30:16\n+   |\n+LL |     let fail = 0x8FFF_FFFF_FFFF_FFFE; //~WARNING literal out of range for i32\n+   |                ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the literal `0x8FFF_FFFF_FFFF_FFFE` (decimal `10376293541461622782`) does not fit into an `i32` and will become `-2i32`\n+   = help: consider using `i128` instead\n+\n+warning: literal out of range for i8\n+  --> $DIR/type-overflow.rs:32:17\n+   |\n+LL |     let fail = -0b1111_1111i8; //~WARNING literal out of range for i8\n+   |                 ^^^^^^^^^^^^^ help: consider using `i16` instead: `0b1111_1111i16`\n+   |\n+   = note: the literal `0b1111_1111i8` (decimal `255`) does not fit into an `i8` and will become `-1i8`\n+"}]}