{"sha": "ebe6c38a44ebeebeceed8159b149ce9399d7b883", "node_id": "C_kwDOAAsO6NoAKGViZTZjMzhhNDRlYmVlYmVjZWVkODE1OWIxNDljZTkzOTlkN2I4ODM", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-03T11:06:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-03T11:06:06Z"}, "message": "Merge #10438\n\n10438: minor: Simplify r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "22fc336e892dff50f4a3791a0544a00d1349204f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22fc336e892dff50f4a3791a0544a00d1349204f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebe6c38a44ebeebeceed8159b149ce9399d7b883", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhWY6eCRBK7hj4Ov3rIwAAIjcIAD+R3rUwZ6QRTQPwZCfyqC/o\nwMPos6sqBjr2BmKGD9hblq2PwNBp4HJvI0xZUWQmN5BVnHYuNsS1xnFuvEfl/lM5\nNdIuoZph6SKeZMp9iVtdmahnjg0PjtxQkvWJQLKd0PY9WhxioUExg6czMbPYvxqS\nTId5vcBh15pm9bqnZesCfHtYMbdpRVeYj5+YfKiYje4g5UCSBY/KEbhc5a1CkV1w\n86r7Z6qUFfTBLdMRxEpj1j5bWarbmthUNmRKh62b7NdaVsrX+a9mLWI48W8rs1LJ\nm3kBD2qa2plp8xDoMPQIZRJ3Udn1+GePim1MNsMlqlHgbilHsvoVfG4Vjqu5pzc=\n=nW3c\n-----END PGP SIGNATURE-----\n", "payload": "tree 22fc336e892dff50f4a3791a0544a00d1349204f\nparent 0618a6f1841fccf5d63ddd349540a92eb24c87f8\nparent 0943c4be8b141fd9164e50b591a4219bd2939923\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1633259166 +0000\ncommitter GitHub <noreply@github.com> 1633259166 +0000\n\nMerge #10438\n\n10438: minor: Simplify r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebe6c38a44ebeebeceed8159b149ce9399d7b883", "html_url": "https://github.com/rust-lang/rust/commit/ebe6c38a44ebeebeceed8159b149ce9399d7b883", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebe6c38a44ebeebeceed8159b149ce9399d7b883/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0618a6f1841fccf5d63ddd349540a92eb24c87f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0618a6f1841fccf5d63ddd349540a92eb24c87f8", "html_url": "https://github.com/rust-lang/rust/commit/0618a6f1841fccf5d63ddd349540a92eb24c87f8"}, {"sha": "0943c4be8b141fd9164e50b591a4219bd2939923", "url": "https://api.github.com/repos/rust-lang/rust/commits/0943c4be8b141fd9164e50b591a4219bd2939923", "html_url": "https://github.com/rust-lang/rust/commit/0943c4be8b141fd9164e50b591a4219bd2939923"}], "stats": {"total": 234, "additions": 91, "deletions": 143}, "files": [{"sha": "e83210f4f937f4036f7ce274dce739d528e69e2c", "filename": "crates/ide/src/call_hierarchy.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ebe6c38a44ebeebeceed8159b149ce9399d7b883/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe6c38a44ebeebeceed8159b149ce9399d7b883/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs?ref=ebe6c38a44ebeebeceed8159b149ce9399d7b883", "patch": "@@ -4,7 +4,6 @@ use indexmap::IndexMap;\n \n use hir::Semantics;\n use ide_db::{\n-    call_info::FnCallNode,\n     defs::{Definition, NameClass, NameRefClass},\n     helpers::pick_best_token,\n     search::FileReference,\n@@ -101,23 +100,27 @@ pub(crate) fn outgoing_calls(db: &RootDatabase, position: FilePosition) -> Optio\n             _ => None,\n         })\n         .flatten()\n-        .filter_map(|node| FnCallNode::with_node_exact(&node))\n+        .filter_map(ast::CallableExpr::cast)\n         .filter_map(|call_node| {\n-            let name_ref = call_node.name_ref()?;\n-            let func_target = match call_node {\n-                FnCallNode::CallExpr(expr) => {\n-                    let callable = sema.type_of_expr(&expr.expr()?)?.original.as_callable(db)?;\n+            let (nav_target, range) = match call_node {\n+                ast::CallableExpr::Call(call) => {\n+                    let expr = call.expr()?;\n+                    let callable = sema.type_of_expr(&expr)?.original.as_callable(db)?;\n                     match callable.kind() {\n-                        hir::CallableKind::Function(it) => it.try_to_nav(db),\n+                        hir::CallableKind::Function(it) => {\n+                            let range = expr.syntax().text_range();\n+                            it.try_to_nav(db).zip(Some(range))\n+                        }\n                         _ => None,\n                     }\n                 }\n-                FnCallNode::MethodCallExpr(expr) => {\n+                ast::CallableExpr::MethodCall(expr) => {\n+                    let range = expr.name_ref()?.syntax().text_range();\n                     let function = sema.resolve_method_call(&expr)?;\n-                    function.try_to_nav(db)\n+                    function.try_to_nav(db).zip(Some(range))\n                 }\n             }?;\n-            Some((func_target, name_ref.syntax().text_range()))\n+            Some((nav_target, range))\n         })\n         .for_each(|(nav, range)| calls.add(nav, range));\n "}, {"sha": "64e5c23f7cb5babb89c380e17a0e45e01fe06ea4", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ebe6c38a44ebeebeceed8159b149ce9399d7b883/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe6c38a44ebeebeceed8159b149ce9399d7b883/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=ebe6c38a44ebeebeceed8159b149ce9399d7b883", "patch": "@@ -51,27 +51,6 @@ pub(crate) fn generate_function(acc: &mut Assists, ctx: &AssistContext) -> Optio\n     gen_fn(acc, ctx).or_else(|| gen_method(acc, ctx))\n }\n \n-enum FuncExpr {\n-    Func(ast::CallExpr),\n-    Method(ast::MethodCallExpr),\n-}\n-\n-impl FuncExpr {\n-    fn arg_list(&self) -> Option<ast::ArgList> {\n-        match self {\n-            FuncExpr::Func(fn_call) => fn_call.arg_list(),\n-            FuncExpr::Method(m_call) => m_call.arg_list(),\n-        }\n-    }\n-\n-    fn syntax(&self) -> &SyntaxNode {\n-        match self {\n-            FuncExpr::Func(fn_call) => fn_call.syntax(),\n-            FuncExpr::Method(m_call) => m_call.syntax(),\n-        }\n-    }\n-}\n-\n fn gen_fn(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n     let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n@@ -254,7 +233,8 @@ impl FunctionBuilder {\n         let needs_pub = target_module.is_some();\n         let target_module = target_module.or_else(|| current_module(target.syntax(), ctx))?;\n         let fn_name = make::name(fn_name);\n-        let (type_params, params) = fn_args(ctx, target_module, FuncExpr::Func(call.clone()))?;\n+        let (type_params, params) =\n+            fn_args(ctx, target_module, ast::CallableExpr::Call(call.clone()))?;\n \n         let await_expr = call.syntax().parent().and_then(ast::AwaitExpr::cast);\n         let is_async = await_expr.is_some();\n@@ -284,7 +264,8 @@ impl FunctionBuilder {\n         let needs_pub =\n             !module_is_descendant(&current_module(call.syntax(), ctx)?, &target_module, ctx);\n         let fn_name = make::name(&name.text());\n-        let (type_params, params) = fn_args(ctx, target_module, FuncExpr::Method(call.clone()))?;\n+        let (type_params, params) =\n+            fn_args(ctx, target_module, ast::CallableExpr::MethodCall(call.clone()))?;\n \n         let await_expr = call.syntax().parent().and_then(ast::AwaitExpr::cast);\n         let is_async = await_expr.is_some();\n@@ -392,7 +373,7 @@ fn get_fn_target(\n             file = in_file;\n             target\n         }\n-        None => next_space_for_fn_after_call_site(FuncExpr::Func(call))?,\n+        None => next_space_for_fn_after_call_site(ast::CallableExpr::Call(call))?,\n     };\n     Some((target.clone(), file, get_insert_offset(&target)))\n }\n@@ -438,7 +419,7 @@ impl GeneratedFunctionTarget {\n fn fn_args(\n     ctx: &AssistContext,\n     target_module: hir::Module,\n-    call: FuncExpr,\n+    call: ast::CallableExpr,\n ) -> Option<(Option<ast::GenericParamList>, ast::ParamList)> {\n     let mut arg_names = Vec::new();\n     let mut arg_types = Vec::new();\n@@ -468,8 +449,8 @@ fn fn_args(\n         None,\n         make::param_list(\n             match call {\n-                FuncExpr::Func(_) => None,\n-                FuncExpr::Method(_) => Some(make::self_param()),\n+                ast::CallableExpr::Call(_) => None,\n+                ast::CallableExpr::MethodCall(_) => Some(make::self_param()),\n             },\n             params,\n         ),\n@@ -553,7 +534,7 @@ fn fn_arg_type(\n /// directly after the current block\n /// We want to write the generated function directly after\n /// fns, impls or macro calls, but inside mods\n-fn next_space_for_fn_after_call_site(expr: FuncExpr) -> Option<GeneratedFunctionTarget> {\n+fn next_space_for_fn_after_call_site(expr: ast::CallableExpr) -> Option<GeneratedFunctionTarget> {\n     let mut ancestors = expr.syntax().ancestors().peekable();\n     let mut last_ancestor: Option<SyntaxNode> = None;\n     while let Some(next_ancestor) = ancestors.next() {"}, {"sha": "b3dc95df41ebe7587562ab11facd4f8bd6e0661f", "filename": "crates/ide_assists/src/handlers/inline_call.rs", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ebe6c38a44ebeebeceed8159b149ce9399d7b883/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe6c38a44ebeebeceed8159b149ce9399d7b883/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=ebe6c38a44ebeebeceed8159b149ce9399d7b883", "patch": "@@ -12,7 +12,7 @@ use ide_db::{\n use itertools::{izip, Itertools};\n use syntax::{\n     ast::{self, edit_in_place::Indent, HasArgList, PathExpr},\n-    ted, AstNode, SyntaxNode,\n+    ted, AstNode,\n };\n \n use crate::{\n@@ -178,7 +178,7 @@ pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     let name_ref: ast::NameRef = ctx.find_node_at_offset()?;\n     let call_info = CallInfo::from_name_ref(name_ref.clone())?;\n     let (function, label) = match &call_info.node {\n-        CallExprNode::Call(call) => {\n+        ast::CallableExpr::Call(call) => {\n             let path = match call.expr()? {\n                 ast::Expr::PathExpr(path) => path.path(),\n                 _ => None,\n@@ -190,7 +190,7 @@ pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n             };\n             (function, format!(\"Inline `{}`\", path))\n         }\n-        CallExprNode::MethodCallExpr(call) => {\n+        ast::CallableExpr::MethodCall(call) => {\n             (ctx.sema.resolve_method_call(call)?, format!(\"Inline `{}`\", name_ref))\n         }\n     };\n@@ -223,31 +223,17 @@ pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n \n             builder.replace_ast(\n                 match call_info.node {\n-                    CallExprNode::Call(it) => ast::Expr::CallExpr(it),\n-                    CallExprNode::MethodCallExpr(it) => ast::Expr::MethodCallExpr(it),\n+                    ast::CallableExpr::Call(it) => ast::Expr::CallExpr(it),\n+                    ast::CallableExpr::MethodCall(it) => ast::Expr::MethodCallExpr(it),\n                 },\n                 replacement,\n             );\n         },\n     )\n }\n \n-enum CallExprNode {\n-    Call(ast::CallExpr),\n-    MethodCallExpr(ast::MethodCallExpr),\n-}\n-\n-impl CallExprNode {\n-    fn syntax(&self) -> &SyntaxNode {\n-        match self {\n-            CallExprNode::Call(it) => it.syntax(),\n-            CallExprNode::MethodCallExpr(it) => it.syntax(),\n-        }\n-    }\n-}\n-\n struct CallInfo {\n-    node: CallExprNode,\n+    node: ast::CallableExpr,\n     arguments: Vec<ast::Expr>,\n     generic_arg_list: Option<ast::GenericArgList>,\n }\n@@ -261,7 +247,7 @@ impl CallInfo {\n             arguments.extend(call.arg_list()?.args());\n             Some(CallInfo {\n                 generic_arg_list: call.generic_arg_list(),\n-                node: CallExprNode::MethodCallExpr(call),\n+                node: ast::CallableExpr::MethodCall(call),\n                 arguments,\n             })\n         } else if let Some(segment) = ast::PathSegment::cast(parent) {\n@@ -271,7 +257,7 @@ impl CallInfo {\n \n             Some(CallInfo {\n                 arguments: call.arg_list()?.args().collect(),\n-                node: CallExprNode::Call(call),\n+                node: ast::CallableExpr::Call(call),\n                 generic_arg_list: segment.generic_arg_list(),\n             })\n         } else {\n@@ -367,8 +353,9 @@ fn inline(\n                 ted::replace(usage.syntax(), &replacement.syntax().clone_for_update());\n             }\n         };\n-        // izip confuses RA due to our lack of hygiene info currently losing us typeinfo\n+        // izip confuses RA due to our lack of hygiene info currently losing us type info causing incorrect errors\n         let usages: &[ast::PathExpr] = &*usages;\n+        let expr: &ast::Expr = expr;\n         match usages {\n             // inline single use closure arguments\n             [usage]\n@@ -414,8 +401,8 @@ fn inline(\n     }\n \n     let original_indentation = match node {\n-        CallExprNode::Call(it) => it.indent_level(),\n-        CallExprNode::MethodCallExpr(it) => it.indent_level(),\n+        ast::CallableExpr::Call(it) => it.indent_level(),\n+        ast::CallableExpr::MethodCall(it) => it.indent_level(),\n     };\n     body.reindent_to(original_indentation);\n "}, {"sha": "922a411aed14fb58771157c455064770f054599e", "filename": "crates/ide_db/src/call_info.rs", "status": "modified", "additions": 17, "deletions": 77, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/ebe6c38a44ebeebeceed8159b149ce9399d7b883/crates%2Fide_db%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe6c38a44ebeebeceed8159b149ce9399d7b883/crates%2Fide_db%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fcall_info.rs?ref=ebe6c38a44ebeebeceed8159b149ce9399d7b883", "patch": "@@ -6,7 +6,7 @@ use stdx::format_to;\n use syntax::{\n     algo,\n     ast::{self, HasArgList, HasName},\n-    match_ast, AstNode, Direction, SyntaxNode, SyntaxToken, TextRange, TextSize,\n+    AstNode, Direction, SyntaxToken, TextRange, TextSize,\n };\n \n use crate::RootDatabase;\n@@ -25,9 +25,11 @@ impl CallInfo {\n     pub fn parameter_labels(&self) -> impl Iterator<Item = &str> + '_ {\n         self.parameters.iter().map(move |&it| &self.signature[it])\n     }\n+\n     pub fn parameter_ranges(&self) -> &[TextRange] {\n         &self.parameters\n     }\n+\n     fn push_param(&mut self, param: &str) {\n         if !self.signature.ends_with('(') {\n             self.signature.push_str(\", \");\n@@ -115,31 +117,24 @@ fn call_info_impl(\n     token: SyntaxToken,\n ) -> Option<(hir::Callable, Option<usize>)> {\n     // Find the calling expression and it's NameRef\n-    let calling_node = FnCallNode::with_node(&token.parent()?)?;\n+    let parent = token.parent()?;\n+    let calling_node = parent.ancestors().filter_map(ast::CallableExpr::cast).find(|it| {\n+        it.arg_list()\n+            .map_or(false, |it| it.syntax().text_range().contains(token.text_range().start()))\n+    })?;\n \n     let callable = match &calling_node {\n-        FnCallNode::CallExpr(call) => {\n-            sema.type_of_expr(&call.expr()?)?.adjusted().as_callable(sema.db)?\n+        ast::CallableExpr::Call(call) => {\n+            let expr = call.expr()?;\n+            sema.type_of_expr(&expr)?.adjusted().as_callable(sema.db)\n         }\n-        FnCallNode::MethodCallExpr(call) => sema.resolve_method_call_as_callable(call)?,\n-    };\n+        ast::CallableExpr::MethodCall(call) => sema.resolve_method_call_as_callable(call),\n+    }?;\n     let active_param = if let Some(arg_list) = calling_node.arg_list() {\n-        // Number of arguments specified at the call site\n-        let num_args_at_callsite = arg_list.args().count();\n-\n-        let arg_list_range = arg_list.syntax().text_range();\n-        if !arg_list_range.contains_inclusive(token.text_range().start()) {\n-            cov_mark::hit!(call_info_bad_offset);\n-            return None;\n-        }\n-        let param = std::cmp::min(\n-            num_args_at_callsite,\n-            arg_list\n-                .args()\n-                .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n-                .count(),\n-        );\n-\n+        let param = arg_list\n+            .args()\n+            .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n+            .count();\n         Some(param)\n     } else {\n         None\n@@ -175,60 +170,5 @@ impl ActiveParameter {\n     }\n }\n \n-#[derive(Debug)]\n-pub enum FnCallNode {\n-    CallExpr(ast::CallExpr),\n-    MethodCallExpr(ast::MethodCallExpr),\n-}\n-\n-impl FnCallNode {\n-    fn with_node(syntax: &SyntaxNode) -> Option<FnCallNode> {\n-        syntax.ancestors().find_map(|node| {\n-            match_ast! {\n-                match node {\n-                    ast::CallExpr(it) => Some(FnCallNode::CallExpr(it)),\n-                    ast::MethodCallExpr(it) => {\n-                        let arg_list = it.arg_list()?;\n-                        if !arg_list.syntax().text_range().contains_range(syntax.text_range()) {\n-                            return None;\n-                        }\n-                        Some(FnCallNode::MethodCallExpr(it))\n-                    },\n-                    _ => None,\n-                }\n-            }\n-        })\n-    }\n-\n-    pub fn with_node_exact(node: &SyntaxNode) -> Option<FnCallNode> {\n-        match_ast! {\n-            match node {\n-                ast::CallExpr(it) => Some(FnCallNode::CallExpr(it)),\n-                ast::MethodCallExpr(it) => Some(FnCallNode::MethodCallExpr(it)),\n-                _ => None,\n-            }\n-        }\n-    }\n-\n-    pub fn name_ref(&self) -> Option<ast::NameRef> {\n-        match self {\n-            FnCallNode::CallExpr(call_expr) => Some(match call_expr.expr()? {\n-                ast::Expr::PathExpr(path_expr) => path_expr.path()?.segment()?.name_ref()?,\n-                _ => return None,\n-            }),\n-            FnCallNode::MethodCallExpr(call_expr) => {\n-                call_expr.syntax().children().find_map(ast::NameRef::cast)\n-            }\n-        }\n-    }\n-\n-    fn arg_list(&self) -> Option<ast::ArgList> {\n-        match self {\n-            FnCallNode::CallExpr(expr) => expr.arg_list(),\n-            FnCallNode::MethodCallExpr(expr) => expr.arg_list(),\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests;"}, {"sha": "8cdfcd027a3066d8e7bed28b3201dfa719f3525a", "filename": "crates/ide_db/src/call_info/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ebe6c38a44ebeebeceed8159b149ce9399d7b883/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe6c38a44ebeebeceed8159b149ce9399d7b883/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs?ref=ebe6c38a44ebeebeceed8159b149ce9399d7b883", "patch": "@@ -362,7 +362,6 @@ pub fn foo(mut r: WriteHandler<()>) {\n \n #[test]\n fn call_info_bad_offset() {\n-    cov_mark::check!(call_info_bad_offset);\n     check(\n         r#\"\n fn foo(x: u32, y: u32) -> u32 {x + y}"}, {"sha": "8732593af9cf380fdec82b725e5d9e401a949e18", "filename": "crates/syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebe6c38a44ebeebeceed8159b149ce9399d7b883/crates%2Fsyntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe6c38a44ebeebeceed8159b149ce9399d7b883/crates%2Fsyntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast.rs?ref=ebe6c38a44ebeebeceed8159b149ce9399d7b883", "patch": "@@ -18,7 +18,7 @@ use crate::{\n };\n \n pub use self::{\n-    expr_ext::{ArrayExprKind, BlockModifier, ElseBranch, LiteralKind},\n+    expr_ext::{ArrayExprKind, BlockModifier, CallableExpr, ElseBranch, LiteralKind},\n     generated::{nodes::*, tokens::*},\n     node_ext::{\n         AttrKind, FieldKind, Macro, NameLike, NameOrNameRef, PathSegmentKind, SelfParamKind,"}, {"sha": "f421f34b3dc4b5e9b2018615726fcb326bf3ce24", "filename": "crates/syntax/src/ast/expr_ext.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ebe6c38a44ebeebeceed8159b149ce9399d7b883/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe6c38a44ebeebeceed8159b149ce9399d7b883/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs?ref=ebe6c38a44ebeebeceed8159b149ce9399d7b883", "patch": "@@ -10,7 +10,7 @@ use crate::{\n     },\n     AstToken,\n     SyntaxKind::*,\n-    SyntaxToken, T,\n+    SyntaxNode, SyntaxToken, T,\n };\n \n impl ast::HasAttrs for ast::Expr {}\n@@ -312,3 +312,41 @@ impl ast::RecordExprField {\n         self.syntax().ancestors().find_map(ast::RecordExpr::cast).unwrap()\n     }\n }\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum CallableExpr {\n+    Call(ast::CallExpr),\n+    MethodCall(ast::MethodCallExpr),\n+}\n+\n+impl ast::HasAttrs for CallableExpr {}\n+impl ast::HasArgList for CallableExpr {}\n+\n+impl AstNode for CallableExpr {\n+    fn can_cast(kind: parser::SyntaxKind) -> bool\n+    where\n+        Self: Sized,\n+    {\n+        ast::CallExpr::can_cast(kind) || ast::MethodCallExpr::can_cast(kind)\n+    }\n+\n+    fn cast(syntax: SyntaxNode) -> Option<Self>\n+    where\n+        Self: Sized,\n+    {\n+        if let Some(it) = ast::CallExpr::cast(syntax.clone()) {\n+            Some(Self::Call(it))\n+        } else if let Some(it) = ast::MethodCallExpr::cast(syntax.clone()) {\n+            Some(Self::MethodCall(it))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            Self::Call(it) => it.syntax(),\n+            Self::MethodCall(it) => it.syntax(),\n+        }\n+    }\n+}"}]}