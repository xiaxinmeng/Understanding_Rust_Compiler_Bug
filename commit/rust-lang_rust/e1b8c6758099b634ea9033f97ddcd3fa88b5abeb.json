{"sha": "e1b8c6758099b634ea9033f97ddcd3fa88b5abeb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxYjhjNjc1ODA5OWI2MzRlYTkwMzNmOTdkZGNkM2ZhODhiNWFiZWI=", "commit": {"author": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-06-23T22:57:59Z"}, "committer": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-06-24T04:02:45Z"}, "message": "Improve the SHA-1 implementation\n\n* Rename struct Sha1State to Sha1\n* Remove all use of @ types\n* Use fixed length vectors\n* Move all of the inner functions from inside sha1() to top level, private functions\n* Sha1 instances are now created via Sha1::new()\n* Update all constant names to uppercase\n* Remove unecessary assert_eq!s\n* Remove check_vec_eq() helper function; use vec::eq() instead", "tree": {"sha": "6928e2a55656fe6f10a748bf5e02bfa2b5ed36cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6928e2a55656fe6f10a748bf5e02bfa2b5ed36cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1b8c6758099b634ea9033f97ddcd3fa88b5abeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1b8c6758099b634ea9033f97ddcd3fa88b5abeb", "html_url": "https://github.com/rust-lang/rust/commit/e1b8c6758099b634ea9033f97ddcd3fa88b5abeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1b8c6758099b634ea9033f97ddcd3fa88b5abeb/comments", "author": null, "committer": null, "parents": [{"sha": "c5400a8830c0115af06c1a5fe4d04f6ba5f6751d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5400a8830c0115af06c1a5fe4d04f6ba5f6751d", "html_url": "https://github.com/rust-lang/rust/commit/c5400a8830c0115af06c1a5fe4d04f6ba5f6751d"}], "stats": {"total": 443, "additions": 206, "deletions": 237}, "files": [{"sha": "01e210803cf38ec55d542a9ca522b1061c6b8005", "filename": "src/libextra/crypto/sha1.rs", "status": "modified", "additions": 203, "deletions": 234, "changes": 437, "blob_url": "https://github.com/rust-lang/rust/blob/e1b8c6758099b634ea9033f97ddcd3fa88b5abeb/src%2Flibextra%2Fcrypto%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b8c6758099b634ea9033f97ddcd3fa88b5abeb/src%2Flibextra%2Fcrypto%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha1.rs?ref=e1b8c6758099b634ea9033f97ddcd3fa88b5abeb", "patch": "@@ -25,258 +25,237 @@\n use core::prelude::*;\n \n use core::uint;\n-use core::vec;\n \n /*\n  * A SHA-1 implementation derived from Paul E. Jones's reference\n  * implementation, which is written for clarity, not speed. At some\n  * point this will want to be rewritten.\n  */\n \n-/// The SHA-1 interface\n-trait Sha1 {\n-    /// Provide message input as bytes\n-    fn input(&mut self, &[u8]);\n-    /// Provide message input as string\n-    fn input_str(&mut self, &str);\n-    /**\n-     * Read the digest as a vector of 20 bytes. After calling this no further\n-     * input may be provided until reset is called.\n-     */\n-    fn result(&mut self) -> ~[u8];\n-    /**\n-     * Read the digest as a hex string. After calling this no further\n-     * input may be provided until reset is called.\n-     */\n-    fn result_str(&mut self) -> ~str;\n-    /// Reset the SHA-1 state for reuse\n-    fn reset(&mut self);\n-}\n-\n // Some unexported constants\n-static digest_buf_len: uint = 5u;\n-static msg_block_len: uint = 64u;\n-static work_buf_len: uint = 80u;\n-static k0: u32 = 0x5A827999u32;\n-static k1: u32 = 0x6ED9EBA1u32;\n-static k2: u32 = 0x8F1BBCDCu32;\n-static k3: u32 = 0xCA62C1D6u32;\n-\n+static DIGEST_BUF_LEN: uint = 5u;\n+static MSG_BLOCK_LEN: uint = 64u;\n+static WORK_BUF_LEN: uint = 80u;\n+static K0: u32 = 0x5A827999u32;\n+static K1: u32 = 0x6ED9EBA1u32;\n+static K2: u32 = 0x8F1BBCDCu32;\n+static K3: u32 = 0xCA62C1D6u32;\n \n-/// Construct a `sha` object\n-pub fn sha1() -> @Sha1 {\n-    struct Sha1State\n-        { h: ~[u32],\n-          len_low: u32,\n-          len_high: u32,\n-          msg_block: ~[u8],\n-          msg_block_idx: uint,\n-          computed: bool,\n-          work_buf: @mut ~[u32]};\n+/// Structure representing the state of a Sha1 computation\n+pub struct Sha1 {\n+    priv h: [u32, ..DIGEST_BUF_LEN],\n+    priv len_low: u32,\n+    priv len_high: u32,\n+    priv msg_block: [u8, ..MSG_BLOCK_LEN],\n+    priv msg_block_idx: uint,\n+    priv computed: bool,\n+    priv work_buf: [u32, ..WORK_BUF_LEN]\n+}\n \n-    fn add_input(st: &mut Sha1State, msg: &[u8]) {\n-        assert!((!st.computed));\n-        for msg.iter().advance |element| {\n-            st.msg_block[st.msg_block_idx] = *element;\n-            st.msg_block_idx += 1u;\n-            st.len_low += 8u32;\n-            if st.len_low == 0u32 {\n-                st.len_high += 1u32;\n-                if st.len_high == 0u32 {\n-                    // FIXME: Need better failure mode (#2346)\n-                    fail!();\n-                }\n+fn add_input(st: &mut Sha1, msg: &[u8]) {\n+    assert!((!st.computed));\n+    for msg.iter().advance |element| {\n+        st.msg_block[st.msg_block_idx] = *element;\n+        st.msg_block_idx += 1;\n+        st.len_low += 8;\n+        if st.len_low == 0 {\n+            st.len_high += 1;\n+            if st.len_high == 0 {\n+                // FIXME: Need better failure mode (#2346)\n+                fail!();\n             }\n-            if st.msg_block_idx == msg_block_len { process_msg_block(st); }\n         }\n+        if st.msg_block_idx == MSG_BLOCK_LEN { process_msg_block(st); }\n     }\n-    fn process_msg_block(st: &mut Sha1State) {\n-        assert_eq!(st.h.len(), digest_buf_len);\n-        assert_eq!(st.work_buf.len(), work_buf_len);\n-        let mut t: int; // Loop counter\n-        let w = st.work_buf;\n+}\n \n-        // Initialize the first 16 words of the vector w\n-        t = 0;\n-        while t < 16 {\n-            let mut tmp;\n-            tmp = (st.msg_block[t * 4] as u32) << 24u32;\n-            tmp = tmp | (st.msg_block[t * 4 + 1] as u32) << 16u32;\n-            tmp = tmp | (st.msg_block[t * 4 + 2] as u32) << 8u32;\n-            tmp = tmp | (st.msg_block[t * 4 + 3] as u32);\n-            w[t] = tmp;\n-            t += 1;\n-        }\n+fn process_msg_block(st: &mut Sha1) {\n+    let mut t: int; // Loop counter\n+    let mut w = st.work_buf;\n \n-        // Initialize the rest of vector w\n-        while t < 80 {\n-            let val = w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16];\n-            w[t] = circular_shift(1u32, val);\n-            t += 1;\n-        }\n-        let mut a = st.h[0];\n-        let mut b = st.h[1];\n-        let mut c = st.h[2];\n-        let mut d = st.h[3];\n-        let mut e = st.h[4];\n-        let mut temp: u32;\n-        t = 0;\n-        while t < 20 {\n-            temp = circular_shift(5u32, a) + (b & c | !b & d) + e + w[t] + k0;\n-            e = d;\n-            d = c;\n-            c = circular_shift(30u32, b);\n-            b = a;\n-            a = temp;\n-            t += 1;\n-        }\n-        while t < 40 {\n-            temp = circular_shift(5u32, a) + (b ^ c ^ d) + e + w[t] + k1;\n-            e = d;\n-            d = c;\n-            c = circular_shift(30u32, b);\n-            b = a;\n-            a = temp;\n-            t += 1;\n-        }\n-        while t < 60 {\n-            temp =\n-                circular_shift(5u32, a) + (b & c | b & d | c & d) + e + w[t] +\n-                    k2;\n-            e = d;\n-            d = c;\n-            c = circular_shift(30u32, b);\n-            b = a;\n-            a = temp;\n-            t += 1;\n-        }\n-        while t < 80 {\n-            temp = circular_shift(5u32, a) + (b ^ c ^ d) + e + w[t] + k3;\n-            e = d;\n-            d = c;\n-            c = circular_shift(30u32, b);\n-            b = a;\n-            a = temp;\n-            t += 1;\n-        }\n-        st.h[0] = st.h[0] + a;\n-        st.h[1] = st.h[1] + b;\n-        st.h[2] = st.h[2] + c;\n-        st.h[3] = st.h[3] + d;\n-        st.h[4] = st.h[4] + e;\n-        st.msg_block_idx = 0u;\n+    // Initialize the first 16 words of the vector w\n+    t = 0;\n+    while t < 16 {\n+        let mut tmp;\n+        tmp = (st.msg_block[t * 4] as u32) << 24u32;\n+        tmp = tmp | (st.msg_block[t * 4 + 1] as u32) << 16u32;\n+        tmp = tmp | (st.msg_block[t * 4 + 2] as u32) << 8u32;\n+        tmp = tmp | (st.msg_block[t * 4 + 3] as u32);\n+        w[t] = tmp;\n+        t += 1;\n     }\n-    fn circular_shift(bits: u32, word: u32) -> u32 {\n-        return word << bits | word >> 32u32 - bits;\n+\n+    // Initialize the rest of vector w\n+    while t < 80 {\n+        let val = w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16];\n+        w[t] = circular_shift(1, val);\n+        t += 1;\n     }\n-    fn mk_result(st: &mut Sha1State) -> ~[u8] {\n-        if !(*st).computed { pad_msg(st); (*st).computed = true; }\n-        let mut rs: ~[u8] = ~[];\n-        for st.h.mut_iter().advance |ptr_hpart| {\n-            let hpart = *ptr_hpart;\n-            let a = (hpart >> 24u32 & 0xFFu32) as u8;\n-            let b = (hpart >> 16u32 & 0xFFu32) as u8;\n-            let c = (hpart >> 8u32 & 0xFFu32) as u8;\n-            let d = (hpart & 0xFFu32) as u8;\n-            rs = vec::append(copy rs, [a, b, c, d]);\n-        }\n-        return rs;\n+    let mut a = st.h[0];\n+    let mut b = st.h[1];\n+    let mut c = st.h[2];\n+    let mut d = st.h[3];\n+    let mut e = st.h[4];\n+    let mut temp: u32;\n+    t = 0;\n+    while t < 20 {\n+        temp = circular_shift(5, a) + (b & c | !b & d) + e + w[t] + K0;\n+        e = d;\n+        d = c;\n+        c = circular_shift(30, b);\n+        b = a;\n+        a = temp;\n+        t += 1;\n+    }\n+    while t < 40 {\n+        temp = circular_shift(5, a) + (b ^ c ^ d) + e + w[t] + K1;\n+        e = d;\n+        d = c;\n+        c = circular_shift(30, b);\n+        b = a;\n+        a = temp;\n+        t += 1;\n+    }\n+    while t < 60 {\n+        temp =\n+            circular_shift(5, a) + (b & c | b & d | c & d) + e + w[t] +\n+                K2;\n+        e = d;\n+        d = c;\n+        c = circular_shift(30, b);\n+        b = a;\n+        a = temp;\n+        t += 1;\n+    }\n+    while t < 80 {\n+        temp = circular_shift(5, a) + (b ^ c ^ d) + e + w[t] + K3;\n+        e = d;\n+        d = c;\n+        c = circular_shift(30, b);\n+        b = a;\n+        a = temp;\n+        t += 1;\n+    }\n+    st.h[0] = st.h[0] + a;\n+    st.h[1] = st.h[1] + b;\n+    st.h[2] = st.h[2] + c;\n+    st.h[3] = st.h[3] + d;\n+    st.h[4] = st.h[4] + e;\n+    st.msg_block_idx = 0;\n+}\n+\n+fn circular_shift(bits: u32, word: u32) -> u32 {\n+    return word << bits | word >> 32u32 - bits;\n+}\n+\n+fn mk_result(st: &mut Sha1) -> ~[u8] {\n+    if !st.computed { pad_msg(st); st.computed = true; }\n+    let mut rs: ~[u8] = ~[];\n+    for st.h.mut_iter().advance |ptr_hpart| {\n+        let hpart = *ptr_hpart;\n+        let a = (hpart >> 24u32 & 0xFFu32) as u8;\n+        let b = (hpart >> 16u32 & 0xFFu32) as u8;\n+        let c = (hpart >> 8u32 & 0xFFu32) as u8;\n+        let d = (hpart & 0xFFu32) as u8;\n+        rs = vec::append(copy rs, [a, b, c, d]);\n     }\n+    return rs;\n+}\n \n+/*\n+ * According to the standard, the message must be padded to an even\n+ * 512 bits.  The first padding bit must be a '1'.  The last 64 bits\n+ * represent the length of the original message.  All bits in between\n+ * should be 0.  This function will pad the message according to those\n+ * rules by filling the msg_block vector accordingly.  It will also\n+ * call process_msg_block() appropriately.  When it returns, it\n+ * can be assumed that the message digest has been computed.\n+ */\n+fn pad_msg(st: &mut Sha1) {\n     /*\n-     * According to the standard, the message must be padded to an even\n-     * 512 bits.  The first padding bit must be a '1'.  The last 64 bits\n-     * represent the length of the original message.  All bits in between\n-     * should be 0.  This function will pad the message according to those\n-     * rules by filling the msg_block vector accordingly.  It will also\n-     * call process_msg_block() appropriately.  When it returns, it\n-     * can be assumed that the message digest has been computed.\n+     * Check to see if the current message block is too small to hold\n+     * the initial padding bits and length.  If so, we will pad the\n+     * block, process it, and then continue padding into a second block.\n      */\n-    fn pad_msg(st: &mut Sha1State) {\n-        assert_eq!((*st).msg_block.len(), msg_block_len);\n-\n-        /*\n-         * Check to see if the current message block is too small to hold\n-         * the initial padding bits and length.  If so, we will pad the\n-         * block, process it, and then continue padding into a second block.\n-         */\n-        if (*st).msg_block_idx > 55u {\n-            (*st).msg_block[(*st).msg_block_idx] = 0x80u8;\n-            (*st).msg_block_idx += 1u;\n-            while (*st).msg_block_idx < msg_block_len {\n-                (*st).msg_block[(*st).msg_block_idx] = 0u8;\n-                (*st).msg_block_idx += 1u;\n-            }\n-            process_msg_block(st);\n-        } else {\n-            (*st).msg_block[(*st).msg_block_idx] = 0x80u8;\n-            (*st).msg_block_idx += 1u;\n-        }\n-        while (*st).msg_block_idx < 56u {\n-            (*st).msg_block[(*st).msg_block_idx] = 0u8;\n-            (*st).msg_block_idx += 1u;\n+    if st.msg_block_idx > 55 {\n+        st.msg_block[st.msg_block_idx] = 0x80;\n+        st.msg_block_idx += 1;\n+        while st.msg_block_idx < MSG_BLOCK_LEN {\n+            st.msg_block[st.msg_block_idx] = 0;\n+            st.msg_block_idx += 1;\n         }\n-\n-        // Store the message length as the last 8 octets\n-        (*st).msg_block[56] = ((*st).len_high >> 24u32 & 0xFFu32) as u8;\n-        (*st).msg_block[57] = ((*st).len_high >> 16u32 & 0xFFu32) as u8;\n-        (*st).msg_block[58] = ((*st).len_high >> 8u32 & 0xFFu32) as u8;\n-        (*st).msg_block[59] = ((*st).len_high & 0xFFu32) as u8;\n-        (*st).msg_block[60] = ((*st).len_low >> 24u32 & 0xFFu32) as u8;\n-        (*st).msg_block[61] = ((*st).len_low >> 16u32 & 0xFFu32) as u8;\n-        (*st).msg_block[62] = ((*st).len_low >> 8u32 & 0xFFu32) as u8;\n-        (*st).msg_block[63] = ((*st).len_low & 0xFFu32) as u8;\n         process_msg_block(st);\n+    } else {\n+        st.msg_block[st.msg_block_idx] = 0x80;\n+        st.msg_block_idx += 1;\n+    }\n+    while st.msg_block_idx < 56 {\n+        st.msg_block[st.msg_block_idx] = 0u8;\n+        st.msg_block_idx += 1;\n     }\n \n-    impl Sha1 for Sha1State {\n-        fn reset(&mut self) {\n-            assert_eq!(self.h.len(), digest_buf_len);\n-            self.len_low = 0u32;\n-            self.len_high = 0u32;\n-            self.msg_block_idx = 0u;\n-            self.h[0] = 0x67452301u32;\n-            self.h[1] = 0xEFCDAB89u32;\n-            self.h[2] = 0x98BADCFEu32;\n-            self.h[3] = 0x10325476u32;\n-            self.h[4] = 0xC3D2E1F0u32;\n-            self.computed = false;\n-        }\n-        fn input(&mut self, msg: &[u8]) { add_input(self, msg); }\n-        fn input_str(&mut self, msg: &str) {\n-            add_input(self, msg.as_bytes());\n-        }\n-        fn result(&mut self) -> ~[u8] { return mk_result(self); }\n-        fn result_str(&mut self) -> ~str {\n-            let rr = mk_result(self);\n-            let mut s = ~\"\";\n-            for rr.iter().advance |b| {\n-                let hex = uint::to_str_radix(*b as uint, 16u);\n-                if hex.len() == 1 {\n-                    s += \"0\";\n-                }\n-                s += hex;\n+    // Store the message length as the last 8 octets\n+    st.msg_block[56] = (st.len_high >> 24u32 & 0xFFu32) as u8;\n+    st.msg_block[57] = (st.len_high >> 16u32 & 0xFFu32) as u8;\n+    st.msg_block[58] = (st.len_high >> 8u32 & 0xFFu32) as u8;\n+    st.msg_block[59] = (st.len_high & 0xFFu32) as u8;\n+    st.msg_block[60] = (st.len_low >> 24u32 & 0xFFu32) as u8;\n+    st.msg_block[61] = (st.len_low >> 16u32 & 0xFFu32) as u8;\n+    st.msg_block[62] = (st.len_low >> 8u32 & 0xFFu32) as u8;\n+    st.msg_block[63] = (st.len_low & 0xFFu32) as u8;\n+    process_msg_block(st);\n+}\n+\n+impl Sha1 {\n+    /// Construct a `sha` object\n+    pub fn new() -> Sha1 {\n+        let mut st = Sha1 {\n+            h: [0u32, ..DIGEST_BUF_LEN],\n+            len_low: 0u32,\n+            len_high: 0u32,\n+            msg_block: [0u8, ..MSG_BLOCK_LEN],\n+            msg_block_idx: 0,\n+            computed: false,\n+            work_buf: [0u32, ..WORK_BUF_LEN]\n+        };\n+        st.reset();\n+        return st;\n+    }\n+    pub fn reset(&mut self) {\n+        self.len_low = 0;\n+        self.len_high = 0;\n+        self.msg_block_idx = 0;\n+        self.h[0] = 0x67452301u32;\n+        self.h[1] = 0xEFCDAB89u32;\n+        self.h[2] = 0x98BADCFEu32;\n+        self.h[3] = 0x10325476u32;\n+        self.h[4] = 0xC3D2E1F0u32;\n+        self.computed = false;\n+    }\n+    pub fn input(&mut self, msg: &[u8]) { add_input(self, msg); }\n+    pub fn input_str(&mut self, msg: &str) {\n+        add_input(self, msg.as_bytes());\n+    }\n+    pub fn result(&mut self) -> ~[u8] { return mk_result(self); }\n+    pub fn result_str(&mut self) -> ~str {\n+        let rr = mk_result(self);\n+        let mut s = ~\"\";\n+        for rr.iter().advance() |b| {\n+            let hex = uint::to_str_radix(*b as uint, 16u);\n+            if hex.len() == 1 {\n+                s += \"0\";\n             }\n-            return s;\n+            s += hex;\n         }\n+        return s;\n     }\n-    let st = Sha1State {\n-         h: vec::from_elem(digest_buf_len, 0u32),\n-         len_low: 0u32,\n-         len_high: 0u32,\n-         msg_block: vec::from_elem(msg_block_len, 0u8),\n-         msg_block_idx: 0u,\n-         computed: false,\n-         work_buf: @mut vec::from_elem(work_buf_len, 0u32)\n-    };\n-    let mut sh = @st as @Sha1;\n-    sh.reset();\n-    return sh;\n }\n \n #[cfg(test)]\n mod tests {\n-    use sha1;\n+    use core::vec;\n+\n+    use sha1::Sha1;\n \n     #[test]\n     fn test() {\n@@ -361,24 +340,14 @@ mod tests {\n             },\n         ];\n         let tests = fips_180_1_tests + wikipedia_tests;\n-        fn check_vec_eq(v0: ~[u8], v1: ~[u8]) {\n-            assert_eq!(v0.len(), v1.len());\n-            let len = v0.len();\n-            let mut i = 0u;\n-            while i < len {\n-                let a = v0[i];\n-                let b = v1[i];\n-                assert_eq!(a, b);\n-                i += 1u;\n-            }\n-        }\n+\n         // Test that it works when accepting the message all at once\n \n-        let mut sh = sha1::sha1();\n+        let mut sh = ~Sha1::new();\n         for tests.iter().advance |t| {\n             sh.input_str(t.input);\n             let out = sh.result();\n-            check_vec_eq(copy t.output, out);\n+            assert!(vec::eq(t.output, out));\n \n             let out_str = sh.result_str();\n             assert_eq!(out_str.len(), 40);\n@@ -398,7 +367,7 @@ mod tests {\n                 left = left - take;\n             }\n             let out = sh.result();\n-            check_vec_eq(copy t.output, out);\n+            assert!(vec::eq(t.output, out));\n \n             let out_str = sh.result_str();\n             assert_eq!(out_str.len(), 40);"}, {"sha": "2ebf00c485efaf96b54b9ad844804c0f4e7b835c", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1b8c6758099b634ea9033f97ddcd3fa88b5abeb/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b8c6758099b634ea9033f97ddcd3fa88b5abeb/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=e1b8c6758099b634ea9033f97ddcd3fa88b5abeb", "patch": "@@ -13,7 +13,7 @@\n use core::prelude::*;\n \n use json;\n-use sha1;\n+use sha1::Sha1;\n use serialize::{Encoder, Encodable, Decoder, Decodable};\n use sort;\n \n@@ -248,13 +248,13 @@ fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n }\n \n fn digest<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n-    let mut sha = sha1::sha1();\n+    let mut sha = Sha1::new();\n     sha.input_str(json_encode(t));\n     sha.result_str()\n }\n \n fn digest_file(path: &Path) -> ~str {\n-    let mut sha = sha1::sha1();\n+    let mut sha = Sha1::new();\n     let s = io::read_whole_file_str(path);\n     sha.input_str(*s.get_ref());\n     sha.result_str()"}]}