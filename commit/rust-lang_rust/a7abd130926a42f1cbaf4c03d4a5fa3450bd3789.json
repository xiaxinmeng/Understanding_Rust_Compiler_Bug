{"sha": "a7abd130926a42f1cbaf4c03d4a5fa3450bd3789", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3YWJkMTMwOTI2YTQyZjFjYmFmNGMwM2Q0YTVmYTM0NTBiZDM3ODk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-27T10:01:49Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-27T10:01:49Z"}, "message": "make Ord doc style consistent with the other two; explain which properties are ensured by default impls", "tree": {"sha": "7da1aed7157c38a9ec85d9f7a9e04e82199d54bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7da1aed7157c38a9ec85d9f7a9e04e82199d54bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7abd130926a42f1cbaf4c03d4a5fa3450bd3789", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7abd130926a42f1cbaf4c03d4a5fa3450bd3789", "html_url": "https://github.com/rust-lang/rust/commit/a7abd130926a42f1cbaf4c03d4a5fa3450bd3789", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7abd130926a42f1cbaf4c03d4a5fa3450bd3789/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cfc1874b526fd8a681ebfaf64c554077586c8b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cfc1874b526fd8a681ebfaf64c554077586c8b1", "html_url": "https://github.com/rust-lang/rust/commit/1cfc1874b526fd8a681ebfaf64c554077586c8b1"}], "stats": {"total": 43, "additions": 26, "deletions": 17}, "files": [{"sha": "a17cd632583358c23835bad7d42d1431f8e251fd", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a7abd130926a42f1cbaf4c03d4a5fa3450bd3789/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7abd130926a42f1cbaf4c03d4a5fa3450bd3789/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=a7abd130926a42f1cbaf4c03d4a5fa3450bd3789", "patch": "@@ -35,8 +35,10 @@ use self::Ordering::*;\n /// so floating point types implement `PartialEq` but not [`trait@Eq`].\n ///\n /// Implementations must ensure that `eq` and `ne` are consistent with each other:\n-/// `a != b` if and only if `!(a == b)`.\n-/// This is ensured by the default implementation of `ne`.\n+///\n+/// - `a != b` if and only if `!(a == b)`\n+///   (ensured by the default implementation).\n+///\n /// If [`PartialOrd`] or [`Ord`] are also implemented for `Self` and `Rhs`, their methods must also\n /// be consistent with `PartialEq` (see the documentation of those traits for the exact\n /// requirememts). It's easy to accidentally make them disagree by deriving some of the traits and\n@@ -633,22 +635,25 @@ impl<T: Clone> Clone for Reverse<T> {\n \n /// Trait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order).\n ///\n-/// An order is a total order if it is (for all `a`, `b` and `c`):\n+/// Implementations must ensure to be consistent with the [`PartialOrd`] implementation, and that\n+/// `max`, `min`, and `clamp` are consistent with `cmp`:\n ///\n-/// - total and asymmetric: exactly one of `a < b`, `a == b` or `a > b` is true; and\n-/// - transitive: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n+/// - `partial_cmp(a, b) == Some(cmp(a, b))`.\n+/// - `max(a, b) == max_by(a, b, cmp)` (ensured by the default implementation).\n+/// - `min(a, b) == min_by(a, b, cmp)` (ensured by the default implementation).\n+/// - For `a.clamp(min, max)`, see the [method docs](#method.clamp)\n+///   (ensured by the default implementation).\n ///\n-/// Implementations of [`PartialEq`], [`PartialOrd`], and `Ord` *must* agree with each other (for\n-/// all `a` and `b`):\n+/// It's easy to accidentally make `cmp` and `partial_cmp` disagree by\n+/// deriving some of the traits and manually implementing others.\n ///\n-/// - `a.partial_cmp(b) == Some(a.cmp(b))`\n-/// - `a.cmp(b) == Ordering::Equal` if and only if `a == b`\n-///   (already follows from the above and the requirements of `PartialOrd`)\n+/// ## Corollaries\n ///\n-/// It's easy to accidentally make them disagree by\n-/// deriving some of the traits and manually implementing others.\n+/// From the above and the requirements of `PartialOrd`, it follows that `<` defines a strict total order.\n+/// This means that for all `a`, `b` and `c`:\n ///\n-/// Furthermore, the `max`, `min`, and `clamp` methods of this trait must be consistent with `cmp`.\n+/// - exactly one of `a < b`, `a == b` or `a > b` is true; and\n+/// - `<` is transitive: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n ///\n /// ## Derivable\n ///\n@@ -839,10 +844,14 @@ impl PartialOrd for Ordering {\n /// the following sense:\n ///\n /// - `a == b` if and only if `partial_cmp(a, b) == Some(Equal)`.\n-/// - `a < b` if and only if `partial_cmp(a, b) == Some(Less)`.\n-/// - `a > b` if and only if `partial_cmp(a, b) == Some(Greater)`.\n-/// - `a <= b` if and only if `a < b || a == b`.\n-/// - `a >= b` if and only if `a > b || a == b`.\n+/// - `a < b` if and only if `partial_cmp(a, b) == Some(Less)`\n+///   (ensured by the default implementation).\n+/// - `a > b` if and only if `partial_cmp(a, b) == Some(Greater)`\n+///   (ensured by the default implementation).\n+/// - `a <= b` if and only if `a < b || a == b`\n+///   (ensured by the default implementation).\n+/// - `a >= b` if and only if `a > b || a == b`\n+///   (ensured by the default implementation).\n /// - `a != b` if and only if `!(a == b)` (already part of `PartialEq`).\n ///\n /// If [`Ord`] is also implemented for `Self` and `Rhs`, it must also be consistent with"}]}