{"sha": "6eb9960d3603aadab62b8f0877e87c63f67001d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlYjk5NjBkMzYwM2FhZGFiNjJiOGYwODc3ZTg3YzYzZjY3MDAxZDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-19T21:02:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-19T21:02:53Z"}, "message": "Auto merge of #39799 - dpc:create_dir_all, r=alexcrichton\n\nFix race condition in fs::create_dir_all\n\nThe code would crash if the directory was created after create_dir_all\nchecked whether the directory already existed.  This was contrary to\nthe documentation which claimed to create the directory if it doesn't\nexist, implying (but not stating) that there would not be a failure\ndue to the directory existing.", "tree": {"sha": "b066bbde2d4dfee622dfe2ea461243153568a6d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b066bbde2d4dfee622dfe2ea461243153568a6d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6eb9960d3603aadab62b8f0877e87c63f67001d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6eb9960d3603aadab62b8f0877e87c63f67001d6", "html_url": "https://github.com/rust-lang/rust/commit/6eb9960d3603aadab62b8f0877e87c63f67001d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6eb9960d3603aadab62b8f0877e87c63f67001d6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38c53f3c2d31e73404545114f0ef42d5711c6403", "url": "https://api.github.com/repos/rust-lang/rust/commits/38c53f3c2d31e73404545114f0ef42d5711c6403", "html_url": "https://github.com/rust-lang/rust/commit/38c53f3c2d31e73404545114f0ef42d5711c6403"}, {"sha": "088696b98fca3c38f109ef97e17bd5403212b10c", "url": "https://api.github.com/repos/rust-lang/rust/commits/088696b98fca3c38f109ef97e17bd5403212b10c", "html_url": "https://github.com/rust-lang/rust/commit/088696b98fca3c38f109ef97e17bd5403212b10c"}], "stats": {"total": 112, "additions": 64, "deletions": 48}, "files": [{"sha": "090753b18c0ba4281c61e2c596d0a4f6f8407329", "filename": "src/librustc/util/fs.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6eb9960d3603aadab62b8f0877e87c63f67001d6/src%2Flibrustc%2Futil%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eb9960d3603aadab62b8f0877e87c63f67001d6/src%2Flibrustc%2Futil%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Ffs.rs?ref=6eb9960d3603aadab62b8f0877e87c63f67001d6", "patch": "@@ -109,23 +109,3 @@ pub fn rename_or_copy_remove<P: AsRef<Path>, Q: AsRef<Path>>(p: P,\n         }\n     }\n }\n-\n-// Like std::fs::create_dir_all, except handles concurrent calls among multiple\n-// threads or processes.\n-pub fn create_dir_racy(path: &Path) -> io::Result<()> {\n-    match fs::create_dir(path) {\n-        Ok(()) => return Ok(()),\n-        Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists => return Ok(()),\n-        Err(ref e) if e.kind() == io::ErrorKind::NotFound => (),\n-        Err(e) => return Err(e),\n-    }\n-    match path.parent() {\n-        Some(p) => try!(create_dir_racy(p)),\n-        None => return Err(io::Error::new(io::ErrorKind::Other, \"failed to create whole tree\")),\n-    }\n-    match fs::create_dir(path) {\n-        Ok(()) => Ok(()),\n-        Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists => Ok(()),\n-        Err(e) => Err(e),\n-    }\n-}"}, {"sha": "2a4a01cd4a453fd1780f7b877940c243550356f1", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eb9960d3603aadab62b8f0877e87c63f67001d6/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eb9960d3603aadab62b8f0877e87c63f67001d6/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=6eb9960d3603aadab62b8f0877e87c63f67001d6", "patch": "@@ -461,7 +461,7 @@ fn generate_session_dir_path(crate_dir: &Path) -> PathBuf {\n }\n \n fn create_dir(sess: &Session, path: &Path, dir_tag: &str) -> Result<(),()> {\n-    match fs_util::create_dir_racy(path) {\n+    match std_fs::create_dir_all(path) {\n         Ok(()) => {\n             debug!(\"{} directory created successfully\", dir_tag);\n             Ok(())"}, {"sha": "581b23d52142d36ecd344d6f190faefda26b04c8", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eb9960d3603aadab62b8f0877e87c63f67001d6/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eb9960d3603aadab62b8f0877e87c63f67001d6/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=6eb9960d3603aadab62b8f0877e87c63f67001d6", "patch": "@@ -884,7 +884,7 @@ pub fn process_crate<'l, 'tcx>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n         },\n     };\n \n-    if let Err(e) = rustc::util::fs::create_dir_racy(&root_path) {\n+    if let Err(e) = std::fs::create_dir_all(&root_path) {\n         tcx.sess.err(&format!(\"Could not create directory {}: {}\",\n                               root_path.display(),\n                               e));"}, {"sha": "ca26dc9527c041e86061ff9c1f11ffbec73827f4", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6eb9960d3603aadab62b8f0877e87c63f67001d6/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eb9960d3603aadab62b8f0877e87c63f67001d6/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=6eb9960d3603aadab62b8f0877e87c63f67001d6", "patch": "@@ -1534,6 +1534,12 @@ pub fn create_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// error conditions for when a directory is being created (after it is\n /// determined to not exist) are outlined by `fs::create_dir`.\n ///\n+/// Notable exception is made for situations where any of the directories\n+/// specified in the `path` could not be created as it was created concurrently.\n+/// Such cases are considered success. In other words: calling `create_dir_all`\n+/// concurrently from multiple threads or processes is guaranteed to not fail\n+/// due to race itself.\n+///\n /// # Examples\n ///\n /// ```\n@@ -1769,11 +1775,25 @@ impl DirBuilder {\n     }\n \n     fn create_dir_all(&self, path: &Path) -> io::Result<()> {\n-        if path == Path::new(\"\") || path.is_dir() { return Ok(()) }\n-        if let Some(p) = path.parent() {\n-            self.create_dir_all(p)?\n+        if path == Path::new(\"\") {\n+            return Ok(())\n+        }\n+\n+        match self.inner.mkdir(path) {\n+            Ok(()) => return Ok(()),\n+            Err(ref e) if e.kind() == io::ErrorKind::NotFound => {}\n+            Err(_) if path.is_dir() => return Ok(()),\n+            Err(e) => return Err(e),\n+        }\n+        match path.parent() {\n+            Some(p) => try!(self.create_dir_all(p)),\n+            None => return Err(io::Error::new(io::ErrorKind::Other, \"failed to create whole tree\")),\n+        }\n+        match self.inner.mkdir(path) {\n+            Ok(()) => Ok(()),\n+            Err(_) if path.is_dir() => Ok(()),\n+            Err(e) => Err(e),\n         }\n-        self.inner.mkdir(path)\n     }\n }\n \n@@ -1793,6 +1813,7 @@ mod tests {\n     use rand::{StdRng, Rng};\n     use str;\n     use sys_common::io::test::{TempDir, tmpdir};\n+    use thread;\n \n     #[cfg(windows)]\n     use os::windows::fs::{symlink_dir, symlink_file};\n@@ -2260,11 +2281,42 @@ mod tests {\n         assert!(result.is_err());\n     }\n \n+    #[test]\n+    fn concurrent_recursive_mkdir() {\n+        for _ in 0..100 {\n+            let dir = tmpdir();\n+            let mut dir = dir.join(\"a\");\n+            for _ in 0..40 {\n+                dir = dir.join(\"a\");\n+            }\n+            let mut join = vec!();\n+            for _ in 0..8 {\n+                let dir = dir.clone();\n+                join.push(thread::spawn(move || {\n+                    check!(fs::create_dir_all(&dir));\n+                }))\n+            }\n+\n+            // No `Display` on result of `join()`\n+            join.drain(..).map(|join| join.join().unwrap()).count();\n+        }\n+    }\n+\n     #[test]\n     fn recursive_mkdir_slash() {\n         check!(fs::create_dir_all(&Path::new(\"/\")));\n     }\n \n+    #[test]\n+    fn recursive_mkdir_dot() {\n+        check!(fs::create_dir_all(&Path::new(\".\")));\n+    }\n+\n+    #[test]\n+    fn recursive_mkdir_empty() {\n+        check!(fs::create_dir_all(&Path::new(\"\")));\n+    }\n+\n     #[test]\n     fn recursive_rmdir() {\n         let tmpdir = tmpdir();"}, {"sha": "2865fa6a79253862af85e76ee76bba779a30c8c0", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6eb9960d3603aadab62b8f0877e87c63f67001d6/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eb9960d3603aadab62b8f0877e87c63f67001d6/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=6eb9960d3603aadab62b8f0877e87c63f67001d6", "patch": "@@ -25,7 +25,7 @@ use util::logv;\n use std::collections::HashSet;\n use std::env;\n use std::fmt;\n-use std::fs::{self, File};\n+use std::fs::{self, File, create_dir_all};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::path::{Path, PathBuf};\n@@ -395,7 +395,7 @@ actual:\\n\\\n \n         let out_dir = self.output_base_name().with_extension(\"pretty-out\");\n         let _ = fs::remove_dir_all(&out_dir);\n-        self.create_dir_racy(&out_dir);\n+        create_dir_all(&out_dir).unwrap();\n \n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let mut args = vec![\"-\".to_owned(),\n@@ -1269,7 +1269,7 @@ actual:\\n\\\n \n     fn compose_and_run_compiler(&self, args: ProcArgs, input: Option<String>) -> ProcRes {\n         if !self.props.aux_builds.is_empty() {\n-            self.create_dir_racy(&self.aux_output_dir_name());\n+            create_dir_all(&self.aux_output_dir_name()).unwrap();\n         }\n \n         let aux_dir = self.aux_output_dir_name();\n@@ -1340,22 +1340,6 @@ actual:\\n\\\n                              input)\n     }\n \n-    // Like std::fs::create_dir_all, except handles concurrent calls among multiple\n-    // threads or processes.\n-    fn create_dir_racy(&self, path: &Path) {\n-        match fs::create_dir(path) {\n-            Ok(()) => return,\n-            Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists => return,\n-            Err(ref e) if e.kind() == io::ErrorKind::NotFound => {}\n-            Err(e) => panic!(\"failed to create dir {:?}: {}\", path, e),\n-        }\n-        self.create_dir_racy(path.parent().unwrap());\n-        match fs::create_dir(path) {\n-            Ok(()) => {}\n-            Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists => {}\n-            Err(e) => panic!(\"failed to create dir {:?}: {}\", path, e),\n-        }\n-    }\n \n     fn compose_and_run(&self,\n                        ProcArgs{ args, prog }: ProcArgs,\n@@ -1435,7 +1419,7 @@ actual:\\n\\\n \n \n                 let mir_dump_dir = self.get_mir_dump_dir();\n-                self.create_dir_racy(mir_dump_dir.as_path());\n+                create_dir_all(mir_dump_dir.as_path()).unwrap();\n                 let mut dir_opt = \"dump-mir-dir=\".to_string();\n                 dir_opt.push_str(mir_dump_dir.to_str().unwrap());\n                 debug!(\"dir_opt: {:?}\", dir_opt);\n@@ -1923,7 +1907,7 @@ actual:\\n\\\n \n         let out_dir = self.output_base_name();\n         let _ = fs::remove_dir_all(&out_dir);\n-        self.create_dir_racy(&out_dir);\n+        create_dir_all(&out_dir).unwrap();\n \n         let proc_res = self.document(&out_dir);\n         if !proc_res.status.success() {\n@@ -2299,7 +2283,7 @@ actual:\\n\\\n         if tmpdir.exists() {\n             self.aggressive_rm_rf(&tmpdir).unwrap();\n         }\n-        self.create_dir_racy(&tmpdir);\n+        create_dir_all(&tmpdir).unwrap();\n \n         let host = &self.config.host;\n         let make = if host.contains(\"bitrig\") || host.contains(\"dragonfly\") ||"}]}