{"sha": "58fd6ab90db3eb68c94695e1254a73e57bc44658", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4ZmQ2YWI5MGRiM2ViNjhjOTQ2OTVlMTI1NGE3M2U1N2JjNDQ2NTg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-02-28T21:09:09Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-03-02T06:40:52Z"}, "message": "libsyntax: Mechanically change `~[T]` to `Vec<T>`", "tree": {"sha": "51078e799ec82df848205dce6f32a8f1c0c312f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51078e799ec82df848205dce6f32a8f1c0c312f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58fd6ab90db3eb68c94695e1254a73e57bc44658", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58fd6ab90db3eb68c94695e1254a73e57bc44658", "html_url": "https://github.com/rust-lang/rust/commit/58fd6ab90db3eb68c94695e1254a73e57bc44658", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58fd6ab90db3eb68c94695e1254a73e57bc44658/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df40aeccdbfcfb0cc7851c6df24f28fbeccfe046", "url": "https://api.github.com/repos/rust-lang/rust/commits/df40aeccdbfcfb0cc7851c6df24f28fbeccfe046", "html_url": "https://github.com/rust-lang/rust/commit/df40aeccdbfcfb0cc7851c6df24f28fbeccfe046"}], "stats": {"total": 1913, "additions": 934, "deletions": 979}, "files": [{"sha": "eda71552765cc710f4fa9878ae37f085b61e6e62", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::fmt;\n+use std::vec_ng::Vec;\n use std::fmt::Show;\n \n #[deriving(Eq)]\n@@ -117,7 +118,7 @@ pub fn lookup(name: &str) -> Option<Abi> {\n     res\n }\n \n-pub fn all_names() -> ~[&'static str] {\n+pub fn all_names() -> Vec<&'static str> {\n     AbiDatas.map(|d| d.name)\n }\n \n@@ -232,7 +233,7 @@ impl AbiSet {\n     }\n \n     pub fn check_valid(&self) -> Option<(Abi, Abi)> {\n-        let mut abis = ~[];\n+        let mut abis = Vec::new();\n         self.each(|abi| { abis.push(abi); true });\n \n         for (i, abi) in abis.iter().enumerate() {"}, {"sha": "deb125a935d9f33c96bbc9b548685d129e93fdf4", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -98,7 +98,7 @@ pub type SyntaxContext = u32;\n // it should cut down on memory use *a lot*; applying a mark\n // to a tree containing 50 identifiers would otherwise generate\n pub struct SCTable {\n-    table: RefCell<~[SyntaxContext_]>,\n+    table: RefCell<Vec<SyntaxContext_> >,\n     mark_memo: RefCell<HashMap<(SyntaxContext,Mrk),SyntaxContext>>,\n     rename_memo: RefCell<HashMap<(SyntaxContext,Ident,Name),SyntaxContext>>,\n }\n@@ -164,7 +164,7 @@ pub struct Path {\n     /// module (like paths in an import).\n     global: bool,\n     /// The segments in the path: the things separated by `::`.\n-    segments: ~[PathSegment],\n+    segments: Vec<PathSegment> ,\n }\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n@@ -288,12 +288,12 @@ pub enum DefRegion {\n \n // The set of MetaItems that define the compilation environment of the crate,\n // used to drive conditional compilation\n-pub type CrateConfig = ~[@MetaItem];\n+pub type CrateConfig = Vec<@MetaItem> ;\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Crate {\n     module: Mod,\n-    attrs: ~[Attribute],\n+    attrs: Vec<Attribute> ,\n     config: CrateConfig,\n     span: Span,\n }\n@@ -303,7 +303,7 @@ pub type MetaItem = Spanned<MetaItem_>;\n #[deriving(Clone, Encodable, Decodable, Hash)]\n pub enum MetaItem_ {\n     MetaWord(InternedString),\n-    MetaList(InternedString, ~[@MetaItem]),\n+    MetaList(InternedString, Vec<@MetaItem> ),\n     MetaNameValue(InternedString, Lit),\n }\n \n@@ -334,8 +334,8 @@ impl Eq for MetaItem_ {\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Block {\n-    view_items: ~[ViewItem],\n-    stmts: ~[@Stmt],\n+    view_items: Vec<ViewItem> ,\n+    stmts: Vec<@Stmt> ,\n     expr: Option<@Expr>,\n     id: NodeId,\n     rules: BlockCheckMode,\n@@ -373,17 +373,17 @@ pub enum Pat_ {\n     // records this pattern's NodeId in an auxiliary\n     // set (of \"pat_idents that refer to nullary enums\")\n     PatIdent(BindingMode, Path, Option<@Pat>),\n-    PatEnum(Path, Option<~[@Pat]>), /* \"none\" means a * pattern where\n+    PatEnum(Path, Option<Vec<@Pat> >), /* \"none\" means a * pattern where\n                                      * we don't bind the fields to names */\n-    PatStruct(Path, ~[FieldPat], bool),\n-    PatTup(~[@Pat]),\n+    PatStruct(Path, Vec<FieldPat> , bool),\n+    PatTup(Vec<@Pat> ),\n     PatUniq(@Pat),\n     PatRegion(@Pat), // reference pattern\n     PatLit(@Expr),\n     PatRange(@Expr, @Expr),\n     // [a, b, ..i, y, z] is represented as\n     // PatVec(~[a, b], Some(i), ~[y, z])\n-    PatVec(~[@Pat], Option<@Pat>, ~[@Pat])\n+    PatVec(Vec<@Pat> , Option<@Pat>, Vec<@Pat> )\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n@@ -488,7 +488,7 @@ pub enum Decl_ {\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Arm {\n-    pats: ~[@Pat],\n+    pats: Vec<@Pat> ,\n     guard: Option<@Expr>,\n     body: P<Block>,\n }\n@@ -526,10 +526,10 @@ pub enum Expr_ {\n     ExprVstore(@Expr, ExprVstore),\n     // First expr is the place; second expr is the value.\n     ExprBox(@Expr, @Expr),\n-    ExprVec(~[@Expr], Mutability),\n-    ExprCall(@Expr, ~[@Expr]),\n-    ExprMethodCall(Ident, ~[P<Ty>], ~[@Expr]),\n-    ExprTup(~[@Expr]),\n+    ExprVec(Vec<@Expr> , Mutability),\n+    ExprCall(@Expr, Vec<@Expr> ),\n+    ExprMethodCall(Ident, Vec<P<Ty>> , Vec<@Expr> ),\n+    ExprTup(Vec<@Expr> ),\n     ExprBinary(BinOp, @Expr, @Expr),\n     ExprUnary(UnOp, @Expr),\n     ExprLit(@Lit),\n@@ -541,14 +541,14 @@ pub enum Expr_ {\n     // Conditionless loop (can be exited with break, cont, or ret)\n     // FIXME #6993: change to Option<Name>\n     ExprLoop(P<Block>, Option<Ident>),\n-    ExprMatch(@Expr, ~[Arm]),\n+    ExprMatch(@Expr, Vec<Arm> ),\n     ExprFnBlock(P<FnDecl>, P<Block>),\n     ExprProc(P<FnDecl>, P<Block>),\n     ExprBlock(P<Block>),\n \n     ExprAssign(@Expr, @Expr),\n     ExprAssignOp(BinOp, @Expr, @Expr),\n-    ExprField(@Expr, Ident, ~[P<Ty>]),\n+    ExprField(@Expr, Ident, Vec<P<Ty>> ),\n     ExprIndex(@Expr, @Expr),\n \n     /// Expression that looks like a \"name\". For example,\n@@ -569,7 +569,7 @@ pub enum Expr_ {\n     ExprMac(Mac),\n \n     // A struct literal expression.\n-    ExprStruct(Path, ~[Field], Option<@Expr> /* base */),\n+    ExprStruct(Path, Vec<Field> , Option<@Expr> /* base */),\n \n     // A vector literal constructed from one repeated element.\n     ExprRepeat(@Expr /* element */, @Expr /* count */, Mutability),\n@@ -600,14 +600,14 @@ pub enum TokenTree {\n     TTTok(Span, ::parse::token::Token),\n     // a delimited sequence (the delimiters appear as the first\n     // and last elements of the vector)\n-    TTDelim(@~[TokenTree]),\n+    TTDelim(@Vec<TokenTree> ),\n \n     // These only make sense for right-hand-sides of MBE macros:\n \n     // a kleene-style repetition sequence with a span, a TTForest,\n     // an optional separator, and a boolean where true indicates\n     // zero or more (..), and false indicates one or more (+).\n-    TTSeq(Span, @~[TokenTree], Option<::parse::token::Token>, bool),\n+    TTSeq(Span, @Vec<TokenTree> , Option<::parse::token::Token>, bool),\n \n     // a syntactic variable that will be filled in by macro expansion.\n     TTNonterminal(Span, Ident)\n@@ -673,7 +673,7 @@ pub enum Matcher_ {\n     MatchTok(::parse::token::Token),\n     // match repetitions of a sequence: body, separator, zero ok?,\n     // lo, hi position-in-match-array used:\n-    MatchSeq(~[Matcher], Option<::parse::token::Token>, bool, uint, uint),\n+    MatchSeq(Vec<Matcher> , Option<::parse::token::Token>, bool, uint, uint),\n     // parse a Rust NT: name to bind, name of NT, position in match array:\n     MatchNonterminal(Ident, Ident, uint)\n }\n@@ -686,7 +686,7 @@ pub type Mac = Spanned<Mac_>;\n // There's only one flavor, now, so this could presumably be simplified.\n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Mac_ {\n-    MacInvocTT(Path, ~[TokenTree], SyntaxContext),   // new macro-invocation\n+    MacInvocTT(Path, Vec<TokenTree> , SyntaxContext),   // new macro-invocation\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n@@ -700,7 +700,7 @@ pub type Lit = Spanned<Lit_>;\n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Lit_ {\n     LitStr(InternedString, StrStyle),\n-    LitBinary(Rc<~[u8]>),\n+    LitBinary(Rc<Vec<u8> >),\n     LitChar(u32),\n     LitInt(i64, IntTy),\n     LitUint(u64, UintTy),\n@@ -729,7 +729,7 @@ pub struct TypeField {\n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct TypeMethod {\n     ident: Ident,\n-    attrs: ~[Attribute],\n+    attrs: Vec<Attribute> ,\n     purity: Purity,\n     decl: P<FnDecl>,\n     generics: Generics,\n@@ -858,7 +858,7 @@ pub enum Ty_ {\n     TyRptr(Option<Lifetime>, MutTy),\n     TyClosure(@ClosureTy),\n     TyBareFn(@BareFnTy),\n-    TyTup(~[P<Ty>]),\n+    TyTup(Vec<P<Ty>> ),\n     TyPath(Path, Option<OptVec<TyParamBound>>, NodeId), // for #7264; see above\n     TyTypeof(@Expr),\n     // TyInfer means the type should be inferred instead of it having been\n@@ -878,8 +878,8 @@ pub struct InlineAsm {\n     asm: InternedString,\n     asm_str_style: StrStyle,\n     clobbers: InternedString,\n-    inputs: ~[(InternedString, @Expr)],\n-    outputs: ~[(InternedString, @Expr)],\n+    inputs: Vec<(InternedString, @Expr)> ,\n+    outputs: Vec<(InternedString, @Expr)> ,\n     volatile: bool,\n     alignstack: bool,\n     dialect: AsmDialect\n@@ -914,7 +914,7 @@ impl Arg {\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct FnDecl {\n-    inputs: ~[Arg],\n+    inputs: Vec<Arg> ,\n     output: P<Ty>,\n     cf: RetStyle,\n     variadic: bool\n@@ -957,7 +957,7 @@ pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n #[deriving(Eq, Encodable, Decodable, Hash)]\n pub struct Method {\n     ident: Ident,\n-    attrs: ~[Attribute],\n+    attrs: Vec<Attribute> ,\n     generics: Generics,\n     explicit_self: ExplicitSelf,\n     purity: Purity,\n@@ -970,15 +970,15 @@ pub struct Method {\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Mod {\n-    view_items: ~[ViewItem],\n-    items: ~[@Item],\n+    view_items: Vec<ViewItem> ,\n+    items: Vec<@Item> ,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct ForeignMod {\n     abis: AbiSet,\n-    view_items: ~[ViewItem],\n-    items: ~[@ForeignItem],\n+    view_items: Vec<ViewItem> ,\n+    items: Vec<@ForeignItem> ,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n@@ -989,19 +989,19 @@ pub struct VariantArg {\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum VariantKind {\n-    TupleVariantKind(~[VariantArg]),\n+    TupleVariantKind(Vec<VariantArg> ),\n     StructVariantKind(@StructDef),\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct EnumDef {\n-    variants: ~[P<Variant>],\n+    variants: Vec<P<Variant>> ,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Variant_ {\n     name: Ident,\n-    attrs: ~[Attribute],\n+    attrs: Vec<Attribute> ,\n     kind: VariantKind,\n     id: NodeId,\n     disr_expr: Option<@Expr>,\n@@ -1034,13 +1034,13 @@ pub enum ViewPath_ {\n     ViewPathGlob(Path, NodeId),\n \n     // foo::bar::{a,b,c}\n-    ViewPathList(Path, ~[PathListIdent], NodeId)\n+    ViewPathList(Path, Vec<PathListIdent> , NodeId)\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct ViewItem {\n     node: ViewItem_,\n-    attrs: ~[Attribute],\n+    attrs: Vec<Attribute> ,\n     vis: Visibility,\n     span: Span,\n }\n@@ -1052,7 +1052,7 @@ pub enum ViewItem_ {\n     // (containing arbitrary characters) from which to fetch the crate sources\n     // For example, extern crate whatever = \"github.com/mozilla/rust\"\n     ViewItemExternMod(Ident, Option<(InternedString,StrStyle)>, NodeId),\n-    ViewItemUse(~[@ViewPath]),\n+    ViewItemUse(Vec<@ViewPath> ),\n }\n \n // Meta-data associated with an item\n@@ -1109,7 +1109,7 @@ pub struct StructField_ {\n     kind: StructFieldKind,\n     id: NodeId,\n     ty: P<Ty>,\n-    attrs: ~[Attribute],\n+    attrs: Vec<Attribute> ,\n }\n \n pub type StructField = Spanned<StructField_>;\n@@ -1122,7 +1122,7 @@ pub enum StructFieldKind {\n \n #[deriving(Eq, Encodable, Decodable, Hash)]\n pub struct StructDef {\n-    fields: ~[StructField], /* fields, not including ctor */\n+    fields: Vec<StructField> , /* fields, not including ctor */\n     /* ID of the constructor. This is only used for tuple- or enum-like\n      * structs. */\n     ctor_id: Option<NodeId>\n@@ -1135,7 +1135,7 @@ pub struct StructDef {\n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Item {\n     ident: Ident,\n-    attrs: ~[Attribute],\n+    attrs: Vec<Attribute> ,\n     id: NodeId,\n     node: Item_,\n     vis: Visibility,\n@@ -1151,19 +1151,19 @@ pub enum Item_ {\n     ItemTy(P<Ty>, Generics),\n     ItemEnum(EnumDef, Generics),\n     ItemStruct(@StructDef, Generics),\n-    ItemTrait(Generics, ~[TraitRef], ~[TraitMethod]),\n+    ItemTrait(Generics, Vec<TraitRef> , Vec<TraitMethod> ),\n     ItemImpl(Generics,\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n-             ~[@Method]),\n+             Vec<@Method> ),\n     // a macro invocation (which includes macro definition)\n     ItemMac(Mac),\n }\n \n #[deriving(Eq, Encodable, Decodable, Hash)]\n pub struct ForeignItem {\n     ident: Ident,\n-    attrs: ~[Attribute],\n+    attrs: Vec<Attribute> ,\n     node: ForeignItem_,\n     id: NodeId,\n     span: Span,\n@@ -1205,9 +1205,9 @@ mod test {\n     #[test]\n     fn check_asts_encodable() {\n         let e = Crate {\n-            module: Mod {view_items: ~[], items: ~[]},\n-            attrs: ~[],\n-            config: ~[],\n+            module: Mod {view_items: Vec::new(), items: Vec::new()},\n+            attrs: Vec::new(),\n+            config: Vec::new(),\n             span: Span {\n                 lo: BytePos(10),\n                 hi: BytePos(20),"}, {"sha": "2c2b4a6535d4bf199153812cd9924adae2b80673", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -134,7 +134,7 @@ enum MapEntry {\n }\n \n struct InlinedParent {\n-    path: ~[PathElem],\n+    path: Vec<PathElem> ,\n     // Required by NodeTraitMethod and NodeMethod.\n     def_id: DefId\n }\n@@ -185,7 +185,7 @@ pub struct Map {\n     ///\n     /// Also, indexing is pretty quick when you've got a vector and\n     /// plain old integers.\n-    priv map: RefCell<~[MapEntry]>\n+    priv map: RefCell<Vec<MapEntry> >\n }\n \n impl Map {\n@@ -522,7 +522,7 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n }\n \n pub fn map_crate<F: FoldOps>(krate: Crate, fold_ops: F) -> (Crate, Map) {\n-    let map = Map { map: RefCell::new(~[]) };\n+    let map = Map { map: RefCell::new(Vec::new()) };\n     let krate = {\n         let mut cx = Ctx {\n             map: &map,\n@@ -557,7 +557,7 @@ pub fn map_crate<F: FoldOps>(krate: Crate, fold_ops: F) -> (Crate, Map) {\n // crate.  The `path` should be the path to the item but should not include\n // the item itself.\n pub fn map_decoded_item<F: FoldOps>(map: &Map,\n-                                    path: ~[PathElem],\n+                                    path: Vec<PathElem> ,\n                                     fold_ops: F,\n                                     fold: |&mut Ctx<F>| -> InlinedItem)\n                                     -> InlinedItem {"}, {"sha": "1386ac5404b0ace3effd341cd9b888624880c6b2", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -180,8 +180,8 @@ pub fn is_call_expr(e: @Expr) -> bool {\n \n pub fn block_from_expr(e: @Expr) -> P<Block> {\n     P(Block {\n-        view_items: ~[],\n-        stmts: ~[],\n+        view_items: Vec::new(),\n+        stmts: Vec::new(),\n         expr: Some(e),\n         id: e.id,\n         rules: DefaultBlock,\n@@ -193,13 +193,13 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n     ast::Path {\n         span: s,\n         global: false,\n-        segments: ~[\n+        segments: vec!(\n             ast::PathSegment {\n                 identifier: identifier,\n                 lifetimes: opt_vec::Empty,\n                 types: opt_vec::Empty,\n             }\n-        ],\n+        ),\n     }\n }\n \n@@ -216,7 +216,7 @@ pub fn is_unguarded(a: &Arm) -> bool {\n     }\n }\n \n-pub fn unguarded_pat(a: &Arm) -> Option<~[@Pat]> {\n+pub fn unguarded_pat(a: &Arm) -> Option<Vec<@Pat> > {\n     if is_unguarded(a) {\n         Some(/* FIXME (#2543) */ a.pats.clone())\n     } else {\n@@ -241,7 +241,7 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n     token::gensym_ident(pretty)\n }\n \n-pub fn public_methods(ms: ~[@Method]) -> ~[@Method] {\n+pub fn public_methods(ms: Vec<@Method> ) -> Vec<@Method> {\n     ms.move_iter().filter(|m| {\n         match m.vis {\n             Public => true,\n@@ -271,9 +271,9 @@ pub fn trait_method_to_ty_method(method: &TraitMethod) -> TypeMethod {\n }\n \n pub fn split_trait_methods(trait_methods: &[TraitMethod])\n-    -> (~[TypeMethod], ~[@Method]) {\n-    let mut reqd = ~[];\n-    let mut provd = ~[];\n+    -> (Vec<TypeMethod> , Vec<@Method> ) {\n+    let mut reqd = Vec::new();\n+    let mut provd = Vec::new();\n     for trt_method in trait_methods.iter() {\n         match *trt_method {\n             Required(ref tm) => reqd.push((*tm).clone()),\n@@ -724,7 +724,7 @@ pub fn new_rename_internal(id: Ident,\n // FIXME #8215 : currently pub to allow testing\n pub fn new_sctable_internal() -> SCTable {\n     SCTable {\n-        table: RefCell::new(~[EmptyCtxt,IllegalCtxt]),\n+        table: RefCell::new(vec!(EmptyCtxt,IllegalCtxt)),\n         mark_memo: RefCell::new(HashMap::new()),\n         rename_memo: RefCell::new(HashMap::new()),\n     }\n@@ -754,7 +754,7 @@ pub fn display_sctable(table : &SCTable) {\n \n \n /// Add a value to the end of a vec, return its index\n-fn idx_push<T>(vec: &mut ~[T], val: T) -> u32 {\n+fn idx_push<T>(vec: &mut Vec<T> , val: T) -> u32 {\n     vec.push(val);\n     (vec.len() - 1) as u32\n }\n@@ -831,15 +831,15 @@ pub fn resolve_internal(id : Ident,\n }\n \n /// Compute the marks associated with a syntax context.\n-pub fn mtwt_marksof(ctxt: SyntaxContext, stopname: Name) -> ~[Mrk] {\n+pub fn mtwt_marksof(ctxt: SyntaxContext, stopname: Name) -> Vec<Mrk> {\n     marksof(ctxt, stopname, get_sctable())\n }\n \n // the internal function for computing marks\n // it's not clear to me whether it's better to use a [] mutable\n // vector or a cons-list for this.\n-pub fn marksof(ctxt: SyntaxContext, stopname: Name, table: &SCTable) -> ~[Mrk] {\n-    let mut result = ~[];\n+pub fn marksof(ctxt: SyntaxContext, stopname: Name, table: &SCTable) -> Vec<Mrk> {\n+    let mut result = Vec::new();\n     let mut loopvar = ctxt;\n     loop {\n         let table_entry = {\n@@ -881,7 +881,7 @@ pub fn mtwt_outer_mark(ctxt: SyntaxContext) -> Mrk {\n \n /// Push a name... unless it matches the one on top, in which\n /// case pop and discard (so two of the same marks cancel)\n-pub fn xorPush(marks: &mut ~[Mrk], mark: Mrk) {\n+pub fn xorPush(marks: &mut Vec<Mrk> , mark: Mrk) {\n     if (marks.len() > 0) && (getLast(marks) == mark) {\n         marks.pop().unwrap();\n     } else {\n@@ -891,7 +891,7 @@ pub fn xorPush(marks: &mut ~[Mrk], mark: Mrk) {\n \n // get the last element of a mutable array.\n // FIXME #4903: , must be a separate procedure for now.\n-pub fn getLast(arr: &~[Mrk]) -> Mrk {\n+pub fn getLast(arr: &Vec<Mrk> ) -> Mrk {\n     *arr.last().unwrap()\n }\n \n@@ -956,21 +956,21 @@ mod test {\n     }\n \n     #[test] fn xorpush_test () {\n-        let mut s = ~[];\n+        let mut s = Vec::new();\n         xorPush(&mut s, 14);\n-        assert_eq!(s.clone(), ~[14]);\n+        assert_eq!(s.clone(), vec!(14));\n         xorPush(&mut s, 14);\n-        assert_eq!(s.clone(), ~[]);\n+        assert_eq!(s.clone(), Vec::new());\n         xorPush(&mut s, 14);\n-        assert_eq!(s.clone(), ~[14]);\n+        assert_eq!(s.clone(), vec!(14));\n         xorPush(&mut s, 15);\n-        assert_eq!(s.clone(), ~[14, 15]);\n+        assert_eq!(s.clone(), vec!(14, 15));\n         xorPush(&mut s, 16);\n-        assert_eq!(s.clone(), ~[14, 15, 16]);\n+        assert_eq!(s.clone(), vec!(14, 15, 16));\n         xorPush(&mut s, 16);\n-        assert_eq!(s.clone(), ~[14, 15]);\n+        assert_eq!(s.clone(), vec!(14, 15));\n         xorPush(&mut s, 15);\n-        assert_eq!(s.clone(), ~[14]);\n+        assert_eq!(s.clone(), vec!(14));\n     }\n \n     fn id(n: Name, s: SyntaxContext) -> Ident {\n@@ -987,7 +987,7 @@ mod test {\n \n     // unfold a vector of TestSC values into a SCTable,\n     // returning the resulting index\n-    fn unfold_test_sc(tscs : ~[TestSC], tail: SyntaxContext, table: &SCTable)\n+    fn unfold_test_sc(tscs : Vec<TestSC> , tail: SyntaxContext, table: &SCTable)\n         -> SyntaxContext {\n         tscs.rev_iter().fold(tail, |tail : SyntaxContext, tsc : &TestSC|\n                   {match *tsc {\n@@ -996,8 +996,8 @@ mod test {\n     }\n \n     // gather a SyntaxContext back into a vector of TestSCs\n-    fn refold_test_sc(mut sc: SyntaxContext, table : &SCTable) -> ~[TestSC] {\n-        let mut result = ~[];\n+    fn refold_test_sc(mut sc: SyntaxContext, table : &SCTable) -> Vec<TestSC> {\n+        let mut result = Vec::new();\n         loop {\n             let table = table.table.borrow();\n             match table.get()[sc] {\n@@ -1020,7 +1020,7 @@ mod test {\n     #[test] fn test_unfold_refold(){\n         let mut t = new_sctable_internal();\n \n-        let test_sc = ~[M(3),R(id(101,0),14),M(9)];\n+        let test_sc = vec!(M(3),R(id(101,0),14),M(9));\n         assert_eq!(unfold_test_sc(test_sc.clone(),EMPTY_CTXT,&mut t),4);\n         {\n             let table = t.table.borrow();\n@@ -1033,7 +1033,7 @@ mod test {\n \n     // extend a syntax context with a sequence of marks given\n     // in a vector. v[0] will be the outermost mark.\n-    fn unfold_marks(mrks: ~[Mrk], tail: SyntaxContext, table: &SCTable)\n+    fn unfold_marks(mrks: Vec<Mrk> , tail: SyntaxContext, table: &SCTable)\n                     -> SyntaxContext {\n         mrks.rev_iter().fold(tail, |tail:SyntaxContext, mrk:&Mrk|\n                    {new_mark_internal(*mrk,tail,table)})\n@@ -1042,7 +1042,7 @@ mod test {\n     #[test] fn unfold_marks_test() {\n         let mut t = new_sctable_internal();\n \n-        assert_eq!(unfold_marks(~[3,7],EMPTY_CTXT,&mut t),3);\n+        assert_eq!(unfold_marks(vec!(3,7),EMPTY_CTXT,&mut t),3);\n         {\n             let table = t.table.borrow();\n             assert!(table.get()[2] == Mark(7,0));\n@@ -1054,32 +1054,32 @@ mod test {\n         let stopname = 242;\n         let name1 = 243;\n         let mut t = new_sctable_internal();\n-        assert_eq!(marksof (EMPTY_CTXT,stopname,&t),~[]);\n+        assert_eq!(marksof (EMPTY_CTXT,stopname,&t),Vec::new());\n         // FIXME #5074: ANF'd to dodge nested calls\n-        { let ans = unfold_marks(~[4,98],EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof (ans,stopname,&t),~[4,98]);}\n+        { let ans = unfold_marks(vec!(4,98),EMPTY_CTXT,&mut t);\n+         assert_eq! (marksof (ans,stopname,&t),vec!(4,98));}\n         // does xoring work?\n-        { let ans = unfold_marks(~[5,5,16],EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof (ans,stopname,&t), ~[16]);}\n+        { let ans = unfold_marks(vec!(5,5,16),EMPTY_CTXT,&mut t);\n+         assert_eq! (marksof (ans,stopname,&t), vec!(16));}\n         // does nested xoring work?\n-        { let ans = unfold_marks(~[5,10,10,5,16],EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof (ans, stopname,&t), ~[16]);}\n+        { let ans = unfold_marks(vec!(5,10,10,5,16),EMPTY_CTXT,&mut t);\n+         assert_eq! (marksof (ans, stopname,&t), vec!(16));}\n         // rename where stop doesn't match:\n-        { let chain = ~[M(9),\n+        { let chain = vec!(M(9),\n                         R(id(name1,\n                              new_mark_internal (4, EMPTY_CTXT,&mut t)),\n                           100101102),\n-                        M(14)];\n+                        M(14));\n          let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof (ans, stopname, &t), ~[9,14]);}\n+         assert_eq! (marksof (ans, stopname, &t), vec!(9,14));}\n         // rename where stop does match\n         { let name1sc = new_mark_internal(4, EMPTY_CTXT, &mut t);\n-         let chain = ~[M(9),\n+         let chain = vec!(M(9),\n                        R(id(name1, name1sc),\n                          stopname),\n-                       M(14)];\n+                       M(14));\n          let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof (ans, stopname, &t), ~[9]); }\n+         assert_eq! (marksof (ans, stopname, &t), vec!(9)); }\n     }\n \n \n@@ -1090,32 +1090,32 @@ mod test {\n         // - ctxt is MT\n         assert_eq!(resolve_internal(id(a,EMPTY_CTXT),&mut t, &mut rt),a);\n         // - simple ignored marks\n-        { let sc = unfold_marks(~[1,2,3],EMPTY_CTXT,&mut t);\n+        { let sc = unfold_marks(vec!(1,2,3),EMPTY_CTXT,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),a);}\n         // - orthogonal rename where names don't match\n-        { let sc = unfold_test_sc(~[R(id(50,EMPTY_CTXT),51),M(12)],EMPTY_CTXT,&mut t);\n+        { let sc = unfold_test_sc(vec!(R(id(50,EMPTY_CTXT),51),M(12)),EMPTY_CTXT,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),a);}\n         // - rename where names do match, but marks don't\n         { let sc1 = new_mark_internal(1,EMPTY_CTXT,&mut t);\n-         let sc = unfold_test_sc(~[R(id(a,sc1),50),\n+         let sc = unfold_test_sc(vec!(R(id(a,sc1),50),\n                                    M(1),\n-                                   M(2)],\n+                                   M(2)),\n                                  EMPTY_CTXT,&mut t);\n         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), a);}\n         // - rename where names and marks match\n-        { let sc1 = unfold_test_sc(~[M(1),M(2)],EMPTY_CTXT,&mut t);\n-         let sc = unfold_test_sc(~[R(id(a,sc1),50),M(1),M(2)],EMPTY_CTXT,&mut t);\n+        { let sc1 = unfold_test_sc(vec!(M(1),M(2)),EMPTY_CTXT,&mut t);\n+         let sc = unfold_test_sc(vec!(R(id(a,sc1),50),M(1),M(2)),EMPTY_CTXT,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 50); }\n         // - rename where names and marks match by literal sharing\n-        { let sc1 = unfold_test_sc(~[M(1),M(2)],EMPTY_CTXT,&mut t);\n-         let sc = unfold_test_sc(~[R(id(a,sc1),50)],sc1,&mut t);\n+        { let sc1 = unfold_test_sc(vec!(M(1),M(2)),EMPTY_CTXT,&mut t);\n+         let sc = unfold_test_sc(vec!(R(id(a,sc1),50)),sc1,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 50); }\n         // - two renames of the same var.. can only happen if you use\n         // local-expand to prevent the inner binding from being renamed\n         // during the rename-pass caused by the first:\n         println!(\"about to run bad test\");\n-        { let sc = unfold_test_sc(~[R(id(a,EMPTY_CTXT),50),\n-                                    R(id(a,EMPTY_CTXT),51)],\n+        { let sc = unfold_test_sc(vec!(R(id(a,EMPTY_CTXT),50),\n+                                    R(id(a,EMPTY_CTXT),51)),\n                                   EMPTY_CTXT,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 51); }\n         // the simplest double-rename:\n@@ -1126,8 +1126,8 @@ mod test {\n          let sc = new_mark_internal(9,a50_to_a51,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),51);\n          // but mark on the inside does:\n-         let a50_to_a51_b = unfold_test_sc(~[R(id(a,a_to_a50),51),\n-                                              M(9)],\n+         let a50_to_a51_b = unfold_test_sc(vec!(R(id(a,a_to_a50),51),\n+                                              M(9)),\n                                            a_to_a50,\n                                            &mut t);\n          assert_eq!(resolve_internal(id(a,a50_to_a51_b),&mut t, &mut rt),50);}"}, {"sha": "df1ad6381deb1661d2c5b79cac43859cfc5ba0b4", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -146,7 +146,7 @@ pub fn mk_name_value_item(name: InternedString, value: ast::Lit)\n     @dummy_spanned(MetaNameValue(name, value))\n }\n \n-pub fn mk_list_item(name: InternedString, items: ~[@MetaItem]) -> @MetaItem {\n+pub fn mk_list_item(name: InternedString, items: Vec<@MetaItem> ) -> @MetaItem {\n     @dummy_spanned(MetaList(name, items))\n }\n \n@@ -212,12 +212,12 @@ pub fn last_meta_item_value_str_by_name(items: &[@MetaItem], name: &str)\n \n /* Higher-level applications */\n \n-pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n+pub fn sort_meta_items(items: &[@MetaItem]) -> Vec<@MetaItem> {\n     // This is sort of stupid here, but we need to sort by\n     // human-readable strings.\n     let mut v = items.iter()\n         .map(|&mi| (mi.name(), mi))\n-        .collect::<~[(InternedString, @MetaItem)]>();\n+        .collect::<Vec<(InternedString, @MetaItem)> >();\n \n     v.sort_by(|&(ref a, _), &(ref b, _)| a.cmp(b));\n \n@@ -239,8 +239,8 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n  * From a list of crate attributes get only the meta_items that affect crate\n  * linkage\n  */\n-pub fn find_linkage_metas(attrs: &[Attribute]) -> ~[@MetaItem] {\n-    let mut result = ~[];\n+pub fn find_linkage_metas(attrs: &[Attribute]) -> Vec<@MetaItem> {\n+    let mut result = Vec::new();\n     for attr in attrs.iter().filter(|at| at.name().equiv(&(\"link\"))) {\n         match attr.meta().node {\n             MetaList(_, ref items) => result.push_all(*items),"}, {"sha": "8cea8f7278680c1c4d88a901c3c78cebb104a8a4", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -188,8 +188,7 @@ pub type FileName = ~str;\n pub struct FileLines\n {\n     file: @FileMap,\n-    lines: ~[uint]\n-}\n+    lines: Vec<uint> }\n \n /// Identifies an offset of a multi-byte character in a FileMap\n pub struct MultiByteChar {\n@@ -210,9 +209,9 @@ pub struct FileMap {\n     /// The start position of this source in the CodeMap\n     start_pos: BytePos,\n     /// Locations of lines beginnings in the source code\n-    lines: RefCell<~[BytePos]>,\n+    lines: RefCell<Vec<BytePos> >,\n     /// Locations of multi-byte characters in the source code\n-    multibyte_chars: RefCell<~[MultiByteChar]>,\n+    multibyte_chars: RefCell<Vec<MultiByteChar> >,\n }\n \n impl FileMap {\n@@ -257,13 +256,13 @@ impl FileMap {\n }\n \n pub struct CodeMap {\n-    files: RefCell<~[@FileMap]>\n+    files: RefCell<Vec<@FileMap> >\n }\n \n impl CodeMap {\n     pub fn new() -> CodeMap {\n         CodeMap {\n-            files: RefCell::new(~[]),\n+            files: RefCell::new(Vec::new()),\n         }\n     }\n \n@@ -278,8 +277,8 @@ impl CodeMap {\n             name: filename,\n             src: src,\n             start_pos: Pos::from_uint(start_pos),\n-            lines: RefCell::new(~[]),\n-            multibyte_chars: RefCell::new(~[]),\n+            lines: RefCell::new(Vec::new()),\n+            multibyte_chars: RefCell::new(Vec::new()),\n         };\n \n         files.get().push(filemap);\n@@ -330,7 +329,7 @@ impl CodeMap {\n     pub fn span_to_lines(&self, sp: Span) -> @FileLines {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n-        let mut lines = ~[];\n+        let mut lines = Vec::new();\n         for i in range(lo.line - 1u, hi.line as uint) {\n             lines.push(i);\n         };"}, {"sha": "f3dcd61f2405795c4f48c16f5c4bce66ae32f6c8", "filename": "src/libsyntax/crateid.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -48,21 +48,21 @@ impl fmt::Show for CrateId {\n \n impl FromStr for CrateId {\n     fn from_str(s: &str) -> Option<CrateId> {\n-        let pieces: ~[&str] = s.splitn('#', 1).collect();\n+        let pieces: Vec<&str> = s.splitn('#', 1).collect();\n         let path = pieces[0].to_owned();\n \n         if path.starts_with(\"/\") || path.ends_with(\"/\") ||\n             path.starts_with(\".\") || path.is_empty() {\n             return None;\n         }\n \n-        let path_pieces: ~[&str] = path.rsplitn('/', 1).collect();\n+        let path_pieces: Vec<&str> = path.rsplitn('/', 1).collect();\n         let inferred_name = path_pieces[0];\n \n         let (name, version) = if pieces.len() == 1 {\n             (inferred_name.to_owned(), None)\n         } else {\n-            let hash_pieces: ~[&str] = pieces[1].splitn(':', 1).collect();\n+            let hash_pieces: Vec<&str> = pieces[1].splitn(':', 1).collect();\n             let (hash_name, hash_version) = if hash_pieces.len() == 1 {\n                 (\"\", hash_pieces[0])\n             } else {"}, {"sha": "c2d16d8330157512f8f310aefd88d1c79ff4666d", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -46,8 +46,8 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     let mut asm = InternedString::new(\"\");\n     let mut asm_str_style = None;\n-    let mut outputs = ~[];\n-    let mut inputs = ~[];\n+    let mut outputs = Vec::new();\n+    let mut inputs = Vec::new();\n     let mut cons = ~\"\";\n     let mut volatile = false;\n     let mut alignstack = false;\n@@ -119,7 +119,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 }\n             }\n             Clobbers => {\n-                let mut clobs = ~[];\n+                let mut clobs = Vec::new();\n                 while p.token != token::EOF &&\n                       p.token != token::COLON &&\n                       p.token != token::MOD_SEP {"}, {"sha": "85a8be1c87697c7abba72cf796adff81b99378ef", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -74,7 +74,7 @@ pub trait IdentMacroExpander {\n               cx: &mut ExtCtxt,\n               sp: Span,\n               ident: ast::Ident,\n-              token_tree: ~[ast::TokenTree])\n+              token_tree: Vec<ast::TokenTree> )\n               -> MacResult;\n }\n \n@@ -83,14 +83,14 @@ impl IdentMacroExpander for BasicIdentMacroExpander {\n               cx: &mut ExtCtxt,\n               sp: Span,\n               ident: ast::Ident,\n-              token_tree: ~[ast::TokenTree])\n+              token_tree: Vec<ast::TokenTree> )\n               -> MacResult {\n         (self.expander)(cx, sp, ident, token_tree)\n     }\n }\n \n pub type IdentMacroExpanderFn =\n-    fn(&mut ExtCtxt, Span, ast::Ident, ~[ast::TokenTree]) -> MacResult;\n+    fn(&mut ExtCtxt, Span, ast::Ident, Vec<ast::TokenTree> ) -> MacResult;\n \n pub type MacroCrateRegistrationFun =\n     fn(|ast::Name, SyntaxExtension|);\n@@ -154,13 +154,13 @@ impl BlockInfo {\n     pub fn new() -> BlockInfo {\n         BlockInfo {\n             macros_escape: false,\n-            pending_renames: ~[],\n+            pending_renames: Vec::new(),\n         }\n     }\n }\n \n // a list of ident->name renamings\n-pub type RenameList = ~[(ast::Ident,Name)];\n+pub type RenameList = Vec<(ast::Ident,Name)> ;\n \n // The base map of methods for expanding syntax extension\n // AST nodes into full ASTs\n@@ -271,7 +271,7 @@ pub struct MacroCrate {\n \n pub trait CrateLoader {\n     fn load_crate(&mut self, krate: &ast::ViewItem) -> MacroCrate;\n-    fn get_exported_macros(&mut self, crate_num: ast::CrateNum) -> ~[~str];\n+    fn get_exported_macros(&mut self, crate_num: ast::CrateNum) -> Vec<~str> ;\n     fn get_registrar_symbol(&mut self, crate_num: ast::CrateNum) -> Option<~str>;\n }\n \n@@ -284,7 +284,7 @@ pub struct ExtCtxt<'a> {\n     backtrace: Option<@ExpnInfo>,\n     loader: &'a mut CrateLoader,\n \n-    mod_path: ~[ast::Ident],\n+    mod_path: Vec<ast::Ident> ,\n     trace_mac: bool\n }\n \n@@ -296,7 +296,7 @@ impl<'a> ExtCtxt<'a> {\n             cfg: cfg,\n             backtrace: None,\n             loader: loader,\n-            mod_path: ~[],\n+            mod_path: Vec::new(),\n             trace_mac: false\n         }\n     }\n@@ -329,7 +329,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn backtrace(&self) -> Option<@ExpnInfo> { self.backtrace }\n     pub fn mod_push(&mut self, i: ast::Ident) { self.mod_path.push(i); }\n     pub fn mod_pop(&mut self) { self.mod_path.pop().unwrap(); }\n-    pub fn mod_path(&self) -> ~[ast::Ident] { self.mod_path.clone() }\n+    pub fn mod_path(&self) -> Vec<ast::Ident> { self.mod_path.clone() }\n     pub fn bt_push(&mut self, ei: codemap::ExpnInfo) {\n         match ei {\n             ExpnInfo {call_site: cs, callee: ref callee} => {\n@@ -458,11 +458,11 @@ pub fn get_single_str_from_tts(cx: &ExtCtxt,\n /// parsing error, emit a non-fatal error and return None.\n pub fn get_exprs_from_tts(cx: &ExtCtxt,\n                           sp: Span,\n-                          tts: &[ast::TokenTree]) -> Option<~[@ast::Expr]> {\n+                          tts: &[ast::TokenTree]) -> Option<Vec<@ast::Expr> > {\n     let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n                                            cx.cfg(),\n                                            tts.to_owned());\n-    let mut es = ~[];\n+    let mut es = Vec::new();\n     while p.token != token::EOF {\n         if es.len() != 0 && !p.eat(&token::COMMA) {\n             cx.span_err(sp, \"expected token: `,`\");\n@@ -507,12 +507,12 @@ impl Drop for MapChainFrame {\n \n // Only generic to make it easy to test\n pub struct SyntaxEnv {\n-    priv chain: ~[MapChainFrame],\n+    priv chain: Vec<MapChainFrame> ,\n }\n \n impl SyntaxEnv {\n     pub fn new() -> SyntaxEnv {\n-        let mut map = SyntaxEnv { chain: ~[] };\n+        let mut map = SyntaxEnv { chain: Vec::new() };\n         map.push_frame();\n         map\n     }"}, {"sha": "2dc94253a35ff1899f893bb8be91221c9f51a1e8", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 113, "deletions": 117, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -34,14 +34,14 @@ mod syntax {\n \n pub trait AstBuilder {\n     // paths\n-    fn path(&self, span: Span, strs: ~[ast::Ident]) -> ast::Path;\n+    fn path(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path;\n     fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path;\n-    fn path_global(&self, span: Span, strs: ~[ast::Ident]) -> ast::Path;\n+    fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path;\n     fn path_all(&self, sp: Span,\n                 global: bool,\n-                idents: ~[ast::Ident],\n+                idents: Vec<ast::Ident> ,\n                 lifetimes: OptVec<ast::Lifetime>,\n-                types: ~[P<ast::Ty>])\n+                types: Vec<P<ast::Ty>> )\n         -> ast::Path;\n \n     // types\n@@ -61,8 +61,8 @@ pub trait AstBuilder {\n     fn ty_infer(&self, sp: Span) -> P<ast::Ty>;\n     fn ty_nil(&self) -> P<ast::Ty>;\n \n-    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[P<ast::Ty>];\n-    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[P<ast::Ty>];\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n+    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n     fn ty_field_imm(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::TypeField;\n     fn strip_bounds(&self, bounds: &Generics) -> Generics;\n \n@@ -87,11 +87,11 @@ pub trait AstBuilder {\n                       -> @ast::Stmt;\n \n     // blocks\n-    fn block(&self, span: Span, stmts: ~[@ast::Stmt], expr: Option<@ast::Expr>) -> P<ast::Block>;\n+    fn block(&self, span: Span, stmts: Vec<@ast::Stmt> , expr: Option<@ast::Expr>) -> P<ast::Block>;\n     fn block_expr(&self, expr: @ast::Expr) -> P<ast::Block>;\n     fn block_all(&self, span: Span,\n-                 view_items: ~[ast::ViewItem],\n-                 stmts: ~[@ast::Stmt],\n+                 view_items: Vec<ast::ViewItem> ,\n+                 stmts: Vec<@ast::Stmt> ,\n                  expr: Option<@ast::Expr>) -> P<ast::Block>;\n \n     // expressions\n@@ -109,19 +109,19 @@ pub trait AstBuilder {\n     fn expr_addr_of(&self, sp: Span, e: @ast::Expr) -> @ast::Expr;\n     fn expr_mut_addr_of(&self, sp: Span, e: @ast::Expr) -> @ast::Expr;\n     fn expr_field_access(&self, span: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr;\n-    fn expr_call(&self, span: Span, expr: @ast::Expr, args: ~[@ast::Expr]) -> @ast::Expr;\n-    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: ~[@ast::Expr]) -> @ast::Expr;\n-    fn expr_call_global(&self, sp: Span, fn_path: ~[ast::Ident],\n-                        args: ~[@ast::Expr]) -> @ast::Expr;\n+    fn expr_call(&self, span: Span, expr: @ast::Expr, args: Vec<@ast::Expr> ) -> @ast::Expr;\n+    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: Vec<@ast::Expr> ) -> @ast::Expr;\n+    fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident> ,\n+                        args: Vec<@ast::Expr> ) -> @ast::Expr;\n     fn expr_method_call(&self, span: Span,\n                         expr: @ast::Expr, ident: ast::Ident,\n-                        args: ~[@ast::Expr]) -> @ast::Expr;\n+                        args: Vec<@ast::Expr> ) -> @ast::Expr;\n     fn expr_block(&self, b: P<ast::Block>) -> @ast::Expr;\n     fn expr_cast(&self, sp: Span, expr: @ast::Expr, ty: P<ast::Ty>) -> @ast::Expr;\n \n     fn field_imm(&self, span: Span, name: Ident, e: @ast::Expr) -> ast::Field;\n-    fn expr_struct(&self, span: Span, path: ast::Path, fields: ~[ast::Field]) -> @ast::Expr;\n-    fn expr_struct_ident(&self, span: Span, id: ast::Ident, fields: ~[ast::Field]) -> @ast::Expr;\n+    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field> ) -> @ast::Expr;\n+    fn expr_struct_ident(&self, span: Span, id: ast::Ident, fields: Vec<ast::Field> ) -> @ast::Expr;\n \n     fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> @ast::Expr;\n \n@@ -131,9 +131,9 @@ pub trait AstBuilder {\n     fn expr_bool(&self, sp: Span, value: bool) -> @ast::Expr;\n \n     fn expr_vstore(&self, sp: Span, expr: @ast::Expr, vst: ast::ExprVstore) -> @ast::Expr;\n-    fn expr_vec(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr;\n-    fn expr_vec_uniq(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr;\n-    fn expr_vec_slice(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr;\n+    fn expr_vec(&self, sp: Span, exprs: Vec<@ast::Expr> ) -> @ast::Expr;\n+    fn expr_vec_uniq(&self, sp: Span, exprs: Vec<@ast::Expr> ) -> @ast::Expr;\n+    fn expr_vec_slice(&self, sp: Span, exprs: Vec<@ast::Expr> ) -> @ast::Expr;\n     fn expr_str(&self, sp: Span, s: InternedString) -> @ast::Expr;\n     fn expr_str_uniq(&self, sp: Span, s: InternedString) -> @ast::Expr;\n \n@@ -152,55 +152,55 @@ pub trait AstBuilder {\n                               span: Span,\n                               ident: ast::Ident,\n                               bm: ast::BindingMode) -> @ast::Pat;\n-    fn pat_enum(&self, span: Span, path: ast::Path, subpats: ~[@ast::Pat]) -> @ast::Pat;\n+    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<@ast::Pat> ) -> @ast::Pat;\n     fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: ~[ast::FieldPat]) -> @ast::Pat;\n+                  path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> @ast::Pat;\n \n-    fn arm(&self, span: Span, pats: ~[@ast::Pat], expr: @ast::Expr) -> ast::Arm;\n+    fn arm(&self, span: Span, pats: Vec<@ast::Pat> , expr: @ast::Expr) -> ast::Arm;\n     fn arm_unreachable(&self, span: Span) -> ast::Arm;\n \n-    fn expr_match(&self, span: Span, arg: @ast::Expr, arms: ~[ast::Arm]) -> @ast::Expr;\n+    fn expr_match(&self, span: Span, arg: @ast::Expr, arms: Vec<ast::Arm> ) -> @ast::Expr;\n     fn expr_if(&self, span: Span,\n                cond: @ast::Expr, then: @ast::Expr, els: Option<@ast::Expr>) -> @ast::Expr;\n \n     fn lambda_fn_decl(&self, span: Span,\n                       fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> @ast::Expr;\n \n-    fn lambda(&self, span: Span, ids: ~[ast::Ident], blk: P<ast::Block>) -> @ast::Expr;\n+    fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> @ast::Expr;\n     fn lambda0(&self, span: Span, blk: P<ast::Block>) -> @ast::Expr;\n     fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> @ast::Expr;\n \n-    fn lambda_expr(&self, span: Span, ids: ~[ast::Ident], blk: @ast::Expr) -> @ast::Expr;\n+    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , blk: @ast::Expr) -> @ast::Expr;\n     fn lambda_expr_0(&self, span: Span, expr: @ast::Expr) -> @ast::Expr;\n     fn lambda_expr_1(&self, span: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr;\n \n-    fn lambda_stmts(&self, span: Span, ids: ~[ast::Ident], blk: ~[@ast::Stmt]) -> @ast::Expr;\n-    fn lambda_stmts_0(&self, span: Span, stmts: ~[@ast::Stmt]) -> @ast::Expr;\n-    fn lambda_stmts_1(&self, span: Span, stmts: ~[@ast::Stmt], ident: ast::Ident) -> @ast::Expr;\n+    fn lambda_stmts(&self, span: Span, ids: Vec<ast::Ident> , blk: Vec<@ast::Stmt> ) -> @ast::Expr;\n+    fn lambda_stmts_0(&self, span: Span, stmts: Vec<@ast::Stmt> ) -> @ast::Expr;\n+    fn lambda_stmts_1(&self, span: Span, stmts: Vec<@ast::Stmt> , ident: ast::Ident) -> @ast::Expr;\n \n     // items\n     fn item(&self, span: Span,\n-            name: Ident, attrs: ~[ast::Attribute], node: ast::Item_) -> @ast::Item;\n+            name: Ident, attrs: Vec<ast::Attribute> , node: ast::Item_) -> @ast::Item;\n \n     fn arg(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::Arg;\n     // FIXME unused self\n-    fn fn_decl(&self, inputs: ~[ast::Arg], output: P<ast::Ty>) -> P<ast::FnDecl>;\n+    fn fn_decl(&self, inputs: Vec<ast::Arg> , output: P<ast::Ty>) -> P<ast::FnDecl>;\n \n     fn item_fn_poly(&self,\n                     span: Span,\n                     name: Ident,\n-                    inputs: ~[ast::Arg],\n+                    inputs: Vec<ast::Arg> ,\n                     output: P<ast::Ty>,\n                     generics: Generics,\n                     body: P<ast::Block>) -> @ast::Item;\n     fn item_fn(&self,\n                span: Span,\n                name: Ident,\n-               inputs: ~[ast::Arg],\n+               inputs: Vec<ast::Arg> ,\n                output: P<ast::Ty>,\n                body: P<ast::Block>) -> @ast::Item;\n \n-    fn variant(&self, span: Span, name: Ident, tys: ~[P<ast::Ty>]) -> ast::Variant;\n+    fn variant(&self, span: Span, name: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant;\n     fn item_enum_poly(&self,\n                       span: Span,\n                       name: Ident,\n@@ -216,8 +216,8 @@ pub trait AstBuilder {\n     fn item_struct(&self, span: Span, name: Ident, struct_def: ast::StructDef) -> @ast::Item;\n \n     fn item_mod(&self, span: Span,\n-                name: Ident, attrs: ~[ast::Attribute],\n-                vi: ~[ast::ViewItem], items: ~[@ast::Item]) -> @ast::Item;\n+                name: Ident, attrs: Vec<ast::Attribute> ,\n+                vi: Vec<ast::ViewItem> , items: Vec<@ast::Item> ) -> @ast::Item;\n \n     fn item_ty_poly(&self,\n                     span: Span,\n@@ -232,7 +232,7 @@ pub trait AstBuilder {\n     fn meta_list(&self,\n                  sp: Span,\n                  name: InternedString,\n-                 mis: ~[@ast::MetaItem])\n+                 mis: Vec<@ast::MetaItem> )\n                  -> @ast::MetaItem;\n     fn meta_name_value(&self,\n                        sp: Span,\n@@ -241,35 +241,35 @@ pub trait AstBuilder {\n                        -> @ast::MetaItem;\n \n     fn view_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: ~[@ast::ViewPath]) -> ast::ViewItem;\n+                vis: ast::Visibility, vp: Vec<@ast::ViewPath> ) -> ast::ViewItem;\n     fn view_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> ast::ViewItem;\n     fn view_use_simple_(&self, sp: Span, vis: ast::Visibility,\n                         ident: ast::Ident, path: ast::Path) -> ast::ViewItem;\n     fn view_use_list(&self, sp: Span, vis: ast::Visibility,\n-                     path: ~[ast::Ident], imports: &[ast::Ident]) -> ast::ViewItem;\n+                     path: Vec<ast::Ident> , imports: &[ast::Ident]) -> ast::ViewItem;\n     fn view_use_glob(&self, sp: Span,\n-                     vis: ast::Visibility, path: ~[ast::Ident]) -> ast::ViewItem;\n+                     vis: ast::Visibility, path: Vec<ast::Ident> ) -> ast::ViewItem;\n }\n \n impl<'a> AstBuilder for ExtCtxt<'a> {\n-    fn path(&self, span: Span, strs: ~[ast::Ident]) -> ast::Path {\n-        self.path_all(span, false, strs, opt_vec::Empty, ~[])\n+    fn path(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n+        self.path_all(span, false, strs, opt_vec::Empty, Vec::new())\n     }\n     fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path {\n-        self.path(span, ~[id])\n+        self.path(span, vec!(id))\n     }\n-    fn path_global(&self, span: Span, strs: ~[ast::Ident]) -> ast::Path {\n-        self.path_all(span, true, strs, opt_vec::Empty, ~[])\n+    fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n+        self.path_all(span, true, strs, opt_vec::Empty, Vec::new())\n     }\n     fn path_all(&self,\n                 sp: Span,\n                 global: bool,\n-                mut idents: ~[ast::Ident],\n+                mut idents: Vec<ast::Ident> ,\n                 lifetimes: OptVec<ast::Lifetime>,\n-                types: ~[P<ast::Ty>])\n+                types: Vec<P<ast::Ty>> )\n                 -> ast::Path {\n         let last_identifier = idents.pop().unwrap();\n-        let mut segments: ~[ast::PathSegment] = idents.move_iter()\n+        let mut segments: Vec<ast::PathSegment> = idents.move_iter()\n                                                       .map(|ident| {\n             ast::PathSegment {\n                 identifier: ident,\n@@ -335,13 +335,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.ty_path(\n             self.path_all(DUMMY_SP,\n                           true,\n-                          ~[\n+                          vec!(\n                               self.ident_of(\"std\"),\n                               self.ident_of(\"option\"),\n                               self.ident_of(\"Option\")\n-                          ],\n+                          ),\n                           opt_vec::Empty,\n-                          ~[ ty ]), None)\n+                          vec!( ty )), None)\n     }\n \n     fn ty_field_imm(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::TypeField {\n@@ -379,15 +379,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     // these are strange, and probably shouldn't be used outside of\n     // pipes. Specifically, the global version possible generates\n     // incorrect code.\n-    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[P<ast::Ty>] {\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> Vec<P<ast::Ty>> {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_ident(DUMMY_SP, p.ident)))\n     }\n \n-    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[P<ast::Ty>] {\n+    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> Vec<P<ast::Ty>> {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_path(\n-                self.path_global(DUMMY_SP, ~[p.ident]), None)))\n+                self.path_global(DUMMY_SP, vec!(p.ident)), None)))\n     }\n \n     fn strip_bounds(&self, generics: &Generics) -> Generics {\n@@ -459,17 +459,17 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         @respan(sp, ast::StmtDecl(@decl, ast::DUMMY_NODE_ID))\n     }\n \n-    fn block(&self, span: Span, stmts: ~[@ast::Stmt], expr: Option<@Expr>) -> P<ast::Block> {\n-        self.block_all(span, ~[], stmts, expr)\n+    fn block(&self, span: Span, stmts: Vec<@ast::Stmt> , expr: Option<@Expr>) -> P<ast::Block> {\n+        self.block_all(span, Vec::new(), stmts, expr)\n     }\n \n     fn block_expr(&self, expr: @ast::Expr) -> P<ast::Block> {\n-        self.block_all(expr.span, ~[], ~[], Some(expr))\n+        self.block_all(expr.span, Vec::new(), Vec::new(), Some(expr))\n     }\n     fn block_all(&self,\n                  span: Span,\n-                 view_items: ~[ast::ViewItem],\n-                 stmts: ~[@ast::Stmt],\n+                 view_items: Vec<ast::ViewItem> ,\n+                 stmts: Vec<@ast::Stmt> ,\n                  expr: Option<@ast::Expr>) -> P<ast::Block> {\n             P(ast::Block {\n                view_items: view_items,\n@@ -517,7 +517,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_field_access(&self, sp: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr {\n-        self.expr(sp, ast::ExprField(expr, ident, ~[]))\n+        self.expr(sp, ast::ExprField(expr, ident, Vec::new()))\n     }\n     fn expr_addr_of(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n         self.expr(sp, ast::ExprAddrOf(ast::MutImmutable, e))\n@@ -526,35 +526,35 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(sp, ast::ExprAddrOf(ast::MutMutable, e))\n     }\n \n-    fn expr_call(&self, span: Span, expr: @ast::Expr, args: ~[@ast::Expr]) -> @ast::Expr {\n+    fn expr_call(&self, span: Span, expr: @ast::Expr, args: Vec<@ast::Expr> ) -> @ast::Expr {\n         self.expr(span, ast::ExprCall(expr, args))\n     }\n-    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: ~[@ast::Expr]) -> @ast::Expr {\n+    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: Vec<@ast::Expr> ) -> @ast::Expr {\n         self.expr(span, ast::ExprCall(self.expr_ident(span, id), args))\n     }\n-    fn expr_call_global(&self, sp: Span, fn_path: ~[ast::Ident],\n-                      args: ~[@ast::Expr]) -> @ast::Expr {\n+    fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident> ,\n+                      args: Vec<@ast::Expr> ) -> @ast::Expr {\n         let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n         self.expr_call(sp, pathexpr, args)\n     }\n     fn expr_method_call(&self, span: Span,\n                         expr: @ast::Expr,\n                         ident: ast::Ident,\n-                        mut args: ~[@ast::Expr]) -> @ast::Expr {\n+                        mut args: Vec<@ast::Expr> ) -> @ast::Expr {\n         args.unshift(expr);\n-        self.expr(span, ast::ExprMethodCall(ident, ~[], args))\n+        self.expr(span, ast::ExprMethodCall(ident, Vec::new(), args))\n     }\n     fn expr_block(&self, b: P<ast::Block>) -> @ast::Expr {\n         self.expr(b.span, ast::ExprBlock(b))\n     }\n     fn field_imm(&self, span: Span, name: Ident, e: @ast::Expr) -> ast::Field {\n         ast::Field { ident: respan(span, name), expr: e, span: span }\n     }\n-    fn expr_struct(&self, span: Span, path: ast::Path, fields: ~[ast::Field]) -> @ast::Expr {\n+    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field> ) -> @ast::Expr {\n         self.expr(span, ast::ExprStruct(path, fields, None))\n     }\n     fn expr_struct_ident(&self, span: Span,\n-                         id: ast::Ident, fields: ~[ast::Field]) -> @ast::Expr {\n+                         id: ast::Ident, fields: Vec<ast::Field> ) -> @ast::Expr {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n \n@@ -577,13 +577,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_vstore(&self, sp: Span, expr: @ast::Expr, vst: ast::ExprVstore) -> @ast::Expr {\n         self.expr(sp, ast::ExprVstore(expr, vst))\n     }\n-    fn expr_vec(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr {\n+    fn expr_vec(&self, sp: Span, exprs: Vec<@ast::Expr> ) -> @ast::Expr {\n         self.expr(sp, ast::ExprVec(exprs, ast::MutImmutable))\n     }\n-    fn expr_vec_uniq(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr {\n+    fn expr_vec_uniq(&self, sp: Span, exprs: Vec<@ast::Expr> ) -> @ast::Expr {\n         self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::ExprVstoreUniq)\n     }\n-    fn expr_vec_slice(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr {\n+    fn expr_vec_slice(&self, sp: Span, exprs: Vec<@ast::Expr> ) -> @ast::Expr {\n         self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::ExprVstoreSlice)\n     }\n     fn expr_str(&self, sp: Span, s: InternedString) -> @ast::Expr {\n@@ -600,38 +600,34 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n \n     fn expr_some(&self, sp: Span, expr: @ast::Expr) -> @ast::Expr {\n-        let some = ~[\n+        let some = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"option\"),\n-            self.ident_of(\"Some\"),\n-        ];\n-        self.expr_call_global(sp, some, ~[expr])\n+            self.ident_of(\"Some\"));\n+        self.expr_call_global(sp, some, vec!(expr))\n     }\n \n     fn expr_none(&self, sp: Span) -> @ast::Expr {\n-        let none = self.path_global(sp, ~[\n+        let none = self.path_global(sp, vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"option\"),\n-            self.ident_of(\"None\"),\n-        ]);\n+            self.ident_of(\"None\")));\n         self.expr_path(none)\n     }\n \n     fn expr_fail(&self, span: Span, msg: InternedString) -> @ast::Expr {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         self.expr_call_global(\n             span,\n-            ~[\n+            vec!(\n                 self.ident_of(\"std\"),\n                 self.ident_of(\"rt\"),\n-                self.ident_of(\"begin_unwind\"),\n-            ],\n-            ~[\n+                self.ident_of(\"begin_unwind\")),\n+            vec!(\n                 self.expr_str(span, msg),\n                 self.expr_str(span,\n                               token::intern_and_get_ident(loc.file.name)),\n-                self.expr_uint(span, loc.line),\n-            ])\n+                self.expr_uint(span, loc.line)))\n     }\n \n     fn expr_unreachable(&self, span: Span) -> @ast::Expr {\n@@ -662,17 +658,17 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let pat = ast::PatIdent(bm, path, None);\n         self.pat(span, pat)\n     }\n-    fn pat_enum(&self, span: Span, path: ast::Path, subpats: ~[@ast::Pat]) -> @ast::Pat {\n+    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<@ast::Pat> ) -> @ast::Pat {\n         let pat = ast::PatEnum(path, Some(subpats));\n         self.pat(span, pat)\n     }\n     fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: ~[ast::FieldPat]) -> @ast::Pat {\n+                  path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> @ast::Pat {\n         let pat = ast::PatStruct(path, field_pats, false);\n         self.pat(span, pat)\n     }\n \n-    fn arm(&self, _span: Span, pats: ~[@ast::Pat], expr: @ast::Expr) -> ast::Arm {\n+    fn arm(&self, _span: Span, pats: Vec<@ast::Pat> , expr: @ast::Expr) -> ast::Arm {\n         ast::Arm {\n             pats: pats,\n             guard: None,\n@@ -681,10 +677,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn arm_unreachable(&self, span: Span) -> ast::Arm {\n-        self.arm(span, ~[self.pat_wild(span)], self.expr_unreachable(span))\n+        self.arm(span, vec!(self.pat_wild(span)), self.expr_unreachable(span))\n     }\n \n-    fn expr_match(&self, span: Span, arg: @ast::Expr, arms: ~[ast::Arm]) -> @Expr {\n+    fn expr_match(&self, span: Span, arg: @ast::Expr, arms: Vec<ast::Arm> ) -> @Expr {\n         self.expr(span, ast::ExprMatch(arg, arms))\n     }\n \n@@ -698,7 +694,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                       fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> @ast::Expr {\n         self.expr(span, ast::ExprFnBlock(fn_decl, blk))\n     }\n-    fn lambda(&self, span: Span, ids: ~[ast::Ident], blk: P<ast::Block>) -> @ast::Expr {\n+    fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> @ast::Expr {\n         let fn_decl = self.fn_decl(\n             ids.map(|id| self.arg(span, *id, self.ty_infer(span))),\n             self.ty_infer(span));\n@@ -715,7 +711,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         quote_expr!(self, |$ident| $blk_e )\n     }\n \n-    fn lambda_expr(&self, span: Span, ids: ~[ast::Ident], expr: @ast::Expr) -> @ast::Expr {\n+    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , expr: @ast::Expr) -> @ast::Expr {\n         self.lambda(span, ids, self.block_expr(expr))\n     }\n     fn lambda_expr_0(&self, span: Span, expr: @ast::Expr) -> @ast::Expr {\n@@ -725,13 +721,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.lambda1(span, self.block_expr(expr), ident)\n     }\n \n-    fn lambda_stmts(&self, span: Span, ids: ~[ast::Ident], stmts: ~[@ast::Stmt]) -> @ast::Expr {\n+    fn lambda_stmts(&self, span: Span, ids: Vec<ast::Ident> , stmts: Vec<@ast::Stmt> ) -> @ast::Expr {\n         self.lambda(span, ids, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_0(&self, span: Span, stmts: ~[@ast::Stmt]) -> @ast::Expr {\n+    fn lambda_stmts_0(&self, span: Span, stmts: Vec<@ast::Stmt> ) -> @ast::Expr {\n         self.lambda0(span, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_1(&self, span: Span, stmts: ~[@ast::Stmt], ident: ast::Ident) -> @ast::Expr {\n+    fn lambda_stmts_1(&self, span: Span, stmts: Vec<@ast::Stmt> , ident: ast::Ident) -> @ast::Expr {\n         self.lambda1(span, self.block(span, stmts, None), ident)\n     }\n \n@@ -745,7 +741,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     // FIXME unused self\n-    fn fn_decl(&self, inputs: ~[ast::Arg], output: P<ast::Ty>) -> P<ast::FnDecl> {\n+    fn fn_decl(&self, inputs: Vec<ast::Arg> , output: P<ast::Ty>) -> P<ast::FnDecl> {\n         P(ast::FnDecl {\n             inputs: inputs,\n             output: output,\n@@ -755,7 +751,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item(&self, span: Span,\n-            name: Ident, attrs: ~[ast::Attribute], node: ast::Item_) -> @ast::Item {\n+            name: Ident, attrs: Vec<ast::Attribute> , node: ast::Item_) -> @ast::Item {\n         // FIXME: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n         @ast::Item { ident: name,\n@@ -769,13 +765,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn item_fn_poly(&self,\n                     span: Span,\n                     name: Ident,\n-                    inputs: ~[ast::Arg],\n+                    inputs: Vec<ast::Arg> ,\n                     output: P<ast::Ty>,\n                     generics: Generics,\n                     body: P<ast::Block>) -> @ast::Item {\n         self.item(span,\n                   name,\n-                  ~[],\n+                  Vec::new(),\n                   ast::ItemFn(self.fn_decl(inputs, output),\n                               ast::ImpureFn,\n                               AbiSet::Rust(),\n@@ -786,7 +782,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn item_fn(&self,\n                span: Span,\n                name: Ident,\n-               inputs: ~[ast::Arg],\n+               inputs: Vec<ast::Arg> ,\n                output: P<ast::Ty>,\n                body: P<ast::Block>\n               ) -> @ast::Item {\n@@ -799,15 +795,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             body)\n     }\n \n-    fn variant(&self, span: Span, name: Ident, tys: ~[P<ast::Ty>]) -> ast::Variant {\n+    fn variant(&self, span: Span, name: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant {\n         let args = tys.move_iter().map(|ty| {\n             ast::VariantArg { ty: ty, id: ast::DUMMY_NODE_ID }\n         }).collect();\n \n         respan(span,\n                ast::Variant_ {\n                    name: name,\n-                   attrs: ~[],\n+                   attrs: Vec::new(),\n                    kind: ast::TupleVariantKind(args),\n                    id: ast::DUMMY_NODE_ID,\n                    disr_expr: None,\n@@ -818,7 +814,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn item_enum_poly(&self, span: Span, name: Ident,\n                       enum_definition: ast::EnumDef,\n                       generics: Generics) -> @ast::Item {\n-        self.item(span, name, ~[], ast::ItemEnum(enum_definition, generics))\n+        self.item(span, name, Vec::new(), ast::ItemEnum(enum_definition, generics))\n     }\n \n     fn item_enum(&self, span: Span, name: Ident,\n@@ -839,13 +835,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn item_struct_poly(&self, span: Span, name: Ident,\n         struct_def: ast::StructDef, generics: Generics) -> @ast::Item {\n-        self.item(span, name, ~[], ast::ItemStruct(@struct_def, generics))\n+        self.item(span, name, Vec::new(), ast::ItemStruct(@struct_def, generics))\n     }\n \n     fn item_mod(&self, span: Span, name: Ident,\n-                attrs: ~[ast::Attribute],\n-                vi: ~[ast::ViewItem],\n-                items: ~[@ast::Item]) -> @ast::Item {\n+                attrs: Vec<ast::Attribute> ,\n+                vi: Vec<ast::ViewItem> ,\n+                items: Vec<@ast::Item> ) -> @ast::Item {\n         self.item(\n             span,\n             name,\n@@ -859,7 +855,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,\n                     generics: Generics) -> @ast::Item {\n-        self.item(span, name, ~[], ast::ItemTy(ty, generics))\n+        self.item(span, name, Vec::new(), ast::ItemTy(ty, generics))\n     }\n \n     fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> @ast::Item {\n@@ -880,7 +876,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn meta_list(&self,\n                  sp: Span,\n                  name: InternedString,\n-                 mis: ~[@ast::MetaItem])\n+                 mis: Vec<@ast::MetaItem> )\n                  -> @ast::MetaItem {\n         @respan(sp, ast::MetaList(name, mis))\n     }\n@@ -893,10 +889,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn view_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: ~[@ast::ViewPath]) -> ast::ViewItem {\n+                vis: ast::Visibility, vp: Vec<@ast::ViewPath> ) -> ast::ViewItem {\n         ast::ViewItem {\n             node: ast::ViewItemUse(vp),\n-            attrs: ~[],\n+            attrs: Vec::new(),\n             vis: vis,\n             span: sp\n         }\n@@ -910,30 +906,30 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn view_use_simple_(&self, sp: Span, vis: ast::Visibility,\n                         ident: ast::Ident, path: ast::Path) -> ast::ViewItem {\n         self.view_use(sp, vis,\n-                      ~[@respan(sp,\n+                      vec!(@respan(sp,\n                                 ast::ViewPathSimple(ident,\n                                                     path,\n-                                                    ast::DUMMY_NODE_ID))])\n+                                                    ast::DUMMY_NODE_ID))))\n     }\n \n     fn view_use_list(&self, sp: Span, vis: ast::Visibility,\n-                     path: ~[ast::Ident], imports: &[ast::Ident]) -> ast::ViewItem {\n+                     path: Vec<ast::Ident> , imports: &[ast::Ident]) -> ast::ViewItem {\n         let imports = imports.map(|id| {\n             respan(sp, ast::PathListIdent_ { name: *id, id: ast::DUMMY_NODE_ID })\n         });\n \n         self.view_use(sp, vis,\n-                      ~[@respan(sp,\n+                      vec!(@respan(sp,\n                                 ast::ViewPathList(self.path(sp, path),\n                                                   imports,\n-                                                  ast::DUMMY_NODE_ID))])\n+                                                  ast::DUMMY_NODE_ID))))\n     }\n \n     fn view_use_glob(&self, sp: Span,\n-                     vis: ast::Visibility, path: ~[ast::Ident]) -> ast::ViewItem {\n+                     vis: ast::Visibility, path: Vec<ast::Ident> ) -> ast::ViewItem {\n         self.view_use(sp, vis,\n-                      ~[@respan(sp,\n-                                ast::ViewPathGlob(self.path(sp, path), ast::DUMMY_NODE_ID))])\n+                      vec!(@respan(sp,\n+                                ast::ViewPathGlob(self.path(sp, path), ast::DUMMY_NODE_ID))))\n     }\n }\n "}, {"sha": "ba6ad4888e29b09f14ac9126b6ced283b771325e", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -24,7 +24,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) ->\n         None => return MacResult::dummy_expr(sp),\n         Some(e) => e,\n     };\n-    let mut bytes = ~[];\n+    let mut bytes = Vec::new();\n \n     for expr in exprs.iter() {\n         match expr.node {"}, {"sha": "e1f487a95bb2bf9f2b7372edcdc2c1a89487f56d", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -31,7 +31,7 @@ pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> base::M\n                                            cx.cfg(),\n                                            tts.to_owned());\n \n-    let mut cfgs = ~[];\n+    let mut cfgs = Vec::new();\n     // parse `cfg!(meta_item, meta_item(x,y), meta_item=\"foo\", ...)`\n     while p.token != token::EOF {\n         cfgs.push(p.parse_meta_item());"}, {"sha": "2552586939811515626d2bacec8c141ba35cf3a1", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -48,13 +48,13 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             ast::Path {\n                  span: sp,\n                  global: false,\n-                 segments: ~[\n+                 segments: vec!(\n                     ast::PathSegment {\n                         identifier: res,\n                         lifetimes: opt_vec::Empty,\n                         types: opt_vec::Empty,\n                     }\n-                ]\n+                )\n             }\n         ),\n         span: sp,"}, {"sha": "3f8fb3ae4f57fda32f1d2a825e6b93ecfdd11722", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -21,22 +21,22 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                              push: |@Item|) {\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"clone\", \"Clone\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"clone\", \"Clone\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"clone\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[],\n+                args: Vec::new(),\n                 ret_ty: Self,\n                 inline: true,\n                 const_nonmatching: false,\n                 combine_substructure: |c, s, sub| cs_clone(\"Clone\", c, s, sub)\n             }\n-        ]\n+        )\n     };\n \n     trait_def.expand(cx, mitem, item, push)\n@@ -49,24 +49,24 @@ pub fn expand_deriving_deep_clone(cx: &mut ExtCtxt,\n                                   push: |@Item|) {\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"clone\", \"DeepClone\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"clone\", \"DeepClone\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"deep_clone\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[],\n+                args: Vec::new(),\n                 ret_ty: Self,\n                 inline: true,\n                 const_nonmatching: false,\n                 // cs_clone uses the ident passed to it, i.e. it will\n                 // call deep_clone (not clone) here.\n                 combine_substructure: |c, s, sub| cs_clone(\"DeepClone\", c, s, sub)\n             }\n-        ]\n+        )\n     };\n \n     trait_def.expand(cx, mitem, item, push)\n@@ -80,7 +80,7 @@ fn cs_clone(\n     let ctor_ident;\n     let all_fields;\n     let subcall = |field: &FieldInfo|\n-        cx.expr_method_call(field.span, field.self_, clone_ident, ~[]);\n+        cx.expr_method_call(field.span, field.self_, clone_ident, Vec::new());\n \n     match *substr.fields {\n         Struct(ref af) => {"}, {"sha": "975b8885de7348deee1541467544970ef83a3f4b", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -36,8 +36,8 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                 name: $name,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[borrowed_self()],\n-                ret_ty: Literal(Path::new(~[\"bool\"])),\n+                args: vec!(borrowed_self()),\n+                ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 inline: true,\n                 const_nonmatching: true,\n                 combine_substructure: $f\n@@ -47,14 +47,14 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n \n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"cmp\", \"Eq\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"cmp\", \"Eq\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             md!(\"eq\", cs_eq),\n             md!(\"ne\", cs_ne)\n-        ]\n+        )\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "5605c0b61071b78563dea401f33ab2e426cea325", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -26,8 +26,8 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                 name: $name,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[borrowed_self()],\n-                ret_ty: Literal(Path::new(~[\"bool\"])),\n+                args: vec!(borrowed_self()),\n+                ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 inline: true,\n                 const_nonmatching: false,\n                 combine_substructure: |cx, span, substr| cs_op($op, $equal, cx, span, substr)\n@@ -37,16 +37,16 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n \n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"cmp\", \"Ord\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"cmp\", \"Ord\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             md!(\"lt\", true, false),\n             md!(\"le\", true, true),\n             md!(\"gt\", false, false),\n             md!(\"ge\", false, true)\n-        ]\n+        )\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "ffabed95db5240056618b9e47dce21e9909592b8", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -26,22 +26,22 @@ pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n \n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"cmp\", \"TotalEq\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"cmp\", \"TotalEq\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"equals\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[borrowed_self()],\n-                ret_ty: Literal(Path::new(~[\"bool\"])),\n+                args: vec!(borrowed_self()),\n+                ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 inline: true,\n                 const_nonmatching: true,\n                 combine_substructure: cs_equals\n             }\n-        ]\n+        )\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "13f72f5fc2f8aab1a51e6ce79cea4c115dc26e2f", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -23,22 +23,22 @@ pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n                                 push: |@Item|) {\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"cmp\", \"TotalOrd\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"cmp\", \"TotalOrd\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"cmp\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[borrowed_self()],\n-                ret_ty: Literal(Path::new(~[\"std\", \"cmp\", \"Ordering\"])),\n+                args: vec!(borrowed_self()),\n+                ret_ty: Literal(Path::new(vec!(\"std\", \"cmp\", \"Ordering\"))),\n                 inline: true,\n                 const_nonmatching: false,\n                 combine_substructure: cs_cmp\n             }\n-        ]\n+        )\n     };\n \n     trait_def.expand(cx, mitem, item, push)\n@@ -52,9 +52,9 @@ pub fn ordering_const(cx: &mut ExtCtxt, span: Span, cnst: Ordering) -> ast::Path\n         Greater => \"Greater\"\n     };\n     cx.path_global(span,\n-                   ~[cx.ident_of(\"std\"),\n+                   vec!(cx.ident_of(\"std\"),\n                      cx.ident_of(\"cmp\"),\n-                     cx.ident_of(cnst)])\n+                     cx.ident_of(cnst)))\n }\n \n pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n@@ -99,7 +99,7 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n             let if_ = cx.expr_if(span,\n                                  cond,\n                                  old, Some(cx.expr_ident(span, test_id)));\n-            cx.expr_block(cx.block(span, ~[assign], Some(if_)))\n+            cx.expr_block(cx.block(span, vec!(assign), Some(if_)))\n         },\n         cx.expr_path(equals_path.clone()),\n         |cx, span, list, _| {"}, {"sha": "4c9a58c46f733270232df7b94900672ef8617329", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -28,27 +28,26 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                  push: |@Item|) {\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new_(~[\"serialize\", \"Decodable\"], None,\n-                         ~[~Literal(Path::new_local(\"__D\"))], true),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new_(vec!(\"serialize\", \"Decodable\"), None,\n+                         vec!(~Literal(Path::new_local(\"__D\"))), true),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds {\n-            lifetimes: ~[],\n-            bounds: ~[(\"__D\", ~[Path::new(~[\"serialize\", \"Decoder\"])])],\n+            lifetimes: Vec::new(),\n+            bounds: vec!((\"__D\", vec!(Path::new(vec!(\"serialize\", \"Decoder\"))))),\n         },\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"decode\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n-                args: ~[Ptr(~Literal(Path::new_local(\"__D\")),\n-                            Borrowed(None, MutMutable))],\n+                args: vec!(Ptr(~Literal(Path::new_local(\"__D\")),\n+                            Borrowed(None, MutMutable))),\n                 ret_ty: Self,\n                 inline: false,\n                 const_nonmatching: true,\n                 combine_substructure: decodable_substructure,\n-            },\n-        ]\n+            })\n     };\n \n     trait_def.expand(cx, mitem, item, push)\n@@ -57,13 +56,13 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                           substr: &Substructure) -> @Expr {\n     let decoder = substr.nonself_args[0];\n-    let recurse = ~[cx.ident_of(\"serialize\"),\n+    let recurse = vec!(cx.ident_of(\"serialize\"),\n                     cx.ident_of(\"Decodable\"),\n-                    cx.ident_of(\"decode\")];\n+                    cx.ident_of(\"decode\"));\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = cx.ident_of(\"_d\");\n     let blkdecoder = cx.expr_ident(trait_span, blkarg);\n-    let calldecode = cx.expr_call_global(trait_span, recurse, ~[blkdecoder]);\n+    let calldecode = cx.expr_call_global(trait_span, recurse, vec!(blkdecoder));\n     let lambdadecode = cx.lambda_expr_1(trait_span, calldecode, blkarg);\n \n     return match *substr.fields {\n@@ -80,24 +79,24 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                               summary,\n                                               |cx, span, name, field| {\n                 cx.expr_method_call(span, blkdecoder, read_struct_field,\n-                                    ~[cx.expr_str(span, name),\n+                                    vec!(cx.expr_str(span, name),\n                                       cx.expr_uint(span, field),\n-                                      lambdadecode])\n+                                      lambdadecode))\n             });\n             cx.expr_method_call(trait_span,\n                                 decoder,\n                                 cx.ident_of(\"read_struct\"),\n-                                ~[\n+                                vec!(\n                 cx.expr_str(trait_span, token::get_ident(substr.type_ident)),\n                 cx.expr_uint(trait_span, nfields),\n                 cx.lambda_expr_1(trait_span, result, blkarg)\n-            ])\n+            ))\n         }\n         StaticEnum(_, ref fields) => {\n             let variant = cx.ident_of(\"i\");\n \n-            let mut arms = ~[];\n-            let mut variants = ~[];\n+            let mut arms = Vec::new();\n+            let mut variants = Vec::new();\n             let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\");\n \n             for (i, &(name, v_span, ref parts)) in fields.iter().enumerate() {\n@@ -110,29 +109,29 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                                    |cx, span, _, field| {\n                     let idx = cx.expr_uint(span, field);\n                     cx.expr_method_call(span, blkdecoder, rvariant_arg,\n-                                        ~[idx, lambdadecode])\n+                                        vec!(idx, lambdadecode))\n                 });\n \n                 arms.push(cx.arm(v_span,\n-                                 ~[cx.pat_lit(v_span, cx.expr_uint(v_span, i))],\n+                                 vec!(cx.pat_lit(v_span, cx.expr_uint(v_span, i))),\n                                  decoded));\n             }\n \n             arms.push(cx.arm_unreachable(trait_span));\n \n             let result = cx.expr_match(trait_span, cx.expr_ident(trait_span, variant), arms);\n-            let lambda = cx.lambda_expr(trait_span, ~[blkarg, variant], result);\n+            let lambda = cx.lambda_expr(trait_span, vec!(blkarg, variant), result);\n             let variant_vec = cx.expr_vec(trait_span, variants);\n             let result = cx.expr_method_call(trait_span, blkdecoder,\n                                              cx.ident_of(\"read_enum_variant\"),\n-                                             ~[variant_vec, lambda]);\n+                                             vec!(variant_vec, lambda));\n             cx.expr_method_call(trait_span,\n                                 decoder,\n                                 cx.ident_of(\"read_enum\"),\n-                                ~[\n+                                vec!(\n                 cx.expr_str(trait_span, token::get_ident(substr.type_ident)),\n                 cx.lambda_expr_1(trait_span, result, blkarg)\n-            ])\n+            ))\n         }\n         _ => cx.bug(\"expected StaticEnum or StaticStruct in deriving(Decodable)\")\n     };"}, {"sha": "46e9dfb89abac3b2e608f3b7d59de1edc2ed3baf", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -21,34 +21,33 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                             push: |@Item|) {\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"default\", \"Default\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"default\", \"Default\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"default\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n-                args: ~[],\n+                args: Vec::new(),\n                 ret_ty: Self,\n                 inline: true,\n                 const_nonmatching: false,\n                 combine_substructure: default_substructure\n-            },\n-        ]\n+            })\n     };\n     trait_def.expand(cx, mitem, item, push)\n }\n \n fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n-    let default_ident = ~[\n+    let default_ident = vec!(\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"default\"),\n         cx.ident_of(\"Default\"),\n         cx.ident_of(\"default\")\n-    ];\n-    let default_call = |span| cx.expr_call_global(span, default_ident.clone(), ~[]);\n+    );\n+    let default_call = |span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n \n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {"}, {"sha": "2fa6ec6888b6b41d189f2ad145e9564f352b70b2", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -96,27 +96,26 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                  push: |@Item|) {\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new_(~[\"serialize\", \"Encodable\"], None,\n-                         ~[~Literal(Path::new_local(\"__E\"))], true),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new_(vec!(\"serialize\", \"Encodable\"), None,\n+                         vec!(~Literal(Path::new_local(\"__E\"))), true),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds {\n-            lifetimes: ~[],\n-            bounds: ~[(\"__E\", ~[Path::new(~[\"serialize\", \"Encoder\"])])],\n+            lifetimes: Vec::new(),\n+            bounds: vec!((\"__E\", vec!(Path::new(vec!(\"serialize\", \"Encoder\"))))),\n         },\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"encode\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[Ptr(~Literal(Path::new_local(\"__E\")),\n-                            Borrowed(None, MutMutable))],\n+                args: vec!(Ptr(~Literal(Path::new_local(\"__E\")),\n+                            Borrowed(None, MutMutable))),\n                 ret_ty: nil_ty(),\n                 inline: false,\n                 const_nonmatching: true,\n                 combine_substructure: encodable_substructure,\n-            },\n-        ]\n+            })\n     };\n \n     trait_def.expand(cx, mitem, item, push)\n@@ -133,7 +132,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n     return match *substr.fields {\n         Struct(ref fields) => {\n             let emit_struct_field = cx.ident_of(\"emit_struct_field\");\n-            let mut stmts = ~[];\n+            let mut stmts = Vec::new();\n             for (i, &FieldInfo {\n                     name,\n                     self_,\n@@ -146,25 +145,25 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                         token::intern_and_get_ident(format!(\"_field{}\", i))\n                     }\n                 };\n-                let enc = cx.expr_method_call(span, self_, encode, ~[blkencoder]);\n+                let enc = cx.expr_method_call(span, self_, encode, vec!(blkencoder));\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n                 let call = cx.expr_method_call(span, blkencoder,\n                                                emit_struct_field,\n-                                               ~[cx.expr_str(span, name),\n+                                               vec!(cx.expr_str(span, name),\n                                                  cx.expr_uint(span, i),\n-                                                 lambda]);\n+                                                 lambda));\n                 stmts.push(cx.stmt_expr(call));\n             }\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n             cx.expr_method_call(trait_span,\n                                 encoder,\n                                 cx.ident_of(\"emit_struct\"),\n-                                ~[\n+                                vec!(\n                 cx.expr_str(trait_span, token::get_ident(substr.type_ident)),\n                 cx.expr_uint(trait_span, fields.len()),\n                 blk\n-            ])\n+            ))\n         }\n \n         EnumMatching(idx, variant, ref fields) => {\n@@ -175,34 +174,34 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             let me = cx.stmt_let(trait_span, false, blkarg, encoder);\n             let encoder = cx.expr_ident(trait_span, blkarg);\n             let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n-            let mut stmts = ~[];\n+            let mut stmts = Vec::new();\n             for (i, &FieldInfo { self_, span, .. }) in fields.iter().enumerate() {\n-                let enc = cx.expr_method_call(span, self_, encode, ~[blkencoder]);\n+                let enc = cx.expr_method_call(span, self_, encode, vec!(blkencoder));\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n                 let call = cx.expr_method_call(span, blkencoder,\n                                                emit_variant_arg,\n-                                               ~[cx.expr_uint(span, i),\n-                                                 lambda]);\n+                                               vec!(cx.expr_uint(span, i),\n+                                                 lambda));\n                 stmts.push(cx.stmt_expr(call));\n             }\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n             let name = cx.expr_str(trait_span, token::get_ident(variant.node.name));\n             let call = cx.expr_method_call(trait_span, blkencoder,\n                                            cx.ident_of(\"emit_enum_variant\"),\n-                                           ~[name,\n+                                           vec!(name,\n                                              cx.expr_uint(trait_span, idx),\n                                              cx.expr_uint(trait_span, fields.len()),\n-                                             blk]);\n+                                             blk));\n             let blk = cx.lambda_expr_1(trait_span, call, blkarg);\n             let ret = cx.expr_method_call(trait_span,\n                                           encoder,\n                                           cx.ident_of(\"emit_enum\"),\n-                                          ~[\n+                                          vec!(\n                 cx.expr_str(trait_span, token::get_ident(substr.type_ident)),\n                 blk\n-            ]);\n-            cx.expr_block(cx.block(trait_span, ~[me], Some(ret)))\n+            ));\n+            cx.expr_block(cx.block(trait_span, vec!(me), Some(ret)))\n         }\n \n         _ => cx.bug(\"expected Struct or EnumMatching in deriving(Encodable)\")"}, {"sha": "6869ff2fd0dfe59777a06f28345aeeb9d7f10f2e", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 48, "deletions": 50, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -197,20 +197,19 @@ pub struct TraitDef<'a> {\n     /// The span for the current #[deriving(Foo)] header.\n     span: Span,\n \n-    attributes: ~[ast::Attribute],\n+    attributes: Vec<ast::Attribute> ,\n \n     /// Path of the trait, including any type parameters\n     path: Path<'a>,\n \n     /// Additional bounds required of any type parameters of the type,\n     /// other than the current trait\n-    additional_bounds: ~[Ty<'a>],\n+    additional_bounds: Vec<Ty<'a>> ,\n \n     /// Any extra lifetimes and/or bounds, e.g. `D: serialize::Decoder`\n     generics: LifetimeBounds<'a>,\n \n-    methods: ~[MethodDef<'a>]\n-}\n+    methods: Vec<MethodDef<'a>> }\n \n \n pub struct MethodDef<'a> {\n@@ -225,7 +224,7 @@ pub struct MethodDef<'a> {\n     explicit_self: Option<Option<PtrTy<'a>>>,\n \n     /// Arguments other than the self argument\n-    args: ~[Ty<'a>],\n+    args: Vec<Ty<'a>> ,\n \n     /// Return type\n     ret_ty: Ty<'a>,\n@@ -264,39 +263,38 @@ pub struct FieldInfo {\n     self_: @Expr,\n     /// The expressions corresponding to references to this field in\n     /// the other Self arguments.\n-    other: ~[@Expr]\n-}\n+    other: Vec<@Expr> }\n \n /// Fields for a static method\n pub enum StaticFields {\n     /// Tuple structs/enum variants like this\n-    Unnamed(~[Span]),\n+    Unnamed(Vec<Span> ),\n     /// Normal structs/struct variants.\n-    Named(~[(Ident, Span)])\n+    Named(Vec<(Ident, Span)> )\n }\n \n /// A summary of the possible sets of fields. See above for details\n /// and examples\n pub enum SubstructureFields<'a> {\n-    Struct(~[FieldInfo]),\n+    Struct(Vec<FieldInfo> ),\n     /**\n     Matching variants of the enum: variant index, ast::Variant,\n     fields: the field name is only non-`None` in the case of a struct\n     variant.\n     */\n-    EnumMatching(uint, &'a ast::Variant, ~[FieldInfo]),\n+    EnumMatching(uint, &'a ast::Variant, Vec<FieldInfo> ),\n \n     /**\n     non-matching variants of the enum, [(variant index, ast::Variant,\n     [field span, field ident, fields])] (i.e. all fields for self are in the\n     first tuple, for other1 are in the second tuple, etc.)\n     */\n-    EnumNonMatching(&'a [(uint, P<ast::Variant>, ~[(Span, Option<Ident>, @Expr)])]),\n+    EnumNonMatching(&'a [(uint, P<ast::Variant>, Vec<(Span, Option<Ident>, @Expr)> )]),\n \n     /// A static method where Self is a struct.\n     StaticStruct(&'a ast::StructDef, StaticFields),\n     /// A static method where Self is an enum.\n-    StaticEnum(&'a ast::EnumDef, ~[(Ident, Span, StaticFields)])\n+    StaticEnum(&'a ast::EnumDef, Vec<(Ident, Span, StaticFields)> )\n }\n \n \n@@ -316,7 +314,7 @@ representing each variant: (variant index, ast::Variant instance,\n pub type EnumNonMatchFunc<'a> =\n     'a |&mut ExtCtxt,\n            Span,\n-           &[(uint, P<ast::Variant>, ~[(Span, Option<Ident>, @Expr)])],\n+           &[(uint, P<ast::Variant>, Vec<(Span, Option<Ident>, @Expr)> )],\n            &[@Expr]|\n            -> @Expr;\n \n@@ -360,7 +358,7 @@ impl<'a> TraitDef<'a> {\n                            cx: &mut ExtCtxt,\n                            type_ident: Ident,\n                            generics: &Generics,\n-                           methods: ~[@ast::Method]) -> @ast::Item {\n+                           methods: Vec<@ast::Method> ) -> @ast::Item {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n         let mut trait_generics = self.generics.to_generics(cx, self.span,\n@@ -397,7 +395,7 @@ impl<'a> TraitDef<'a> {\n \n         // Create the type of `self`.\n         let self_type = cx.ty_path(\n-            cx.path_all(self.span, false, ~[ type_ident ], self_lifetimes,\n+            cx.path_all(self.span, false, vec!( type_ident ), self_lifetimes,\n                         opt_vec::take_vec(self_ty_params)), None);\n \n         let doc_attr = cx.attribute(\n@@ -412,7 +410,7 @@ impl<'a> TraitDef<'a> {\n         cx.item(\n             self.span,\n             ident,\n-            vec::append(~[doc_attr], self.attributes),\n+            vec_ng::append(vec!(doc_attr), self.attributes),\n             ast::ItemImpl(trait_generics, opt_trait_ref,\n                           self_type, methods.map(|x| *x)))\n     }\n@@ -524,11 +522,11 @@ impl<'a> MethodDef<'a> {\n                                trait_: &TraitDef,\n                                type_ident: Ident,\n                                generics: &Generics)\n-        -> (ast::ExplicitSelf, ~[@Expr], ~[@Expr], ~[(Ident, P<ast::Ty>)]) {\n+        -> (ast::ExplicitSelf, Vec<@Expr> , Vec<@Expr> , Vec<(Ident, P<ast::Ty>)> ) {\n \n-        let mut self_args = ~[];\n-        let mut nonself_args = ~[];\n-        let mut arg_tys = ~[];\n+        let mut self_args = Vec::new();\n+        let mut nonself_args = Vec::new();\n+        let mut arg_tys = Vec::new();\n         let mut nonstatic = false;\n \n         let ast_explicit_self = match self.explicit_self {\n@@ -575,7 +573,7 @@ impl<'a> MethodDef<'a> {\n                      type_ident: Ident,\n                      generics: &Generics,\n                      explicit_self: ast::ExplicitSelf,\n-                     arg_types: ~[(Ident, P<ast::Ty>)],\n+                     arg_types: Vec<(Ident, P<ast::Ty>)> ,\n                      body: @Expr) -> @ast::Method {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n@@ -598,16 +596,16 @@ impl<'a> MethodDef<'a> {\n         let body_block = cx.block_expr(body);\n \n         let attrs = if self.inline {\n-            ~[\n+            vec!(\n                 cx\n                       .attribute(trait_.span,\n                                  cx\n                                        .meta_word(trait_.span,\n                                                   InternedString::new(\n                                                       \"inline\")))\n-            ]\n+            )\n         } else {\n-            ~[]\n+            Vec::new()\n         };\n \n         // Create the method.\n@@ -655,9 +653,9 @@ impl<'a> MethodDef<'a> {\n                                  nonself_args: &[@Expr])\n         -> @Expr {\n \n-        let mut raw_fields = ~[]; // ~[[fields of self],\n+        let mut raw_fields = Vec::new(); // ~[[fields of self],\n                                  // [fields of next Self arg], [etc]]\n-        let mut patterns = ~[];\n+        let mut patterns = Vec::new();\n         for i in range(0u, self_args.len()) {\n             let (pat, ident_expr) = trait_.create_struct_pattern(cx, type_ident, struct_def,\n                                                                  format!(\"__self_{}\", i),\n@@ -703,7 +701,7 @@ impl<'a> MethodDef<'a> {\n         // matter.\n         for (&arg_expr, &pat) in self_args.iter().zip(patterns.iter()) {\n             body = cx.expr_match(trait_.span, arg_expr,\n-                                     ~[ cx.arm(trait_.span, ~[pat], body) ])\n+                                     vec!( cx.arm(trait_.span, vec!(pat), body) ))\n         }\n         body\n     }\n@@ -759,7 +757,7 @@ impl<'a> MethodDef<'a> {\n                                self_args: &[@Expr],\n                                nonself_args: &[@Expr])\n                                -> @Expr {\n-        let mut matches = ~[];\n+        let mut matches = Vec::new();\n         self.build_enum_match(cx, trait_, enum_def, type_ident,\n                               self_args, nonself_args,\n                               None, &mut matches, 0)\n@@ -795,8 +793,8 @@ impl<'a> MethodDef<'a> {\n                         self_args: &[@Expr],\n                         nonself_args: &[@Expr],\n                         matching: Option<uint>,\n-                        matches_so_far: &mut ~[(uint, P<ast::Variant>,\n-                                              ~[(Span, Option<Ident>, @Expr)])],\n+                        matches_so_far: &mut Vec<(uint, P<ast::Variant>,\n+                                              Vec<(Span, Option<Ident>, @Expr)> )> ,\n                         match_count: uint) -> @Expr {\n         if match_count == self_args.len() {\n             // we've matched against all arguments, so make the final\n@@ -826,7 +824,7 @@ impl<'a> MethodDef<'a> {\n                         (_, v, ref s) => (v, s)\n                     };\n \n-                    let mut enum_matching_fields = vec::from_elem(self_vec.len(), ~[]);\n+                    let mut enum_matching_fields = vec::from_elem(self_vec.len(), Vec::new());\n \n                     for triple in matches_so_far.tail().iter() {\n                         match triple {\n@@ -865,7 +863,7 @@ impl<'a> MethodDef<'a> {\n                 format!(\"__arg_{}\", match_count)\n             };\n \n-            let mut arms = ~[];\n+            let mut arms = Vec::new();\n \n             // the code for nonmatching variants only matters when\n             // we've seen at least one other variant already\n@@ -895,7 +893,7 @@ impl<'a> MethodDef<'a> {\n                                                      matches_so_far,\n                                                      match_count + 1);\n                 matches_so_far.pop().unwrap();\n-                arms.push(cx.arm(trait_.span, ~[ pattern ], arm_expr));\n+                arms.push(cx.arm(trait_.span, vec!( pattern ), arm_expr));\n \n                 if enum_def.variants.len() > 1 {\n                     let e = &EnumNonMatching(&[]);\n@@ -904,7 +902,7 @@ impl<'a> MethodDef<'a> {\n                                                                   e);\n                     let wild_arm = cx.arm(\n                         trait_.span,\n-                        ~[ cx.pat_wild(trait_.span) ],\n+                        vec!( cx.pat_wild(trait_.span) ),\n                         wild_expr);\n                     arms.push(wild_arm);\n                 }\n@@ -933,7 +931,7 @@ impl<'a> MethodDef<'a> {\n                                                          match_count + 1);\n                     matches_so_far.pop().unwrap();\n \n-                    let arm = cx.arm(trait_.span, ~[ pattern ], arm_expr);\n+                    let arm = cx.arm(trait_.span, vec!( pattern ), arm_expr);\n                     arms.push(arm);\n                 }\n             }\n@@ -997,8 +995,8 @@ impl<'a> TraitDef<'a> {\n     fn summarise_struct(&self,\n                         cx: &mut ExtCtxt,\n                         struct_def: &StructDef) -> StaticFields {\n-        let mut named_idents = ~[];\n-        let mut just_spans = ~[];\n+        let mut named_idents = Vec::new();\n+        let mut just_spans = Vec::new();\n         for field in struct_def.fields.iter(){\n             let sp = self.set_expn_info(cx, field.span);\n             match field.node.kind {\n@@ -1020,9 +1018,9 @@ impl<'a> TraitDef<'a> {\n \n     fn create_subpatterns(&self,\n                           cx: &mut ExtCtxt,\n-                          field_paths: ~[ast::Path],\n+                          field_paths: Vec<ast::Path> ,\n                           mutbl: ast::Mutability)\n-                          -> ~[@ast::Pat] {\n+                          -> Vec<@ast::Pat> {\n         field_paths.map(|path| {\n             cx.pat(path.span,\n                         ast::PatIdent(ast::BindByRef(mutbl), (*path).clone(), None))\n@@ -1035,18 +1033,18 @@ impl<'a> TraitDef<'a> {\n                              struct_def: &StructDef,\n                              prefix: &str,\n                              mutbl: ast::Mutability)\n-                             -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n+                             -> (@ast::Pat, Vec<(Span, Option<Ident>, @Expr)> ) {\n         if struct_def.fields.is_empty() {\n             return (\n                 cx.pat_ident_binding_mode(\n                     self.span, struct_ident, ast::BindByValue(ast::MutImmutable)),\n-                ~[]);\n+                Vec::new());\n         }\n \n-        let matching_path = cx.path(self.span, ~[ struct_ident ]);\n+        let matching_path = cx.path(self.span, vec!( struct_ident ));\n \n-        let mut paths = ~[];\n-        let mut ident_expr = ~[];\n+        let mut paths = Vec::new();\n+        let mut ident_expr = Vec::new();\n         let mut struct_type = Unknown;\n \n         for (i, struct_field) in struct_def.fields.iter().enumerate() {\n@@ -1096,20 +1094,20 @@ impl<'a> TraitDef<'a> {\n                                    variant: &ast::Variant,\n                                    prefix: &str,\n                                    mutbl: ast::Mutability)\n-        -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n+        -> (@ast::Pat, Vec<(Span, Option<Ident>, @Expr)> ) {\n         let variant_ident = variant.node.name;\n         match variant.node.kind {\n             ast::TupleVariantKind(ref variant_args) => {\n                 if variant_args.is_empty() {\n                     return (cx.pat_ident_binding_mode(variant.span, variant_ident,\n                                                           ast::BindByValue(ast::MutImmutable)),\n-                            ~[]);\n+                            Vec::new());\n                 }\n \n                 let matching_path = cx.path_ident(variant.span, variant_ident);\n \n-                let mut paths = ~[];\n-                let mut ident_expr = ~[];\n+                let mut paths = Vec::new();\n+                let mut ident_expr = Vec::new();\n                 for (i, va) in variant_args.iter().enumerate() {\n                     let sp = self.set_expn_info(cx, va.ty.span);\n                     let path = cx.path_ident(sp, cx.ident_of(format!(\"{}_{}\", prefix, i)));\n@@ -1179,7 +1177,7 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n ~~~\n */\n #[inline]\n-pub fn cs_same_method(f: |&mut ExtCtxt, Span, ~[@Expr]| -> @Expr,\n+pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<@Expr> | -> @Expr,\n                       enum_nonmatch_f: EnumNonMatchFunc,\n                       cx: &mut ExtCtxt,\n                       trait_span: Span,"}, {"sha": "ed7f61d5e94218a6ffcac03fd5c83b06a4215366", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -22,23 +22,23 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n \n     let hash_trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"hash\", \"Hash\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"hash\", \"Hash\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"hash\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[Ptr(~Literal(Path::new(~[\"std\", \"hash\", \"sip\", \"SipState\"])),\n-                            Borrowed(None, MutMutable))],\n+                args: vec!(Ptr(~Literal(Path::new(vec!(\"std\", \"hash\", \"sip\", \"SipState\"))),\n+                            Borrowed(None, MutMutable))),\n                 ret_ty: nil_ty(),\n                 inline: true,\n                 const_nonmatching: false,\n                 combine_substructure: hash_substructure\n             }\n-        ]\n+        )\n     };\n \n     hash_trait_def.expand(cx, mitem, item, push);\n@@ -51,10 +51,10 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n     };\n     let hash_ident = substr.method_ident;\n     let call_hash = |span, thing_expr| {\n-        let expr = cx.expr_method_call(span, thing_expr, hash_ident, ~[state_expr]);\n+        let expr = cx.expr_method_call(span, thing_expr, hash_ident, vec!(state_expr));\n         cx.stmt_expr(expr)\n     };\n-    let mut stmts = ~[];\n+    let mut stmts = Vec::new();\n \n     let fields = match *substr.fields {\n         Struct(ref fs) => fs,"}, {"sha": "2615479fa72aa498c8dc62d9bd9842132a0f622f", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -23,21 +23,20 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                                       push: |@Item|) {\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"num\", \"FromPrimitive\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"num\", \"FromPrimitive\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"from_i64\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n-                args: ~[\n-                    Literal(Path::new(~[\"i64\"])),\n-                ],\n-                ret_ty: Literal(Path::new_(~[\"std\", \"option\", \"Option\"],\n+                args: vec!(\n+                    Literal(Path::new(vec!(\"i64\")))),\n+                ret_ty: Literal(Path::new_(vec!(\"std\", \"option\", \"Option\"),\n                                            None,\n-                                           ~[~Self],\n+                                           vec!(~Self),\n                                            true)),\n                 // liable to cause code-bloat\n                 inline: true,\n@@ -48,19 +47,17 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                 name: \"from_u64\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n-                args: ~[\n-                    Literal(Path::new(~[\"u64\"])),\n-                ],\n-                ret_ty: Literal(Path::new_(~[\"std\", \"option\", \"Option\"],\n+                args: vec!(\n+                    Literal(Path::new(vec!(\"u64\")))),\n+                ret_ty: Literal(Path::new_(vec!(\"std\", \"option\", \"Option\"),\n                                            None,\n-                                           ~[~Self],\n+                                           vec!(~Self),\n                                            true)),\n                 // liable to cause code-bloat\n                 inline: true,\n                 const_nonmatching: false,\n                 combine_substructure: |c, s, sub| cs_from(\"u64\", c, s, sub),\n-            },\n-        ]\n+            })\n     };\n \n     trait_def.expand(cx, mitem, item, push)\n@@ -84,7 +81,7 @@ fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure\n                 return cx.expr_fail(trait_span, InternedString::new(\"\"));\n             }\n \n-            let mut arms = ~[];\n+            let mut arms = Vec::new();\n \n             for variant in enum_def.variants.iter() {\n                 match variant.node.kind {\n@@ -109,7 +106,7 @@ fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure\n \n                         // arm for `_ if $guard => $body`\n                         let arm = ast::Arm {\n-                            pats: ~[cx.pat_wild(span)],\n+                            pats: vec!(cx.pat_wild(span)),\n                             guard: Some(guard),\n                             body: cx.block_expr(body),\n                         };\n@@ -128,7 +125,7 @@ fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure\n \n             // arm for `_ => None`\n             let arm = ast::Arm {\n-                pats: ~[cx.pat_wild(trait_span)],\n+                pats: vec!(cx.pat_wild(trait_span)),\n                 guard: None,\n                 body: cx.block_expr(cx.expr_none(trait_span)),\n             };"}, {"sha": "203e5aae567cf48590fd1da7928de02786ac03c2", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -23,48 +23,48 @@ pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n                             push: |@Item|) {\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"rand\", \"Rand\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"rand\", \"Rand\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"rand\",\n                 generics: LifetimeBounds {\n-                    lifetimes: ~[],\n-                    bounds: ~[(\"R\",\n-                               ~[ Path::new(~[\"std\", \"rand\", \"Rng\"]) ])]\n+                    lifetimes: Vec::new(),\n+                    bounds: vec!((\"R\",\n+                               vec!( Path::new(vec!(\"std\", \"rand\", \"Rng\")) )))\n                 },\n                 explicit_self: None,\n-                args: ~[\n+                args: vec!(\n                     Ptr(~Literal(Path::new_local(\"R\")),\n                         Borrowed(None, ast::MutMutable))\n-                ],\n+                ),\n                 ret_ty: Self,\n                 inline: false,\n                 const_nonmatching: false,\n                 combine_substructure: rand_substructure\n             }\n-        ]\n+        )\n     };\n     trait_def.expand(cx, mitem, item, push)\n }\n \n fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n     let rng = match substr.nonself_args {\n-        [rng] => ~[ rng ],\n+        [rng] => vec!( rng ),\n         _ => cx.bug(\"Incorrect number of arguments to `rand` in `deriving(Rand)`\")\n     };\n-    let rand_ident = ~[\n+    let rand_ident = vec!(\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"rand\"),\n         cx.ident_of(\"Rand\"),\n         cx.ident_of(\"rand\")\n-    ];\n+    );\n     let rand_call = |cx: &mut ExtCtxt, span| {\n         cx.expr_call_global(span,\n                             rand_ident.clone(),\n-                            ~[ rng[0] ])\n+                            vec!( rng[0] ))\n     };\n \n     return match *substr.fields {\n@@ -84,13 +84,13 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n                                         true,\n                                         rand_ident.clone(),\n                                         opt_vec::Empty,\n-                                        ~[]);\n+                                        Vec::new());\n             let rand_name = cx.expr_path(rand_name);\n \n             // ::std::rand::Rand::rand(rng)\n             let rv_call = cx.expr_call(trait_span,\n                                        rand_name,\n-                                       ~[ rng[0] ]);\n+                                       vec!( rng[0] ));\n \n             // need to specify the uint-ness of the random number\n             let uint_ty = cx.ty_ident(trait_span, cx.ident_of(\"uint\"));\n@@ -113,15 +113,15 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n                 let pat = cx.pat_lit(v_span, i_expr);\n \n                 let thing = rand_thing(cx, v_span, ident, summary, |cx, sp| rand_call(cx, sp));\n-                cx.arm(v_span, ~[ pat ], thing)\n-            }).collect::<~[ast::Arm]>();\n+                cx.arm(v_span, vec!( pat ), thing)\n+            }).collect::<Vec<ast::Arm> >();\n \n             // _ => {} at the end. Should never occur\n             arms.push(cx.arm_unreachable(trait_span));\n \n             let match_expr = cx.expr_match(trait_span, rand_variant, arms);\n \n-            let block = cx.block(trait_span, ~[ let_statement ], Some(match_expr));\n+            let block = cx.block(trait_span, vec!( let_statement ), Some(match_expr));\n             cx.expr_block(block)\n         }\n         _ => cx.bug(\"Non-static method in `deriving(Rand)`\")"}, {"sha": "0622588be8ee4a8a4f392a003962fde700c3bc6f", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -26,27 +26,27 @@ pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                             item: @Item,\n                             push: |@Item|) {\n     // &mut ::std::fmt::Formatter\n-    let fmtr = Ptr(~Literal(Path::new(~[\"std\", \"fmt\", \"Formatter\"])),\n+    let fmtr = Ptr(~Literal(Path::new(vec!(\"std\", \"fmt\", \"Formatter\"))),\n                    Borrowed(None, ast::MutMutable));\n \n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"fmt\", \"Show\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"fmt\", \"Show\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"fmt\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[fmtr],\n-                ret_ty: Literal(Path::new(~[\"std\", \"fmt\", \"Result\"])),\n+                args: vec!(fmtr),\n+                ret_ty: Literal(Path::new(vec!(\"std\", \"fmt\", \"Result\"))),\n                 inline: false,\n                 const_nonmatching: false,\n                 combine_substructure: show_substructure\n             }\n-        ]\n+        )\n     };\n     trait_def.expand(cx, mitem, item, push)\n }\n@@ -70,7 +70,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n \n     let mut format_string = token::get_ident(name).get().to_owned();\n     // the internal fields we're actually formatting\n-    let mut exprs = ~[];\n+    let mut exprs = Vec::new();\n \n     // Getting harder... making the format string:\n     match *substr.fields {\n@@ -124,10 +124,10 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     let formatter = substr.nonself_args[0];\n     let buf = cx.expr_field_access(span, formatter, cx.ident_of(\"buf\"));\n \n-    let std_write = ~[cx.ident_of(\"std\"), cx.ident_of(\"fmt\"), cx.ident_of(\"write\")];\n+    let std_write = vec!(cx.ident_of(\"std\"), cx.ident_of(\"fmt\"), cx.ident_of(\"write\"));\n     let args = cx.ident_of(\"__args\");\n-    let write_call = cx.expr_call_global(span, std_write, ~[buf, cx.expr_ident(span, args)]);\n-    let format_closure = cx.lambda_expr(span, ~[args], write_call);\n+    let write_call = cx.expr_call_global(span, std_write, vec!(buf, cx.expr_ident(span, args)));\n+    let format_closure = cx.lambda_expr(span, vec!(args), write_call);\n \n     let s = token::intern_and_get_ident(format_string);\n     let format_string = cx.expr_str(span, s);"}, {"sha": "f7019d65058b93595f507c6bcb4246c8f3e8fba0", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -30,22 +30,22 @@ pub enum PtrTy<'a> {\n /// A path, e.g. `::std::option::Option::<int>` (global). Has support\n /// for type parameters and a lifetime.\n pub struct Path<'a> {\n-    path: ~[&'a str],\n+    path: Vec<&'a str> ,\n     lifetime: Option<&'a str>,\n-    params: ~[~Ty<'a>],\n+    params: Vec<~Ty<'a>> ,\n     global: bool\n }\n \n impl<'a> Path<'a> {\n-    pub fn new<'r>(path: ~[&'r str]) -> Path<'r> {\n-        Path::new_(path, None, ~[], true)\n+    pub fn new<'r>(path: Vec<&'r str> ) -> Path<'r> {\n+        Path::new_(path, None, Vec::new(), true)\n     }\n     pub fn new_local<'r>(path: &'r str) -> Path<'r> {\n-        Path::new_(~[ path ], None, ~[], false)\n+        Path::new_(vec!( path ), None, Vec::new(), false)\n     }\n-    pub fn new_<'r>(path: ~[&'r str],\n+    pub fn new_<'r>(path: Vec<&'r str> ,\n                     lifetime: Option<&'r str>,\n-                    params: ~[~Ty<'r>],\n+                    params: Vec<~Ty<'r>> ,\n                     global: bool)\n                     -> Path<'r> {\n         Path {\n@@ -87,7 +87,7 @@ pub enum Ty<'a> {\n     // parameter, and things like `int`\n     Literal(Path<'a>),\n     // includes nil\n-    Tuple(~[Ty<'a>])\n+    Tuple(Vec<Ty<'a>> )\n }\n \n pub fn borrowed_ptrty<'r>() -> PtrTy<'r> {\n@@ -106,7 +106,7 @@ pub fn borrowed_self<'r>() -> Ty<'r> {\n }\n \n pub fn nil_ty() -> Ty<'static> {\n-    Tuple(~[])\n+    Tuple(Vec::new())\n }\n \n fn mk_lifetime(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> Option<ast::Lifetime> {\n@@ -172,7 +172,7 @@ impl<'a> Ty<'a> {\n                 });\n                 let lifetimes = self_generics.lifetimes.clone();\n \n-                cx.path_all(span, false, ~[self_ty], lifetimes,\n+                cx.path_all(span, false, vec!(self_ty), lifetimes,\n                             opt_vec::take_vec(self_params))\n             }\n             Literal(ref p) => {\n@@ -195,7 +195,7 @@ fn mk_ty_param(cx: &ExtCtxt, span: Span, name: &str, bounds: &[Path],\n     cx.typaram(cx.ident_of(name), bounds, None)\n }\n \n-fn mk_generics(lifetimes: ~[ast::Lifetime],  ty_params: ~[ast::TyParam]) -> Generics {\n+fn mk_generics(lifetimes: Vec<ast::Lifetime> ,  ty_params: Vec<ast::TyParam> ) -> Generics {\n     Generics {\n         lifetimes: opt_vec::from(lifetimes),\n         ty_params: opt_vec::from(ty_params)\n@@ -204,14 +204,14 @@ fn mk_generics(lifetimes: ~[ast::Lifetime],  ty_params: ~[ast::TyParam]) -> Gene\n \n /// Lifetimes and bounds on type parameters\n pub struct LifetimeBounds<'a> {\n-    lifetimes: ~[&'a str],\n-    bounds: ~[(&'a str, ~[Path<'a>])]\n+    lifetimes: Vec<&'a str> ,\n+    bounds: vec!((&'a str, Vec<Path<'a>> ))\n }\n \n impl<'a> LifetimeBounds<'a> {\n     pub fn empty() -> LifetimeBounds<'static> {\n         LifetimeBounds {\n-            lifetimes: ~[], bounds: ~[]\n+            lifetimes: Vec::new(), bounds: Vec::new()\n         }\n     }\n     pub fn to_generics(&self,"}, {"sha": "9feae18689416c6c215a4a8fe5796669a94eddae", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -21,16 +21,16 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                             push: |@Item|) {\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"num\", \"Zero\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"num\", \"Zero\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"zero\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n-                args: ~[],\n+                args: Vec::new(),\n                 ret_ty: Self,\n                 inline: true,\n                 const_nonmatching: false,\n@@ -40,8 +40,8 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                 name: \"is_zero\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[],\n-                ret_ty: Literal(Path::new(~[\"bool\"])),\n+                args: Vec::new(),\n+                ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 inline: true,\n                 const_nonmatching: false,\n                 combine_substructure: |cx, span, substr| {\n@@ -52,19 +52,19 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                            cx, span, substr)\n                 }\n             }\n-        ]\n+        )\n     };\n     trait_def.expand(cx, mitem, item, push)\n }\n \n fn zero_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n-    let zero_ident = ~[\n+    let zero_ident = vec!(\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"num\"),\n         cx.ident_of(\"Zero\"),\n         cx.ident_of(\"zero\")\n-    ];\n-    let zero_call = |span| cx.expr_call_global(span, zero_ident.clone(), ~[]);\n+    );\n+    let zero_call = |span| cx.expr_call_global(span, zero_ident.clone(), Vec::new());\n \n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {"}, {"sha": "08d407458941a2f934b5bb2021d02baca54833d5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 35, "deletions": 53, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -169,21 +169,21 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n             let none_arm = {\n                 let break_expr = fld.cx.expr(span, ast::ExprBreak(opt_ident));\n                 let none_pat = fld.cx.pat_ident(span, none_ident);\n-                fld.cx.arm(span, ~[none_pat], break_expr)\n+                fld.cx.arm(span, vec!(none_pat), break_expr)\n             };\n \n             // `Some(<src_pat>) => <src_loop_block>`\n             let some_arm =\n                 fld.cx.arm(span,\n-                           ~[fld.cx.pat_enum(span, some_path, ~[src_pat])],\n+                           vec!(fld.cx.pat_enum(span, some_path, vec!(src_pat))),\n                            fld.cx.expr_block(src_loop_block));\n \n             // `match i.next() { ... }`\n             let match_expr = {\n                 let next_call_expr =\n-                    fld.cx.expr_method_call(span, fld.cx.expr_path(local_path), next_ident, ~[]);\n+                    fld.cx.expr_method_call(span, fld.cx.expr_path(local_path), next_ident, Vec::new());\n \n-                fld.cx.expr_match(span, next_call_expr, ~[none_arm, some_arm])\n+                fld.cx.expr_match(span, next_call_expr, vec!(none_arm, some_arm))\n             };\n \n             // ['ident:] loop { ... }\n@@ -196,8 +196,8 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n             // `match &mut <src_expr> { i => loop { ... } }`\n             let discrim = fld.cx.expr_mut_addr_of(span, src_expr);\n             let i_pattern = fld.cx.pat_ident(span, local_ident);\n-            let arm = fld.cx.arm(span, ~[i_pattern], loop_expr);\n-            fld.cx.expr_match(span, discrim, ~[arm])\n+            let arm = fld.cx.arm(span, vec!(i_pattern), loop_expr);\n+            fld.cx.expr_match(span, discrim, vec!(arm))\n         }\n \n         ast::ExprLoop(loop_block, opt_ident) => {\n@@ -221,7 +221,7 @@ fn rename_loop_label(opt_ident: Option<Ident>,\n             let new_label = fresh_name(&label);\n             let rename = (label, new_label);\n             fld.extsbox.info().pending_renames.push(rename);\n-            let mut pending_renames = ~[rename];\n+            let mut pending_renames = vec!(rename);\n             let mut rename_fld = renames_to_fold(&mut pending_renames);\n             (Some(rename_fld.fold_ident(label)),\n              rename_fld.fold_block(loop_block))\n@@ -607,10 +607,10 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                     // oh dear heaven... this is going to include the enum\n                     // names, as well... but that should be okay, as long as\n                     // the new names are gensyms for the old ones.\n-                    let mut name_finder = new_name_finder(~[]);\n+                    let mut name_finder = new_name_finder(Vec::new());\n                     name_finder.visit_pat(expanded_pat,());\n                     // generate fresh names, push them to a new pending list\n-                    let mut new_pending_renames = ~[];\n+                    let mut new_pending_renames = Vec::new();\n                     for ident in name_finder.ident_accumulator.iter() {\n                         let new_name = fresh_name(ident);\n                         new_pending_renames.push((*ident,new_name));\n@@ -657,7 +657,7 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n // array (passed in to the traversal)\n #[deriving(Clone)]\n struct NewNameFinderContext {\n-    ident_accumulator: ~[ast::Ident],\n+    ident_accumulator: Vec<ast::Ident> ,\n }\n \n impl Visitor<()> for NewNameFinderContext {\n@@ -700,7 +700,7 @@ impl Visitor<()> for NewNameFinderContext {\n // return a visitor that extracts the pat_ident paths\n // from a given thingy and puts them in a mutable\n // array (passed in to the traversal)\n-pub fn new_name_finder(idents: ~[ast::Ident]) -> NewNameFinderContext {\n+pub fn new_name_finder(idents: Vec<ast::Ident> ) -> NewNameFinderContext {\n     NewNameFinderContext {\n         ident_accumulator: idents,\n     }\n@@ -860,7 +860,7 @@ fn new_mark_folder(m: Mrk) -> Marker {\n }\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n-fn mark_tts(tts: &[TokenTree], m: Mrk) -> ~[TokenTree] {\n+fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n     fold_tts(tts, &mut new_mark_folder(m))\n }\n \n@@ -917,7 +917,7 @@ mod test {\n     // array (passed in to the traversal)\n     #[deriving(Clone)]\n     struct NewPathExprFinderContext {\n-        path_accumulator: ~[ast::Path],\n+        path_accumulator: Vec<ast::Path> ,\n     }\n \n     impl Visitor<()> for NewPathExprFinderContext {\n@@ -941,7 +941,7 @@ mod test {\n     // return a visitor that extracts the paths\n     // from a given pattern and puts them in a mutable\n     // array (passed in to the traversal)\n-    pub fn new_path_finder(paths: ~[ast::Path]) -> NewPathExprFinderContext {\n+    pub fn new_path_finder(paths: Vec<ast::Path> ) -> NewPathExprFinderContext {\n         NewPathExprFinderContext {\n             path_accumulator: paths\n         }\n@@ -954,7 +954,7 @@ mod test {\n             fail!(\"lolwut\")\n         }\n \n-        fn get_exported_macros(&mut self, _: ast::CrateNum) -> ~[~str] {\n+        fn get_exported_macros(&mut self, _: ast::CrateNum) -> Vec<~str> {\n             fail!(\"lolwut\")\n         }\n \n@@ -975,7 +975,7 @@ mod test {\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             src,\n-            ~[],sess);\n+            Vec::new(),sess);\n         // should fail:\n         let mut loader = ErrLoader;\n         expand_crate(sess,&mut loader,crate_ast);\n@@ -990,7 +990,7 @@ mod test {\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             src,\n-            ~[],sess);\n+            Vec::new(),sess);\n         // should fail:\n         let mut loader = ErrLoader;\n         expand_crate(sess,&mut loader,crate_ast);\n@@ -1004,7 +1004,7 @@ mod test {\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             src,\n-            ~[], sess);\n+            Vec::new(), sess);\n         // should fail:\n         let mut loader = ErrLoader;\n         expand_crate(sess, &mut loader, crate_ast);\n@@ -1014,9 +1014,9 @@ mod test {\n         let attr1 = make_dummy_attr (\"foo\");\n         let attr2 = make_dummy_attr (\"bar\");\n         let escape_attr = make_dummy_attr (\"macro_escape\");\n-        let attrs1 = ~[attr1, escape_attr, attr2];\n+        let attrs1 = vec!(attr1, escape_attr, attr2);\n         assert_eq!(contains_macro_escape (attrs1),true);\n-        let attrs2 = ~[attr1,attr2];\n+        let attrs2 = vec!(attr1,attr2);\n         assert_eq!(contains_macro_escape (attrs2),false);\n     }\n \n@@ -1082,48 +1082,30 @@ mod test {\n     // in principle, you might want to control this boolean on a per-varref basis,\n     // but that would make things even harder to understand, and might not be\n     // necessary for thorough testing.\n-    type RenamingTest = (&'static str, ~[~[uint]], bool);\n+    type RenamingTest = (&'static str, vec!(Vec<uint> ), bool);\n \n     #[test]\n     fn automatic_renaming () {\n-        let tests: ~[RenamingTest] =\n-            ~[// b & c should get new names throughout, in the expr too:\n+        let tests: Vec<RenamingTest> =\n+            vec!(// b & c should get new names throughout, in the expr too:\n                 (\"fn a() -> int { let b = 13; let c = b; b+c }\",\n-                 ~[~[0,1],~[2]], false),\n+                 vec!(vec!(0,1),vec!(2)), false),\n                 // both x's should be renamed (how is this causing a bug?)\n                 (\"fn main () {let x: int = 13;x;}\",\n-                 ~[~[0]], false),\n+                 vec!(vec!(0)), false),\n                 // the use of b after the + should be renamed, the other one not:\n                 (\"macro_rules! f (($x:ident) => (b + $x)) fn a() -> int { let b = 13; f!(b)}\",\n-                 ~[~[1]], false),\n+                 vec!(vec!(1)), false),\n                 // the b before the plus should not be renamed (requires marks)\n                 (\"macro_rules! f (($x:ident) => ({let b=9; ($x + b)})) fn a() -> int { f!(b)}\",\n-                 ~[~[1]], false),\n+                 vec!(vec!(1)), false),\n                 // the marks going in and out of letty should cancel, allowing that $x to\n                 // capture the one following the semicolon.\n                 // this was an awesome test case, and caught a *lot* of bugs.\n                 (\"macro_rules! letty(($x:ident) => (let $x = 15;))\n                   macro_rules! user(($x:ident) => ({letty!($x); $x}))\n                   fn main() -> int {user!(z)}\",\n-                 ~[~[0]], false),\n-                // no longer a fixme #8062: this test exposes a *potential* bug; our system does\n-                // not behave exactly like MTWT, but a conversation with Matthew Flatt\n-                // suggests that this can only occur in the presence of local-expand, which\n-                // we have no plans to support.\n-                // (\"fn main() {let hrcoo = 19; macro_rules! getx(()=>(hrcoo)); getx!();}\",\n-                // ~[~[0]], true)\n-                // FIXME #6994: the next string exposes the bug referred to in issue 6994, so I'm\n-                // commenting it out.\n-                // the z flows into and out of two macros (g & f) along one path, and one\n-                // (just g) along the other, so the result of the whole thing should\n-                // be \"let z_123 = 3; z_123\"\n-                //\"macro_rules! g (($x:ident) =>\n-                //   ({macro_rules! f(($y:ident)=>({let $y=3;$x}));f!($x)}))\n-                //   fn a(){g!(z)}\"\n-                // create a really evil test case where a $x appears inside a binding of $x\n-                // but *shouldnt* bind because it was inserted by a different macro....\n-                // can't write this test case until we have macro-generating macros.\n-            ];\n+                 vec!(vec!(0)), false));\n         for (idx,s) in tests.iter().enumerate() {\n             run_renaming_test(s,idx);\n         }\n@@ -1137,12 +1119,12 @@ mod test {\n         };\n         let cr = expand_crate_str(teststr.to_owned());\n         // find the bindings:\n-        let mut name_finder = new_name_finder(~[]);\n+        let mut name_finder = new_name_finder(Vec::new());\n         visit::walk_crate(&mut name_finder,&cr,());\n         let bindings = name_finder.ident_accumulator;\n \n         // find the varrefs:\n-        let mut path_finder = new_path_finder(~[]);\n+        let mut path_finder = new_path_finder(Vec::new());\n         visit::walk_crate(&mut path_finder,&cr,());\n         let varrefs = path_finder.path_accumulator;\n \n@@ -1205,11 +1187,11 @@ foo_module!()\n \";\n         let cr = expand_crate_str(crate_str);\n         // find the xx binding\n-        let mut name_finder = new_name_finder(~[]);\n+        let mut name_finder = new_name_finder(Vec::new());\n         visit::walk_crate(&mut name_finder, &cr, ());\n         let bindings = name_finder.ident_accumulator;\n \n-        let cxbinds: ~[&ast::Ident] =\n+        let cxbinds: Vec<&ast::Ident> =\n             bindings.iter().filter(|b| {\n                 let ident = token::get_ident(**b);\n                 let string = ident.get();\n@@ -1222,7 +1204,7 @@ foo_module!()\n         };\n         let resolved_binding = mtwt_resolve(*cxbind);\n         // find all the xx varrefs:\n-        let mut path_finder = new_path_finder(~[]);\n+        let mut path_finder = new_path_finder(Vec::new());\n         visit::walk_crate(&mut path_finder, &cr, ());\n         let varrefs = path_finder.path_accumulator;\n \n@@ -1256,10 +1238,10 @@ foo_module!()\n     #[test]\n     fn pat_idents(){\n         let pat = string_to_pat(~\"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\");\n-        let mut pat_idents = new_name_finder(~[]);\n+        let mut pat_idents = new_name_finder(Vec::new());\n         pat_idents.visit_pat(pat, ());\n         assert_eq!(pat_idents.ident_accumulator,\n-                   strs_to_idents(~[\"a\",\"c\",\"b\",\"d\"]));\n+                   strs_to_idents(vec!(\"a\",\"c\",\"b\",\"d\")));\n     }\n \n }"}, {"sha": "4b27951aa507a9e8ae358f3e909d312a2b8ae426", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 74, "deletions": 87, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -41,8 +41,8 @@ struct Context<'a> {\n \n     // Parsed argument expressions and the types that we've found so far for\n     // them.\n-    args: ~[@ast::Expr],\n-    arg_types: ~[Option<ArgumentType>],\n+    args: Vec<@ast::Expr>,\n+    arg_types: Vec<Option<ArgumentType>>,\n     // Parsed named expressions and the types that we've found for them so far.\n     // Note that we keep a side-array of the ordering of the named arguments\n     // found to be sure that we can translate them in the same order that they\n@@ -52,9 +52,9 @@ struct Context<'a> {\n     name_ordering: ~[~str],\n \n     // Collection of the compiled `rt::Piece` structures\n-    pieces: ~[@ast::Expr],\n+    pieces: Vec<@ast::Expr> ,\n     name_positions: HashMap<~str, uint>,\n-    method_statics: ~[@ast::Item],\n+    method_statics: Vec<@ast::Item> ,\n \n     // Updated as arguments are consumed or methods are entered\n     nest_level: uint,\n@@ -70,10 +70,9 @@ struct Context<'a> {\n ///     Some((fmtstr, unnamed arguments, ordering of named arguments,\n ///           named arguments))\n fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> (@ast::Expr, Option<(@ast::Expr, ~[@ast::Expr], ~[~str],\n-                            HashMap<~str, @ast::Expr>)>)\n-{\n-    let mut args = ~[];\n+    -> (@ast::Expr, Option<(@ast::Expr, Vec<@ast::Expr>, ~[~str],\n+                            HashMap<~str, @ast::Expr>)>) {\n+    let mut args = Vec::new();\n     let mut names = HashMap::<~str, @ast::Expr>::new();\n     let mut order = ~[];\n \n@@ -357,7 +356,7 @@ impl<'a> Context<'a> {\n \n     /// These attributes are applied to all statics that this syntax extension\n     /// will generate.\n-    fn static_attrs(&self) -> ~[ast::Attribute] {\n+    fn static_attrs(&self) -> Vec<ast::Attribute> {\n         // Flag statics as `address_insignificant` so LLVM can merge duplicate\n         // globals as much as possible (which we're generating a whole lot of).\n         let unnamed = self.ecx\n@@ -371,53 +370,53 @@ impl<'a> Context<'a> {\n                                            InternedString::new(\"dead_code\"));\n         let allow_dead_code = self.ecx.meta_list(self.fmtsp,\n                                                  InternedString::new(\"allow\"),\n-                                                 ~[dead_code]);\n+                                                 vec!(dead_code));\n         let allow_dead_code = self.ecx.attribute(self.fmtsp, allow_dead_code);\n-        return ~[unnamed, allow_dead_code];\n+        return vec!(unnamed, allow_dead_code);\n     }\n \n-    fn parsepath(&self, s: &str) -> ~[ast::Ident] {\n-        ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n-          self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s)]\n+    fn parsepath(&self, s: &str) -> Vec<ast::Ident> {\n+        vec!(self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n+          self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s))\n     }\n \n-    fn rtpath(&self, s: &str) -> ~[ast::Ident] {\n-        ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n-          self.ecx.ident_of(\"rt\"), self.ecx.ident_of(s)]\n+    fn rtpath(&self, s: &str) -> Vec<ast::Ident> {\n+        vec!(self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n+          self.ecx.ident_of(\"rt\"), self.ecx.ident_of(s))\n     }\n \n-    fn ctpath(&self, s: &str) -> ~[ast::Ident] {\n-        ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n-          self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s)]\n+    fn ctpath(&self, s: &str) -> Vec<ast::Ident> {\n+        vec!(self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n+          self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s))\n     }\n \n     fn none(&self) -> @ast::Expr {\n-        let none = self.ecx.path_global(self.fmtsp, ~[\n+        let none = self.ecx.path_global(self.fmtsp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"option\"),\n-                self.ecx.ident_of(\"None\")]);\n+                self.ecx.ident_of(\"None\")));\n         self.ecx.expr_path(none)\n     }\n \n     fn some(&self, e: @ast::Expr) -> @ast::Expr {\n-        let p = self.ecx.path_global(self.fmtsp, ~[\n+        let p = self.ecx.path_global(self.fmtsp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"option\"),\n-                self.ecx.ident_of(\"Some\")]);\n+                self.ecx.ident_of(\"Some\")));\n         let p = self.ecx.expr_path(p);\n-        self.ecx.expr_call(self.fmtsp, p, ~[e])\n+        self.ecx.expr_call(self.fmtsp, p, vec!(e))\n     }\n \n     fn trans_count(&self, c: parse::Count) -> @ast::Expr {\n         let sp = self.fmtsp;\n         match c {\n             parse::CountIs(i) => {\n                 self.ecx.expr_call_global(sp, self.rtpath(\"CountIs\"),\n-                                          ~[self.ecx.expr_uint(sp, i)])\n+                                          vec!(self.ecx.expr_uint(sp, i)))\n             }\n             parse::CountIsParam(i) => {\n                 self.ecx.expr_call_global(sp, self.rtpath(\"CountIsParam\"),\n-                                          ~[self.ecx.expr_uint(sp, i)])\n+                                          vec!(self.ecx.expr_uint(sp, i)))\n             }\n             parse::CountImplied => {\n                 let path = self.ecx.path_global(sp, self.rtpath(\"CountImplied\"));\n@@ -434,7 +433,7 @@ impl<'a> Context<'a> {\n                 };\n                 let i = i + self.args.len();\n                 self.ecx.expr_call_global(sp, self.rtpath(\"CountIsParam\"),\n-                                          ~[self.ecx.expr_uint(sp, i)])\n+                                          vec!(self.ecx.expr_uint(sp, i)))\n             }\n         }\n     }\n@@ -450,21 +449,19 @@ impl<'a> Context<'a> {\n                         }).collect();\n                         let s = token::intern_and_get_ident(arm.selector);\n                         let selector = self.ecx.expr_str(sp, s);\n-                        self.ecx.expr_struct(sp, p, ~[\n+                        self.ecx.expr_struct(sp, p, vec!(\n                                 self.ecx.field_imm(sp,\n                                                    self.ecx.ident_of(\"selector\"),\n                                                    selector),\n                                 self.ecx.field_imm(sp, self.ecx.ident_of(\"result\"),\n-                                                   self.ecx.expr_vec_slice(sp, result)),\n-                                ])\n+                                                   self.ecx.expr_vec_slice(sp, result))))\n                     }).collect();\n                 let default = default.iter().map(|p| {\n                         self.trans_piece(p)\n                     }).collect();\n-                self.ecx.expr_call_global(sp, self.rtpath(\"Select\"), ~[\n+                self.ecx.expr_call_global(sp, self.rtpath(\"Select\"), vec!(\n                         self.ecx.expr_vec_slice(sp, arms),\n-                        self.ecx.expr_vec_slice(sp, default),\n-                        ])\n+                        self.ecx.expr_vec_slice(sp, default)))\n             }\n             parse::Plural(offset, ref arms, ref default) => {\n                 let offset = match offset {\n@@ -487,23 +484,21 @@ impl<'a> Context<'a> {\n                             }\n                         };\n                         let selector = self.ecx.expr_call_global(sp,\n-                                                                 lr, ~[selarg]);\n-                        self.ecx.expr_struct(sp, p, ~[\n+                                                                 lr, vec!(selarg));\n+                        self.ecx.expr_struct(sp, p, vec!(\n                                 self.ecx.field_imm(sp,\n                                                    self.ecx.ident_of(\"selector\"),\n                                                    selector),\n                                 self.ecx.field_imm(sp, self.ecx.ident_of(\"result\"),\n-                                                   self.ecx.expr_vec_slice(sp, result)),\n-                                ])\n+                                                   self.ecx.expr_vec_slice(sp, result))))\n                     }).collect();\n                 let default = default.iter().map(|p| {\n                         self.trans_piece(p)\n                     }).collect();\n-                self.ecx.expr_call_global(sp, self.rtpath(\"Plural\"), ~[\n+                self.ecx.expr_call_global(sp, self.rtpath(\"Plural\"), vec!(\n                         offset,\n                         self.ecx.expr_vec_slice(sp, arms),\n-                        self.ecx.expr_vec_slice(sp, default),\n-                        ])\n+                        self.ecx.expr_vec_slice(sp, default)))\n             }\n         };\n         let life = self.ecx.lifetime(sp, self.ecx.ident_of(\"static\").name);\n@@ -512,7 +507,7 @@ impl<'a> Context<'a> {\n                 true,\n                 self.rtpath(\"Method\"),\n                 opt_vec::with(life),\n-                ~[]\n+                Vec::new()\n                     ), None);\n         let st = ast::ItemStatic(ty, ast::MutImmutable, method);\n         let static_name = self.ecx.ident_of(format!(\"__STATIC_METHOD_{}\",\n@@ -530,13 +525,13 @@ impl<'a> Context<'a> {\n                 let s = token::intern_and_get_ident(s);\n                 self.ecx.expr_call_global(sp,\n                                           self.rtpath(\"String\"),\n-                                          ~[\n+                                          vec!(\n                     self.ecx.expr_str(sp, s)\n-                ])\n+                ))\n             }\n             parse::CurrentArgument => {\n                 let nil = self.ecx.expr_lit(sp, ast::LitNil);\n-                self.ecx.expr_call_global(sp, self.rtpath(\"CurrentArgument\"), ~[nil])\n+                self.ecx.expr_call_global(sp, self.rtpath(\"CurrentArgument\"), vec!(nil))\n             }\n             parse::Argument(ref arg) => {\n                 // Translate the position\n@@ -549,7 +544,7 @@ impl<'a> Context<'a> {\n                     }\n                     parse::ArgumentIs(i) => {\n                         self.ecx.expr_call_global(sp, self.rtpath(\"ArgumentIs\"),\n-                                                  ~[self.ecx.expr_uint(sp, i)])\n+                                                  vec!(self.ecx.expr_uint(sp, i)))\n                     }\n                     // Named arguments are converted to positional arguments at\n                     // the end of the list of arguments\n@@ -560,7 +555,7 @@ impl<'a> Context<'a> {\n                         };\n                         let i = i + self.args.len();\n                         self.ecx.expr_call_global(sp, self.rtpath(\"ArgumentIs\"),\n-                                                  ~[self.ecx.expr_uint(sp, i)])\n+                                                  vec!(self.ecx.expr_uint(sp, i)))\n                     }\n                 };\n \n@@ -583,13 +578,12 @@ impl<'a> Context<'a> {\n                 let prec = self.trans_count(arg.format.precision);\n                 let width = self.trans_count(arg.format.width);\n                 let path = self.ecx.path_global(sp, self.rtpath(\"FormatSpec\"));\n-                let fmt = self.ecx.expr_struct(sp, path, ~[\n+                let fmt = self.ecx.expr_struct(sp, path, vec!(\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"align\"), align),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\"), flags),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\"), prec),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width),\n-                ]);\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width)));\n \n                 // Translate the method (if any)\n                 let method = match arg.method {\n@@ -600,24 +594,23 @@ impl<'a> Context<'a> {\n                     }\n                 };\n                 let path = self.ecx.path_global(sp, self.rtpath(\"Argument\"));\n-                let s = self.ecx.expr_struct(sp, path, ~[\n+                let s = self.ecx.expr_struct(sp, path, vec!(\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"position\"), pos),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"method\"), method),\n-                ]);\n-                self.ecx.expr_call_global(sp, self.rtpath(\"Argument\"), ~[s])\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"method\"), method)));\n+                self.ecx.expr_call_global(sp, self.rtpath(\"Argument\"), vec!(s))\n             }\n         }\n     }\n \n     /// Actually builds the expression which the iformat! block will be expanded\n     /// to\n     fn to_expr(&self, extra: @ast::Expr) -> @ast::Expr {\n-        let mut lets = ~[];\n-        let mut locals = ~[];\n+        let mut lets = Vec::new();\n+        let mut locals = Vec::new();\n         let mut names = vec::from_fn(self.name_positions.len(), |_| None);\n-        let mut pats = ~[];\n-        let mut heads = ~[];\n+        let mut pats = Vec::new();\n+        let mut heads = Vec::new();\n \n         // First, declare all of our methods that are statics\n         for &method in self.method_statics.iter() {\n@@ -631,15 +624,14 @@ impl<'a> Context<'a> {\n         let fmt = self.ecx.expr_vec(self.fmtsp, self.pieces.clone());\n         let piece_ty = self.ecx.ty_path(self.ecx.path_all(\n                 self.fmtsp,\n-                true, ~[\n+                true, vec!(\n                     self.ecx.ident_of(\"std\"),\n                     self.ecx.ident_of(\"fmt\"),\n                     self.ecx.ident_of(\"rt\"),\n-                    self.ecx.ident_of(\"Piece\"),\n-                ],\n+                    self.ecx.ident_of(\"Piece\")),\n                 opt_vec::with(\n                     self.ecx.lifetime(self.fmtsp, self.ecx.ident_of(\"static\").name)),\n-                ~[]\n+                Vec::new()\n             ), None);\n         let ty = ast::TyFixedLengthVec(\n             piece_ty,\n@@ -696,18 +688,17 @@ impl<'a> Context<'a> {\n         // Now create the fmt::Arguments struct with all our locals we created.\n         let fmt = self.ecx.expr_ident(self.fmtsp, static_name);\n         let args_slice = self.ecx.expr_ident(self.fmtsp, slicename);\n-        let result = self.ecx.expr_call_global(self.fmtsp, ~[\n+        let result = self.ecx.expr_call_global(self.fmtsp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"fmt\"),\n                 self.ecx.ident_of(\"Arguments\"),\n-                self.ecx.ident_of(\"new\"),\n-            ], ~[fmt, args_slice]);\n+                self.ecx.ident_of(\"new\")), vec!(fmt, args_slice));\n \n         // We did all the work of making sure that the arguments\n         // structure is safe, so we can safely have an unsafe block.\n         let result = self.ecx.expr_block(P(ast::Block {\n-           view_items: ~[],\n-           stmts: ~[],\n+           view_items: Vec::new(),\n+           stmts: Vec::new(),\n            expr: Some(result),\n            id: ast::DUMMY_NODE_ID,\n            rules: ast::UnsafeBlock(ast::CompilerGenerated),\n@@ -716,8 +707,8 @@ impl<'a> Context<'a> {\n         let resname = self.ecx.ident_of(\"__args\");\n         lets.push(self.ecx.stmt_let(self.fmtsp, false, resname, result));\n         let res = self.ecx.expr_ident(self.fmtsp, resname);\n-        let result = self.ecx.expr_call(extra.span, extra, ~[\n-                            self.ecx.expr_addr_of(extra.span, res)]);\n+        let result = self.ecx.expr_call(extra.span, extra, vec!(\n+                            self.ecx.expr_addr_of(extra.span, res)));\n         let body = self.ecx.expr_block(self.ecx.block(self.fmtsp, lets,\n                                                       Some(result)));\n \n@@ -749,9 +740,9 @@ impl<'a> Context<'a> {\n         // But the nested match expression is proved to perform not as well\n         // as series of let's; the first approach does.\n         let pat = self.ecx.pat(self.fmtsp, ast::PatTup(pats));\n-        let arm = self.ecx.arm(self.fmtsp, ~[pat], body);\n+        let arm = self.ecx.arm(self.fmtsp, vec!(pat), body);\n         let head = self.ecx.expr(self.fmtsp, ast::ExprTup(heads));\n-        self.ecx.expr_match(self.fmtsp, head, ~[arm])\n+        self.ecx.expr_match(self.fmtsp, head, vec!(arm))\n     }\n \n     fn format_arg(&self, sp: Span, argno: Position, arg: @ast::Expr)\n@@ -787,31 +778,27 @@ impl<'a> Context<'a> {\n                 }\n             }\n             String => {\n-                return self.ecx.expr_call_global(sp, ~[\n+                return self.ecx.expr_call_global(sp, vec!(\n                         self.ecx.ident_of(\"std\"),\n                         self.ecx.ident_of(\"fmt\"),\n-                        self.ecx.ident_of(\"argumentstr\"),\n-                    ], ~[arg])\n+                        self.ecx.ident_of(\"argumentstr\")), vec!(arg))\n             }\n             Unsigned => {\n-                return self.ecx.expr_call_global(sp, ~[\n+                return self.ecx.expr_call_global(sp, vec!(\n                         self.ecx.ident_of(\"std\"),\n                         self.ecx.ident_of(\"fmt\"),\n-                        self.ecx.ident_of(\"argumentuint\"),\n-                    ], ~[arg])\n+                        self.ecx.ident_of(\"argumentuint\")), vec!(arg))\n             }\n         };\n \n-        let format_fn = self.ecx.path_global(sp, ~[\n+        let format_fn = self.ecx.path_global(sp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"fmt\"),\n-                self.ecx.ident_of(fmt_fn),\n-            ]);\n-        self.ecx.expr_call_global(sp, ~[\n+                self.ecx.ident_of(fmt_fn)));\n+        self.ecx.expr_call_global(sp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"fmt\"),\n-                self.ecx.ident_of(\"argument\"),\n-            ], ~[self.ecx.expr_path(format_fn), arg])\n+                self.ecx.ident_of(\"argument\")), vec!(self.ecx.expr_path(format_fn), arg))\n     }\n }\n \n@@ -832,8 +819,8 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n /// expression.\n pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     extra: @ast::Expr,\n-                                    efmt: @ast::Expr, args: ~[@ast::Expr],\n-                                    name_ordering: ~[~str],\n+                                    efmt: @ast::Expr, args: Vec<@ast::Expr>,\n+                                    name_ordering: Vec<~str>,\n                                     names: HashMap<~str, @ast::Expr>) -> @ast::Expr {\n     let arg_types = vec::from_fn(args.len(), |_| None);\n     let mut cx = Context {\n@@ -846,8 +833,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         name_ordering: name_ordering,\n         nest_level: 0,\n         next_arg: 0,\n-        pieces: ~[],\n-        method_statics: ~[],\n+        pieces: Vec::new(),\n+        method_statics: Vec::new(),\n         fmtsp: sp,\n     };\n     cx.fmtsp = efmt.span;"}, {"sha": "3b8df84acc3237f57097ebacb0432534c4612973", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -41,11 +41,11 @@ pub mod rt {\n     pub use codemap::{BytePos, Span, dummy_spanned};\n \n     pub trait ToTokens {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> ~[TokenTree];\n+        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> ;\n     }\n \n-    impl ToTokens for ~[TokenTree] {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> ~[TokenTree] {\n+    impl ToTokens for Vec<TokenTree> {\n+        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n             (*self).clone()\n         }\n     }\n@@ -201,7 +201,7 @@ pub mod rt {\n     macro_rules! impl_to_tokens(\n         ($t:ty) => (\n             impl ToTokens for $t {\n-                fn to_tokens(&self, cx: &ExtCtxt) -> ~[TokenTree] {\n+                fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n                     cx.parse_tts(self.to_source())\n                 }\n             }\n@@ -211,7 +211,7 @@ pub mod rt {\n     macro_rules! impl_to_tokens_self(\n         ($t:ty) => (\n             impl<'a> ToTokens for $t {\n-                fn to_tokens(&self, cx: &ExtCtxt) -> ~[TokenTree] {\n+                fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n                     cx.parse_tts(self.to_source())\n                 }\n             }\n@@ -242,7 +242,7 @@ pub mod rt {\n         fn parse_item(&self, s: ~str) -> @ast::Item;\n         fn parse_expr(&self, s: ~str) -> @ast::Expr;\n         fn parse_stmt(&self, s: ~str) -> @ast::Stmt;\n-        fn parse_tts(&self, s: ~str) -> ~[ast::TokenTree];\n+        fn parse_tts(&self, s: ~str) -> Vec<ast::TokenTree> ;\n     }\n \n     impl<'a> ExtParseUtils for ExtCtxt<'a> {\n@@ -266,7 +266,7 @@ pub mod rt {\n             parse::parse_stmt_from_source_str(\"<quote expansion>\".to_str(),\n                                               s,\n                                               self.cfg(),\n-                                              ~[],\n+                                              Vec::new(),\n                                               self.parse_sess())\n         }\n \n@@ -277,7 +277,7 @@ pub mod rt {\n                                               self.parse_sess())\n         }\n \n-        fn parse_tts(&self, s: ~str) -> ~[ast::TokenTree] {\n+        fn parse_tts(&self, s: ~str) -> Vec<ast::TokenTree> {\n             parse::parse_tts_from_source_str(\"<quote expansion>\".to_str(),\n                                              s,\n                                              self.cfg(),\n@@ -298,16 +298,16 @@ pub fn expand_quote_tokens(cx: &mut ExtCtxt,\n pub fn expand_quote_expr(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::TokenTree]) -> base::MacResult {\n-    let expanded = expand_parse_call(cx, sp, \"parse_expr\", ~[], tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_expr\", Vec::new(), tts);\n     base::MRExpr(expanded)\n }\n \n pub fn expand_quote_item(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::TokenTree]) -> base::MacResult {\n-    let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n+    let e_attrs = cx.expr_vec_uniq(sp, Vec::new());\n     let expanded = expand_parse_call(cx, sp, \"parse_item\",\n-                                    ~[e_attrs], tts);\n+                                    vec!(e_attrs), tts);\n     base::MRExpr(expanded)\n }\n \n@@ -316,7 +316,7 @@ pub fn expand_quote_pat(cx: &mut ExtCtxt,\n                         tts: &[ast::TokenTree]) -> base::MacResult {\n     let e_refutable = cx.expr_lit(sp, ast::LitBool(true));\n     let expanded = expand_parse_call(cx, sp, \"parse_pat\",\n-                                    ~[e_refutable], tts);\n+                                    vec!(e_refutable), tts);\n     base::MRExpr(expanded)\n }\n \n@@ -325,20 +325,20 @@ pub fn expand_quote_ty(cx: &mut ExtCtxt,\n                        tts: &[ast::TokenTree]) -> base::MacResult {\n     let e_param_colons = cx.expr_lit(sp, ast::LitBool(false));\n     let expanded = expand_parse_call(cx, sp, \"parse_ty\",\n-                                     ~[e_param_colons], tts);\n+                                     vec!(e_param_colons), tts);\n     base::MRExpr(expanded)\n }\n \n pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::TokenTree]) -> base::MacResult {\n-    let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n+    let e_attrs = cx.expr_vec_uniq(sp, Vec::new());\n     let expanded = expand_parse_call(cx, sp, \"parse_stmt\",\n-                                    ~[e_attrs], tts);\n+                                    vec!(e_attrs), tts);\n     base::MRExpr(expanded)\n }\n \n-fn ids_ext(strs: ~[~str]) -> ~[ast::Ident] {\n+fn ids_ext(strs: Vec<~str> ) -> Vec<ast::Ident> {\n     strs.map(|str| str_to_ident(*str))\n }\n \n@@ -352,7 +352,7 @@ fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> @ast::Expr {\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"ident_of\"),\n-                        ~[e_str])\n+                        vec!(e_str))\n }\n \n fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::BinOp) -> @ast::Expr {\n@@ -377,18 +377,18 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n         BINOP(binop) => {\n             return cx.expr_call_ident(sp,\n                                       id_ext(\"BINOP\"),\n-                                      ~[mk_binop(cx, sp, binop)]);\n+                                      vec!(mk_binop(cx, sp, binop)));\n         }\n         BINOPEQ(binop) => {\n             return cx.expr_call_ident(sp,\n                                       id_ext(\"BINOPEQ\"),\n-                                      ~[mk_binop(cx, sp, binop)]);\n+                                      vec!(mk_binop(cx, sp, binop)));\n         }\n \n         LIT_CHAR(i) => {\n             let e_char = cx.expr_lit(sp, ast::LitChar(i));\n \n-            return cx.expr_call_ident(sp, id_ext(\"LIT_CHAR\"), ~[e_char]);\n+            return cx.expr_call_ident(sp, id_ext(\"LIT_CHAR\"), vec!(e_char));\n         }\n \n         LIT_INT(i, ity) => {\n@@ -405,7 +405,7 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n \n             return cx.expr_call_ident(sp,\n                                       id_ext(\"LIT_INT\"),\n-                                      ~[e_i64, e_ity]);\n+                                      vec!(e_i64, e_ity));\n         }\n \n         LIT_UINT(u, uty) => {\n@@ -422,15 +422,15 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n \n             return cx.expr_call_ident(sp,\n                                       id_ext(\"LIT_UINT\"),\n-                                      ~[e_u64, e_uty]);\n+                                      vec!(e_u64, e_uty));\n         }\n \n         LIT_INT_UNSUFFIXED(i) => {\n             let e_i64 = cx.expr_lit(sp, ast::LitInt(i, ast::TyI64));\n \n             return cx.expr_call_ident(sp,\n                                       id_ext(\"LIT_INT_UNSUFFIXED\"),\n-                                      ~[e_i64]);\n+                                      vec!(e_i64));\n         }\n \n         LIT_FLOAT(fident, fty) => {\n@@ -444,39 +444,39 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n \n             return cx.expr_call_ident(sp,\n                                       id_ext(\"LIT_FLOAT\"),\n-                                      ~[e_fident, e_fty]);\n+                                      vec!(e_fident, e_fty));\n         }\n \n         LIT_STR(ident) => {\n             return cx.expr_call_ident(sp,\n                                       id_ext(\"LIT_STR\"),\n-                                      ~[mk_ident(cx, sp, ident)]);\n+                                      vec!(mk_ident(cx, sp, ident)));\n         }\n \n         LIT_STR_RAW(ident, n) => {\n             return cx.expr_call_ident(sp,\n                                       id_ext(\"LIT_STR_RAW\"),\n-                                      ~[mk_ident(cx, sp, ident),\n-                                        cx.expr_uint(sp, n)]);\n+                                      vec!(mk_ident(cx, sp, ident),\n+                                        cx.expr_uint(sp, n)));\n         }\n \n         IDENT(ident, b) => {\n             return cx.expr_call_ident(sp,\n                                       id_ext(\"IDENT\"),\n-                                      ~[mk_ident(cx, sp, ident),\n-                                        cx.expr_bool(sp, b)]);\n+                                      vec!(mk_ident(cx, sp, ident),\n+                                        cx.expr_bool(sp, b)));\n         }\n \n         LIFETIME(ident) => {\n             return cx.expr_call_ident(sp,\n                                       id_ext(\"LIFETIME\"),\n-                                      ~[mk_ident(cx, sp, ident)]);\n+                                      vec!(mk_ident(cx, sp, ident)));\n         }\n \n         DOC_COMMENT(ident) => {\n             return cx.expr_call_ident(sp,\n                                       id_ext(\"DOC_COMMENT\"),\n-                                      ~[mk_ident(cx, sp, ident)]);\n+                                      vec!(mk_ident(cx, sp, ident)));\n         }\n \n         INTERPOLATED(_) => fail!(\"quote! with interpolated token\"),\n@@ -523,21 +523,21 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n }\n \n \n-fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> ~[@ast::Stmt] {\n+fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> Vec<@ast::Stmt> {\n \n     match *tt {\n \n         ast::TTTok(sp, ref tok) => {\n             let e_sp = cx.expr_ident(sp, id_ext(\"_sp\"));\n             let e_tok = cx.expr_call_ident(sp,\n                                            id_ext(\"TTTok\"),\n-                                           ~[e_sp, mk_token(cx, sp, tok)]);\n+                                           vec!(e_sp, mk_token(cx, sp, tok)));\n             let e_push =\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, id_ext(\"tt\")),\n                                     id_ext(\"push\"),\n-                                    ~[e_tok]);\n-            ~[cx.stmt_expr(e_push)]\n+                                    vec!(e_tok));\n+            vec!(cx.stmt_expr(e_push))\n         }\n \n         ast::TTDelim(ref tts) => mk_tts(cx, sp, **tts),\n@@ -551,22 +551,22 @@ fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> ~[@ast::Stmt] {\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, ident),\n                                     id_ext(\"to_tokens\"),\n-                                    ~[cx.expr_ident(sp, id_ext(\"ext_cx\"))]);\n+                                    vec!(cx.expr_ident(sp, id_ext(\"ext_cx\"))));\n \n             let e_push =\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, id_ext(\"tt\")),\n                                     id_ext(\"push_all_move\"),\n-                                    ~[e_to_toks]);\n+                                    vec!(e_to_toks));\n \n-            ~[cx.stmt_expr(e_push)]\n+            vec!(cx.stmt_expr(e_push))\n         }\n     }\n }\n \n fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> ~[@ast::Stmt] {\n-    let mut ss = ~[];\n+    -> Vec<@ast::Stmt> {\n+    let mut ss = Vec::new();\n     for tt in tts.iter() {\n         ss.push_all_move(mk_tt(cx, sp, tt));\n     }\n@@ -623,20 +623,20 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let e_sp = cx.expr_method_call(sp,\n                                    cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                                    id_ext(\"call_site\"),\n-                                   ~[]);\n+                                   Vec::new());\n \n     let stmt_let_sp = cx.stmt_let(sp, false,\n                                   id_ext(\"_sp\"),\n                                   e_sp);\n \n     let stmt_let_tt = cx.stmt_let(sp, true,\n                                   id_ext(\"tt\"),\n-                                  cx.expr_vec_uniq(sp, ~[]));\n+                                  cx.expr_vec_uniq(sp, Vec::new()));\n \n     let block = cx.expr_block(\n         cx.block_all(sp,\n-                     ~[],\n-                     ~[stmt_let_sp, stmt_let_tt] + mk_tts(cx, sp, tts),\n+                     Vec::new(),\n+                     vec!(stmt_let_sp, stmt_let_tt) + mk_tts(cx, sp, tts),\n                      Some(cx.expr_ident(sp, id_ext(\"tt\")))));\n \n     (cx_expr, block)\n@@ -646,36 +646,36 @@ fn expand_wrapper(cx: &ExtCtxt,\n                   sp: Span,\n                   cx_expr: @ast::Expr,\n                   expr: @ast::Expr) -> @ast::Expr {\n-    let uses = ~[ cx.view_use_glob(sp, ast::Inherited,\n-                                   ids_ext(~[~\"syntax\",\n+    let uses = vec!( cx.view_use_glob(sp, ast::Inherited,\n+                                   ids_ext(vec!(~\"syntax\",\n                                              ~\"ext\",\n                                              ~\"quote\",\n-                                             ~\"rt\"])) ];\n+                                             ~\"rt\"))) );\n \n     let stmt_let_ext_cx = cx.stmt_let(sp, false, id_ext(\"ext_cx\"), cx_expr);\n \n-    cx.expr_block(cx.block_all(sp, uses, ~[stmt_let_ext_cx], Some(expr)))\n+    cx.expr_block(cx.block_all(sp, uses, vec!(stmt_let_ext_cx), Some(expr)))\n }\n \n fn expand_parse_call(cx: &ExtCtxt,\n                      sp: Span,\n                      parse_method: &str,\n-                     arg_exprs: ~[@ast::Expr],\n+                     arg_exprs: Vec<@ast::Expr> ,\n                      tts: &[ast::TokenTree]) -> @ast::Expr {\n     let (cx_expr, tts_expr) = expand_tts(cx, sp, tts);\n \n     let cfg_call = || cx.expr_method_call(\n         sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n-        id_ext(\"cfg\"), ~[]);\n+        id_ext(\"cfg\"), Vec::new());\n \n     let parse_sess_call = || cx.expr_method_call(\n         sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n-        id_ext(\"parse_sess\"), ~[]);\n+        id_ext(\"parse_sess\"), Vec::new());\n \n     let new_parser_call =\n         cx.expr_call(sp,\n                      cx.expr_ident(sp, id_ext(\"new_parser_from_tts\")),\n-                     ~[parse_sess_call(), cfg_call(), tts_expr]);\n+                     vec!(parse_sess_call(), cfg_call(), tts_expr));\n \n     let expr = cx.expr_method_call(sp, new_parser_call, id_ext(parse_method),\n                                    arg_exprs);"}, {"sha": "15e753ee49f7093d75c6cbe8aa8c04d488ed88fd", "filename": "src/libsyntax/ext/registrar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fregistrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Fregistrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fregistrar.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -16,7 +16,7 @@ use visit;\n use visit::Visitor;\n \n struct MacroRegistrarContext {\n-    registrars: ~[(ast::NodeId, Span)],\n+    registrars: Vec<(ast::NodeId, Span)> ,\n }\n \n impl Visitor<()> for MacroRegistrarContext {\n@@ -36,7 +36,7 @@ impl Visitor<()> for MacroRegistrarContext {\n \n pub fn find_macro_registrar(diagnostic: @diagnostic::SpanHandler,\n                             krate: &ast::Crate) -> Option<ast::DefId> {\n-    let mut ctx = MacroRegistrarContext { registrars: ~[] };\n+    let mut ctx = MacroRegistrarContext { registrars: Vec::new() };\n     visit::walk_crate(&mut ctx, krate, ());\n \n     match ctx.registrars.len() {"}, {"sha": "cb86f2cecaa6682a6107743dda0e61d15023abe2", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -99,11 +99,11 @@ nonempty body. */\n \n #[deriving(Clone)]\n pub struct MatcherPos {\n-    elts: ~[ast::Matcher], // maybe should be <'>? Need to understand regions.\n+    elts: Vec<ast::Matcher> , // maybe should be <'>? Need to understand regions.\n     sep: Option<Token>,\n     idx: uint,\n     up: Option<~MatcherPos>,\n-    matches: ~[~[@NamedMatch]],\n+    matches: vec!(Vec<@NamedMatch> ),\n     match_lo: uint, match_hi: uint,\n     sp_lo: BytePos,\n }\n@@ -117,7 +117,7 @@ pub fn count_names(ms: &[Matcher]) -> uint {\n         }})\n }\n \n-pub fn initial_matcher_pos(ms: ~[Matcher], sep: Option<Token>, lo: BytePos)\n+pub fn initial_matcher_pos(ms: Vec<Matcher> , sep: Option<Token>, lo: BytePos)\n                         -> ~MatcherPos {\n     let mut match_idx_hi = 0u;\n     for elt in ms.iter() {\n@@ -131,7 +131,7 @@ pub fn initial_matcher_pos(ms: ~[Matcher], sep: Option<Token>, lo: BytePos)\n             }\n         }\n     }\n-    let matches = vec::from_fn(count_names(ms), |_i| ~[]);\n+    let matches = vec::from_fn(count_names(ms), |_i| Vec::new());\n     ~MatcherPos {\n         elts: ms,\n         sep: sep,\n@@ -164,7 +164,7 @@ pub fn initial_matcher_pos(ms: ~[Matcher], sep: Option<Token>, lo: BytePos)\n // ast::Matcher it was derived from.\n \n pub enum NamedMatch {\n-    MatchedSeq(~[@NamedMatch], codemap::Span),\n+    MatchedSeq(Vec<@NamedMatch> , codemap::Span),\n     MatchedNonterminal(Nonterminal)\n }\n \n@@ -206,7 +206,7 @@ pub enum ParseResult {\n pub fn parse_or_else<R: Reader>(sess: @ParseSess,\n                                 cfg: ast::CrateConfig,\n                                 rdr: R,\n-                                ms: ~[Matcher])\n+                                ms: Vec<Matcher> )\n                                 -> HashMap<Ident, @NamedMatch> {\n     match parse(sess, cfg, rdr, ms) {\n         Success(m) => m,\n@@ -230,13 +230,13 @@ pub fn parse<R: Reader>(sess: @ParseSess,\n                         rdr: R,\n                         ms: &[Matcher])\n                         -> ParseResult {\n-    let mut cur_eis = ~[];\n+    let mut cur_eis = Vec::new();\n     cur_eis.push(initial_matcher_pos(ms.to_owned(), None, rdr.peek().sp.lo));\n \n     loop {\n-        let mut bb_eis = ~[]; // black-box parsed by parser.rs\n-        let mut next_eis = ~[]; // or proceed normally\n-        let mut eof_eis = ~[];\n+        let mut bb_eis = Vec::new(); // black-box parsed by parser.rs\n+        let mut next_eis = Vec::new(); // or proceed normally\n+        let mut eof_eis = Vec::new();\n \n         let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();\n \n@@ -317,13 +317,13 @@ pub fn parse<R: Reader>(sess: @ParseSess,\n                         new_ei.idx += 1u;\n                         //we specifically matched zero repeats.\n                         for idx in range(match_idx_lo, match_idx_hi) {\n-                            new_ei.matches[idx].push(@MatchedSeq(~[], sp));\n+                            new_ei.matches[idx].push(@MatchedSeq(Vec::new(), sp));\n                         }\n \n                         cur_eis.push(new_ei);\n                     }\n \n-                    let matches = vec::from_elem(ei.matches.len(), ~[]);\n+                    let matches = vec::from_elem(ei.matches.len(), Vec::new());\n                     let ei_t = ei;\n                     cur_eis.push(~MatcherPos {\n                         elts: (*matchers).clone(),\n@@ -351,7 +351,7 @@ pub fn parse<R: Reader>(sess: @ParseSess,\n         /* error messages here could be improved with links to orig. rules */\n         if token_name_eq(&tok, &EOF) {\n             if eof_eis.len() == 1u {\n-                let mut v = ~[];\n+                let mut v = Vec::new();\n                 for dv in eof_eis[0u].matches.mut_iter() {\n                     v.push(dv.pop().unwrap());\n                 }\n@@ -413,12 +413,12 @@ pub fn parse<R: Reader>(sess: @ParseSess,\n \n pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n     match name {\n-      \"item\" => match p.parse_item(~[]) {\n+      \"item\" => match p.parse_item(Vec::new()) {\n         Some(i) => token::NtItem(i),\n         None => p.fatal(\"expected an item keyword\")\n       },\n       \"block\" => token::NtBlock(p.parse_block()),\n-      \"stmt\" => token::NtStmt(p.parse_stmt(~[])),\n+      \"stmt\" => token::NtStmt(p.parse_stmt(Vec::new())),\n       \"pat\" => token::NtPat(p.parse_pat()),\n       \"expr\" => token::NtExpr(p.parse_expr()),\n       \"ty\" => token::NtTy(p.parse_ty(false /* no need to disambiguate*/)),"}, {"sha": "ed127c431176f8ea74f836e2ed76f8a25806efff", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -90,8 +90,8 @@ impl AnyMacro for ParserAnyMacro {\n \n struct MacroRulesMacroExpander {\n     name: Ident,\n-    lhses: @~[@NamedMatch],\n-    rhses: @~[@NamedMatch],\n+    lhses: @Vec<@NamedMatch> ,\n+    rhses: @Vec<@NamedMatch> ,\n }\n \n impl MacroExpander for MacroRulesMacroExpander {\n@@ -174,7 +174,7 @@ fn generic_extension(cx: &ExtCtxt,\n pub fn add_new_extension(cx: &mut ExtCtxt,\n                          sp: Span,\n                          name: Ident,\n-                         arg: ~[ast::TokenTree])\n+                         arg: Vec<ast::TokenTree> )\n                          -> base::MacResult {\n     // these spans won't matter, anyways\n     fn ms(m: Matcher_) -> Matcher {\n@@ -191,15 +191,14 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n     // The grammar for macro_rules! is:\n     // $( $lhs:mtcs => $rhs:tt );+\n     // ...quasiquoting this would be nice.\n-    let argument_gram = ~[\n-        ms(MatchSeq(~[\n+    let argument_gram = vec!(\n+        ms(MatchSeq(vec!(\n             ms(MatchNonterminal(lhs_nm, special_idents::matchers, 0u)),\n             ms(MatchTok(FAT_ARROW)),\n-            ms(MatchNonterminal(rhs_nm, special_idents::tt, 1u)),\n-        ], Some(SEMI), false, 0u, 2u)),\n+            ms(MatchNonterminal(rhs_nm, special_idents::tt, 1u))), Some(SEMI), false, 0u, 2u)),\n         //to phase into semicolon-termination instead of\n         //semicolon-separation\n-        ms(MatchSeq(~[ms(MatchTok(SEMI))], None, true, 2u, 2u))];\n+        ms(MatchSeq(vec!(ms(MatchTok(SEMI))), None, true, 2u, 2u)));\n \n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):"}, {"sha": "690ae82741cbaaa0361d23c226eaeaa7187456f8", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -22,7 +22,7 @@ use collections::HashMap;\n \n ///an unzipping of `TokenTree`s\n struct TtFrame {\n-    forest: @~[ast::TokenTree],\n+    forest: @Vec<ast::TokenTree> ,\n     idx: Cell<uint>,\n     dotdotdoted: bool,\n     sep: Option<Token>,\n@@ -35,8 +35,8 @@ pub struct TtReader {\n     priv stack: RefCell<@TtFrame>,\n     /* for MBE-style macro transcription */\n     priv interpolations: RefCell<HashMap<Ident, @NamedMatch>>,\n-    priv repeat_idx: RefCell<~[uint]>,\n-    priv repeat_len: RefCell<~[uint]>,\n+    priv repeat_idx: RefCell<Vec<uint> >,\n+    priv repeat_len: RefCell<Vec<uint> >,\n     /* cached: */\n     cur_tok: RefCell<Token>,\n     cur_span: RefCell<Span>,\n@@ -47,7 +47,7 @@ pub struct TtReader {\n  *  should) be none. */\n pub fn new_tt_reader(sp_diag: @SpanHandler,\n                      interp: Option<HashMap<Ident, @NamedMatch>>,\n-                     src: ~[ast::TokenTree])\n+                     src: Vec<ast::TokenTree> )\n                      -> TtReader {\n     let r = TtReader {\n         sp_diag: sp_diag,\n@@ -62,8 +62,8 @@ pub fn new_tt_reader(sp_diag: @SpanHandler,\n             None => RefCell::new(HashMap::new()),\n             Some(x) => RefCell::new(x),\n         },\n-        repeat_idx: RefCell::new(~[]),\n-        repeat_len: RefCell::new(~[]),\n+        repeat_idx: RefCell::new(Vec::new()),\n+        repeat_len: RefCell::new(Vec::new()),\n         /* dummy values, never read: */\n         cur_tok: RefCell::new(EOF),\n         cur_span: RefCell::new(DUMMY_SP),"}, {"sha": "cb6bc3c1b27711683a8691958d3decd0dfbd8144", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -22,11 +22,11 @@ pub trait Folder {\n         noop_fold_crate(c, self)\n     }\n \n-    fn fold_meta_items(&mut self, meta_items: &[@MetaItem]) -> ~[@MetaItem] {\n+    fn fold_meta_items(&mut self, meta_items: &[@MetaItem]) -> Vec<@MetaItem> {\n         meta_items.map(|x| fold_meta_item_(*x, self))\n     }\n \n-    fn fold_view_paths(&mut self, view_paths: &[@ViewPath]) -> ~[@ViewPath] {\n+    fn fold_view_paths(&mut self, view_paths: &[@ViewPath]) -> Vec<@ViewPath> {\n         view_paths.map(|view_path| {\n             let inner_view_path = match view_path.node {\n                 ViewPathSimple(ref ident, ref path, node_id) => {\n@@ -283,7 +283,7 @@ pub trait Folder {\n         }\n     }\n \n-    fn map_exprs(&self, f: |@Expr| -> @Expr, es: &[@Expr]) -> ~[@Expr] {\n+    fn map_exprs(&self, f: |@Expr| -> @Expr, es: &[@Expr]) -> Vec<@Expr> {\n         es.map(|x| f(*x))\n     }\n \n@@ -370,7 +370,7 @@ fn fold_arg_<T: Folder>(a: &Arg, fld: &mut T) -> Arg {\n // since many token::IDENT are not necessary part of let bindings and most\n // token::LIFETIME are certainly not loop labels. But we can't tell in their\n // token form. So this is less ideal and hacky but it works.\n-pub fn fold_tts<T: Folder>(tts: &[TokenTree], fld: &mut T) -> ~[TokenTree] {\n+pub fn fold_tts<T: Folder>(tts: &[TokenTree], fld: &mut T) -> Vec<TokenTree> {\n     tts.map(|tt| {\n         match *tt {\n             TTTok(span, ref tok) =>"}, {"sha": "5524fdf1caf9c719e1ba6e28b14678ca2d18a588", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -21,14 +21,14 @@ use std::default::Default;\n #[deriving(Clone, Encodable, Decodable, Hash)]\n pub enum OptVec<T> {\n     Empty,\n-    Vec(~[T])\n+    Vec(Vec<T> )\n }\n \n pub fn with<T>(t: T) -> OptVec<T> {\n-    Vec(~[t])\n+    Vec(vec!(t))\n }\n \n-pub fn from<T>(t: ~[T]) -> OptVec<T> {\n+pub fn from<T>(t: Vec<T> ) -> OptVec<T> {\n     if t.len() == 0 {\n         Empty\n     } else {\n@@ -44,7 +44,7 @@ impl<T> OptVec<T> {\n                 return;\n             }\n             Empty => {\n-                *self = Vec(~[t]);\n+                *self = Vec(vec!(t));\n             }\n         }\n     }\n@@ -121,11 +121,11 @@ impl<T> OptVec<T> {\n     }\n \n     #[inline]\n-    pub fn map_to_vec<B>(&self, op: |&T| -> B) -> ~[B] {\n+    pub fn map_to_vec<B>(&self, op: |&T| -> B) -> Vec<B> {\n         self.iter().map(op).collect()\n     }\n \n-    pub fn mapi_to_vec<B>(&self, op: |uint, &T| -> B) -> ~[B] {\n+    pub fn mapi_to_vec<B>(&self, op: |uint, &T| -> B) -> Vec<B> {\n         let mut index = 0;\n         self.map_to_vec(|a| {\n             let i = index;\n@@ -135,16 +135,16 @@ impl<T> OptVec<T> {\n     }\n }\n \n-pub fn take_vec<T>(v: OptVec<T>) -> ~[T] {\n+pub fn take_vec<T>(v: OptVec<T>) -> Vec<T> {\n     match v {\n-        Empty => ~[],\n+        Empty => Vec::new(),\n         Vec(v) => v\n     }\n }\n \n impl<T:Clone> OptVec<T> {\n     pub fn prepend(&self, t: T) -> OptVec<T> {\n-        let mut v0 = ~[t];\n+        let mut v0 = vec!(t);\n         match *self {\n             Empty => {}\n             Vec(ref v1) => { v0.push_all(*v1); }"}, {"sha": "25bd051a69d5eb119a3b544867df19d2fa831f33", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -17,19 +17,19 @@ use parse::token::INTERPOLATED;\n \n // a parser that can parse attributes.\n pub trait ParserAttr {\n-    fn parse_outer_attributes(&mut self) -> ~[ast::Attribute];\n+    fn parse_outer_attributes(&mut self) -> Vec<ast::Attribute> ;\n     fn parse_attribute(&mut self, permit_inner: bool) -> ast::Attribute;\n     fn parse_inner_attrs_and_next(&mut self)\n-                                  -> (~[ast::Attribute], ~[ast::Attribute]);\n+                                  -> (Vec<ast::Attribute> , Vec<ast::Attribute> );\n     fn parse_meta_item(&mut self) -> @ast::MetaItem;\n-    fn parse_meta_seq(&mut self) -> ~[@ast::MetaItem];\n-    fn parse_optional_meta(&mut self) -> ~[@ast::MetaItem];\n+    fn parse_meta_seq(&mut self) -> Vec<@ast::MetaItem> ;\n+    fn parse_optional_meta(&mut self) -> Vec<@ast::MetaItem> ;\n }\n \n impl ParserAttr for Parser {\n     // Parse attributes that appear before an item\n-    fn parse_outer_attributes(&mut self) -> ~[ast::Attribute] {\n-        let mut attrs: ~[ast::Attribute] = ~[];\n+    fn parse_outer_attributes(&mut self) -> Vec<ast::Attribute> {\n+        let mut attrs: Vec<ast::Attribute> = Vec::new();\n         loop {\n             debug!(\"parse_outer_attributes: self.token={:?}\",\n                    self.token);\n@@ -116,9 +116,9 @@ impl ParserAttr for Parser {\n     // you can make the 'next' field an Option, but the result is going to be\n     // more useful as a vector.\n     fn parse_inner_attrs_and_next(&mut self)\n-                                  -> (~[ast::Attribute], ~[ast::Attribute]) {\n-        let mut inner_attrs: ~[ast::Attribute] = ~[];\n-        let mut next_outer_attrs: ~[ast::Attribute] = ~[];\n+                                  -> (Vec<ast::Attribute> , Vec<ast::Attribute> ) {\n+        let mut inner_attrs: Vec<ast::Attribute> = Vec::new();\n+        let mut next_outer_attrs: Vec<ast::Attribute> = Vec::new();\n         loop {\n             let attr = match self.token {\n                 token::INTERPOLATED(token::NtAttr(..)) => {\n@@ -188,17 +188,17 @@ impl ParserAttr for Parser {\n     }\n \n     // matches meta_seq = ( COMMASEP(meta_item) )\n-    fn parse_meta_seq(&mut self) -> ~[@ast::MetaItem] {\n+    fn parse_meta_seq(&mut self) -> Vec<@ast::MetaItem> {\n         self.parse_seq(&token::LPAREN,\n                        &token::RPAREN,\n                        seq_sep_trailing_disallowed(token::COMMA),\n                        |p| p.parse_meta_item()).node\n     }\n \n-    fn parse_optional_meta(&mut self) -> ~[@ast::MetaItem] {\n+    fn parse_optional_meta(&mut self) -> Vec<@ast::MetaItem> {\n         match self.token {\n             token::LPAREN => self.parse_meta_seq(),\n-            _ => ~[]\n+            _ => Vec::new()\n         }\n     }\n }"}, {"sha": "1c45fe5ee2c5001f4aa96d9e8cf8e9d5ad95ea6c", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -32,7 +32,7 @@ pub enum CommentStyle {\n #[deriving(Clone)]\n pub struct Comment {\n     style: CommentStyle,\n-    lines: ~[~str],\n+    lines: Vec<~str> ,\n     pos: BytePos\n }\n \n@@ -54,7 +54,7 @@ pub fn doc_comment_style(comment: &str) -> ast::AttrStyle {\n \n pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n     /// remove whitespace-only lines from the start/end of lines\n-    fn vertical_trim(lines: ~[~str]) -> ~[~str] {\n+    fn vertical_trim(lines: Vec<~str> ) -> Vec<~str> {\n         let mut i = 0u;\n         let mut j = lines.len();\n         // first line of all-stars should be omitted\n@@ -75,7 +75,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n     }\n \n     /// remove a \"[ \\t]*\\*\" block from each line, if possible\n-    fn horizontal_trim(lines: ~[~str]) -> ~[~str] {\n+    fn horizontal_trim(lines: Vec<~str> ) -> Vec<~str> {\n         let mut i = uint::MAX;\n         let mut can_trim = true;\n         let mut first = true;\n@@ -122,7 +122,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         let lines = comment.slice(3u, comment.len() - 2u)\n             .lines_any()\n             .map(|s| s.to_owned())\n-            .collect::<~[~str]>();\n+            .collect::<Vec<~str> >();\n \n         let lines = vertical_trim(lines);\n         let lines = horizontal_trim(lines);\n@@ -157,9 +157,9 @@ fn consume_non_eol_whitespace(rdr: &StringReader) {\n     }\n }\n \n-fn push_blank_line_comment(rdr: &StringReader, comments: &mut ~[Comment]) {\n+fn push_blank_line_comment(rdr: &StringReader, comments: &mut Vec<Comment> ) {\n     debug!(\">>> blank-line comment\");\n-    let v: ~[~str] = ~[];\n+    let v: Vec<~str> = Vec::new();\n     comments.push(Comment {\n         style: BlankLine,\n         lines: v,\n@@ -168,7 +168,7 @@ fn push_blank_line_comment(rdr: &StringReader, comments: &mut ~[Comment]) {\n }\n \n fn consume_whitespace_counting_blank_lines(rdr: &StringReader,\n-                                           comments: &mut ~[Comment]) {\n+                                           comments: &mut Vec<Comment> ) {\n     while is_whitespace(rdr.curr.get()) && !is_eof(rdr) {\n         if rdr.col.get() == CharPos(0u) && rdr.curr_is('\\n') {\n             push_blank_line_comment(rdr, &mut *comments);\n@@ -179,22 +179,22 @@ fn consume_whitespace_counting_blank_lines(rdr: &StringReader,\n \n \n fn read_shebang_comment(rdr: &StringReader, code_to_the_left: bool,\n-                                            comments: &mut ~[Comment]) {\n+                                            comments: &mut Vec<Comment> ) {\n     debug!(\">>> shebang comment\");\n     let p = rdr.last_pos.get();\n     debug!(\"<<< shebang comment\");\n     comments.push(Comment {\n         style: if code_to_the_left { Trailing } else { Isolated },\n-        lines: ~[read_one_line_comment(rdr)],\n+        lines: vec!(read_one_line_comment(rdr)),\n         pos: p\n     });\n }\n \n fn read_line_comments(rdr: &StringReader, code_to_the_left: bool,\n-                                          comments: &mut ~[Comment]) {\n+                                          comments: &mut Vec<Comment> ) {\n     debug!(\">>> line comments\");\n     let p = rdr.last_pos.get();\n-    let mut lines: ~[~str] = ~[];\n+    let mut lines: Vec<~str> = Vec::new();\n     while rdr.curr_is('/') && nextch_is(rdr, '/') {\n         let line = read_one_line_comment(rdr);\n         debug!(\"{}\", line);\n@@ -232,7 +232,7 @@ fn all_whitespace(s: &str, col: CharPos) -> Option<uint> {\n     return Some(cursor);\n }\n \n-fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n+fn trim_whitespace_prefix_and_push_line(lines: &mut Vec<~str> ,\n                                         s: ~str, col: CharPos) {\n     let len = s.len();\n     let s1 = match all_whitespace(s, col) {\n@@ -249,10 +249,10 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n \n fn read_block_comment(rdr: &StringReader,\n                       code_to_the_left: bool,\n-                      comments: &mut ~[Comment]) {\n+                      comments: &mut Vec<Comment> ) {\n     debug!(\">>> block comment\");\n     let p = rdr.last_pos.get();\n-    let mut lines: ~[~str] = ~[];\n+    let mut lines: Vec<~str> = Vec::new();\n     let col: CharPos = rdr.col.get();\n     bump(rdr);\n     bump(rdr);\n@@ -324,7 +324,7 @@ fn peeking_at_comment(rdr: &StringReader) -> bool {\n \n fn consume_comment(rdr: &StringReader,\n                    code_to_the_left: bool,\n-                   comments: &mut ~[Comment]) {\n+                   comments: &mut Vec<Comment> ) {\n     debug!(\">>> consume comment\");\n     if rdr.curr_is('/') && nextch_is(rdr, '/') {\n         read_line_comments(rdr, code_to_the_left, comments);\n@@ -348,15 +348,15 @@ pub fn gather_comments_and_literals(span_diagnostic:\n                                         @diagnostic::SpanHandler,\n                                     path: ~str,\n                                     srdr: &mut io::Reader)\n-                                 -> (~[Comment], ~[Literal]) {\n+                                 -> (Vec<Comment> , Vec<Literal> ) {\n     let src = srdr.read_to_end().unwrap();\n     let src = str::from_utf8_owned(src).unwrap();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);\n     let rdr = lexer::new_low_level_string_reader(span_diagnostic, filemap);\n \n-    let mut comments: ~[Comment] = ~[];\n-    let mut literals: ~[Literal] = ~[];\n+    let mut comments: Vec<Comment> = Vec::new();\n+    let mut literals: Vec<Literal> = Vec::new();\n     let mut first_read: bool = true;\n     while !is_eof(&rdr) {\n         loop {"}, {"sha": "677881de684e43d8592422fe27ac398caa0750c9", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -1048,7 +1048,7 @@ mod test {\n \n     // check that the given reader produces the desired stream\n     // of tokens (stop checking after exhausting the expected vec)\n-    fn check_tokenization (env: Env, expected: ~[token::Token]) {\n+    fn check_tokenization (env: Env, expected: Vec<token::Token> ) {\n         for expected_tok in expected.iter() {\n             let TokenAndSpan {tok:actual_tok, sp: _} =\n                 env.string_reader.next_token();\n@@ -1064,32 +1064,32 @@ mod test {\n     #[test] fn doublecolonparsing () {\n         let env = setup (~\"a b\");\n         check_tokenization (env,\n-                           ~[mk_ident(\"a\",false),\n-                             mk_ident(\"b\",false)]);\n+                           vec!(mk_ident(\"a\",false),\n+                             mk_ident(\"b\",false)));\n     }\n \n     #[test] fn dcparsing_2 () {\n         let env = setup (~\"a::b\");\n         check_tokenization (env,\n-                           ~[mk_ident(\"a\",true),\n+                           vec!(mk_ident(\"a\",true),\n                              token::MOD_SEP,\n-                             mk_ident(\"b\",false)]);\n+                             mk_ident(\"b\",false)));\n     }\n \n     #[test] fn dcparsing_3 () {\n         let env = setup (~\"a ::b\");\n         check_tokenization (env,\n-                           ~[mk_ident(\"a\",false),\n+                           vec!(mk_ident(\"a\",false),\n                              token::MOD_SEP,\n-                             mk_ident(\"b\",false)]);\n+                             mk_ident(\"b\",false)));\n     }\n \n     #[test] fn dcparsing_4 () {\n         let env = setup (~\"a:: b\");\n         check_tokenization (env,\n-                           ~[mk_ident(\"a\",true),\n+                           vec!(mk_ident(\"a\",true),\n                              token::MOD_SEP,\n-                             mk_ident(\"b\",false)]);\n+                             mk_ident(\"b\",false)));\n     }\n \n     #[test] fn character_a() {"}, {"sha": "40c9f346007b4a5056b0c78f4746754506cce125", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -42,15 +42,15 @@ pub struct ParseSess {\n     cm: @codemap::CodeMap, // better be the same as the one in the reader!\n     span_diagnostic: @SpanHandler, // better be the same as the one in the reader!\n     /// Used to determine and report recursive mod inclusions\n-    included_mod_stack: RefCell<~[Path]>,\n+    included_mod_stack: RefCell<Vec<Path> >,\n }\n \n pub fn new_parse_sess() -> @ParseSess {\n     let cm = @CodeMap::new();\n     @ParseSess {\n         cm: cm,\n         span_diagnostic: mk_span_handler(default_handler(), cm),\n-        included_mod_stack: RefCell::new(~[]),\n+        included_mod_stack: RefCell::new(Vec::new()),\n     }\n }\n \n@@ -60,7 +60,7 @@ pub fn new_parse_sess_special_handler(sh: @SpanHandler,\n     @ParseSess {\n         cm: cm,\n         span_diagnostic: sh,\n-        included_mod_stack: RefCell::new(~[]),\n+        included_mod_stack: RefCell::new(Vec::new()),\n     }\n }\n \n@@ -82,7 +82,7 @@ pub fn parse_crate_attrs_from_file(\n     input: &Path,\n     cfg: ast::CrateConfig,\n     sess: @ParseSess\n-) -> ~[ast::Attribute] {\n+) -> Vec<ast::Attribute> {\n     let mut parser = new_parser_from_file(sess, cfg, input);\n     let (inner, _) = parser.parse_inner_attrs_and_next();\n     return inner;\n@@ -104,7 +104,7 @@ pub fn parse_crate_attrs_from_source_str(name: ~str,\n                                          source: ~str,\n                                          cfg: ast::CrateConfig,\n                                          sess: @ParseSess)\n-                                         -> ~[ast::Attribute] {\n+                                         -> Vec<ast::Attribute> {\n     let mut p = new_parser_from_source_str(sess,\n                                            cfg,\n                                            name,\n@@ -144,7 +144,7 @@ pub fn parse_meta_from_source_str(name: ~str,\n pub fn parse_stmt_from_source_str(name: ~str,\n                                   source: ~str,\n                                   cfg: ast::CrateConfig,\n-                                  attrs: ~[ast::Attribute],\n+                                  attrs: Vec<ast::Attribute> ,\n                                   sess: @ParseSess)\n                                   -> @ast::Stmt {\n     let mut p = new_parser_from_source_str(\n@@ -160,7 +160,7 @@ pub fn parse_tts_from_source_str(name: ~str,\n                                  source: ~str,\n                                  cfg: ast::CrateConfig,\n                                  sess: @ParseSess)\n-                                 -> ~[ast::TokenTree] {\n+                                 -> Vec<ast::TokenTree> {\n     let mut p = new_parser_from_source_str(\n         sess,\n         cfg,\n@@ -214,7 +214,7 @@ pub fn filemap_to_parser(sess: @ParseSess,\n // compiler expands into it\n pub fn new_parser_from_tts(sess: @ParseSess,\n                      cfg: ast::CrateConfig,\n-                     tts: ~[ast::TokenTree]) -> Parser {\n+                     tts: Vec<ast::TokenTree> ) -> Parser {\n     tts_to_parser(sess,tts,cfg)\n }\n \n@@ -256,18 +256,18 @@ pub fn string_to_filemap(sess: @ParseSess, source: ~str, path: ~str)\n \n // given a filemap, produce a sequence of token-trees\n pub fn filemap_to_tts(sess: @ParseSess, filemap: @FileMap)\n-    -> ~[ast::TokenTree] {\n+    -> Vec<ast::TokenTree> {\n     // it appears to me that the cfg doesn't matter here... indeed,\n     // parsing tt's probably shouldn't require a parser at all.\n-    let cfg = ~[];\n+    let cfg = Vec::new();\n     let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap);\n     let mut p1 = Parser(sess, cfg, ~srdr);\n     p1.parse_all_token_trees()\n }\n \n // given tts and cfg, produce a parser\n pub fn tts_to_parser(sess: @ParseSess,\n-                     tts: ~[ast::TokenTree],\n+                     tts: Vec<ast::TokenTree> ,\n                      cfg: ast::CrateConfig) -> Parser {\n     let trdr = lexer::new_tt_reader(sess.span_diagnostic, None, tts);\n     Parser(sess, cfg, ~trdr)\n@@ -318,13 +318,13 @@ mod test {\n                     node: ast::ExprPath(ast::Path {\n                         span: sp(0, 1),\n                         global: false,\n-                        segments: ~[\n+                        segments: vec!(\n                             ast::PathSegment {\n                                 identifier: str_to_ident(\"a\"),\n                                 lifetimes: opt_vec::Empty,\n                                 types: opt_vec::Empty,\n                             }\n-                        ],\n+                        ),\n                     }),\n                     span: sp(0, 1)\n                    })\n@@ -337,7 +337,7 @@ mod test {\n                     node: ast::ExprPath(ast::Path {\n                             span: sp(0, 6),\n                             global: true,\n-                            segments: ~[\n+                            segments: vec!(\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"a\"),\n                                     lifetimes: opt_vec::Empty,\n@@ -348,7 +348,7 @@ mod test {\n                                     lifetimes: opt_vec::Empty,\n                                     types: opt_vec::Empty,\n                                 }\n-                            ]\n+                            )\n                         }),\n                     span: sp(0, 6)\n                    })\n@@ -550,13 +550,13 @@ mod test {\n                         node:ast::ExprPath(ast::Path{\n                             span: sp(7, 8),\n                             global: false,\n-                            segments: ~[\n+                            segments: vec!(\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"d\"),\n                                     lifetimes: opt_vec::Empty,\n                                     types: opt_vec::Empty,\n                                 }\n-                            ],\n+                            ),\n                         }),\n                         span:sp(7,8)\n                     })),\n@@ -572,13 +572,13 @@ mod test {\n                            node: ast::ExprPath(ast::Path {\n                                span:sp(0,1),\n                                global:false,\n-                               segments: ~[\n+                               segments: vec!(\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"b\"),\n                                     lifetimes: opt_vec::Empty,\n                                     types: opt_vec::Empty,\n                                 }\n-                               ],\n+                               ),\n                             }),\n                            span: sp(0,1)},\n                                            ast::DUMMY_NODE_ID),\n@@ -599,13 +599,13 @@ mod test {\n                                 ast::Path {\n                                     span:sp(0,1),\n                                     global:false,\n-                                    segments: ~[\n+                                    segments: vec!(\n                                         ast::PathSegment {\n                                             identifier: str_to_ident(\"b\"),\n                                             lifetimes: opt_vec::Empty,\n                                             types: opt_vec::Empty,\n                                         }\n-                                    ],\n+                                    ),\n                                 },\n                                 None /* no idea */),\n                              span: sp(0,1)});\n@@ -618,22 +618,22 @@ mod test {\n         assert!(string_to_item(~\"fn a (b : int) { b; }\") ==\n                   Some(\n                       @ast::Item{ident:str_to_ident(\"a\"),\n-                            attrs:~[],\n+                            attrs:Vec::new(),\n                             id: ast::DUMMY_NODE_ID,\n                             node: ast::ItemFn(ast::P(ast::FnDecl {\n-                                inputs: ~[ast::Arg{\n+                                inputs: vec!(ast::Arg{\n                                     ty: ast::P(ast::Ty{id: ast::DUMMY_NODE_ID,\n                                                        node: ast::TyPath(ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n-                                        segments: ~[\n+                                        segments: vec!(\n                                             ast::PathSegment {\n                                                 identifier:\n                                                     str_to_ident(\"int\"),\n                                                 lifetimes: opt_vec::Empty,\n                                                 types: opt_vec::Empty,\n                                             }\n-                                        ],\n+                                        ),\n                                         }, None, ast::DUMMY_NODE_ID),\n                                         span:sp(10,13)\n                                     }),\n@@ -644,21 +644,21 @@ mod test {\n                                             ast::Path {\n                                                 span:sp(6,7),\n                                                 global:false,\n-                                                segments: ~[\n+                                                segments: vec!(\n                                                     ast::PathSegment {\n                                                         identifier:\n                                                             str_to_ident(\"b\"),\n                                                         lifetimes: opt_vec::Empty,\n                                                         types: opt_vec::Empty,\n                                                     }\n-                                                ],\n+                                                ),\n                                             },\n                                             None // no idea\n                                         ),\n                                         span: sp(6,7)\n                                     },\n                                     id: ast::DUMMY_NODE_ID\n-                                }],\n+                                }),\n                                 output: ast::P(ast::Ty{id: ast::DUMMY_NODE_ID,\n                                                        node: ast::TyNil,\n                                                        span:sp(15,15)}), // not sure\n@@ -672,15 +672,15 @@ mod test {\n                                         ty_params: opt_vec::Empty,\n                                     },\n                                     ast::P(ast::Block {\n-                                        view_items: ~[],\n-                                        stmts: ~[@Spanned{\n+                                        view_items: Vec::new(),\n+                                        stmts: vec!(@Spanned{\n                                             node: ast::StmtSemi(@ast::Expr{\n                                                 id: ast::DUMMY_NODE_ID,\n                                                 node: ast::ExprPath(\n                                                       ast::Path{\n                                                         span:sp(17,18),\n                                                         global:false,\n-                                                        segments: ~[\n+                                                        segments: vec!(\n                                                             ast::PathSegment {\n                                                                 identifier:\n                                                                 str_to_ident(\n@@ -690,11 +690,11 @@ mod test {\n                                                                 types:\n                                                                 opt_vec::Empty\n                                                             }\n-                                                        ],\n+                                                        ),\n                                                       }),\n                                                 span: sp(17,18)},\n                                                 ast::DUMMY_NODE_ID),\n-                                            span: sp(17,18)}],\n+                                            span: sp(17,18)}),\n                                         expr: None,\n                                         id: ast::DUMMY_NODE_ID,\n                                         rules: ast::DefaultBlock, // no idea"}, {"sha": "ceafa10cbecf0ada98325f236d1ed9458533be5a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 123, "deletions": 124, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -93,7 +93,7 @@ enum restriction {\n     RESTRICT_NO_BAR_OR_DOUBLEBAR_OP,\n }\n \n-type ItemInfo = (Ident, Item_, Option<~[Attribute]>);\n+type ItemInfo = (Ident, Item_, Option<Vec<Attribute> >);\n \n /// How to parse a path. There are four different kinds of paths, all of which\n /// are parsed somewhat differently.\n@@ -129,7 +129,7 @@ pub struct PathAndBounds {\n enum ItemOrViewItem {\n     // Indicates a failure to parse any kind of item. The attributes are\n     // returned.\n-    IoviNone(~[Attribute]),\n+    IoviNone(Vec<Attribute> ),\n     IoviItem(@Item),\n     IoviForeignItem(@ForeignItem),\n     IoviViewItem(ViewItem)\n@@ -257,7 +257,7 @@ macro_rules! maybe_whole (\n             };\n             match __found__ {\n                 Some(INTERPOLATED(token::$constructor(x))) => {\n-                    return (~[], x)\n+                    return (Vec::new(), x)\n                 }\n                 _ => {}\n             }\n@@ -266,21 +266,20 @@ macro_rules! maybe_whole (\n )\n \n \n-fn maybe_append(lhs: ~[Attribute], rhs: Option<~[Attribute]>)\n-             -> ~[Attribute] {\n+fn maybe_append(lhs: Vec<Attribute> , rhs: Option<Vec<Attribute> >)\n+             -> Vec<Attribute> {\n     match rhs {\n         None => lhs,\n-        Some(ref attrs) => vec::append(lhs, (*attrs))\n+        Some(ref attrs) => vec_ng::append(lhs, (*attrs))\n     }\n }\n \n \n struct ParsedItemsAndViewItems {\n-    attrs_remaining: ~[Attribute],\n-    view_items: ~[ViewItem],\n-    items: ~[@Item],\n-    foreign_items: ~[@ForeignItem]\n-}\n+    attrs_remaining: Vec<Attribute> ,\n+    view_items: Vec<ViewItem> ,\n+    items: Vec<@Item> ,\n+    foreign_items: Vec<@ForeignItem> }\n \n /* ident is handled by common.rs */\n \n@@ -314,8 +313,8 @@ pub fn Parser(sess: @ParseSess, cfg: ast::CrateConfig, rdr: ~Reader:)\n         restriction: UNRESTRICTED,\n         quote_depth: 0,\n         obsolete_set: HashSet::new(),\n-        mod_path_stack: ~[],\n-        open_braces: ~[],\n+        mod_path_stack: Vec::new(),\n+        open_braces: Vec::new(),\n         nopod: marker::NoPod\n     }\n }\n@@ -343,9 +342,9 @@ pub struct Parser {\n     /// extra detail when the same error is seen twice\n     obsolete_set: HashSet<ObsoleteSyntax>,\n     /// Used to determine the path to externally loaded source files\n-    mod_path_stack: ~[InternedString],\n+    mod_path_stack: Vec<InternedString> ,\n     /// Stack of spans of open delimiters. Used for error message.\n-    open_braces: ~[Span],\n+    open_braces: Vec<Span> ,\n     /* do not copy the parser; its state is tied to outside state */\n     priv nopod: marker::NoPod\n }\n@@ -407,7 +406,7 @@ impl Parser {\n         } else if inedible.contains(&self.token) {\n             // leave it in the input\n         } else {\n-            let expected = vec::append(edible.to_owned(), inedible);\n+            let expected = vec_ng::append(edible.to_owned(), inedible);\n             let expect = tokens_to_str(expected);\n             let actual = self.this_token_to_str();\n             self.fatal(\n@@ -446,7 +445,7 @@ impl Parser {\n         match e.node {\n             ExprPath(..) => {\n                 // might be unit-struct construction; check for recoverableinput error.\n-                let expected = vec::append(edible.to_owned(), inedible);\n+                let expected = vec_ng::append(edible.to_owned(), inedible);\n                 self.check_for_erroneous_unit_struct_expecting(expected);\n             }\n             _ => {}\n@@ -465,7 +464,7 @@ impl Parser {\n         debug!(\"commit_stmt {:?}\", s);\n         let _s = s; // unused, but future checks might want to inspect `s`.\n         if self.last_token.as_ref().map_or(false, |t| is_ident_or_path(*t)) {\n-            let expected = vec::append(edible.to_owned(), inedible);\n+            let expected = vec_ng::append(edible.to_owned(), inedible);\n             self.check_for_erroneous_unit_struct_expecting(expected);\n         }\n         self.expect_one_of(edible, inedible)\n@@ -578,9 +577,9 @@ impl Parser {\n                               &mut self,\n                               sep: &token::Token,\n                               f: |&mut Parser| -> T)\n-                              -> ~[T] {\n+                              -> Vec<T> {\n         let mut first = true;\n-        let mut vector = ~[];\n+        let mut vector = Vec::new();\n         while self.token != token::BINOP(token::OR) &&\n                 self.token != token::OROR {\n             if first {\n@@ -655,7 +654,7 @@ impl Parser {\n                             ket: &token::Token,\n                             sep: SeqSep,\n                             f: |&mut Parser| -> T)\n-                            -> ~[T] {\n+                            -> Vec<T> {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n         val\n@@ -669,9 +668,9 @@ impl Parser {\n                                    ket: &token::Token,\n                                    sep: SeqSep,\n                                    f: |&mut Parser| -> T)\n-                                   -> ~[T] {\n+                                   -> Vec<T> {\n         let mut first: bool = true;\n-        let mut v: ~[T] = ~[];\n+        let mut v: Vec<T> = Vec::new();\n         while self.token != *ket {\n             match sep.sep {\n               Some(ref t) => {\n@@ -695,7 +694,7 @@ impl Parser {\n                                ket: &token::Token,\n                                sep: SeqSep,\n                                f: |&mut Parser| -> T)\n-                               -> ~[T] {\n+                               -> Vec<T> {\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n@@ -710,7 +709,7 @@ impl Parser {\n                      ket: &token::Token,\n                      sep: SeqSep,\n                      f: |&mut Parser| -> T)\n-                     -> Spanned<~[T]> {\n+                     -> Spanned<Vec<T> > {\n         let lo = self.span.lo;\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n@@ -950,7 +949,7 @@ impl Parser {\n                 };\n \n                 let inputs = if self.eat(&token::OROR) {\n-                    ~[]\n+                    Vec::new()\n                 } else {\n                     self.expect_or();\n                     let inputs = self.parse_seq_to_before_or(\n@@ -1034,7 +1033,7 @@ impl Parser {\n     }\n \n     // parse the methods in a trait declaration\n-    pub fn parse_trait_methods(&mut self) -> ~[TraitMethod] {\n+    pub fn parse_trait_methods(&mut self) -> Vec<TraitMethod> {\n         self.parse_unspanned_seq(\n             &token::LBRACE,\n             &token::RBRACE,\n@@ -1083,7 +1082,7 @@ impl Parser {\n                 debug!(\"parse_trait_methods(): parsing provided method\");\n                 let (inner_attrs, body) =\n                     p.parse_inner_attrs_and_block();\n-                let attrs = vec::append(attrs, inner_attrs);\n+                let attrs = vec_ng::append(attrs, inner_attrs);\n                 Provided(@ast::Method {\n                     ident: ident,\n                     attrs: attrs,\n@@ -1176,7 +1175,7 @@ impl Parser {\n                 // (t) is a parenthesized ty\n                 // (t,) is the type of a tuple with only one field,\n                 // of type t\n-                let mut ts = ~[self.parse_ty(false)];\n+                let mut ts = vec!(self.parse_ty(false));\n                 let mut one_tuple = false;\n                 while self.token == token::COMMA {\n                     self.bump();\n@@ -1479,7 +1478,7 @@ impl Parser {\n         // Parse any number of segments and bound sets. A segment is an\n         // identifier followed by an optional lifetime and a set of types.\n         // A bound set is a set of type parameter bounds.\n-        let mut segments = ~[];\n+        let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n             let identifier = self.parse_ident();\n@@ -1541,7 +1540,7 @@ impl Parser {\n         let span = mk_sp(lo, self.last_span.hi);\n \n         // Assemble the path segments.\n-        let mut path_segments = ~[];\n+        let mut path_segments = Vec::new();\n         let mut bounds = None;\n         let last_segment_index = segments.len() - 1;\n         for (i, segment_and_bounds) in segments.move_iter().enumerate() {\n@@ -1690,19 +1689,19 @@ impl Parser {\n         ExprBinary(binop, lhs, rhs)\n     }\n \n-    pub fn mk_call(&mut self, f: @Expr, args: ~[@Expr]) -> ast::Expr_ {\n+    pub fn mk_call(&mut self, f: @Expr, args: Vec<@Expr> ) -> ast::Expr_ {\n         ExprCall(f, args)\n     }\n \n-    fn mk_method_call(&mut self, ident: Ident, tps: ~[P<Ty>], args: ~[@Expr]) -> ast::Expr_ {\n+    fn mk_method_call(&mut self, ident: Ident, tps: Vec<P<Ty>> , args: Vec<@Expr> ) -> ast::Expr_ {\n         ExprMethodCall(ident, tps, args)\n     }\n \n     pub fn mk_index(&mut self, expr: @Expr, idx: @Expr) -> ast::Expr_ {\n         ExprIndex(expr, idx)\n     }\n \n-    pub fn mk_field(&mut self, expr: @Expr, ident: Ident, tys: ~[P<Ty>]) -> ast::Expr_ {\n+    pub fn mk_field(&mut self, expr: @Expr, ident: Ident, tys: Vec<P<Ty>> ) -> ast::Expr_ {\n         ExprField(expr, ident, tys)\n     }\n \n@@ -1754,7 +1753,7 @@ impl Parser {\n                 let lit = @spanned(lo, hi, LitNil);\n                 return self.mk_expr(lo, hi, ExprLit(lit));\n             }\n-            let mut es = ~[self.parse_expr()];\n+            let mut es = vec!(self.parse_expr());\n             self.commit_expr(*es.last().unwrap(), &[], &[token::COMMA, token::RPAREN]);\n             while self.token == token::COMMA {\n                 self.bump();\n@@ -1786,8 +1785,8 @@ impl Parser {\n             let decl = self.parse_proc_decl();\n             let body = self.parse_expr();\n             let fakeblock = P(ast::Block {\n-                view_items: ~[],\n-                stmts: ~[],\n+                view_items: Vec::new(),\n+                stmts: Vec::new(),\n                 expr: Some(body),\n                 id: ast::DUMMY_NODE_ID,\n                 rules: DefaultBlock,\n@@ -1840,7 +1839,7 @@ impl Parser {\n             if self.token == token::RBRACKET {\n                 // Empty vector.\n                 self.bump();\n-                ex = ExprVec(~[], mutbl);\n+                ex = ExprVec(Vec::new(), mutbl);\n             } else {\n                 // Nonempty vector.\n                 let first_expr = self.parse_expr();\n@@ -1860,11 +1859,11 @@ impl Parser {\n                         seq_sep_trailing_allowed(token::COMMA),\n                         |p| p.parse_expr()\n                     );\n-                    ex = ExprVec(~[first_expr] + remaining_exprs, mutbl);\n+                    ex = ExprVec(vec!(first_expr) + remaining_exprs, mutbl);\n                 } else {\n                     // Vector with one element.\n                     self.expect(&token::RBRACKET);\n-                    ex = ExprVec(~[first_expr], mutbl);\n+                    ex = ExprVec(vec!(first_expr), mutbl);\n                 }\n             }\n             hi = self.last_span.hi;\n@@ -1919,7 +1918,7 @@ impl Parser {\n                 if self.looking_at_struct_literal() {\n                     // It's a struct literal.\n                     self.bump();\n-                    let mut fields = ~[];\n+                    let mut fields = Vec::new();\n                     let mut base = None;\n \n                     while self.token != token::RBRACE {\n@@ -1981,7 +1980,7 @@ impl Parser {\n                         self.expect(&token::LT);\n                         self.parse_generic_values_after_lt()\n                     } else {\n-                        (opt_vec::Empty, ~[])\n+                        (opt_vec::Empty, Vec::new())\n                     };\n \n                     // expr.f() method call\n@@ -2143,7 +2142,7 @@ impl Parser {\n \n                 // Parse the open delimiter.\n                 self.open_braces.push(self.span);\n-                let mut result = ~[parse_any_tt_tok(self)];\n+                let mut result = vec!(parse_any_tt_tok(self));\n \n                 let trees =\n                     self.parse_seq_to_before_end(&close_delim,\n@@ -2163,15 +2162,15 @@ impl Parser {\n \n     // parse a stream of tokens into a list of TokenTree's,\n     // up to EOF.\n-    pub fn parse_all_token_trees(&mut self) -> ~[TokenTree] {\n-        let mut tts = ~[];\n+    pub fn parse_all_token_trees(&mut self) -> Vec<TokenTree> {\n+        let mut tts = Vec::new();\n         while self.token != token::EOF {\n             tts.push(self.parse_token_tree());\n         }\n         tts\n     }\n \n-    pub fn parse_matchers(&mut self) -> ~[Matcher] {\n+    pub fn parse_matchers(&mut self) -> Vec<Matcher> {\n         // unification of Matcher's and TokenTree's would vastly improve\n         // the interpolation of Matcher's\n         maybe_whole!(self, NtMatchers);\n@@ -2192,8 +2191,8 @@ impl Parser {\n     pub fn parse_matcher_subseq_upto(&mut self,\n                                      name_idx: @Cell<uint>,\n                                      ket: &token::Token)\n-                                     -> ~[Matcher] {\n-        let mut ret_val = ~[];\n+                                     -> Vec<Matcher> {\n+        let mut ret_val = Vec::new();\n         let mut lparens = 0u;\n \n         while self.token != *ket || lparens > 0u {\n@@ -2478,7 +2477,7 @@ impl Parser {\n                     _ => {\n                         // No argument list - `do foo {`\n                         P(FnDecl {\n-                            inputs: ~[],\n+                            inputs: Vec::new(),\n                             output: P(Ty {\n                                 id: ast::DUMMY_NODE_ID,\n                                 node: TyInfer,\n@@ -2513,8 +2512,8 @@ impl Parser {\n         let decl = parse_decl(self);\n         let body = parse_body(self);\n         let fakeblock = P(ast::Block {\n-            view_items: ~[],\n-            stmts: ~[],\n+            view_items: Vec::new(),\n+            stmts: Vec::new(),\n             expr: Some(body),\n             id: ast::DUMMY_NODE_ID,\n             rules: DefaultBlock,\n@@ -2601,7 +2600,7 @@ impl Parser {\n         let lo = self.last_span.lo;\n         let discriminant = self.parse_expr();\n         self.commit_expr_expecting(discriminant, token::LBRACE);\n-        let mut arms: ~[Arm] = ~[];\n+        let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::RBRACE {\n             let pats = self.parse_pats();\n             let mut guard = None;\n@@ -2622,8 +2621,8 @@ impl Parser {\n             }\n \n             let blk = P(ast::Block {\n-                view_items: ~[],\n-                stmts: ~[],\n+                view_items: Vec::new(),\n+                stmts: Vec::new(),\n                 expr: Some(expr),\n                 id: ast::DUMMY_NODE_ID,\n                 rules: DefaultBlock,\n@@ -2662,8 +2661,8 @@ impl Parser {\n     }\n \n     // parse patterns, separated by '|' s\n-    fn parse_pats(&mut self) -> ~[@Pat] {\n-        let mut pats = ~[];\n+    fn parse_pats(&mut self) -> Vec<@Pat> {\n+        let mut pats = Vec::new();\n         loop {\n             pats.push(self.parse_pat());\n             if self.token == token::BINOP(token::OR) { self.bump(); }\n@@ -2673,10 +2672,10 @@ impl Parser {\n \n     fn parse_pat_vec_elements(\n         &mut self,\n-    ) -> (~[@Pat], Option<@Pat>, ~[@Pat]) {\n-        let mut before = ~[];\n+    ) -> (Vec<@Pat> , Option<@Pat>, Vec<@Pat> ) {\n+        let mut before = Vec::new();\n         let mut slice = None;\n-        let mut after = ~[];\n+        let mut after = Vec::new();\n         let mut first = true;\n         let mut before_slice = true;\n \n@@ -2733,8 +2732,8 @@ impl Parser {\n     }\n \n     // parse the fields of a struct-like pattern\n-    fn parse_pat_fields(&mut self) -> (~[ast::FieldPat], bool) {\n-        let mut fields = ~[];\n+    fn parse_pat_fields(&mut self) -> (Vec<ast::FieldPat> , bool) {\n+        let mut fields = Vec::new();\n         let mut etc = false;\n         let mut first = true;\n         while self.token != token::RBRACE {\n@@ -2900,7 +2899,7 @@ impl Parser {\n                 let expr = self.mk_expr(lo, hi, ExprLit(lit));\n                 pat = PatLit(expr);\n             } else {\n-                let mut fields = ~[self.parse_pat()];\n+                let mut fields = vec!(self.parse_pat());\n                 if self.look_ahead(1, |t| *t != token::RPAREN) {\n                     while self.token == token::COMMA {\n                         self.bump();\n@@ -3002,7 +3001,7 @@ impl Parser {\n                         pat = PatStruct(enum_path, fields, etc);\n                     }\n                     _ => {\n-                        let mut args: ~[@Pat] = ~[];\n+                        let mut args: Vec<@Pat> = Vec::new();\n                         match self.token {\n                           token::LPAREN => {\n                             let is_star = self.look_ahead(1, |t| {\n@@ -3128,7 +3127,7 @@ impl Parser {\n \n     // parse a structure field\n     fn parse_name_and_ty(&mut self, pr: Visibility,\n-                         attrs: ~[Attribute]) -> StructField {\n+                         attrs: Vec<Attribute> ) -> StructField {\n         let lo = self.span.lo;\n         if !is_plain_ident(&self.token) {\n             self.fatal(\"expected ident\");\n@@ -3146,7 +3145,7 @@ impl Parser {\n \n     // parse a statement. may include decl.\n     // precondition: any attributes are parsed already\n-    pub fn parse_stmt(&mut self, item_attrs: ~[Attribute]) -> @Stmt {\n+    pub fn parse_stmt(&mut self, item_attrs: Vec<Attribute> ) -> @Stmt {\n         maybe_whole!(self, NtStmt);\n \n         fn check_expected_item(p: &mut Parser, found_attrs: bool) {\n@@ -3229,7 +3228,7 @@ impl Parser {\n                         self.mk_item(\n                             lo, hi, id /*id is good here*/,\n                             ItemMac(spanned(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT))),\n-                            Inherited, ~[/*no attrs*/]))),\n+                            Inherited, Vec::new(/*no attrs*/)))),\n                     ast::DUMMY_NODE_ID));\n             }\n \n@@ -3275,12 +3274,12 @@ impl Parser {\n         }\n         self.expect(&token::LBRACE);\n \n-        return self.parse_block_tail_(lo, DefaultBlock, ~[]);\n+        return self.parse_block_tail_(lo, DefaultBlock, Vec::new());\n     }\n \n     // parse a block. Inner attrs are allowed.\n     fn parse_inner_attrs_and_block(&mut self)\n-        -> (~[Attribute], P<Block>) {\n+        -> (Vec<Attribute> , P<Block>) {\n \n         maybe_whole!(pair_empty self, NtBlock);\n \n@@ -3299,13 +3298,13 @@ impl Parser {\n     // necessary, and this should take a qualifier.\n     // some blocks start with \"#{\"...\n     fn parse_block_tail(&mut self, lo: BytePos, s: BlockCheckMode) -> P<Block> {\n-        self.parse_block_tail_(lo, s, ~[])\n+        self.parse_block_tail_(lo, s, Vec::new())\n     }\n \n     // parse the rest of a block expression or function body\n     fn parse_block_tail_(&mut self, lo: BytePos, s: BlockCheckMode,\n-                         first_item_attrs: ~[Attribute]) -> P<Block> {\n-        let mut stmts = ~[];\n+                         first_item_attrs: Vec<Attribute> ) -> P<Block> {\n+        let mut stmts = Vec::new();\n         let mut expr = None;\n \n         // wouldn't it be more uniform to parse view items only, here?\n@@ -3333,7 +3332,7 @@ impl Parser {\n                 token::SEMI => {\n                     if !attributes_box.is_empty() {\n                         self.span_err(self.last_span, \"expected item after attributes\");\n-                        attributes_box = ~[];\n+                        attributes_box = Vec::new();\n                     }\n                     self.bump(); // empty\n                 }\n@@ -3342,7 +3341,7 @@ impl Parser {\n                 }\n                 _ => {\n                     let stmt = self.parse_stmt(attributes_box);\n-                    attributes_box = ~[];\n+                    attributes_box = Vec::new();\n                     match stmt.node {\n                         StmtExpr(e, stmt_id) => {\n                             // expression without semicolon\n@@ -3510,7 +3509,7 @@ impl Parser {\n         }\n     }\n \n-    fn parse_generic_values_after_lt(&mut self) -> (OptVec<ast::Lifetime>, ~[P<Ty>]) {\n+    fn parse_generic_values_after_lt(&mut self) -> (OptVec<ast::Lifetime>, Vec<P<Ty>> ) {\n         let lifetimes = self.parse_lifetimes();\n         let result = self.parse_seq_to_gt(\n             Some(token::COMMA),\n@@ -3519,9 +3518,9 @@ impl Parser {\n     }\n \n     fn parse_fn_args(&mut self, named_args: bool, allow_variadic: bool)\n-                     -> (~[Arg], bool) {\n+                     -> (Vec<Arg> , bool) {\n         let sp = self.span;\n-        let mut args: ~[Option<Arg>] =\n+        let mut args: Vec<Option<Arg>> =\n             self.parse_unspanned_seq(\n                 &token::LPAREN,\n                 &token::RPAREN,\n@@ -3716,7 +3715,7 @@ impl Parser {\n                     fn_inputs\n                 }\n                 token::RPAREN => {\n-                    ~[Arg::new_self(explicit_self_sp, mutbl_self)]\n+                    vec!(Arg::new_self(explicit_self_sp, mutbl_self))\n                 }\n                 _ => {\n                     let token_str = self.this_token_to_str();\n@@ -3749,7 +3748,7 @@ impl Parser {\n     fn parse_fn_block_decl(&mut self) -> P<FnDecl> {\n         let inputs_captures = {\n             if self.eat(&token::OROR) {\n-                ~[]\n+                Vec::new()\n             } else {\n                 self.parse_unspanned_seq(\n                     &token::BINOP(token::OR),\n@@ -3812,7 +3811,7 @@ impl Parser {\n \n     fn mk_item(&mut self, lo: BytePos, hi: BytePos, ident: Ident,\n                node: Item_, vis: Visibility,\n-               attrs: ~[Attribute]) -> @Item {\n+               attrs: Vec<Attribute> ) -> @Item {\n         @Item {\n             ident: ident,\n             attrs: attrs,\n@@ -3832,7 +3831,7 @@ impl Parser {\n     }\n \n     // parse a method in a trait impl, starting with `attrs` attributes.\n-    fn parse_method(&mut self, already_parsed_attrs: Option<~[Attribute]>) -> @Method {\n+    fn parse_method(&mut self, already_parsed_attrs: Option<Vec<Attribute> >) -> @Method {\n         let next_attrs = self.parse_outer_attributes();\n         let attrs = match already_parsed_attrs {\n             Some(mut a) => { a.push_all_move(next_attrs); a }\n@@ -3851,7 +3850,7 @@ impl Parser {\n \n         let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n         let hi = body.span.hi;\n-        let attrs = vec::append(attrs, inner_attrs);\n+        let attrs = vec_ng::append(attrs, inner_attrs);\n         @ast::Method {\n             ident: ident,\n             attrs: attrs,\n@@ -3877,7 +3876,7 @@ impl Parser {\n             self.bump();\n             traits = self.parse_trait_ref_list(&token::LBRACE);\n         } else {\n-            traits = ~[];\n+            traits = Vec::new();\n         }\n \n         let meths = self.parse_trait_methods();\n@@ -3925,7 +3924,7 @@ impl Parser {\n             None\n         };\n \n-        let mut meths = ~[];\n+        let mut meths = Vec::new();\n         self.expect(&token::LBRACE);\n         let (inner_attrs, next) = self.parse_inner_attrs_and_next();\n         let mut method_attrs = Some(next);\n@@ -3948,7 +3947,7 @@ impl Parser {\n     }\n \n     // parse B + C<~str,int> + D\n-    fn parse_trait_ref_list(&mut self, ket: &token::Token) -> ~[TraitRef] {\n+    fn parse_trait_ref_list(&mut self, ket: &token::Token) -> Vec<TraitRef> {\n         self.parse_seq_to_before_end(\n             ket,\n             seq_sep_trailing_disallowed(token::BINOP(token::PLUS)),\n@@ -3961,13 +3960,13 @@ impl Parser {\n         let class_name = self.parse_ident();\n         let generics = self.parse_generics();\n \n-        let mut fields: ~[StructField];\n+        let mut fields: Vec<StructField> ;\n         let is_tuple_like;\n \n         if self.eat(&token::LBRACE) {\n             // It's a record-like struct.\n             is_tuple_like = false;\n-            fields = ~[];\n+            fields = Vec::new();\n             while self.token != token::RBRACE {\n                 fields.push(self.parse_struct_decl_field());\n             }\n@@ -3998,7 +3997,7 @@ impl Parser {\n         } else if self.eat(&token::SEMI) {\n             // It's a unit-like struct.\n             is_tuple_like = true;\n-            fields = ~[];\n+            fields = Vec::new();\n         } else {\n             let token_str = self.this_token_to_str();\n             self.fatal(format!(\"expected `\\\\{`, `(`, or `;` after struct \\\n@@ -4019,7 +4018,7 @@ impl Parser {\n     // parse a structure field declaration\n     pub fn parse_single_struct_field(&mut self,\n                                      vis: Visibility,\n-                                     attrs: ~[Attribute])\n+                                     attrs: Vec<Attribute> )\n                                      -> StructField {\n         let a_var = self.parse_name_and_ty(vis, attrs);\n         match self.token {\n@@ -4064,7 +4063,7 @@ impl Parser {\n     // attributes (of length 0 or 1), parse all of the items in a module\n     fn parse_mod_items(&mut self,\n                        term: token::Token,\n-                       first_item_attrs: ~[Attribute])\n+                       first_item_attrs: Vec<Attribute> )\n                        -> Mod {\n         // parse all of the items up to closing or an attribute.\n         // view items are legal here.\n@@ -4074,7 +4073,7 @@ impl Parser {\n             items: starting_items,\n             ..\n         } = self.parse_items_and_view_items(first_item_attrs, true, true);\n-        let mut items: ~[@Item] = starting_items;\n+        let mut items: Vec<@Item> = starting_items;\n         let attrs_remaining_len = attrs_remaining.len();\n \n         // don't think this other loop is even necessary....\n@@ -4162,7 +4161,7 @@ impl Parser {\n                     id: ast::Ident,\n                     outer_attrs: &[ast::Attribute],\n                     id_sp: Span)\n-                    -> (ast::Item_, ~[ast::Attribute]) {\n+                    -> (ast::Item_, Vec<ast::Attribute> ) {\n         let mut prefix = Path::new(self.sess.cm.span_to_filename(self.span));\n         prefix.pop();\n         let mod_path = Path::new(\".\").join_many(self.mod_path_stack);\n@@ -4201,8 +4200,8 @@ impl Parser {\n \n     fn eval_src_mod_from_path(&mut self,\n                               path: Path,\n-                              outer_attrs: ~[ast::Attribute],\n-                              id_sp: Span) -> (ast::Item_, ~[ast::Attribute]) {\n+                              outer_attrs: Vec<ast::Attribute> ,\n+                              id_sp: Span) -> (ast::Item_, Vec<ast::Attribute> ) {\n         {\n             let mut included_mod_stack = self.sess\n                                              .included_mod_stack\n@@ -4232,7 +4231,7 @@ impl Parser {\n                                      &path,\n                                      id_sp);\n         let (inner, next) = p0.parse_inner_attrs_and_next();\n-        let mod_attrs = vec::append(outer_attrs, inner);\n+        let mod_attrs = vec_ng::append(outer_attrs, inner);\n         let first_item_outer_attrs = next;\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n         {\n@@ -4246,7 +4245,7 @@ impl Parser {\n \n     // parse a function declaration from a foreign module\n     fn parse_item_foreign_fn(&mut self, vis: ast::Visibility,\n-                             attrs: ~[Attribute]) -> @ForeignItem {\n+                             attrs: Vec<Attribute> ) -> @ForeignItem {\n         let lo = self.span.lo;\n \n         // Parse obsolete purity.\n@@ -4269,7 +4268,7 @@ impl Parser {\n \n     // parse a static item from a foreign module\n     fn parse_item_foreign_static(&mut self, vis: ast::Visibility,\n-                                 attrs: ~[Attribute]) -> @ForeignItem {\n+                                 attrs: Vec<Attribute> ) -> @ForeignItem {\n         let lo = self.span.lo;\n \n         self.expect_keyword(keywords::Static);\n@@ -4303,7 +4302,7 @@ impl Parser {\n     // parse_foreign_items.\n     fn parse_foreign_mod_items(&mut self,\n                                abis: AbiSet,\n-                               first_item_attrs: ~[Attribute])\n+                               first_item_attrs: Vec<Attribute> )\n                                -> ForeignMod {\n         let ParsedItemsAndViewItems {\n             attrs_remaining: attrs_remaining,\n@@ -4332,7 +4331,7 @@ impl Parser {\n     fn parse_item_extern_crate(&mut self,\n                                 lo: BytePos,\n                                 visibility: Visibility,\n-                                attrs: ~[Attribute])\n+                                attrs: Vec<Attribute> )\n                                 -> ItemOrViewItem {\n \n         let (maybe_path, ident) = match self.token {\n@@ -4377,7 +4376,7 @@ impl Parser {\n                               lo: BytePos,\n                               opt_abis: Option<AbiSet>,\n                               visibility: Visibility,\n-                              attrs: ~[Attribute])\n+                              attrs: Vec<Attribute> )\n                               -> ItemOrViewItem {\n \n         self.expect(&token::LBRACE);\n@@ -4410,7 +4409,7 @@ impl Parser {\n     // parse a structure-like enum variant definition\n     // this should probably be renamed or refactored...\n     fn parse_struct_def(&mut self) -> @StructDef {\n-        let mut fields: ~[StructField] = ~[];\n+        let mut fields: Vec<StructField> = Vec::new();\n         while self.token != token::RBRACE {\n             fields.push(self.parse_struct_decl_field());\n         }\n@@ -4424,7 +4423,7 @@ impl Parser {\n \n     // parse the part of an \"enum\" decl following the '{'\n     fn parse_enum_def(&mut self, _generics: &ast::Generics) -> EnumDef {\n-        let mut variants = ~[];\n+        let mut variants = Vec::new();\n         let mut all_nullary = true;\n         let mut have_disr = false;\n         while self.token != token::RBRACE {\n@@ -4435,7 +4434,7 @@ impl Parser {\n \n             let ident;\n             let kind;\n-            let mut args = ~[];\n+            let mut args = Vec::new();\n             let mut disr_expr = None;\n             ident = self.parse_ident();\n             if self.eat(&token::LBRACE) {\n@@ -4462,7 +4461,7 @@ impl Parser {\n                 disr_expr = Some(self.parse_expr());\n                 kind = TupleVariantKind(args);\n             } else {\n-                kind = TupleVariantKind(~[]);\n+                kind = TupleVariantKind(Vec::new());\n             }\n \n             let vr = ast::Variant_ {\n@@ -4551,13 +4550,13 @@ impl Parser {\n     // NB: this function no longer parses the items inside an\n     // extern crate.\n     fn parse_item_or_view_item(&mut self,\n-                               attrs: ~[Attribute],\n+                               attrs: Vec<Attribute> ,\n                                macros_allowed: bool)\n                                -> ItemOrViewItem {\n         match self.token {\n             INTERPOLATED(token::NtItem(item)) => {\n                 self.bump();\n-                let new_attrs = vec::append(attrs, item.attrs);\n+                let new_attrs = vec_ng::append(attrs, item.attrs);\n                 return IoviItem(@Item {\n                     attrs: new_attrs,\n                     ..(*item).clone()\n@@ -4732,7 +4731,7 @@ impl Parser {\n \n     // parse a foreign item; on failure, return IoviNone.\n     fn parse_foreign_item(&mut self,\n-                          attrs: ~[Attribute],\n+                          attrs: Vec<Attribute> ,\n                           macros_allowed: bool)\n                           -> ItemOrViewItem {\n         maybe_whole!(iovi self, NtItem);\n@@ -4756,7 +4755,7 @@ impl Parser {\n     // this is the fall-through for parsing items.\n     fn parse_macro_use_or_failure(\n         &mut self,\n-        attrs: ~[Attribute],\n+        attrs: Vec<Attribute> ,\n         macros_allowed: bool,\n         lo: BytePos,\n         visibility: Visibility\n@@ -4820,7 +4819,7 @@ impl Parser {\n         return IoviNone(attrs);\n     }\n \n-    pub fn parse_item(&mut self, attrs: ~[Attribute]) -> Option<@Item> {\n+    pub fn parse_item(&mut self, attrs: Vec<Attribute> ) -> Option<@Item> {\n         match self.parse_item_or_view_item(attrs, true) {\n             IoviNone(_) => None,\n             IoviViewItem(_) =>\n@@ -4854,20 +4853,20 @@ impl Parser {\n             let path = ast::Path {\n                 span: mk_sp(lo, self.span.hi),\n                 global: false,\n-                segments: ~[]\n+                segments: Vec::new()\n             };\n             return @spanned(lo, self.span.hi,\n                             ViewPathList(path, idents, ast::DUMMY_NODE_ID));\n         }\n \n         let first_ident = self.parse_ident();\n-        let mut path = ~[first_ident];\n+        let mut path = vec!(first_ident);\n         match self.token {\n           token::EQ => {\n             // x = foo::bar\n             self.bump();\n             let path_lo = self.span.lo;\n-            path = ~[self.parse_ident()];\n+            path = vec!(self.parse_ident());\n             while self.token == token::MOD_SEP {\n                 self.bump();\n                 let id = self.parse_ident();\n@@ -4965,8 +4964,8 @@ impl Parser {\n     }\n \n     // matches view_paths = view_path | view_path , view_paths\n-    fn parse_view_paths(&mut self) -> ~[@ViewPath] {\n-        let mut vp = ~[self.parse_view_path()];\n+    fn parse_view_paths(&mut self) -> Vec<@ViewPath> {\n+        let mut vp = vec!(self.parse_view_path());\n         while self.token == token::COMMA {\n             self.bump();\n             self.obsolete(self.last_span, ObsoleteMultipleImport);\n@@ -4980,15 +4979,15 @@ impl Parser {\n     // - mod_items uses extern_mod_allowed = true\n     // - block_tail_ uses extern_mod_allowed = false\n     fn parse_items_and_view_items(&mut self,\n-                                  first_item_attrs: ~[Attribute],\n+                                  first_item_attrs: Vec<Attribute> ,\n                                   mut extern_mod_allowed: bool,\n                                   macros_allowed: bool)\n                                   -> ParsedItemsAndViewItems {\n-        let mut attrs = vec::append(first_item_attrs,\n+        let mut attrs = vec_ng::append(first_item_attrs,\n                                     self.parse_outer_attributes());\n         // First, parse view items.\n-        let mut view_items : ~[ast::ViewItem] = ~[];\n-        let mut items = ~[];\n+        let mut view_items : Vec<ast::ViewItem> = Vec::new();\n+        let mut items = Vec::new();\n \n         // I think this code would probably read better as a single\n         // loop with a mutable three-state-variable (for extern crates,\n@@ -5001,7 +5000,7 @@ impl Parser {\n                         attrs_remaining: attrs,\n                         view_items: view_items,\n                         items: items,\n-                        foreign_items: ~[]\n+                        foreign_items: Vec::new()\n                     }\n                 }\n                 IoviViewItem(view_item) => {\n@@ -5056,18 +5055,18 @@ impl Parser {\n             attrs_remaining: attrs,\n             view_items: view_items,\n             items: items,\n-            foreign_items: ~[]\n+            foreign_items: Vec::new()\n         }\n     }\n \n     // Parses a sequence of foreign items. Stops when it finds program\n     // text that can't be parsed as an item\n-    fn parse_foreign_items(&mut self, first_item_attrs: ~[Attribute],\n+    fn parse_foreign_items(&mut self, first_item_attrs: Vec<Attribute> ,\n                            macros_allowed: bool)\n         -> ParsedItemsAndViewItems {\n-        let mut attrs = vec::append(first_item_attrs,\n+        let mut attrs = vec_ng::append(first_item_attrs,\n                                     self.parse_outer_attributes());\n-        let mut foreign_items = ~[];\n+        let mut foreign_items = Vec::new();\n         loop {\n             match self.parse_foreign_item(attrs, macros_allowed) {\n                 IoviNone(returned_attrs) => {\n@@ -5095,8 +5094,8 @@ impl Parser {\n \n         ParsedItemsAndViewItems {\n             attrs_remaining: attrs,\n-            view_items: ~[],\n-            items: ~[],\n+            view_items: Vec::new(),\n+            items: Vec::new(),\n             foreign_items: foreign_items\n         }\n     }"}, {"sha": "d7d8752b0090b477fc6dc76e04aca703dd56e62e", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -115,7 +115,7 @@ pub enum Nonterminal {\n     NtAttr(@ast::Attribute), // #[foo]\n     NtPath(~ast::Path),\n     NtTT(  @ast::TokenTree), // needs @ed to break a circularity\n-    NtMatchers(~[ast::Matcher])\n+    NtMatchers(Vec<ast::Matcher> )\n }\n \n impl fmt::Show for Nonterminal {\n@@ -412,11 +412,11 @@ macro_rules! declare_special_idents_and_keywords {(\n         // The indices here must correspond to the numbers in\n         // special_idents, in Keyword to_ident(), and in static\n         // constants below.\n-        let init_vec = ~[\n+        let init_vec = vec!(\n             $( $si_str, )*\n             $( $sk_str, )*\n             $( $rk_str, )*\n-        ];\n+        );\n \n         interner::StrInterner::prefill(init_vec)\n     }"}, {"sha": "151f9c8b327ea23b3e5919461feaacab949caeaf", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -119,7 +119,7 @@ pub fn tok_str(t: Token) -> ~str {\n     }\n }\n \n-pub fn buf_str(toks: ~[Token], szs: ~[int], left: uint, right: uint,\n+pub fn buf_str(toks: Vec<Token> , szs: Vec<int> , left: uint, right: uint,\n                lim: uint) -> ~str {\n     let n = toks.len();\n     assert_eq!(n, szs.len());\n@@ -156,9 +156,9 @@ pub fn mk_printer(out: ~io::Writer, linewidth: uint) -> Printer {\n     // fall behind.\n     let n: uint = 3 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n-    let token: ~[Token] = vec::from_elem(n, Eof);\n-    let size: ~[int] = vec::from_elem(n, 0);\n-    let scan_stack: ~[uint] = vec::from_elem(n, 0u);\n+    let token: Vec<Token> = vec::from_elem(n, Eof);\n+    let size: Vec<int> = vec::from_elem(n, 0);\n+    let scan_stack: Vec<uint> = vec::from_elem(n, 0u);\n     Printer {\n         out: out,\n         buf_len: n,\n@@ -174,7 +174,7 @@ pub fn mk_printer(out: ~io::Writer, linewidth: uint) -> Printer {\n         scan_stack_empty: true,\n         top: 0,\n         bottom: 0,\n-        print_stack: ~[],\n+        print_stack: Vec::new(),\n         pending_indentation: 0\n     }\n }\n@@ -264,8 +264,8 @@ pub struct Printer {\n     space: int, // number of spaces left on line\n     left: uint, // index of left side of input stream\n     right: uint, // index of right side of input stream\n-    token: ~[Token], // ring-buffr stream goes through\n-    size: ~[int], // ring-buffer of calculated sizes\n+    token: Vec<Token> , // ring-buffr stream goes through\n+    size: Vec<int> , // ring-buffer of calculated sizes\n     left_total: int, // running size of stream \"...left\"\n     right_total: int, // running size of stream \"...right\"\n     // pseudo-stack, really a ring too. Holds the\n@@ -274,12 +274,12 @@ pub struct Printer {\n     // Begin (if there is any) on top of it. Stuff is flushed off the\n     // bottom as it becomes irrelevant due to the primary ring-buffer\n     // advancing.\n-    scan_stack: ~[uint],\n+    scan_stack: Vec<uint> ,\n     scan_stack_empty: bool, // top==bottom disambiguator\n     top: uint, // index of top of scan_stack\n     bottom: uint, // index of bottom of scan_stack\n     // stack of blocks-in-progress being flushed by print\n-    print_stack: ~[PrintStackElem],\n+    print_stack: Vec<PrintStackElem> ,\n     // buffered indentation to avoid writing trailing whitespace\n     pending_indentation: int,\n }"}, {"sha": "25ff793d34bcaaf8272ddaec469176eafecfbcce", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -60,10 +60,10 @@ pub struct State<'a> {\n     s: pp::Printer,\n     cm: Option<@CodeMap>,\n     intr: @token::IdentInterner,\n-    comments: Option<~[comments::Comment]>,\n-    literals: Option<~[comments::Literal]>,\n+    comments: Option<Vec<comments::Comment> >,\n+    literals: Option<Vec<comments::Literal> >,\n     cur_cmnt_and_lit: CurrentCommentAndLiteral,\n-    boxes: RefCell<~[pp::Breaks]>,\n+    boxes: RefCell<Vec<pp::Breaks> >,\n     ann: &'a PpAnn\n }\n \n@@ -98,7 +98,7 @@ pub fn rust_printer_annotated<'a>(writer: ~io::Writer, ann: &'a PpAnn) -> State<\n             cur_cmnt: 0,\n             cur_lit: 0\n         },\n-        boxes: RefCell::new(~[]),\n+        boxes: RefCell::new(Vec::new()),\n         ann: ann\n     }\n }\n@@ -140,7 +140,7 @@ pub fn print_crate(cm: @CodeMap,\n             cur_cmnt: 0,\n             cur_lit: 0\n         },\n-        boxes: RefCell::new(~[]),\n+        boxes: RefCell::new(Vec::new()),\n         ann: ann\n     };\n     print_crate_(&mut s, krate)\n@@ -1981,7 +1981,7 @@ pub fn print_generics(s: &mut State,\n             }\n         }\n \n-        let mut ints = ~[];\n+        let mut ints = Vec::new();\n         for i in range(0u, total) {\n             ints.push(i);\n         }\n@@ -2540,7 +2540,7 @@ mod test {\n         let abba_ident = token::str_to_ident(\"abba\");\n \n         let decl = ast::FnDecl {\n-            inputs: ~[],\n+            inputs: Vec::new(),\n             output: ast::P(ast::Ty {id: 0,\n                                     node: ast::TyNil,\n                                     span: codemap::DUMMY_SP}),\n@@ -2559,9 +2559,9 @@ mod test {\n \n         let var = codemap::respan(codemap::DUMMY_SP, ast::Variant_ {\n             name: ident,\n-            attrs: ~[],\n+            attrs: Vec::new(),\n             // making this up as I go.... ?\n-            kind: ast::TupleVariantKind(~[]),\n+            kind: ast::TupleVariantKind(Vec::new()),\n             id: 0,\n             disr_expr: None,\n             vis: ast::Public,"}, {"sha": "7969cacb765a47f11e5566413fd1d01bfbf76fbf", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -24,15 +24,15 @@ use std::rc::Rc;\n \n pub struct Interner<T> {\n     priv map: RefCell<HashMap<T, Name>>,\n-    priv vect: RefCell<~[T]>,\n+    priv vect: RefCell<Vec<T> >,\n }\n \n // when traits can extend traits, we should extend index<Name,T> to get []\n impl<T:Eq + Hash + Freeze + Clone + 'static> Interner<T> {\n     pub fn new() -> Interner<T> {\n         Interner {\n             map: RefCell::new(HashMap::new()),\n-            vect: RefCell::new(~[]),\n+            vect: RefCell::new(Vec::new()),\n         }\n     }\n \n@@ -134,15 +134,15 @@ impl RcStr {\n // &str rather than RcStr, resulting in less allocation.\n pub struct StrInterner {\n     priv map: RefCell<HashMap<RcStr, Name>>,\n-    priv vect: RefCell<~[RcStr]>,\n+    priv vect: RefCell<Vec<RcStr> >,\n }\n \n // when traits can extend traits, we should extend index<Name,T> to get []\n impl StrInterner {\n     pub fn new() -> StrInterner {\n         StrInterner {\n             map: RefCell::new(HashMap::new()),\n-            vect: RefCell::new(~[]),\n+            vect: RefCell::new(Vec::new()),\n         }\n     }\n "}, {"sha": "36243350d2161422fc74d8de8fc207f2c270cf70", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -17,20 +17,20 @@ use parse::token;\n \n // map a string to tts, using a made-up filename: return both the TokenTree's\n // and the ParseSess\n-pub fn string_to_tts_and_sess (source_str : ~str) -> (~[ast::TokenTree], @ParseSess) {\n+pub fn string_to_tts_and_sess (source_str : ~str) -> (Vec<ast::TokenTree> , @ParseSess) {\n     let ps = new_parse_sess();\n     (filemap_to_tts(ps,string_to_filemap(ps,source_str,~\"bogofile\")),ps)\n }\n \n // map a string to tts, using a made-up filename:\n-pub fn string_to_tts(source_str : ~str) -> ~[ast::TokenTree] {\n+pub fn string_to_tts(source_str : ~str) -> Vec<ast::TokenTree> {\n     let (tts,_) = string_to_tts_and_sess(source_str);\n     tts\n }\n \n pub fn string_to_parser_and_sess(source_str: ~str) -> (Parser,@ParseSess) {\n     let ps = new_parse_sess();\n-    (new_parser_from_source_str(ps,~[],~\"bogofile\",source_str),ps)\n+    (new_parser_from_source_str(ps,Vec::new(),~\"bogofile\",source_str),ps)\n }\n \n // map string to parser (via tts)\n@@ -69,14 +69,14 @@ pub fn string_to_expr (source_str : ~str) -> @ast::Expr {\n // parse a string, return an item\n pub fn string_to_item (source_str : ~str) -> Option<@ast::Item> {\n     with_error_checking_parse(source_str, |p| {\n-        p.parse_item(~[])\n+        p.parse_item(Vec::new())\n     })\n }\n \n // parse a string, return a stmt\n pub fn string_to_stmt(source_str : ~str) -> @ast::Stmt {\n     with_error_checking_parse(source_str, |p| {\n-        p.parse_stmt(~[])\n+        p.parse_stmt(Vec::new())\n     })\n }\n \n@@ -87,7 +87,7 @@ pub fn string_to_pat(source_str : ~str) -> @ast::Pat {\n }\n \n // convert a vector of strings to a vector of ast::Ident's\n-pub fn strs_to_idents(ids: ~[&str]) -> ~[ast::Ident] {\n+pub fn strs_to_idents(ids: Vec<&str> ) -> Vec<ast::Ident> {\n     ids.map(|u| token::str_to_ident(*u))\n }\n "}, {"sha": "22bf0f0a53f38e18005a922a0aee3c48bdaae417", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fd6ab90db3eb68c94695e1254a73e57bc44658/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=58fd6ab90db3eb68c94695e1254a73e57bc44658", "patch": "@@ -14,7 +14,7 @@ use std::vec;\n pub enum SmallVector<T> {\n     priv Zero,\n     priv One(T),\n-    priv Many(~[T]),\n+    priv Many(Vec<T> ),\n }\n \n impl<T> Container for SmallVector<T> {\n@@ -46,7 +46,7 @@ impl<T> SmallVector<T> {\n         One(v)\n     }\n \n-    pub fn many(vs: ~[T]) -> SmallVector<T> {\n+    pub fn many(vs: Vec<T> ) -> SmallVector<T> {\n         Many(vs)\n     }\n \n@@ -56,7 +56,7 @@ impl<T> SmallVector<T> {\n             One(..) => {\n                 let one = mem::replace(self, Zero);\n                 match one {\n-                    One(v1) => mem::replace(self, Many(~[v1, v])),\n+                    One(v1) => mem::replace(self, Many(vec!(v1, v))),\n                     _ => unreachable!()\n                 };\n             }\n@@ -142,7 +142,7 @@ mod test {\n         assert_eq!(0, v.len());\n \n         assert_eq!(1, SmallVector::one(1).len());\n-        assert_eq!(5, SmallVector::many(~[1, 2, 3, 4, 5]).len());\n+        assert_eq!(5, SmallVector::many(vec!(1, 2, 3, 4, 5)).len());\n     }\n \n     #[test]\n@@ -161,7 +161,7 @@ mod test {\n \n     #[test]\n     fn test_from_iterator() {\n-        let v: SmallVector<int> = (~[1, 2, 3]).move_iter().collect();\n+        let v: SmallVector<int> = (vec!(1, 2, 3)).move_iter().collect();\n         assert_eq!(3, v.len());\n         assert_eq!(&1, v.get(0));\n         assert_eq!(&2, v.get(1));\n@@ -171,14 +171,14 @@ mod test {\n     #[test]\n     fn test_move_iter() {\n         let v = SmallVector::zero();\n-        let v: ~[int] = v.move_iter().collect();\n-        assert_eq!(~[], v);\n+        let v: Vec<int> = v.move_iter().collect();\n+        assert_eq!(Vec::new(), v);\n \n         let v = SmallVector::one(1);\n-        assert_eq!(~[1], v.move_iter().collect());\n+        assert_eq!(vec!(1), v.move_iter().collect());\n \n-        let v = SmallVector::many(~[1, 2, 3]);\n-        assert_eq!(~[1, 2, 3], v.move_iter().collect());\n+        let v = SmallVector::many(vec!(1, 2, 3));\n+        assert_eq!(vec!(1, 2, 3), v.move_iter().collect());\n     }\n \n     #[test]\n@@ -190,12 +190,12 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_expect_one_many() {\n-        SmallVector::many(~[1, 2]).expect_one(\"\");\n+        SmallVector::many(vec!(1, 2)).expect_one(\"\");\n     }\n \n     #[test]\n     fn test_expect_one_one() {\n         assert_eq!(1, SmallVector::one(1).expect_one(\"\"));\n-        assert_eq!(1, SmallVector::many(~[1]).expect_one(\"\"));\n+        assert_eq!(1, SmallVector::many(vec!(1)).expect_one(\"\"));\n     }\n }"}]}