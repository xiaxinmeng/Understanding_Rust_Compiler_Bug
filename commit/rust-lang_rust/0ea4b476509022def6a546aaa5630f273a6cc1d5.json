{"sha": "0ea4b476509022def6a546aaa5630f273a6cc1d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlYTRiNDc2NTA5MDIyZGVmNmE1NDZhYWE1NjMwZjI3M2E2Y2MxZDU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-11-20T12:11:03Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-11-20T12:11:03Z"}, "message": "incr.comp.: Make sure we don't lose unused green results from the query cache.", "tree": {"sha": "2b150e77e70fb28cab110c1cd70493a0531f45d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b150e77e70fb28cab110c1cd70493a0531f45d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ea4b476509022def6a546aaa5630f273a6cc1d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ea4b476509022def6a546aaa5630f273a6cc1d5", "html_url": "https://github.com/rust-lang/rust/commit/0ea4b476509022def6a546aaa5630f273a6cc1d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ea4b476509022def6a546aaa5630f273a6cc1d5/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "580298680ca6500c537662f38b4f56dab9c8c9aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/580298680ca6500c537662f38b4f56dab9c8c9aa", "html_url": "https://github.com/rust-lang/rust/commit/580298680ca6500c537662f38b4f56dab9c8c9aa"}], "stats": {"total": 92, "additions": 92, "deletions": 0}, "files": [{"sha": "32f40367faba4731b752c2d42130f4b542e6cfbc", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0ea4b476509022def6a546aaa5630f273a6cc1d5/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea4b476509022def6a546aaa5630f273a6cc1d5/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=0ea4b476509022def6a546aaa5630f273a6cc1d5", "patch": "@@ -659,6 +659,39 @@ impl DepGraph {\n         }).unwrap_or(false)\n     }\n \n+    // This method loads all on-disk cacheable query results into memory, so\n+    // they can be written out to the new cache file again. Most query results\n+    // will already be in memory but in the case where we marked something as\n+    // green but then did not need the value, that value will never have been\n+    // loaded from disk.\n+    //\n+    // This method will only load queries that will end up in the disk cache.\n+    // Other queries will not be executed.\n+    pub fn exec_cache_promotions<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+        let green_nodes: Vec<DepNode> = {\n+            let data = self.data.as_ref().unwrap();\n+            data.colors.borrow().iter().filter_map(|(dep_node, color)| match color {\n+                DepNodeColor::Green(_) => {\n+                    if dep_node.cache_on_disk(tcx) {\n+                        Some(*dep_node)\n+                    } else {\n+                        None\n+                    }\n+                }\n+                DepNodeColor::Red => {\n+                    // We can skip red nodes because a node can only be marked\n+                    // as red if the query result was recomputed and thus is\n+                    // already in memory.\n+                    None\n+                }\n+            }).collect()\n+        };\n+\n+        for dep_node in green_nodes {\n+            dep_node.load_from_on_disk_cache(tcx);\n+        }\n+    }\n+\n     pub fn mark_loaded_from_cache(&self, dep_node_index: DepNodeIndex, state: bool) {\n         debug!(\"mark_loaded_from_cache({:?}, {})\",\n                self.data.as_ref().unwrap().current.borrow().nodes[dep_node_index],"}, {"sha": "6f55df76df4a13227bcf6fc42cb252fe5c0b77b8", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ea4b476509022def6a546aaa5630f273a6cc1d5/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea4b476509022def6a546aaa5630f273a6cc1d5/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=0ea4b476509022def6a546aaa5630f273a6cc1d5", "patch": "@@ -197,6 +197,10 @@ impl<'sess> OnDiskCache<'sess> {\n \n         encoder.encode_tagged(PREV_DIAGNOSTICS_TAG, &diagnostics)?;\n \n+        // Load everything into memory so we can write it out to the on-disk\n+        // cache. The vast majority of cacheable query results should already\n+        // be in memory, so this should be a cheap operation.\n+        tcx.dep_graph.exec_cache_promotions(tcx);\n \n         // Encode query results\n         let mut query_result_index = EncodedQueryResultIndex::new();"}, {"sha": "488c0748d551cf1e03522d1d7c76bf33e8b1a286", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0ea4b476509022def6a546aaa5630f273a6cc1d5/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea4b476509022def6a546aaa5630f273a6cc1d5/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=0ea4b476509022def6a546aaa5630f273a6cc1d5", "patch": "@@ -900,3 +900,58 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n \n     true\n }\n+\n+\n+// FIXME(#45015): Another piece of boilerplate code that could be generated in\n+//                a combined define_dep_nodes!()/define_maps!() macro.\n+macro_rules! impl_load_from_cache {\n+    ($($dep_kind:ident => $query_name:ident,)*) => {\n+        impl DepNode {\n+            // Check whether the query invocation corresponding to the given\n+            // DepNode is eligible for on-disk-caching.\n+            pub fn cache_on_disk(&self, tcx: TyCtxt) -> bool {\n+                use ty::maps::queries;\n+                use ty::maps::QueryDescription;\n+\n+                match self.kind {\n+                    $(DepKind::$dep_kind => {\n+                        let def_id = self.extract_def_id(tcx).unwrap();\n+                        queries::$query_name::cache_on_disk(def_id)\n+                    })*\n+                    _ => false\n+                }\n+            }\n+\n+            // This is method will execute the query corresponding to the given\n+            // DepNode. It is only expected to work for DepNodes where the\n+            // above `cache_on_disk` methods returns true.\n+            // Also, as a sanity check, it expects that the corresponding query\n+            // invocation has been marked as green already.\n+            pub fn load_from_on_disk_cache(&self, tcx: TyCtxt) {\n+                match self.kind {\n+                    $(DepKind::$dep_kind => {\n+                        debug_assert!(tcx.dep_graph\n+                                         .node_color(self)\n+                                         .map(|c| c.is_green())\n+                                         .unwrap_or(false));\n+\n+                        let def_id = self.extract_def_id(tcx).unwrap();\n+                        let _ = tcx.$query_name(def_id);\n+                    })*\n+                    _ => {\n+                        bug!()\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl_load_from_cache!(\n+    TypeckTables => typeck_tables_of,\n+    MirOptimized => optimized_mir,\n+    UnsafetyCheckResult => unsafety_check_result,\n+    BorrowCheck => borrowck,\n+    MirBorrowCheck => mir_borrowck,\n+    MirConstQualif => mir_const_qualif,\n+);"}]}