{"sha": "628e80d525392ebbcb889bb5d9b37e73c82d335a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyOGU4MGQ1MjUzOTJlYmJjYjg4OWJiNWQ5YjM3ZTczYzgyZDMzNWE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-20T03:51:31Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-20T04:58:45Z"}, "message": "syntax: Extract attribute parsing to its own mod", "tree": {"sha": "214d3f46dcb90a112012cacf6764e6ced9f092a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/214d3f46dcb90a112012cacf6764e6ced9f092a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/628e80d525392ebbcb889bb5d9b37e73c82d335a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/628e80d525392ebbcb889bb5d9b37e73c82d335a", "html_url": "https://github.com/rust-lang/rust/commit/628e80d525392ebbcb889bb5d9b37e73c82d335a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/628e80d525392ebbcb889bb5d9b37e73c82d335a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d6c79109e869de58d6545f683b3e796237039fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d6c79109e869de58d6545f683b3e796237039fb", "html_url": "https://github.com/rust-lang/rust/commit/3d6c79109e869de58d6545f683b3e796237039fb"}], "stats": {"total": 256, "additions": 140, "deletions": 116}, "files": [{"sha": "6482e28a0c809fff20441323105f5f0d5ec682f9", "filename": "src/librustsyntax/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/628e80d525392ebbcb889bb5d9b37e73c82d335a/src%2Flibrustsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/628e80d525392ebbcb889bb5d9b37e73c82d335a/src%2Flibrustsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse.rs?ref=628e80d525392ebbcb889bb5d9b37e73c82d335a", "patch": "@@ -86,7 +86,7 @@ fn parse_crate_from_crate_file(input: str, cfg: ast::crate_cfg,\n     let p = new_parser_from_file(sess, cfg, input, parser::CRATE_FILE);\n     let lo = p.span.lo;\n     let prefix = path::dirname(p.reader.filemap.name);\n-    let leading_attrs = parser::parse_inner_attrs_and_next(p);\n+    let leading_attrs = attr::parse_inner_attrs_and_next(p);\n     let crate_attrs = leading_attrs.inner;\n     let first_cdir_attr = leading_attrs.next;\n     let cdirs = parser::parse_crate_directives("}, {"sha": "7994ba00b1d9b1ab7607f1221d40275832af6a77", "filename": "src/librustsyntax/parse/attr.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/628e80d525392ebbcb889bb5d9b37e73c82d335a/src%2Flibrustsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/628e80d525392ebbcb889bb5d9b37e73c82d335a/src%2Flibrustsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fattr.rs?ref=628e80d525392ebbcb889bb5d9b37e73c82d335a", "patch": "@@ -0,0 +1,123 @@\n+import either::{either, left, right};\n+import parser::{parse_seq,\n+                seq_sep,\n+                expect,\n+                parse_lit,\n+                parse_ident,\n+                parse_syntax_ext_naked,\n+                spanned};\n+\n+export attr_or_ext;\n+export parse_outer_attributes;\n+export parse_outer_attrs_or_ext;\n+export parse_inner_attrs_and_next;\n+export parse_optional_meta;\n+\n+// A type to distingush between the parsing of item attributes or syntax\n+// extensions, which both begin with token.POUND\n+type attr_or_ext = option<either<[ast::attribute], @ast::expr>>;\n+\n+fn parse_outer_attrs_or_ext(\n+    p: parser,\n+    first_item_attrs: [ast::attribute]) -> attr_or_ext {\n+    let expect_item_next = vec::is_not_empty(first_item_attrs);\n+    if p.token == token::POUND {\n+        let lo = p.span.lo;\n+        if p.look_ahead(1u) == token::LBRACKET {\n+            p.bump();\n+            let first_attr = parse_attribute_naked(p, ast::attr_outer, lo);\n+            ret some(left([first_attr] + parse_outer_attributes(p)));\n+        } else if !(p.look_ahead(1u) == token::LT\n+                    || p.look_ahead(1u) == token::LBRACKET\n+                    || expect_item_next) {\n+            p.bump();\n+            ret some(right(parse_syntax_ext_naked(p, lo)));\n+        } else { ret none; }\n+    } else { ret none; }\n+}\n+\n+// Parse attributes that appear before an item\n+fn parse_outer_attributes(p: parser) -> [ast::attribute] {\n+    let mut attrs: [ast::attribute] = [];\n+    while p.token == token::POUND {\n+        attrs += [parse_attribute(p, ast::attr_outer)];\n+    }\n+    ret attrs;\n+}\n+\n+fn parse_attribute(p: parser, style: ast::attr_style) -> ast::attribute {\n+    let lo = p.span.lo;\n+    expect(p, token::POUND);\n+    ret parse_attribute_naked(p, style, lo);\n+}\n+\n+fn parse_attribute_naked(p: parser, style: ast::attr_style, lo: uint) ->\n+   ast::attribute {\n+    expect(p, token::LBRACKET);\n+    let meta_item = parse_meta_item(p);\n+    expect(p, token::RBRACKET);\n+    let mut hi = p.span.hi;\n+    ret spanned(lo, hi, {style: style, value: *meta_item});\n+}\n+\n+// Parse attributes that appear after the opening of an item, each terminated\n+// by a semicolon. In addition to a vector of inner attributes, this function\n+// also returns a vector that may contain the first outer attribute of the\n+// next item (since we can't know whether the attribute is an inner attribute\n+// of the containing item or an outer attribute of the first contained item\n+// until we see the semi).\n+fn parse_inner_attrs_and_next(p: parser) ->\n+   {inner: [ast::attribute], next: [ast::attribute]} {\n+    let mut inner_attrs: [ast::attribute] = [];\n+    let mut next_outer_attrs: [ast::attribute] = [];\n+    while p.token == token::POUND {\n+        if p.look_ahead(1u) != token::LBRACKET {\n+            // This is an extension\n+            break;\n+        }\n+        let attr = parse_attribute(p, ast::attr_inner);\n+        if p.token == token::SEMI {\n+            p.bump();\n+            inner_attrs += [attr];\n+        } else {\n+            // It's not really an inner attribute\n+            let outer_attr =\n+                spanned(attr.span.lo, attr.span.hi,\n+                        {style: ast::attr_outer, value: attr.node.value});\n+            next_outer_attrs += [outer_attr];\n+            break;\n+        }\n+    }\n+    ret {inner: inner_attrs, next: next_outer_attrs};\n+}\n+\n+fn parse_meta_item(p: parser) -> @ast::meta_item {\n+    let lo = p.span.lo;\n+    let ident = parse_ident(p);\n+    alt p.token {\n+      token::EQ {\n+        p.bump();\n+        let lit = parse_lit(p);\n+        let mut hi = p.span.hi;\n+        ret @spanned(lo, hi, ast::meta_name_value(ident, lit));\n+      }\n+      token::LPAREN {\n+        let inner_items = parse_meta_seq(p);\n+        let mut hi = p.span.hi;\n+        ret @spanned(lo, hi, ast::meta_list(ident, inner_items));\n+      }\n+      _ {\n+        let mut hi = p.span.hi;\n+        ret @spanned(lo, hi, ast::meta_word(ident));\n+      }\n+    }\n+}\n+\n+fn parse_meta_seq(p: parser) -> [@ast::meta_item] {\n+    ret parse_seq(token::LPAREN, token::RPAREN, seq_sep(token::COMMA),\n+                  parse_meta_item, p).node;\n+}\n+\n+fn parse_optional_meta(p: parser) -> [@ast::meta_item] {\n+    alt p.token { token::LPAREN { ret parse_meta_seq(p); } _ { ret []; } }\n+}"}, {"sha": "bf4e9f798d6cb2f630b25b49da35f7a8767c6571", "filename": "src/librustsyntax/parse/eval.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/628e80d525392ebbcb889bb5d9b37e73c82d335a/src%2Flibrustsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/628e80d525392ebbcb889bb5d9b37e73c82d335a/src%2Flibrustsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Feval.rs?ref=628e80d525392ebbcb889bb5d9b37e73c82d335a", "patch": "@@ -1,7 +1,6 @@\n-import attr;\n import parser::{parser,\n-                parse_inner_attrs_and_next,\n                 parse_mod_items, SOURCE_FILE};\n+import attr::parse_inner_attrs_and_next;\n \n export eval_crate_directives_to_mod;\n \n@@ -81,7 +80,7 @@ fn parse_companion_mod(cx: ctx, prefix: str, suffix: option<str>)\n }\n \n fn cdir_path_opt(id: str, attrs: [ast::attribute]) -> str {\n-    alt attr::first_attr_value_str_by_name(attrs, \"path\") {\n+    alt ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n       some(d) {\n         ret d;\n       }"}, {"sha": "013357dff156714df2f468b22aeaf4e19262edc5", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 111, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/628e80d525392ebbcb889bb5d9b37e73c82d335a/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/628e80d525392ebbcb889bb5d9b37e73c82d335a/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=628e80d525392ebbcb889bb5d9b37e73c82d335a", "patch": "@@ -8,6 +8,10 @@ import ast::spanned;\n import ast_util::{mk_sp, ident_to_path};\n import lexer::reader;\n import prec::{op_spec, as_prec};\n+import attr::{parse_outer_attrs_or_ext,\n+              parse_inner_attrs_and_next,\n+              parse_outer_attributes,\n+              parse_optional_meta};\n \n export expect;\n export file_type;\n@@ -17,14 +21,19 @@ export parser;\n export parse_crate_directives;\n export parse_crate_mod;\n export parse_expr;\n-export parse_inner_attrs_and_next;\n export parse_item;\n export parse_mod_items;\n-export parse_outer_attributes;\n export parse_pat;\n+export parse_seq;\n export parse_stmt;\n export parse_ty;\n \n+export spanned;\n+export seq_sep;\n+export parse_lit;\n+export parse_ident;\n+export parse_syntax_ext_naked;\n+\n // FIXME: #ast expects to find this here but it's actually defined in `parse`\n // Fixing this will be easier when we have export decls on individual items --\n // then parse can export this publicly, and everything else crate-visibly.\n@@ -2385,115 +2394,6 @@ fn parse_item(p: parser, attrs: [ast::attribute]) -> option<@ast::item> {\n else { ret none; }\n }\n \n-// A type to distingush between the parsing of item attributes or syntax\n-// extensions, which both begin with token.POUND\n-type attr_or_ext = option<either<[ast::attribute], @ast::expr>>;\n-\n-fn parse_outer_attrs_or_ext(\n-    p: parser,\n-    first_item_attrs: [ast::attribute]) -> attr_or_ext {\n-    let expect_item_next = vec::is_not_empty(first_item_attrs);\n-    if p.token == token::POUND {\n-        let lo = p.span.lo;\n-        if p.look_ahead(1u) == token::LBRACKET {\n-            p.bump();\n-            let first_attr = parse_attribute_naked(p, ast::attr_outer, lo);\n-            ret some(left([first_attr] + parse_outer_attributes(p)));\n-        } else if !(p.look_ahead(1u) == token::LT\n-                    || p.look_ahead(1u) == token::LBRACKET\n-                    || expect_item_next) {\n-            p.bump();\n-            ret some(right(parse_syntax_ext_naked(p, lo)));\n-        } else { ret none; }\n-    } else { ret none; }\n-}\n-\n-// Parse attributes that appear before an item\n-fn parse_outer_attributes(p: parser) -> [ast::attribute] {\n-    let mut attrs: [ast::attribute] = [];\n-    while p.token == token::POUND {\n-        attrs += [parse_attribute(p, ast::attr_outer)];\n-    }\n-    ret attrs;\n-}\n-\n-fn parse_attribute(p: parser, style: ast::attr_style) -> ast::attribute {\n-    let lo = p.span.lo;\n-    expect(p, token::POUND);\n-    ret parse_attribute_naked(p, style, lo);\n-}\n-\n-fn parse_attribute_naked(p: parser, style: ast::attr_style, lo: uint) ->\n-   ast::attribute {\n-    expect(p, token::LBRACKET);\n-    let meta_item = parse_meta_item(p);\n-    expect(p, token::RBRACKET);\n-    let mut hi = p.span.hi;\n-    ret spanned(lo, hi, {style: style, value: *meta_item});\n-}\n-\n-// Parse attributes that appear after the opening of an item, each terminated\n-// by a semicolon. In addition to a vector of inner attributes, this function\n-// also returns a vector that may contain the first outer attribute of the\n-// next item (since we can't know whether the attribute is an inner attribute\n-// of the containing item or an outer attribute of the first contained item\n-// until we see the semi).\n-fn parse_inner_attrs_and_next(p: parser) ->\n-   {inner: [ast::attribute], next: [ast::attribute]} {\n-    let mut inner_attrs: [ast::attribute] = [];\n-    let mut next_outer_attrs: [ast::attribute] = [];\n-    while p.token == token::POUND {\n-        if p.look_ahead(1u) != token::LBRACKET {\n-            // This is an extension\n-            break;\n-        }\n-        let attr = parse_attribute(p, ast::attr_inner);\n-        if p.token == token::SEMI {\n-            p.bump();\n-            inner_attrs += [attr];\n-        } else {\n-            // It's not really an inner attribute\n-            let outer_attr =\n-                spanned(attr.span.lo, attr.span.hi,\n-                        {style: ast::attr_outer, value: attr.node.value});\n-            next_outer_attrs += [outer_attr];\n-            break;\n-        }\n-    }\n-    ret {inner: inner_attrs, next: next_outer_attrs};\n-}\n-\n-fn parse_meta_item(p: parser) -> @ast::meta_item {\n-    let lo = p.span.lo;\n-    let ident = parse_ident(p);\n-    alt p.token {\n-      token::EQ {\n-        p.bump();\n-        let lit = parse_lit(p);\n-        let mut hi = p.span.hi;\n-        ret @spanned(lo, hi, ast::meta_name_value(ident, lit));\n-      }\n-      token::LPAREN {\n-        let inner_items = parse_meta_seq(p);\n-        let mut hi = p.span.hi;\n-        ret @spanned(lo, hi, ast::meta_list(ident, inner_items));\n-      }\n-      _ {\n-        let mut hi = p.span.hi;\n-        ret @spanned(lo, hi, ast::meta_word(ident));\n-      }\n-    }\n-}\n-\n-fn parse_meta_seq(p: parser) -> [@ast::meta_item] {\n-    ret parse_seq(token::LPAREN, token::RPAREN, seq_sep(token::COMMA),\n-                  parse_meta_item, p).node;\n-}\n-\n-fn parse_optional_meta(p: parser) -> [@ast::meta_item] {\n-    alt p.token { token::LPAREN { ret parse_meta_seq(p); } _ { ret []; } }\n-}\n-\n fn parse_use(p: parser) -> ast::view_item_ {\n     let ident = parse_ident(p);\n     let metadata = parse_optional_meta(p);"}, {"sha": "5a479269244fc39c0679352ecd1b3d354fabdea8", "filename": "src/librustsyntax/rustsyntax.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/628e80d525392ebbcb889bb5d9b37e73c82d335a/src%2Flibrustsyntax%2Frustsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/628e80d525392ebbcb889bb5d9b37e73c82d335a/src%2Flibrustsyntax%2Frustsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Frustsyntax.rc?ref=628e80d525392ebbcb889bb5d9b37e73c82d335a", "patch": "@@ -28,12 +28,14 @@ mod parse {\n     export comments;\n     export prec;\n     export classify;\n+    export attr;\n \n     mod eval;\n     mod lexer;\n     mod parser;\n     mod token;\n     mod comments;\n+    mod attr;\n \n     #[doc = \"Functions dealing with operator precedence\"]\n     mod prec;"}, {"sha": "73bd801c1ccd0c1f8f7ebcab4c7d5b9a66580b9a", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/628e80d525392ebbcb889bb5d9b37e73c82d335a/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/628e80d525392ebbcb889bb5d9b37e73c82d335a/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=628e80d525392ebbcb889bb5d9b37e73c82d335a", "patch": "@@ -38,7 +38,7 @@ mod test {\n         let parser = parse::new_parser_from_source_str(\n             parse_sess, [], \"-\", codemap::fss_none, @source);\n \n-        parser::parse_outer_attributes(parser)\n+        parse::attr::parse_outer_attributes(parser)\n     }\n }\n "}]}