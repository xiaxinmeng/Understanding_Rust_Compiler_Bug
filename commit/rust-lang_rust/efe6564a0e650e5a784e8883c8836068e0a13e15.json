{"sha": "efe6564a0e650e5a784e8883c8836068e0a13e15", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmZTY1NjRhMGU2NTBlNWE3ODRlODg4M2M4ODM2MDY4ZTBhMTNlMTU=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-05-18T19:53:30Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-05-18T19:58:33Z"}, "message": "Code modernisation and cleanup", "tree": {"sha": "79bed2d3ebc156bc7aa8c65803fd4ccd0c36d805", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79bed2d3ebc156bc7aa8c65803fd4ccd0c36d805"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efe6564a0e650e5a784e8883c8836068e0a13e15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efe6564a0e650e5a784e8883c8836068e0a13e15", "html_url": "https://github.com/rust-lang/rust/commit/efe6564a0e650e5a784e8883c8836068e0a13e15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efe6564a0e650e5a784e8883c8836068e0a13e15/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d73f31b31d1b9f14a6b5288ba5b9cb5277b08f3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d73f31b31d1b9f14a6b5288ba5b9cb5277b08f3a", "html_url": "https://github.com/rust-lang/rust/commit/d73f31b31d1b9f14a6b5288ba5b9cb5277b08f3a"}], "stats": {"total": 164, "additions": 100, "deletions": 64}, "files": [{"sha": "3a0e7bd0639882276c52f8c23cac66286bef74b6", "filename": "src/libcore/char.rs", "status": "modified", "additions": 100, "deletions": 64, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/efe6564a0e650e5a784e8883c8836068e0a13e15/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe6564a0e650e5a784e8883c8836068e0a13e15/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=efe6564a0e650e5a784e8883c8836068e0a13e15", "patch": "@@ -10,47 +10,50 @@\n \n //! Utilities for manipulating the char type\n \n-#[cfg(not(test))]\n-use cmp::Ord;\n use option::{None, Option, Some};\n use str;\n+#[cfg(stage0)]\n+use str::StrSlice;\n+#[cfg(not(stage0))]\n+use str::{StrSlice, OwnedStr};\n use u32;\n use uint;\n use unicode::{derived_property, general_category};\n \n-#[cfg(not(test))] use cmp::Eq;\n+#[cfg(not(test))]\n+use cmp::{Eq, Ord};\n \n /*\n-    Lu  Uppercase_Letter    an uppercase letter\n-    Ll  Lowercase_Letter    a lowercase letter\n-    Lt  Titlecase_Letter    a digraphic character, with first part uppercase\n-    Lm  Modifier_Letter     a modifier letter\n-    Lo  Other_Letter    other letters, including syllables and ideographs\n-    Mn  Nonspacing_Mark     a nonspacing combining mark (zero advance width)\n-    Mc  Spacing_Mark    a spacing combining mark (positive advance width)\n-    Me  Enclosing_Mark  an enclosing combining mark\n-    Nd  Decimal_Number  a decimal digit\n-    Nl  Letter_Number   a letterlike numeric character\n-    No  Other_Number    a numeric character of other type\n+    Lu  Uppercase_Letter        an uppercase letter\n+    Ll  Lowercase_Letter        a lowercase letter\n+    Lt  Titlecase_Letter        a digraphic character, with first part uppercase\n+    Lm  Modifier_Letter         a modifier letter\n+    Lo  Other_Letter            other letters, including syllables and ideographs\n+    Mn  Nonspacing_Mark         a nonspacing combining mark (zero advance width)\n+    Mc  Spacing_Mark            a spacing combining mark (positive advance width)\n+    Me  Enclosing_Mark          an enclosing combining mark\n+    Nd  Decimal_Number          a decimal digit\n+    Nl  Letter_Number           a letterlike numeric character\n+    No  Other_Number            a numeric character of other type\n     Pc  Connector_Punctuation   a connecting punctuation mark, like a tie\n-    Pd  Dash_Punctuation    a dash or hyphen punctuation mark\n-    Ps  Open_Punctuation    an opening punctuation mark (of a pair)\n-    Pe  Close_Punctuation   a closing punctuation mark (of a pair)\n+    Pd  Dash_Punctuation        a dash or hyphen punctuation mark\n+    Ps  Open_Punctuation        an opening punctuation mark (of a pair)\n+    Pe  Close_Punctuation       a closing punctuation mark (of a pair)\n     Pi  Initial_Punctuation     an initial quotation mark\n-    Pf  Final_Punctuation   a final quotation mark\n-    Po  Other_Punctuation   a punctuation mark of other type\n-    Sm  Math_Symbol     a symbol of primarily mathematical use\n-    Sc  Currency_Symbol     a currency sign\n-    Sk  Modifier_Symbol     a non-letterlike modifier symbol\n-    So  Other_Symbol    a symbol of other type\n-    Zs  Space_Separator     a space character (of various non-zero widths)\n-    Zl  Line_Separator  U+2028 LINE SEPARATOR only\n+    Pf  Final_Punctuation       a final quotation mark\n+    Po  Other_Punctuation       a punctuation mark of other type\n+    Sm  Math_Symbol             a symbol of primarily mathematical use\n+    Sc  Currency_Symbol         a currency sign\n+    Sk  Modifier_Symbol         a non-letterlike modifier symbol\n+    So  Other_Symbol            a symbol of other type\n+    Zs  Space_Separator         a space character (of various non-zero widths)\n+    Zl  Line_Separator          U+2028 LINE SEPARATOR only\n     Zp  Paragraph_Separator     U+2029 PARAGRAPH SEPARATOR only\n-    Cc  Control     a C0 or C1 control code\n-    Cf  Format  a format control character\n-    Cs  Surrogate   a surrogate code point\n-    Co  Private_Use     a private-use character\n-    Cn  Unassigned  a reserved unassigned code point or a noncharacter\n+    Cc  Control                 a C0 or C1 control code\n+    Cf  Format                  a format control character\n+    Cs  Surrogate               a surrogate code point\n+    Co  Private_Use             a private-use character\n+    Cn  Unassigned              a reserved unassigned code point or a noncharacter\n */\n \n pub fn is_alphabetic(c: char) -> bool   { derived_property::Alphabetic(c) }\n@@ -62,18 +65,14 @@ pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }\n  * in terms of the Unicode General Category 'Ll'\n  */\n #[inline(always)]\n-pub fn is_lowercase(c: char) -> bool {\n-    return general_category::Ll(c);\n-}\n+pub fn is_lowercase(c: char) -> bool { general_category::Ll(c) }\n \n /**\n  * Indicates whether a character is in upper case, defined\n  * in terms of the Unicode General Category 'Lu'.\n  */\n #[inline(always)]\n-pub fn is_uppercase(c: char) -> bool {\n-    return general_category::Lu(c);\n-}\n+pub fn is_uppercase(c: char) -> bool { general_category::Lu(c) }\n \n /**\n  * Indicates whether a character is whitespace. Whitespace is defined in\n@@ -82,10 +81,10 @@ pub fn is_uppercase(c: char) -> bool {\n  */\n #[inline(always)]\n pub fn is_whitespace(c: char) -> bool {\n-    return ('\\x09' <= c && c <= '\\x0d')\n+    ('\\x09' <= c && c <= '\\x0d')\n         || general_category::Zs(c)\n         || general_category::Zl(c)\n-        || general_category::Zp(c);\n+        || general_category::Zp(c)\n }\n \n /**\n@@ -95,18 +94,18 @@ pub fn is_whitespace(c: char) -> bool {\n  */\n #[inline(always)]\n pub fn is_alphanumeric(c: char) -> bool {\n-    return derived_property::Alphabetic(c) ||\n-        general_category::Nd(c) ||\n-        general_category::Nl(c) ||\n-        general_category::No(c);\n+    derived_property::Alphabetic(c)\n+        || general_category::Nd(c)\n+        || general_category::Nl(c)\n+        || general_category::No(c)\n }\n \n /// Indicates whether the character is numeric (Nd, Nl, or No)\n #[inline(always)]\n pub fn is_digit(c: char) -> bool {\n-    return general_category::Nd(c) ||\n-        general_category::Nl(c) ||\n-        general_category::No(c);\n+    general_category::Nd(c)\n+        || general_category::Nl(c)\n+        || general_category::No(c)\n }\n \n /**\n@@ -125,7 +124,7 @@ pub fn is_digit(c: char) -> bool {\n pub fn is_digit_radix(c: char, radix: uint) -> bool {\n     match to_digit(c, radix) {\n         Some(_) => true,\n-        None    => false\n+        None    => false,\n     }\n }\n \n@@ -151,7 +150,7 @@ pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n       '0' .. '9' => c as uint - ('0' as uint),\n       'a' .. 'z' => c as uint + 10u - ('a' as uint),\n       'A' .. 'Z' => c as uint + 10u - ('A' as uint),\n-      _ => return None\n+      _ => return None,\n     };\n     if val < radix { Some(val) }\n     else { None }\n@@ -181,6 +180,21 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     }\n }\n \n+#[cfg(stage0)]\n+pub fn escape_unicode(c: char) -> ~str {\n+    let s = u32::to_str_radix(c as u32, 16u);\n+    let (c, pad) = (if c <= '\\xff' { ('x', 2u) }\n+                    else if c <= '\\uffff' { ('u', 4u) }\n+                    else { ('U', 8u) });\n+    assert!(str::len(s) <= pad);\n+    let mut out = ~\"\\\\\";\n+    str::push_str(&mut out, str::from_char(c));\n+    for uint::range(str::len(s), pad) |_i|\n+        { str::push_str(&mut out, ~\"0\"); }\n+    str::push_str(&mut out, s);\n+    out\n+}\n+\n /**\n  * Return the hexadecimal unicode escape of a char.\n  *\n@@ -190,17 +204,21 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n  *   - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n  *   - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n  */\n+#[cfg(not(stage0))]\n pub fn escape_unicode(c: char) -> ~str {\n     let s = u32::to_str_radix(c as u32, 16u);\n-    let (c, pad) = (if c <= '\\xff' { ('x', 2u) }\n-                    else if c <= '\\uffff' { ('u', 4u) }\n-                    else { ('U', 8u) });\n-    assert!(str::len(s) <= pad);\n+    let (c, pad) = cond!(\n+        (c <= '\\xff')   { ('x', 2u) }\n+        (c <= '\\uffff') { ('u', 4u) }\n+        _               { ('U', 8u) }\n+    );\n+    assert!(s.len() <= pad);\n     let mut out = ~\"\\\\\";\n-    str::push_str(&mut out, str::from_char(c));\n-    for uint::range(str::len(s), pad) |_i|\n-        { str::push_str(&mut out, ~\"0\"); }\n-    str::push_str(&mut out, s);\n+    out.push_str(str::from_char(c));\n+    for uint::range(s.len(), pad) |_| {\n+        out.push_str(\"0\");\n+    }\n+    out.push_str(s);\n     out\n }\n \n@@ -218,18 +236,18 @@ pub fn escape_unicode(c: char) -> ~str {\n  */\n pub fn escape_default(c: char) -> ~str {\n     match c {\n-      '\\t' => ~\"\\\\t\",\n-      '\\r' => ~\"\\\\r\",\n-      '\\n' => ~\"\\\\n\",\n-      '\\\\' => ~\"\\\\\\\\\",\n-      '\\'' => ~\"\\\\'\",\n-      '\"'  => ~\"\\\\\\\"\",\n-      '\\x20' .. '\\x7e' => str::from_char(c),\n-      _ => escape_unicode(c)\n+        '\\t' => ~\"\\\\t\",\n+        '\\r' => ~\"\\\\r\",\n+        '\\n' => ~\"\\\\n\",\n+        '\\\\' => ~\"\\\\\\\\\",\n+        '\\'' => ~\"\\\\'\",\n+        '\"'  => ~\"\\\\\\\"\",\n+        '\\x20' .. '\\x7e' => str::from_char(c),\n+        _ => c.escape_unicode(),\n     }\n }\n \n-/// Returns the amount of bytes this character would need if encoded in utf8\n+#[cfg(stage0)]\n pub fn len_utf8_bytes(c: char) -> uint {\n     static max_one_b: uint = 128u;\n     static max_two_b: uint = 2048u;\n@@ -244,6 +262,24 @@ pub fn len_utf8_bytes(c: char) -> uint {\n     else { fail!(\"invalid character!\") }\n }\n \n+/// Returns the amount of bytes this character would need if encoded in utf8\n+#[cfg(not(stage0))]\n+pub fn len_utf8_bytes(c: char) -> uint {\n+    static MAX_ONE_B:   uint = 128u;\n+    static MAX_TWO_B:   uint = 2048u;\n+    static MAX_THREE_B: uint = 65536u;\n+    static MAX_FOUR_B:  uint = 2097152u;\n+\n+    let code = c as uint;\n+    cond!(\n+        (code < MAX_ONE_B)   { 1u }\n+        (code < MAX_TWO_B)   { 2u }\n+        (code < MAX_THREE_B) { 3u }\n+        (code < MAX_FOUR_B)  { 4u }\n+        _ { fail!(\"invalid character!\") }\n+    )\n+}\n+\n pub trait Char {\n     fn is_alphabetic(&self) -> bool;\n     fn is_XID_start(&self) -> bool;"}]}