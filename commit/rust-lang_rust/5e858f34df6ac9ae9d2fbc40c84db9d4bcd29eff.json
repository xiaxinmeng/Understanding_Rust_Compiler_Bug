{"sha": "5e858f34df6ac9ae9d2fbc40c84db9d4bcd29eff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlODU4ZjM0ZGY2YWM5YWU5ZDJmYmM0MGM4NGRiOWQ0YmNkMjllZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-03T14:47:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-03T14:47:36Z"}, "message": "Auto merge of #34532 - jonmarkprice:master, r=steveklabnik\n\nBook: Small grammatical and stylistic edits to book\n\nI've been reading [the book](https://doc.rust-lang.org/book/) and noticed a few small grammatical and stylistic issues which I've rolled into this pull request.\n\nI'm not sure if I should do so many small, unrelated edits in a single pull request but it seems like a lot of overhead for each small edit. Maybe one commit per edit but one pull request per file/section? Feedback is very much appreciated as this is my first pull request ever!\n\nr? @steveklabnik rollup", "tree": {"sha": "26147ec080f06e1e0a08960b44e17126d3a434e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26147ec080f06e1e0a08960b44e17126d3a434e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e858f34df6ac9ae9d2fbc40c84db9d4bcd29eff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e858f34df6ac9ae9d2fbc40c84db9d4bcd29eff", "html_url": "https://github.com/rust-lang/rust/commit/5e858f34df6ac9ae9d2fbc40c84db9d4bcd29eff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e858f34df6ac9ae9d2fbc40c84db9d4bcd29eff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20183f498fbd8465859bf47611e1165768b9cc59", "url": "https://api.github.com/repos/rust-lang/rust/commits/20183f498fbd8465859bf47611e1165768b9cc59", "html_url": "https://github.com/rust-lang/rust/commit/20183f498fbd8465859bf47611e1165768b9cc59"}, {"sha": "ec66b5addc8c2e46acb12114ead41324adaaac54", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec66b5addc8c2e46acb12114ead41324adaaac54", "html_url": "https://github.com/rust-lang/rust/commit/ec66b5addc8c2e46acb12114ead41324adaaac54"}], "stats": {"total": 60, "additions": 33, "deletions": 27}, "files": [{"sha": "f7d9c94bc454f31a052f828a7385623801f7ac5c", "filename": "src/doc/book/lifetimes.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e858f34df6ac9ae9d2fbc40c84db9d4bcd29eff/src%2Fdoc%2Fbook%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e858f34df6ac9ae9d2fbc40c84db9d4bcd29eff/src%2Fdoc%2Fbook%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flifetimes.md?ref=5e858f34df6ac9ae9d2fbc40c84db9d4bcd29eff", "patch": "@@ -290,7 +290,7 @@ lifetime parameters using three easily memorizable and unambiguous rules. This m\n acts as a shorthand for writing an item signature, while not hiding\n away the actual types involved as full local inference would if applied to it.\n \n-When talking about lifetime elision, we use the term *input lifetime* and\n+When talking about lifetime elision, we use the terms *input lifetime* and\n *output lifetime*. An *input lifetime* is a lifetime associated with a parameter\n of a function, and an *output lifetime* is a lifetime associated with the return\n value of a function. For example, this function has an input lifetime:\n@@ -335,11 +335,13 @@ fn print<'a>(s: &'a str); // expanded\n \n fn debug(lvl: u32, s: &str); // elided\n fn debug<'a>(lvl: u32, s: &'a str); // expanded\n+```\n \n-// In the preceding example, `lvl` doesn\u2019t need a lifetime because it\u2019s not a\n-// reference (`&`). Only things relating to references (such as a `struct`\n-// which contains a reference) need lifetimes.\n+In the preceding example, `lvl` doesn\u2019t need a lifetime because it\u2019s not a\n+reference (`&`). Only things relating to references (such as a `struct`\n+which contains a reference) need lifetimes.\n \n+```rust,ignore\n fn substr(s: &str, until: u32) -> &str; // elided\n fn substr<'a>(s: &'a str, until: u32) -> &'a str; // expanded\n "}, {"sha": "23ca21b3b49923f01ed930a2dbb4acac7d81ff3b", "filename": "src/doc/book/ownership.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e858f34df6ac9ae9d2fbc40c84db9d4bcd29eff/src%2Fdoc%2Fbook%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e858f34df6ac9ae9d2fbc40c84db9d4bcd29eff/src%2Fdoc%2Fbook%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fownership.md?ref=5e858f34df6ac9ae9d2fbc40c84db9d4bcd29eff", "patch": "@@ -214,7 +214,7 @@ But, unlike a move, we can still use `v` afterward. This is because an `i32`\n has no pointers to data somewhere else, copying it is a full copy.\n \n All primitive types implement the `Copy` trait and their ownership is\n-therefore not moved like one would assume, following the \u00b4ownership rules\u00b4.\n+therefore not moved like one would assume, following the \u2018ownership rules\u2019.\n To give an example, the two following snippets of code only compile because the\n `i32` and `bool` types implement the `Copy` trait.\n \n@@ -290,6 +290,6 @@ let (v1, v2, answer) = foo(v1, v2);\n Ugh! The return type, return line, and calling the function gets way more\n complicated.\n \n-Luckily, Rust offers a feature, borrowing, which helps us solve this problem.\n-It\u2019s the topic of the next section!\n+Luckily, Rust offers a feature which helps us solve this problem.\n+It\u2019s called borrowing and is the topic of the next section!\n "}, {"sha": "57bfbce8b84debab2f26a638ae1aed85ecc491ed", "filename": "src/doc/book/references-and-borrowing.md", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5e858f34df6ac9ae9d2fbc40c84db9d4bcd29eff/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e858f34df6ac9ae9d2fbc40c84db9d4bcd29eff/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md?ref=5e858f34df6ac9ae9d2fbc40c84db9d4bcd29eff", "patch": "@@ -123,7 +123,7 @@ let v = vec![];\n foo(&v);\n ```\n \n-errors with:\n+will give us this error:\n \n ```text\n error: cannot borrow immutable borrowed content `*v` as mutable\n@@ -152,8 +152,8 @@ the thing `y` points at. You\u2019ll notice that `x` had to be marked `mut` as well\n If it wasn\u2019t, we couldn\u2019t take a mutable borrow to an immutable value.\n \n You'll also notice we added an asterisk (`*`) in front of `y`, making it `*y`,\n-this is because `y` is a `&mut` reference. You'll also need to use them for\n-accessing the contents of a reference as well.\n+this is because `y` is a `&mut` reference. You'll need to use astrisks to\n+access the contents of a reference as well.\n \n Otherwise, `&mut` references are like references. There _is_ a large\n difference between the two, and how they interact, though. You can tell\n@@ -179,7 +179,7 @@ As it turns out, there are rules.\n \n # The Rules\n \n-Here\u2019s the rules about borrowing in Rust:\n+Here are the rules for borrowing in Rust:\n \n First, any borrow must last for a scope no greater than that of the owner.\n Second, you may have one or the other of these two kinds of borrows, but not\n@@ -208,12 +208,14 @@ With this in mind, let\u2019s consider our example again.\n Here\u2019s the code:\n \n ```rust,ignore\n-let mut x = 5;\n-let y = &mut x;\n+fn main() {\n+    let mut x = 5;\n+    let y = &mut x;\n \n-*y += 1;\n+    *y += 1;\n \n-println!(\"{}\", x);\n+    println!(\"{}\", x);\n+}\n ```\n \n This code gives us this error:\n@@ -225,7 +227,7 @@ error: cannot borrow `x` as immutable because it is also borrowed as mutable\n ```\n \n This is because we\u2019ve violated the rules: we have a `&mut T` pointing to `x`,\n-and so we aren\u2019t allowed to create any `&T`s. One or the other. The note\n+and so we aren\u2019t allowed to create any `&T`s. It's one or the other. The note\n hints at how to think about this problem:\n \n ```text\n@@ -243,14 +245,16 @@ In Rust, borrowing is tied to the scope that the borrow is valid for. And our\n scopes look like this:\n \n ```rust,ignore\n-let mut x = 5;\n-\n-let y = &mut x;    // -+ &mut borrow of x starts here\n-                   //  |\n-*y += 1;           //  |\n-                   //  |\n-println!(\"{}\", x); // -+ - try to borrow x here\n-                   // -+ &mut borrow of x ends here\n+fn main() {\n+    let mut x = 5;\n+\n+    let y = &mut x;    // -+ &mut borrow of x starts here\n+                       //  |\n+    *y += 1;           //  |\n+                       //  |\n+    println!(\"{}\", x); // -+ - try to borrow x here\n+}                      // -+ &mut borrow of x ends here\n+                       \n ```\n \n The scopes conflict: we can\u2019t make an `&x` while `y` is in scope.\n@@ -269,12 +273,12 @@ println!(\"{}\", x);  // <- try to borrow x here\n ```\n \n There\u2019s no problem. Our mutable borrow goes out of scope before we create an\n-immutable one. But scope is the key to seeing how long a borrow lasts for.\n+immutable one. So scope is the key to seeing how long a borrow lasts for.\n \n ## Issues borrowing prevents\n \n Why have these restrictive rules? Well, as we noted, these rules prevent data\n-races. What kinds of issues do data races cause? Here\u2019s a few.\n+races. What kinds of issues do data races cause? Here are a few.\n \n ### Iterator invalidation\n \n@@ -323,7 +327,7 @@ for i in &v {\n \n We can\u2019t modify `v` because it\u2019s borrowed by the loop.\n \n-### use after free\n+### Use after free\n \n References must not live longer than the resource they refer to. Rust will\n check the scopes of your references to ensure that this is true."}]}