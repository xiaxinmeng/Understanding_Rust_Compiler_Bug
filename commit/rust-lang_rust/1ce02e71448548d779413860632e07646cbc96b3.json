{"sha": "1ce02e71448548d779413860632e07646cbc96b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZTAyZTcxNDQ4NTQ4ZDc3OTQxMzg2MDYzMmUwNzY0NmNiYzk2YjM=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-09-13T09:41:49Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-09-15T10:28:25Z"}, "message": "debuginfo: Added test cases for recursive structs.", "tree": {"sha": "1fa3b21b3ab0cb85e4e89a3be4c3b7eabf018bac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fa3b21b3ab0cb85e4e89a3be4c3b7eabf018bac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ce02e71448548d779413860632e07646cbc96b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ce02e71448548d779413860632e07646cbc96b3", "html_url": "https://github.com/rust-lang/rust/commit/1ce02e71448548d779413860632e07646cbc96b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ce02e71448548d779413860632e07646cbc96b3/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f85da506a88265f7e541ef548c644527f7510945", "url": "https://api.github.com/repos/rust-lang/rust/commits/f85da506a88265f7e541ef548c644527f7510945", "html_url": "https://github.com/rust-lang/rust/commit/f85da506a88265f7e541ef548c644527f7510945"}], "stats": {"total": 315, "additions": 315, "deletions": 0}, "files": [{"sha": "4c602ba383298e9e13384d198f8dc2dc18fba9c1", "filename": "src/test/debug-info/recursive-struct.rs", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/1ce02e71448548d779413860632e07646cbc96b3/src%2Ftest%2Fdebug-info%2Frecursive-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce02e71448548d779413860632e07646cbc96b3/src%2Ftest%2Fdebug-info%2Frecursive-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Frecursive-struct.rs?ref=1ce02e71448548d779413860632e07646cbc96b3", "patch": "@@ -0,0 +1,314 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:rbreak zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print stack_unique.value\n+// check:$1 = 0\n+// debugger:print stack_unique.next.val->value\n+// check:$2 = 1\n+\n+// debugger:print unique_unique->value\n+// check:$3 = 2\n+// debugger:print unique_unique->next.val->value\n+// check:$4 = 3\n+\n+// debugger:print box_unique->val.value\n+// check:$5 = 4\n+// debugger:print box_unique->val.next.val->value\n+// check:$6 = 5\n+\n+// debugger:print vec_unique[0].value\n+// check:$7 = 6.5\n+// debugger:print vec_unique[0].next.val->value\n+// check:$8 = 7.5\n+\n+// debugger:print borrowed_unique->value\n+// check:$9 = 8.5\n+// debugger:print borrowed_unique->next.val->value\n+// check:$10 = 9.5\n+\n+// MANAGED\n+// debugger:print stack_managed.value\n+// check:$11 = 10\n+// debugger:print stack_managed.next.val->val.value\n+// check:$12 = 11\n+\n+// debugger:print unique_managed->val.value\n+// check:$13 = 12\n+// debugger:print unique_managed->val.next.val->val.value\n+// check:$14 = 13\n+\n+// debugger:print box_managed->val.value\n+// check:$15 = 14\n+// debugger:print box_managed->val.next.val->val.value\n+// check:$16 = 15\n+\n+// debugger:print vec_managed[0].value\n+// check:$17 = 16.5\n+// debugger:print vec_managed[0].next.val->val.value\n+// check:$18 = 17.5\n+\n+// debugger:print borrowed_managed->value\n+// check:$19 = 18.5\n+// debugger:print borrowed_managed->next.val->val.value\n+// check:$20 = 19.5\n+\n+// LONG CYCLE\n+// debugger:print long_cycle1.value\n+// check:$21 = 20\n+// debugger:print long_cycle1.next->value\n+// check:$22 = 21\n+// debugger:print long_cycle1.next->next->value\n+// check:$23 = 22\n+// debugger:print long_cycle1.next->next->next->value\n+// check:$24 = 23\n+\n+// debugger:print long_cycle2.value\n+// check:$25 = 24\n+// debugger:print long_cycle2.next->value\n+// check:$26 = 25\n+// debugger:print long_cycle2.next->next->value\n+// check:$27 = 26\n+\n+// debugger:print long_cycle3.value\n+// check:$28 = 27\n+// debugger:print long_cycle3.next->value\n+// check:$29 = 28\n+\n+// debugger:print long_cycle4.value\n+// check:$30 = 29.5\n+\n+// debugger:print (*****long_cycle_w_anonymous_types).value\n+// check:$31 = 30\n+\n+// debugger:print (*****((*****long_cycle_w_anonymous_types).next.val)).value\n+// check:$32 = 31\n+\n+// debugger:continue\n+\n+#[allow(unused_variable)];\n+\n+enum Opt<T> {\n+    Empty,\n+    Val { val: T }\n+}\n+\n+struct UniqueNode<T> {\n+    next: Opt<~UniqueNode<T>>,\n+    value: T\n+}\n+\n+struct ManagedNode<T> {\n+    next: Opt<@ManagedNode<T>>,\n+    value: T\n+}\n+\n+struct LongCycle1<T> {\n+    next: ~LongCycle2<T>,\n+    value: T,\n+}\n+\n+struct LongCycle2<T> {\n+    next: ~LongCycle3<T>,\n+    value: T,\n+}\n+\n+struct LongCycle3<T> {\n+    next: ~LongCycle4<T>,\n+    value: T,\n+}\n+\n+struct LongCycle4<T> {\n+    next: Option<~LongCycle1<T>>,\n+    value: T,\n+}\n+\n+struct LongCycleWithAnonymousTypes {\n+    next: Opt<~~~~~LongCycleWithAnonymousTypes>,\n+    value: uint,\n+}\n+\n+// This test case makes sure that recursive structs are properly described. The Node structs are\n+// generic so that we can have a new type (that newly needs to be described) for the different\n+// cases. The potential problem with recursive types is that the DI generation algorithm get trapped\n+// in an endless loop. To make sure, we actually test this in the different cases, we have to\n+// operate on a new type each time, otherwise we would just hit the DI cache for all but the first\n+// case.\n+\n+// The different cases below (stack_*, unique_*, box_*, etc) are set up so that the type description\n+// algorithm will enter the type reference cycle that is created by a recursive definition from a\n+// different context.\n+\n+// The \"long cycle\" cases are constructed to span a longer, indirect recursion cycle between types.\n+// The different locals will cause the DI algorithm to enter the type reference cycle at different\n+// points.\n+\n+fn main() {\n+    let stack_unique: UniqueNode<u16> = UniqueNode {\n+        next: Val {\n+            val: ~UniqueNode {\n+                next: Empty,\n+                value: 1_u16,\n+            }\n+        },\n+        value: 0_u16,\n+    };\n+\n+    let unique_unique: ~UniqueNode<u32> = ~UniqueNode {\n+        next: Val {\n+            val: ~UniqueNode {\n+                next: Empty,\n+                value: 3,\n+            }\n+        },\n+        value: 2,\n+    };\n+\n+    let box_unique: @UniqueNode<u64> = @UniqueNode {\n+        next: Val {\n+            val: ~UniqueNode {\n+                next: Empty,\n+                value: 5,\n+            }\n+        },\n+        value: 4,\n+    };\n+\n+    let vec_unique: [UniqueNode<f32>, ..1] = [UniqueNode {\n+        next: Val {\n+            val: ~UniqueNode {\n+                next: Empty,\n+                value: 7.5,\n+            }\n+        },\n+        value: 6.5,\n+    }];\n+\n+    let borrowed_unique: &UniqueNode<f64> = &UniqueNode {\n+        next: Val {\n+            val: ~UniqueNode {\n+                next: Empty,\n+                value: 9.5,\n+            }\n+        },\n+        value: 8.5,\n+    };\n+\n+    let stack_managed: ManagedNode<u16> = ManagedNode {\n+        next: Val {\n+            val: @ManagedNode {\n+                next: Empty,\n+                value: 11,\n+            }\n+        },\n+        value: 10,\n+    };\n+\n+    let unique_managed: ~ManagedNode<u32> = ~ManagedNode {\n+        next: Val {\n+            val: @ManagedNode {\n+                next: Empty,\n+                value: 13,\n+            }\n+        },\n+        value: 12,\n+    };\n+\n+    let box_managed: @ManagedNode<u64> = @ManagedNode {\n+        next: Val {\n+            val: @ManagedNode {\n+                next: Empty,\n+                value: 15,\n+            }\n+        },\n+        value: 14,\n+    };\n+\n+    let vec_managed: [ManagedNode<f32>, ..1] = [ManagedNode {\n+        next: Val {\n+            val: @ManagedNode {\n+                next: Empty,\n+                value: 17.5,\n+            }\n+        },\n+        value: 16.5,\n+    }];\n+\n+    let borrowed_managed: &ManagedNode<f64> = &ManagedNode {\n+        next: Val {\n+            val: @ManagedNode {\n+                next: Empty,\n+                value: 19.5,\n+            }\n+        },\n+        value: 18.5,\n+    };\n+\n+    // LONG CYCLE\n+    let long_cycle1: LongCycle1<u16> = LongCycle1 {\n+        next: ~LongCycle2 {\n+            next: ~LongCycle3 {\n+                next: ~LongCycle4 {\n+                    next: None,\n+                    value: 23,\n+                },\n+                value: 22,\n+            },\n+            value: 21\n+        },\n+        value: 20\n+    };\n+\n+    let long_cycle2: LongCycle2<u32> = LongCycle2 {\n+        next: ~LongCycle3 {\n+            next: ~LongCycle4 {\n+                next: None,\n+                value: 26,\n+            },\n+            value: 25,\n+        },\n+        value: 24\n+    };\n+\n+    let long_cycle3: LongCycle3<u64> = LongCycle3 {\n+        next: ~LongCycle4 {\n+            next: None,\n+            value: 28,\n+        },\n+        value: 27,\n+    };\n+\n+    let long_cycle4: LongCycle4<f32> = LongCycle4 {\n+        next: None,\n+        value: 29.5,\n+    };\n+\n+    // It's important that LongCycleWithAnonymousTypes is encountered only at the end of the\n+    // `~` chain.\n+    let long_cycle_w_anonymous_types = ~~~~~LongCycleWithAnonymousTypes {\n+        next: Val {\n+            val: ~~~~~LongCycleWithAnonymousTypes {\n+                next: Empty,\n+                value: 31,\n+            }\n+        },\n+        value: 30\n+    };\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n+"}, {"sha": "1a5e3505511b2cf1fe9161dd439edb3f343e7fe3", "filename": "src/test/debug-info/trait-pointers.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ce02e71448548d779413860632e07646cbc96b3/src%2Ftest%2Fdebug-info%2Ftrait-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce02e71448548d779413860632e07646cbc96b3/src%2Ftest%2Fdebug-info%2Ftrait-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ftrait-pointers.rs?ref=1ce02e71448548d779413860632e07646cbc96b3", "patch": "@@ -24,6 +24,7 @@ struct Struct {\n \n impl Trait for Struct {}\n \n+// There is no real test here yet. Just make that it compiles without crashing.\n fn main() {\n     let stack_struct = Struct { a:0, b: 1.0 };\n     let reference: &Trait = &stack_struct as &Trait;"}]}