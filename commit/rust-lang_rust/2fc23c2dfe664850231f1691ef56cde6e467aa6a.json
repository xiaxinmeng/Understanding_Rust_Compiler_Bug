{"sha": "2fc23c2dfe664850231f1691ef56cde6e467aa6a", "node_id": "C_kwDOAAsO6NoAKDJmYzIzYzJkZmU2NjQ4NTAyMzFmMTY5MWVmNTZjZGU2ZTQ2N2FhNmE", "commit": {"author": {"name": "Beno\u00eet du Garreau", "email": "bdgdlm@outlook.com", "date": "2023-03-02T10:12:24Z"}, "committer": {"name": "Beno\u00eet du Garreau", "email": "bdgdlm@outlook.com", "date": "2023-03-02T10:12:24Z"}, "message": "Use weak linkage on Android", "tree": {"sha": "78918a2b88e9eb61231314aa60810e0c891dc31c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78918a2b88e9eb61231314aa60810e0c891dc31c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fc23c2dfe664850231f1691ef56cde6e467aa6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fc23c2dfe664850231f1691ef56cde6e467aa6a", "html_url": "https://github.com/rust-lang/rust/commit/2fc23c2dfe664850231f1691ef56cde6e467aa6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fc23c2dfe664850231f1691ef56cde6e467aa6a/comments", "author": {"login": "a1phyr", "id": 47725341, "node_id": "MDQ6VXNlcjQ3NzI1MzQx", "avatar_url": "https://avatars.githubusercontent.com/u/47725341?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a1phyr", "html_url": "https://github.com/a1phyr", "followers_url": "https://api.github.com/users/a1phyr/followers", "following_url": "https://api.github.com/users/a1phyr/following{/other_user}", "gists_url": "https://api.github.com/users/a1phyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/a1phyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a1phyr/subscriptions", "organizations_url": "https://api.github.com/users/a1phyr/orgs", "repos_url": "https://api.github.com/users/a1phyr/repos", "events_url": "https://api.github.com/users/a1phyr/events{/privacy}", "received_events_url": "https://api.github.com/users/a1phyr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "a1phyr", "id": 47725341, "node_id": "MDQ6VXNlcjQ3NzI1MzQx", "avatar_url": "https://avatars.githubusercontent.com/u/47725341?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a1phyr", "html_url": "https://github.com/a1phyr", "followers_url": "https://api.github.com/users/a1phyr/followers", "following_url": "https://api.github.com/users/a1phyr/following{/other_user}", "gists_url": "https://api.github.com/users/a1phyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/a1phyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a1phyr/subscriptions", "organizations_url": "https://api.github.com/users/a1phyr/orgs", "repos_url": "https://api.github.com/users/a1phyr/repos", "events_url": "https://api.github.com/users/a1phyr/events{/privacy}", "received_events_url": "https://api.github.com/users/a1phyr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "351c154cb44d90b1db7e3c62aa6500e0fb472969", "url": "https://api.github.com/repos/rust-lang/rust/commits/351c154cb44d90b1db7e3c62aa6500e0fb472969", "html_url": "https://github.com/rust-lang/rust/commit/351c154cb44d90b1db7e3c62aa6500e0fb472969"}], "stats": {"total": 100, "additions": 96, "deletions": 4}, "files": [{"sha": "6bfeebd9965bc30337b63a773ab92083f996280b", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 96, "deletions": 4, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/2fc23c2dfe664850231f1691ef56cde6e467aa6a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc23c2dfe664850231f1691ef56cde6e467aa6a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=2fc23c2dfe664850231f1691ef56cde6e467aa6a", "patch": "@@ -148,7 +148,6 @@ impl FileDesc {\n     }\n \n     #[cfg(any(\n-        target_os = \"android\",\n         target_os = \"emscripten\",\n         target_os = \"freebsd\",\n         target_os = \"fuchsia\",\n@@ -171,7 +170,6 @@ impl FileDesc {\n     }\n \n     #[cfg(not(any(\n-        target_os = \"android\",\n         target_os = \"emscripten\",\n         target_os = \"freebsd\",\n         target_os = \"fuchsia\",\n@@ -185,6 +183,54 @@ impl FileDesc {\n         io::default_read_vectored(|b| self.read_at(b, offset), bufs)\n     }\n \n+    // We support some old Android versions that do not have `preadv` in libc,\n+    // so we use weak linkage and fallback to a direct syscall if not available.\n+    //\n+    // On 32-bit targets, we don't want to deal with weird ABI issues around\n+    // passing 64-bits parameters to syscalls, so we fallback to the default\n+    // implementation.\n+    #[cfg(all(target_os = \"android\", target_pointer_width = \"64\"))]\n+    pub fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n+        super::weak::syscall! {\n+            fn preadv(\n+                fd: libc::c_int,\n+                iovec: *const libc::iovec,\n+                n_iovec: libc::c_int,\n+                offset: off64_t\n+            ) -> isize\n+        }\n+\n+        let ret = cvt(unsafe {\n+            preadv(\n+                self.as_raw_fd(),\n+                bufs.as_mut_ptr() as *mut libc::iovec as *const libc::iovec,\n+                cmp::min(bufs.len(), max_iov()) as libc::c_int,\n+                offset as _,\n+            )\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    #[cfg(all(target_os = \"android\", target_pointer_width = \"32\"))]\n+    pub fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n+        super::weak::weak!(fn preadv64(libc::c_int, *const libc::iovec, libc::c_int, off64_t) -> isize);\n+\n+        match preadv64.get() {\n+            Some(preadv) => {\n+                let ret = cvt(unsafe {\n+                    preadv(\n+                        self.as_raw_fd(),\n+                        bufs.as_mut_ptr() as *mut libc::iovec as *const libc::iovec,\n+                        cmp::min(bufs.len(), max_iov()) as libc::c_int,\n+                        offset as _,\n+                    )\n+                })?;\n+                Ok(ret as usize)\n+            }\n+            None => io::default_read_vectored(|b| self.read_at(b, offset), bufs),\n+        }\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n             libc::write(\n@@ -236,7 +282,6 @@ impl FileDesc {\n     }\n \n     #[cfg(any(\n-        target_os = \"android\",\n         target_os = \"emscripten\",\n         target_os = \"freebsd\",\n         target_os = \"fuchsia\",\n@@ -259,7 +304,6 @@ impl FileDesc {\n     }\n \n     #[cfg(not(any(\n-        target_os = \"android\",\n         target_os = \"emscripten\",\n         target_os = \"freebsd\",\n         target_os = \"fuchsia\",\n@@ -273,6 +317,54 @@ impl FileDesc {\n         io::default_write_vectored(|b| self.write_at(b, offset), bufs)\n     }\n \n+    // We support some old Android versions that do not have `pwritev` in libc,\n+    // so we use weak linkage and fallback to a direct syscall if not available.\n+    //\n+    // On 32-bit targets, we don't want to deal with weird ABI issues around\n+    // passing 64-bits parameters to syscalls, so we fallback to the default\n+    // implementation.\n+    #[cfg(all(target_os = \"android\", target_pointer_width = \"64\"))]\n+    pub fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n+        super::weak::syscall! {\n+            fn pwritev(\n+                fd: libc::c_int,\n+                iovec: *const libc::iovec,\n+                n_iovec: libc::c_int,\n+                offset: off64_t\n+            ) -> isize\n+        }\n+\n+        let ret = cvt(unsafe {\n+            pwritev(\n+                self.as_raw_fd(),\n+                bufs.as_ptr() as *const libc::iovec,\n+                cmp::min(bufs.len(), max_iov()) as libc::c_int,\n+                offset as _,\n+            )\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    #[cfg(all(target_os = \"android\", target_pointer_width = \"32\"))]\n+    pub fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n+        super::weak::weak!(fn pwritev64(libc::c_int, *const libc::iovec, libc::c_int, off64_t) -> isize);\n+\n+        match pwritev64.get() {\n+            Some(pwritev) => {\n+                let ret = cvt(unsafe {\n+                    pwritev(\n+                        self.as_raw_fd(),\n+                        bufs.as_ptr() as *const libc::iovec,\n+                        cmp::min(bufs.len(), max_iov()) as libc::c_int,\n+                        offset as _,\n+                    )\n+                })?;\n+                Ok(ret as usize)\n+            }\n+            None => io::default_write_vectored(|b| self.write_at(b, offset), bufs),\n+        }\n+    }\n+\n     #[cfg(not(any(\n         target_env = \"newlib\",\n         target_os = \"solaris\","}]}