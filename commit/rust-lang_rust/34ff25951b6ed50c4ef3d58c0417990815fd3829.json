{"sha": "34ff25951b6ed50c4ef3d58c0417990815fd3829", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0ZmYyNTk1MWI2ZWQ1MGM0ZWYzZDU4YzA0MTc5OTA4MTVmZDM4Mjk=", "commit": {"author": {"name": "Paul Trojahn", "email": "paul.trojahn@gmail.com", "date": "2021-05-19T16:40:47Z"}, "committer": {"name": "Paul Trojahn", "email": "paul.trojahn@gmail.com", "date": "2021-07-07T16:33:50Z"}, "message": "Add help on reinitialization between move and access\n\nFixes #83760", "tree": {"sha": "d89c816222237d19d07f844194aee3db439efbec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d89c816222237d19d07f844194aee3db439efbec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34ff25951b6ed50c4ef3d58c0417990815fd3829", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34ff25951b6ed50c4ef3d58c0417990815fd3829", "html_url": "https://github.com/rust-lang/rust/commit/34ff25951b6ed50c4ef3d58c0417990815fd3829", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34ff25951b6ed50c4ef3d58c0417990815fd3829/comments", "author": {"login": "ptrojahn", "id": 45311997, "node_id": "MDQ6VXNlcjQ1MzExOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/45311997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptrojahn", "html_url": "https://github.com/ptrojahn", "followers_url": "https://api.github.com/users/ptrojahn/followers", "following_url": "https://api.github.com/users/ptrojahn/following{/other_user}", "gists_url": "https://api.github.com/users/ptrojahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptrojahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptrojahn/subscriptions", "organizations_url": "https://api.github.com/users/ptrojahn/orgs", "repos_url": "https://api.github.com/users/ptrojahn/repos", "events_url": "https://api.github.com/users/ptrojahn/events{/privacy}", "received_events_url": "https://api.github.com/users/ptrojahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ptrojahn", "id": 45311997, "node_id": "MDQ6VXNlcjQ1MzExOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/45311997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptrojahn", "html_url": "https://github.com/ptrojahn", "followers_url": "https://api.github.com/users/ptrojahn/followers", "following_url": "https://api.github.com/users/ptrojahn/following{/other_user}", "gists_url": "https://api.github.com/users/ptrojahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptrojahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptrojahn/subscriptions", "organizations_url": "https://api.github.com/users/ptrojahn/orgs", "repos_url": "https://api.github.com/users/ptrojahn/repos", "events_url": "https://api.github.com/users/ptrojahn/events{/privacy}", "received_events_url": "https://api.github.com/users/ptrojahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5e344f7747dbd7e7d4b209e3c480deb5979a56f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5e344f7747dbd7e7d4b209e3c480deb5979a56f", "html_url": "https://github.com/rust-lang/rust/commit/c5e344f7747dbd7e7d4b209e3c480deb5979a56f"}], "stats": {"total": 194, "additions": 176, "deletions": 18}, "files": [{"sha": "2e854ea5be7df7046321a33dde452c5a84a38d30", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 74, "deletions": 18, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/34ff25951b6ed50c4ef3d58c0417990815fd3829/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ff25951b6ed50c4ef3d58c0417990815fd3829/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=34ff25951b6ed50c4ef3d58c0417990815fd3829", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::mir::{\n use rustc_middle::ty::{self, suggest_constraining_type_param, Ty};\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::sym;\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt;\n \n use crate::dataflow::drop_flag_effects;\n@@ -66,7 +66,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             self.move_spans(moved_place, location).or_else(|| self.borrow_spans(span, location));\n         let span = use_spans.args_or_use();\n \n-        let move_site_vec = self.get_moved_indexes(location, mpi);\n+        let (move_site_vec, maybe_reinitialized_locations) = self.get_moved_indexes(location, mpi);\n         debug!(\n             \"report_use_of_moved_or_uninitialized: move_site_vec={:?} use_spans={:?}\",\n             move_site_vec, use_spans\n@@ -139,6 +139,32 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 self.describe_place_with_options(moved_place, IncludingDowncast(true)),\n             );\n \n+            let reinit_spans = maybe_reinitialized_locations\n+                .iter()\n+                .take(3)\n+                .map(|loc| {\n+                    self.move_spans(self.move_data.move_paths[mpi].place.as_ref(), *loc)\n+                        .args_or_use()\n+                })\n+                .collect::<Vec<Span>>();\n+            let reinits = maybe_reinitialized_locations.len();\n+            if reinits == 1 {\n+                err.span_label(reinit_spans[0], \"this reinitialization might get skipped\");\n+            } else if reinits > 1 {\n+                err.span_note(\n+                    MultiSpan::from_spans(reinit_spans),\n+                    &if reinits <= 3 {\n+                        format!(\"these {} reinitializations might get skipped\", reinits)\n+                    } else {\n+                        format!(\n+                            \"these 3 reinitializations and {} other{} might get skipped\",\n+                            reinits - 3,\n+                            if reinits == 4 { \"\" } else { \"s\" }\n+                        )\n+                    },\n+                );\n+            }\n+\n             self.add_moved_or_invoked_closure_note(location, used_place, &mut err);\n \n             let mut is_loop_move = false;\n@@ -219,7 +245,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     ),\n                                 );\n                             }\n-                            if is_option_or_result {\n+                            if is_option_or_result && maybe_reinitialized_locations.is_empty() {\n                                 err.span_suggestion_verbose(\n                                     fn_call_span.shrink_to_lo(),\n                                     \"consider calling `.as_ref()` to borrow the type's contents\",\n@@ -260,19 +286,23 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     }\n                 }\n \n-                if let UseSpans::PatUse(span) = move_spans {\n-                    err.span_suggestion_verbose(\n-                        span.shrink_to_lo(),\n-                        &format!(\n-                            \"borrow this field in the pattern to avoid moving {}\",\n-                            self.describe_place(moved_place.as_ref())\n-                                .map(|n| format!(\"`{}`\", n))\n-                                .unwrap_or_else(|| \"the value\".to_string())\n-                        ),\n-                        \"ref \".to_string(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                    in_pattern = true;\n+                if let (UseSpans::PatUse(span), []) =\n+                    (move_spans, &maybe_reinitialized_locations[..])\n+                {\n+                    if maybe_reinitialized_locations.is_empty() {\n+                        err.span_suggestion_verbose(\n+                            span.shrink_to_lo(),\n+                            &format!(\n+                                \"borrow this field in the pattern to avoid moving {}\",\n+                                self.describe_place(moved_place.as_ref())\n+                                    .map(|n| format!(\"`{}`\", n))\n+                                    .unwrap_or_else(|| \"the value\".to_string())\n+                            ),\n+                            \"ref \".to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        in_pattern = true;\n+                    }\n                 }\n \n                 if let Some(DesugaringKind::ForLoop(_)) = move_span.desugaring_kind() {\n@@ -1465,7 +1495,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    fn get_moved_indexes(&mut self, location: Location, mpi: MovePathIndex) -> Vec<MoveSite> {\n+    fn get_moved_indexes(\n+        &mut self,\n+        location: Location,\n+        mpi: MovePathIndex,\n+    ) -> (Vec<MoveSite>, Vec<Location>) {\n         fn predecessor_locations(\n             body: &'a mir::Body<'tcx>,\n             location: Location,\n@@ -1488,6 +1522,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }));\n \n         let mut visited = FxHashSet::default();\n+        let mut move_locations = FxHashSet::default();\n+        let mut reinits = vec![];\n         let mut result = vec![];\n \n         'dfs: while let Some((location, is_back_edge)) = stack.pop() {\n@@ -1529,6 +1565,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             move_paths[path].place\n                         );\n                         result.push(MoveSite { moi: *moi, traversed_back_edge: is_back_edge });\n+                        move_locations.insert(location);\n \n                         // Strictly speaking, we could continue our DFS here. There may be\n                         // other moves that can reach the point of error. But it is kind of\n@@ -1565,6 +1602,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 },\n             );\n             if any_match {\n+                reinits.push(location);\n                 continue 'dfs;\n             }\n \n@@ -1574,7 +1612,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }));\n         }\n \n-        result\n+        // Check if we can reach these reinits from a move location.\n+        let reinits_reachable = reinits\n+            .into_iter()\n+            .filter(|reinit| {\n+                let mut visited = FxHashSet::default();\n+                let mut stack = vec![*reinit];\n+                while let Some(location) = stack.pop() {\n+                    if !visited.insert(location) {\n+                        continue;\n+                    }\n+                    if move_locations.contains(&location) {\n+                        return true;\n+                    }\n+                    stack.extend(predecessor_locations(self.body, location));\n+                }\n+                false\n+            })\n+            .collect::<Vec<Location>>();\n+        (result, reinits_reachable)\n     }\n \n     pub(in crate::borrow_check) fn report_illegal_mutation_of_borrowed("}, {"sha": "e25b4f727856e54d39b84003a663b025947692d2", "filename": "src/test/ui/borrowck/issue-83760.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/34ff25951b6ed50c4ef3d58c0417990815fd3829/src%2Ftest%2Fui%2Fborrowck%2Fissue-83760.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ff25951b6ed50c4ef3d58c0417990815fd3829/src%2Ftest%2Fui%2Fborrowck%2Fissue-83760.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-83760.rs?ref=34ff25951b6ed50c4ef3d58c0417990815fd3829", "patch": "@@ -0,0 +1,40 @@\n+struct Struct;\n+\n+fn test1() {\n+    let mut val = Some(Struct);\n+    while let Some(foo) = val { //~ ERROR use of moved value\n+        if true {\n+            val = None;\n+        } else {\n+\n+        }\n+    }\n+}\n+\n+fn test2() {\n+    let mut foo = Some(Struct);\n+    let _x = foo.unwrap();\n+    if true {\n+        foo = Some(Struct);\n+    } else {\n+    }\n+    let _y = foo; //~ ERROR use of moved value: `foo`\n+}\n+\n+fn test3() {\n+    let mut foo = Some(Struct);\n+    let _x = foo.unwrap();\n+    if true {\n+        foo = Some(Struct);\n+    } else if true {\n+        foo = Some(Struct);\n+    } else if true {\n+        foo = Some(Struct);\n+    } else if true {\n+        foo = Some(Struct);\n+    } else {\n+    }\n+    let _y = foo; //~ ERROR use of moved value: `foo`\n+}\n+\n+fn main() {}"}, {"sha": "beeda5685dc093a25e4a7ce1b81ad5a43e457091", "filename": "src/test/ui/borrowck/issue-83760.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/34ff25951b6ed50c4ef3d58c0417990815fd3829/src%2Ftest%2Fui%2Fborrowck%2Fissue-83760.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34ff25951b6ed50c4ef3d58c0417990815fd3829/src%2Ftest%2Fui%2Fborrowck%2Fissue-83760.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-83760.stderr?ref=34ff25951b6ed50c4ef3d58c0417990815fd3829", "patch": "@@ -0,0 +1,62 @@\n+error[E0382]: use of moved value\n+  --> $DIR/issue-83760.rs:5:20\n+   |\n+LL |     while let Some(foo) = val {\n+   |                    ^^^ value moved here, in previous iteration of loop\n+LL |         if true {\n+LL |             val = None;\n+   |             ---------- this reinitialization might get skipped\n+   |\n+   = note: move occurs because value has type `Struct`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `foo`\n+  --> $DIR/issue-83760.rs:21:14\n+   |\n+LL |     let mut foo = Some(Struct);\n+   |         ------- move occurs because `foo` has type `Option<Struct>`, which does not implement the `Copy` trait\n+LL |     let _x = foo.unwrap();\n+   |                  -------- `foo` moved due to this method call\n+LL |     if true {\n+LL |         foo = Some(Struct);\n+   |         ------------------ this reinitialization might get skipped\n+...\n+LL |     let _y = foo;\n+   |              ^^^ value used here after move\n+   |\n+note: this function takes ownership of the receiver `self`, which moves `foo`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+   |\n+LL |     pub const fn unwrap(self) -> T {\n+   |                         ^^^^\n+\n+error[E0382]: use of moved value: `foo`\n+  --> $DIR/issue-83760.rs:37:14\n+   |\n+LL |     let mut foo = Some(Struct);\n+   |         ------- move occurs because `foo` has type `Option<Struct>`, which does not implement the `Copy` trait\n+LL |     let _x = foo.unwrap();\n+   |                  -------- `foo` moved due to this method call\n+...\n+LL |     let _y = foo;\n+   |              ^^^ value used here after move\n+   |\n+note: these 3 reinitializations and 1 other might get skipped\n+  --> $DIR/issue-83760.rs:30:9\n+   |\n+LL |         foo = Some(Struct);\n+   |         ^^^^^^^^^^^^^^^^^^\n+LL |     } else if true {\n+LL |         foo = Some(Struct);\n+   |         ^^^^^^^^^^^^^^^^^^\n+LL |     } else if true {\n+LL |         foo = Some(Struct);\n+   |         ^^^^^^^^^^^^^^^^^^\n+note: this function takes ownership of the receiver `self`, which moves `foo`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+   |\n+LL |     pub const fn unwrap(self) -> T {\n+   |                         ^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}]}