{"sha": "000f87ab1eb13b1e743bcb614b8d59463f2efd04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwMGY4N2FiMWViMTNiMWU3NDNiY2I2MTRiOGQ1OTQ2M2YyZWZkMDQ=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-07-28T22:13:40Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-08-18T23:14:53Z"}, "message": "Desugar parenthesized generic arguments in HIR", "tree": {"sha": "915ce13dfaa72a62895379961ea3e873ce00b149", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/915ce13dfaa72a62895379961ea3e873ce00b149"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/000f87ab1eb13b1e743bcb614b8d59463f2efd04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/000f87ab1eb13b1e743bcb614b8d59463f2efd04", "html_url": "https://github.com/rust-lang/rust/commit/000f87ab1eb13b1e743bcb614b8d59463f2efd04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/000f87ab1eb13b1e743bcb614b8d59463f2efd04/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "230a379a452e5a2bcdfd0a956b259e0a1d83b512", "url": "https://api.github.com/repos/rust-lang/rust/commits/230a379a452e5a2bcdfd0a956b259e0a1d83b512", "html_url": "https://github.com/rust-lang/rust/commit/230a379a452e5a2bcdfd0a956b259e0a1d83b512"}], "stats": {"total": 702, "additions": 264, "deletions": 438}, "files": [{"sha": "412759e11423e94ed22176988b06ba484b1833e7", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=000f87ab1eb13b1e743bcb614b8d59463f2efd04", "patch": "@@ -687,6 +687,21 @@ attributes:\n See also https://doc.rust-lang.org/book/first-edition/no-stdlib.html\n \"##,\n \n+E0214: r##\"\n+A generic type was described using parentheses rather than angle brackets. For\n+example:\n+\n+```compile_fail,E0214\n+fn main() {\n+    let v: Vec(&str) = vec![\"foo\"];\n+}\n+```\n+\n+This is not currently supported: `v` should be defined as `Vec<&str>`.\n+Parentheses are currently only used with generic types when defining parameters\n+for `Fn`-family traits.\n+\"##,\n+\n E0261: r##\"\n When using a lifetime like `'a` in a type, it must be declared before being\n used."}, {"sha": "483885b3d23f6573cd928e7bf88b9a2b69c9a403", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=000f87ab1eb13b1e743bcb614b8d59463f2efd04", "patch": "@@ -617,17 +617,9 @@ pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                 _path_span: Span,\n                                                 path_parameters: &'v PathParameters) {\n-    match *path_parameters {\n-        AngleBracketedParameters(ref data) => {\n-            walk_list!(visitor, visit_ty, &data.types);\n-            walk_list!(visitor, visit_lifetime, &data.lifetimes);\n-            walk_list!(visitor, visit_assoc_type_binding, &data.bindings);\n-        }\n-        ParenthesizedParameters(ref data) => {\n-            walk_list!(visitor, visit_ty, &data.inputs);\n-            walk_list!(visitor, visit_ty, &data.output);\n-        }\n-    }\n+    walk_list!(visitor, visit_lifetime, &path_parameters.lifetimes);\n+    walk_list!(visitor, visit_ty, &path_parameters.types);\n+    walk_list!(visitor, visit_assoc_type_binding, &path_parameters.bindings);\n }\n \n pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,"}, {"sha": "89ce52af77cb969c1d81aa3b29368996ada676d9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 73, "deletions": 25, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=000f87ab1eb13b1e743bcb614b8d59463f2efd04", "patch": "@@ -45,15 +45,16 @@ use hir::map::{Definitions, DefKey, REGULAR_SPACE};\n use hir::map::definitions::DefPathData;\n use hir::def_id::{DefIndex, DefId, CRATE_DEF_INDEX};\n use hir::def::{Def, PathResolution};\n+use lint::builtin::PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES;\n use rustc_data_structures::indexed_vec::IndexVec;\n use session::Session;\n+use util::common::FN_OUTPUT_NAME;\n use util::nodemap::{DefIdMap, FxHashMap, NodeMap};\n \n use std::collections::BTreeMap;\n use std::fmt::Debug;\n use std::iter;\n use std::mem;\n-\n use syntax::attr;\n use syntax::ast::*;\n use syntax::errors;\n@@ -160,6 +161,12 @@ struct LoweredNodeId {\n     hir_id: hir::HirId,\n }\n \n+enum ParenthesizedGenericArgs {\n+    Ok,\n+    Warn,\n+    Err,\n+}\n+\n impl<'a> LoweringContext<'a> {\n     fn lower_crate(mut self, c: &Crate) -> hir::Crate {\n         /// Full-crate AST visitor that inserts into a fresh\n@@ -749,6 +756,21 @@ impl<'a> LoweringContext<'a> {\n                     Def::Trait(def_id) if i + 1 == proj_start => Some(def_id),\n                     _ => None\n                 };\n+                let parenthesized_generic_args = match resolution.base_def() {\n+                    // `a::b::Trait(Args)`\n+                    Def::Trait(..) if i + 1 == proj_start => ParenthesizedGenericArgs::Ok,\n+                    // `a::b::Trait(Args)::TraitItem`\n+                    Def::Method(..) |\n+                    Def::AssociatedConst(..) |\n+                    Def::AssociatedTy(..) if i + 2 == proj_start => ParenthesizedGenericArgs::Ok,\n+                    // Avoid duplicated errors\n+                    Def::Err => ParenthesizedGenericArgs::Ok,\n+                    // An error\n+                    Def::Struct(..) | Def::Enum(..) | Def::Union(..) | Def::TyAlias(..) |\n+                    Def::Variant(..) if i + 1 == proj_start => ParenthesizedGenericArgs::Err,\n+                    // A warning for now, for compatibility reasons\n+                    _ => ParenthesizedGenericArgs::Warn,\n+                };\n \n                 let num_lifetimes = type_def_id.map_or(0, |def_id| {\n                     if let Some(&n) = self.type_def_lifetime_params.get(&def_id) {\n@@ -759,7 +781,8 @@ impl<'a> LoweringContext<'a> {\n                     self.type_def_lifetime_params.insert(def_id, n);\n                     n\n                 });\n-                self.lower_path_segment(p.span, segment, param_mode, num_lifetimes)\n+                self.lower_path_segment(p.span, segment, param_mode, num_lifetimes,\n+                                        parenthesized_generic_args)\n             }).collect(),\n             span: p.span,\n         });\n@@ -794,7 +817,8 @@ impl<'a> LoweringContext<'a> {\n         //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n         // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n         for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n-            let segment = P(self.lower_path_segment(p.span, segment, param_mode, 0));\n+            let segment = P(self.lower_path_segment(p.span, segment, param_mode, 0,\n+                                                    ParenthesizedGenericArgs::Warn));\n             let qpath = hir::QPath::TypeRelative(ty, segment);\n \n             // It's finished, return the extension of the right node type.\n@@ -827,7 +851,8 @@ impl<'a> LoweringContext<'a> {\n         hir::Path {\n             def: self.expect_full_def(id),\n             segments: segments.map(|segment| {\n-                self.lower_path_segment(p.span, segment, param_mode, 0)\n+                self.lower_path_segment(p.span, segment, param_mode, 0,\n+                                        ParenthesizedGenericArgs::Err)\n             }).chain(name.map(|name| {\n                 hir::PathSegment {\n                     name,\n@@ -851,29 +876,37 @@ impl<'a> LoweringContext<'a> {\n                           path_span: Span,\n                           segment: &PathSegment,\n                           param_mode: ParamMode,\n-                          expected_lifetimes: usize)\n+                          expected_lifetimes: usize,\n+                          parenthesized_generic_args: ParenthesizedGenericArgs)\n                           -> hir::PathSegment {\n         let mut parameters = if let Some(ref parameters) = segment.parameters {\n+            let msg = \"parenthesized parameters may only be used with a trait\";\n             match **parameters {\n                 PathParameters::AngleBracketed(ref data) => {\n-                    let data = self.lower_angle_bracketed_parameter_data(data, param_mode);\n-                    hir::AngleBracketedParameters(data)\n+                    self.lower_angle_bracketed_parameter_data(data, param_mode)\n                 }\n-                PathParameters::Parenthesized(ref data) => {\n-                    hir::ParenthesizedParameters(self.lower_parenthesized_parameter_data(data))\n+                PathParameters::Parenthesized(ref data) => match parenthesized_generic_args {\n+                    ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n+                    ParenthesizedGenericArgs::Warn => {\n+                        self.sess.buffer_lint(PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n+                                              CRATE_NODE_ID, data.span, msg.into());\n+                        hir::PathParameters::none()\n+                    }\n+                    ParenthesizedGenericArgs::Err => {\n+                        struct_span_err!(self.sess, data.span, E0214, \"{}\", msg)\n+                            .span_label(data.span, \"only traits may use parentheses\").emit();\n+                        hir::PathParameters::none()\n+                    }\n                 }\n             }\n         } else {\n-            let data = self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode);\n-            hir::AngleBracketedParameters(data)\n+            self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode)\n         };\n \n-        if let hir::AngleBracketedParameters(ref mut data) = parameters {\n-            if data.lifetimes.is_empty() {\n-                data.lifetimes = (0..expected_lifetimes).map(|_| {\n-                    self.elided_lifetime(path_span)\n-                }).collect();\n-            }\n+        if !parameters.parenthesized && parameters.lifetimes.is_empty() {\n+            parameters.lifetimes = (0..expected_lifetimes).map(|_| {\n+                self.elided_lifetime(path_span)\n+            }).collect();\n         }\n \n         hir::PathSegment {\n@@ -885,24 +918,38 @@ impl<'a> LoweringContext<'a> {\n     fn lower_angle_bracketed_parameter_data(&mut self,\n                                             data: &AngleBracketedParameterData,\n                                             param_mode: ParamMode)\n-                                            -> hir::AngleBracketedParameterData {\n+                                            -> hir::PathParameters {\n         let &AngleBracketedParameterData { ref lifetimes, ref types, ref bindings, .. } = data;\n-        hir::AngleBracketedParameterData {\n+        hir::PathParameters {\n             lifetimes: self.lower_lifetimes(lifetimes),\n             types: types.iter().map(|ty| self.lower_ty(ty)).collect(),\n             infer_types: types.is_empty() && param_mode == ParamMode::Optional,\n             bindings: bindings.iter().map(|b| self.lower_ty_binding(b)).collect(),\n+            parenthesized: false,\n         }\n     }\n \n     fn lower_parenthesized_parameter_data(&mut self,\n                                           data: &ParenthesizedParameterData)\n-                                          -> hir::ParenthesizedParameterData {\n+                                          -> hir::PathParameters {\n         let &ParenthesizedParameterData { ref inputs, ref output, span } = data;\n-        hir::ParenthesizedParameterData {\n-            inputs: inputs.iter().map(|ty| self.lower_ty(ty)).collect(),\n-            output: output.as_ref().map(|ty| self.lower_ty(ty)),\n-            span,\n+        let inputs = inputs.iter().map(|ty| self.lower_ty(ty)).collect();\n+        let mk_tup = |this: &mut Self, tys, span| {\n+            P(hir::Ty { node: hir::TyTup(tys), id: this.next_id().node_id, span })\n+        };\n+\n+        hir::PathParameters {\n+            lifetimes: hir::HirVec::new(),\n+            types: hir_vec![mk_tup(self, inputs, span)],\n+            infer_types: false,\n+            bindings: hir_vec![hir::TypeBinding {\n+                id: self.next_id().node_id,\n+                name: Symbol::intern(FN_OUTPUT_NAME),\n+                ty: output.as_ref().map(|ty| self.lower_ty(&ty))\n+                                   .unwrap_or_else(|| mk_tup(self, hir::HirVec::new(), span)),\n+                span: output.as_ref().map_or(span, |ty| ty.span),\n+            }],\n+            parenthesized: true,\n         }\n     }\n \n@@ -1877,7 +1924,8 @@ impl<'a> LoweringContext<'a> {\n                 hir::ExprCall(f, args.iter().map(|x| self.lower_expr(x)).collect())\n             }\n             ExprKind::MethodCall(ref seg, ref args) => {\n-                let hir_seg = self.lower_path_segment(e.span, seg, ParamMode::Optional, 0);\n+                let hir_seg = self.lower_path_segment(e.span, seg, ParamMode::Optional, 0,\n+                                                      ParenthesizedGenericArgs::Err);\n                 let args = args.iter().map(|x| self.lower_expr(x)).collect();\n                 hir::ExprMethodCall(hir_seg, seg.span, args)\n             }"}, {"sha": "01f5d268815f06484ff225af1b7775306768222d", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 25, "deletions": 70, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=000f87ab1eb13b1e743bcb614b8d59463f2efd04", "patch": "@@ -26,7 +26,6 @@ pub use self::TyParamBound::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n pub use self::Visibility::{Public, Inherited};\n-pub use self::PathParameters::*;\n \n use hir::def::Def;\n use hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n@@ -227,65 +226,7 @@ impl PathSegment {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum PathParameters {\n-    /// The `<'a, A,B,C>` in `foo::bar::baz::<'a, A,B,C>`\n-    AngleBracketedParameters(AngleBracketedParameterData),\n-    /// The `(A,B)` and `C` in `Foo(A,B) -> C`\n-    ParenthesizedParameters(ParenthesizedParameterData),\n-}\n-\n-impl PathParameters {\n-    pub fn none() -> PathParameters {\n-        AngleBracketedParameters(AngleBracketedParameterData {\n-            lifetimes: HirVec::new(),\n-            types: HirVec::new(),\n-            infer_types: true,\n-            bindings: HirVec::new(),\n-        })\n-    }\n-\n-    /// Returns the types that the user wrote. Note that these do not necessarily map to the type\n-    /// parameters in the parenthesized case.\n-    pub fn types(&self) -> HirVec<&P<Ty>> {\n-        match *self {\n-            AngleBracketedParameters(ref data) => {\n-                data.types.iter().collect()\n-            }\n-            ParenthesizedParameters(ref data) => {\n-                data.inputs\n-                    .iter()\n-                    .chain(data.output.iter())\n-                    .collect()\n-            }\n-        }\n-    }\n-\n-    pub fn lifetimes(&self) -> HirVec<&Lifetime> {\n-        match *self {\n-            AngleBracketedParameters(ref data) => {\n-                data.lifetimes.iter().collect()\n-            }\n-            ParenthesizedParameters(_) => {\n-                HirVec::new()\n-            }\n-        }\n-    }\n-\n-    pub fn bindings(&self) -> HirVec<&TypeBinding> {\n-        match *self {\n-            AngleBracketedParameters(ref data) => {\n-                data.bindings.iter().collect()\n-            }\n-            ParenthesizedParameters(_) => {\n-                HirVec::new()\n-            }\n-        }\n-    }\n-}\n-\n-/// A path like `Foo<'a, T>`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct AngleBracketedParameterData {\n+pub struct PathParameters {\n     /// The lifetime parameters for this path segment.\n     pub lifetimes: HirVec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n@@ -298,19 +239,33 @@ pub struct AngleBracketedParameterData {\n     /// Bindings (equality constraints) on associated types, if present.\n     /// E.g., `Foo<A=Bar>`.\n     pub bindings: HirVec<TypeBinding>,\n+    /// Were parameters written in parenthesized form `Fn(T) -> U`?\n+    /// This is required mostly for pretty-printing and diagnostics,\n+    /// but also for changing lifetime elision rules to be \"function-like\".\n+    pub parenthesized: bool,\n }\n \n-/// A path like `Foo(A,B) -> C`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct ParenthesizedParameterData {\n-    /// Overall span\n-    pub span: Span,\n-\n-    /// `(A,B)`\n-    pub inputs: HirVec<P<Ty>>,\n+impl PathParameters {\n+    pub fn none() -> Self {\n+        Self {\n+            lifetimes: HirVec::new(),\n+            types: HirVec::new(),\n+            infer_types: true,\n+            bindings: HirVec::new(),\n+            parenthesized: false,\n+        }\n+    }\n \n-    /// `C`\n-    pub output: Option<P<Ty>>,\n+    pub fn inputs(&self) -> &[P<Ty>] {\n+        if self.parenthesized {\n+            if let Some(ref ty) = self.types.get(0) {\n+                if let TyTup(ref tys) = ty.node {\n+                    return tys;\n+                }\n+            }\n+        }\n+        bug!(\"PathParameters::inputs: not a `Fn(T) -> U`\");\n+    }\n }\n \n /// The AST represents all type param bounds as types."}, {"sha": "876875bce4a5e54cc550dfb35507482020f7b537", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 42, "deletions": 48, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=000f87ab1eb13b1e743bcb614b8d59463f2efd04", "patch": "@@ -1194,9 +1194,9 @@ impl<'a> State<'a> {\n         self.print_expr(&args[0])?;\n         self.s.word(\".\")?;\n         self.print_name(segment.name)?;\n-        if !segment.parameters.lifetimes().is_empty() ||\n-                !segment.parameters.types().is_empty() ||\n-                !segment.parameters.bindings().is_empty() {\n+        if !segment.parameters.lifetimes.is_empty() ||\n+                !segment.parameters.types.is_empty() ||\n+                !segment.parameters.bindings.is_empty() {\n             self.print_path_parameters(&segment.parameters, true)?;\n         }\n         self.print_call_post(base_args)\n@@ -1581,61 +1581,55 @@ impl<'a> State<'a> {\n                              parameters: &hir::PathParameters,\n                              colons_before_params: bool)\n                              -> io::Result<()> {\n-        match *parameters {\n-            hir::AngleBracketedParameters(ref data) => {\n-                let start = if colons_before_params { \"::<\" } else { \"<\" };\n-                let empty = Cell::new(true);\n-                let start_or_comma = |this: &mut Self| {\n-                    if empty.get() {\n-                        empty.set(false);\n-                        this.s.word(start)\n-                    } else {\n-                        this.word_space(\",\")\n-                    }\n-                };\n+        if parameters.parenthesized {\n+            self.s.word(\"(\")?;\n+            self.commasep(Inconsistent, parameters.inputs(), |s, ty| s.print_type(&ty))?;\n+            self.s.word(\")\")?;\n \n-                if !data.lifetimes.iter().all(|lt| lt.is_elided()) {\n-                    for lifetime in &data.lifetimes {\n-                        start_or_comma(self)?;\n-                        self.print_lifetime(lifetime)?;\n-                    }\n-                }\n-\n-                if !data.types.is_empty() {\n-                    start_or_comma(self)?;\n-                    self.commasep(Inconsistent, &data.types, |s, ty| s.print_type(&ty))?;\n+            self.space_if_not_bol()?;\n+            self.word_space(\"->\")?;\n+            self.print_type(&parameters.bindings[0].ty)?;\n+        } else {\n+            let start = if colons_before_params { \"::<\" } else { \"<\" };\n+            let empty = Cell::new(true);\n+            let start_or_comma = |this: &mut Self| {\n+                if empty.get() {\n+                    empty.set(false);\n+                    this.s.word(start)\n+                } else {\n+                    this.word_space(\",\")\n                 }\n+            };\n \n-                // FIXME(eddyb) This would leak into error messages, e.g.:\n-                // \"non-exhaustive patterns: `Some::<..>(_)` not covered\".\n-                if data.infer_types && false {\n+            if !parameters.lifetimes.iter().all(|lt| lt.is_elided()) {\n+                for lifetime in &parameters.lifetimes {\n                     start_or_comma(self)?;\n-                    self.s.word(\"..\")?;\n+                    self.print_lifetime(lifetime)?;\n                 }\n+            }\n \n-                for binding in data.bindings.iter() {\n-                    start_or_comma(self)?;\n-                    self.print_name(binding.name)?;\n-                    self.s.space()?;\n-                    self.word_space(\"=\")?;\n-                    self.print_type(&binding.ty)?;\n-                }\n+            if !parameters.types.is_empty() {\n+                start_or_comma(self)?;\n+                self.commasep(Inconsistent, &parameters.types, |s, ty| s.print_type(&ty))?;\n+            }\n \n-                if !empty.get() {\n-                    self.s.word(\">\")?\n-                }\n+            // FIXME(eddyb) This would leak into error messages, e.g.:\n+            // \"non-exhaustive patterns: `Some::<..>(_)` not covered\".\n+            if parameters.infer_types && false {\n+                start_or_comma(self)?;\n+                self.s.word(\"..\")?;\n             }\n \n-            hir::ParenthesizedParameters(ref data) => {\n-                self.s.word(\"(\")?;\n-                self.commasep(Inconsistent, &data.inputs, |s, ty| s.print_type(&ty))?;\n-                self.s.word(\")\")?;\n+            for binding in parameters.bindings.iter() {\n+                start_or_comma(self)?;\n+                self.print_name(binding.name)?;\n+                self.s.space()?;\n+                self.word_space(\"=\")?;\n+                self.print_type(&binding.ty)?;\n+            }\n \n-                if let Some(ref ty) = data.output {\n-                    self.space_if_not_bol()?;\n-                    self.word_space(\"->\")?;\n-                    self.print_type(&ty)?;\n-                }\n+            if !empty.get() {\n+                self.s.word(\">\")?\n             }\n         }\n "}, {"sha": "c5222c2d6cb8174a8d84dcda28e72848714524ce", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=000f87ab1eb13b1e743bcb614b8d59463f2efd04", "patch": "@@ -133,22 +133,12 @@ impl_stable_hash_for!(struct hir::PathSegment {\n     parameters\n });\n \n-impl_stable_hash_for!(enum hir::PathParameters {\n-    AngleBracketedParameters(data),\n-    ParenthesizedParameters(data)\n-});\n-\n-impl_stable_hash_for!(struct hir::AngleBracketedParameterData {\n+impl_stable_hash_for!(struct hir::PathParameters {\n     lifetimes,\n     types,\n     infer_types,\n-    bindings\n-});\n-\n-impl_stable_hash_for!(struct hir::ParenthesizedParameterData {\n-    span,\n-    inputs,\n-    output\n+    bindings,\n+    parenthesized\n });\n \n impl_stable_hash_for!(enum hir::TyParamBound {"}, {"sha": "a8e98e53db394960de8abd5537dfdae7fafb763d", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=000f87ab1eb13b1e743bcb614b8d59463f2efd04", "patch": "@@ -915,18 +915,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                 def: Def,\n                                 depth: usize,\n                                 params: &'tcx hir::PathParameters) {\n-        let data = match *params {\n-            hir::ParenthesizedParameters(ref data) => {\n-                self.visit_fn_like_elision(&data.inputs, data.output.as_ref());\n-                return;\n-            }\n-            hir::AngleBracketedParameters(ref data) => data\n-        };\n+        if params.parenthesized {\n+            self.visit_fn_like_elision(params.inputs(), Some(&params.bindings[0].ty));\n+            return;\n+        }\n \n-        if data.lifetimes.iter().all(|l| l.is_elided()) {\n-            self.resolve_elided_lifetimes(&data.lifetimes);\n+        if params.lifetimes.iter().all(|l| l.is_elided()) {\n+            self.resolve_elided_lifetimes(&params.lifetimes);\n         } else {\n-            for l in &data.lifetimes { self.visit_lifetime(l); }\n+            for l in &params.lifetimes { self.visit_lifetime(l); }\n         }\n \n         // Figure out if this is a type/trait segment,\n@@ -995,13 +992,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             Some(Region::Static)\n                         }\n                     }\n-                    Set1::One(r) => r.subst(&data.lifetimes, map),\n+                    Set1::One(r) => r.subst(&params.lifetimes, map),\n                     Set1::Many => None\n                 }\n             }).collect()\n         });\n \n-        for (i, ty) in data.types.iter().enumerate() {\n+        for (i, ty) in params.types.iter().enumerate() {\n             if let Some(&lt) = object_lifetime_defaults.get(i) {\n                 let scope = Scope::ObjectLifetimeDefault {\n                     lifetime: lt,\n@@ -1013,7 +1010,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n \n-        for b in &data.bindings { self.visit_assoc_type_binding(b); }\n+        for b in &params.bindings { self.visit_assoc_type_binding(b); }\n     }\n \n     fn visit_fn_like_elision(&mut self, inputs: &'tcx [P<hir::Ty>],"}, {"sha": "0be29ee57287a9c8f6175d145cb471ba5c62b226", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=000f87ab1eb13b1e743bcb614b8d59463f2efd04", "patch": "@@ -833,10 +833,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         })\n     })?;\n \n-    time(time_passes,\n-         \"early lint checks\",\n-         || lint::check_ast_crate(sess, &krate));\n-\n     // Lower ast -> hir.\n     let hir_forest = time(time_passes, \"lowering ast -> hir\", || {\n         let hir_crate = lower_crate(sess, &krate, &mut resolver);\n@@ -848,6 +844,10 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         hir_map::Forest::new(hir_crate, &sess.dep_graph)\n     });\n \n+    time(time_passes,\n+         \"early lint checks\",\n+         || lint::check_ast_crate(sess, &krate));\n+\n     // Discard hygiene data, which isn't required after lowering to HIR.\n     if !keep_hygiene_data(sess) {\n         syntax::ext::hygiene::clear_markings();"}, {"sha": "ffe444933a3b1c04db6599b07ec38b17258b2f1b", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=000f87ab1eb13b1e743bcb614b8d59463f2efd04", "patch": "@@ -140,14 +140,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             ExprKind::Continue(Some(ident)) => {\n                 self.check_label(ident.node, ident.span);\n             }\n-            ExprKind::MethodCall(ref segment, ..) => {\n-                if let Some(ref params) = segment.parameters {\n-                    if let PathParameters::Parenthesized(..) = **params {\n-                        self.err_handler().span_err(expr.span,\n-                            \"parenthesized parameters cannot be used on method calls\");\n-                    }\n-                }\n-            }\n             _ => {}\n         }\n "}, {"sha": "ee1e6bd950fa17e8c8385511d9284b1e7743d73e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 31, "deletions": 133, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=000f87ab1eb13b1e743bcb614b8d59463f2efd04", "patch": "@@ -22,16 +22,14 @@ use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n-use rustc::lint::builtin::PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES;\n use rustc_back::slice;\n use require_c_abi_if_variadic;\n-use util::common::{ErrorReported, FN_OUTPUT_NAME};\n+use util::common::ErrorReported;\n use util::nodemap::FxHashSet;\n \n use std::iter;\n use syntax::{abi, ast};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub trait AstConv<'gcx, 'tcx> {\n@@ -152,21 +150,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         item_segment: &hir::PathSegment)\n         -> &'tcx Substs<'tcx>\n     {\n-        let tcx = self.tcx();\n-\n-        match item_segment.parameters {\n-            hir::AngleBracketedParameters(_) => {}\n-            hir::ParenthesizedParameters(..) => {\n-                self.prohibit_parenthesized_params(item_segment, true);\n-\n-                return Substs::for_item(tcx, def_id, |_, _| {\n-                    tcx.types.re_static\n-                }, |_, _| {\n-                    tcx.types.err\n-                });\n-            }\n-        }\n-\n         let (substs, assoc_bindings) =\n             self.create_substs_for_ast_path(span,\n                                             def_id,\n@@ -196,19 +179,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                parameters={:?})\",\n                def_id, self_ty, parameters);\n \n-        let (lifetimes, num_types_provided, infer_types) = match *parameters {\n-            hir::AngleBracketedParameters(ref data) => {\n-                (&data.lifetimes[..], data.types.len(), data.infer_types)\n-            }\n-            hir::ParenthesizedParameters(_) => (&[][..], 1, false)\n-        };\n-\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n         let decl_generics = tcx.generics_of(def_id);\n+        let num_types_provided = parameters.types.len();\n         let expected_num_region_params = decl_generics.regions.len();\n-        let supplied_num_region_params = lifetimes.len();\n+        let supplied_num_region_params = parameters.lifetimes.len();\n         if expected_num_region_params != supplied_num_region_params {\n             report_lifetime_number_error(tcx, span,\n                                          supplied_num_region_params,\n@@ -220,7 +197,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // Check the number of type parameters supplied by the user.\n         let ty_param_defs = &decl_generics.types[self_ty.is_some() as usize..];\n-        if !infer_types || num_types_provided > ty_param_defs.len() {\n+        if !parameters.infer_types || num_types_provided > ty_param_defs.len() {\n             check_type_argument_count(tcx, span, num_types_provided, ty_param_defs);\n         }\n \n@@ -237,10 +214,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             false\n         };\n \n-        let mut output_assoc_binding = None;\n         let substs = Substs::for_item(tcx, def_id, |def, _| {\n             let i = def.index as usize - self_ty.is_some() as usize;\n-            if let Some(lifetime) = lifetimes.get(i) {\n+            if let Some(lifetime) = parameters.lifetimes.get(i) {\n                 self.ast_region_to_region(lifetime, Some(def))\n             } else {\n                 tcx.types.re_static\n@@ -256,18 +232,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             let i = i - self_ty.is_some() as usize - decl_generics.regions.len();\n             if i < num_types_provided {\n                 // A provided type parameter.\n-                match *parameters {\n-                    hir::AngleBracketedParameters(ref data) => {\n-                        self.ast_ty_to_ty(&data.types[i])\n-                    }\n-                    hir::ParenthesizedParameters(ref data) => {\n-                        assert_eq!(i, 0);\n-                        let (ty, assoc) = self.convert_parenthesized_parameters(data);\n-                        output_assoc_binding = Some(assoc);\n-                        ty\n-                    }\n-                }\n-            } else if infer_types {\n+                self.ast_ty_to_ty(&parameters.types[i])\n+            } else if parameters.infer_types {\n                 // No type parameters were provided, we can infer all.\n                 let ty_var = if !default_needs_object_self(def) {\n                     self.ty_infer_for_def(def, substs, span)\n@@ -306,57 +272,20 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n         });\n \n-        let assoc_bindings = match *parameters {\n-            hir::AngleBracketedParameters(ref data) => {\n-                data.bindings.iter().map(|b| {\n-                    ConvertedBinding {\n-                        item_name: b.name,\n-                        ty: self.ast_ty_to_ty(&b.ty),\n-                        span: b.span\n-                    }\n-                }).collect()\n-            }\n-            hir::ParenthesizedParameters(ref data) => {\n-                vec![output_assoc_binding.unwrap_or_else(|| {\n-                    // This is an error condition, but we should\n-                    // get the associated type binding anyway.\n-                    self.convert_parenthesized_parameters(data).1\n-                })]\n+        let assoc_bindings = parameters.bindings.iter().map(|binding| {\n+            ConvertedBinding {\n+                item_name: binding.name,\n+                ty: self.ast_ty_to_ty(&binding.ty),\n+                span: binding.span,\n             }\n-        };\n+        }).collect();\n \n         debug!(\"create_substs_for_ast_path(decl_generics={:?}, self_ty={:?}) -> {:?}\",\n                decl_generics, self_ty, substs);\n \n         (substs, assoc_bindings)\n     }\n \n-    fn convert_parenthesized_parameters(&self,\n-                                        data: &hir::ParenthesizedParameterData)\n-                                        -> (Ty<'tcx>, ConvertedBinding<'tcx>)\n-    {\n-        let inputs = self.tcx().mk_type_list(data.inputs.iter().map(|a_t| {\n-            self.ast_ty_to_ty(a_t)\n-        }));\n-\n-        let (output, output_span) = match data.output {\n-            Some(ref output_ty) => {\n-                (self.ast_ty_to_ty(output_ty), output_ty.span)\n-            }\n-            None => {\n-                (self.tcx().mk_nil(), data.span)\n-            }\n-        };\n-\n-        let output_binding = ConvertedBinding {\n-            item_name: Symbol::intern(FN_OUTPUT_NAME),\n-            ty: output,\n-            span: output_span\n-        };\n-\n-        (self.tcx().mk_ty(ty::TyTuple(inputs, false)), output_binding)\n-    }\n-\n     /// Instantiates the path for the given trait reference, assuming that it's\n     /// bound to a valid trait type. Returns the def_id for the defining trait.\n     /// Fails if the type is a type other than a trait type.\n@@ -453,29 +382,17 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let trait_def = self.tcx().trait_def(trait_def_id);\n \n-        match trait_segment.parameters {\n-            hir::AngleBracketedParameters(_) => {\n-                // For now, require that parenthetical notation be used\n-                // only with `Fn()` etc.\n-                if !self.tcx().sess.features.borrow().unboxed_closures && trait_def.paren_sugar {\n-                    emit_feature_err(&self.tcx().sess.parse_sess,\n-                                     \"unboxed_closures\", span, GateIssue::Language,\n-                                     \"\\\n-                        the precise format of `Fn`-family traits' \\\n-                        type parameters is subject to change. \\\n-                        Use parenthetical notation (Fn(Foo, Bar) -> Baz) instead\");\n-                }\n-            }\n-            hir::ParenthesizedParameters(_) => {\n-                // For now, require that parenthetical notation be used\n-                // only with `Fn()` etc.\n-                if !self.tcx().sess.features.borrow().unboxed_closures && !trait_def.paren_sugar {\n-                    emit_feature_err(&self.tcx().sess.parse_sess,\n-                                     \"unboxed_closures\", span, GateIssue::Language,\n-                                     \"\\\n-                        parenthetical notation is only stable when used with `Fn`-family traits\");\n-                }\n-            }\n+        if !self.tcx().sess.features.borrow().unboxed_closures &&\n+           trait_segment.parameters.parenthesized != trait_def.paren_sugar {\n+            // For now, require that parenthetical notation be used only with `Fn()` etc.\n+            let msg = if trait_def.paren_sugar {\n+                \"the precise format of `Fn`-family traits' type parameters is subject to change. \\\n+                 Use parenthetical notation (Fn(Foo, Bar) -> Baz) instead\"\n+            } else {\n+                \"parenthetical notation is only stable when used with `Fn`-family traits\"\n+            };\n+            emit_feature_err(&self.tcx().sess.parse_sess, \"unboxed_closures\",\n+                             span, GateIssue::Language, msg);\n         }\n \n         self.create_substs_for_ast_path(span,\n@@ -951,47 +868,28 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     pub fn prohibit_type_params(&self, segments: &[hir::PathSegment]) {\n         for segment in segments {\n-            if let hir::ParenthesizedParameters(_) = segment.parameters {\n-                self.prohibit_parenthesized_params(segment, false);\n-                break;\n-            }\n-            for typ in segment.parameters.types() {\n+            for typ in &segment.parameters.types {\n                 struct_span_err!(self.tcx().sess, typ.span, E0109,\n                                  \"type parameters are not allowed on this type\")\n                     .span_label(typ.span, \"type parameter not allowed\")\n                     .emit();\n                 break;\n             }\n-            for lifetime in segment.parameters.lifetimes() {\n+            for lifetime in &segment.parameters.lifetimes {\n                 struct_span_err!(self.tcx().sess, lifetime.span, E0110,\n                                  \"lifetime parameters are not allowed on this type\")\n                     .span_label(lifetime.span,\n                                 \"lifetime parameter not allowed on this type\")\n                     .emit();\n                 break;\n             }\n-            for binding in segment.parameters.bindings() {\n+            for binding in &segment.parameters.bindings {\n                 self.prohibit_projection(binding.span);\n                 break;\n             }\n         }\n     }\n \n-    pub fn prohibit_parenthesized_params(&self, segment: &hir::PathSegment, emit_error: bool) {\n-        if let hir::ParenthesizedParameters(ref data) = segment.parameters {\n-            if emit_error {\n-                struct_span_err!(self.tcx().sess, data.span, E0214,\n-                          \"parenthesized parameters may only be used with a trait\")\n-                    .span_label(data.span, \"only traits may use parentheses\")\n-                    .emit();\n-            } else {\n-                let msg = \"parenthesized parameters may only be used with a trait\";\n-                self.tcx().lint_node(PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n-                                     ast::CRATE_NODE_ID, data.span, msg);\n-            }\n-        }\n-    }\n-\n     pub fn prohibit_projection(&self, span: Span) {\n         let mut err = struct_span_err!(self.tcx().sess, span, E0229,\n                                        \"associated type bindings are not allowed here\");\n@@ -1392,13 +1290,13 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                     Some(trait_did) == tcx.lang_items.sync_trait() {\n                     let segments = &bound.trait_ref.path.segments;\n                     let parameters = &segments[segments.len() - 1].parameters;\n-                    if !parameters.types().is_empty() {\n+                    if !parameters.types.is_empty() {\n                         check_type_argument_count(tcx, bound.trait_ref.path.span,\n-                                                  parameters.types().len(), &[]);\n+                                                  parameters.types.len(), &[]);\n                     }\n-                    if !parameters.lifetimes().is_empty() {\n+                    if !parameters.lifetimes.is_empty() {\n                         report_lifetime_number_error(tcx, bound.trait_ref.path.span,\n-                                                     parameters.lifetimes().len(), 0);\n+                                                     parameters.lifetimes.len(), 0);\n                     }\n                     true\n                 } else {"}, {"sha": "db383b6305b4a424fd60490907442f62c2e92363", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=000f87ab1eb13b1e743bcb614b8d59463f2efd04", "patch": "@@ -311,17 +311,14 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         // Create subst for early-bound lifetime parameters, combining\n         // parameters from the type and those from the method.\n-        let (supplied_types, supplied_lifetimes) = match segment.parameters {\n-            hir::AngleBracketedParameters(ref data) => (&data.types, &data.lifetimes),\n-            _ => bug!(\"unexpected generic arguments: {:?}\", segment.parameters),\n-        };\n         assert_eq!(method_generics.parent_count(), parent_substs.len());\n+        let provided = &segment.parameters;\n         Substs::for_item(self.tcx, pick.item.def_id, |def, _| {\n             let i = def.index as usize;\n             if i < parent_substs.len() {\n                 parent_substs.region_at(i)\n-            } else if let Some(lifetime) =\n-                    supplied_lifetimes.get(i - parent_substs.len()) {\n+            } else if let Some(lifetime)\n+                    = provided.lifetimes.get(i - parent_substs.len()) {\n                 AstConv::ast_region_to_region(self.fcx, lifetime, Some(def))\n             } else {\n                 self.region_var_for_def(self.span, def)\n@@ -330,8 +327,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             let i = def.index as usize;\n             if i < parent_substs.len() {\n                 parent_substs.type_at(i)\n-            } else if let Some(ast_ty) =\n-                    supplied_types.get(i - parent_substs.len() - method_generics.regions.len()) {\n+            } else if let Some(ast_ty)\n+                    = provided.types.get(i - parent_substs.len() - method_generics.regions.len()) {\n                 self.to_ty(ast_ty)\n             } else {\n                 self.type_var_for_def(self.span, def, cur_substs)"}, {"sha": "f4e7110713d50b707133719019c43b41b80027cf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=000f87ab1eb13b1e743bcb614b8d59463f2efd04", "patch": "@@ -4621,11 +4621,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 i -= fn_start;\n                 fn_segment\n             };\n-            let lifetimes = match segment.map(|(s, _)| &s.parameters) {\n-                Some(&hir::AngleBracketedParameters(ref data)) => &data.lifetimes[..],\n-                Some(&hir::ParenthesizedParameters(_)) => bug!(),\n-                None => &[]\n-            };\n+            let lifetimes = segment.map_or(&[][..], |(s, _)| &s.parameters.lifetimes[..]);\n \n             if let Some(lifetime) = lifetimes.get(i) {\n                 AstConv::ast_region_to_region(self, lifetime, Some(def))\n@@ -4648,13 +4644,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 i -= fn_start;\n                 fn_segment\n             };\n-            let (types, infer_types) = match segment.map(|(s, _)| &s.parameters) {\n-                Some(&hir::AngleBracketedParameters(ref data)) => {\n-                    (&data.types[..], data.infer_types)\n-                }\n-                Some(&hir::ParenthesizedParameters(_)) => bug!(),\n-                None => (&[][..], true)\n-            };\n+            let (types, infer_types) = segment.map_or((&[][..], true), |(s, _)| {\n+                (&s.parameters.types[..], s.parameters.infer_types)\n+            });\n \n             // Skip over the lifetimes in the same segment.\n             if let Some((_, generics)) = segment {\n@@ -4728,19 +4720,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   span: Span,\n                                   segment: &mut Option<(&hir::PathSegment, &ty::Generics)>,\n                                   is_method_call: bool) {\n-        let (lifetimes, types, infer_types, bindings) = {\n-            match segment.map(|(s, _)| &s.parameters) {\n-                Some(&hir::AngleBracketedParameters(ref data)) => {\n-                    (&data.lifetimes[..], &data.types[..], data.infer_types, &data.bindings[..])\n-                }\n-                Some(&hir::ParenthesizedParameters(_)) => {\n-                    AstConv::prohibit_parenthesized_params(self, &segment.as_ref().unwrap().0,\n-                                                           false);\n-                    (&[][..], &[][..], true, &[][..])\n-                }\n-                None => (&[][..], &[][..], true, &[][..])\n-            }\n-        };\n+        let (lifetimes, types, infer_types, bindings) = segment.map_or(\n+            (&[][..], &[][..], true, &[][..]),\n+            |(s, _)| (&s.parameters.lifetimes[..], &s.parameters.types[..],\n+                      s.parameters.infer_types, &s.parameters.bindings[..]));\n         let infer_lifetimes = lifetimes.len() == 0;\n \n         let count_lifetime_params = |n| {\n@@ -4786,9 +4769,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         if !bindings.is_empty() {\n-            span_err!(self.tcx.sess, bindings[0].span, E0182,\n-                      \"unexpected binding of associated item in expression path \\\n-                       (only allowed in type paths)\");\n+            AstConv::prohibit_projection(self, bindings[0].span);\n         }\n \n         // Check provided lifetime parameters."}, {"sha": "cb430efd9508fc9433a98b801213b82d47ad43f4", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 54, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=000f87ab1eb13b1e743bcb614b8d59463f2efd04", "patch": "@@ -1636,45 +1636,6 @@ fn bar(foo: Foo) -> u32 {\n ```\n \"##,\n \n-E0182: r##\"\n-You bound an associated type in an expression path which is not\n-allowed.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0182\n-trait Foo {\n-    type A;\n-    fn bar() -> isize;\n-}\n-\n-impl Foo for isize {\n-    type A = usize;\n-    fn bar() -> isize { 42 }\n-}\n-\n-// error: unexpected binding of associated item in expression path\n-let x: isize = Foo::<A=usize>::bar();\n-```\n-\n-To give a concrete type when using the Universal Function Call Syntax,\n-use \"Type as Trait\". Example:\n-\n-```\n-trait Foo {\n-    type A;\n-    fn bar() -> isize;\n-}\n-\n-impl Foo for isize {\n-    type A = usize;\n-    fn bar() -> isize { 42 }\n-}\n-\n-let x: isize = <isize as Foo>::bar(); // ok!\n-```\n-\"##,\n-\n E0184: r##\"\n Explicitly implementing both Drop and Copy for a type is currently disallowed.\n This feature can make some sense in theory, but the current implementation is\n@@ -2359,21 +2320,6 @@ impl Foo {\n \"##,\n      */\n \n-E0214: r##\"\n-A generic type was described using parentheses rather than angle brackets. For\n-example:\n-\n-```compile_fail,E0214\n-fn main() {\n-    let v: Vec(&str) = vec![\"foo\"];\n-}\n-```\n-\n-This is not currently supported: `v` should be defined as `Vec<&str>`.\n-Parentheses are currently only used with generic types when defining parameters\n-for `Fn`-family traits.\n-\"##,\n-\n E0220: r##\"\n You used an associated type which isn't defined in the trait.\n Erroneous code example:\n@@ -4721,6 +4667,7 @@ register_diagnostics! {\n //  E0172, // non-trait found in a type sum, moved to resolve\n //  E0173, // manual implementations of unboxed closure traits are experimental\n //  E0174,\n+//  E0182, // merged into E0229\n     E0183,\n //  E0187, // can't infer the kind of the closure\n //  E0188, // can not cast an immutable reference to a mutable pointer"}, {"sha": "92b3180c5cbf2ce28f67361e505b42abf0e595a1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=000f87ab1eb13b1e743bcb614b8d59463f2efd04", "patch": "@@ -1794,16 +1794,14 @@ impl Clean<Type> for hir::Ty {\n                     let mut lt_substs = FxHashMap();\n                     for (i, ty_param) in generics.ty_params.iter().enumerate() {\n                         let ty_param_def = Def::TyParam(cx.tcx.hir.local_def_id(ty_param.id));\n-                        if let Some(ty) = provided_params.types().get(i).cloned()\n-                                                                        .cloned() {\n+                        if let Some(ty) = provided_params.types.get(i).cloned() {\n                             ty_substs.insert(ty_param_def, ty.unwrap().clean(cx));\n                         } else if let Some(default) = ty_param.default.clone() {\n                             ty_substs.insert(ty_param_def, default.unwrap().clean(cx));\n                         }\n                     }\n                     for (i, lt_param) in generics.lifetimes.iter().enumerate() {\n-                        if let Some(lt) = provided_params.lifetimes().get(i).cloned()\n-                                                                            .cloned() {\n+                        if let Some(lt) = provided_params.lifetimes.get(i).cloned() {\n                             if !lt.is_elided() {\n                                 lt_substs.insert(lt_param.lifetime.id, lt.clean(cx));\n                             }\n@@ -2314,24 +2312,21 @@ pub enum PathParameters {\n \n impl Clean<PathParameters> for hir::PathParameters {\n     fn clean(&self, cx: &DocContext) -> PathParameters {\n-        match *self {\n-            hir::AngleBracketedParameters(ref data) => {\n-                PathParameters::AngleBracketed {\n-                    lifetimes: if data.lifetimes.iter().all(|lt| lt.is_elided()) {\n-                        vec![]\n-                    } else {\n-                        data.lifetimes.clean(cx)\n-                    },\n-                    types: data.types.clean(cx),\n-                    bindings: data.bindings.clean(cx),\n-                }\n+        if self.parenthesized {\n+            let output = self.bindings[0].ty.clean(cx);\n+            PathParameters::Parenthesized {\n+                inputs: self.inputs().clean(cx),\n+                output: if output != Type::Tuple(Vec::new()) { Some(output) } else { None }\n             }\n-\n-            hir::ParenthesizedParameters(ref data) => {\n-                PathParameters::Parenthesized {\n-                    inputs: data.inputs.clean(cx),\n-                    output: data.output.clean(cx),\n-                }\n+        } else {\n+            PathParameters::AngleBracketed {\n+                lifetimes: if self.lifetimes.iter().all(|lt| lt.is_elided()) {\n+                    vec![]\n+                } else {\n+                    self.lifetimes.clean(cx)\n+                },\n+                types: self.types.clean(cx),\n+                bindings: self.bindings.clean(cx),\n             }\n         }\n     }"}, {"sha": "847393ba2b89f4168069b2ad97c1d09fd0cf9cac", "filename": "src/test/compile-fail/associated-types-eq-expr-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs?ref=000f87ab1eb13b1e743bcb614b8d59463f2efd04", "patch": "@@ -22,5 +22,5 @@ impl Foo for isize {\n \n pub fn main() {\n     let x: isize = Foo::<A=usize>::bar();\n-    //~^ ERROR unexpected binding of associated item in expression path\n+    //~^ ERROR associated type bindings are not allowed here\n }"}, {"sha": "e9f62152888147aaaa75dcb2bc75818ec408778c", "filename": "src/test/compile-fail/issue-43431.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Ftest%2Fcompile-fail%2Fissue-43431.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Ftest%2Fcompile-fail%2Fissue-43431.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43431.rs?ref=000f87ab1eb13b1e743bcb614b8d59463f2efd04", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(fn_traits)]\n+\n+trait CallSingle<A, B> {\n+    fn call(&self, a: A) -> B where Self: Fn(A) -> B;\n+}\n+\n+impl<A, B, F: Fn(A) -> B> CallSingle<A, B> for F {\n+    fn call(&self, a: A) -> B {\n+        <Self as Fn(A) -> B>::call(self, (a,))\n+        //~^ ERROR associated type bindings are not allowed here\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6c0793ee78f19c5adaed14a58312e894162f2050", "filename": "src/test/compile-fail/method-call-type-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Ftest%2Fcompile-fail%2Fmethod-call-type-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Ftest%2Fcompile-fail%2Fmethod-call-type-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-call-type-binding.rs?ref=000f87ab1eb13b1e743bcb614b8d59463f2efd04", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    0.clone::<T = u8>(); //~ ERROR unexpected binding of associated item\n+    0.clone::<T = u8>(); //~ ERROR associated type bindings are not allowed here\n }"}, {"sha": "5fcde4facbe8d5ecb1d05dcd4e4ad846e796b7c8", "filename": "src/test/compile-fail/unboxed-closure-sugar-used-on-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000f87ab1eb13b1e743bcb614b8d59463f2efd04/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct.rs?ref=000f87ab1eb13b1e743bcb614b8d59463f2efd04", "patch": "@@ -16,6 +16,7 @@ struct Bar<A> {\n \n fn foo(b: Box<Bar()>) {\n     //~^ ERROR parenthesized parameters may only be used with a trait\n+    //~| ERROR the type placeholder `_` is not allowed within types on item signatures\n }\n \n fn main() { }"}]}