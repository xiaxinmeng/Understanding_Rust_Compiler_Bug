{"sha": "341d6dfba585979e5909403567638e34b206fffa", "node_id": "C_kwDOAAsO6NoAKDM0MWQ2ZGZiYTU4NTk3OWU1OTA5NDAzNTY3NjM4ZTM0YjIwNmZmZmE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-12T00:43:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-12T00:43:06Z"}, "message": "Rollup merge of #106038 - aliemjay:opaque-implied, r=lcnr\n\nuse implied bounds when checking opaque types\n\nDuring opaque type inference, we check for the well-formedness of the hidden type in the opaque type's own environment, not the one of the defining site, which are different in the case of TAIT.\n\nHowever in the case of associated-type-impl-trait, we don't use implied bounds from the impl header. This caused us to reject the following:\n```rust\ntrait Service<Req> {\n    type Output;\n    fn call(req: Req) -> Self::Output;\n}\n\nimpl<'a, Req> Service<&'a Req> for u8 {\n    type Output= impl Sized; // we can't prove WF of hidden type  `WF(&'a Req)` although it's implied by the impl\n    //~^ ERROR type parameter Req doesn't live long enough\n    fn call(req: &'a Req) -> Self::Output {\n        req\n    }\n}\n```\n\nalthough adding an explicit bound would make it pass:\n```diff\n- impl<'a, Req> Service<&'a Req> for u8 {\n+ impl<'a, Req> Service<&'a Req> for u8  where Req: 'a, {\n```\n\nI believe it should pass as we already allow the concrete type to be used:\n```diff\nimpl<'a, Req> Service<&'a Req> for u8 {\n-    type Output= impl Sized;\n+    type Output= &'a Req;\n```\n\nFixes #95922\n\nBuilds on #105982\n\ncc ``@lcnr`` (because implied bounds)\n\nr? ``@oli-obk``", "tree": {"sha": "a03f988869c931f1b06e7578f3ce18cd9bb91660", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a03f988869c931f1b06e7578f3ce18cd9bb91660"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/341d6dfba585979e5909403567638e34b206fffa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkXYuaCRBK7hj4Ov3rIwAANUoIAIZXmgpzMyCRNyrY0246xHOb\nzDY0HwEgWVICnuMGtRIn6cwjEXcMCKGzmv42s+wxMPDSqjCeWpglP3niutuRfwfn\nGdET32J4Wr1JJK69LJiOhRSIyh/m8zKcmUULfF2ElYR9z9rb4k6W5kazYzQOk1CU\nESozAM+t3syJBdcv0j5bQXdQYccZnFv5RMOQVF4+a9DUJ6I7C/XWPDoA6MNy5ju3\nntjK3YlBHS6VpKaujMwNYBtEVESfX6mB4jvwvll+gXK8tsVqpgY0XjrV7SuP7CxM\nsgNI7gwUX3mCXyRMkCLdWpkjyRgEswTpVChsE7j9NIDZ2A2mHeiksuWdzcmIHXg=\n=Khpq\n-----END PGP SIGNATURE-----\n", "payload": "tree a03f988869c931f1b06e7578f3ce18cd9bb91660\nparent 2a8221dbdfd180a2d56d4b0089f4f3952d8c2bcd\nparent d548747c8531f2f0dfd3921b85aafb09ded27d49\nauthor Michael Goulet <michael@errs.io> 1683852186 -0700\ncommitter GitHub <noreply@github.com> 1683852186 -0700\n\nRollup merge of #106038 - aliemjay:opaque-implied, r=lcnr\n\nuse implied bounds when checking opaque types\n\nDuring opaque type inference, we check for the well-formedness of the hidden type in the opaque type's own environment, not the one of the defining site, which are different in the case of TAIT.\n\nHowever in the case of associated-type-impl-trait, we don't use implied bounds from the impl header. This caused us to reject the following:\n```rust\ntrait Service<Req> {\n    type Output;\n    fn call(req: Req) -> Self::Output;\n}\n\nimpl<'a, Req> Service<&'a Req> for u8 {\n    type Output= impl Sized; // we can't prove WF of hidden type  `WF(&'a Req)` although it's implied by the impl\n    //~^ ERROR type parameter Req doesn't live long enough\n    fn call(req: &'a Req) -> Self::Output {\n        req\n    }\n}\n```\n\nalthough adding an explicit bound would make it pass:\n```diff\n- impl<'a, Req> Service<&'a Req> for u8 {\n+ impl<'a, Req> Service<&'a Req> for u8  where Req: 'a, {\n```\n\nI believe it should pass as we already allow the concrete type to be used:\n```diff\nimpl<'a, Req> Service<&'a Req> for u8 {\n-    type Output= impl Sized;\n+    type Output= &'a Req;\n```\n\nFixes #95922\n\nBuilds on #105982\n\ncc ``@lcnr`` (because implied bounds)\n\nr? ``@oli-obk``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/341d6dfba585979e5909403567638e34b206fffa", "html_url": "https://github.com/rust-lang/rust/commit/341d6dfba585979e5909403567638e34b206fffa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/341d6dfba585979e5909403567638e34b206fffa/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a8221dbdfd180a2d56d4b0089f4f3952d8c2bcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a8221dbdfd180a2d56d4b0089f4f3952d8c2bcd", "html_url": "https://github.com/rust-lang/rust/commit/2a8221dbdfd180a2d56d4b0089f4f3952d8c2bcd"}, {"sha": "d548747c8531f2f0dfd3921b85aafb09ded27d49", "url": "https://api.github.com/repos/rust-lang/rust/commits/d548747c8531f2f0dfd3921b85aafb09ded27d49", "html_url": "https://github.com/rust-lang/rust/commit/d548747c8531f2f0dfd3921b85aafb09ded27d49"}], "stats": {"total": 193, "additions": 189, "deletions": 4}, "files": [{"sha": "5187e63f8e3a144f51703be89e22b7f09c56c2d3", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/341d6dfba585979e5909403567638e34b206fffa/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341d6dfba585979e5909403567638e34b206fffa/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=341d6dfba585979e5909403567638e34b206fffa", "patch": "@@ -31,6 +31,7 @@ use rustc_target::abi::FieldIdx;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::on_unimplemented::OnUnimplementedDirective;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n+use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCtxt, TraitEngine, TraitEngineExt as _};\n \n use std::ops::ControlFlow;\n@@ -222,7 +223,7 @@ fn check_opaque(tcx: TyCtxt<'_>, id: hir::ItemId) {\n     if check_opaque_for_cycles(tcx, item.owner_id.def_id, substs, span, &origin).is_err() {\n         return;\n     }\n-    check_opaque_meets_bounds(tcx, item.owner_id.def_id, substs, span, &origin);\n+    check_opaque_meets_bounds(tcx, item.owner_id.def_id, span, &origin);\n }\n \n /// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n@@ -391,7 +392,6 @@ pub(super) fn check_opaque_for_cycles<'tcx>(\n fn check_opaque_meets_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,\n-    substs: SubstsRef<'tcx>,\n     span: Span,\n     origin: &hir::OpaqueTyOrigin,\n ) {\n@@ -406,6 +406,8 @@ fn check_opaque_meets_bounds<'tcx>(\n         .with_opaque_type_inference(DefiningAnchor::Bind(defining_use_anchor))\n         .build();\n     let ocx = ObligationCtxt::new(&infcx);\n+\n+    let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n     let opaque_ty = tcx.mk_opaque(def_id.to_def_id(), substs);\n \n     // `ReErased` regions appear in the \"parent_substs\" of closures/generators.\n@@ -448,9 +450,18 @@ fn check_opaque_meets_bounds<'tcx>(\n     match origin {\n         // Checked when type checking the function containing them.\n         hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n+        // Nested opaque types occur only in associated types:\n+        // ` type Opaque<T> = impl Trait<&'static T, AssocTy = impl Nested>; `\n+        // They can only be referenced as `<Opaque<T> as Trait<&'static T>>::AssocTy`.\n+        // We don't have to check them here because their well-formedness follows from the WF of\n+        // the projection input types in the defining- and use-sites.\n+        hir::OpaqueTyOrigin::TyAlias\n+            if tcx.def_kind(tcx.parent(def_id.to_def_id())) == DefKind::OpaqueTy => {}\n         // Can have different predicates to their defining use\n         hir::OpaqueTyOrigin::TyAlias => {\n-            let outlives_env = OutlivesEnvironment::new(param_env);\n+            let wf_tys = ocx.assumed_wf_types(param_env, span, def_id);\n+            let implied_bounds = infcx.implied_bounds_tys(param_env, def_id, wf_tys);\n+            let outlives_env = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n             let _ = ocx.resolve_regions_and_report_errors(defining_use_anchor, &outlives_env);\n         }\n     }"}, {"sha": "5ca5d14337cf08b0d2f7b08e52ec5034389948ac", "filename": "compiler/rustc_ty_utils/src/implied_bounds.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/341d6dfba585979e5909403567638e34b206fffa/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341d6dfba585979e5909403567638e34b206fffa/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs?ref=341d6dfba585979e5909403567638e34b206fffa", "patch": "@@ -31,6 +31,18 @@ fn assumed_wf_types(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::List<Ty<'_>> {\n             }\n         }\n         DefKind::AssocConst | DefKind::AssocTy => tcx.assumed_wf_types(tcx.parent(def_id)),\n+        DefKind::OpaqueTy => match tcx.def_kind(tcx.parent(def_id)) {\n+            DefKind::TyAlias => ty::List::empty(),\n+            DefKind::AssocTy => tcx.assumed_wf_types(tcx.parent(def_id)),\n+            // Nested opaque types only occur in associated types:\n+            // ` type Opaque<T> = impl Trait<&'static T, AssocTy = impl Nested>; `\n+            // assumed_wf_types should include those of `Opaque<T>`, `Opaque<T>` itself\n+            // and `&'static T`.\n+            DefKind::OpaqueTy => bug!(\"unimplemented implied bounds for neseted opaque types\"),\n+            def_kind @ _ => {\n+                bug!(\"unimplemented implied bounds for opaque types with parent {def_kind:?}\")\n+            }\n+        },\n         DefKind::Mod\n         | DefKind::Struct\n         | DefKind::Union\n@@ -51,7 +63,6 @@ fn assumed_wf_types(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::List<Ty<'_>> {\n         | DefKind::ForeignMod\n         | DefKind::AnonConst\n         | DefKind::InlineConst\n-        | DefKind::OpaqueTy\n         | DefKind::ImplTraitPlaceholder\n         | DefKind::Field\n         | DefKind::LifetimeParam"}, {"sha": "9e96323ab54bbaa6cf8e26fa6814c09d4544e499", "filename": "tests/ui/type-alias-impl-trait/wf-in-associated-type.fail.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/341d6dfba585979e5909403567638e34b206fffa/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-in-associated-type.fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/341d6dfba585979e5909403567638e34b206fffa/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-in-associated-type.fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-in-associated-type.fail.stderr?ref=341d6dfba585979e5909403567638e34b206fffa", "patch": "@@ -0,0 +1,25 @@\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/wf-in-associated-type.rs:36:23\n+   |\n+LL |         type Opaque = impl Sized + 'a;\n+   |                       ^^^^^^^^^^^^^^^ ...so that the type `&'a T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     impl<'a, T: 'a> Trait<'a, T> for () {\n+   |               ++++\n+\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/wf-in-associated-type.rs:36:23\n+   |\n+LL |         type Opaque = impl Sized + 'a;\n+   |                       ^^^^^^^^^^^^^^^ ...so that the reference type `&'a T` does not outlive the data it points at\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     impl<'a, T: 'a> Trait<'a, T> for () {\n+   |               ++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0309`."}, {"sha": "31fbef9f78f834b0b9acd9bf74a63192519cac06", "filename": "tests/ui/type-alias-impl-trait/wf-in-associated-type.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/341d6dfba585979e5909403567638e34b206fffa/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-in-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341d6dfba585979e5909403567638e34b206fffa/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-in-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-in-associated-type.rs?ref=341d6dfba585979e5909403567638e34b206fffa", "patch": "@@ -0,0 +1,45 @@\n+// WF check for impl Trait in associated type position.\n+//\n+// revisions: pass fail\n+// [pass] check-pass\n+// [fail] check-fail\n+\n+#![feature(impl_trait_in_assoc_type)]\n+\n+// The hidden type here (`&'a T`) requires proving `T: 'a`.\n+// We know it holds because of implied bounds from the impl header.\n+#[cfg(pass)]\n+mod pass {\n+    trait Trait<Req> {\n+        type Opaque1;\n+        fn constrain_opaque1(req: Req) -> Self::Opaque1;\n+    }\n+\n+    impl<'a, T> Trait<&'a T> for () {\n+        type Opaque1 = impl IntoIterator<Item = impl Sized + 'a>;\n+        fn constrain_opaque1(req: &'a T) -> Self::Opaque1 {\n+            [req]\n+        }\n+    }\n+}\n+\n+// The hidden type here (`&'a T`) requires proving `T: 'a`,\n+// but that is not known to hold in the impl.\n+#[cfg(fail)]\n+mod fail {\n+    trait Trait<'a, T> {\n+        type Opaque;\n+        fn constrain_opaque(req: &'a T) -> Self::Opaque;\n+    }\n+\n+    impl<'a, T> Trait<'a, T> for () {\n+        type Opaque = impl Sized + 'a;\n+        //[fail]~^ ERROR the parameter type `T` may not live long enough\n+        //[fail]~| ERROR the parameter type `T` may not live long enough\n+        fn constrain_opaque(req: &'a T) -> Self::Opaque {\n+            req\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "753a46e882eda4e64964a7760bcd4972e34f5e8a", "filename": "tests/ui/type-alias-impl-trait/wf-nested.fail.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/341d6dfba585979e5909403567638e34b206fffa/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-nested.fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/341d6dfba585979e5909403567638e34b206fffa/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-nested.fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-nested.fail.stderr?ref=341d6dfba585979e5909403567638e34b206fffa", "patch": "@@ -0,0 +1,19 @@\n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/wf-nested.rs:55:27\n+   |\n+LL |     type InnerOpaque<T> = impl Sized;\n+   |                           ^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds...\n+   |\n+note: ...that is required by this bound\n+  --> $DIR/wf-nested.rs:12:20\n+   |\n+LL | struct IsStatic<T: 'static>(T);\n+   |                    ^^^^^^^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     type InnerOpaque<T: 'static> = impl Sized;\n+   |                       +++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0310`."}, {"sha": "9ab6685a7f73fd305b218d7fdfae30706ce110ea", "filename": "tests/ui/type-alias-impl-trait/wf-nested.pass_sound.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/341d6dfba585979e5909403567638e34b206fffa/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-nested.pass_sound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/341d6dfba585979e5909403567638e34b206fffa/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-nested.pass_sound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-nested.pass_sound.stderr?ref=341d6dfba585979e5909403567638e34b206fffa", "patch": "@@ -0,0 +1,14 @@\n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/wf-nested.rs:46:17\n+   |\n+LL |         let _ = outer.get();\n+   |                 ^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     fn test<T: 'static>() {\n+   |              +++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0310`."}, {"sha": "de38832948918c82627c07afa95630156e800cf8", "filename": "tests/ui/type-alias-impl-trait/wf-nested.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/341d6dfba585979e5909403567638e34b206fffa/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341d6dfba585979e5909403567638e34b206fffa/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-nested.rs?ref=341d6dfba585979e5909403567638e34b206fffa", "patch": "@@ -0,0 +1,60 @@\n+// Well-formedness of nested opaque types, i.e. `impl Sized` in\n+// `type Outer = impl Trait<Assoc = impl Sized>`.\n+// See the comments below.\n+//\n+// revisions: pass pass_sound fail\n+// [pass] check-pass\n+// [pass_sound] check-fail\n+// [fail] check-fail\n+\n+#![feature(type_alias_impl_trait)]\n+\n+struct IsStatic<T: 'static>(T);\n+\n+trait Trait<In> {\n+    type Out;\n+\n+    fn get(&self) -> Result<Self::Out, ()> {\n+        Err(())\n+    }\n+}\n+\n+impl<T> Trait<&'static T> for () {\n+    type Out = IsStatic<T>;\n+}\n+\n+// The hidden type for `impl Sized` is `IsStatic<T>`, which requires `T: 'static`.\n+// We know it is well-formed because it can *only* be referenced as a projection:\n+// <OuterOpaque<T> as Trait<&'static T>>::Out`.\n+// So any instantiation of the type already requires proving `T: 'static`.\n+#[cfg(pass)]\n+mod pass {\n+    use super::*;\n+    type OuterOpaque<T> = impl Trait<&'static T, Out = impl Sized>;\n+    fn define<T>() -> OuterOpaque<T> {}\n+}\n+\n+// Test the soundness of `pass` - We should require `T: 'static` at the use site.\n+#[cfg(pass_sound)]\n+mod pass_sound {\n+    use super::*;\n+    type OuterOpaque<T> = impl Trait<&'static T, Out = impl Sized>;\n+    fn define<T>() -> OuterOpaque<T> {}\n+\n+    fn test<T>() {\n+        let outer = define::<T>();\n+        let _ = outer.get(); //[pass_sound]~ ERROR `T` may not live long enough\n+    }\n+}\n+\n+// Similar to `pass` but here `impl Sized` can be referenced directly as\n+// InnerOpaque<T>, so we require an explicit bound `T: 'static`.\n+#[cfg(fail)]\n+mod fail {\n+    use super::*;\n+    type InnerOpaque<T> = impl Sized; //[fail]~ ERROR `T` may not live long enough\n+    type OuterOpaque<T> = impl Trait<&'static T, Out = InnerOpaque<T>>;\n+    fn define<T>() -> OuterOpaque<T> {}\n+}\n+\n+fn main() {}"}]}