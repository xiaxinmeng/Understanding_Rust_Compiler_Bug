{"sha": "ad0bc66402eb528aedb1d14235fed9a70bcc0a34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMGJjNjY0MDJlYjUyOGFlZGIxZDE0MjM1ZmVkOWE3MGJjYzBhMzQ=", "commit": {"author": {"name": "R.Chavignat", "email": "r.chavignat@gmail.com", "date": "2015-08-21T01:03:37Z"}, "committer": {"name": "R.Chavignat", "email": "r.chavignat@gmail.com", "date": "2015-08-21T01:03:37Z"}, "message": "Added support for isize/usize in the CastPass lint pass.\n\nExtracted the match that determines an integer types's size in a\nutility function and implemented support for usize/isize.\nAdded a needed feature to the crate root.\nAdded some tests to cover those cases, and a test I previously forgot.\nSilenced two errors signaled by dogfood.sh in unicode.rs.", "tree": {"sha": "d44d742229cc606486c756efcbe000ec6f18d3ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d44d742229cc606486c756efcbe000ec6f18d3ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad0bc66402eb528aedb1d14235fed9a70bcc0a34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad0bc66402eb528aedb1d14235fed9a70bcc0a34", "html_url": "https://github.com/rust-lang/rust/commit/ad0bc66402eb528aedb1d14235fed9a70bcc0a34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad0bc66402eb528aedb1d14235fed9a70bcc0a34/comments", "author": {"login": "Robzz", "id": 304428, "node_id": "MDQ6VXNlcjMwNDQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/304428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Robzz", "html_url": "https://github.com/Robzz", "followers_url": "https://api.github.com/users/Robzz/followers", "following_url": "https://api.github.com/users/Robzz/following{/other_user}", "gists_url": "https://api.github.com/users/Robzz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Robzz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Robzz/subscriptions", "organizations_url": "https://api.github.com/users/Robzz/orgs", "repos_url": "https://api.github.com/users/Robzz/repos", "events_url": "https://api.github.com/users/Robzz/events{/privacy}", "received_events_url": "https://api.github.com/users/Robzz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Robzz", "id": 304428, "node_id": "MDQ6VXNlcjMwNDQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/304428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Robzz", "html_url": "https://github.com/Robzz", "followers_url": "https://api.github.com/users/Robzz/followers", "following_url": "https://api.github.com/users/Robzz/following{/other_user}", "gists_url": "https://api.github.com/users/Robzz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Robzz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Robzz/subscriptions", "organizations_url": "https://api.github.com/users/Robzz/orgs", "repos_url": "https://api.github.com/users/Robzz/repos", "events_url": "https://api.github.com/users/Robzz/events{/privacy}", "received_events_url": "https://api.github.com/users/Robzz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbc9b7f46eb95d2583fc60c09220c0803ba541ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc9b7f46eb95d2583fc60c09220c0803ba541ee", "html_url": "https://github.com/rust-lang/rust/commit/dbc9b7f46eb95d2583fc60c09220c0803ba541ee"}], "stats": {"total": 66, "additions": 46, "deletions": 20}, "files": [{"sha": "9ea1efeed5f8afcfe6f422941b4919f35eabb7f3", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad0bc66402eb528aedb1d14235fed9a70bcc0a34/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad0bc66402eb528aedb1d14235fed9a70bcc0a34/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=ad0bc66402eb528aedb1d14235fed9a70bcc0a34", "patch": "@@ -1,6 +1,6 @@\n #![feature(plugin_registrar, box_syntax)]\n #![feature(rustc_private, core, collections)]\n-#![feature(str_split_at)]\n+#![feature(str_split_at, num_bits_bytes)]\n #![allow(unknown_lints)]\n \n #[macro_use]"}, {"sha": "915ffb15fe56a1cf67eae4d6d9525d5bb691a64e", "filename": "src/types.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ad0bc66402eb528aedb1d14235fed9a70bcc0a34/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad0bc66402eb528aedb1d14235fed9a70bcc0a34/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=ad0bc66402eb528aedb1d14235fed9a70bcc0a34", "patch": "@@ -146,6 +146,18 @@ declare_lint!(pub CAST_SIGN_LOSS, Allow,\n declare_lint!(pub CAST_POSSIBLE_TRUNCATION, Allow,\n               \"casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\");\n \n+/// Returns the size in bits of an integral type.\n+/// Will return 0 if the type is not an int or uint variant\n+fn int_ty_to_nbits(typ: &ty::TyS) -> usize {\n+    let n = match &typ.sty {\n+    &ty::TyInt(i) =>  4 << (i as usize),\n+    &ty::TyUint(u) => 4 << (u as usize),\n+    _ => 0\n+    };\n+    // n == 4 is the usize/isize case\n+    if n == 4 { ::std::usize::BITS } else { n }\n+}\n+\n impl LintPass for CastPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(CAST_PRECISION_LOSS,\n@@ -159,18 +171,13 @@ impl LintPass for CastPass {\n             if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx, expr.span) {\n                 match (cast_from.is_integral(), cast_to.is_integral()) {\n                     (true, false) => {\n-                        let from_nbits = match &cast_from.sty {\n-                            &ty::TyInt(i) =>  4 << (i as usize),\n-                            &ty::TyUint(u) => 4 << (u as usize),\n-                            _ => 0\n-                        };\n+                        let from_nbits = int_ty_to_nbits(cast_from);\n                         let to_nbits : usize = match &cast_to.sty {\n                             &ty::TyFloat(ast::TyF32) => 32,\n                             &ty::TyFloat(ast::TyF64) => 64,\n                             _ => 0\n                         };\n-                        if from_nbits != 4 {\n-                            // Handle TyIs/TyUs separately (pointer size is arch dependant)\n+                        if from_nbits != 0 {\n                             if from_nbits >= to_nbits {\n                                 span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n                                           &format!(\"converting from {0} to {1}, which causes a loss of precision \\\n@@ -192,16 +199,8 @@ impl LintPass for CastPass {\n                             span_lint(cx, CAST_SIGN_LOSS, expr.span,\n                                       &format!(\"casting from {} to {} loses the sign of the value\", cast_from, cast_to));\n                         }\n-                        let from_nbits = match &cast_from.sty {\n-                            &ty::TyInt(i) =>  4 << (i as usize),\n-                            &ty::TyUint(u) => 4 << (u as usize),\n-                            _ => 0\n-                        };\n-                        let to_nbits = match &cast_to.sty {\n-                            &ty::TyInt(i) =>  4 << (i as usize),\n-                            &ty::TyUint(u) => 4 << (u as usize),\n-                            _ => 0\n-                        };\n+                        let from_nbits = int_ty_to_nbits(cast_from);\n+                        let to_nbits   = int_ty_to_nbits(cast_to);\n                         if to_nbits < from_nbits ||\n                            (!cast_from.is_signed() && cast_to.is_signed() && to_nbits <= from_nbits) {\n                                 span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,"}, {"sha": "8a64f612666b26046166da5feac4d34ccdc547d8", "filename": "src/unicode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad0bc66402eb528aedb1d14235fed9a70bcc0a34/src%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad0bc66402eb528aedb1d14235fed9a70bcc0a34/src%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funicode.rs?ref=ad0bc66402eb528aedb1d14235fed9a70bcc0a34", "patch": "@@ -40,6 +40,7 @@ fn check_str(cx: &Context, string: &str, span: Span) {\n     }\n }\n \n+#[allow(cast_possible_truncation)]\n fn str_pos_lint(cx: &Context, lint: &'static Lint, span: Span, index: usize, msg: &str) {\n     span_lint(cx, lint, Span { lo: span.lo + BytePos((1 + index) as u32),\n                                hi: span.lo + BytePos((1 + index) as u32),"}, {"sha": "0fa402b3bf73ebf69698bcde773938a106bbe300", "filename": "tests/compile-fail/cast.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ad0bc66402eb528aedb1d14235fed9a70bcc0a34/tests%2Fcompile-fail%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad0bc66402eb528aedb1d14235fed9a70bcc0a34/tests%2Fcompile-fail%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast.rs?ref=ad0bc66402eb528aedb1d14235fed9a70bcc0a34", "patch": "@@ -2,6 +2,7 @@\n #![plugin(clippy)]\n \n #[deny(cast_precision_loss, cast_possible_truncation, cast_sign_loss)]\n+#[allow(dead_code)]\n fn main() {\n     let i : i32 = 42;\n     let u : u32 = 42;\n@@ -16,7 +17,7 @@ fn main() {\n     (u as u64) as f64; //~ERROR converting from u64 to f64, which causes a loss of precision (u64 is 64 bits wide, but f64's mantissa is only 52 bits wide)\n     i as f64; // Should not trigger the lint\n     u as f64; // Should not trigger the lint\n-    \n+\n     // Test cast_possible_truncation\n     f as i32; //~ERROR casting f32 to i32 may cause truncation of the value\n     f as u32; //~ERROR casting f32 to u32 may cause truncation of the value\n@@ -25,7 +26,32 @@ fn main() {\n               //~^ERROR casting from i32 to u8 loses the sign of the value\n     (f as f64) as f32; //~ERROR casting f64 to f32 may cause truncation of the value\n     i as i8;  //~ERROR casting i32 to i8 may cause truncation of the value\n-    \n+    u as i32; //~ERROR casting u32 to i32 may cause truncation of the value\n+\n     // Test cast_sign_loss\n     i as u32; //~ERROR casting from i32 to u32 loses the sign of the value\n+\n+    // Extra checks for usize/isize\n+    let is : isize = -42;\n+    is as usize; //~ERROR casting from isize to usize loses the sign of the value\n+    is as i8; //~ERROR casting isize to i8 may cause truncation of the value\n+\n+    // FIXME : enable these checks when we figure out a way to make compiletest deal with conditional compilation\n+    /*\n+    #[cfg(target_pointer_width = \"64\")]\n+    fn check_64() {\n+        let is : isize = -42;\n+        let us : usize = 42;\n+        is as f32; //ERROR converting from isize to f32, which causes a loss of precision (isize is 64 bits wide, but f32's mantissa is only 23 bits wide)\n+        us as u32; //ERROR casting usize to u32 may cause truncation of the value\n+        us as u64; // Should not trigger any lint\n+    }\n+    #[cfg(target_pointer_width = \"32\")]\n+    fn check_32() {\n+        let is : isize = -42;\n+        let us : usize = 42;\n+        is as f32; //ERROR converting from isize to f32, which causes a loss of precision (isize is 32 bits wide, but f32's mantissa is only 23 bits wide)\n+        us as u32; // Should not trigger any lint\n+        us as u64; // Should not trigger any lint\n+    }*/\n }\n\\ No newline at end of file"}]}