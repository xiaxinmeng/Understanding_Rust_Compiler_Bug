{"sha": "c5f4789d5b75d3098665b17d318144cb7c54f42a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1ZjQ3ODlkNWI3NWQzMDk4NjY1YjE3ZDMxODE0NGNiN2M1NGY0MmE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-21T06:56:43Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-21T06:56:43Z"}, "message": "Bind pattern slots with ?, drop parens from 0-ary tag constructors, translate 0-ary constructors as constants. Rustc loses ~300kb.", "tree": {"sha": "2d0ef3ef0e85aa7f2453d8bae762c89552a99ed9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d0ef3ef0e85aa7f2453d8bae762c89552a99ed9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5f4789d5b75d3098665b17d318144cb7c54f42a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5f4789d5b75d3098665b17d318144cb7c54f42a", "html_url": "https://github.com/rust-lang/rust/commit/c5f4789d5b75d3098665b17d318144cb7c54f42a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5f4789d5b75d3098665b17d318144cb7c54f42a/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acdec301496d580b60d8eed5690fed18bf97b7e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/acdec301496d580b60d8eed5690fed18bf97b7e0", "html_url": "https://github.com/rust-lang/rust/commit/acdec301496d580b60d8eed5690fed18bf97b7e0"}], "stats": {"total": 960, "additions": 507, "deletions": 453}, "files": [{"sha": "b4233f5b2bc8e35cb1694dba7dde28f57c7f222d", "filename": "src/Makefile", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -384,6 +384,9 @@ self: $(CFG_COMPILER)\n \n NOMINAL_TAG_XFAILS := test/run-pass/mlist.rs\n \n+# Temporarily xfail tests broken by the constant-tags change.\n+\n+CONST_TAG_XFAILS := test/run-pass/generic-tag.rs\n \n # Temporarily xfail some of the task tests, while debugging the\n # overhauled inter-domain messaging system.\n@@ -400,6 +403,7 @@ TASK_XFAILS := test/run-pass/task-comm-8.rs \\\n \n TEST_XFAILS_X86 :=  $(TASK_XFAILS) \\\n                     $(NOMINAL_TAG_XFAILS) \\\n+                    $(CONST_TAG_XFAILS) \\\n                     test/run-pass/child-outlives-parent.rs \\\n                     test/run-pass/clone-with-exterior.rs \\\n                     test/run-pass/constrained-type.rs \\\n@@ -424,6 +428,7 @@ TEST_XFAILS_X86 :=  $(TASK_XFAILS) \\\n \n TEST_XFAILS_LLVM := $(TASK_XFAILS) \\\n                     $(NOMINAL_TAG_XFAILS) \\\n+                    $(CONST_TAG_XFAILS) \\\n                     $(addprefix test/run-pass/, \\\n                       arith-1.rs \\\n                       acyclic-unwind.rs \\"}, {"sha": "0e13b4c0dd5155ac44d57982e838cf124a65c15f", "filename": "src/boot/be/il.ml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fboot%2Fbe%2Fil.ml", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fboot%2Fbe%2Fil.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fil.ml?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -128,7 +128,9 @@ let mem_off (mem:mem) (off:Asm.expr64) : mem =\n         Abs e -> Abs (addto e)\n       | RegIn (r, None) -> RegIn (r, Some off)\n       | RegIn (r, Some e) -> RegIn (r, Some (addto e))\n-      | Spill _ -> bug () \"Adding offset to spill slot\"\n+      | Spill _ ->\n+          bug () \"Adding offset %s to spill slot\"\n+            (Asm.string_of_expr64 off)\n ;;\n \n let mem_off_imm (mem:mem) (imm:int64) : mem ="}, {"sha": "4173eb53b0664d55de3adc347bd2343b66b7cf93", "filename": "src/boot/fe/item.ml", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fboot%2Ffe%2Fitem.ml", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fboot%2Ffe%2Fitem.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fitem.ml?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -255,12 +255,11 @@ and parse_stmts (ps:pstate) : Ast.stmt array =\n           bump ps;\n           let rec parse_pat ps  =\n             match peek ps with\n-                IDENT _ ->\n+                QUES ->\n                   let apos = lexpos ps in\n-                  let name = Pexp.parse_name ps in\n-                  let bpos = lexpos ps in\n-\n-                    if peek ps != LPAREN then\n+                    bump ps;\n+                    let name = Pexp.parse_name ps in\n+                    let bpos = lexpos ps in\n                       begin\n                         match name with\n                             Ast.NAME_base (Ast.BASE_ident ident) ->\n@@ -273,11 +272,19 @@ and parse_stmts (ps:pstate) : Ast.stmt array =\n                                                  ident))\n                           |_ -> raise (unexpected ps)\n                       end\n-                    else\n-                      let lv = name_to_lval apos bpos name in\n-                      let parse_pat ps = either_get_left (parse_pat ps) in\n-                        Left\n-                          (Ast.PAT_tag (lv, paren_comma_list parse_pat ps))\n+\n+              | IDENT _ ->\n+                  let apos = lexpos ps in\n+                  let name = Pexp.parse_name ps in\n+                  let bpos = lexpos ps in\n+                  let lv = name_to_lval apos bpos name in\n+                  let parse_pat ps = either_get_left (parse_pat ps) in\n+                  let args =\n+                    match peek ps with\n+                        LPAREN -> paren_comma_list parse_pat ps\n+                      | _ -> [| |]\n+                  in\n+                    Left (Ast.PAT_tag (lv, args))\n \n               | LIT_INT _\n               | LIT_UINT _\n@@ -874,9 +881,16 @@ and parse_tag_item\n           incr j;\n           ((span ps apos bpos s), \"_\" ^ string_of_int (!j))\n       in\n-      let res = match peek ps with\n-              LPAREN -> paren_comma_list parse_ctor_slot ps\n-        | _ -> raise (err \"tag variant missing argument list\" ps)\n+      let res =\n+        match peek ps with\n+            LPAREN ->\n+              let slots = paren_comma_list parse_ctor_slot ps in\n+                if Array.length slots = 0\n+                then\n+                  raise (err (\"empty argument list to tag constructor\") ps)\n+                else slots\n+\n+          | _ -> [| |]\n       in\n         expect ps SEMI;\n         res"}, {"sha": "763b50c91d97cac57005f3d2c5aeb31d0e8cc7fc", "filename": "src/boot/fe/lexer.mll", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fboot%2Ffe%2Flexer.mll", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fboot%2Ffe%2Flexer.mll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Flexer.mll?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -244,6 +244,7 @@ rule token = parse\n | ','                          { COMMA      }\n | ';'                          { SEMI       }\n | ':'                          { COLON      }\n+| '?'                          { QUES       }\n | \"<-\"                         { LARROW     }\n | \"<|\"                         { SEND       }\n | \"->\"                         { RARROW     }"}, {"sha": "85dd2a13f2d65da6c1ecf08f7ed4dfec3fbbde72", "filename": "src/boot/fe/token.ml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fboot%2Ffe%2Ftoken.ml", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fboot%2Ffe%2Ftoken.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Ftoken.ml?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -33,6 +33,7 @@ type token =\n   | COMMA\n   | SEMI\n   | COLON\n+  | QUES\n   | RARROW\n   | SEND\n   | LARROW\n@@ -187,6 +188,7 @@ let rec string_of_tok t =\n     | COMMA      -> \",\"\n     | SEMI       -> \";\"\n     | COLON      -> \":\"\n+    | QUES       -> \"?\"\n     | RARROW     -> \"->\"\n     | SEND       -> \"<|\"\n     | LARROW     -> \"<-\""}, {"sha": "0b994145be7bb5f2ec8cfb3b26a7aeea7c5925de", "filename": "src/boot/me/layout.ml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fboot%2Fme%2Flayout.ml", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fboot%2Fme%2Flayout.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Flayout.ml?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -296,7 +296,7 @@ let layout_visitor\n             layout_header i.id\n               (header_slot_ids f.Ast.fn_input_slots)\n \n-        | Ast.MOD_ITEM_tag (hdr, _, _) ->\n+        | Ast.MOD_ITEM_tag (hdr, _, _) when Array.length hdr <> 0 ->\n             enter_frame i.id;\n             layout_header i.id\n               (header_slot_ids hdr)\n@@ -319,8 +319,9 @@ let layout_visitor\n     begin\n       match i.node.Ast.decl_item with\n           Ast.MOD_ITEM_fn _\n-        | Ast.MOD_ITEM_tag _\n         | Ast.MOD_ITEM_obj _ -> leave_frame ()\n+        | Ast.MOD_ITEM_tag (hdr, _, _) when Array.length hdr <> 0 ->\n+            leave_frame()\n         | _ -> ()\n     end\n   in"}, {"sha": "b5d7d65f6300750ec29988b8e6f0a80404e1adbb", "filename": "src/boot/me/resolve.ml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fboot%2Fme%2Fresolve.ml", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fboot%2Fme%2Fresolve.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fresolve.ml?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -722,7 +722,9 @@ let pattern_resolving_visitor\n      * asking for its arity, it doesn't matter that the possibly parametric\n      * tag type has its parameters unbound here. *)\n     let tag_ty =\n-      fn_output_ty (Hashtbl.find cx.ctxt_all_item_types tag_ctor_id)\n+      match Hashtbl.find cx.ctxt_all_item_types tag_ctor_id with\n+          Ast.TY_tag t -> Ast.TY_tag t\n+        | ft -> fn_output_ty ft\n     in\n       begin\n         match tag_ty with"}, {"sha": "fd7d2709e9f23f8b495fc71d78fa731add8dc41e", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -1483,23 +1483,29 @@ let ty_of_mod_item (item:Ast.mod_item) : Ast.ty =\n           (Ast.TY_fn (tsig, taux))\n \n     | Ast.MOD_ITEM_tag (hdr, tid, _) ->\n-        let taux = { Ast.fn_effect = Ast.PURE;\n-                     Ast.fn_is_iter = false }\n-        in\n-        let inputs = Array.map (fun (s, _) -> s.node) hdr in\n         let args =\n           Array.map\n             (fun p -> Ast.TY_param (snd p.node))\n             item.node.Ast.decl_params\n         in\n-        let tsig = { Ast.sig_input_slots = inputs;\n-                     Ast.sig_input_constrs = [| |];\n-                     Ast.sig_output_slot =\n-            local_slot\n-              (Ast.TY_tag { Ast.tag_id = tid;\n-                            Ast.tag_args = args } ) }\n+        let ttag =\n+          { Ast.tag_id = tid;\n+            Ast.tag_args = args }\n         in\n-          (Ast.TY_fn (tsig, taux))\n+          if Array.length hdr = 0\n+          then Ast.TY_tag ttag\n+          else\n+            let taux = { Ast.fn_effect = Ast.PURE;\n+                         Ast.fn_is_iter = false }\n+            in\n+            let inputs = Array.map (fun (s, _) -> s.node) hdr in\n+            let tsig = { Ast.sig_input_slots = inputs;\n+                         Ast.sig_input_constrs = [| |];\n+                         Ast.sig_output_slot =\n+                local_slot\n+                  (Ast.TY_tag ttag ) }\n+            in\n+              (Ast.TY_fn (tsig, taux))\n ;;\n \n (* Scopes and the visitor that builds them. *)"}, {"sha": "ba0c47716b5e37434d23a8609a2e43669753fd85", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -1054,10 +1054,14 @@ let trans_visitor\n       : (Ast.ty * const) =\n     assert (lval_base_is_item cx lv);\n     let item = lval_item cx lv in\n-      check_concrete item.node.Ast.decl_params ();\n       match item.node.Ast.decl_item with\n           Ast.MOD_ITEM_const (_, Some e) -> trans_const_expr e\n \n+        | Ast.MOD_ITEM_tag (hdr, _, i) when Array.length hdr = 0 ->\n+            (lval_ty cx lv,\n+             CONST_frag (Asm.WORD (word_ty_mach,\n+                                   Asm.IMM (Int64.of_int i))))\n+\n         | _ -> bug ()\n             \"trans_const_lval called on unsupported item lval '%a'\"\n               Ast.sprintf_lval lv\n@@ -1069,9 +1073,8 @@ let trans_visitor\n     match trans_const_lval lv with\n \n         (ty, CONST_val v) ->\n-          let f tm =\n-            (Il.Reg (force_to_reg (imm_of_ty v tm)), ty)\n-          in\n+          let r tm = Il.Reg (force_to_reg (imm_of_ty v tm)) in\n+          let f tm = (r tm, ty) in\n             begin\n               match ty with\n                   Ast.TY_mach tm -> f tm\n@@ -1080,18 +1083,22 @@ let trans_visitor\n                 | Ast.TY_bool -> f TY_u8\n                 | Ast.TY_char -> f TY_u32\n                 | Ast.TY_nil -> (nil_ptr, ty)\n+\n                 | _ -> bug ()\n                     \"trans_lval_item on %a: unexpected type %a\"\n                       Ast.sprintf_lval lv Ast.sprintf_ty ty\n             end\n \n       | (ty, CONST_frag f) ->\n           let item = lval_item cx lv in\n-            (crate_rel_to_ptr\n-               (trans_crate_rel_data_operand\n-                  (DATA_const item.id)\n-                  (fun _ -> f))\n-               (referent_type cx ty), ty)\n+          let ptr =\n+            crate_rel_to_ptr\n+              (trans_crate_rel_data_operand\n+                 (DATA_const item.id)\n+                 (fun _ -> f))\n+              (referent_type cx ty)\n+          in\n+            (deref ptr, ty)\n \n   and trans_lval_full\n       (initializing:bool)\n@@ -5430,7 +5437,7 @@ let trans_visitor\n             \"Trans.required_rust_fn on unexpected form of require library\"\n   in\n \n-  let trans_tag\n+  let trans_tag_fn\n       (n:Ast.ident)\n       (tagid:node_id)\n       (tag:(Ast.header_slots * opaque_id * int))\n@@ -5473,6 +5480,16 @@ let trans_visitor\n       trans_frame_exit tagid true;\n   in\n \n+  let trans_tag\n+      (n:Ast.ident)\n+      (tagid:node_id)\n+      (tag:(Ast.header_slots * opaque_id * int))\n+      : unit =\n+    let (header_tup, _, _) = tag in\n+      if Array.length header_tup <> 0\n+      then trans_tag_fn n tagid tag\n+  in\n+\n   let enter_file_for id =\n     if Hashtbl.mem cx.ctxt_item_files id\n     then Stack.push id curr_file"}, {"sha": "2e27553712aa08bfaa3be8371753eb3075f78440", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -711,6 +711,8 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n             match constr_ty with\n                 Ast.TY_fn (ty_sig, _) ->\n                   Array.map get_slot_ty ty_sig.Ast.sig_input_slots\n+              | Ast.TY_tag _ ->\n+                  [||]\n               | _ -> type_error \"constructor function\" constr_ty\n           in\n           Common.arr_iter2 check_pat arg_tys arg_pats"}, {"sha": "dcea02de798ac5f257ef06546f6cb545c39b9c94", "filename": "src/comp/fe/ast.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fcomp%2Ffe%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fcomp%2Ffe%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffe%2Fast.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -36,20 +36,20 @@ tag atom {\n tag lit {\n     lit_char(char);\n     lit_int(int);\n-    lit_nil();\n+    lit_nil;\n     lit_bool(bool);\n }\n \n tag ty {\n-    ty_nil();\n-    ty_bool();\n-    ty_int();\n-    ty_char();\n+    ty_nil;\n+    ty_bool;\n+    ty_int;\n+    ty_char;\n }\n \n tag mode {\n-    val();\n-    alias();\n+    val;\n+    alias;\n }\n \n type slot = rec(ty ty, mode mode);"}, {"sha": "f68fcc058c385c1d44cf82234455d849fbedd51a", "filename": "src/comp/fe/lexer.rs", "status": "modified", "additions": 110, "deletions": 110, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fcomp%2Ffe%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fcomp%2Ffe%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffe%2Flexer.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -94,100 +94,100 @@ fn new_reader(stdio_reader rdr, str filename) -> reader\n     auto keywords = new_str_hash[token.token]();\n     auto reserved = new_str_hash[()]();\n \n-    keywords.insert(\"mod\", token.MOD());\n-    keywords.insert(\"use\", token.USE());\n-    keywords.insert(\"meta\", token.META());\n-    keywords.insert(\"auth\", token.AUTH());\n+    keywords.insert(\"mod\", token.MOD);\n+    keywords.insert(\"use\", token.USE);\n+    keywords.insert(\"meta\", token.META);\n+    keywords.insert(\"auth\", token.AUTH);\n \n-    keywords.insert(\"syntax\", token.SYNTAX());\n+    keywords.insert(\"syntax\", token.SYNTAX);\n \n-    keywords.insert(\"if\", token.IF());\n-    keywords.insert(\"else\", token.ELSE());\n-    keywords.insert(\"while\", token.WHILE());\n-    keywords.insert(\"do\", token.DO());\n-    keywords.insert(\"alt\", token.ALT());\n-    keywords.insert(\"case\", token.CASE());\n+    keywords.insert(\"if\", token.IF);\n+    keywords.insert(\"else\", token.ELSE);\n+    keywords.insert(\"while\", token.WHILE);\n+    keywords.insert(\"do\", token.DO);\n+    keywords.insert(\"alt\", token.ALT);\n+    keywords.insert(\"case\", token.CASE);\n \n-    keywords.insert(\"for\", token.FOR());\n-    keywords.insert(\"each\", token.EACH());\n-    keywords.insert(\"put\", token.PUT());\n-    keywords.insert(\"ret\", token.RET());\n-    keywords.insert(\"be\", token.BE());\n+    keywords.insert(\"for\", token.FOR);\n+    keywords.insert(\"each\", token.EACH);\n+    keywords.insert(\"put\", token.PUT);\n+    keywords.insert(\"ret\", token.RET);\n+    keywords.insert(\"be\", token.BE);\n \n-    keywords.insert(\"fail\", token.FAIL());\n-    keywords.insert(\"drop\", token.DROP());\n+    keywords.insert(\"fail\", token.FAIL);\n+    keywords.insert(\"drop\", token.DROP);\n \n-    keywords.insert(\"type\", token.TYPE());\n-    keywords.insert(\"check\", token.CHECK());\n-    keywords.insert(\"claim\", token.CLAIM());\n-    keywords.insert(\"prove\", token.PROVE());\n+    keywords.insert(\"type\", token.TYPE);\n+    keywords.insert(\"check\", token.CHECK);\n+    keywords.insert(\"claim\", token.CLAIM);\n+    keywords.insert(\"prove\", token.PROVE);\n \n-    keywords.insert(\"io\", token.IO());\n-    keywords.insert(\"state\", token.STATE());\n-    keywords.insert(\"unsafe\", token.UNSAFE());\n+    keywords.insert(\"io\", token.IO);\n+    keywords.insert(\"state\", token.STATE);\n+    keywords.insert(\"unsafe\", token.UNSAFE);\n \n-    keywords.insert(\"native\", token.NATIVE());\n-    keywords.insert(\"mutable\", token.MUTABLE());\n-    keywords.insert(\"auto\", token.AUTO());\n+    keywords.insert(\"native\", token.NATIVE);\n+    keywords.insert(\"mutable\", token.MUTABLE);\n+    keywords.insert(\"auto\", token.AUTO);\n \n-    keywords.insert(\"fn\", token.FN());\n-    keywords.insert(\"iter\", token.ITER());\n+    keywords.insert(\"fn\", token.FN);\n+    keywords.insert(\"iter\", token.ITER);\n \n-    keywords.insert(\"import\", token.IMPORT());\n-    keywords.insert(\"export\", token.EXPORT());\n+    keywords.insert(\"import\", token.IMPORT);\n+    keywords.insert(\"export\", token.EXPORT);\n \n-    keywords.insert(\"let\", token.LET());\n-    keywords.insert(\"const\", token.CONST());\n+    keywords.insert(\"let\", token.LET);\n+    keywords.insert(\"const\", token.CONST);\n \n-    keywords.insert(\"log\", token.LOG());\n-    keywords.insert(\"spawn\", token.SPAWN());\n-    keywords.insert(\"thread\", token.THREAD());\n-    keywords.insert(\"yield\", token.YIELD());\n-    keywords.insert(\"join\", token.JOIN());\n+    keywords.insert(\"log\", token.LOG);\n+    keywords.insert(\"spawn\", token.SPAWN);\n+    keywords.insert(\"thread\", token.THREAD);\n+    keywords.insert(\"yield\", token.YIELD);\n+    keywords.insert(\"join\", token.JOIN);\n \n-    keywords.insert(\"bool\", token.BOOL());\n+    keywords.insert(\"bool\", token.BOOL);\n \n-    keywords.insert(\"int\", token.INT());\n-    keywords.insert(\"uint\", token.UINT());\n-    keywords.insert(\"float\", token.FLOAT());\n+    keywords.insert(\"int\", token.INT);\n+    keywords.insert(\"uint\", token.UINT);\n+    keywords.insert(\"float\", token.FLOAT);\n \n-    keywords.insert(\"char\", token.CHAR());\n-    keywords.insert(\"str\", token.STR());\n+    keywords.insert(\"char\", token.CHAR);\n+    keywords.insert(\"str\", token.STR);\n \n \n-    keywords.insert(\"rec\", token.REC());\n-    keywords.insert(\"tup\", token.TUP());\n-    keywords.insert(\"tag\", token.TAG());\n-    keywords.insert(\"vec\", token.VEC());\n-    keywords.insert(\"any\", token.ANY());\n+    keywords.insert(\"rec\", token.REC);\n+    keywords.insert(\"tup\", token.TUP);\n+    keywords.insert(\"tag\", token.TAG);\n+    keywords.insert(\"vec\", token.VEC);\n+    keywords.insert(\"any\", token.ANY);\n \n-    keywords.insert(\"obj\", token.OBJ());\n+    keywords.insert(\"obj\", token.OBJ);\n \n-    keywords.insert(\"port\", token.PORT());\n-    keywords.insert(\"chan\", token.CHAN());\n+    keywords.insert(\"port\", token.PORT);\n+    keywords.insert(\"chan\", token.CHAN);\n \n-    keywords.insert(\"task\", token.TASK());\n+    keywords.insert(\"task\", token.TASK);\n \n     keywords.insert(\"true\", token.LIT_BOOL(true));\n     keywords.insert(\"false\", token.LIT_BOOL(false));\n \n-    keywords.insert(\"in\", token.IN());\n+    keywords.insert(\"in\", token.IN);\n \n-    keywords.insert(\"as\", token.AS());\n-    keywords.insert(\"with\", token.WITH());\n+    keywords.insert(\"as\", token.AS);\n+    keywords.insert(\"with\", token.WITH);\n \n-    keywords.insert(\"bind\", token.BIND());\n+    keywords.insert(\"bind\", token.BIND);\n \n-    keywords.insert(\"u8\", token.MACH(common.ty_u8()));\n-    keywords.insert(\"u16\", token.MACH(common.ty_u16()));\n-    keywords.insert(\"u32\", token.MACH(common.ty_u32()));\n-    keywords.insert(\"u64\", token.MACH(common.ty_u64()));\n-    keywords.insert(\"i8\", token.MACH(common.ty_i8()));\n-    keywords.insert(\"i16\", token.MACH(common.ty_i16()));\n-    keywords.insert(\"i32\", token.MACH(common.ty_i32()));\n-    keywords.insert(\"i64\", token.MACH(common.ty_i64()));\n-    keywords.insert(\"f32\", token.MACH(common.ty_f32()));\n-    keywords.insert(\"f64\", token.MACH(common.ty_f64()));\n+    keywords.insert(\"u8\", token.MACH(common.ty_u8));\n+    keywords.insert(\"u16\", token.MACH(common.ty_u16));\n+    keywords.insert(\"u32\", token.MACH(common.ty_u32));\n+    keywords.insert(\"u64\", token.MACH(common.ty_u64));\n+    keywords.insert(\"i8\", token.MACH(common.ty_i8));\n+    keywords.insert(\"i16\", token.MACH(common.ty_i16));\n+    keywords.insert(\"i32\", token.MACH(common.ty_i32));\n+    keywords.insert(\"i64\", token.MACH(common.ty_i64));\n+    keywords.insert(\"f32\", token.MACH(common.ty_f32));\n+    keywords.insert(\"f64\", token.MACH(common.ty_f64));\n \n     ret reader(rdr, filename, rdr.getc() as char, rdr.getc() as char,\n                1u, 1u, 1u, 1u, keywords, reserved);\n@@ -305,7 +305,7 @@ state fn next_token(reader rdr) -> token.token {\n \n     consume_any_whitespace(rdr);\n \n-    if (rdr.is_eof()) { ret token.EOF(); }\n+    if (rdr.is_eof()) { ret token.EOF; }\n \n     auto c = rdr.curr();\n \n@@ -372,40 +372,40 @@ state fn next_token(reader rdr) -> token.token {\n \n     alt (c) {\n         // One-byte tokens.\n-        case (':') { rdr.bump(); ret token.COLON(); }\n-        case (';') { rdr.bump(); ret token.SEMI(); }\n-        case (',') { rdr.bump(); ret token.COMMA(); }\n-        case ('.') { rdr.bump(); ret token.DOT(); }\n-        case ('(') { rdr.bump(); ret token.LPAREN(); }\n-        case (')') { rdr.bump(); ret token.RPAREN(); }\n-        case ('{') { rdr.bump(); ret token.LBRACE(); }\n-        case ('}') { rdr.bump(); ret token.RBRACE(); }\n-        case ('[') { rdr.bump(); ret token.LBRACKET(); }\n-        case (']') { rdr.bump(); ret token.RBRACKET(); }\n-        case ('@') { rdr.bump(); ret token.AT(); }\n-        case ('#') { rdr.bump(); ret token.POUND(); }\n-        case ('_') { rdr.bump(); ret token.UNDERSCORE(); }\n-        case ('~') { rdr.bump(); ret token.TILDE(); }\n+        case (':') { rdr.bump(); ret token.COLON; }\n+        case (';') { rdr.bump(); ret token.SEMI; }\n+        case (',') { rdr.bump(); ret token.COMMA; }\n+        case ('.') { rdr.bump(); ret token.DOT; }\n+        case ('(') { rdr.bump(); ret token.LPAREN; }\n+        case (')') { rdr.bump(); ret token.RPAREN; }\n+        case ('{') { rdr.bump(); ret token.LBRACE; }\n+        case ('}') { rdr.bump(); ret token.RBRACE; }\n+        case ('[') { rdr.bump(); ret token.LBRACKET; }\n+        case (']') { rdr.bump(); ret token.RBRACKET; }\n+        case ('@') { rdr.bump(); ret token.AT; }\n+        case ('#') { rdr.bump(); ret token.POUND; }\n+        case ('_') { rdr.bump(); ret token.UNDERSCORE; }\n+        case ('~') { rdr.bump(); ret token.TILDE; }\n \n \n         // Multi-byte tokens.\n         case ('=') {\n             rdr.bump();\n             if (rdr.curr() == '=') {\n                 rdr.bump();\n-                ret token.EQEQ();\n+                ret token.EQEQ;\n             } else {\n-                ret token.EQ();\n+                ret token.EQ;\n             }\n         }\n \n         case ('!') {\n             rdr.bump();\n             if (rdr.curr() == '=') {\n                 rdr.bump();\n-                ret token.NE();\n+                ret token.NE;\n             } else {\n-                ret token.NOT();\n+                ret token.NOT;\n             }\n         }\n \n@@ -414,21 +414,21 @@ state fn next_token(reader rdr) -> token.token {\n             alt (rdr.curr()) {\n                 case ('=') {\n                     rdr.bump();\n-                    ret token.LE();\n+                    ret token.LE;\n                 }\n                 case ('<') {\n-                    ret binop(rdr, token.LSL());\n+                    ret binop(rdr, token.LSL);\n                 }\n                 case ('-') {\n                     rdr.bump();\n-                    ret token.LARROW();\n+                    ret token.LARROW;\n                 }\n                 case ('|') {\n                     rdr.bump();\n-                    ret token.SEND();\n+                    ret token.SEND;\n                 }\n                 case (_) {\n-                    ret token.LT();\n+                    ret token.LT;\n                 }\n             }\n         }\n@@ -438,20 +438,20 @@ state fn next_token(reader rdr) -> token.token {\n             alt (rdr.curr()) {\n                 case ('=') {\n                     rdr.bump();\n-                    ret token.GE();\n+                    ret token.GE;\n                 }\n \n                 case ('>') {\n                     if (rdr.next() == '>') {\n                         rdr.bump();\n-                        ret binop(rdr, token.ASR());\n+                        ret binop(rdr, token.ASR);\n                     } else {\n-                        ret binop(rdr, token.LSR());\n+                        ret binop(rdr, token.LSR);\n                     }\n                 }\n \n                 case (_) {\n-                    ret token.GT();\n+                    ret token.GT;\n                 }\n             }\n         }\n@@ -467,7 +467,7 @@ state fn next_token(reader rdr) -> token.token {\n                     case ('\\\\') { rdr.bump(); c2 = '\\\\'; }\n                     case ('\\'') { rdr.bump(); c2 = '\\''; }\n                     // FIXME: unicode numeric escapes.\n-                    case (c2) {\n+                    case (?c2) {\n                         log \"unknown character escape\";\n                         log c2;\n                         fail;\n@@ -512,7 +512,7 @@ state fn next_token(reader rdr) -> token.token {\n                                 accum_str += '\"' as u8;\n                             }\n                             // FIXME: unicode numeric escapes.\n-                            case (c2) {\n+                            case (?c2) {\n                                 log \"unknown string escape\";\n                                 log c2;\n                                 fail;\n@@ -533,57 +533,57 @@ state fn next_token(reader rdr) -> token.token {\n             if (rdr.next() == '>') {\n                 rdr.bump();\n                 rdr.bump();\n-                ret token.RARROW();\n+                ret token.RARROW;\n             } else {\n-                ret binop(rdr, token.MINUS());\n+                ret binop(rdr, token.MINUS);\n             }\n         }\n \n         case ('&') {\n             if (rdr.next() == '&') {\n                 rdr.bump();\n                 rdr.bump();\n-                ret token.ANDAND();\n+                ret token.ANDAND;\n             } else {\n-                ret binop(rdr, token.AND());\n+                ret binop(rdr, token.AND);\n             }\n         }\n \n         case ('|') {\n             if (rdr.next() == '|') {\n                 rdr.bump();\n                 rdr.bump();\n-                ret token.OROR();\n+                ret token.OROR;\n             } else {\n-                ret binop(rdr, token.OR());\n+                ret binop(rdr, token.OR);\n             }\n         }\n \n         case ('+') {\n-            ret binop(rdr, token.PLUS());\n+            ret binop(rdr, token.PLUS);\n         }\n \n         case ('*') {\n-            ret binop(rdr, token.STAR());\n+            ret binop(rdr, token.STAR);\n         }\n \n         case ('/') {\n-            ret binop(rdr, token.STAR());\n+            ret binop(rdr, token.STAR);\n         }\n \n         case ('^') {\n-            ret binop(rdr, token.CARET());\n+            ret binop(rdr, token.CARET);\n         }\n \n         case ('%') {\n-            ret binop(rdr, token.PERCENT());\n+            ret binop(rdr, token.PERCENT);\n         }\n \n     }\n \n     log \"lexer stopping at \";\n     log c;\n-    ret token.EOF();\n+    ret token.EOF;\n }\n \n "}, {"sha": "24228a8a0e5a627ea08dbcefa412dd2db16dafbb", "filename": "src/comp/fe/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fcomp%2Ffe%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fcomp%2Ffe%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffe%2Fparser.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -64,7 +64,7 @@ state fn expect(parser p, token.token t) {\n \n state fn parse_ident(parser p) -> ast.ident {\n     alt (p.peek()) {\n-        case (token.IDENT(i)) { ret i; }\n+        case (token.IDENT(?i)) { ret i; }\n         case (_) {\n             p.err(\"expecting ident\");\n             fail;\n@@ -77,10 +77,10 @@ state fn parse_item(parser p) -> tup(ast.ident, ast.item) {\n         case (token.FN()) {\n             p.bump();\n             auto id = parse_ident(p);\n-            expect(p, token.LPAREN());\n+            expect(p, token.LPAREN);\n             let vec[rec(ast.slot slot, ast.ident ident)] inputs = vec();\n             let vec[@ast.stmt] body = vec();\n-            auto output = rec(ty = ast.ty_nil(), mode = ast.val() );\n+            auto output = rec(ty = ast.ty_nil, mode = ast.val );\n             let ast._fn f = rec(inputs = inputs,\n                                 output = output,\n                                 body = body);"}, {"sha": "ca58d4fe97195fb25f571f385b872c40ad038520", "filename": "src/comp/fe/token.rs", "status": "modified", "additions": 209, "deletions": 209, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fcomp%2Ffe%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fcomp%2Ffe%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffe%2Ftoken.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -4,114 +4,114 @@ import std._int;\n import std._uint;\n \n tag binop {\n-    PLUS();\n-    MINUS();\n-    STAR();\n-    SLASH();\n-    PERCENT();\n-    CARET();\n-    AND();\n-    OR();\n-    LSL();\n-    LSR();\n-    ASR();\n+    PLUS;\n+    MINUS;\n+    STAR;\n+    SLASH;\n+    PERCENT;\n+    CARET;\n+    AND;\n+    OR;\n+    LSL;\n+    LSR;\n+    ASR;\n }\n \n tag token {\n     /* Expression-operator symbols. */\n-    EQ();\n-    LT();\n-    LE();\n-    EQEQ();\n-    NE();\n-    GE();\n-    GT();\n-    ANDAND();\n-    OROR();\n-    NOT();\n-    TILDE();\n+    EQ;\n+    LT;\n+    LE;\n+    EQEQ;\n+    NE;\n+    GE;\n+    GT;\n+    ANDAND;\n+    OROR;\n+    NOT;\n+    TILDE;\n \n     BINOP(binop);\n     BINOPEQ(binop);\n \n-    AS();\n-    WITH();\n+    AS;\n+    WITH;\n \n     /* Structural symbols */\n-    AT();\n-    DOT();\n-    COMMA();\n-    SEMI();\n-    COLON();\n-    RARROW();\n-    SEND();\n-    LARROW();\n-    LPAREN();\n-    RPAREN();\n-    LBRACKET();\n-    RBRACKET();\n-    LBRACE();\n-    RBRACE();\n+    AT;\n+    DOT;\n+    COMMA;\n+    SEMI;\n+    COLON;\n+    RARROW;\n+    SEND;\n+    LARROW;\n+    LPAREN;\n+    RPAREN;\n+    LBRACKET;\n+    RBRACKET;\n+    LBRACE;\n+    RBRACE;\n \n     /* Module and crate keywords */\n-    MOD();\n-    USE();\n-    AUTH();\n-    META();\n+    MOD;\n+    USE;\n+    AUTH;\n+    META;\n \n     /* Metaprogramming keywords */\n-    SYNTAX();\n-    POUND();\n+    SYNTAX;\n+    POUND;\n \n     /* Statement keywords */\n-    IF();\n-    ELSE();\n-    DO();\n-    WHILE();\n-    ALT();\n-    CASE();\n-\n-    FAIL();\n-    DROP();\n-\n-    IN();\n-    FOR();\n-    EACH();\n-    PUT();\n-    RET();\n-    BE();\n+    IF;\n+    ELSE;\n+    DO;\n+    WHILE;\n+    ALT;\n+    CASE;\n+\n+    FAIL;\n+    DROP;\n+\n+    IN;\n+    FOR;\n+    EACH;\n+    PUT;\n+    RET;\n+    BE;\n \n     /* Type and type-state keywords */\n-    TYPE();\n-    CHECK();\n-    CLAIM();\n-    PROVE();\n+    TYPE;\n+    CHECK;\n+    CLAIM;\n+    PROVE;\n \n     /* Effect keywords */\n-    IO();\n-    STATE();\n-    UNSAFE();\n+    IO;\n+    STATE;\n+    UNSAFE;\n \n     /* Type qualifiers */\n-    NATIVE();\n-    AUTO();\n-    MUTABLE();\n+    NATIVE;\n+    AUTO;\n+    MUTABLE;\n \n     /* Name management */\n-    IMPORT();\n-    EXPORT();\n+    IMPORT;\n+    EXPORT;\n \n     /* Value / stmt declarators */\n-    LET();\n-    CONST();\n+    LET;\n+    CONST;\n \n     /* Magic runtime services */\n-    LOG();\n-    SPAWN();\n-    BIND();\n-    THREAD();\n-    YIELD();\n-    JOIN();\n+    LOG;\n+    SPAWN;\n+    BIND;\n+    THREAD;\n+    YIELD;\n+    JOIN;\n \n     /* Literals */\n     LIT_INT(int);\n@@ -124,213 +124,213 @@ tag token {\n     /* Name components */\n     IDENT(str);\n     IDX(int);\n-    UNDERSCORE();\n+    UNDERSCORE;\n \n     /* Reserved type names */\n-    BOOL();\n-    INT();\n-    UINT();\n-    FLOAT();\n-    CHAR();\n-    STR();\n+    BOOL;\n+    INT;\n+    UINT;\n+    FLOAT;\n+    CHAR;\n+    STR;\n     MACH(ty_mach);\n \n     /* Algebraic type constructors */\n-    REC();\n-    TUP();\n-    TAG();\n-    VEC();\n-    ANY();\n+    REC;\n+    TUP;\n+    TAG;\n+    VEC;\n+    ANY;\n \n     /* Callable type constructors */\n-    FN();\n-    ITER();\n+    FN;\n+    ITER;\n \n     /* Object type */\n-    OBJ();\n+    OBJ;\n \n     /* Comm and task types */\n-    CHAN();\n-    PORT();\n-    TASK();\n+    CHAN;\n+    PORT;\n+    TASK;\n \n     BRACEQUOTE(str);\n-    EOF();\n+    EOF;\n }\n \n fn binop_to_str(binop o) -> str {\n     alt (o) {\n-        case (PLUS()) { ret \"+\"; }\n-        case (MINUS()) { ret \"-\"; }\n-        case (STAR()) { ret \"*\"; }\n-        case (SLASH()) { ret \"/\"; }\n-        case (PERCENT()) { ret \"%\"; }\n-        case (CARET()) { ret \"^\"; }\n-        case (AND()) { ret \"&\"; }\n-        case (OR()) { ret \"|\"; }\n-        case (LSL()) { ret \"<<\"; }\n-        case (LSR()) { ret \">>\"; }\n-        case (ASR()) { ret \">>>\"; }\n+        case (PLUS) { ret \"+\"; }\n+        case (MINUS) { ret \"-\"; }\n+        case (STAR) { ret \"*\"; }\n+        case (SLASH) { ret \"/\"; }\n+        case (PERCENT) { ret \"%\"; }\n+        case (CARET) { ret \"^\"; }\n+        case (AND) { ret \"&\"; }\n+        case (OR) { ret \"|\"; }\n+        case (LSL) { ret \"<<\"; }\n+        case (LSR) { ret \">>\"; }\n+        case (ASR) { ret \">>>\"; }\n     }\n }\n \n fn to_str(token t) -> str {\n     alt (t) {\n \n-        case (EQ()) { ret \"=\"; }\n-        case (LT()) { ret \"<\"; }\n-        case (LE()) { ret \"<=\"; }\n-        case (EQEQ()) { ret \"==\"; }\n-        case (NE()) { ret \"!=\"; }\n-        case (GE()) { ret \">=\"; }\n-        case (GT()) { ret \">\"; }\n-        case (NOT()) { ret \"!\"; }\n-        case (TILDE()) { ret \"~\"; }\n-        case (OROR()) { ret \"||\"; }\n-        case (ANDAND()) { ret \"&&\"; }\n+        case (EQ) { ret \"=\"; }\n+        case (LT) { ret \"<\"; }\n+        case (LE) { ret \"<=\"; }\n+        case (EQEQ) { ret \"==\"; }\n+        case (NE) { ret \"!=\"; }\n+        case (GE) { ret \">=\"; }\n+        case (GT) { ret \">\"; }\n+        case (NOT) { ret \"!\"; }\n+        case (TILDE) { ret \"~\"; }\n+        case (OROR) { ret \"||\"; }\n+        case (ANDAND) { ret \"&&\"; }\n \n-        case (BINOP(op)) { ret binop_to_str(op); }\n-        case (BINOPEQ(op)) { ret binop_to_str(op) + \"=\"; }\n+        case (BINOP(?op)) { ret binop_to_str(op); }\n+        case (BINOPEQ(?op)) { ret binop_to_str(op) + \"=\"; }\n \n-        case (AS()) { ret \"as\"; }\n-        case (WITH()) { ret \"with\"; }\n+        case (AS) { ret \"as\"; }\n+        case (WITH) { ret \"with\"; }\n \n \n         /* Structural symbols */\n-        case (AT()) { ret \"@\"; }\n-        case (DOT()) { ret \".\"; }\n-        case (COMMA()) { ret \",\"; }\n-        case (SEMI()) { ret \";\"; }\n-        case (COLON()) { ret \":\"; }\n-        case (RARROW()) { ret \"->\"; }\n-        case (SEND()) { ret \"<|\"; }\n-        case (LARROW()) { ret \"<-\"; }\n-        case (LPAREN()) { ret \"(\"; }\n-        case (RPAREN()) { ret \")\"; }\n-        case (LBRACKET()) { ret \"[\"; }\n-        case (RBRACKET()) { ret \"]\"; }\n-        case (LBRACE()) { ret \"{\"; }\n-        case (RBRACE()) { ret \"}\"; }\n+        case (AT) { ret \"@\"; }\n+        case (DOT) { ret \".\"; }\n+        case (COMMA) { ret \",\"; }\n+        case (SEMI) { ret \";\"; }\n+        case (COLON) { ret \":\"; }\n+        case (RARROW) { ret \"->\"; }\n+        case (SEND) { ret \"<|\"; }\n+        case (LARROW) { ret \"<-\"; }\n+        case (LPAREN) { ret \"(\"; }\n+        case (RPAREN) { ret \")\"; }\n+        case (LBRACKET) { ret \"[\"; }\n+        case (RBRACKET) { ret \"]\"; }\n+        case (LBRACE) { ret \"{\"; }\n+        case (RBRACE) { ret \"}\"; }\n \n         /* Module and crate keywords */\n-        case (MOD()) { ret \"mod\"; }\n-        case (USE()) { ret \"use\"; }\n-        case (AUTH()) { ret \"auth\"; }\n-        case (META()) { ret \"meta\"; }\n+        case (MOD) { ret \"mod\"; }\n+        case (USE) { ret \"use\"; }\n+        case (AUTH) { ret \"auth\"; }\n+        case (META) { ret \"meta\"; }\n \n         /* Metaprogramming keywords */\n-        case (SYNTAX()) { ret \"syntax\"; }\n-        case (POUND()) { ret \"#\"; }\n+        case (SYNTAX) { ret \"syntax\"; }\n+        case (POUND) { ret \"#\"; }\n \n         /* Statement keywords */\n-        case (IF()) { ret \"if\"; }\n-        case (ELSE()) { ret \"else\"; }\n-        case (DO()) { ret \"do\"; }\n-        case (WHILE()) { ret \"while\"; }\n-        case (ALT()) { ret \"alt\"; }\n-        case (CASE()) { ret \"case\"; }\n-\n-        case (FAIL()) { ret \"fail\"; }\n-        case (DROP()) { ret \"drop\"; }\n-\n-        case (IN()) { ret \"in\"; }\n-        case (FOR()) { ret \"for\"; }\n-        case (EACH()) { ret \"each\"; }\n-        case (PUT()) { ret \"put\"; }\n-        case (RET()) { ret \"ret\"; }\n-        case (BE()) { ret \"be\"; }\n+        case (IF) { ret \"if\"; }\n+        case (ELSE) { ret \"else\"; }\n+        case (DO) { ret \"do\"; }\n+        case (WHILE) { ret \"while\"; }\n+        case (ALT) { ret \"alt\"; }\n+        case (CASE) { ret \"case\"; }\n+\n+        case (FAIL) { ret \"fail\"; }\n+        case (DROP) { ret \"drop\"; }\n+\n+        case (IN) { ret \"in\"; }\n+        case (FOR) { ret \"for\"; }\n+        case (EACH) { ret \"each\"; }\n+        case (PUT) { ret \"put\"; }\n+        case (RET) { ret \"ret\"; }\n+        case (BE) { ret \"be\"; }\n \n         /* Type and type-state keywords */\n-        case (TYPE()) { ret \"type\"; }\n-        case (CHECK()) { ret \"check\"; }\n-        case (CLAIM()) { ret \"claim\"; }\n-        case (PROVE()) { ret \"prove\"; }\n+        case (TYPE) { ret \"type\"; }\n+        case (CHECK) { ret \"check\"; }\n+        case (CLAIM) { ret \"claim\"; }\n+        case (PROVE) { ret \"prove\"; }\n \n         /* Effect keywords */\n-        case (IO()) { ret \"io\"; }\n-        case (STATE()) { ret \"state\"; }\n-        case (UNSAFE()) { ret \"unsafe\"; }\n+        case (IO) { ret \"io\"; }\n+        case (STATE) { ret \"state\"; }\n+        case (UNSAFE) { ret \"unsafe\"; }\n \n         /* Type qualifiers */\n-        case (NATIVE()) { ret \"native\"; }\n-        case (AUTO()) { ret \"auto\"; }\n-        case (MUTABLE()) { ret \"mutable\"; }\n+        case (NATIVE) { ret \"native\"; }\n+        case (AUTO) { ret \"auto\"; }\n+        case (MUTABLE) { ret \"mutable\"; }\n \n         /* Name management */\n-        case (IMPORT()) { ret \"import\"; }\n-        case (EXPORT()) { ret \"export\"; }\n+        case (IMPORT) { ret \"import\"; }\n+        case (EXPORT) { ret \"export\"; }\n \n         /* Value / stmt declarators */\n-        case (LET()) { ret \"let\"; }\n-        case (CONST()) { ret \"const\"; }\n+        case (LET) { ret \"let\"; }\n+        case (CONST) { ret \"const\"; }\n \n         /* Magic runtime services */\n-        case (LOG()) { ret \"log\"; }\n-        case (SPAWN()) { ret \"spawn\"; }\n-        case (BIND()) { ret \"bind\"; }\n-        case (THREAD()) { ret \"thread\"; }\n-        case (YIELD()) { ret \"yield\"; }\n-        case (JOIN()) { ret \"join\"; }\n+        case (LOG) { ret \"log\"; }\n+        case (SPAWN) { ret \"spawn\"; }\n+        case (BIND) { ret \"bind\"; }\n+        case (THREAD) { ret \"thread\"; }\n+        case (YIELD) { ret \"yield\"; }\n+        case (JOIN) { ret \"join\"; }\n \n         /* Literals */\n-        case (LIT_INT(i)) { ret _int.to_str(i, 10u); }\n-        case (LIT_UINT(u)) { ret _uint.to_str(u, 10u); }\n-        case (LIT_MACH_INT(tm, i)) {\n+        case (LIT_INT(?i)) { ret _int.to_str(i, 10u); }\n+        case (LIT_UINT(?u)) { ret _uint.to_str(u, 10u); }\n+        case (LIT_MACH_INT(?tm, ?i)) {\n             ret  _int.to_str(i, 10u)\n                 + \"_\" + ty_mach_to_str(tm);\n         }\n \n-        case (LIT_STR(s)) {\n+        case (LIT_STR(?s)) {\n             // FIXME: escape.\n             ret \"\\\"\" + s + \"\\\"\";\n         }\n-        case (LIT_CHAR(c)) {\n+        case (LIT_CHAR(?c)) {\n             // FIXME: escape and encode.\n             auto tmp = \"'\";\n             tmp += c as u8;\n             tmp += '\\'' as u8;\n             ret tmp;\n         }\n \n-        case (LIT_BOOL(b)) {\n+        case (LIT_BOOL(?b)) {\n             if (b) { ret \"true\"; } else { ret \"false\"; }\n         }\n \n         /* Name components */\n-        case (IDENT(s)) { auto si = \"ident:\"; si += s; ret si; }\n-        case (IDX(i)) { ret \"_\" + _int.to_str(i, 10u); }\n-        case (UNDERSCORE()) { ret \"_\"; }\n+        case (IDENT(?s)) { auto si = \"ident:\"; si += s; ret si; }\n+        case (IDX(?i)) { ret \"_\" + _int.to_str(i, 10u); }\n+        case (UNDERSCORE) { ret \"_\"; }\n \n         /* Reserved type names */\n-        case (BOOL()) { ret \"bool\"; }\n-        case (INT()) { ret \"int\"; }\n-        case (UINT()) { ret \"uint\"; }\n-        case (FLOAT()) { ret \"float\"; }\n-        case (CHAR()) { ret \"char\"; }\n-        case (STR()) { ret \"str\"; }\n-        case (MACH(tm)) { ret ty_mach_to_str(tm); }\n+        case (BOOL) { ret \"bool\"; }\n+        case (INT) { ret \"int\"; }\n+        case (UINT) { ret \"uint\"; }\n+        case (FLOAT) { ret \"float\"; }\n+        case (CHAR) { ret \"char\"; }\n+        case (STR) { ret \"str\"; }\n+        case (MACH(?tm)) { ret ty_mach_to_str(tm); }\n \n         /* Algebraic type constructors */\n-        case (REC()) { ret \"rec\"; }\n-        case (TUP()) { ret \"tup\"; }\n-        case (TAG()) { ret \"tag\"; }\n-        case (VEC()) { ret \"vec\"; }\n-        case (ANY()) { ret \"any\"; }\n+        case (REC) { ret \"rec\"; }\n+        case (TUP) { ret \"tup\"; }\n+        case (TAG) { ret \"tag\"; }\n+        case (VEC) { ret \"vec\"; }\n+        case (ANY) { ret \"any\"; }\n \n         /* Callable type constructors */\n-        case (FN()) { ret \"fn\"; }\n-        case (ITER()) { ret \"iter\"; }\n+        case (FN) { ret \"fn\"; }\n+        case (ITER) { ret \"iter\"; }\n \n         /* Object type */\n-        case (OBJ()) { ret \"obj\"; }\n+        case (OBJ) { ret \"obj\"; }\n \n         /* Comm and task types */\n-        case (CHAN()) { ret \"chan\"; }\n-        case (PORT()) { ret \"port\"; }\n-        case (TASK()) { ret \"task\"; }\n+        case (CHAN) { ret \"chan\"; }\n+        case (PORT) { ret \"port\"; }\n+        case (TASK) { ret \"task\"; }\n \n         case (BRACEQUOTE(_)) { ret \"<bracequote>\"; }\n-        case (EOF()) { ret \"<eof>\"; }\n+        case (EOF) { ret \"<eof>\"; }\n     }\n }\n "}, {"sha": "086a1e544b6d0e9f81b4e053377607bf864facfc", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -4,34 +4,34 @@ type pos = rec(uint line, uint col);\n type span = rec(str filename, pos lo, pos hi);\n \n tag ty_mach {\n-    ty_i8();\n-    ty_i16();\n-    ty_i32();\n-    ty_i64();\n-\n-    ty_u8();\n-    ty_u16();\n-    ty_u32();\n-    ty_u64();\n-\n-    ty_f32();\n-    ty_f64();\n+    ty_i8;\n+    ty_i16;\n+    ty_i32;\n+    ty_i64;\n+\n+    ty_u8;\n+    ty_u16;\n+    ty_u32;\n+    ty_u64;\n+\n+    ty_f32;\n+    ty_f64;\n }\n \n fn ty_mach_to_str(ty_mach tm) -> str {\n     alt (tm) {\n-        case (ty_u8()) { ret \"u8\"; }\n-        case (ty_u16()) { ret \"u16\"; }\n-        case (ty_u32()) { ret \"u32\"; }\n-        case (ty_u64()) { ret \"u64\"; }\n-\n-        case (ty_i8()) { ret \"i8\"; }\n-        case (ty_i16()) { ret \"i16\"; }\n-        case (ty_i32()) { ret \"i32\"; }\n-        case (ty_i64()) { ret \"i64\"; }\n-\n-        case (ty_f32()) { ret \"f32\"; }\n-        case (ty_f64()) { ret \"f64\"; }\n+        case (ty_u8) { ret \"u8\"; }\n+        case (ty_u16) { ret \"u16\"; }\n+        case (ty_u32) { ret \"u32\"; }\n+        case (ty_u64) { ret \"u64\"; }\n+\n+        case (ty_i8) { ret \"i8\"; }\n+        case (ty_i16) { ret \"i16\"; }\n+        case (ty_i32) { ret \"i32\"; }\n+        case (ty_i64) { ret \"i64\"; }\n+\n+        case (ty_f32) { ret \"f32\"; }\n+        case (ty_f64) { ret \"f64\"; }\n     }\n }\n "}, {"sha": "96a63880bacbf802852d37a6308b258f8e200376", "filename": "src/lib/deque.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -38,7 +38,7 @@ fn create[T]() -> t[T] {\n       if (i < nelts) {\n         ret old.((lo + i) % nelts);\n       } else {\n-        ret util.none[T]();\n+        ret util.none[T];\n       }\n     }\n \n@@ -49,7 +49,7 @@ fn create[T]() -> t[T] {\n \n   fn get[T](vec[cell[T]] elts, uint i) -> T {\n     alt (elts.(i)) {\n-      case (util.some[T](t)) { ret t; }\n+      case (util.some[T](?t)) { ret t; }\n       case (_) { fail; }\n     }\n   }\n@@ -98,7 +98,7 @@ fn create[T]() -> t[T] {\n      */\n     fn pop_front() -> T {\n       let T t = get[T](elts, lo);\n-      elts.(lo) = util.none[T]();\n+      elts.(lo) = util.none[T];\n       lo = (lo + 1u) % _vec.len[cell[T]](elts);\n       nelts -= 1u;\n       ret t;\n@@ -112,7 +112,7 @@ fn create[T]() -> t[T] {\n       }\n \n       let T t = get[T](elts, hi);\n-      elts.(hi) = util.none[T]();\n+      elts.(hi) = util.none[T];\n       nelts -= 1u;\n       ret t;\n     }\n@@ -131,7 +131,7 @@ fn create[T]() -> t[T] {\n     }\n \n   }\n-  let vec[cell[T]] v = _vec.init_elt[cell[T]](util.none[T](),\n+  let vec[cell[T]] v = _vec.init_elt[cell[T]](util.none[T],\n                                               initial_capacity);\n \n   ret deque[T](0u, 0u, 0u, v);"}, {"sha": "14d76013cbfa015f24c91a91c2cdb74558cc83c8", "filename": "src/lib/map.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -28,13 +28,13 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n   let util.rational load_factor = rec(num=3, den=4);\n \n   tag bucket[K, V] {\n-    nil();\n-    deleted();\n+    nil;\n+    deleted;\n     some(K, V);\n   }\n \n   fn make_buckets[K, V](uint nbkts) -> vec[mutable bucket[K, V]] {\n-    ret _vec.init_elt[mutable bucket[K, V]](nil[K, V](), nbkts);\n+    ret _vec.init_elt[mutable bucket[K, V]](nil[K, V], nbkts);\n   }\n \n   // Derive two hash functions from the one given by taking the upper\n@@ -81,7 +81,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n     while (i < nbkts) {\n       let uint j = hash[K](hasher, nbkts, key, i);\n       alt (bkts.(j)) {\n-        case (some[K, V](k, _)) {\n+        case (some[K, V](?k, _)) {\n           if (eqer(key, k)) {\n             bkts.(j) = some[K, V](k, val);\n             ret false;\n@@ -108,19 +108,19 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n     while (i < nbkts) {\n       let uint j = (hash[K](hasher, nbkts, key, i));\n       alt (bkts.(j)) {\n-        case (some[K, V](k, v)) {\n+        case (some[K, V](?k, ?v)) {\n           if (eqer(key, k)) {\n             ret util.some[V](v);\n           }\n         }\n         case (nil[K, V]()) {\n-          ret util.none[V]();\n+          ret util.none[V];\n         }\n         case (deleted[K, V]()) { }\n       }\n       i += 1u;\n     }\n-    ret util.none[V]();\n+    ret util.none[V];\n   }\n \n \n@@ -131,7 +131,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n   {\n     for (bucket[K, V] b in oldbkts) {\n       alt (b) {\n-        case (some[K, V](k, v)) {\n+        case (some[K, V](?k, ?v)) {\n           insert_common[K, V](hasher, eqer, newbkts, nnewbkts, k, v);\n         }\n         case (_) { }\n@@ -174,7 +174,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n \n     fn get(&K key) -> V {\n       alt (find_common[K, V](hasher, eqer, bkts, nbkts, key)) {\n-        case (util.some[V](val)) { ret val; }\n+        case (util.some[V](?val)) { ret val; }\n         case (_) { fail; }\n       }\n     }\n@@ -188,21 +188,21 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n       while (i < nbkts) {\n         let uint j = (hash[K](hasher, nbkts, key, i));\n         alt (bkts.(j)) {\n-          case (some[K, V](k, v)) {\n+          case (some[K, V](?k, ?v)) {\n             if (eqer(key, k)) {\n-              bkts.(j) = deleted[K, V]();\n+              bkts.(j) = deleted[K, V];\n               nelts -= 1u;\n               ret util.some[V](v);\n             }\n           }\n-          case (deleted[K, V]()) { }\n-          case (nil[K, V]()) {\n-            ret util.none[V]();\n+          case (deleted[K, V]) { }\n+          case (nil[K, V]) {\n+            ret util.none[V];\n           }\n         }\n         i += 1u;\n       }\n-      ret util.none[V]();\n+      ret util.none[V];\n     }\n \n     fn rehash() {"}, {"sha": "9b55d89a44d67dc34a8ed5d663c59980eb0a2897", "filename": "src/lib/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Flib%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Flib%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Futil.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -1,17 +1,17 @@\n tag option[T] {\n-  none();\n+  none;\n   some(T);\n }\n \n type operator[T, U] = fn(&T) -> U;\n \n fn option_map[T, U](&operator[T, U] f, &option[T] opt) -> option[U] {\n   alt (opt) {\n-    case (some[T](x)) {\n+    case (some[T](?x)) {\n       ret some[U](f(x));\n     }\n-    case (none[T]()) {\n-      ret none[U]();\n+    case (none[T]) {\n+      ret none[U];\n     }\n   }\n }"}, {"sha": "17f8f594f9274bb9e9fcb1ac21110c6ba09c4ec7", "filename": "src/test/compile-fail/infinite-tag-type-recursion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Fcompile-fail%2Finfinite-tag-type-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Fcompile-fail%2Finfinite-tag-type-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-tag-type-recursion.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -4,9 +4,9 @@\n \n tag mlist {\n   cons(int, mlist);\n-  nil();\n+  nil;\n }\n \n fn main() {\n-  auto a = cons(10, cons(11, nil()));\n+  auto a = cons(10, cons(11, nil));\n }"}, {"sha": "1c9cc000dbcf9b025dbbe77d6b4b4149462775fc", "filename": "src/test/run-pass/alt-pattern-drop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -5,14 +5,14 @@ import std._str;\n \n tag t {\n   make_t(str);\n-  clam();\n+  clam;\n }\n \n fn foo(str s) {\n   let t x = make_t(s);  // ref up\n \n   alt (x) {\n-    case (make_t(y)) { log y; }  // ref up then down\n+    case (make_t(?y)) { log y; }  // ref up then down\n     case (_) { log \"?\"; fail; }\n   }\n "}, {"sha": "10891ceb9b563bc0bb3ee6f21474ca0f1e2b9e52", "filename": "src/test/run-pass/alt-pattern-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Falt-pattern-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Falt-pattern-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-simple.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -1,6 +1,6 @@\n fn altsimple(int f) {\n   alt (f) {\n-    case (x) {}\n+    case (?x) {}\n   }\n }\n "}, {"sha": "68013dfe303a772823b5822630b1bdb9405c6b93", "filename": "src/test/run-pass/alt-tag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Falt-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Falt-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-tag.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -9,17 +9,17 @@ tag color {\n fn process(color c) -> int {\n   let int x;\n   alt (c) {\n-    case (rgb(r, _, _)) {\n+    case (rgb(?r, _, _)) {\n       log \"rgb\";\n       log r;\n       x = r;\n     }\n-    case (rgba(_, _, _, a)) {\n+    case (rgba(_, _, _, ?a)) {\n       log \"rgba\";\n       log a;\n       x = a;\n     }\n-    case (hsl(_, s, _)) {\n+    case (hsl(_, ?s, _)) {\n       log \"hsl\";\n       log s;\n       x = s;"}, {"sha": "4f04e729dfd0105e8d4158c3cd3f25c72410c972", "filename": "src/test/run-pass/generic-tag-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -5,7 +5,7 @@ tag foo[T] {\n fn altfoo[T](foo[T] f) {\n   auto hit = false;\n   alt (f) {\n-    case (arm[T](x)) {\n+    case (arm[T](?x)) {\n       log \"in arm\";\n       hit = true;\n     }"}, {"sha": "090a050404a92849670cf3c0d47ece2ae97e83f8", "filename": "src/test/run-pass/generic-tag-values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Fgeneric-tag-values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Fgeneric-tag-values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-values.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -7,15 +7,15 @@ tag noption[T] {\n fn main() {\n   let noption[int] nop = some[int](5);\n   alt (nop) {\n-    case (some[int](n)) {\n+    case (some[int](?n)) {\n       log n;\n       check (n == 5);\n     }\n   }\n \n   let noption[tup(int, int)] nop2 = some[tup(int, int)](tup(17, 42));\n   alt (nop2) {\n-    case (some[tup(int, int)](t)) {\n+    case (some[tup(int, int)](?t)) {\n       log t._0;\n       log t._1;\n       check (t._0 == 17);"}, {"sha": "1fd88255a14106a93a1ce07e56c5c695d32ba0ed", "filename": "src/test/run-pass/generic-tag.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Fgeneric-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Fgeneric-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -1,9 +1,9 @@\n tag option[T] {\n   some(@T);\n-  none();\n+  none;\n }\n \n fn main() {\n   let option[int] a = some[int](@10);\n-  a = none[int]();\n+  a = none[int];\n }\n\\ No newline at end of file"}, {"sha": "4ba772f015941238de26aa71ee2bc27f9354b632", "filename": "src/test/run-pass/lib-deque.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Flib-deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Flib-deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-deque.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -151,21 +151,23 @@ fn main() {\n \n   fn taggyeq(taggy a, taggy b) -> bool {\n     alt (a) {\n-      case (one(a1)) {\n+      case (one(?a1)) {\n         alt (b) {\n-          case (one(b1)) { ret a1 == b1; }\n+          case (one(?b1)) { ret a1 == b1; }\n           case (_) { ret false; }\n         }\n       }\n-      case (two(a1, a2)) {\n+      case (two(?a1, ?a2)) {\n         alt (b) {\n-          case (two(b1, b2)) { ret (a1 == b1 && a2 == b2); }\n+          case (two(?b1, ?b2)) { ret (a1 == b1 && a2 == b2); }\n           case (_) { ret false; }\n         }\n       }\n-      case (three(a1, a2, a3)) {\n+      case (three(?a1, ?a2, ?a3)) {\n         alt (b) {\n-          case (three(b1, b2, b3)) { ret (a1 == b1 && a2 == b2 && a3 == b3); }\n+          case (three(?b1, ?b2, ?b3)) {\n+            ret (a1 == b1 && a2 == b2 && a3 == b3);\n+          }\n           case (_) { ret false; }\n         }\n       }\n@@ -174,21 +176,21 @@ fn main() {\n \n   fn taggypareq[T](taggypar[T] a, taggypar[T] b) -> bool {\n     alt (a) {\n-      case (onepar[T](a1)) {\n+      case (onepar[T](?a1)) {\n         alt (b) {\n-          case (onepar[T](b1)) { ret a1 == b1; }\n+          case (onepar[T](?b1)) { ret a1 == b1; }\n           case (_) { ret false; }\n         }\n       }\n-      case (twopar[T](a1, a2)) {\n+      case (twopar[T](?a1, ?a2)) {\n         alt (b) {\n-          case (twopar[T](b1, b2)) { ret (a1 == b1 && a2 == b2); }\n+          case (twopar[T](?b1, ?b2)) { ret (a1 == b1 && a2 == b2); }\n           case (_) { ret false; }\n         }\n       }\n-      case (threepar[T](a1, a2, a3)) {\n+      case (threepar[T](?a1, ?a2, ?a3)) {\n         alt (b) {\n-          case (threepar[T](b1, b2, b3)) {\n+          case (threepar[T](?b1, ?b2, ?b3)) {\n             ret (a1 == b1 && a2 == b2 && a3 == b3);\n           }\n           case (_) { ret false; }"}, {"sha": "2fd94598bbc47c8ab229cc5c56d6298c61ced159", "filename": "src/test/run-pass/list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flist.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -2,9 +2,9 @@\n \n tag list {\n   cons(int,@list);\n-  nil();\n+  nil;\n }\n \n fn main() {\n-  cons(10, @cons(11, @cons(12, @nil())));\n+  cons(10, @cons(11, @cons(12, @nil)));\n }"}, {"sha": "4d851052c5c5e36c68e7faf1663fdd04acc7f707", "filename": "src/test/run-pass/mutual-recursion-group.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Fmutual-recursion-group.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Fmutual-recursion-group.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutual-recursion-group.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -1,9 +1,9 @@\n // -*- rust -*-\n \n tag colour {\n-  red();\n-  green();\n-  blue();\n+  red;\n+  green;\n+  blue;\n }\n \n tag tree {\n@@ -13,12 +13,12 @@ tag tree {\n \n tag list {\n   cons(@tree, @list);\n-  nil();\n+  nil;\n }\n \n tag small_list {\n   kons(int,@small_list);\n-  neel();\n+  neel;\n }\n \n fn main() {"}, {"sha": "58d529e8374d6148d6a24fa8681cd73068af2087", "filename": "src/test/run-pass/size-and-align.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Fsize-and-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Fsize-and-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsize-and-align.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -2,17 +2,17 @@\n \n tag clam[T] {\n   a(T, int);\n-  b();\n+  b;\n }\n \n fn uhoh[T](vec[clam[T]] v) {\n   alt (v.(1)) {\n-    case (a[T](t, u)) { log \"incorrect\"; log u; fail; }\n-    case (b[T]()) { log \"correct\"; }\n+    case (a[T](?t, ?u)) { log \"incorrect\"; log u; fail; }\n+    case (b[T]) { log \"correct\"; }\n   }\n }\n \n fn main() {\n-  let vec[clam[int]] v = vec(b[int](), b[int](), a[int](42, 17));\n+  let vec[clam[int]] v = vec(b[int], b[int], a[int](42, 17));\n   uhoh[int](v);\n }"}, {"sha": "e3f89a7f262f47076b86646d66f5cbfe35ef260f", "filename": "src/test/run-pass/tag.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Ftag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f4789d5b75d3098665b17d318144cb7c54f42a/src%2Ftest%2Frun-pass%2Ftag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag.rs?ref=c5f4789d5b75d3098665b17d318144cb7c54f42a", "patch": "@@ -2,12 +2,12 @@\n \n tag colour {\n   red(int,int);\n-  green();\n+  green;\n }\n \n fn f() {\n   auto x = red(1,2);\n-  auto y = green();\n+  auto y = green;\n   // FIXME: needs structural equality test working.\n   // check (x != y);\n }"}]}