{"sha": "ecc60106c9d95ce78205f689a662a52a0adeed6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjYzYwMTA2YzlkOTVjZTc4MjA1ZjY4OWE2NjJhNTJhMGFkZWVkNmI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-11-28T23:05:04Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-11-28T23:05:04Z"}, "message": "std: Fix partial writes in LineWriter\n\nPreviously the `LineWriter` could successfully write some bytes but then fail to\nreport that it has done so. Additionally, an erroneous flush after a successful\nwrite was permanently ignored. This commit fixes these two issues by (a)\nmaintaining a `need_flush` flag to indicate whether a flush should be the first\noperation in `LineWriter::write` and (b) avoiding returning an error once some\nbytes have been successfully written.\n\nCloses #37807", "tree": {"sha": "b7b3b7c7c686d4de3bab350c6f4075a7b5058922", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7b3b7c7c686d4de3bab350c6f4075a7b5058922"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecc60106c9d95ce78205f689a662a52a0adeed6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecc60106c9d95ce78205f689a662a52a0adeed6b", "html_url": "https://github.com/rust-lang/rust/commit/ecc60106c9d95ce78205f689a662a52a0adeed6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecc60106c9d95ce78205f689a662a52a0adeed6b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b399e5e99a44cf44d3860d353a8b7619d466410", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b399e5e99a44cf44d3860d353a8b7619d466410", "html_url": "https://github.com/rust-lang/rust/commit/0b399e5e99a44cf44d3860d353a8b7619d466410"}], "stats": {"total": 99, "additions": 86, "deletions": 13}, "files": [{"sha": "c15a1c8328c03608a64344e0444201cab314dcda", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 86, "deletions": 13, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/ecc60106c9d95ce78205f689a662a52a0adeed6b/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecc60106c9d95ce78205f689a662a52a0adeed6b/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=ecc60106c9d95ce78205f689a662a52a0adeed6b", "patch": "@@ -652,6 +652,7 @@ impl<W> fmt::Display for IntoInnerError<W> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LineWriter<W: Write> {\n     inner: BufWriter<W>,\n+    need_flush: bool,\n }\n \n impl<W: Write> LineWriter<W> {\n@@ -692,7 +693,10 @@ impl<W: Write> LineWriter<W> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(cap: usize, inner: W) -> LineWriter<W> {\n-        LineWriter { inner: BufWriter::with_capacity(cap, inner) }\n+        LineWriter {\n+            inner: BufWriter::with_capacity(cap, inner),\n+            need_flush: false,\n+        }\n     }\n \n     /// Gets a reference to the underlying writer.\n@@ -759,28 +763,57 @@ impl<W: Write> LineWriter<W> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> {\n         self.inner.into_inner().map_err(|IntoInnerError(buf, e)| {\n-            IntoInnerError(LineWriter { inner: buf }, e)\n+            IntoInnerError(LineWriter {\n+                inner: buf,\n+                need_flush: false,\n+            }, e)\n         })\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write> Write for LineWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        match memchr::memrchr(b'\\n', buf) {\n-            Some(i) => {\n-                let n = self.inner.write(&buf[..i + 1])?;\n-                if n != i + 1 || self.inner.flush().is_err() {\n-                    // Do not return errors on partial writes.\n-                    return Ok(n);\n-                }\n-                self.inner.write(&buf[i + 1..]).map(|i| n + i)\n-            }\n-            None => self.inner.write(buf),\n+        if self.need_flush {\n+            self.flush()?;\n+        }\n+\n+        // Find the last newline character in the buffer provided. If found then\n+        // we're going to write all the data up to that point and then flush,\n+        // otherewise we just write the whole block to the underlying writer.\n+        let i = match memchr::memrchr(b'\\n', buf) {\n+            Some(i) => i,\n+            None => return self.inner.write(buf),\n+        };\n+\n+\n+        // Ok, we're going to write a partial amount of the data given first\n+        // followed by flushing the newline. After we've successfully written\n+        // some data then we *must* report that we wrote that data, so future\n+        // errors are ignored. We set our internal `need_flush` flag, though, in\n+        // case flushing fails and we need to try it first next time.\n+        let n = self.inner.write(&buf[..i + 1])?;\n+        self.need_flush = true;\n+        if self.flush().is_err() || n != i + 1 {\n+            return Ok(n)\n+        }\n+\n+        // At this point we successfully wrote `i + 1` bytes and flushed it out,\n+        // meaning that the entire line is now flushed out on the screen. While\n+        // we can attempt to finish writing the rest of the data provided.\n+        // Remember though that we ignore errors here as we've successfully\n+        // written data, so we need to report that.\n+        match self.inner.write(&buf[i + 1..]) {\n+            Ok(i) => Ok(n + i),\n+            Err(_) => Ok(n),\n         }\n     }\n \n-    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.inner.flush()?;\n+        self.need_flush = false;\n+        Ok(())\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1153,4 +1186,44 @@ mod tests {\n             BufWriter::new(io::sink())\n         });\n     }\n+\n+    struct AcceptOneThenFail {\n+        written: bool,\n+        flushed: bool,\n+    }\n+\n+    impl Write for AcceptOneThenFail {\n+        fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+            if !self.written {\n+                assert_eq!(data, b\"a\\nb\\n\");\n+                self.written = true;\n+                Ok(data.len())\n+            } else {\n+                Err(io::Error::new(io::ErrorKind::NotFound, \"test\"))\n+            }\n+        }\n+\n+        fn flush(&mut self) -> io::Result<()> {\n+            assert!(self.written);\n+            assert!(!self.flushed);\n+            self.flushed = true;\n+            Err(io::Error::new(io::ErrorKind::Other, \"test\"))\n+        }\n+    }\n+\n+    #[test]\n+    fn erroneous_flush_retried() {\n+        let a = AcceptOneThenFail {\n+            written: false,\n+            flushed: false,\n+        };\n+\n+        let mut l = LineWriter::new(a);\n+        assert_eq!(l.write(b\"a\\nb\\na\").unwrap(), 4);\n+        assert!(l.get_ref().written);\n+        assert!(l.get_ref().flushed);\n+        l.get_mut().flushed = false;\n+\n+        assert_eq!(l.write(b\"a\").unwrap_err().kind(), io::ErrorKind::Other)\n+    }\n }"}]}