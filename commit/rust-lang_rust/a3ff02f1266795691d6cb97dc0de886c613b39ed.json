{"sha": "a3ff02f1266795691d6cb97dc0de886c613b39ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZmYwMmYxMjY2Nzk1NjkxZDZjYjk3ZGMwZGU4ODZjNjEzYjM5ZWQ=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-05-03T14:19:28Z"}, "committer": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-05-03T14:24:18Z"}, "message": "Split start into rustc and rustboot versions. This introduces a bit of\nduplication, but we will hopefully drop the rustboot one soon.\n\nThis is also a preparation for changing the rustc one to have the activate glue\nreturn to the exit glue which will then call the main function.\n\nThis (returning to the function that calls main) matches what happens when\nloader stats a program or a new thread. It lets gdb produce good backtraces\nand should help with EH too.", "tree": {"sha": "f93a945a8b15446c9ff3a5d2f7e26ebe1c2fa5f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f93a945a8b15446c9ff3a5d2f7e26ebe1c2fa5f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3ff02f1266795691d6cb97dc0de886c613b39ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3ff02f1266795691d6cb97dc0de886c613b39ed", "html_url": "https://github.com/rust-lang/rust/commit/a3ff02f1266795691d6cb97dc0de886c613b39ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3ff02f1266795691d6cb97dc0de886c613b39ed/comments", "author": null, "committer": null, "parents": [{"sha": "a919a3082d04a24a6aaa13ffcef98bb06307addc", "url": "https://api.github.com/repos/rust-lang/rust/commits/a919a3082d04a24a6aaa13ffcef98bb06307addc", "html_url": "https://github.com/rust-lang/rust/commit/a919a3082d04a24a6aaa13ffcef98bb06307addc"}], "stats": {"total": 149, "additions": 122, "deletions": 27}, "files": [{"sha": "bed4e57b1941624af7eea1f823290a889dec2102", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 114, "deletions": 27, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/a3ff02f1266795691d6cb97dc0de886c613b39ed/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a3ff02f1266795691d6cb97dc0de886c613b39ed/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=a3ff02f1266795691d6cb97dc0de886c613b39ed", "patch": "@@ -141,6 +141,18 @@ rust_task::start(uintptr_t exit_task_glue,\n                  uintptr_t spawnee_fn,\n                  uintptr_t args,\n                  size_t callsz)\n+{\n+    if (spawnee_abi == ABI_X86_RUSTBOOT_CDECL)\n+        start_rustboot(exit_task_glue, spawnee_fn, args, callsz);\n+    else\n+        start_rustc(exit_task_glue, spawnee_fn, args, callsz);\n+}\n+\n+void\n+rust_task::start_rustboot(uintptr_t exit_task_glue,\n+                          uintptr_t spawnee_fn,\n+                          uintptr_t args,\n+                          size_t callsz)\n {\n     LOGPTR(dom, \"exit-task glue\", exit_task_glue);\n     LOGPTR(dom, \"from spawnee\", spawnee_fn);\n@@ -176,30 +188,25 @@ rust_task::start(uintptr_t exit_task_glue,\n \n     uintptr_t exit_task_frame_base = 0;\n \n-    if (spawnee_abi == ABI_X86_RUSTBOOT_CDECL) {\n-        for (size_t j = 0; j < n_callee_saves; ++j) {\n-\n-            // We want 'frame_base' to point to the old fp in this (exit-task)\n-            // frame, because we're going to inject this frame-pointer into\n-            // the callee-save frame pointer value in the *next* (spawnee)\n-            // frame. A cheap trick, but this means the spawnee frame will\n-            // restore the proper frame pointer of the glue frame as it runs\n-            // its epilogue.\n-            if (j == callee_save_fp)\n-                exit_task_frame_base = (uintptr_t)spp;\n+    for (size_t j = 0; j < n_callee_saves; ++j) {\n \n-            *spp-- = 0;\n-        }\n+        // We want 'frame_base' to point to the old fp in this (exit-task)\n+        // frame, because we're going to inject this frame-pointer into\n+        // the callee-save frame pointer value in the *next* (spawnee)\n+        // frame. A cheap trick, but this means the spawnee frame will\n+        // restore the proper frame pointer of the glue frame as it runs\n+        // its epilogue.\n+        if (j == callee_save_fp)\n+            exit_task_frame_base = (uintptr_t)spp;\n \n-        *spp-- = (uintptr_t) dom->root_crate;  // crate ptr\n-        *spp-- = (uintptr_t) 0;                // frame_glue_fns\n+        *spp-- = 0;\n     }\n \n+    *spp-- = (uintptr_t) dom->root_crate;  // crate ptr\n+    *spp-- = (uintptr_t) 0;                // frame_glue_fns\n+\n     I(dom, args);\n-    if (spawnee_abi == ABI_X86_RUSTBOOT_CDECL)\n-        make_aligned_room_for_bytes(spp, callsz - sizeof(uintptr_t));\n-    else\n-        make_aligned_room_for_bytes(spp, callsz - 3 * sizeof(uintptr_t));\n+    make_aligned_room_for_bytes(spp, callsz - sizeof(uintptr_t));\n \n     // Copy args from spawner to spawnee.\n     uintptr_t *src = (uintptr_t *)args;\n@@ -222,16 +229,96 @@ rust_task::start(uintptr_t exit_task_glue,\n     // activating:\n     *spp-- = (uintptr_t) 0x0;               // closure-or-obj\n \n-    if (spawnee_abi == ABI_X86_RUSTBOOT_CDECL) {\n-        // in CDECL mode we write the task + outptr to the spawnee stack.\n-        *spp-- = (uintptr_t) this;            // task\n-        *spp-- = (uintptr_t) 0;               // output addr\n-    } else {\n-        // in FASTCALL mode we don't, the outptr will be in ecx and the task\n-        // in edx, and the activate_glue will make sure to set that up.\n-        I(dom, spawnee_abi == ABI_X86_RUSTC_FASTCALL);\n+    // in CDECL mode we write the task + outptr to the spawnee stack.\n+    *spp-- = (uintptr_t) this;            // task\n+    *spp-- = (uintptr_t) 0;               // output addr\n+\n+    I(dom, spp+1 == align_down(spp+1));\n+    *spp-- = (uintptr_t) exit_task_glue;  // retpc\n+\n+    // The context the activate_glue needs to switch stack.\n+    *spp-- = (uintptr_t) spawnee_fn;      // instruction to start at\n+    for (size_t j = 0; j < n_callee_saves; ++j) {\n+        // callee-saves to carry in when we activate\n+        if (j == callee_save_fp)\n+            *spp-- = exit_task_frame_base;\n+        else\n+            *spp-- = (uintptr_t)NULL;\n     }\n \n+    // Back up one, we overshot where sp should be.\n+    rust_sp = (uintptr_t) (spp+1);\n+\n+    transition(&dom->newborn_tasks, &dom->running_tasks);\n+}\n+\n+void\n+rust_task::start_rustc(uintptr_t exit_task_glue,\n+                          uintptr_t spawnee_fn,\n+                          uintptr_t args,\n+                          size_t callsz)\n+{\n+    LOGPTR(dom, \"exit-task glue\", exit_task_glue);\n+    LOGPTR(dom, \"from spawnee\", spawnee_fn);\n+\n+    // Set sp to last uintptr_t-sized cell of segment\n+    rust_sp -= sizeof(uintptr_t);\n+\n+    // NB: Darwin needs \"16-byte aligned\" stacks *at the point of the call\n+    // instruction in the caller*. This means that the address at which the\n+    // word before retpc is pushed must always be 16-byte aligned.\n+    //\n+    // see: \"Mac OS X ABI Function Call Guide\"\n+\n+\n+    // Begin synthesizing frames. There are two: a \"fully formed\"\n+    // exit-task frame at the top of the stack -- that pretends to be\n+    // mid-execution -- and a just-starting frame beneath it that\n+    // starts executing the first instruction of the spawnee. The\n+    // spawnee *thinks* it was called by the exit-task frame above\n+    // it. It wasn't; we put that fake frame in place here, but the\n+    // illusion is enough for the spawnee to return to the exit-task\n+    // frame when it's done, and exit.\n+    uintptr_t *spp = (uintptr_t *)rust_sp;\n+\n+\n+    // The exit_task_glue frame we synthesize above the frame we activate:\n+    make_aligned_room_for_bytes(spp, 2 * sizeof(uintptr_t));\n+    *spp-- = (uintptr_t) 0;          // closure-or-obj\n+    *spp-- = (uintptr_t) this;       // task\n+    I(dom, spp == align_down(spp));\n+    *spp-- = (uintptr_t) 0x0;        // output\n+    *spp-- = (uintptr_t) 0x0;        // retpc\n+\n+    uintptr_t exit_task_frame_base = 0;\n+\n+    I(dom, args);\n+    make_aligned_room_for_bytes(spp, callsz - 3 * sizeof(uintptr_t));\n+\n+    // Copy args from spawner to spawnee.\n+    uintptr_t *src = (uintptr_t *)args;\n+    src += 1;                  // spawn-call output slot\n+    src += 1;                  // spawn-call task slot\n+    src += 1;                  // spawn-call closure-or-obj slot\n+\n+    // Undo previous sp-- so we're pointing at the last word pushed.\n+    ++spp;\n+\n+    // Memcpy all but the task, output and env pointers\n+    callsz -= (3 * sizeof(uintptr_t));\n+    spp = (uintptr_t*) (((uintptr_t)spp) - callsz);\n+    memcpy(spp, src, callsz);\n+\n+    // Move sp down to point to last implicit-arg cell (env).\n+    spp--;\n+\n+    // The *implicit* incoming args to the spawnee frame we're\n+    // activating:\n+    *spp-- = (uintptr_t) 0x0;               // closure-or-obj\n+\n+    // in FASTCALL mode we don't, the outptr will be in ecx and the task\n+    // in edx, and the activate_glue will make sure to set that up.\n+\n     I(dom, spp+1 == align_down(spp+1));\n     *spp-- = (uintptr_t) exit_task_glue;  // retpc\n "}, {"sha": "9169a0b3418b462b88bed0a34b5d0fe6a54d11c7", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3ff02f1266795691d6cb97dc0de886c613b39ed/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/a3ff02f1266795691d6cb97dc0de886c613b39ed/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=a3ff02f1266795691d6cb97dc0de886c613b39ed", "patch": "@@ -60,6 +60,14 @@ rust_task : public maybe_proxy<rust_task>,\n                uintptr_t spawnee_fn,\n                uintptr_t args,\n                size_t callsz);\n+    void start_rustboot(uintptr_t exit_task_glue,\n+                        uintptr_t spawnee_fn,\n+                        uintptr_t args,\n+                        size_t callsz);\n+    void start_rustc(uintptr_t exit_task_glue,\n+                     uintptr_t spawnee_fn,\n+                     uintptr_t args,\n+                     size_t callsz);\n     void grow(size_t n_frame_bytes);\n     bool running();\n     bool blocked();"}]}