{"sha": "0c3f0cddde337ef596b45a8ac53aae4c8845237b", "node_id": "C_kwDOAAsO6NoAKDBjM2YwY2RkZGUzMzdlZjU5NmI0NWE4YWM1M2FhZTRjODg0NTIzN2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-15T02:27:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-15T02:27:37Z"}, "message": "Auto merge of #93752 - eholk:drop-tracking-break-continue, r=nikomatsakis\n\nGenerator drop tracking: improve break and continue handling\n\nThis PR fixes two related issues.\n\nOne, sometimes break or continue have a block target instead of an expression target. This seems to mainly happen with try blocks. Since the drop tracking analysis only works on expressions, if we see a block target for break or continue, we substitute the last expression of the block as the target instead.\n\nTwo, break and continue were incorrectly being treated as the same, so continue would also show up as an exit from the loop or block. This patch corrects the way continue is handled by keeping a stack of loop entry points and uses those to find the target of the continue.\n\nFixes #93197\n\nr? `@nikomatsakis`", "tree": {"sha": "5b5cce1ca140be428bdcc8d61748fc05af85db01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b5cce1ca140be428bdcc8d61748fc05af85db01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c3f0cddde337ef596b45a8ac53aae4c8845237b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c3f0cddde337ef596b45a8ac53aae4c8845237b", "html_url": "https://github.com/rust-lang/rust/commit/0c3f0cddde337ef596b45a8ac53aae4c8845237b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c3f0cddde337ef596b45a8ac53aae4c8845237b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5c610aad0a012a9228ecb83cc19e77111a52140", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5c610aad0a012a9228ecb83cc19e77111a52140", "html_url": "https://github.com/rust-lang/rust/commit/c5c610aad0a012a9228ecb83cc19e77111a52140"}, {"sha": "c37a906db56e5cd3699cdc385af9320615ca0064", "url": "https://api.github.com/repos/rust-lang/rust/commits/c37a906db56e5cd3699cdc385af9320615ca0064", "html_url": "https://github.com/rust-lang/rust/commit/c37a906db56e5cd3699cdc385af9320615ca0064"}], "stats": {"total": 124, "additions": 114, "deletions": 10}, "files": [{"sha": "e9135b7163025aff04b91749d10314e4be7e2031", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c3f0cddde337ef596b45a8ac53aae4c8845237b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c3f0cddde337ef596b45a8ac53aae4c8845237b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=0c3f0cddde337ef596b45a8ac53aae4c8845237b", "patch": "@@ -54,7 +54,7 @@ mod tests;\n /// ```\n ///\n /// `'outer` is a label.\n-#[derive(Clone, Encodable, Decodable, Copy, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Copy, HashStable_Generic, Eq, PartialEq)]\n pub struct Label {\n     pub ident: Ident,\n }"}, {"sha": "e2a4d9c1b3af7075aa70dbaed456eade45ed6e31", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 94, "deletions": 9, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/0c3f0cddde337ef596b45a8ac53aae4c8845237b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c3f0cddde337ef596b45a8ac53aae4c8845237b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=0c3f0cddde337ef596b45a8ac53aae4c8845237b", "patch": "@@ -4,7 +4,7 @@ use super::{\n };\n use hir::{\n     intravisit::{self, Visitor},\n-    Body, Expr, ExprKind, Guard, HirId,\n+    Body, Expr, ExprKind, Guard, HirId, LoopIdError,\n };\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n@@ -85,6 +85,7 @@ struct DropRangeVisitor<'a, 'tcx> {\n     expr_index: PostOrderId,\n     tcx: TyCtxt<'tcx>,\n     typeck_results: &'a TypeckResults<'tcx>,\n+    label_stack: Vec<(Option<rustc_ast::Label>, PostOrderId)>,\n }\n \n impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n@@ -101,7 +102,15 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n             hir,\n             num_exprs,\n         );\n-        Self { hir, places, drop_ranges, expr_index: PostOrderId::from_u32(0), typeck_results, tcx }\n+        Self {\n+            hir,\n+            places,\n+            drop_ranges,\n+            expr_index: PostOrderId::from_u32(0),\n+            typeck_results,\n+            tcx,\n+            label_stack: vec![],\n+        }\n     }\n \n     fn record_drop(&mut self, value: TrackedValue) {\n@@ -209,6 +218,60 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n             self.drop_ranges.add_control_edge(self.expr_index + 1, self.expr_index + 1);\n         }\n     }\n+\n+    /// Map a Destination to an equivalent expression node\n+    ///\n+    /// The destination field of a Break or Continue expression can target either an\n+    /// expression or a block. The drop range analysis, however, only deals in\n+    /// expression nodes, so blocks that might be the destination of a Break or Continue\n+    /// will not have a PostOrderId.\n+    ///\n+    /// If the destination is an expression, this function will simply return that expression's\n+    /// hir_id. If the destination is a block, this function will return the hir_id of last\n+    /// expression in the block.\n+    fn find_target_expression_from_destination(\n+        &self,\n+        destination: hir::Destination,\n+    ) -> Result<HirId, LoopIdError> {\n+        destination.target_id.map(|target| {\n+            let node = self.hir.get(target);\n+            match node {\n+                hir::Node::Expr(_) => target,\n+                hir::Node::Block(b) => find_last_block_expression(b),\n+                hir::Node::Param(..)\n+                | hir::Node::Item(..)\n+                | hir::Node::ForeignItem(..)\n+                | hir::Node::TraitItem(..)\n+                | hir::Node::ImplItem(..)\n+                | hir::Node::Variant(..)\n+                | hir::Node::Field(..)\n+                | hir::Node::AnonConst(..)\n+                | hir::Node::Stmt(..)\n+                | hir::Node::PathSegment(..)\n+                | hir::Node::Ty(..)\n+                | hir::Node::TraitRef(..)\n+                | hir::Node::Binding(..)\n+                | hir::Node::Pat(..)\n+                | hir::Node::Arm(..)\n+                | hir::Node::Local(..)\n+                | hir::Node::Ctor(..)\n+                | hir::Node::Lifetime(..)\n+                | hir::Node::GenericParam(..)\n+                | hir::Node::Visibility(..)\n+                | hir::Node::Crate(..)\n+                | hir::Node::Infer(..) => bug!(\"Unsupported branch target: {:?}\", node),\n+            }\n+        })\n+    }\n+}\n+\n+fn find_last_block_expression(block: &hir::Block<'_>) -> HirId {\n+    block.expr.map_or_else(\n+        // If there is no tail expression, there will be at least one statement in the\n+        // block because the block contains a break or continue statement.\n+        || block.stmts.last().unwrap().hir_id,\n+        |expr| expr.hir_id,\n+    )\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n@@ -320,8 +383,9 @@ impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n                 });\n             }\n \n-            ExprKind::Loop(body, ..) => {\n+            ExprKind::Loop(body, label, ..) => {\n                 let loop_begin = self.expr_index + 1;\n+                self.label_stack.push((label, loop_begin));\n                 if body.stmts.is_empty() && body.expr.is_none() {\n                     // For empty loops we won't have updated self.expr_index after visiting the\n                     // body, meaning we'd get an edge from expr_index to expr_index + 1, but\n@@ -331,10 +395,31 @@ impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n                     self.visit_block(body);\n                     self.drop_ranges.add_control_edge(self.expr_index, loop_begin);\n                 }\n+                self.label_stack.pop();\n             }\n-            ExprKind::Break(hir::Destination { target_id: Ok(target), .. }, ..)\n-            | ExprKind::Continue(hir::Destination { target_id: Ok(target), .. }, ..) => {\n-                self.drop_ranges.add_control_edge_hir_id(self.expr_index, target);\n+            // Find the loop entry by searching through the label stack for either the last entry\n+            // (if label is none), or the first entry where the label matches this one. The Loop\n+            // case maintains this stack mapping labels to the PostOrderId for the loop entry.\n+            ExprKind::Continue(hir::Destination { label, .. }, ..) => self\n+                .label_stack\n+                .iter()\n+                .rev()\n+                .find(|(loop_label, _)| label.is_none() || *loop_label == label)\n+                .map_or((), |(_, target)| {\n+                    self.drop_ranges.add_control_edge(self.expr_index, *target)\n+                }),\n+\n+            ExprKind::Break(destination, ..) => {\n+                // destination either points to an expression or to a block. We use\n+                // find_target_expression_from_destination to use the last expression of the block\n+                // if destination points to a block.\n+                //\n+                // We add an edge to the hir_id of the expression/block we are breaking out of, and\n+                // then in process_deferred_edges we will map this hir_id to its PostOrderId, which\n+                // will refer to the end of the block due to the post order traversal.\n+                self.find_target_expression_from_destination(destination).map_or((), |target| {\n+                    self.drop_ranges.add_control_edge_hir_id(self.expr_index, target)\n+                })\n             }\n \n             ExprKind::Call(f, args) => {\n@@ -359,11 +444,9 @@ impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n             | ExprKind::Binary(..)\n             | ExprKind::Block(..)\n             | ExprKind::Box(..)\n-            | ExprKind::Break(..)\n             | ExprKind::Cast(..)\n             | ExprKind::Closure(..)\n             | ExprKind::ConstBlock(..)\n-            | ExprKind::Continue(..)\n             | ExprKind::DropTemps(..)\n             | ExprKind::Err\n             | ExprKind::Field(..)\n@@ -462,11 +545,13 @@ impl DropRangesBuilder {\n     /// Should be called after visiting the HIR but before solving the control flow, otherwise some\n     /// edges will be missed.\n     fn process_deferred_edges(&mut self) {\n+        trace!(\"processing deferred edges. post_order_map={:#?}\", self.post_order_map);\n         let mut edges = vec![];\n         swap(&mut edges, &mut self.deferred_edges);\n         edges.into_iter().for_each(|(from, to)| {\n-            let to = *self.post_order_map.get(&to).expect(\"Expression ID not found\");\n             trace!(\"Adding deferred edge from {:?} to {:?}\", from, to);\n+            let to = *self.post_order_map.get(&to).expect(\"Expression ID not found\");\n+            trace!(\"target edge PostOrderId={:?}\", to);\n             self.add_control_edge(from, to)\n         });\n     }"}, {"sha": "c627fe17afbbed51635608c6cad0b2e38cdf1793", "filename": "src/test/ui/async-await/issue-93197.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c3f0cddde337ef596b45a8ac53aae4c8845237b/src%2Ftest%2Fui%2Fasync-await%2Fissue-93197.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c3f0cddde337ef596b45a8ac53aae4c8845237b/src%2Ftest%2Fui%2Fasync-await%2Fissue-93197.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-93197.rs?ref=0c3f0cddde337ef596b45a8ac53aae4c8845237b", "patch": "@@ -1,6 +1,7 @@\n // Regression test for #93197\n // check-pass\n // edition:2021\n+// compile-flags: -Zdrop-tracking\n \n #![feature(try_blocks)]\n "}, {"sha": "914a7d71dc4210853587198f854b7202ade0ce9e", "filename": "src/test/ui/generator/drop-control-flow.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c3f0cddde337ef596b45a8ac53aae4c8845237b/src%2Ftest%2Fui%2Fgenerator%2Fdrop-control-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c3f0cddde337ef596b45a8ac53aae4c8845237b/src%2Ftest%2Fui%2Fgenerator%2Fdrop-control-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdrop-control-flow.rs?ref=0c3f0cddde337ef596b45a8ac53aae4c8845237b", "patch": "@@ -1,4 +1,5 @@\n // build-pass\n+// compile-flags: -Zdrop-tracking\n \n // FIXME(eholk): temporarily disabled while drop range tracking is disabled\n // (see generator_interior.rs:27)\n@@ -114,6 +115,22 @@ fn nested_loop() {\n     };\n }\n \n+fn loop_continue(b: bool) {\n+    let _ = || {\n+        let mut arr = [Ptr];\n+        let mut count = 0;\n+        drop(arr);\n+        while count < 3 {\n+            count += 1;\n+            yield;\n+            if b {\n+                arr = [Ptr];\n+                continue;\n+            }\n+        }\n+    };\n+}\n+\n fn main() {\n     one_armed_if(true);\n     if_let(Some(41));\n@@ -122,4 +139,5 @@ fn main() {\n     reinit();\n     loop_uninit();\n     nested_loop();\n+    loop_continue(true);\n }"}]}