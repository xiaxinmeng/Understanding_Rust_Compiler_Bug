{"sha": "4d30b08027f191e26431e0e62b5f17de76d273c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkMzBiMDgwMjdmMTkxZTI2NDMxZTBlNjJiNWYxN2RlNzZkMjczYzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-26T07:38:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-26T07:38:08Z"}, "message": "Auto merge of #4569 - james9909:add-comparison-chain, r=oli-obk\n\nAdd a new lint for comparison chains\n\nchangelog: Adds a new lint: `comparison_chain`.\n\n`comparison_chain` lints all `if` conditional chains where all the conditions are binary comparisons on the same two operands and will suggest a rewrite with `match`.\n\nCloses #4531.", "tree": {"sha": "b69a2eb12eb7f790283c25caecdb57da5fa8d551", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b69a2eb12eb7f790283c25caecdb57da5fa8d551"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d30b08027f191e26431e0e62b5f17de76d273c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d30b08027f191e26431e0e62b5f17de76d273c5", "html_url": "https://github.com/rust-lang/rust/commit/4d30b08027f191e26431e0e62b5f17de76d273c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d30b08027f191e26431e0e62b5f17de76d273c5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855", "html_url": "https://github.com/rust-lang/rust/commit/bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855"}, {"sha": "2f34576c18846e3a1186cf0deb74e336f62fe86b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f34576c18846e3a1186cf0deb74e336f62fe86b", "html_url": "https://github.com/rust-lang/rust/commit/2f34576c18846e3a1186cf0deb74e336f62fe86b"}], "stats": {"total": 469, "additions": 362, "deletions": 107}, "files": [{"sha": "ca0eb65ca3d8a08d56141b016792d1994d710fc8", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d30b08027f191e26431e0e62b5f17de76d273c5/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d30b08027f191e26431e0e62b5f17de76d273c5/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=4d30b08027f191e26431e0e62b5f17de76d273c5", "patch": "@@ -962,6 +962,7 @@ Released 2018-09-13\n [`cmp_owned`]: https://rust-lang.github.io/rust-clippy/master/index.html#cmp_owned\n [`cognitive_complexity`]: https://rust-lang.github.io/rust-clippy/master/index.html#cognitive_complexity\n [`collapsible_if`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\n+[`comparison_chain`]: https://rust-lang.github.io/rust-clippy/master/index.html#comparison_chain\n [`copy_iterator`]: https://rust-lang.github.io/rust-clippy/master/index.html#copy_iterator\n [`crosspointer_transmute`]: https://rust-lang.github.io/rust-clippy/master/index.html#crosspointer_transmute\n [`dbg_macro`]: https://rust-lang.github.io/rust-clippy/master/index.html#dbg_macro"}, {"sha": "f944e716e9aa712201f5b729790185507b0599bf", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d30b08027f191e26431e0e62b5f17de76d273c5/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d30b08027f191e26431e0e62b5f17de76d273c5/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=4d30b08027f191e26431e0e62b5f17de76d273c5", "patch": "@@ -6,7 +6,7 @@\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 316 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are 317 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n "}, {"sha": "6747614e2bcc93fdf32875d6896bec3ae22e788e", "filename": "clippy_lints/src/comparison_chain.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/4d30b08027f191e26431e0e62b5f17de76d273c5/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d30b08027f191e26431e0e62b5f17de76d273c5/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=4d30b08027f191e26431e0e62b5f17de76d273c5", "patch": "@@ -0,0 +1,107 @@\n+use crate::utils::{if_sequence, parent_node_is_if_expr, span_help_and_lint, SpanlessEq};\n+use rustc::hir::*;\n+use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks comparison chains written with `if` that can be\n+    /// rewritten with `match` and `cmp`.\n+    ///\n+    /// **Why is this bad?** `if` is not guaranteed to be exhaustive and conditionals can get\n+    /// repetitive\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// # fn a() {}\n+    /// # fn b() {}\n+    /// # fn c() {}\n+    /// fn f(x: u8, y: u8) {\n+    ///     if x > y {\n+    ///         a()\n+    ///     } else if x < y {\n+    ///         b()\n+    ///     } else {\n+    ///         c()\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust,ignore\n+    /// use std::cmp::Ordering;\n+    /// # fn a() {}\n+    /// # fn b() {}\n+    /// # fn c() {}\n+    /// fn f(x: u8, y: u8) {\n+    ///      match x.cmp(&y) {\n+    ///          Ordering::Greater => a(),\n+    ///          Ordering::Less => b(),\n+    ///          Ordering::Equal => c()\n+    ///      }\n+    /// }\n+    /// ```\n+    pub COMPARISON_CHAIN,\n+    style,\n+    \"`if`s that can be rewritten with `match` and `cmp`\"\n+}\n+\n+declare_lint_pass!(ComparisonChain => [COMPARISON_CHAIN]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ComparisonChain {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        // We only care about the top-most `if` in the chain\n+        if parent_node_is_if_expr(expr, cx) {\n+            return;\n+        }\n+\n+        // Check that there exists at least one explicit else condition\n+        let (conds, _) = if_sequence(expr);\n+        if conds.len() < 2 {\n+            return;\n+        }\n+\n+        for cond in conds.windows(2) {\n+            if let (\n+                &ExprKind::Binary(ref kind1, ref lhs1, ref rhs1),\n+                &ExprKind::Binary(ref kind2, ref lhs2, ref rhs2),\n+            ) = (&cond[0].node, &cond[1].node)\n+            {\n+                if !kind_is_cmp(kind1.node) || !kind_is_cmp(kind2.node) {\n+                    return;\n+                }\n+\n+                // Check that both sets of operands are equal\n+                let mut spanless_eq = SpanlessEq::new(cx);\n+                if (!spanless_eq.eq_expr(lhs1, lhs2) || !spanless_eq.eq_expr(rhs1, rhs2))\n+                    && (!spanless_eq.eq_expr(lhs1, rhs2) || !spanless_eq.eq_expr(rhs1, lhs2))\n+                {\n+                    return;\n+                }\n+            } else {\n+                // We only care about comparison chains\n+                return;\n+            }\n+        }\n+        span_help_and_lint(\n+            cx,\n+            COMPARISON_CHAIN,\n+            expr.span,\n+            \"`if` chain can be rewritten with `match`\",\n+            \"Consider rewriting the `if` chain to use `cmp` and `match`.\",\n+        )\n+    }\n+}\n+\n+fn kind_is_cmp(kind: BinOpKind) -> bool {\n+    match kind {\n+        BinOpKind::Lt | BinOpKind::Gt | BinOpKind::Eq => true,\n+        _ => false,\n+    }\n+}"}, {"sha": "dc9f68a13c89ef958e15296e2d0bfeb90e7e853b", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 4, "deletions": 43, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4d30b08027f191e26431e0e62b5f17de76d273c5/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d30b08027f191e26431e0e62b5f17de76d273c5/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=4d30b08027f191e26431e0e62b5f17de76d273c5", "patch": "@@ -1,11 +1,11 @@\n-use crate::utils::{get_parent_expr, higher, same_tys, snippet, span_lint_and_then, span_note_and_lint};\n+use crate::utils::{get_parent_expr, higher, if_sequence, same_tys, snippet, span_lint_and_then, span_note_and_lint};\n use crate::utils::{SpanlessEq, SpanlessHash};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty::Ty;\n use rustc::{declare_lint_pass, declare_tool_lint};\n use rustc_data_structures::fx::FxHashMap;\n-use smallvec::SmallVec;\n+use std::cmp::Ordering;\n use std::collections::hash_map::Entry;\n use std::hash::BuildHasherDefault;\n use syntax::symbol::Symbol;\n@@ -236,39 +236,6 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr) {\n     }\n }\n \n-/// Returns the list of condition expressions and the list of blocks in a\n-/// sequence of `if/else`.\n-/// E.g., this returns `([a, b], [c, d, e])` for the expression\n-/// `if a { c } else if b { d } else { e }`.\n-fn if_sequence(mut expr: &Expr) -> (SmallVec<[&Expr; 1]>, SmallVec<[&Block; 1]>) {\n-    let mut conds = SmallVec::new();\n-    let mut blocks: SmallVec<[&Block; 1]> = SmallVec::new();\n-\n-    while let Some((ref cond, ref then_expr, ref else_expr)) = higher::if_block(&expr) {\n-        conds.push(&**cond);\n-        if let ExprKind::Block(ref block, _) = then_expr.node {\n-            blocks.push(block);\n-        } else {\n-            panic!(\"ExprKind::If node is not an ExprKind::Block\");\n-        }\n-\n-        if let Some(ref else_expr) = *else_expr {\n-            expr = else_expr;\n-        } else {\n-            break;\n-        }\n-    }\n-\n-    // final `else {..}`\n-    if !blocks.is_empty() {\n-        if let ExprKind::Block(ref block, _) = expr.node {\n-            blocks.push(&**block);\n-        }\n-    }\n-\n-    (conds, blocks)\n-}\n-\n /// Returns the list of bindings in a pattern.\n fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> FxHashMap<Symbol, Ty<'tcx>> {\n     fn bindings_impl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat, map: &mut FxHashMap<Symbol, Ty<'tcx>>) {\n@@ -333,14 +300,8 @@ fn search_common_cases<'a, T, Eq>(exprs: &'a [T], eq: &Eq) -> Option<(&'a T, &'a\n where\n     Eq: Fn(&T, &T) -> bool,\n {\n-    if exprs.len() < 2 {\n-        None\n-    } else if exprs.len() == 2 {\n-        if eq(&exprs[0], &exprs[1]) {\n-            Some((&exprs[0], &exprs[1]))\n-        } else {\n-            None\n-        }\n+    if exprs.len() == 2 && eq(&exprs[0], &exprs[1]) {\n+        Some((&exprs[0], &exprs[1]))\n     } else {\n         None\n     }"}, {"sha": "ed47b6a1857667aaebf350d50797fac8e9ebabac", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d30b08027f191e26431e0e62b5f17de76d273c5/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d30b08027f191e26431e0e62b5f17de76d273c5/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=4d30b08027f191e26431e0e62b5f17de76d273c5", "patch": "@@ -159,6 +159,7 @@ pub mod cargo_common_metadata;\n pub mod checked_conversions;\n pub mod cognitive_complexity;\n pub mod collapsible_if;\n+pub mod comparison_chain;\n pub mod copies;\n pub mod copy_iterator;\n pub mod dbg_macro;\n@@ -600,6 +601,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n     reg.register_late_lint_pass(box integer_division::IntegerDivision);\n     reg.register_late_lint_pass(box inherent_to_string::InherentToString);\n     reg.register_late_lint_pass(box trait_bounds::TraitBounds);\n+    reg.register_late_lint_pass(box comparison_chain::ComparisonChain);\n \n     reg.register_lint_group(\"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -706,6 +708,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         bytecount::NAIVE_BYTECOUNT,\n         cognitive_complexity::COGNITIVE_COMPLEXITY,\n         collapsible_if::COLLAPSIBLE_IF,\n+        comparison_chain::COMPARISON_CHAIN,\n         copies::IFS_SAME_COND,\n         copies::IF_SAME_THEN_ELSE,\n         derive::DERIVE_HASH_XOR_EQ,\n@@ -932,6 +935,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_EXPR,\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_STMT,\n         collapsible_if::COLLAPSIBLE_IF,\n+        comparison_chain::COMPARISON_CHAIN,\n         doc::MISSING_SAFETY_DOC,\n         enum_variants::ENUM_VARIANT_NAMES,\n         enum_variants::MODULE_INCEPTION,"}, {"sha": "d19939be6c0d20d1641a0be604c595f018a74ca9", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4d30b08027f191e26431e0e62b5f17de76d273c5/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d30b08027f191e26431e0e62b5f17de76d273c5/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=4d30b08027f191e26431e0e62b5f17de76d273c5", "patch": "@@ -3,7 +3,7 @@\n //! This lint is **warn** by default\n \n use crate::utils::sugg::Sugg;\n-use crate::utils::{higher, span_lint, span_lint_and_sugg};\n+use crate::utils::{higher, parent_node_is_if_expr, span_lint, span_lint_and_sugg};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n@@ -118,17 +118,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n     }\n }\n \n-fn parent_node_is_if_expr<'a, 'b>(expr: &Expr, cx: &LateContext<'a, 'b>) -> bool {\n-    let parent_id = cx.tcx.hir().get_parent_node(expr.hir_id);\n-    let parent_node = cx.tcx.hir().get(parent_id);\n-\n-    match parent_node {\n-        rustc::hir::Node::Expr(e) => higher::if_block(&e).is_some(),\n-        rustc::hir::Node::Arm(e) => higher::if_block(&e.body).is_some(),\n-        _ => false,\n-    }\n-}\n-\n declare_lint_pass!(BoolComparison => [BOOL_COMPARISON]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoolComparison {"}, {"sha": "ff06eaca465e1aa49d0800ab7c518fd09f120209", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 54, "deletions": 49, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/4d30b08027f191e26431e0e62b5f17de76d273c5/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d30b08027f191e26431e0e62b5f17de76d273c5/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=4d30b08027f191e26431e0e62b5f17de76d273c5", "patch": "@@ -1,6 +1,7 @@\n use crate::utils::{span_lint, span_lint_and_then};\n use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, impl_lint_pass};\n+use std::cmp::Ordering;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::source_map::Span;\n@@ -206,63 +207,67 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n                 continue;\n             }\n             let mut split_at = None;\n-            if existing_name.len > count {\n-                if existing_name.len - count != 1 || levenstein_not_1(&interned_name, &existing_name.interned) {\n-                    continue;\n-                }\n-            } else if existing_name.len < count {\n-                if count - existing_name.len != 1 || levenstein_not_1(&existing_name.interned, &interned_name) {\n-                    continue;\n-                }\n-            } else {\n-                let mut interned_chars = interned_name.chars();\n-                let mut existing_chars = existing_name.interned.chars();\n-                let first_i = interned_chars.next().expect(\"we know we have at least one char\");\n-                let first_e = existing_chars.next().expect(\"we know we have at least one char\");\n-                let eq_or_numeric = |(a, b): (char, char)| a == b || a.is_numeric() && b.is_numeric();\n+            match existing_name.len.cmp(&count) {\n+                Ordering::Greater => {\n+                    if existing_name.len - count != 1 || levenstein_not_1(&interned_name, &existing_name.interned) {\n+                        continue;\n+                    }\n+                },\n+                Ordering::Less => {\n+                    if count - existing_name.len != 1 || levenstein_not_1(&existing_name.interned, &interned_name) {\n+                        continue;\n+                    }\n+                },\n+                Ordering::Equal => {\n+                    let mut interned_chars = interned_name.chars();\n+                    let mut existing_chars = existing_name.interned.chars();\n+                    let first_i = interned_chars.next().expect(\"we know we have at least one char\");\n+                    let first_e = existing_chars.next().expect(\"we know we have at least one char\");\n+                    let eq_or_numeric = |(a, b): (char, char)| a == b || a.is_numeric() && b.is_numeric();\n \n-                if eq_or_numeric((first_i, first_e)) {\n-                    let last_i = interned_chars.next_back().expect(\"we know we have at least two chars\");\n-                    let last_e = existing_chars.next_back().expect(\"we know we have at least two chars\");\n-                    if eq_or_numeric((last_i, last_e)) {\n-                        if interned_chars\n-                            .zip(existing_chars)\n-                            .filter(|&ie| !eq_or_numeric(ie))\n-                            .count()\n-                            != 1\n-                        {\n-                            continue;\n+                    if eq_or_numeric((first_i, first_e)) {\n+                        let last_i = interned_chars.next_back().expect(\"we know we have at least two chars\");\n+                        let last_e = existing_chars.next_back().expect(\"we know we have at least two chars\");\n+                        if eq_or_numeric((last_i, last_e)) {\n+                            if interned_chars\n+                                .zip(existing_chars)\n+                                .filter(|&ie| !eq_or_numeric(ie))\n+                                .count()\n+                                != 1\n+                            {\n+                                continue;\n+                            }\n+                        } else {\n+                            let second_last_i = interned_chars\n+                                .next_back()\n+                                .expect(\"we know we have at least three chars\");\n+                            let second_last_e = existing_chars\n+                                .next_back()\n+                                .expect(\"we know we have at least three chars\");\n+                            if !eq_or_numeric((second_last_i, second_last_e))\n+                                || second_last_i == '_'\n+                                || !interned_chars.zip(existing_chars).all(eq_or_numeric)\n+                            {\n+                                // allowed similarity foo_x, foo_y\n+                                // or too many chars differ (foo_x, boo_y) or (foox, booy)\n+                                continue;\n+                            }\n+                            split_at = interned_name.char_indices().rev().next().map(|(i, _)| i);\n                         }\n                     } else {\n-                        let second_last_i = interned_chars\n-                            .next_back()\n-                            .expect(\"we know we have at least three chars\");\n-                        let second_last_e = existing_chars\n-                            .next_back()\n-                            .expect(\"we know we have at least three chars\");\n-                        if !eq_or_numeric((second_last_i, second_last_e))\n-                            || second_last_i == '_'\n+                        let second_i = interned_chars.next().expect(\"we know we have at least two chars\");\n+                        let second_e = existing_chars.next().expect(\"we know we have at least two chars\");\n+                        if !eq_or_numeric((second_i, second_e))\n+                            || second_i == '_'\n                             || !interned_chars.zip(existing_chars).all(eq_or_numeric)\n                         {\n-                            // allowed similarity foo_x, foo_y\n-                            // or too many chars differ (foo_x, boo_y) or (foox, booy)\n+                            // allowed similarity x_foo, y_foo\n+                            // or too many chars differ (x_foo, y_boo) or (xfoo, yboo)\n                             continue;\n                         }\n-                        split_at = interned_name.char_indices().rev().next().map(|(i, _)| i);\n+                        split_at = interned_name.chars().next().map(char::len_utf8);\n                     }\n-                } else {\n-                    let second_i = interned_chars.next().expect(\"we know we have at least two chars\");\n-                    let second_e = existing_chars.next().expect(\"we know we have at least two chars\");\n-                    if !eq_or_numeric((second_i, second_e))\n-                        || second_i == '_'\n-                        || !interned_chars.zip(existing_chars).all(eq_or_numeric)\n-                    {\n-                        // allowed similarity x_foo, y_foo\n-                        // or too many chars differ (x_foo, y_boo) or (xfoo, yboo)\n-                        continue;\n-                    }\n-                    split_at = interned_name.chars().next().map(char::len_utf8);\n-                }\n+                },\n             }\n             span_lint_and_then(\n                 self.0.cx,"}, {"sha": "ca0927636d746e7731c3aef1594b045fe395b739", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4d30b08027f191e26431e0e62b5f17de76d273c5/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d30b08027f191e26431e0e62b5f17de76d273c5/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=4d30b08027f191e26431e0e62b5f17de76d273c5", "patch": "@@ -1168,3 +1168,47 @@ pub fn match_def_path<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, did: DefId, syms: &[\n     let path = cx.get_def_path(did);\n     path.len() == syms.len() && path.into_iter().zip(syms.iter()).all(|(a, &b)| a.as_str() == b)\n }\n+\n+/// Returns the list of condition expressions and the list of blocks in a\n+/// sequence of `if/else`.\n+/// E.g., this returns `([a, b], [c, d, e])` for the expression\n+/// `if a { c } else if b { d } else { e }`.\n+pub fn if_sequence(mut expr: &Expr) -> (SmallVec<[&Expr; 1]>, SmallVec<[&Block; 1]>) {\n+    let mut conds = SmallVec::new();\n+    let mut blocks: SmallVec<[&Block; 1]> = SmallVec::new();\n+\n+    while let Some((ref cond, ref then_expr, ref else_expr)) = higher::if_block(&expr) {\n+        conds.push(&**cond);\n+        if let ExprKind::Block(ref block, _) = then_expr.node {\n+            blocks.push(block);\n+        } else {\n+            panic!(\"ExprKind::If node is not an ExprKind::Block\");\n+        }\n+\n+        if let Some(ref else_expr) = *else_expr {\n+            expr = else_expr;\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    // final `else {..}`\n+    if !blocks.is_empty() {\n+        if let ExprKind::Block(ref block, _) = expr.node {\n+            blocks.push(&**block);\n+        }\n+    }\n+\n+    (conds, blocks)\n+}\n+\n+pub fn parent_node_is_if_expr<'a, 'b>(expr: &Expr, cx: &LateContext<'a, 'b>) -> bool {\n+    let parent_id = cx.tcx.hir().get_parent_node(expr.hir_id);\n+    let parent_node = cx.tcx.hir().get(parent_id);\n+\n+    match parent_node {\n+        rustc::hir::Node::Expr(e) => higher::if_block(&e).is_some(),\n+        rustc::hir::Node::Arm(e) => higher::if_block(&e.body).is_some(),\n+        _ => false,\n+    }\n+}"}, {"sha": "1b838b17f7f7ad6a809b1c8799679dfb9e42ba93", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4d30b08027f191e26431e0e62b5f17de76d273c5/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d30b08027f191e26431e0e62b5f17de76d273c5/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=4d30b08027f191e26431e0e62b5f17de76d273c5", "patch": "@@ -6,7 +6,7 @@ pub use lint::Lint;\n pub use lint::LINT_LEVELS;\n \n // begin lint list, do not remove this comment, it\u2019s used in `update_lints`\n-pub const ALL_LINTS: [Lint; 316] = [\n+pub const ALL_LINTS: [Lint; 317] = [\n     Lint {\n         name: \"absurd_extreme_comparisons\",\n         group: \"correctness\",\n@@ -252,6 +252,13 @@ pub const ALL_LINTS: [Lint; 316] = [\n         deprecation: None,\n         module: \"collapsible_if\",\n     },\n+    Lint {\n+        name: \"comparison_chain\",\n+        group: \"style\",\n+        desc: \"`if`s that can be rewritten with `match` and `cmp`\",\n+        deprecation: None,\n+        module: \"comparison_chain\",\n+    },\n     Lint {\n         name: \"copy_iterator\",\n         group: \"pedantic\","}, {"sha": "b697413b6e031b1f881d9d267d64a0eee53c9fd4", "filename": "tests/ui/comparison_chain.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4d30b08027f191e26431e0e62b5f17de76d273c5/tests%2Fui%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d30b08027f191e26431e0e62b5f17de76d273c5/tests%2Fui%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcomparison_chain.rs?ref=4d30b08027f191e26431e0e62b5f17de76d273c5", "patch": "@@ -0,0 +1,79 @@\n+#![allow(dead_code)]\n+#![warn(clippy::comparison_chain)]\n+\n+fn a() {}\n+fn b() {}\n+fn c() {}\n+\n+fn f(x: u8, y: u8, z: u8) {\n+    // Ignored: Only one branch\n+    if x > y {\n+        a()\n+    }\n+\n+    if x > y {\n+        a()\n+    } else if x < y {\n+        b()\n+    }\n+\n+    // Ignored: Only one explicit conditional\n+    if x > y {\n+        a()\n+    } else {\n+        b()\n+    }\n+\n+    if x > y {\n+        a()\n+    } else if x < y {\n+        b()\n+    } else {\n+        c()\n+    }\n+\n+    if x > y {\n+        a()\n+    } else if y > x {\n+        b()\n+    } else {\n+        c()\n+    }\n+\n+    if x > 1 {\n+        a()\n+    } else if x < 1 {\n+        b()\n+    } else if x == 1 {\n+        c()\n+    }\n+\n+    // Ignored: Binop args are not equivalent\n+    if x > 1 {\n+        a()\n+    } else if y > 1 {\n+        b()\n+    } else {\n+        c()\n+    }\n+\n+    // Ignored: Binop args are not equivalent\n+    if x > y {\n+        a()\n+    } else if x > z {\n+        b()\n+    } else if y > z {\n+        c()\n+    }\n+\n+    // Ignored: Not binary comparisons\n+    if true {\n+        a()\n+    } else if false {\n+        b()\n+    } else {\n+        c()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "575181dd7194276279cd103b627a50d1a20d98c5", "filename": "tests/ui/comparison_chain.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4d30b08027f191e26431e0e62b5f17de76d273c5/tests%2Fui%2Fcomparison_chain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d30b08027f191e26431e0e62b5f17de76d273c5/tests%2Fui%2Fcomparison_chain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcomparison_chain.stderr?ref=4d30b08027f191e26431e0e62b5f17de76d273c5", "patch": "@@ -0,0 +1,57 @@\n+error: `if` chain can be rewritten with `match`\n+  --> $DIR/comparison_chain.rs:14:5\n+   |\n+LL | /     if x > y {\n+LL | |         a()\n+LL | |     } else if x < y {\n+LL | |         b()\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::comparison-chain` implied by `-D warnings`\n+   = help: Consider rewriting the `if` chain to use `cmp` and `match`.\n+\n+error: `if` chain can be rewritten with `match`\n+  --> $DIR/comparison_chain.rs:27:5\n+   |\n+LL | /     if x > y {\n+LL | |         a()\n+LL | |     } else if x < y {\n+LL | |         b()\n+LL | |     } else {\n+LL | |         c()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: Consider rewriting the `if` chain to use `cmp` and `match`.\n+\n+error: `if` chain can be rewritten with `match`\n+  --> $DIR/comparison_chain.rs:35:5\n+   |\n+LL | /     if x > y {\n+LL | |         a()\n+LL | |     } else if y > x {\n+LL | |         b()\n+LL | |     } else {\n+LL | |         c()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: Consider rewriting the `if` chain to use `cmp` and `match`.\n+\n+error: `if` chain can be rewritten with `match`\n+  --> $DIR/comparison_chain.rs:43:5\n+   |\n+LL | /     if x > 1 {\n+LL | |         a()\n+LL | |     } else if x < 1 {\n+LL | |         b()\n+LL | |     } else if x == 1 {\n+LL | |         c()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: Consider rewriting the `if` chain to use `cmp` and `match`.\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "4ef992b05e7618f2b40221690618354f528b7d9d", "filename": "tests/ui/crashes/if_same_then_else.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d30b08027f191e26431e0e62b5f17de76d273c5/tests%2Fui%2Fcrashes%2Fif_same_then_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d30b08027f191e26431e0e62b5f17de76d273c5/tests%2Fui%2Fcrashes%2Fif_same_then_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fif_same_then_else.rs?ref=4d30b08027f191e26431e0e62b5f17de76d273c5", "patch": "@@ -1,5 +1,6 @@\n // run-pass\n \n+#![allow(clippy::comparison_chain)]\n #![deny(clippy::if_same_then_else)]\n \n /// Test for https://github.com/rust-lang/rust-clippy/issues/2426"}, {"sha": "80e9839ff40bd30df3bfdfaec456c1d44aa8154e", "filename": "tests/ui/ifs_same_cond.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d30b08027f191e26431e0e62b5f17de76d273c5/tests%2Fui%2Fifs_same_cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d30b08027f191e26431e0e62b5f17de76d273c5/tests%2Fui%2Fifs_same_cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fifs_same_cond.rs?ref=4d30b08027f191e26431e0e62b5f17de76d273c5", "patch": "@@ -1,5 +1,5 @@\n #![warn(clippy::ifs_same_cond)]\n-#![allow(clippy::if_same_then_else)] // all empty blocks\n+#![allow(clippy::if_same_then_else, clippy::comparison_chain)] // all empty blocks\n \n fn ifs_same_cond() {\n     let a = 0;"}]}