{"sha": "369f3601592f38b0689bb58b38094edd3164c9d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2OWYzNjAxNTkyZjM4YjA2ODliYjU4YjM4MDk0ZWRkMzE2NGM5ZDk=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-22T07:51:01Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-02-05T07:38:08Z"}, "message": "Move rustc::traits datatypes to module traits::types.", "tree": {"sha": "325d55f698bda5ee32e3b549860c54c2ea9f8927", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/325d55f698bda5ee32e3b549860c54c2ea9f8927"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/369f3601592f38b0689bb58b38094edd3164c9d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/369f3601592f38b0689bb58b38094edd3164c9d9", "html_url": "https://github.com/rust-lang/rust/commit/369f3601592f38b0689bb58b38094edd3164c9d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/369f3601592f38b0689bb58b38094edd3164c9d9/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ff8fb9cb210a9f06e0eafc364bd12de2b67f087", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ff8fb9cb210a9f06e0eafc364bd12de2b67f087", "html_url": "https://github.com/rust-lang/rust/commit/4ff8fb9cb210a9f06e0eafc364bd12de2b67f087"}], "stats": {"total": 1372, "additions": 691, "deletions": 681}, "files": [{"sha": "d775393a808f74da948b3ec1aeb0ca2deae2587b", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/369f3601592f38b0689bb58b38094edd3164c9d9/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/369f3601592f38b0689bb58b38094edd3164c9d9/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=369f3601592f38b0689bb58b38094edd3164c9d9", "patch": "@@ -9,6 +9,7 @@ use crate::ty::fold::TypeFolder;\n use crate::ty::{Region, RegionVid};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use syntax::ast;\n \n use std::collections::hash_map::Entry;\n use std::collections::VecDeque;"}, {"sha": "0eed762c000bc42503579da7d6d330d54c819dfb", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 681, "changes": 685, "blob_url": "https://github.com/rust-lang/rust/blob/369f3601592f38b0689bb58b38094edd3164c9d9/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/369f3601592f38b0689bb58b38094edd3164c9d9/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=369f3601592f38b0689bb58b38094edd3164c9d9", "patch": "@@ -19,31 +19,25 @@ mod select;\n mod specialize;\n mod structural_impls;\n mod structural_match;\n+mod types;\n mod util;\n pub mod wf;\n \n use crate::infer::outlives::env::OutlivesEnvironment;\n use crate::infer::{InferCtxt, SuppressRegionErrors};\n use crate::middle::region;\n-use crate::mir::interpret::ErrorHandled;\n use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::{InternalSubsts, SubstsRef};\n-use crate::ty::{self, AdtKind, GenericParamDefKind, List, ToPredicate, Ty, TyCtxt, WithConstness};\n+use crate::ty::{self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, WithConstness};\n use crate::util::common::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_macros::HashStable;\n use rustc_span::{Span, DUMMY_SP};\n-use syntax::ast;\n \n use std::fmt::Debug;\n-use std::rc::Rc;\n \n pub use self::FulfillmentErrorCode::*;\n-pub use self::ObligationCauseCode::*;\n-pub use self::SelectionError::*;\n-pub use self::Vtable::*;\n \n pub use self::coherence::{add_placeholder_note, orphan_check, overlapping_impls};\n pub use self::coherence::{OrphanCheckErr, OverlapResult};\n@@ -81,10 +75,7 @@ pub use self::chalk_fulfill::{\n     CanonicalGoal as ChalkCanonicalGoal, FulfillmentContext as ChalkFulfillmentContext,\n };\n \n-pub use self::FulfillmentErrorCode::*;\n-pub use self::ObligationCauseCode::*;\n-pub use self::SelectionError::*;\n-pub use self::Vtable::*;\n+pub use self::types::*;\n \n /// Whether to enable bug compatibility with issue #43355.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -138,392 +129,12 @@ pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(PredicateObligation<'_>, 112);\n \n-/// The reason why we incurred this obligation; used for error reporting.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct ObligationCause<'tcx> {\n-    pub span: Span,\n-\n-    /// The ID of the fn body that triggered this obligation. This is\n-    /// used for region obligations to determine the precise\n-    /// environment in which the region obligation should be evaluated\n-    /// (in particular, closures can add new assumptions). See the\n-    /// field `region_obligations` of the `FulfillmentContext` for more\n-    /// information.\n-    pub body_id: hir::HirId,\n-\n-    pub code: ObligationCauseCode<'tcx>,\n-}\n-\n-impl ObligationCause<'_> {\n-    pub fn span(&self, tcx: TyCtxt<'_>) -> Span {\n-        match self.code {\n-            ObligationCauseCode::CompareImplMethodObligation { .. }\n-            | ObligationCauseCode::MainFunctionType\n-            | ObligationCauseCode::StartFunctionType => tcx.sess.source_map().def_span(self.span),\n-            ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                arm_span,\n-                ..\n-            }) => arm_span,\n-            _ => self.span,\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum ObligationCauseCode<'tcx> {\n-    /// Not well classified or should be obvious from the span.\n-    MiscObligation,\n-\n-    /// A slice or array is WF only if `T: Sized`.\n-    SliceOrArrayElem,\n-\n-    /// A tuple is WF only if its middle elements are `Sized`.\n-    TupleElem,\n-\n-    /// This is the trait reference from the given projection.\n-    ProjectionWf(ty::ProjectionTy<'tcx>),\n-\n-    /// In an impl of trait `X` for type `Y`, type `Y` must\n-    /// also implement all supertraits of `X`.\n-    ItemObligation(DefId),\n-\n-    /// Like `ItemObligation`, but with extra detail on the source of the obligation.\n-    BindingObligation(DefId, Span),\n-\n-    /// A type like `&'a T` is WF only if `T: 'a`.\n-    ReferenceOutlivesReferent(Ty<'tcx>),\n-\n-    /// A type like `Box<Foo<'a> + 'b>` is WF only if `'b: 'a`.\n-    ObjectTypeBound(Ty<'tcx>, ty::Region<'tcx>),\n-\n-    /// Obligation incurred due to an object cast.\n-    ObjectCastObligation(/* Object type */ Ty<'tcx>),\n-\n-    /// Obligation incurred due to a coercion.\n-    Coercion {\n-        source: Ty<'tcx>,\n-        target: Ty<'tcx>,\n-    },\n-\n-    /// Various cases where expressions must be `Sized` / `Copy` / etc.\n-    /// `L = X` implies that `L` is `Sized`.\n-    AssignmentLhsSized,\n-    /// `(x1, .., xn)` must be `Sized`.\n-    TupleInitializerSized,\n-    /// `S { ... }` must be `Sized`.\n-    StructInitializerSized,\n-    /// Type of each variable must be `Sized`.\n-    VariableType(hir::HirId),\n-    /// Argument type must be `Sized`.\n-    SizedArgumentType,\n-    /// Return type must be `Sized`.\n-    SizedReturnType,\n-    /// Yield type must be `Sized`.\n-    SizedYieldType,\n-    /// `[T, ..n]` implies that `T` must be `Copy`.\n-    /// If `true`, suggest `const_in_array_repeat_expressions` feature flag.\n-    RepeatVec(bool),\n-\n-    /// Types of fields (other than the last, except for packed structs) in a struct must be sized.\n-    FieldSized {\n-        adt_kind: AdtKind,\n-        last: bool,\n-    },\n-\n-    /// Constant expressions must be sized.\n-    ConstSized,\n-\n-    /// `static` items must have `Sync` type.\n-    SharedStatic,\n-\n-    BuiltinDerivedObligation(DerivedObligationCause<'tcx>),\n-\n-    ImplDerivedObligation(DerivedObligationCause<'tcx>),\n-\n-    /// Error derived when matching traits/impls; see ObligationCause for more details\n-    CompareImplMethodObligation {\n-        item_name: ast::Name,\n-        impl_item_def_id: DefId,\n-        trait_item_def_id: DefId,\n-    },\n-\n-    /// Error derived when matching traits/impls; see ObligationCause for more details\n-    CompareImplTypeObligation {\n-        item_name: ast::Name,\n-        impl_item_def_id: DefId,\n-        trait_item_def_id: DefId,\n-    },\n-\n-    /// Checking that this expression can be assigned where it needs to be\n-    // FIXME(eddyb) #11161 is the original Expr required?\n-    ExprAssignable,\n-\n-    /// Computing common supertype in the arms of a match expression\n-    MatchExpressionArm(Box<MatchExpressionArmCause<'tcx>>),\n-\n-    /// Type error arising from type checking a pattern against an expected type.\n-    Pattern {\n-        /// The span of the scrutinee or type expression which caused the `root_ty` type.\n-        span: Option<Span>,\n-        /// The root expected type induced by a scrutinee or type expression.\n-        root_ty: Ty<'tcx>,\n-        /// Whether the `Span` came from an expression or a type expression.\n-        origin_expr: bool,\n-    },\n-\n-    /// Constants in patterns must have `Structural` type.\n-    ConstPatternStructural,\n-\n-    /// Computing common supertype in an if expression\n-    IfExpression(Box<IfExpressionCause>),\n-\n-    /// Computing common supertype of an if expression with no else counter-part\n-    IfExpressionWithNoElse,\n-\n-    /// `main` has wrong type\n-    MainFunctionType,\n-\n-    /// `start` has wrong type\n-    StartFunctionType,\n-\n-    /// Intrinsic has wrong type\n-    IntrinsicType,\n-\n-    /// Method receiver\n-    MethodReceiver,\n-\n-    /// `return` with no expression\n-    ReturnNoExpression,\n-\n-    /// `return` with an expression\n-    ReturnValue(hir::HirId),\n-\n-    /// Return type of this function\n-    ReturnType,\n-\n-    /// Block implicit return\n-    BlockTailExpression(hir::HirId),\n-\n-    /// #[feature(trivial_bounds)] is not enabled\n-    TrivialBound,\n-\n-    AssocTypeBound(Box<AssocTypeBoundData>),\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct AssocTypeBoundData {\n-    pub impl_span: Option<Span>,\n-    pub original: Span,\n-    pub bounds: Vec<Span>,\n-}\n-\n-// `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(ObligationCauseCode<'_>, 32);\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct MatchExpressionArmCause<'tcx> {\n-    pub arm_span: Span,\n-    pub source: hir::MatchSource,\n-    pub prior_arms: Vec<Span>,\n-    pub last_ty: Ty<'tcx>,\n-    pub scrut_hir_id: hir::HirId,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct IfExpressionCause {\n-    pub then: Span,\n-    pub outer: Option<Span>,\n-    pub semicolon: Option<Span>,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct DerivedObligationCause<'tcx> {\n-    /// The trait reference of the parent obligation that led to the\n-    /// current obligation. Note that only trait obligations lead to\n-    /// derived obligations, so we just store the trait reference here\n-    /// directly.\n-    parent_trait_ref: ty::PolyTraitRef<'tcx>,\n-\n-    /// The parent trait had this cause.\n-    parent_code: Rc<ObligationCauseCode<'tcx>>,\n-}\n-\n pub type Obligations<'tcx, O> = Vec<Obligation<'tcx, O>>;\n pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n \n-/// The following types:\n-/// * `WhereClause`,\n-/// * `WellFormed`,\n-/// * `FromEnv`,\n-/// * `DomainGoal`,\n-/// * `Goal`,\n-/// * `Clause`,\n-/// * `Environment`,\n-/// * `InEnvironment`,\n-/// are used for representing the trait system in the form of\n-/// logic programming clauses. They are part of the interface\n-/// for the chalk SLG solver.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum WhereClause<'tcx> {\n-    Implemented(ty::TraitPredicate<'tcx>),\n-    ProjectionEq(ty::ProjectionPredicate<'tcx>),\n-    RegionOutlives(ty::RegionOutlivesPredicate<'tcx>),\n-    TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum WellFormed<'tcx> {\n-    Trait(ty::TraitPredicate<'tcx>),\n-    Ty(Ty<'tcx>),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum FromEnv<'tcx> {\n-    Trait(ty::TraitPredicate<'tcx>),\n-    Ty(Ty<'tcx>),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum DomainGoal<'tcx> {\n-    Holds(WhereClause<'tcx>),\n-    WellFormed(WellFormed<'tcx>),\n-    FromEnv(FromEnv<'tcx>),\n-    Normalize(ty::ProjectionPredicate<'tcx>),\n-}\n-\n-pub type PolyDomainGoal<'tcx> = ty::Binder<DomainGoal<'tcx>>;\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n-pub enum QuantifierKind {\n-    Universal,\n-    Existential,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum GoalKind<'tcx> {\n-    Implies(Clauses<'tcx>, Goal<'tcx>),\n-    And(Goal<'tcx>, Goal<'tcx>),\n-    Not(Goal<'tcx>),\n-    DomainGoal(DomainGoal<'tcx>),\n-    Quantified(QuantifierKind, ty::Binder<Goal<'tcx>>),\n-    Subtype(Ty<'tcx>, Ty<'tcx>),\n-    CannotProve,\n-}\n-\n-pub type Goal<'tcx> = &'tcx GoalKind<'tcx>;\n-\n-pub type Goals<'tcx> = &'tcx List<Goal<'tcx>>;\n-\n-impl<'tcx> DomainGoal<'tcx> {\n-    pub fn into_goal(self) -> GoalKind<'tcx> {\n-        GoalKind::DomainGoal(self)\n-    }\n-\n-    pub fn into_program_clause(self) -> ProgramClause<'tcx> {\n-        ProgramClause {\n-            goal: self,\n-            hypotheses: ty::List::empty(),\n-            category: ProgramClauseCategory::Other,\n-        }\n-    }\n-}\n-\n-impl<'tcx> GoalKind<'tcx> {\n-    pub fn from_poly_domain_goal(\n-        domain_goal: PolyDomainGoal<'tcx>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> GoalKind<'tcx> {\n-        match domain_goal.no_bound_vars() {\n-            Some(p) => p.into_goal(),\n-            None => GoalKind::Quantified(\n-                QuantifierKind::Universal,\n-                domain_goal.map_bound(|p| tcx.mk_goal(p.into_goal())),\n-            ),\n-        }\n-    }\n-}\n-\n-/// This matches the definition from Page 7 of \"A Proof Procedure for the Logic of Hereditary\n-/// Harrop Formulas\".\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub enum Clause<'tcx> {\n-    Implies(ProgramClause<'tcx>),\n-    ForAll(ty::Binder<ProgramClause<'tcx>>),\n-}\n-\n-impl Clause<'tcx> {\n-    pub fn category(self) -> ProgramClauseCategory {\n-        match self {\n-            Clause::Implies(clause) => clause.category,\n-            Clause::ForAll(clause) => clause.skip_binder().category,\n-        }\n-    }\n-}\n-\n-/// Multiple clauses.\n-pub type Clauses<'tcx> = &'tcx List<Clause<'tcx>>;\n-\n-/// A \"program clause\" has the form `D :- G1, ..., Gn`. It is saying\n-/// that the domain goal `D` is true if `G1...Gn` are provable. This\n-/// is equivalent to the implication `G1..Gn => D`; we usually write\n-/// it with the reverse implication operator `:-` to emphasize the way\n-/// that programs are actually solved (via backchaining, which starts\n-/// with the goal to solve and proceeds from there).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub struct ProgramClause<'tcx> {\n-    /// This goal will be considered true ...\n-    pub goal: DomainGoal<'tcx>,\n-\n-    /// ... if we can prove these hypotheses (there may be no hypotheses at all):\n-    pub hypotheses: Goals<'tcx>,\n-\n-    /// Useful for filtering clauses.\n-    pub category: ProgramClauseCategory,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n-pub enum ProgramClauseCategory {\n-    ImpliedBound,\n-    WellFormed,\n-    Other,\n-}\n-\n-/// A set of clauses that we assume to be true.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub struct Environment<'tcx> {\n-    pub clauses: Clauses<'tcx>,\n-}\n-\n-impl Environment<'tcx> {\n-    pub fn with<G>(self, goal: G) -> InEnvironment<'tcx, G> {\n-        InEnvironment { environment: self, goal }\n-    }\n-}\n-\n-/// Something (usually a goal), along with an environment.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub struct InEnvironment<'tcx, G> {\n-    pub environment: Environment<'tcx>,\n-    pub goal: G,\n-}\n-\n pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n \n-#[derive(Clone, Debug, TypeFoldable)]\n-pub enum SelectionError<'tcx> {\n-    Unimplemented,\n-    OutputTypeParameterMismatch(\n-        ty::PolyTraitRef<'tcx>,\n-        ty::PolyTraitRef<'tcx>,\n-        ty::error::TypeError<'tcx>,\n-    ),\n-    TraitNotObjectSafe(DefId),\n-    ConstEvalFailure(ErrorHandled),\n-    Overflow,\n-}\n-\n pub struct FulfillmentError<'tcx> {\n     pub obligation: PredicateObligation<'tcx>,\n     pub code: FulfillmentErrorCode<'tcx>,\n@@ -541,164 +152,6 @@ pub enum FulfillmentErrorCode<'tcx> {\n     CodeAmbiguity,\n }\n \n-/// When performing resolution, it is typically the case that there\n-/// can be one of three outcomes:\n-///\n-/// - `Ok(Some(r))`: success occurred with result `r`\n-/// - `Ok(None)`: could not definitely determine anything, usually due\n-///   to inconclusive type inference.\n-/// - `Err(e)`: error `e` occurred\n-pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n-\n-/// Given the successful resolution of an obligation, the `Vtable`\n-/// indicates where the vtable comes from. Note that while we call this\n-/// a \"vtable\", it does not necessarily indicate dynamic dispatch at\n-/// runtime. `Vtable` instances just tell the compiler where to find\n-/// methods, but in generic code those methods are typically statically\n-/// dispatched -- only when an object is constructed is a `Vtable`\n-/// instance reified into an actual vtable.\n-///\n-/// For example, the vtable may be tied to a specific impl (case A),\n-/// or it may be relative to some bound that is in scope (case B).\n-///\n-/// ```\n-/// impl<T:Clone> Clone<T> for Option<T> { ... } // Impl_1\n-/// impl<T:Clone> Clone<T> for Box<T> { ... }    // Impl_2\n-/// impl Clone for int { ... }             // Impl_3\n-///\n-/// fn foo<T:Clone>(concrete: Option<Box<int>>,\n-///                 param: T,\n-///                 mixed: Option<T>) {\n-///\n-///    // Case A: Vtable points at a specific impl. Only possible when\n-///    // type is concretely known. If the impl itself has bounded\n-///    // type parameters, Vtable will carry resolutions for those as well:\n-///    concrete.clone(); // Vtable(Impl_1, [Vtable(Impl_2, [Vtable(Impl_3)])])\n-///\n-///    // Case B: Vtable must be provided by caller. This applies when\n-///    // type is a type parameter.\n-///    param.clone();    // VtableParam\n-///\n-///    // Case C: A mix of cases A and B.\n-///    mixed.clone();    // Vtable(Impl_1, [VtableParam])\n-/// }\n-/// ```\n-///\n-/// ### The type parameter `N`\n-///\n-/// See explanation on `VtableImplData`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub enum Vtable<'tcx, N> {\n-    /// Vtable identifying a particular impl.\n-    VtableImpl(VtableImplData<'tcx, N>),\n-\n-    /// Vtable for auto trait implementations.\n-    /// This carries the information and nested obligations with regards\n-    /// to an auto implementation for a trait `Trait`. The nested obligations\n-    /// ensure the trait implementation holds for all the constituent types.\n-    VtableAutoImpl(VtableAutoImplData<N>),\n-\n-    /// Successful resolution to an obligation provided by the caller\n-    /// for some type parameter. The `Vec<N>` represents the\n-    /// obligations incurred from normalizing the where-clause (if\n-    /// any).\n-    VtableParam(Vec<N>),\n-\n-    /// Virtual calls through an object.\n-    VtableObject(VtableObjectData<'tcx, N>),\n-\n-    /// Successful resolution for a builtin trait.\n-    VtableBuiltin(VtableBuiltinData<N>),\n-\n-    /// Vtable automatically generated for a closure. The `DefId` is the ID\n-    /// of the closure expression. This is a `VtableImpl` in spirit, but the\n-    /// impl is generated by the compiler and does not appear in the source.\n-    VtableClosure(VtableClosureData<'tcx, N>),\n-\n-    /// Same as above, but for a function pointer type with the given signature.\n-    VtableFnPointer(VtableFnPointerData<'tcx, N>),\n-\n-    /// Vtable automatically generated for a generator.\n-    VtableGenerator(VtableGeneratorData<'tcx, N>),\n-\n-    /// Vtable for a trait alias.\n-    VtableTraitAlias(VtableTraitAliasData<'tcx, N>),\n-}\n-\n-/// Identifies a particular impl in the source, along with a set of\n-/// substitutions from the impl's type/lifetime parameters. The\n-/// `nested` vector corresponds to the nested obligations attached to\n-/// the impl's type parameters.\n-///\n-/// The type parameter `N` indicates the type used for \"nested\n-/// obligations\" that are required by the impl. During type-check, this\n-/// is `Obligation`, as one might expect. During codegen, however, this\n-/// is `()`, because codegen only requires a shallow resolution of an\n-/// impl, and nested obligations are satisfied later.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableImplData<'tcx, N> {\n-    pub impl_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableGeneratorData<'tcx, N> {\n-    pub generator_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    /// Nested obligations. This can be non-empty if the generator\n-    /// signature contains associated types.\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableClosureData<'tcx, N> {\n-    pub closure_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    /// Nested obligations. This can be non-empty if the closure\n-    /// signature contains associated types.\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableAutoImplData<N> {\n-    pub trait_def_id: DefId,\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableBuiltinData<N> {\n-    pub nested: Vec<N>,\n-}\n-\n-/// A vtable for some object-safe trait `Foo` automatically derived\n-/// for the object type `Foo`.\n-#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableObjectData<'tcx, N> {\n-    /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n-    pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n-\n-    /// The vtable is formed by concatenating together the method lists of\n-    /// the base object trait and all supertraits; this is the start of\n-    /// `upcast_trait_ref`'s methods in that vtable.\n-    pub vtable_base: usize,\n-\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableFnPointerData<'tcx, N> {\n-    pub fn_ty: Ty<'tcx>,\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableTraitAliasData<'tcx, N> {\n-    pub alias_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    pub nested: Vec<N>,\n-}\n-\n /// Creates predicate obligations from the generic bounds.\n pub fn predicates_for_generics<'tcx>(\n     cause: ObligationCause<'tcx>,\n@@ -1147,97 +600,6 @@ impl<'tcx, O> Obligation<'tcx, O> {\n     }\n }\n \n-impl<'tcx> ObligationCause<'tcx> {\n-    #[inline]\n-    pub fn new(\n-        span: Span,\n-        body_id: hir::HirId,\n-        code: ObligationCauseCode<'tcx>,\n-    ) -> ObligationCause<'tcx> {\n-        ObligationCause { span, body_id, code }\n-    }\n-\n-    pub fn misc(span: Span, body_id: hir::HirId) -> ObligationCause<'tcx> {\n-        ObligationCause { span, body_id, code: MiscObligation }\n-    }\n-\n-    pub fn dummy() -> ObligationCause<'tcx> {\n-        ObligationCause { span: DUMMY_SP, body_id: hir::CRATE_HIR_ID, code: MiscObligation }\n-    }\n-}\n-\n-impl ObligationCauseCode<'_> {\n-    // Return the base obligation, ignoring derived obligations.\n-    pub fn peel_derives(&self) -> &Self {\n-        let mut base_cause = self;\n-        while let BuiltinDerivedObligation(cause) | ImplDerivedObligation(cause) = base_cause {\n-            base_cause = &cause.parent_code;\n-        }\n-        base_cause\n-    }\n-}\n-\n-impl<'tcx, N> Vtable<'tcx, N> {\n-    pub fn nested_obligations(self) -> Vec<N> {\n-        match self {\n-            VtableImpl(i) => i.nested,\n-            VtableParam(n) => n,\n-            VtableBuiltin(i) => i.nested,\n-            VtableAutoImpl(d) => d.nested,\n-            VtableClosure(c) => c.nested,\n-            VtableGenerator(c) => c.nested,\n-            VtableObject(d) => d.nested,\n-            VtableFnPointer(d) => d.nested,\n-            VtableTraitAlias(d) => d.nested,\n-        }\n-    }\n-\n-    pub fn map<M, F>(self, f: F) -> Vtable<'tcx, M>\n-    where\n-        F: FnMut(N) -> M,\n-    {\n-        match self {\n-            VtableImpl(i) => VtableImpl(VtableImplData {\n-                impl_def_id: i.impl_def_id,\n-                substs: i.substs,\n-                nested: i.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableParam(n) => VtableParam(n.into_iter().map(f).collect()),\n-            VtableBuiltin(i) => {\n-                VtableBuiltin(VtableBuiltinData { nested: i.nested.into_iter().map(f).collect() })\n-            }\n-            VtableObject(o) => VtableObject(VtableObjectData {\n-                upcast_trait_ref: o.upcast_trait_ref,\n-                vtable_base: o.vtable_base,\n-                nested: o.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableAutoImpl(d) => VtableAutoImpl(VtableAutoImplData {\n-                trait_def_id: d.trait_def_id,\n-                nested: d.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableClosure(c) => VtableClosure(VtableClosureData {\n-                closure_def_id: c.closure_def_id,\n-                substs: c.substs,\n-                nested: c.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableGenerator(c) => VtableGenerator(VtableGeneratorData {\n-                generator_def_id: c.generator_def_id,\n-                substs: c.substs,\n-                nested: c.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableFnPointer(p) => VtableFnPointer(VtableFnPointerData {\n-                fn_ty: p.fn_ty,\n-                nested: p.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableTraitAlias(d) => VtableTraitAlias(VtableTraitAliasData {\n-                alias_def_id: d.alias_def_id,\n-                substs: d.substs,\n-                nested: d.nested.into_iter().map(f).collect(),\n-            }),\n-        }\n-    }\n-}\n-\n impl<'tcx> FulfillmentError<'tcx> {\n     fn new(\n         obligation: PredicateObligation<'tcx>,\n@@ -1265,42 +627,3 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         ..*providers\n     };\n }\n-\n-pub trait ExClauseFold<'tcx>\n-where\n-    Self: chalk_engine::context::Context + Clone,\n-{\n-    fn fold_ex_clause_with<F: TypeFolder<'tcx>>(\n-        ex_clause: &chalk_engine::ExClause<Self>,\n-        folder: &mut F,\n-    ) -> chalk_engine::ExClause<Self>;\n-\n-    fn visit_ex_clause_with<V: TypeVisitor<'tcx>>(\n-        ex_clause: &chalk_engine::ExClause<Self>,\n-        visitor: &mut V,\n-    ) -> bool;\n-}\n-\n-pub trait ChalkContextLift<'tcx>\n-where\n-    Self: chalk_engine::context::Context + Clone,\n-{\n-    type LiftedExClause: Debug + 'tcx;\n-    type LiftedDelayedLiteral: Debug + 'tcx;\n-    type LiftedLiteral: Debug + 'tcx;\n-\n-    fn lift_ex_clause_to_tcx(\n-        ex_clause: &chalk_engine::ExClause<Self>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<Self::LiftedExClause>;\n-\n-    fn lift_delayed_literal_to_tcx(\n-        ex_clause: &chalk_engine::DelayedLiteral<Self>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<Self::LiftedDelayedLiteral>;\n-\n-    fn lift_literal_to_tcx(\n-        ex_clause: &chalk_engine::Literal<Self>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<Self::LiftedLiteral>;\n-}"}, {"sha": "c4a066d5ec07aa4f62ee0edea2bc833f00d2cef3", "filename": "src/librustc/traits/types/mod.rs", "status": "added", "additions": 686, "deletions": 0, "changes": 686, "blob_url": "https://github.com/rust-lang/rust/blob/369f3601592f38b0689bb58b38094edd3164c9d9/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/369f3601592f38b0689bb58b38094edd3164c9d9/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs?ref=369f3601592f38b0689bb58b38094edd3164c9d9", "patch": "@@ -0,0 +1,686 @@\n+//! Trait Resolution. See the [rustc guide] for more information on how this works.\n+//!\n+//! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n+\n+use crate::mir::interpret::ErrorHandled;\n+use crate::ty::fold::{TypeFolder, TypeVisitor};\n+use crate::ty::subst::SubstsRef;\n+use crate::ty::{self, AdtKind, List, Ty, TyCtxt};\n+\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::{Span, DUMMY_SP};\n+use syntax::ast;\n+\n+use std::fmt::Debug;\n+use std::rc::Rc;\n+\n+pub use self::ObligationCauseCode::*;\n+pub use self::SelectionError::*;\n+pub use self::Vtable::*;\n+\n+/// The reason why we incurred this obligation; used for error reporting.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct ObligationCause<'tcx> {\n+    pub span: Span,\n+\n+    /// The ID of the fn body that triggered this obligation. This is\n+    /// used for region obligations to determine the precise\n+    /// environment in which the region obligation should be evaluated\n+    /// (in particular, closures can add new assumptions). See the\n+    /// field `region_obligations` of the `FulfillmentContext` for more\n+    /// information.\n+    pub body_id: hir::HirId,\n+\n+    pub code: ObligationCauseCode<'tcx>,\n+}\n+\n+impl<'tcx> ObligationCause<'tcx> {\n+    #[inline]\n+    pub fn new(\n+        span: Span,\n+        body_id: hir::HirId,\n+        code: ObligationCauseCode<'tcx>,\n+    ) -> ObligationCause<'tcx> {\n+        ObligationCause { span, body_id, code }\n+    }\n+\n+    pub fn misc(span: Span, body_id: hir::HirId) -> ObligationCause<'tcx> {\n+        ObligationCause { span, body_id, code: MiscObligation }\n+    }\n+\n+    pub fn dummy() -> ObligationCause<'tcx> {\n+        ObligationCause { span: DUMMY_SP, body_id: hir::CRATE_HIR_ID, code: MiscObligation }\n+    }\n+\n+    pub fn span(&self, tcx: TyCtxt<'tcx>) -> Span {\n+        match self.code {\n+            ObligationCauseCode::CompareImplMethodObligation { .. }\n+            | ObligationCauseCode::MainFunctionType\n+            | ObligationCauseCode::StartFunctionType => tcx.sess.source_map().def_span(self.span),\n+            ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                arm_span,\n+                ..\n+            }) => arm_span,\n+            _ => self.span,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum ObligationCauseCode<'tcx> {\n+    /// Not well classified or should be obvious from the span.\n+    MiscObligation,\n+\n+    /// A slice or array is WF only if `T: Sized`.\n+    SliceOrArrayElem,\n+\n+    /// A tuple is WF only if its middle elements are `Sized`.\n+    TupleElem,\n+\n+    /// This is the trait reference from the given projection.\n+    ProjectionWf(ty::ProjectionTy<'tcx>),\n+\n+    /// In an impl of trait `X` for type `Y`, type `Y` must\n+    /// also implement all supertraits of `X`.\n+    ItemObligation(DefId),\n+\n+    /// Like `ItemObligation`, but with extra detail on the source of the obligation.\n+    BindingObligation(DefId, Span),\n+\n+    /// A type like `&'a T` is WF only if `T: 'a`.\n+    ReferenceOutlivesReferent(Ty<'tcx>),\n+\n+    /// A type like `Box<Foo<'a> + 'b>` is WF only if `'b: 'a`.\n+    ObjectTypeBound(Ty<'tcx>, ty::Region<'tcx>),\n+\n+    /// Obligation incurred due to an object cast.\n+    ObjectCastObligation(/* Object type */ Ty<'tcx>),\n+\n+    /// Obligation incurred due to a coercion.\n+    Coercion {\n+        source: Ty<'tcx>,\n+        target: Ty<'tcx>,\n+    },\n+\n+    /// Various cases where expressions must be `Sized` / `Copy` / etc.\n+    /// `L = X` implies that `L` is `Sized`.\n+    AssignmentLhsSized,\n+    /// `(x1, .., xn)` must be `Sized`.\n+    TupleInitializerSized,\n+    /// `S { ... }` must be `Sized`.\n+    StructInitializerSized,\n+    /// Type of each variable must be `Sized`.\n+    VariableType(hir::HirId),\n+    /// Argument type must be `Sized`.\n+    SizedArgumentType,\n+    /// Return type must be `Sized`.\n+    SizedReturnType,\n+    /// Yield type must be `Sized`.\n+    SizedYieldType,\n+    /// `[T, ..n]` implies that `T` must be `Copy`.\n+    /// If `true`, suggest `const_in_array_repeat_expressions` feature flag.\n+    RepeatVec(bool),\n+\n+    /// Types of fields (other than the last, except for packed structs) in a struct must be sized.\n+    FieldSized {\n+        adt_kind: AdtKind,\n+        last: bool,\n+    },\n+\n+    /// Constant expressions must be sized.\n+    ConstSized,\n+\n+    /// `static` items must have `Sync` type.\n+    SharedStatic,\n+\n+    BuiltinDerivedObligation(DerivedObligationCause<'tcx>),\n+\n+    ImplDerivedObligation(DerivedObligationCause<'tcx>),\n+\n+    /// Error derived when matching traits/impls; see ObligationCause for more details\n+    CompareImplMethodObligation {\n+        item_name: ast::Name,\n+        impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+    },\n+\n+    /// Error derived when matching traits/impls; see ObligationCause for more details\n+    CompareImplTypeObligation {\n+        item_name: ast::Name,\n+        impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+    },\n+\n+    /// Checking that this expression can be assigned where it needs to be\n+    // FIXME(eddyb) #11161 is the original Expr required?\n+    ExprAssignable,\n+\n+    /// Computing common supertype in the arms of a match expression\n+    MatchExpressionArm(Box<MatchExpressionArmCause<'tcx>>),\n+\n+    /// Type error arising from type checking a pattern against an expected type.\n+    Pattern {\n+        /// The span of the scrutinee or type expression which caused the `root_ty` type.\n+        span: Option<Span>,\n+        /// The root expected type induced by a scrutinee or type expression.\n+        root_ty: Ty<'tcx>,\n+        /// Whether the `Span` came from an expression or a type expression.\n+        origin_expr: bool,\n+    },\n+\n+    /// Constants in patterns must have `Structural` type.\n+    ConstPatternStructural,\n+\n+    /// Computing common supertype in an if expression\n+    IfExpression(Box<IfExpressionCause>),\n+\n+    /// Computing common supertype of an if expression with no else counter-part\n+    IfExpressionWithNoElse,\n+\n+    /// `main` has wrong type\n+    MainFunctionType,\n+\n+    /// `start` has wrong type\n+    StartFunctionType,\n+\n+    /// Intrinsic has wrong type\n+    IntrinsicType,\n+\n+    /// Method receiver\n+    MethodReceiver,\n+\n+    /// `return` with no expression\n+    ReturnNoExpression,\n+\n+    /// `return` with an expression\n+    ReturnValue(hir::HirId),\n+\n+    /// Return type of this function\n+    ReturnType,\n+\n+    /// Block implicit return\n+    BlockTailExpression(hir::HirId),\n+\n+    /// #[feature(trivial_bounds)] is not enabled\n+    TrivialBound,\n+\n+    AssocTypeBound(Box<AssocTypeBoundData>),\n+}\n+\n+impl ObligationCauseCode<'_> {\n+    // Return the base obligation, ignoring derived obligations.\n+    pub fn peel_derives(&self) -> &Self {\n+        let mut base_cause = self;\n+        while let BuiltinDerivedObligation(cause) | ImplDerivedObligation(cause) = base_cause {\n+            base_cause = &cause.parent_code;\n+        }\n+        base_cause\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct AssocTypeBoundData {\n+    pub impl_span: Option<Span>,\n+    pub original: Span,\n+    pub bounds: Vec<Span>,\n+}\n+\n+// `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(ObligationCauseCode<'_>, 32);\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct MatchExpressionArmCause<'tcx> {\n+    pub arm_span: Span,\n+    pub source: hir::MatchSource,\n+    pub prior_arms: Vec<Span>,\n+    pub last_ty: Ty<'tcx>,\n+    pub scrut_hir_id: hir::HirId,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct IfExpressionCause {\n+    pub then: Span,\n+    pub outer: Option<Span>,\n+    pub semicolon: Option<Span>,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct DerivedObligationCause<'tcx> {\n+    /// The trait reference of the parent obligation that led to the\n+    /// current obligation. Note that only trait obligations lead to\n+    /// derived obligations, so we just store the trait reference here\n+    /// directly.\n+    pub parent_trait_ref: ty::PolyTraitRef<'tcx>,\n+\n+    /// The parent trait had this cause.\n+    pub parent_code: Rc<ObligationCauseCode<'tcx>>,\n+}\n+\n+/// The following types:\n+/// * `WhereClause`,\n+/// * `WellFormed`,\n+/// * `FromEnv`,\n+/// * `DomainGoal`,\n+/// * `Goal`,\n+/// * `Clause`,\n+/// * `Environment`,\n+/// * `InEnvironment`,\n+/// are used for representing the trait system in the form of\n+/// logic programming clauses. They are part of the interface\n+/// for the chalk SLG solver.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum WhereClause<'tcx> {\n+    Implemented(ty::TraitPredicate<'tcx>),\n+    ProjectionEq(ty::ProjectionPredicate<'tcx>),\n+    RegionOutlives(ty::RegionOutlivesPredicate<'tcx>),\n+    TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum WellFormed<'tcx> {\n+    Trait(ty::TraitPredicate<'tcx>),\n+    Ty(Ty<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum FromEnv<'tcx> {\n+    Trait(ty::TraitPredicate<'tcx>),\n+    Ty(Ty<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum DomainGoal<'tcx> {\n+    Holds(WhereClause<'tcx>),\n+    WellFormed(WellFormed<'tcx>),\n+    FromEnv(FromEnv<'tcx>),\n+    Normalize(ty::ProjectionPredicate<'tcx>),\n+}\n+\n+pub type PolyDomainGoal<'tcx> = ty::Binder<DomainGoal<'tcx>>;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n+pub enum QuantifierKind {\n+    Universal,\n+    Existential,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum GoalKind<'tcx> {\n+    Implies(Clauses<'tcx>, Goal<'tcx>),\n+    And(Goal<'tcx>, Goal<'tcx>),\n+    Not(Goal<'tcx>),\n+    DomainGoal(DomainGoal<'tcx>),\n+    Quantified(QuantifierKind, ty::Binder<Goal<'tcx>>),\n+    Subtype(Ty<'tcx>, Ty<'tcx>),\n+    CannotProve,\n+}\n+\n+pub type Goal<'tcx> = &'tcx GoalKind<'tcx>;\n+\n+pub type Goals<'tcx> = &'tcx List<Goal<'tcx>>;\n+\n+impl<'tcx> DomainGoal<'tcx> {\n+    pub fn into_goal(self) -> GoalKind<'tcx> {\n+        GoalKind::DomainGoal(self)\n+    }\n+\n+    pub fn into_program_clause(self) -> ProgramClause<'tcx> {\n+        ProgramClause {\n+            goal: self,\n+            hypotheses: ty::List::empty(),\n+            category: ProgramClauseCategory::Other,\n+        }\n+    }\n+}\n+\n+impl<'tcx> GoalKind<'tcx> {\n+    pub fn from_poly_domain_goal(\n+        domain_goal: PolyDomainGoal<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> GoalKind<'tcx> {\n+        match domain_goal.no_bound_vars() {\n+            Some(p) => p.into_goal(),\n+            None => GoalKind::Quantified(\n+                QuantifierKind::Universal,\n+                domain_goal.map_bound(|p| tcx.mk_goal(p.into_goal())),\n+            ),\n+        }\n+    }\n+}\n+\n+/// This matches the definition from Page 7 of \"A Proof Procedure for the Logic of Hereditary\n+/// Harrop Formulas\".\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub enum Clause<'tcx> {\n+    Implies(ProgramClause<'tcx>),\n+    ForAll(ty::Binder<ProgramClause<'tcx>>),\n+}\n+\n+impl Clause<'tcx> {\n+    pub fn category(self) -> ProgramClauseCategory {\n+        match self {\n+            Clause::Implies(clause) => clause.category,\n+            Clause::ForAll(clause) => clause.skip_binder().category,\n+        }\n+    }\n+}\n+\n+/// Multiple clauses.\n+pub type Clauses<'tcx> = &'tcx List<Clause<'tcx>>;\n+\n+/// A \"program clause\" has the form `D :- G1, ..., Gn`. It is saying\n+/// that the domain goal `D` is true if `G1...Gn` are provable. This\n+/// is equivalent to the implication `G1..Gn => D`; we usually write\n+/// it with the reverse implication operator `:-` to emphasize the way\n+/// that programs are actually solved (via backchaining, which starts\n+/// with the goal to solve and proceeds from there).\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub struct ProgramClause<'tcx> {\n+    /// This goal will be considered true ...\n+    pub goal: DomainGoal<'tcx>,\n+\n+    /// ... if we can prove these hypotheses (there may be no hypotheses at all):\n+    pub hypotheses: Goals<'tcx>,\n+\n+    /// Useful for filtering clauses.\n+    pub category: ProgramClauseCategory,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n+pub enum ProgramClauseCategory {\n+    ImpliedBound,\n+    WellFormed,\n+    Other,\n+}\n+\n+/// A set of clauses that we assume to be true.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub struct Environment<'tcx> {\n+    pub clauses: Clauses<'tcx>,\n+}\n+\n+impl Environment<'tcx> {\n+    pub fn with<G>(self, goal: G) -> InEnvironment<'tcx, G> {\n+        InEnvironment { environment: self, goal }\n+    }\n+}\n+\n+/// Something (usually a goal), along with an environment.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub struct InEnvironment<'tcx, G> {\n+    pub environment: Environment<'tcx>,\n+    pub goal: G,\n+}\n+\n+#[derive(Clone, Debug, TypeFoldable)]\n+pub enum SelectionError<'tcx> {\n+    Unimplemented,\n+    OutputTypeParameterMismatch(\n+        ty::PolyTraitRef<'tcx>,\n+        ty::PolyTraitRef<'tcx>,\n+        ty::error::TypeError<'tcx>,\n+    ),\n+    TraitNotObjectSafe(DefId),\n+    ConstEvalFailure(ErrorHandled),\n+    Overflow,\n+}\n+\n+/// When performing resolution, it is typically the case that there\n+/// can be one of three outcomes:\n+///\n+/// - `Ok(Some(r))`: success occurred with result `r`\n+/// - `Ok(None)`: could not definitely determine anything, usually due\n+///   to inconclusive type inference.\n+/// - `Err(e)`: error `e` occurred\n+pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n+\n+/// Given the successful resolution of an obligation, the `Vtable`\n+/// indicates where the vtable comes from. Note that while we call this\n+/// a \"vtable\", it does not necessarily indicate dynamic dispatch at\n+/// runtime. `Vtable` instances just tell the compiler where to find\n+/// methods, but in generic code those methods are typically statically\n+/// dispatched -- only when an object is constructed is a `Vtable`\n+/// instance reified into an actual vtable.\n+///\n+/// For example, the vtable may be tied to a specific impl (case A),\n+/// or it may be relative to some bound that is in scope (case B).\n+///\n+/// ```\n+/// impl<T:Clone> Clone<T> for Option<T> { ... } // Impl_1\n+/// impl<T:Clone> Clone<T> for Box<T> { ... }    // Impl_2\n+/// impl Clone for int { ... }             // Impl_3\n+///\n+/// fn foo<T:Clone>(concrete: Option<Box<int>>,\n+///                 param: T,\n+///                 mixed: Option<T>) {\n+///\n+///    // Case A: Vtable points at a specific impl. Only possible when\n+///    // type is concretely known. If the impl itself has bounded\n+///    // type parameters, Vtable will carry resolutions for those as well:\n+///    concrete.clone(); // Vtable(Impl_1, [Vtable(Impl_2, [Vtable(Impl_3)])])\n+///\n+///    // Case B: Vtable must be provided by caller. This applies when\n+///    // type is a type parameter.\n+///    param.clone();    // VtableParam\n+///\n+///    // Case C: A mix of cases A and B.\n+///    mixed.clone();    // Vtable(Impl_1, [VtableParam])\n+/// }\n+/// ```\n+///\n+/// ### The type parameter `N`\n+///\n+/// See explanation on `VtableImplData`.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub enum Vtable<'tcx, N> {\n+    /// Vtable identifying a particular impl.\n+    VtableImpl(VtableImplData<'tcx, N>),\n+\n+    /// Vtable for auto trait implementations.\n+    /// This carries the information and nested obligations with regards\n+    /// to an auto implementation for a trait `Trait`. The nested obligations\n+    /// ensure the trait implementation holds for all the constituent types.\n+    VtableAutoImpl(VtableAutoImplData<N>),\n+\n+    /// Successful resolution to an obligation provided by the caller\n+    /// for some type parameter. The `Vec<N>` represents the\n+    /// obligations incurred from normalizing the where-clause (if\n+    /// any).\n+    VtableParam(Vec<N>),\n+\n+    /// Virtual calls through an object.\n+    VtableObject(VtableObjectData<'tcx, N>),\n+\n+    /// Successful resolution for a builtin trait.\n+    VtableBuiltin(VtableBuiltinData<N>),\n+\n+    /// Vtable automatically generated for a closure. The `DefId` is the ID\n+    /// of the closure expression. This is a `VtableImpl` in spirit, but the\n+    /// impl is generated by the compiler and does not appear in the source.\n+    VtableClosure(VtableClosureData<'tcx, N>),\n+\n+    /// Same as above, but for a function pointer type with the given signature.\n+    VtableFnPointer(VtableFnPointerData<'tcx, N>),\n+\n+    /// Vtable automatically generated for a generator.\n+    VtableGenerator(VtableGeneratorData<'tcx, N>),\n+\n+    /// Vtable for a trait alias.\n+    VtableTraitAlias(VtableTraitAliasData<'tcx, N>),\n+}\n+\n+impl<'tcx, N> Vtable<'tcx, N> {\n+    pub fn nested_obligations(self) -> Vec<N> {\n+        match self {\n+            VtableImpl(i) => i.nested,\n+            VtableParam(n) => n,\n+            VtableBuiltin(i) => i.nested,\n+            VtableAutoImpl(d) => d.nested,\n+            VtableClosure(c) => c.nested,\n+            VtableGenerator(c) => c.nested,\n+            VtableObject(d) => d.nested,\n+            VtableFnPointer(d) => d.nested,\n+            VtableTraitAlias(d) => d.nested,\n+        }\n+    }\n+\n+    pub fn map<M, F>(self, f: F) -> Vtable<'tcx, M>\n+    where\n+        F: FnMut(N) -> M,\n+    {\n+        match self {\n+            VtableImpl(i) => VtableImpl(VtableImplData {\n+                impl_def_id: i.impl_def_id,\n+                substs: i.substs,\n+                nested: i.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableParam(n) => VtableParam(n.into_iter().map(f).collect()),\n+            VtableBuiltin(i) => {\n+                VtableBuiltin(VtableBuiltinData { nested: i.nested.into_iter().map(f).collect() })\n+            }\n+            VtableObject(o) => VtableObject(VtableObjectData {\n+                upcast_trait_ref: o.upcast_trait_ref,\n+                vtable_base: o.vtable_base,\n+                nested: o.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableAutoImpl(d) => VtableAutoImpl(VtableAutoImplData {\n+                trait_def_id: d.trait_def_id,\n+                nested: d.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableClosure(c) => VtableClosure(VtableClosureData {\n+                closure_def_id: c.closure_def_id,\n+                substs: c.substs,\n+                nested: c.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableGenerator(c) => VtableGenerator(VtableGeneratorData {\n+                generator_def_id: c.generator_def_id,\n+                substs: c.substs,\n+                nested: c.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableFnPointer(p) => VtableFnPointer(VtableFnPointerData {\n+                fn_ty: p.fn_ty,\n+                nested: p.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableTraitAlias(d) => VtableTraitAlias(VtableTraitAliasData {\n+                alias_def_id: d.alias_def_id,\n+                substs: d.substs,\n+                nested: d.nested.into_iter().map(f).collect(),\n+            }),\n+        }\n+    }\n+}\n+\n+/// Identifies a particular impl in the source, along with a set of\n+/// substitutions from the impl's type/lifetime parameters. The\n+/// `nested` vector corresponds to the nested obligations attached to\n+/// the impl's type parameters.\n+///\n+/// The type parameter `N` indicates the type used for \"nested\n+/// obligations\" that are required by the impl. During type-check, this\n+/// is `Obligation`, as one might expect. During codegen, however, this\n+/// is `()`, because codegen only requires a shallow resolution of an\n+/// impl, and nested obligations are satisfied later.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableImplData<'tcx, N> {\n+    pub impl_def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableGeneratorData<'tcx, N> {\n+    pub generator_def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    /// Nested obligations. This can be non-empty if the generator\n+    /// signature contains associated types.\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableClosureData<'tcx, N> {\n+    pub closure_def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    /// Nested obligations. This can be non-empty if the closure\n+    /// signature contains associated types.\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableAutoImplData<N> {\n+    pub trait_def_id: DefId,\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableBuiltinData<N> {\n+    pub nested: Vec<N>,\n+}\n+\n+/// A vtable for some object-safe trait `Foo` automatically derived\n+/// for the object type `Foo`.\n+#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableObjectData<'tcx, N> {\n+    /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n+    pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n+\n+    /// The vtable is formed by concatenating together the method lists of\n+    /// the base object trait and all supertraits; this is the start of\n+    /// `upcast_trait_ref`'s methods in that vtable.\n+    pub vtable_base: usize,\n+\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableFnPointerData<'tcx, N> {\n+    pub fn_ty: Ty<'tcx>,\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableTraitAliasData<'tcx, N> {\n+    pub alias_def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    pub nested: Vec<N>,\n+}\n+\n+pub trait ExClauseFold<'tcx>\n+where\n+    Self: chalk_engine::context::Context + Clone,\n+{\n+    fn fold_ex_clause_with<F: TypeFolder<'tcx>>(\n+        ex_clause: &chalk_engine::ExClause<Self>,\n+        folder: &mut F,\n+    ) -> chalk_engine::ExClause<Self>;\n+\n+    fn visit_ex_clause_with<V: TypeVisitor<'tcx>>(\n+        ex_clause: &chalk_engine::ExClause<Self>,\n+        visitor: &mut V,\n+    ) -> bool;\n+}\n+\n+pub trait ChalkContextLift<'tcx>\n+where\n+    Self: chalk_engine::context::Context + Clone,\n+{\n+    type LiftedExClause: Debug + 'tcx;\n+    type LiftedDelayedLiteral: Debug + 'tcx;\n+    type LiftedLiteral: Debug + 'tcx;\n+\n+    fn lift_ex_clause_to_tcx(\n+        ex_clause: &chalk_engine::ExClause<Self>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Option<Self::LiftedExClause>;\n+\n+    fn lift_delayed_literal_to_tcx(\n+        ex_clause: &chalk_engine::DelayedLiteral<Self>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Option<Self::LiftedDelayedLiteral>;\n+\n+    fn lift_literal_to_tcx(\n+        ex_clause: &chalk_engine::Literal<Self>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Option<Self::LiftedLiteral>;\n+}"}]}