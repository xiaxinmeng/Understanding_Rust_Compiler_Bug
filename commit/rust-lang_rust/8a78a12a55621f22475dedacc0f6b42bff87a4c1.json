{"sha": "8a78a12a55621f22475dedacc0f6b42bff87a4c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhNzhhMTJhNTU2MjFmMjI0NzVkZWRhY2MwZjZiNDJiZmY4N2E0YzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-27T22:22:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-27T22:22:01Z"}, "message": "Auto merge of #43438 - petrochenkov:path, r=jseyfried\n\nsyntax: Simplify parsing of paths\n\nDiscern between `Path` and `Path<>` in AST (but not in HIR).\nGive span to angle bracketed generic arguments (`::<'a, T>` in `path::segment::<'a, T>`).\n\nThis is a refactoring in preparation for https://internals.rust-lang.org/t/macro-path-uses-novel-syntax/5561/3, but it doesn't add anything to the grammar yet.\n\nr? @jseyfried", "tree": {"sha": "97a63159204b7e054f46044a7411734f5f8e37dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97a63159204b7e054f46044a7411734f5f8e37dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a78a12a55621f22475dedacc0f6b42bff87a4c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a78a12a55621f22475dedacc0f6b42bff87a4c1", "html_url": "https://github.com/rust-lang/rust/commit/8a78a12a55621f22475dedacc0f6b42bff87a4c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a78a12a55621f22475dedacc0f6b42bff87a4c1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52a3309695e82ed399c1a22b4e4fdde5d3aa0f3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/52a3309695e82ed399c1a22b4e4fdde5d3aa0f3b", "html_url": "https://github.com/rust-lang/rust/commit/52a3309695e82ed399c1a22b4e4fdde5d3aa0f3b"}, {"sha": "1e8a7f68e9c8dea677390b84fa72476ddb4bf1ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e8a7f68e9c8dea677390b84fa72476ddb4bf1ca", "html_url": "https://github.com/rust-lang/rust/commit/1e8a7f68e9c8dea677390b84fa72476ddb4bf1ca"}], "stats": {"total": 612, "additions": 301, "deletions": 311}, "files": [{"sha": "3ae3671b59347a783b2e7529b910ef01ecf1274f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -865,7 +865,7 @@ impl<'a> LoweringContext<'a> {\n                                             data: &AngleBracketedParameterData,\n                                             param_mode: ParamMode)\n                                             -> hir::AngleBracketedParameterData {\n-        let &AngleBracketedParameterData { ref lifetimes, ref types, ref bindings } = data;\n+        let &AngleBracketedParameterData { ref lifetimes, ref types, ref bindings, .. } = data;\n         hir::AngleBracketedParameterData {\n             lifetimes: self.lower_lifetimes(lifetimes),\n             types: types.iter().map(|ty| self.lower_ty(ty)).collect(),"}, {"sha": "38d8555334c355192d8563f25fbe9c1ea154f94e", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -195,10 +195,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         match item.node {\n             ItemKind::Use(ref view_path) => {\n                 let path = view_path.node.path();\n-                if path.segments.iter().any(|segment| segment.parameters.is_some()) {\n-                    self.err_handler()\n-                        .span_err(path.span, \"type or lifetime parameters in import path\");\n-                }\n+                path.segments.iter().find(|segment| segment.parameters.is_some()).map(|segment| {\n+                    self.err_handler().span_err(segment.parameters.as_ref().unwrap().span(),\n+                                                \"generic arguments in import path\");\n+                });\n             }\n             ItemKind::Impl(.., Some(..), _, ref impl_items) => {\n                 self.invalid_visibility(&item.vis, item.span, None);\n@@ -297,10 +297,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_vis(&mut self, vis: &'a Visibility) {\n         match *vis {\n             Visibility::Restricted { ref path, .. } => {\n-                if !path.segments.iter().all(|segment| segment.parameters.is_none()) {\n-                    self.err_handler()\n-                        .span_err(path.span, \"type or lifetime parameters in visibility path\");\n-                }\n+                path.segments.iter().find(|segment| segment.parameters.is_some()).map(|segment| {\n+                    self.err_handler().span_err(segment.parameters.as_ref().unwrap().span(),\n+                                                \"generic arguments in visibility path\");\n+                });\n             }\n             _ => {}\n         }"}, {"sha": "4d4f6aadce4df343bb92c9c9f327503f8df9e1c7", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -385,15 +385,21 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_macro_to_def(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n                             -> Result<Def, Determinacy> {\n-        let ast::Path { ref segments, span } = *path;\n-        if segments.iter().any(|segment| segment.parameters.is_some()) {\n-            let kind =\n-                if segments.last().unwrap().parameters.is_some() { \"macro\" } else { \"module\" };\n-            let msg = format!(\"type parameters are not allowed on {}s\", kind);\n-            self.session.span_err(path.span, &msg);\n-            return Err(Determinacy::Determined);\n+        let def = self.resolve_macro_to_def_inner(scope, path, kind, force);\n+        if def != Err(Determinacy::Undetermined) {\n+            // Do not report duplicated errors on every undetermined resolution.\n+            path.segments.iter().find(|segment| segment.parameters.is_some()).map(|segment| {\n+                self.session.span_err(segment.parameters.as_ref().unwrap().span(),\n+                                      \"generic arguments in macro path\");\n+            });\n         }\n+        def\n+    }\n \n+    fn resolve_macro_to_def_inner(&mut self, scope: Mark, path: &ast::Path,\n+                                  kind: MacroKind, force: bool)\n+                                  -> Result<Def, Determinacy> {\n+        let ast::Path { ref segments, span } = *path;\n         let path: Vec<_> = segments.iter().map(|seg| respan(seg.span, seg.identifier)).collect();\n         let invocation = self.invocations[&scope];\n         self.current_module = invocation.module.get();"}, {"sha": "4fc737873530e407bd45472f55b101e1602be889", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -120,12 +120,11 @@ pub struct PathSegment {\n     pub span: Span,\n \n     /// Type/lifetime parameters attached to this path. They come in\n-    /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`. Note that\n-    /// this is more than just simple syntactic sugar; the use of\n-    /// parens affects the region binding rules, so we preserve the\n-    /// distinction.\n-    /// The `Option<P<..>>` wrapper is purely a size optimization;\n-    /// `None` is used to represent both `Path` and `Path<>`.\n+    /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`.\n+    /// `None` means that no parameter list is supplied (`Path`),\n+    /// `Some` means that parameter list is supplied (`Path<X, Y>`)\n+    /// but it can be empty (`Path<>`).\n+    /// `P` is used as a size optimization for the common case with no parameters.\n     pub parameters: Option<P<PathParameters>>,\n }\n \n@@ -153,9 +152,20 @@ pub enum PathParameters {\n     Parenthesized(ParenthesizedParameterData),\n }\n \n+impl PathParameters {\n+    pub fn span(&self) -> Span {\n+        match *self {\n+            AngleBracketed(ref data) => data.span,\n+            Parenthesized(ref data) => data.span,\n+        }\n+    }\n+}\n+\n /// A path like `Foo<'a, T>`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Default)]\n pub struct AngleBracketedParameterData {\n+    /// Overall span\n+    pub span: Span,\n     /// The lifetime parameters for this path segment.\n     pub lifetimes: Vec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n@@ -168,8 +178,13 @@ pub struct AngleBracketedParameterData {\n \n impl Into<Option<P<PathParameters>>> for AngleBracketedParameterData {\n     fn into(self) -> Option<P<PathParameters>> {\n-        let empty = self.lifetimes.is_empty() && self.types.is_empty() && self.bindings.is_empty();\n-        if empty { None } else { Some(P(PathParameters::AngleBracketed(self))) }\n+        Some(P(PathParameters::AngleBracketed(self)))\n+    }\n+}\n+\n+impl Into<Option<P<PathParameters>>> for ParenthesizedParameterData {\n+    fn into(self) -> Option<P<PathParameters>> {\n+        Some(P(PathParameters::Parenthesized(self)))\n     }\n }\n "}, {"sha": "7eeafa72c682966ce6687772389c6399e3023f7b", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -608,7 +608,7 @@ pub trait Resolver {\n     fn check_unused_macros(&self);\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub enum Determinacy {\n     Determined,\n     Undetermined,"}, {"sha": "e004f7354ebde2309298d158775bbcaab8b80741", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -312,7 +312,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.path_all(span, true, strs, Vec::new(), Vec::new(), Vec::new())\n     }\n     fn path_all(&self,\n-                sp: Span,\n+                span: Span,\n                 global: bool,\n                 mut idents: Vec<ast::Ident> ,\n                 lifetimes: Vec<ast::Lifetime>,\n@@ -322,28 +322,17 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let last_identifier = idents.pop().unwrap();\n         let mut segments: Vec<ast::PathSegment> = Vec::new();\n         if global {\n-            segments.push(ast::PathSegment::crate_root(sp));\n+            segments.push(ast::PathSegment::crate_root(span));\n         }\n \n-        segments.extend(idents.into_iter().map(|i| ast::PathSegment::from_ident(i, sp)));\n-        let parameters = if lifetimes.is_empty() && types.is_empty() && bindings.is_empty() {\n-            None\n+        segments.extend(idents.into_iter().map(|i| ast::PathSegment::from_ident(i, span)));\n+        let parameters = if !lifetimes.is_empty() || !types.is_empty() || !bindings.is_empty() {\n+            ast::AngleBracketedParameterData { lifetimes, types, bindings, span }.into()\n         } else {\n-            Some(P(ast::PathParameters::AngleBracketed(ast::AngleBracketedParameterData {\n-                lifetimes: lifetimes,\n-                types: types,\n-                bindings: bindings,\n-            })))\n+            None\n         };\n-        segments.push(ast::PathSegment {\n-            identifier: last_identifier,\n-            span: sp,\n-            parameters: parameters\n-        });\n-        ast::Path {\n-            span: sp,\n-            segments: segments,\n-        }\n+        segments.push(ast::PathSegment { identifier: last_identifier, span, parameters });\n+        ast::Path { span, segments }\n     }\n \n     /// Constructs a qualified path.\n@@ -369,15 +358,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                  bindings: Vec<ast::TypeBinding>)\n                  -> (ast::QSelf, ast::Path) {\n         let mut path = trait_path;\n-        let parameters = ast::AngleBracketedParameterData {\n-            lifetimes: lifetimes,\n-            types: types,\n-            bindings: bindings,\n+        let parameters = if !lifetimes.is_empty() || !types.is_empty() || !bindings.is_empty() {\n+            ast::AngleBracketedParameterData { lifetimes, types, bindings, span: ident.span }.into()\n+        } else {\n+            None\n         };\n         path.segments.push(ast::PathSegment {\n             identifier: ident.node,\n             span: ident.span,\n-            parameters: Some(P(ast::PathParameters::AngleBracketed(parameters))),\n+            parameters: parameters,\n         });\n \n         (ast::QSelf {"}, {"sha": "8c616df858a49ab4a85bfa6888f20c6e6d28d5ce", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -471,10 +471,11 @@ pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedP\n                                                            fld: &mut T)\n                                                            -> AngleBracketedParameterData\n {\n-    let AngleBracketedParameterData { lifetimes, types, bindings } = data;\n+    let AngleBracketedParameterData { lifetimes, types, bindings, span } = data;\n     AngleBracketedParameterData { lifetimes: fld.fold_lifetimes(lifetimes),\n                                   types: types.move_map(|ty| fld.fold_ty(ty)),\n-                                  bindings: bindings.move_map(|b| fld.fold_ty_binding(b)) }\n+                                  bindings: bindings.move_map(|b| fld.fold_ty_binding(b)),\n+                                  span: fld.new_span(span) }\n }\n \n pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedParameterData,"}, {"sha": "d1591a219b325e72fed95a700ab08b4557b63247", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 125, "deletions": 250, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use abi::{self, Abi};\n-use ast::{AngleBracketedParameterData, AttrStyle, BareFnTy};\n+use ast::{AngleBracketedParameterData, ParenthesizedParameterData, AttrStyle, BareFnTy};\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::Unsafety;\n use ast::{Mod, Arg, Arm, Attribute, BindingMode, TraitItemKind};\n@@ -72,19 +72,27 @@ bitflags! {\n \n type ItemInfo = (Ident, ItemKind, Option<Vec<Attribute> >);\n \n-/// How to parse a path. There are three different kinds of paths, all of which\n-/// are parsed somewhat differently.\n+/// How to parse a path.\n #[derive(Copy, Clone, PartialEq)]\n pub enum PathStyle {\n-    /// A path with no type parameters, e.g. `foo::bar::Baz`, used in imports or visibilities.\n-    Mod,\n-    /// A path with a lifetime and type parameters, with no double colons\n-    /// before the type parameters; e.g. `foo::bar<'a>::Baz<T>`, used in types.\n-    /// Paths using this style can be passed into macros expecting `path` nonterminals.\n-    Type,\n-    /// A path with a lifetime and type parameters with double colons before\n-    /// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`, used in expressions or patterns.\n+    /// In some contexts, notably in expressions, paths with generic arguments are ambiguous\n+    /// with something else. For example, in expressions `segment < ....` can be interpreted\n+    /// as a comparison and `segment ( ....` can be interpreted as a function call.\n+    /// In all such contexts the non-path interpretation is preferred by default for practical\n+    /// reasons, but the path interpretation can be forced by the disambiguator `::`, e.g.\n+    /// `x<y>` - comparisons, `x::<y>` - unambiguously a path.\n     Expr,\n+    /// In other contexts, notably in types, no ambiguity exists and paths can be written\n+    /// without the disambiguator, e.g. `x<y>` - unambiguously a path.\n+    /// Paths with disambiguators are rejected for now, but may be allowed in the future.\n+    Type,\n+    /// A path with generic arguments disallowed, e.g. `foo::bar::Baz`, used in imports,\n+    /// visibilities or attributes.\n+    /// Technically, this variant is unnecessary and e.g. `Expr` can be used instead\n+    /// (paths in \"mod\" contexts have to be checked later for absence of generic arguments\n+    /// anyway, due to macros), but it is used to avoid weird suggestions about expected\n+    /// tokens when something goes wrong.\n+    Mod,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq)]\n@@ -1397,7 +1405,7 @@ impl<'a> Parser<'a> {\n             TyKind::Infer\n         } else if self.eat_lt() {\n             // Qualified path\n-            let (qself, path) = self.parse_qualified_path(PathStyle::Type)?;\n+            let (qself, path) = self.parse_qpath(PathStyle::Type)?;\n             TyKind::Path(Some(qself), path)\n         } else if self.token.is_path_start() {\n             // Simple path\n@@ -1683,108 +1691,58 @@ impl<'a> Parser<'a> {\n      }\n \n     /// Parses qualified path.\n-    ///\n     /// Assumes that the leading `<` has been parsed already.\n     ///\n-    /// Qualifed paths are a part of the universal function call\n-    /// syntax (UFCS).\n-    ///\n     /// `qualified_path = <type [as trait_ref]>::path`\n     ///\n-    /// See `parse_path` for `mode` meaning.\n-    ///\n-    /// # Examples:\n-    ///\n+    /// # Examples\n     /// `<T as U>::a`\n-    /// `<T as U>::F::a::<S>`\n-    pub fn parse_qualified_path(&mut self, mode: PathStyle)\n-                                -> PResult<'a, (QSelf, ast::Path)> {\n-        let span = self.prev_span;\n-        let self_type = self.parse_ty()?;\n+    /// `<T as U>::F::a<S>` (without disambiguator)\n+    /// `<T as U>::F::a::<S>` (with disambiguator)\n+    fn parse_qpath(&mut self, style: PathStyle) -> PResult<'a, (QSelf, ast::Path)> {\n+        let lo = self.prev_span;\n+        let ty = self.parse_ty()?;\n         let mut path = if self.eat_keyword(keywords::As) {\n             self.parse_path(PathStyle::Type)?\n         } else {\n-            ast::Path {\n-                span: span,\n-                segments: vec![]\n-            }\n-        };\n-\n-        let qself = QSelf {\n-            ty: self_type,\n-            position: path.segments.len()\n+            ast::Path { segments: Vec::new(), span: syntax_pos::DUMMY_SP }\n         };\n-\n         self.expect(&token::Gt)?;\n         self.expect(&token::ModSep)?;\n \n-        let segments = match mode {\n-            PathStyle::Type => {\n-                self.parse_path_segments_without_colons(true)?\n-            }\n-            PathStyle::Expr => {\n-                self.parse_path_segments_with_colons()?\n-            }\n-            PathStyle::Mod => {\n-                self.parse_path_segments_without_types()?\n-            }\n-        };\n-        path.segments.extend(segments);\n-\n-        path.span.hi = self.prev_span.hi;\n+        let qself = QSelf { ty, position: path.segments.len() };\n+        self.parse_path_segments(&mut path.segments, style)?;\n \n-        Ok((qself, path))\n+        Ok((qself, ast::Path { segments: path.segments, span: lo.to(self.prev_span) }))\n     }\n \n-    /// Parses a path and optional type parameter bounds, depending on the\n-    /// mode. The `mode` parameter determines whether lifetimes, types, and/or\n-    /// bounds are permitted and whether `::` must precede type parameter\n-    /// groups.\n-    pub fn parse_path(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> {\n-        self.parse_path_common(mode, true)\n-    }\n-\n-    pub fn parse_path_without_generics(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> {\n-        self.parse_path_common(mode, false)\n-    }\n-\n-    fn parse_path_common(&mut self, mode: PathStyle, parse_generics: bool)\n-        -> PResult<'a, ast::Path>\n+    /// Parses simple paths.\n+    ///\n+    /// `path = [::] segment+`\n+    /// `segment = ident | ident[::]<args> | ident[::](args) [-> type]`\n+    ///\n+    /// # Examples\n+    /// `a::b::C<D>` (without disambiguator)\n+    /// `a::b::C::<D>` (with disambiguator)\n+    /// `Fn(Args)` (without disambiguator)\n+    /// `Fn::(Args)` (with disambiguator)\n+    pub fn parse_path(&mut self, style: PathStyle) -> PResult<'a, ast::Path>\n     {\n         maybe_whole!(self, NtPath, |x| x);\n \n         let lo = self.meta_var_span.unwrap_or(self.span);\n-        let is_global = self.eat(&token::ModSep);\n-\n-        // Parse any number of segments and bound sets. A segment is an\n-        // identifier followed by an optional lifetime and a set of types.\n-        // A bound set is a set of type parameter bounds.\n-        let mut segments = match mode {\n-            PathStyle::Type => {\n-                self.parse_path_segments_without_colons(parse_generics)?\n-            }\n-            PathStyle::Expr => {\n-                self.parse_path_segments_with_colons()?\n-            }\n-            PathStyle::Mod => {\n-                self.parse_path_segments_without_types()?\n-            }\n-        };\n-\n-        if is_global {\n-            segments.insert(0, PathSegment::crate_root(lo));\n+        let mut segments = Vec::new();\n+        if self.eat(&token::ModSep) {\n+            segments.push(PathSegment::crate_root(lo));\n         }\n+        self.parse_path_segments(&mut segments, style)?;\n \n-        // Assemble the result.\n-        Ok(ast::Path {\n-            span: lo.to(self.prev_span),\n-            segments: segments,\n-        })\n+        Ok(ast::Path { segments, span: lo.to(self.prev_span) })\n     }\n \n     /// Like `parse_path`, but also supports parsing `Word` meta items into paths for back-compat.\n     /// This is used when parsing derive macro paths in `#[derive]` attributes.\n-    pub fn parse_path_allowing_meta(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> {\n+    pub fn parse_path_allowing_meta(&mut self, style: PathStyle) -> PResult<'a, ast::Path> {\n         let meta_ident = match self.token {\n             token::Interpolated(ref nt) => match nt.0 {\n                 token::NtMeta(ref meta) => match meta.node {\n@@ -1799,134 +1757,79 @@ impl<'a> Parser<'a> {\n             self.bump();\n             return Ok(ast::Path::from_ident(self.prev_span, ident));\n         }\n-        self.parse_path(mode)\n+        self.parse_path(style)\n     }\n \n-    /// Examples:\n-    /// - `a::b<T,U>::c<V,W>`\n-    /// - `a::b<T,U>::c(V) -> W`\n-    /// - `a::b<T,U>::c(V)`\n-    pub fn parse_path_segments_without_colons(&mut self, parse_generics: bool)\n-        -> PResult<'a, Vec<PathSegment>>\n-    {\n-        let mut segments = Vec::new();\n+    fn parse_path_segments(&mut self, segments: &mut Vec<PathSegment>, style: PathStyle)\n+                           -> PResult<'a, ()> {\n         loop {\n-            // First, parse an identifier.\n-            let ident_span = self.span;\n-            let identifier = self.parse_path_segment_ident()?;\n-\n-            if self.check(&token::ModSep) && self.look_ahead(1, |t| *t == token::Lt) {\n-                self.bump();\n-                let prev_span = self.prev_span;\n+            segments.push(self.parse_path_segment(style)?);\n \n-                let mut err = self.diagnostic().struct_span_err(prev_span,\n-                    \"unexpected token: `::`\");\n-                err.help(\n-                    \"use `<...>` instead of `::<...>` if you meant to specify type arguments\");\n-                err.emit();\n-            }\n-\n-            // Parse types, optionally.\n-            let parameters = if parse_generics && self.eat_lt() {\n-                let (lifetimes, types, bindings) = self.parse_generic_args()?;\n-                self.expect_gt()?;\n-                AngleBracketedParameterData { lifetimes, types, bindings }.into()\n-            } else if self.eat(&token::OpenDelim(token::Paren)) {\n-                let lo = self.prev_span;\n-\n-                let inputs = self.parse_seq_to_end(\n-                    &token::CloseDelim(token::Paren),\n-                    SeqSep::trailing_allowed(token::Comma),\n-                    |p| p.parse_ty())?;\n-\n-                let output_ty = if self.eat(&token::RArrow) {\n-                    Some(self.parse_ty_no_plus()?)\n-                } else {\n-                    None\n-                };\n-\n-                let hi = self.prev_span;\n-\n-                Some(P(ast::PathParameters::Parenthesized(ast::ParenthesizedParameterData {\n-                    span: lo.to(hi),\n-                    inputs: inputs,\n-                    output: output_ty,\n-                })))\n-            } else {\n-                None\n-            };\n-\n-            // Assemble and push the result.\n-            segments.push(PathSegment {\n-                identifier: identifier,\n-                span: ident_span,\n-                parameters: parameters\n-            });\n-\n-            // Continue only if we see a `::`\n-            if !self.eat(&token::ModSep) {\n-                return Ok(segments);\n+            if self.is_import_coupler() || !self.eat(&token::ModSep) {\n+                return Ok(());\n             }\n         }\n     }\n \n-    /// Examples:\n-    /// - `a::b::<T,U>::c`\n-    pub fn parse_path_segments_with_colons(&mut self) -> PResult<'a, Vec<PathSegment>> {\n-        let mut segments = Vec::new();\n-        loop {\n-            // First, parse an identifier.\n-            let ident_span = self.span;\n-            let identifier = self.parse_path_segment_ident()?;\n+    fn parse_path_segment(&mut self, style: PathStyle) -> PResult<'a, PathSegment> {\n+        let ident_span = self.span;\n+        let ident = self.parse_path_segment_ident()?;\n \n-            // If we do not see a `::`, stop.\n-            if !self.eat(&token::ModSep) {\n-                segments.push(PathSegment::from_ident(identifier, ident_span));\n-                return Ok(segments);\n+        let is_args_start = |token: &token::Token| match *token {\n+            token::Lt | token::BinOp(token::Shl) | token::OpenDelim(token::Paren) => true,\n+            _ => false,\n+        };\n+        let check_args_start = |this: &mut Self| {\n+            this.expected_tokens.extend_from_slice(\n+                &[TokenType::Token(token::Lt), TokenType::Token(token::OpenDelim(token::Paren))]\n+            );\n+            is_args_start(&this.token)\n+        };\n+\n+        Ok(if style == PathStyle::Type && check_args_start(self) ||\n+              style != PathStyle::Mod && self.check(&token::ModSep)\n+                                      && self.look_ahead(1, |t| is_args_start(t)) {\n+            // Generic arguments are found - `<`, `(`, `::<` or `::(`.\n+            let lo = self.span;\n+            if self.eat(&token::ModSep) {\n+                // These errors are not strictly necessary and may be removed in the future.\n+                if style == PathStyle::Type {\n+                    let mut err = self.diagnostic().struct_span_err(self.prev_span,\n+                        \"unnecessary path disambiguator\");\n+                    err.span_label(self.prev_span, \"try removing `::`\");\n+                    err.emit();\n+                } else if self.token == token::OpenDelim(token::Paren) {\n+                    self.diagnostic().span_err(self.prev_span,\n+                        \"`::` is not supported before parenthesized generic arguments\")\n+                }\n             }\n \n-            // Check for a type segment.\n-            if self.eat_lt() {\n-                // Consumed `a::b::<`, go look for types\n+            let parameters = if self.eat_lt() {\n+                // `<'a, T, A = U>`\n                 let (lifetimes, types, bindings) = self.parse_generic_args()?;\n                 self.expect_gt()?;\n-                segments.push(PathSegment {\n-                    identifier: identifier,\n-                    span: ident_span,\n-                    parameters: AngleBracketedParameterData { lifetimes, types, bindings }.into(),\n-                });\n-\n-                // Consumed `a::b::<T,U>`, check for `::` before proceeding\n-                if !self.eat(&token::ModSep) {\n-                    return Ok(segments);\n-                }\n+                let span = lo.to(self.prev_span);\n+                AngleBracketedParameterData { lifetimes, types, bindings, span }.into()\n             } else {\n-                // Consumed `a::`, go look for `b`\n-                segments.push(PathSegment::from_ident(identifier, ident_span));\n-            }\n-        }\n-    }\n-\n-    /// Examples:\n-    /// - `a::b::c`\n-    pub fn parse_path_segments_without_types(&mut self)\n-                                             -> PResult<'a, Vec<PathSegment>> {\n-        let mut segments = Vec::new();\n-        loop {\n-            // First, parse an identifier.\n-            let ident_span = self.span;\n-            let identifier = self.parse_path_segment_ident()?;\n-\n-            // Assemble and push the result.\n-            segments.push(PathSegment::from_ident(identifier, ident_span));\n+                // `(T, U) -> R`\n+                self.bump(); // `(`\n+                let inputs = self.parse_seq_to_end(&token::CloseDelim(token::Paren),\n+                                                   SeqSep::trailing_allowed(token::Comma),\n+                                                   |p| p.parse_ty())?;\n+                let output = if self.eat(&token::RArrow) {\n+                    Some(self.parse_ty_no_plus()?)\n+                } else {\n+                    None\n+                };\n+                let span = lo.to(self.prev_span);\n+                ParenthesizedParameterData { inputs, output, span }.into()\n+            };\n \n-            // If we do not see a `::` or see `::{`/`::*`, stop.\n-            if !self.check(&token::ModSep) || self.is_import_coupler() {\n-                return Ok(segments);\n-            } else {\n-                self.bump();\n-            }\n-        }\n+            PathSegment { identifier: ident, span: ident_span, parameters }\n+        } else {\n+            // Generic arguments are not found.\n+            PathSegment::from_ident(ident, ident_span)\n+        })\n     }\n \n     fn check_lifetime(&mut self) -> bool {\n@@ -2030,10 +1933,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn mk_field(&mut self, expr: P<Expr>, ident: ast::SpannedIdent) -> ast::ExprKind {\n-        ExprKind::Field(expr, ident)\n-    }\n-\n     pub fn mk_tup_field(&mut self, expr: P<Expr>, idx: codemap::Spanned<usize>) -> ast::ExprKind {\n         ExprKind::TupField(expr, idx)\n     }\n@@ -2178,8 +2077,7 @@ impl<'a> Parser<'a> {\n             }\n             _ => {\n                 if self.eat_lt() {\n-                    let (qself, path) =\n-                        self.parse_qualified_path(PathStyle::Expr)?;\n+                    let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n                     hi = path.span;\n                     return Ok(self.mk_expr(lo.to(hi), ExprKind::Path(Some(qself), path), attrs));\n                 }\n@@ -2439,50 +2337,33 @@ impl<'a> Parser<'a> {\n         )\n     }\n \n-    // Assuming we have just parsed `.foo` (i.e., a dot and an ident), continue\n-    // parsing into an expression.\n-    fn parse_dot_suffix(&mut self, ident: Ident, ident_span: Span, self_value: P<Expr>, lo: Span)\n-                        -> PResult<'a, P<Expr>> {\n-        let (lifetimes, types, bindings) = if self.eat(&token::ModSep) {\n-            self.expect_lt()?;\n-            let args = self.parse_generic_args()?;\n-            self.expect_gt()?;\n-            args\n-        } else {\n-            (Vec::new(), Vec::new(), Vec::new())\n-        };\n-\n+    // Assuming we have just parsed `.`, continue parsing into an expression.\n+    fn parse_dot_suffix(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n+        let segment = self.parse_path_segment(PathStyle::Expr)?;\n         Ok(match self.token {\n-            // expr.f() method call.\n             token::OpenDelim(token::Paren) => {\n-                let mut es = self.parse_unspanned_seq(\n+                // Method call `expr.f()`\n+                let mut args = self.parse_unspanned_seq(\n                     &token::OpenDelim(token::Paren),\n                     &token::CloseDelim(token::Paren),\n                     SeqSep::trailing_allowed(token::Comma),\n                     |p| Ok(p.parse_expr()?)\n                 )?;\n-                let hi = self.prev_span;\n+                args.insert(0, self_arg);\n \n-                es.insert(0, self_value);\n-                let seg = PathSegment {\n-                    identifier: ident,\n-                    span: ident_span.to(ident_span),\n-                    parameters: AngleBracketedParameterData { lifetimes, types, bindings }.into(),\n-                };\n-                self.mk_expr(lo.to(hi), ExprKind::MethodCall(seg, es), ThinVec::new())\n+                let span = lo.to(self.prev_span);\n+                self.mk_expr(span, ExprKind::MethodCall(segment, args), ThinVec::new())\n             }\n-            // Field access.\n             _ => {\n-                if let Some(generic_arg_span) = lifetimes.get(0).map(|x| x.span).or_else(||\n-                                                types.get(0).map(|x| x.span)).or_else(||\n-                                                bindings.get(0).map(|x| x.span)) {\n-                    self.span_err(generic_arg_span,\n+                // Field access `expr.f`\n+                if let Some(parameters) = segment.parameters {\n+                    self.span_err(parameters.span(),\n                                   \"field expressions may not have generic arguments\");\n                 }\n \n-                let id = respan(ident_span.to(ident_span), ident);\n-                let field = self.mk_field(self_value, id);\n-                self.mk_expr(lo.to(ident_span), field, ThinVec::new())\n+                let span = lo.to(self.prev_span);\n+                let ident = respan(segment.span, segment.identifier);\n+                self.mk_expr(span, ExprKind::Field(self_arg, ident), ThinVec::new())\n             }\n         })\n     }\n@@ -2500,10 +2381,8 @@ impl<'a> Parser<'a> {\n             // expr.f\n             if self.eat(&token::Dot) {\n                 match self.token {\n-                  token::Ident(i) => {\n-                    let ident_span = self.span;\n-                    self.bump();\n-                    e = self.parse_dot_suffix(i, ident_span, e, lo)?;\n+                  token::Ident(..) => {\n+                    e = self.parse_dot_suffix(e, lo)?;\n                   }\n                   token::Literal(token::Integer(n), suf) => {\n                     let sp = self.span;\n@@ -2561,9 +2440,6 @@ impl<'a> Parser<'a> {\n                     // FIXME Could factor this out into non_fatal_unexpected or something.\n                     let actual = self.this_token_to_string();\n                     self.span_err(self.span, &format!(\"unexpected token: `{}`\", actual));\n-\n-                    let dot_span = self.prev_span;\n-                    e = self.parse_dot_suffix(keywords::Invalid.ident(), dot_span, e, lo)?;\n                   }\n                 }\n                 continue;\n@@ -2928,7 +2804,7 @@ impl<'a> Parser<'a> {\n                 let parser_snapshot_after_type = self.clone();\n                 mem::replace(self, parser_snapshot_before_type);\n \n-                match self.parse_path_without_generics(PathStyle::Type) {\n+                match self.parse_path(PathStyle::Expr) {\n                     Ok(path) => {\n                         // Successfully parsed the type path leaving a `<` yet to parse.\n                         type_err.cancel();\n@@ -3455,8 +3331,7 @@ impl<'a> Parser<'a> {\n             let lo = self.span;\n             let (qself, path) = if self.eat_lt() {\n                 // Parse a qualified path\n-                let (qself, path) =\n-                    self.parse_qualified_path(PathStyle::Expr)?;\n+                let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n                 (Some(qself), path)\n             } else {\n                 // Parse an unqualified path\n@@ -3554,7 +3429,7 @@ impl<'a> Parser<'a> {\n                 // Parse pattern starting with a path\n                 let (qself, path) = if self.eat_lt() {\n                     // Parse a qualified path\n-                    let (qself, path) = self.parse_qualified_path(PathStyle::Expr)?;\n+                    let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n                     (Some(qself), path)\n                 } else {\n                     // Parse an unqualified path"}, {"sha": "3a701f91314b6b2a3084054b1fddec81580940fc", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -239,6 +239,12 @@ pub struct SpanLabel {\n     pub label: Option<String>,\n }\n \n+impl Default for Span {\n+    fn default() -> Self {\n+        DUMMY_SP\n+    }\n+}\n+\n impl serialize::UseSpecializedEncodable for Span {\n     fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_struct(\"Span\", 2, |s| {"}, {"sha": "737955b2ff351a0580326424318a2d758ca5189c", "filename": "src/test/compile-fail/issue-36116.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fcompile-fail%2Fissue-36116.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fcompile-fail%2Fissue-36116.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-36116.rs?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -14,10 +14,10 @@ struct Foo<T> {\n \n fn main() {\n     let f = Some(Foo { _a: 42 }).map(|a| a as Foo::<i32>);\n-    //~^ ERROR unexpected token: `::`\n-    //~| HELP use `<...>` instead of `::<...>` if you meant to specify type arguments\n+    //~^ ERROR unnecessary path disambiguator\n+    //~| NOTE try removing `::`\n \n     let g: Foo::<i32> = Foo { _a: 42 };\n-    //~^ ERROR unexpected token: `::`\n-    //~| HELP use `<...>` instead of `::<...>` if you meant to specify type arguments\n+    //~^ ERROR unnecessary path disambiguator\n+    //~| NOTE try removing `::`\n }"}, {"sha": "0f123997ca1d975560de09c9bcb3cd72f7c19686", "filename": "src/test/compile-fail/macro-with-seps-err-msg.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fcompile-fail%2Fmacro-with-seps-err-msg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fcompile-fail%2Fmacro-with-seps-err-msg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-with-seps-err-msg.rs?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -12,7 +12,6 @@\n \n fn main() {\n     globnar::brotz!(); //~ ERROR non-ident macro paths are experimental\n-    ::foo!(); //~ ERROR non-ident macro paths are experimental\n-    foo::<T>!(); //~ ERROR type parameters are not allowed on macros\n     #[derive(foo::Bar)] struct T; //~ ERROR non-ident macro paths are experimental\n+    ::foo!(); //~ ERROR non-ident macro paths are experimental\n }"}, {"sha": "bc7c333723d8ef7e10c8261bba497155edcb7273", "filename": "src/test/compile-fail/parse-error-correct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fcompile-fail%2Fparse-error-correct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fcompile-fail%2Fparse-error-correct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fparse-error-correct.rs?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -17,5 +17,6 @@ fn main() {\n     let y = 42;\n     let x = y.;  //~ ERROR unexpected token\n     let x = y.();  //~ ERROR unexpected token\n+                   //~^ ERROR expected function, found `{integer}`\n     let x = y.foo; //~ ERROR `{integer}` is a primitive type and therefore doesn't have fields [E061\n }"}, {"sha": "95c307c5670990ae72a21635cbd848cd1e77692f", "filename": "src/test/parse-fail/type-parameters-in-field-exprs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fparse-fail%2Ftype-parameters-in-field-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fparse-fail%2Ftype-parameters-in-field-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftype-parameters-in-field-exprs.rs?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n \n struct Foo {\n     x: isize,\n@@ -22,4 +22,6 @@ fn main() {\n     };\n     f.x::<isize>;\n     //~^ ERROR field expressions may not have generic arguments\n+    f.x::<>;\n+    //~^ ERROR field expressions may not have generic arguments\n }"}, {"sha": "548a5078a747bd848120a63373c9e55a33b92f59", "filename": "src/test/parse-fail/unboxed-closure-sugar-used-on-struct-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fparse-fail%2Funboxed-closure-sugar-used-on-struct-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fparse-fail%2Funboxed-closure-sugar-used-on-struct-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Funboxed-closure-sugar-used-on-struct-3.rs?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -24,7 +24,7 @@ fn bar() {\n     let b = Box::Bar::<isize,usize>::new(); // OK\n \n     let b = Box::Bar::()::new();\n-    //~^ ERROR expected identifier, found `(`\n+    //~^ ERROR `::` is not supported before parenthesized generic arguments\n }\n \n fn main() { }"}, {"sha": "d1e3d20f4ba1e99a7b20488f3cf351c9fe27342e", "filename": "src/test/ui/span/import-ty-params.rs", "status": "renamed", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fui%2Fspan%2Fimport-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fui%2Fspan%2Fimport-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fimport-ty-params.rs?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -20,6 +20,11 @@ macro_rules! import {\n     ($p: path) => (use $p;);\n }\n \n-import! { a::b::c::S<u8> } //~ERROR type or lifetime parameters in import path\n+fn f1() {\n+    import! { a::b::c::S<u8> } //~ ERROR generic arguments in import path\n+}\n+fn f2() {\n+    import! { a::b::c::S<> } //~ ERROR generic arguments in import path\n+}\n \n fn main() {}", "previous_filename": "src/test/compile-fail/import-ty-params.rs"}, {"sha": "de959a14cc5bbea72575b61b5ce2f4bcd4ed4ae9", "filename": "src/test/ui/span/import-ty-params.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fui%2Fspan%2Fimport-ty-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fui%2Fspan%2Fimport-ty-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fimport-ty-params.stderr?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -0,0 +1,14 @@\n+error: generic arguments in import path\n+  --> $DIR/import-ty-params.rs:24:25\n+   |\n+24 |     import! { a::b::c::S<u8> } //~ ERROR generic arguments in import path\n+   |                         ^^^^\n+\n+error: generic arguments in import path\n+  --> $DIR/import-ty-params.rs:27:25\n+   |\n+27 |     import! { a::b::c::S<> } //~ ERROR generic arguments in import path\n+   |                         ^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "08a7518dff9d740e6fff644b209af5062ed83b0a", "filename": "src/test/ui/span/macro-ty-params.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.rs?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! m {\n+    ($p1: path) => {\n+        #[derive($p1)] struct U;\n+    }\n+}\n+\n+fn main() {\n+    foo::<T>!();\n+    //~^ ERROR generic arguments in macro path\n+    //~| ERROR generic arguments in macro path\n+    //~| ERROR generic arguments in macro path\n+    foo::<>!();\n+    //~^ ERROR generic arguments in macro path\n+    //~| ERROR generic arguments in macro path\n+    //~| ERROR generic arguments in macro path\n+    m!(MyTrait<>);\n+    //~^ ERROR generic arguments in macro path\n+    //~| ERROR generic arguments in macro path\n+    //~| ERROR generic arguments in macro path\n+    //~| ERROR generic arguments in macro path\n+}"}, {"sha": "f7115a0482666084017bddb1e35a422e49df569a", "filename": "src/test/ui/span/macro-ty-params.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -0,0 +1,20 @@\n+error: generic arguments in macro path\n+  --> $DIR/macro-ty-params.rs:18:8\n+   |\n+18 |     foo::<T>!();\n+   |        ^^^^^\n+\n+error: generic arguments in macro path\n+  --> $DIR/macro-ty-params.rs:22:8\n+   |\n+22 |     foo::<>!();\n+   |        ^^^^\n+\n+error: generic arguments in macro path\n+  --> $DIR/macro-ty-params.rs:26:15\n+   |\n+26 |     m!(MyTrait<>);\n+   |               ^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "8d4817e80b95c1d3a35ef01628f6cd032cdd886d", "filename": "src/test/ui/span/visibility-ty-params.rs", "status": "renamed", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.rs?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -13,7 +13,11 @@ macro_rules! m {\n }\n \n struct S<T>(T);\n-m!{ S<u8> } //~ ERROR type or lifetime parameters in visibility path\n+m!{ S<u8> } //~ ERROR generic arguments in visibility path\n //~^ ERROR expected module, found struct `S`\n \n+mod m {\n+    m!{ m<> } //~ ERROR generic arguments in visibility path\n+}\n+\n fn main() {}", "previous_filename": "src/test/compile-fail/privacy/restricted/ty-params.rs"}, {"sha": "0460b7ca025a67fecfb5e6588082d46f8787dbc9", "filename": "src/test/ui/span/visibility-ty-params.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a78a12a55621f22475dedacc0f6b42bff87a4c1/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.stderr?ref=8a78a12a55621f22475dedacc0f6b42bff87a4c1", "patch": "@@ -0,0 +1,22 @@\n+error[E0577]: expected module, found struct `S`\n+  --> $DIR/visibility-ty-params.rs:16:5\n+   |\n+16 | m!{ S<u8> } //~ ERROR generic arguments in visibility path\n+   |     -^^^^\n+   |     |\n+   |     did you mean `m`?\n+\n+error: generic arguments in visibility path\n+  --> $DIR/visibility-ty-params.rs:16:6\n+   |\n+16 | m!{ S<u8> } //~ ERROR generic arguments in visibility path\n+   |      ^^^^\n+\n+error: generic arguments in visibility path\n+  --> $DIR/visibility-ty-params.rs:20:10\n+   |\n+20 |     m!{ m<> } //~ ERROR generic arguments in visibility path\n+   |          ^^\n+\n+error: aborting due to 3 previous errors\n+"}]}