{"sha": "d1642f1eb51c349c3caa940da43f0b5a51111011", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxNjQyZjFlYjUxYzM0OWMzY2FhOTQwZGE0M2YwYjVhNTExMTEwMTE=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-09T21:01:26Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-15T16:44:33Z"}, "message": "Inline now-trivial IntRange::from_ctor", "tree": {"sha": "03d90deab56cebad1c0a880d3b2849cde6c0864c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03d90deab56cebad1c0a880d3b2849cde6c0864c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1642f1eb51c349c3caa940da43f0b5a51111011", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1642f1eb51c349c3caa940da43f0b5a51111011", "html_url": "https://github.com/rust-lang/rust/commit/d1642f1eb51c349c3caa940da43f0b5a51111011", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1642f1eb51c349c3caa940da43f0b5a51111011/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aadd5e52636c4a48fd515357cad78b9f010074ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/aadd5e52636c4a48fd515357cad78b9f010074ca", "html_url": "https://github.com/rust-lang/rust/commit/aadd5e52636c4a48fd515357cad78b9f010074ca"}], "stats": {"total": 84, "additions": 28, "deletions": 56}, "files": [{"sha": "090bcb8be16ad810236414fe74d6872ddb86ea52", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 28, "deletions": 56, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d1642f1eb51c349c3caa940da43f0b5a51111011/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1642f1eb51c349c3caa940da43f0b5a51111011/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=d1642f1eb51c349c3caa940da43f0b5a51111011", "patch": "@@ -659,12 +659,7 @@ impl<'tcx> Constructor<'tcx> {\n \n     // Returns the set of constructors covered by `self` but not by\n     // anything in `other_ctors`.\n-    fn subtract_ctors(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        other_ctors: &Vec<Constructor<'tcx>>,\n-    ) -> Vec<Constructor<'tcx>> {\n+    fn subtract_ctors(&self, other_ctors: &Vec<Constructor<'tcx>>) -> Vec<Constructor<'tcx>> {\n         match self {\n             // Those constructors can only match themselves.\n             Single | Variant(_) => {\n@@ -747,22 +742,22 @@ impl<'tcx> Constructor<'tcx> {\n             }\n             IntRange(self_range) => {\n                 let mut remaining_ranges = vec![self_range.clone()];\n-                let other_ranges =\n-                    other_ctors.into_iter().filter_map(|c| IntRange::from_ctor(tcx, param_env, c));\n-                for other_range in other_ranges {\n-                    if other_range == *self_range {\n-                        // If the `self` range appears directly in a `match` arm, we can\n-                        // eliminate it straight away.\n-                        remaining_ranges = vec![];\n-                    } else {\n-                        // Otherwise explicitely compute the remaining ranges.\n-                        remaining_ranges = other_range.subtract_from(remaining_ranges);\n-                    }\n+                for other_ctor in other_ctors {\n+                    if let IntRange(other_range) = other_ctor {\n+                        if other_range == self_range {\n+                            // If the `self` range appears directly in a `match` arm, we can\n+                            // eliminate it straight away.\n+                            remaining_ranges = vec![];\n+                        } else {\n+                            // Otherwise explicitely compute the remaining ranges.\n+                            remaining_ranges = other_range.subtract_from(remaining_ranges);\n+                        }\n \n-                    // If the ranges that have been considered so far already cover the entire\n-                    // range of values, we can return early.\n-                    if remaining_ranges.is_empty() {\n-                        break;\n+                        // If the ranges that have been considered so far already cover the entire\n+                        // range of values, we can return early.\n+                        if remaining_ranges.is_empty() {\n+                            break;\n+                        }\n                     }\n                 }\n \n@@ -773,7 +768,7 @@ impl<'tcx> Constructor<'tcx> {\n                 if other_ctors.iter().any(|c| {\n                     c == self\n                         // FIXME(Nadrieril): This condition looks fishy\n-                        || IntRange::from_ctor(tcx, param_env, c).is_some()\n+                        || c.is_integral_range()\n                 }) {\n                     vec![]\n                 } else {\n@@ -1364,26 +1359,15 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n-    fn from_ctor(\n-        _tcx: TyCtxt<'tcx>,\n-        _param_env: ty::ParamEnv<'tcx>,\n-        ctor: &Constructor<'tcx>,\n-    ) -> Option<IntRange<'tcx>> {\n-        // Floating-point ranges are permitted and we don't want\n-        // to consider them when constructing integer ranges.\n-        match ctor {\n-            IntRange(range) => Some(range.clone()),\n-            _ => None,\n-        }\n-    }\n-\n     fn from_pat(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         pat: &Pat<'tcx>,\n     ) -> Option<IntRange<'tcx>> {\n-        let ctor = pat_constructor(tcx, param_env, pat)?;\n-        IntRange::from_ctor(tcx, param_env, &ctor)\n+        match pat_constructor(tcx, param_env, pat)? {\n+            IntRange(range) => Some(range),\n+            _ => None,\n+        }\n     }\n \n     // The return value of `signed_bias` should be XORed with an endpoint to encode/decode it.\n@@ -1490,20 +1474,13 @@ impl<'tcx> std::cmp::PartialEq for IntRange<'tcx> {\n \n // A struct to compute a set of constructors equivalent to `all_ctors \\ used_ctors`.\n struct MissingConstructors<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n     all_ctors: Vec<Constructor<'tcx>>,\n     used_ctors: Vec<Constructor<'tcx>>,\n }\n \n impl<'tcx> MissingConstructors<'tcx> {\n-    fn new(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        all_ctors: Vec<Constructor<'tcx>>,\n-        used_ctors: Vec<Constructor<'tcx>>,\n-    ) -> Self {\n-        MissingConstructors { tcx, param_env, all_ctors, used_ctors }\n+    fn new(all_ctors: Vec<Constructor<'tcx>>, used_ctors: Vec<Constructor<'tcx>>) -> Self {\n+        MissingConstructors { all_ctors, used_ctors }\n     }\n \n     fn into_inner(self) -> (Vec<Constructor<'tcx>>, Vec<Constructor<'tcx>>) {\n@@ -1521,9 +1498,7 @@ impl<'tcx> MissingConstructors<'tcx> {\n \n     /// Iterate over all_ctors \\ used_ctors\n     fn iter<'a>(&'a self) -> impl Iterator<Item = Constructor<'tcx>> + Captures<'a> {\n-        self.all_ctors.iter().flat_map(move |req_ctor| {\n-            req_ctor.subtract_ctors(self.tcx, self.param_env, &self.used_ctors)\n-        })\n+        self.all_ctors.iter().flat_map(move |req_ctor| req_ctor.subtract_ctors(&self.used_ctors))\n     }\n }\n \n@@ -1649,7 +1624,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         // Missing constructors are those that are not matched by any non-wildcard patterns in the\n         // current column. We only fully construct them on-demand, because they're rarely used and\n         // can be big.\n-        let missing_ctors = MissingConstructors::new(cx.tcx, cx.param_env, all_ctors, used_ctors);\n+        let missing_ctors = MissingConstructors::new(all_ctors, used_ctors);\n \n         debug!(\"missing_ctors.empty()={:#?}\", missing_ctors.is_empty(),);\n \n@@ -2305,12 +2280,9 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n             // If the constructor is a:\n             // - Single value: add a row if the pattern contains the constructor.\n             // - Range: add a row if the constructor intersects the pattern.\n-            if constructor.is_integral_range() {\n-                match (\n-                    IntRange::from_ctor(cx.tcx, cx.param_env, constructor),\n-                    IntRange::from_pat(cx.tcx, cx.param_env, pat),\n-                ) {\n-                    (Some(ctor), Some(pat)) => ctor.intersection(cx.tcx, &pat).map(|_| {\n+            if let IntRange(ctor) = constructor {\n+                match IntRange::from_pat(cx.tcx, cx.param_env, pat) {\n+                    Some(pat) => ctor.intersection(cx.tcx, &pat).map(|_| {\n                         // Constructor splitting should ensure that all intersections we encounter\n                         // are actually inclusions.\n                         let (pat_lo, pat_hi) = pat.boundaries();"}]}