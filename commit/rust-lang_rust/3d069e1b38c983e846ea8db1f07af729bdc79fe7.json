{"sha": "3d069e1b38c983e846ea8db1f07af729bdc79fe7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMDY5ZTFiMzhjOTgzZTg0NmVhOGRiMWYwN2FmNzI5YmRjNzlmZTc=", "commit": {"author": {"name": "Keith Yeung", "email": "kungfukeith11@gmail.com", "date": "2016-11-28T18:08:08Z"}, "committer": {"name": "Keith Yeung", "email": "kungfukeith11@gmail.com", "date": "2016-12-04T01:12:28Z"}, "message": "Add TypeVariableOrigin enum", "tree": {"sha": "addaba9f6cf9eba16496953b999e1051d11a4e70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/addaba9f6cf9eba16496953b999e1051d11a4e70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d069e1b38c983e846ea8db1f07af729bdc79fe7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d069e1b38c983e846ea8db1f07af729bdc79fe7", "html_url": "https://github.com/rust-lang/rust/commit/3d069e1b38c983e846ea8db1f07af729bdc79fe7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d069e1b38c983e846ea8db1f07af729bdc79fe7/comments", "author": {"login": "KiChjang", "id": 3248587, "node_id": "MDQ6VXNlcjMyNDg1ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/3248587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KiChjang", "html_url": "https://github.com/KiChjang", "followers_url": "https://api.github.com/users/KiChjang/followers", "following_url": "https://api.github.com/users/KiChjang/following{/other_user}", "gists_url": "https://api.github.com/users/KiChjang/gists{/gist_id}", "starred_url": "https://api.github.com/users/KiChjang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KiChjang/subscriptions", "organizations_url": "https://api.github.com/users/KiChjang/orgs", "repos_url": "https://api.github.com/users/KiChjang/repos", "events_url": "https://api.github.com/users/KiChjang/events{/privacy}", "received_events_url": "https://api.github.com/users/KiChjang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "KiChjang", "id": 3248587, "node_id": "MDQ6VXNlcjMyNDg1ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/3248587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KiChjang", "html_url": "https://github.com/KiChjang", "followers_url": "https://api.github.com/users/KiChjang/followers", "following_url": "https://api.github.com/users/KiChjang/following{/other_user}", "gists_url": "https://api.github.com/users/KiChjang/gists{/gist_id}", "starred_url": "https://api.github.com/users/KiChjang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KiChjang/subscriptions", "organizations_url": "https://api.github.com/users/KiChjang/orgs", "repos_url": "https://api.github.com/users/KiChjang/repos", "events_url": "https://api.github.com/users/KiChjang/events{/privacy}", "received_events_url": "https://api.github.com/users/KiChjang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5db4826410b4ffcc0e4cb45566a0411a0858b6bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/5db4826410b4ffcc0e4cb45566a0411a0858b6bf", "html_url": "https://github.com/rust-lang/rust/commit/5db4826410b4ffcc0e4cb45566a0411a0858b6bf"}], "stats": {"total": 182, "additions": 129, "deletions": 53}, "files": [{"sha": "8ccadc6b2af044819d5c7a2f4586d4ef6cf5b8f8", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=3d069e1b38c983e846ea8db1f07af729bdc79fe7", "patch": "@@ -13,6 +13,7 @@ use super::InferCtxt;\n use super::lattice::{self, LatticeDir};\n use super::Subtype;\n \n+use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n \n@@ -83,6 +84,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> LatticeDir<'infcx, 'gcx, 'tcx>\n         self.fields.infcx\n     }\n \n+    fn cause(&self) -> &ObligationCause<'tcx> {\n+        &self.fields.trace.cause\n+    }\n+\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(&v, &a)?;"}, {"sha": "f7b26a918b3a200d182c5651aab55e7ea562cac1", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=3d069e1b38c983e846ea8db1f07af729bdc79fe7", "patch": "@@ -30,14 +30,18 @@\n //! a lattice.\n \n use super::InferCtxt;\n+use super::type_variable::TypeVariableOrigin;\n \n+use traits::ObligationCause;\n use ty::TyVar;\n use ty::{self, Ty};\n use ty::relate::{RelateResult, TypeRelation};\n \n pub trait LatticeDir<'f, 'gcx: 'f+'tcx, 'tcx: 'f> : TypeRelation<'f, 'gcx, 'tcx> {\n     fn infcx(&self) -> &'f InferCtxt<'f, 'gcx, 'tcx>;\n \n+    fn cause(&self) -> &ObligationCause<'tcx>;\n+\n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n@@ -64,14 +68,15 @@ pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,\n     match (&a.sty, &b.sty) {\n         (&ty::TyInfer(TyVar(..)), &ty::TyInfer(TyVar(..)))\n             if infcx.type_var_diverges(a) && infcx.type_var_diverges(b) => {\n-            let v = infcx.next_diverging_ty_var();\n+            let v = infcx.next_diverging_ty_var(\n+                TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, a, b)?;\n             Ok(v)\n         }\n \n         (&ty::TyInfer(TyVar(..)), _) |\n         (_, &ty::TyInfer(TyVar(..))) => {\n-            let v = infcx.next_ty_var();\n+            let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, a, b)?;\n             Ok(v)\n         }"}, {"sha": "89571dea10c3425b56c3cdefadcc0d59f0994a96", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=3d069e1b38c983e846ea8db1f07af729bdc79fe7", "patch": "@@ -13,6 +13,7 @@ use super::InferCtxt;\n use super::lattice::{self, LatticeDir};\n use super::Subtype;\n \n+use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n \n@@ -83,6 +84,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> LatticeDir<'infcx, 'gcx, 'tcx>\n         self.fields.infcx\n     }\n \n+    fn cause(&self) -> &ObligationCause<'tcx> {\n+        &self.fields.trace.cause\n+    }\n+\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(&a, &v)?;"}, {"sha": "9b58334e65805a6822fa4446bf9271ff81dd037b", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=3d069e1b38c983e846ea8db1f07af729bdc79fe7", "patch": "@@ -45,6 +45,7 @@ use util::nodemap::{FxHashMap, FxHashSet, NodeMap};\n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n+use self::type_variable::TypeVariableOrigin;\n use self::unify_key::ToType;\n \n mod bivariate;\n@@ -114,7 +115,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // We instantiate UnificationTable with bounds<Ty> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n-    type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n+    pub type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n \n     // Map from integral variable to the kind of integer it represents\n     int_unification_table: RefCell<UnificationTable<ty::IntVid>>,\n@@ -1054,18 +1055,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn next_ty_var_id(&self, diverging: bool) -> TyVid {\n+    pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n         self.type_variables\n             .borrow_mut()\n-            .new_var(diverging, None)\n+            .new_var(diverging, origin, None)\n     }\n \n-    pub fn next_ty_var(&self) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(false))\n+    pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_var(self.next_ty_var_id(false, origin))\n     }\n \n-    pub fn next_diverging_ty_var(&self) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(true))\n+    pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_var(self.next_ty_var_id(true, origin))\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {\n@@ -1118,7 +1119,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         let ty_var_id = self.type_variables\n                             .borrow_mut()\n-                            .new_var(false, default);\n+                            .new_var(false,\n+                                     TypeVariableOrigin::TypeParameterDefinition(span, def.name),\n+                                     default);\n \n         self.tcx.mk_var(ty_var_id)\n     }"}, {"sha": "9c8419d9546d24b4f03745e4738a9f179f54f3ff", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=3d069e1b38c983e846ea8db1f07af729bdc79fe7", "patch": "@@ -13,6 +13,7 @@ use self::TypeVariableValue::*;\n use self::UndoEntry::*;\n use hir::def_id::{DefId};\n use syntax::util::small_vector::SmallVector;\n+use syntax::ast;\n use syntax_pos::Span;\n use ty::{self, Ty};\n \n@@ -28,8 +29,24 @@ pub struct TypeVariableTable<'tcx> {\n     eq_relations: ut::UnificationTable<ty::TyVid>,\n }\n \n+/// Reasons to create a type inference variable\n+pub enum TypeVariableOrigin {\n+    MiscVariable(Span),\n+    NormalizeProjectionType(Span),\n+    TypeInference(Span),\n+    TypeParameterDefinition(Span, ast::Name),\n+    TransformedUpvar(Span),\n+    SubstitutionPlaceholder(Span),\n+    AutoDeref(Span),\n+    AdjustmentType(Span),\n+    DivergingStmt(Span),\n+    DivergingBlockExpr(Span),\n+    LatticeVariable(Span),\n+}\n+\n struct TypeVariableData<'tcx> {\n     value: TypeVariableValue<'tcx>,\n+    origin: TypeVariableOrigin,\n     diverging: bool\n }\n \n@@ -107,6 +124,10 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         self.values.get(vid.index as usize).diverging\n     }\n \n+    pub fn var_origin(&self, vid: ty::TyVid) -> &TypeVariableOrigin {\n+        &self.values.get(vid.index as usize).origin\n+    }\n+\n     /// Records that `a <: b`, `a :> b`, or `a == b`, depending on `dir`.\n     ///\n     /// Precondition: neither `a` nor `b` are known.\n@@ -173,10 +194,12 @@ impl<'tcx> TypeVariableTable<'tcx> {\n \n     pub fn new_var(&mut self,\n                    diverging: bool,\n-                   default: Option<Default<'tcx>>) -> ty::TyVid {\n+                   origin: TypeVariableOrigin,\n+                   default: Option<Default<'tcx>>,) -> ty::TyVid {\n         self.eq_relations.new_key(());\n         let index = self.values.push(TypeVariableData {\n             value: Bounded { relations: vec![], default: default },\n+            origin: origin,\n             diverging: diverging\n         });\n         let v = ty::TyVid { index: index as u32 };"}, {"sha": "bed834e237d61a5ce475b72d8daaaa459dd821b2", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=3d069e1b38c983e846ea8db1f07af729bdc79fe7", "patch": "@@ -27,6 +27,7 @@ use super::{\n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n+use infer::type_variable::TypeVariableOrigin;\n use rustc::lint::builtin::EXTRA_REQUIREMENT_IN_IMPL;\n use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::error::ExpectedFound;\n@@ -38,7 +39,7 @@ use util::nodemap::{FxHashMap, FxHashSet};\n use std::cmp;\n use std::fmt;\n use syntax::ast;\n-use syntax_pos::Span;\n+use syntax_pos::{DUMMY_SP, Span};\n use errors::DiagnosticBuilder;\n \n #[derive(Debug, PartialEq, Eq, Hash)]\n@@ -790,9 +791,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.infcx.tcx }\n \n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-                if let ty::TyParam(..) = ty.sty {\n+                if let ty::TyParam(ty::ParamTy {name, ..}) = ty.sty {\n                     let infcx = self.infcx;\n-                    self.var_map.entry(ty).or_insert_with(|| infcx.next_ty_var())\n+                    self.var_map.entry(ty).or_insert_with(||\n+                        infcx.next_ty_var(\n+                            TypeVariableOrigin::TypeParameterDefinition(DUMMY_SP, name)))\n                 } else {\n                     ty.super_fold_with(self)\n                 }"}, {"sha": "865bc2a95608b987a1391c79f0f909214fc8bd05", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=3d069e1b38c983e846ea8db1f07af729bdc79fe7", "patch": "@@ -25,6 +25,7 @@ use super::util;\n \n use hir::def_id::DefId;\n use infer::InferOk;\n+use infer::type_variable::TypeVariableOrigin;\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use syntax::ast;\n use syntax::symbol::Symbol;\n@@ -382,7 +383,12 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             // and a deferred predicate to resolve this when more type\n             // information is available.\n \n-            let ty_var = selcx.infcx().next_ty_var();\n+            let tcx = selcx.infcx().tcx;\n+            let def_id = tcx.associated_items(projection_ty.trait_ref.def_id).find(|i|\n+                i.name == projection_ty.item_name && i.kind == ty::AssociatedKind::Type\n+            ).map(|i| i.def_id).unwrap();\n+            let ty_var = selcx.infcx().next_ty_var(\n+                TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n             let projection = ty::Binder(ty::ProjectionPredicate {\n                 projection_ty: projection_ty,\n                 ty: ty_var\n@@ -596,7 +602,12 @@ fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tc\n     let trait_obligation = Obligation { cause: cause,\n                                         recursion_depth: depth,\n                                         predicate: trait_ref.to_predicate() };\n-    let new_value = selcx.infcx().next_ty_var();\n+    let tcx = selcx.infcx().tcx;\n+    let def_id = tcx.associated_items(projection_ty.trait_ref.def_id).find(|i|\n+        i.name == projection_ty.item_name && i.kind == ty::AssociatedKind::Type\n+    ).map(|i| i.def_id).unwrap();\n+    let new_value = selcx.infcx().next_ty_var(\n+        TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n     Normalized {\n         value: new_value,\n         obligations: vec![trait_obligation]"}, {"sha": "ad7def42b8965b6e75f00d1d1a343180fadaf637", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=3d069e1b38c983e846ea8db1f07af729bdc79fe7", "patch": "@@ -24,6 +24,7 @@ use rustc::ty::subst::{Kind, Subst};\n use rustc::traits::{ObligationCause, Reveal};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::infer::{self, InferOk, InferResult};\n+use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc_metadata::cstore::CStore;\n use rustc::hir::map as hir_map;\n use rustc::session::{self, config};\n@@ -36,6 +37,7 @@ use errors::emitter::Emitter;\n use errors::{Level, DiagnosticBuilder};\n use syntax::feature_gate::UnstableFeatures;\n use syntax::symbol::Symbol;\n+use syntax_pos::DUMMY_SP;\n \n use rustc::hir;\n \n@@ -494,7 +496,7 @@ fn sub_free_bound_false_infer() {\n     //! does NOT hold for any instantiation of `_#1`.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_infer1 = env.infcx.next_ty_var();\n+        let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         env.check_not_sub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n                           env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n@@ -513,7 +515,7 @@ fn lub_free_bound_infer() {\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         env.create_simple_region_hierarchy();\n-        let t_infer1 = env.infcx.next_ty_var();\n+        let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(1, 1);\n         env.check_lub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n@@ -633,7 +635,7 @@ fn glb_bound_free() {\n fn glb_bound_free_infer() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_infer1 = env.infcx.next_ty_var();\n+        let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n \n         // compute GLB(fn(_) -> isize, for<'b> fn(&'b isize) -> isize),\n         // which should yield for<'b> fn(&'b isize) -> isize"}, {"sha": "b652f3c4ad734c639906196d0c33d84d5b96c455", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=3d069e1b38c983e846ea8db1f07af729bdc79fe7", "patch": "@@ -12,6 +12,7 @@ use rustc::hir::{self, PatKind};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::infer;\n+use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::ObligationCauseCode;\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n use check::{FnCtxt, Expectation, Diverges};\n@@ -162,7 +163,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 let max_len = cmp::max(expected_len, elements.len());\n \n-                let element_tys_iter = (0..max_len).map(|_| self.next_ty_var());\n+                let element_tys_iter = (0..max_len).map(|_| self.next_ty_var(\n+                    // FIXME: MiscVariable for now, obtaining the span and name information\n+                    //       from all tuple elements isn't trivial.\n+                    TypeVariableOrigin::TypeInference(pat.span)));\n                 let element_tys = tcx.mk_type_list(element_tys_iter);\n                 let pat_ty = tcx.mk_ty(ty::TyTuple(element_tys));\n                 self.demand_eqtype(pat.span, expected, pat_ty);\n@@ -172,7 +176,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 pat_ty\n             }\n             PatKind::Box(ref inner) => {\n-                let inner_ty = self.next_ty_var();\n+                let inner_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(inner.span));\n                 let uniq_ty = tcx.mk_box(inner_ty);\n \n                 if self.check_dereferencable(pat.span, expected, &inner) {\n@@ -203,7 +207,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             (expected, mt.ty)\n                         }\n                         _ => {\n-                            let inner_ty = self.next_ty_var();\n+                            let inner_ty = self.next_ty_var(\n+                                TypeVariableOrigin::TypeInference(inner.span));\n                             let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n                             let region = self.next_region_var(infer::PatternRegion(pat.span));\n                             let rptr_ty = tcx.mk_ref(region, mt);\n@@ -379,7 +384,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // ...but otherwise we want to use any supertype of the\n             // discriminant. This is sort of a workaround, see note (*) in\n             // `check_pat` for some details.\n-            discrim_ty = self.next_ty_var();\n+            discrim_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(discrim.span));\n             self.check_expr_has_type(discrim, discrim_ty);\n         };\n         let discrim_diverges = self.diverges.get();\n@@ -407,7 +412,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // of execution reach it, we will panic, so bottom is an appropriate\n         // type in that case)\n         let expected = expected.adjust_for_branches(self);\n-        let mut result_ty = self.next_diverging_ty_var();\n+        let mut result_ty = self.next_diverging_ty_var(\n+            TypeVariableOrigin::DivergingBlockExpr(expr.span));\n         let mut all_arms_diverge = Diverges::WarnedAlways;\n         let coerce_first = match expected {\n             // We don't coerce to `()` so that if the match expression is a"}, {"sha": "870c3045e6bdbb3ae1bf291178f9679674f1bb8d", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=3d069e1b38c983e846ea8db1f07af729bdc79fe7", "patch": "@@ -13,6 +13,7 @@\n use super::{check_fn, Expectation, FnCtxt};\n \n use astconv::AstConv;\n+use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::ty::{self, ToPolyTraitRef, Ty};\n use std::cmp;\n use syntax::abi::Abi;\n@@ -65,7 +66,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let closure_type = self.tcx.mk_closure(expr_def_id,\n             self.parameter_environment.free_substs.extend_to(self.tcx, expr_def_id,\n                 |_, _| span_bug!(expr.span, \"closure has region param\"),\n-                |_, _| self.infcx.next_ty_var()\n+                |_, _| self.infcx.next_ty_var(TypeVariableOrigin::TransformedUpvar(expr.span))\n             )\n         );\n "}, {"sha": "5cb0804b1bca19e1972fb953237cd821ac296b0b", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=3d069e1b38c983e846ea8db1f07af729bdc79fe7", "patch": "@@ -20,6 +20,7 @@ use rustc::infer::InferOk;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, ObligationCause};\n use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n+use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::util::nodemap::FxHashSet;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -1225,7 +1226,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let substs = Substs::for_item(self.tcx,\n                                       impl_def_id,\n                                       |_, _| self.tcx.mk_region(ty::ReErased),\n-                                      |_, _| self.next_ty_var());\n+                                      |_, _| self.next_ty_var(\n+                                        TypeVariableOrigin::SubstitutionPlaceholder(\n+                                            self.tcx.def_span(impl_def_id))));\n \n         (impl_ty, substs)\n     }"}, {"sha": "86bfede87b333c6d6e7a7897c8d95d991fdf905c", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=3d069e1b38c983e846ea8db1f07af729bdc79fe7", "patch": "@@ -28,6 +28,7 @@ use syntax_pos::Span;\n \n use rustc::hir::print as pprust;\n use rustc::hir;\n+use rustc::infer::type_variable::TypeVariableOrigin;\n \n use std::cell;\n use std::cmp::Ordering;\n@@ -53,7 +54,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 self.autoderef(span, ty).any(|(ty, _)| {\n                     self.probe(|_| {\n-                        let fn_once_substs = tcx.mk_substs_trait(ty, &[self.next_ty_var()]);\n+                        let fn_once_substs = tcx.mk_substs_trait(ty,\n+                            &[self.next_ty_var(TypeVariableOrigin::MiscVariable(span))]);\n                         let trait_ref = ty::TraitRef::new(fn_once, fn_once_substs);\n                         let poly_trait_ref = trait_ref.to_poly_trait_ref();\n                         let obligation ="}, {"sha": "502a93a4aa2dae157c7bcb71c0563c6b5237ebbb", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3d069e1b38c983e846ea8db1f07af729bdc79fe7", "patch": "@@ -85,8 +85,8 @@ use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n use hir::def::{Def, CtorKind};\n use hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin,\n-                   TypeTrace, type_variable};\n+use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin, TypeTrace};\n+use rustc::infer::type_variable::{self, TypeVariableOrigin};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n@@ -117,7 +117,7 @@ use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, InternedString, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax_pos::{self, BytePos, Span};\n+use syntax_pos::{self, BytePos, Span, DUMMY_SP};\n \n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -683,11 +683,11 @@ struct GatherLocalsVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n-    fn assign(&mut self, _span: Span, nid: ast::NodeId, ty_opt: Option<Ty<'tcx>>) -> Ty<'tcx> {\n+    fn assign(&mut self, span: Span, nid: ast::NodeId, ty_opt: Option<Ty<'tcx>>) -> Ty<'tcx> {\n         match ty_opt {\n             None => {\n                 // infer the variable's type\n-                let var_ty = self.fcx.next_ty_var();\n+                let var_ty = self.fcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n                 self.fcx.locals.borrow_mut().insert(nid, var_ty);\n                 var_ty\n             }\n@@ -1442,8 +1442,8 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         Ok(r)\n     }\n \n-    fn ty_infer(&self, _span: Span) -> Ty<'tcx> {\n-        self.next_ty_var()\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n+        self.next_ty_var(TypeVariableOrigin::TypeInference(span))\n     }\n \n     fn ty_infer_for_def(&self,\n@@ -1749,13 +1749,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let Some(ty_var) = self.anon_types.borrow().get(&def_id) {\n                     return ty_var;\n                 }\n-                let ty_var = self.next_ty_var();\n+                let span = self.tcx.def_span(def_id);\n+                let ty_var = self.next_ty_var(TypeVariableOrigin::TypeInference(span));\n                 self.anon_types.borrow_mut().insert(def_id, ty_var);\n \n                 let item_predicates = self.tcx.item_predicates(def_id);\n                 let bounds = item_predicates.instantiate(self.tcx, substs);\n \n-                let span = self.tcx.def_span(def_id);\n                 for predicate in bounds.predicates {\n                     // Change the predicate to refer to the type variable,\n                     // which will be the concrete type, instead of the TyAnon.\n@@ -2202,7 +2202,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let conflicting_default =\n                         self.find_conflicting_default(&unbound_tyvars, &default_map, conflict)\n                             .unwrap_or(type_variable::Default {\n-                                ty: self.next_ty_var(),\n+                                ty: self.next_ty_var(\n+                                    TypeVariableOrigin::MiscVariable(syntax_pos::DUMMY_SP)),\n                                 origin_span: syntax_pos::DUMMY_SP,\n                                 // what do I put here?\n                                 def_id: self.tcx.map.local_def_id(ast::CRATE_NODE_ID)\n@@ -2396,7 +2397,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                unsize,\n                index_ty);\n \n-        let input_ty = self.next_ty_var();\n+        let input_ty = self.next_ty_var(TypeVariableOrigin::AutoDeref(base_expr.span));\n \n         // First, try built-in indexing.\n         match (adjusted_ty.builtin_index(), &index_ty.sty) {\n@@ -3485,8 +3486,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Add adjustments to !-expressions\n         if ty.is_never() {\n-            if let Some(hir::map::NodeExpr(_)) = self.tcx.map.find(expr.id) {\n-                let adj_ty = self.next_diverging_ty_var();\n+            if let Some(hir::map::NodeExpr(node_expr)) = self.tcx.map.find(expr.id) {\n+                let adj_ty = self.next_diverging_ty_var(\n+                    TypeVariableOrigin::AdjustmentType(node_expr.span));\n                 self.write_adjustment(expr.id, adjustment::Adjustment {\n                     kind: adjustment::Adjust::NeverToAny,\n                     target: adj_ty\n@@ -3778,7 +3780,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n           }\n           hir::ExprLoop(ref body, _, _) => {\n-            let unified = self.next_ty_var();\n+            let unified = self.next_ty_var(TypeVariableOrigin::TypeInference(body.span));\n             let coerce_to = expected.only_has_type(self).unwrap_or(unified);\n             let ctxt = LoopCtxt {\n                 unified: unified,\n@@ -3857,7 +3859,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             });\n \n-            let mut unified = self.next_ty_var();\n+            let mut unified = self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span));\n             let coerce_to = uty.unwrap_or(unified);\n \n             for (i, e) in args.iter().enumerate() {\n@@ -3902,7 +3904,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     (uty, uty)\n                 }\n                 None => {\n-                    let t: Ty = self.next_ty_var();\n+                    let t: Ty = self.next_ty_var(TypeVariableOrigin::MiscVariable(element.span));\n                     let element_ty = self.check_expr_has_type(&element, t);\n                     (element_ty, t)\n                 }\n@@ -4151,31 +4153,35 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.diverges.set(Diverges::Maybe);\n         self.has_errors.set(false);\n \n-        let node_id = match stmt.node {\n+        let (node_id, span) = match stmt.node {\n             hir::StmtDecl(ref decl, id) => {\n-                match decl.node {\n+                let span = match decl.node {\n                     hir::DeclLocal(ref l) => {\n                         self.check_decl_local(&l);\n+                        l.span\n                     }\n-                    hir::DeclItem(_) => {/* ignore for now */ }\n-                }\n-                id\n+                    hir::DeclItem(_) => {/* ignore for now */\n+                        DUMMY_SP\n+                    }\n+                };\n+                (id, span)\n             }\n             hir::StmtExpr(ref expr, id) => {\n                 // Check with expected type of ()\n                 self.check_expr_has_type(&expr, self.tcx.mk_nil());\n-                id\n+                (id, expr.span)\n             }\n             hir::StmtSemi(ref expr, id) => {\n                 self.check_expr(&expr);\n-                id\n+                (id, expr.span)\n             }\n         };\n \n         if self.has_errors.get() {\n             self.write_error(node_id);\n         } else if self.diverges.get().always() {\n-            self.write_ty(node_id, self.next_diverging_ty_var());\n+            self.write_ty(node_id, self.next_diverging_ty_var(\n+                TypeVariableOrigin::DivergingStmt(span)));\n         } else {\n             self.write_nil(node_id);\n         }\n@@ -4221,7 +4227,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            ty = self.next_diverging_ty_var();\n+            ty = self.next_diverging_ty_var(TypeVariableOrigin::DivergingBlockExpr(blk.span));\n         } else if let ExpectHasType(ety) = expected {\n             if let Some(ref e) = blk.expr {\n                 // Coerce the tail expression to the right type."}, {"sha": "d1a9b8ef85ae48e5c990b55cec9d9825dc4c57ac", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d069e1b38c983e846ea8db1f07af729bdc79fe7/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=3d069e1b38c983e846ea8db1f07af729bdc79fe7", "patch": "@@ -13,6 +13,7 @@\n use super::FnCtxt;\n use hir::def_id::DefId;\n use rustc::ty::{Ty, TypeFoldable, PreferMutLvalue};\n+use rustc::infer::type_variable::TypeVariableOrigin;\n use syntax::ast;\n use syntax::symbol::Symbol;\n use rustc::hir;\n@@ -179,7 +180,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // using this variable as the expected type, which sometimes lets\n         // us do better coercions than we would be able to do otherwise,\n         // particularly for things like `String + &String`.\n-        let rhs_ty_var = self.next_ty_var();\n+        let rhs_ty_var = self.next_ty_var(TypeVariableOrigin::MiscVariable(rhs_expr.span));\n \n         let return_ty = match self.lookup_op_method(expr, lhs_ty, vec![rhs_ty_var],\n                                                     Symbol::intern(name), trait_def_id,"}]}