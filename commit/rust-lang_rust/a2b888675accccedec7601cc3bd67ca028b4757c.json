{"sha": "a2b888675accccedec7601cc3bd67ca028b4757c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyYjg4ODY3NWFjY2NjZWRlYzc2MDFjYzNiZDY3Y2EwMjhiNDc1N2M=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2017-08-05T06:38:52Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2017-08-10T05:43:59Z"}, "message": "Implemented #[doc(cfg(...))].\n\nThis attribute has two effects:\n\n1. Items with this attribute and their children will have the \"This is\n   supported on **** only\" message attached in the documentation.\n\n2. The items' doc tests will be skipped if the configuration does not\n   match.", "tree": {"sha": "a13d255f58f1e86112774af9e8c297871adf5834", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a13d255f58f1e86112774af9e8c297871adf5834"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2b888675accccedec7601cc3bd67ca028b4757c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIcBAABCAAGBQJZi/KfAAoJEP72yAUdDgE8ymgP/3dTlVll6QJzT9xxd40xGg4p\nF2zYRFAFhvLKRa4QF1CGAvzevIhQE9VElPH57it8nGKB2mmsD+K8aPRoxc4IOrc9\nN2vno495o3ms4ljyZEme+8i76+RYfS4yfZmz896bERWgS3tSczEsBpXhQX1Zt1MU\nlstWF9Cs39lmRO2zOMvZNGKKoNUrHUZgIQsKyZLTjA+29KHVQFoIVQK8YOgSP1SY\n5bZQvzfZr3PN9znuIcFR2tfRmJxdc3WlyoELeMoMx/ba7f0oz4Mph2exqNb1tEMa\nGXM97GGgwzmENCK9Gm+/MPlx059kdwHILcSFfIGzWd1+nH8X37PP0Rx82b0Cue7i\nlsJ81za7fSRi3ES/JGBHioO2X5lD27QPkfMCOlzesqwgNJuz4sbxC33EoFMfb+a2\n6YqvwWyz7NXfAPO2f0a9Svm/lD+3O+cWP9TZSFtEC7E/tZclO7DLUZJYro8tfzOk\n5pAGlK9MPTUYAVnrTwCiTD1rAJHqpRrTtLT+Woeq/1/gIdg71k/yR6DCaG4+/nZ6\nCCo/63DRG/70GN7+1377sIAQZlJJ5b+DCf+EMafh0z7S8Ldo7XYl7J86ii0tImKn\nJCl/FiRU7Z4Irr8n2+EYFwWTE9qHMbdUOanDyGtojFvYdkNQFnmcdaRRKadm1jco\ndl5P2iY6LafEQRkfE/DB\n=FGlb\n-----END PGP SIGNATURE-----", "payload": "tree a13d255f58f1e86112774af9e8c297871adf5834\nparent 8f935fbb5b7e8ea5a320082cb9e28095aa0b5759\nauthor kennytm <kennytm@gmail.com> 1501915132 +0800\ncommitter kennytm <kennytm@gmail.com> 1502343839 +0800\n\nImplemented #[doc(cfg(...))].\n\nThis attribute has two effects:\n\n1. Items with this attribute and their children will have the \"This is\n   supported on **** only\" message attached in the documentation.\n\n2. The items' doc tests will be skipped if the configuration does not\n   match.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2b888675accccedec7601cc3bd67ca028b4757c", "html_url": "https://github.com/rust-lang/rust/commit/a2b888675accccedec7601cc3bd67ca028b4757c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2b888675accccedec7601cc3bd67ca028b4757c/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f935fbb5b7e8ea5a320082cb9e28095aa0b5759", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f935fbb5b7e8ea5a320082cb9e28095aa0b5759", "html_url": "https://github.com/rust-lang/rust/commit/8f935fbb5b7e8ea5a320082cb9e28095aa0b5759"}], "stats": {"total": 1139, "additions": 1126, "deletions": 13}, "files": [{"sha": "ddc538e12144ac5ff5a2d692d5aba400c4ca3843", "filename": "src/doc/unstable-book/src/language-features/doc-cfg.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-cfg.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-cfg.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-cfg.md?ref=a2b888675accccedec7601cc3bd67ca028b4757c", "patch": "@@ -0,0 +1,42 @@\n+# `doc_cfg`\n+\n+The tracking issue for this feature is: [#43781]\n+\n+------\n+\n+The `doc_cfg` feature allows an API be documented as only available in some specific platforms.\n+This attribute has two effects:\n+\n+1. In the annotated item's documentation, there will be a message saying \"This is supported on\n+    (platform) only\".\n+\n+2. The item's doc-tests will only run on the specific platform.\n+\n+This feature was introduced as part of PR [#43348] to allow the platform-specific parts of the\n+standard library be documented.\n+\n+```rust\n+#![feature(doc_cfg)]\n+\n+#[cfg(any(windows, feature = \"documentation\"))]\n+#[doc(cfg(windows))]\n+/// The application's icon in the notification area (a.k.a. system tray).\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// extern crate my_awesome_ui_library;\n+/// use my_awesome_ui_library::current_app;\n+/// use my_awesome_ui_library::windows::notification;\n+///\n+/// let icon = current_app().get::<notification::Icon>();\n+/// icon.show();\n+/// icon.show_message(\"Hello\");\n+/// ```\n+pub struct Icon {\n+    // ...\n+}\n+```\n+\n+[#43781]: https://github.com/rust-lang/rust/issues/43781\n+[#43348]: https://github.com/rust-lang/rust/issues/43348\n\\ No newline at end of file"}, {"sha": "da8c3a5cf206bc67042e1e5d73ecf78cebc03061", "filename": "src/librustdoc/clean/cfg.rs", "status": "added", "additions": 889, "deletions": 0, "changes": 889, "blob_url": "https://github.com/rust-lang/rust/blob/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=a2b888675accccedec7601cc3bd67ca028b4757c", "patch": "@@ -0,0 +1,889 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Representation of a `#[doc(cfg(...))]` attribute.\n+\n+// FIXME: Once RFC #1868 is implemented, switch to use those structures instead.\n+\n+use std::mem;\n+use std::fmt::{self, Write};\n+use std::ops;\n+use std::ascii::AsciiExt;\n+\n+use syntax::symbol::Symbol;\n+use syntax::ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind, LitKind};\n+use syntax::parse::ParseSess;\n+use syntax::feature_gate::Features;\n+\n+use syntax_pos::Span;\n+\n+use html::escape::Escape;\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, PartialEq)]\n+pub enum Cfg {\n+    /// Accepts all configurations.\n+    True,\n+    /// Denies all configurations.\n+    False,\n+    /// A generic configration option, e.g. `test` or `target_os = \"linux\"`.\n+    Cfg(Symbol, Option<Symbol>),\n+    /// Negate a configuration requirement, i.e. `not(x)`.\n+    Not(Box<Cfg>),\n+    /// Union of a list of configuration requirements, i.e. `any(...)`.\n+    Any(Vec<Cfg>),\n+    /// Intersection of a list of configuration requirements, i.e. `all(...)`.\n+    All(Vec<Cfg>),\n+}\n+\n+#[derive(PartialEq, Debug)]\n+pub struct InvalidCfgError {\n+    pub msg: &'static str,\n+    pub span: Span,\n+}\n+\n+impl Cfg {\n+    /// Parses a `NestedMetaItem` into a `Cfg`.\n+    fn parse_nested(nested_cfg: &NestedMetaItem) -> Result<Cfg, InvalidCfgError> {\n+        match nested_cfg.node {\n+            NestedMetaItemKind::MetaItem(ref cfg) => Cfg::parse(cfg),\n+            NestedMetaItemKind::Literal(ref lit) => Err(InvalidCfgError {\n+                msg: \"unexpected literal\",\n+                span: lit.span,\n+            }),\n+        }\n+    }\n+\n+    /// Parses a `MetaItem` into a `Cfg`.\n+    ///\n+    /// The `MetaItem` should be the content of the `#[cfg(...)]`, e.g. `unix` or\n+    /// `target_os = \"redox\"`.\n+    ///\n+    /// If the content is not properly formatted, it will return an error indicating what and where\n+    /// the error is.\n+    pub fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n+        let name = cfg.name();\n+        match cfg.node {\n+            MetaItemKind::Word => Ok(Cfg::Cfg(name, None)),\n+            MetaItemKind::NameValue(ref lit) => match lit.node {\n+                LitKind::Str(value, _) => Ok(Cfg::Cfg(name, Some(value))),\n+                _ => Err(InvalidCfgError {\n+                    // FIXME: if the main #[cfg] syntax decided to support non-string literals,\n+                    // this should be changed as well.\n+                    msg: \"value of cfg option should be a string literal\",\n+                    span: lit.span,\n+                }),\n+            },\n+            MetaItemKind::List(ref items) => {\n+                let mut sub_cfgs = items.iter().map(Cfg::parse_nested);\n+                match &*name.as_str() {\n+                    \"all\" => sub_cfgs.fold(Ok(Cfg::True), |x, y| Ok(x? & y?)),\n+                    \"any\" => sub_cfgs.fold(Ok(Cfg::False), |x, y| Ok(x? | y?)),\n+                    \"not\" => if sub_cfgs.len() == 1 {\n+                        Ok(!sub_cfgs.next().unwrap()?)\n+                    } else {\n+                        Err(InvalidCfgError {\n+                            msg: \"expected 1 cfg-pattern\",\n+                            span: cfg.span,\n+                        })\n+                    },\n+                    _ => Err(InvalidCfgError {\n+                        msg: \"invalid predicate\",\n+                        span: cfg.span,\n+                    }),\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Checks whether the given configuration can be matched in the current session.\n+    ///\n+    /// Equivalent to `attr::cfg_matches`.\n+    // FIXME: Actually make use of `features`.\n+    pub fn matches(&self, parse_sess: &ParseSess, features: Option<&Features>) -> bool {\n+        match *self {\n+            Cfg::False => false,\n+            Cfg::True => true,\n+            Cfg::Not(ref child) => !child.matches(parse_sess, features),\n+            Cfg::All(ref sub_cfgs) => {\n+                sub_cfgs.iter().all(|sub_cfg| sub_cfg.matches(parse_sess, features))\n+            },\n+            Cfg::Any(ref sub_cfgs) => {\n+                sub_cfgs.iter().any(|sub_cfg| sub_cfg.matches(parse_sess, features))\n+            },\n+            Cfg::Cfg(name, value) => parse_sess.config.contains(&(name, value)),\n+        }\n+    }\n+\n+    /// Whether the configuration consists of just `Cfg` or `Not`.\n+    fn is_simple(&self) -> bool {\n+        match *self {\n+            Cfg::False | Cfg::True | Cfg::Cfg(..) | Cfg::Not(..) => true,\n+            Cfg::All(..) | Cfg::Any(..) => false,\n+        }\n+    }\n+\n+    /// Whether the configuration consists of just `Cfg`, `Not` or `All`.\n+    fn is_all(&self) -> bool {\n+        match *self {\n+            Cfg::False | Cfg::True | Cfg::Cfg(..) | Cfg::Not(..) | Cfg::All(..) => true,\n+            Cfg::Any(..) => false,\n+        }\n+    }\n+\n+    /// Renders the configuration for human display, as a short HTML description.\n+    pub(crate) fn render_short_html(&self) -> String {\n+        let mut msg = Html(self).to_string();\n+        if self.should_capitalize_first_letter() {\n+            if let Some(i) = msg.find(|c: char| c.is_ascii_alphanumeric()) {\n+                msg[i .. i+1].make_ascii_uppercase();\n+            }\n+        }\n+        msg\n+    }\n+\n+    /// Renders the configuration for long display, as a long HTML description.\n+    pub(crate) fn render_long_html(&self) -> String {\n+        let mut msg = format!(\"This is supported on <strong>{}</strong>\", Html(self));\n+        if self.should_append_only_to_description() {\n+            msg.push_str(\" only\");\n+        }\n+        msg.push('.');\n+        msg\n+    }\n+\n+    fn should_capitalize_first_letter(&self) -> bool {\n+        match *self {\n+            Cfg::False | Cfg::True | Cfg::Not(..) => true,\n+            Cfg::Any(ref sub_cfgs) | Cfg::All(ref sub_cfgs) => {\n+                sub_cfgs.first().map(Cfg::should_capitalize_first_letter).unwrap_or(false)\n+            },\n+            Cfg::Cfg(name, _) => match &*name.as_str() {\n+                \"debug_assertions\" | \"target_endian\" => true,\n+                _ => false,\n+            },\n+        }\n+    }\n+\n+    fn should_append_only_to_description(&self) -> bool {\n+        match *self {\n+            Cfg::False | Cfg::True => false,\n+            Cfg::Any(..) | Cfg::All(..) | Cfg::Cfg(..) => true,\n+            Cfg::Not(ref child) => match **child {\n+                Cfg::Cfg(..) => true,\n+                _ => false,\n+            }\n+        }\n+    }\n+}\n+\n+impl ops::Not for Cfg {\n+    type Output = Cfg;\n+    fn not(self) -> Cfg {\n+        match self {\n+            Cfg::False => Cfg::True,\n+            Cfg::True => Cfg::False,\n+            Cfg::Not(cfg) => *cfg,\n+            s => Cfg::Not(Box::new(s)),\n+        }\n+    }\n+}\n+\n+impl ops::BitAndAssign for Cfg {\n+    fn bitand_assign(&mut self, other: Cfg) {\n+        match (self, other) {\n+            (&mut Cfg::False, _) | (_, Cfg::True) => {},\n+            (s, Cfg::False) => *s = Cfg::False,\n+            (s @ &mut Cfg::True, b) => *s = b,\n+            (&mut Cfg::All(ref mut a), Cfg::All(ref mut b)) => a.append(b),\n+            (&mut Cfg::All(ref mut a), ref mut b) => a.push(mem::replace(b, Cfg::True)),\n+            (s, Cfg::All(mut a)) => {\n+                let b = mem::replace(s, Cfg::True);\n+                a.push(b);\n+                *s = Cfg::All(a);\n+            },\n+            (s, b) => {\n+                let a = mem::replace(s, Cfg::True);\n+                *s = Cfg::All(vec![a, b]);\n+            },\n+        }\n+    }\n+}\n+\n+impl ops::BitAnd for Cfg {\n+    type Output = Cfg;\n+    fn bitand(mut self, other: Cfg) -> Cfg {\n+        self &= other;\n+        self\n+    }\n+}\n+\n+impl ops::BitOrAssign for Cfg {\n+    fn bitor_assign(&mut self, other: Cfg) {\n+        match (self, other) {\n+            (&mut Cfg::True, _) | (_, Cfg::False) => {},\n+            (s, Cfg::True) => *s = Cfg::True,\n+            (s @ &mut Cfg::False, b) => *s = b,\n+            (&mut Cfg::Any(ref mut a), Cfg::Any(ref mut b)) => a.append(b),\n+            (&mut Cfg::Any(ref mut a), ref mut b) => a.push(mem::replace(b, Cfg::True)),\n+            (s, Cfg::Any(mut a)) => {\n+                let b = mem::replace(s, Cfg::True);\n+                a.push(b);\n+                *s = Cfg::Any(a);\n+            },\n+            (s, b) => {\n+                let a = mem::replace(s, Cfg::True);\n+                *s = Cfg::Any(vec![a, b]);\n+            },\n+        }\n+    }\n+}\n+\n+impl ops::BitOr for Cfg {\n+    type Output = Cfg;\n+    fn bitor(mut self, other: Cfg) -> Cfg {\n+        self |= other;\n+        self\n+    }\n+}\n+\n+struct Html<'a>(&'a Cfg);\n+\n+fn write_with_opt_paren<T: fmt::Display>(\n+    fmt: &mut fmt::Formatter,\n+    has_paren: bool,\n+    obj: T,\n+) -> fmt::Result {\n+    if has_paren {\n+        fmt.write_char('(')?;\n+    }\n+    obj.fmt(fmt)?;\n+    if has_paren {\n+        fmt.write_char(')')?;\n+    }\n+    Ok(())\n+}\n+\n+\n+impl<'a> fmt::Display for Html<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        match *self.0 {\n+            Cfg::Not(ref child) => match **child {\n+                Cfg::Any(ref sub_cfgs) => {\n+                    let separator = if sub_cfgs.iter().all(Cfg::is_simple) {\n+                        \" nor \"\n+                    } else {\n+                        \", nor \"\n+                    };\n+                    for (i, sub_cfg) in sub_cfgs.iter().enumerate() {\n+                        fmt.write_str(if i == 0 { \"neither \" } else { separator })?;\n+                        write_with_opt_paren(fmt, !sub_cfg.is_all(), Html(sub_cfg))?;\n+                    }\n+                    Ok(())\n+                }\n+                ref simple @ Cfg::Cfg(..) => write!(fmt, \"non-{}\", Html(simple)),\n+                ref c => write!(fmt, \"not ({})\", Html(c)),\n+            },\n+\n+            Cfg::Any(ref sub_cfgs) => {\n+                let separator = if sub_cfgs.iter().all(Cfg::is_simple) {\n+                    \" or \"\n+                } else {\n+                    \", or \"\n+                };\n+                for (i, sub_cfg) in sub_cfgs.iter().enumerate() {\n+                    if i != 0 {\n+                        fmt.write_str(separator)?;\n+                    }\n+                    write_with_opt_paren(fmt, !sub_cfg.is_all(), Html(sub_cfg))?;\n+                }\n+                Ok(())\n+            },\n+\n+            Cfg::All(ref sub_cfgs) => {\n+                for (i, sub_cfg) in sub_cfgs.iter().enumerate() {\n+                    if i != 0 {\n+                        fmt.write_str(\" and \")?;\n+                    }\n+                    write_with_opt_paren(fmt, !sub_cfg.is_simple(), Html(sub_cfg))?;\n+                }\n+                Ok(())\n+            },\n+\n+            Cfg::True => fmt.write_str(\"everywhere\"),\n+            Cfg::False => fmt.write_str(\"nowhere\"),\n+\n+            Cfg::Cfg(name, value) => {\n+                let n = &*name.as_str();\n+                let human_readable = match (n, value) {\n+                    (\"unix\", None) => \"Unix\",\n+                    (\"windows\", None) => \"Windows\",\n+                    (\"debug_assertions\", None) => \"debug-assertions enabled\",\n+                    (\"target_os\", Some(os)) => match &*os.as_str() {\n+                        \"android\" => \"Android\",\n+                        \"bitrig\" => \"Bitrig\",\n+                        \"dragonfly\" => \"DragonFly BSD\",\n+                        \"emscripten\" => \"Emscripten\",\n+                        \"freebsd\" => \"FreeBSD\",\n+                        \"fuchsia\" => \"Fuchsia\",\n+                        \"haiku\" => \"Haiku\",\n+                        \"ios\" => \"iOS\",\n+                        \"l4re\" => \"L4Re\",\n+                        \"linux\" => \"Linux\",\n+                        \"macos\" => \"macOS\",\n+                        \"nacl\" => \"NaCl\",\n+                        \"netbsd\" => \"NetBSD\",\n+                        \"openbsd\" => \"OpenBSD\",\n+                        \"redox\" => \"Redox\",\n+                        \"solaris\" => \"Solaris\",\n+                        \"windows\" => \"Windows\",\n+                        _ => \"\",\n+                    },\n+                    (\"target_arch\", Some(arch)) => match &*arch.as_str() {\n+                        \"aarch64\" => \"AArch64\",\n+                        \"arm\" => \"ARM\",\n+                        \"asmjs\" => \"asm.js\",\n+                        \"mips\" => \"MIPS\",\n+                        \"mips64\" => \"MIPS-64\",\n+                        \"msp430\" => \"MSP430\",\n+                        \"powerpc\" => \"PowerPC\",\n+                        \"powerpc64\" => \"PowerPC-64\",\n+                        \"s390x\" => \"s390x\",\n+                        \"sparc64\" => \"SPARC64\",\n+                        \"wasm32\" => \"WebAssembly\",\n+                        \"x86\" => \"x86\",\n+                        \"x86_64\" => \"x86-64\",\n+                        _ => \"\",\n+                    },\n+                    (\"target_vendor\", Some(vendor)) => match &*vendor.as_str() {\n+                        \"apple\" => \"Apple\",\n+                        \"pc\" => \"PC\",\n+                        \"rumprun\" => \"Rumprun\",\n+                        \"sun\" => \"Sun\",\n+                        _ => \"\"\n+                    },\n+                    (\"target_env\", Some(env)) => match &*env.as_str() {\n+                        \"gnu\" => \"GNU\",\n+                        \"msvc\" => \"MSVC\",\n+                        \"musl\" => \"musl\",\n+                        \"newlib\" => \"Newlib\",\n+                        \"uclibc\" => \"uClibc\",\n+                        _ => \"\",\n+                    },\n+                    (\"target_endian\", Some(endian)) => return write!(fmt, \"{}-endian\", endian),\n+                    (\"target_pointer_width\", Some(bits)) => return write!(fmt, \"{}-bit\", bits),\n+                    _ => \"\",\n+                };\n+                if !human_readable.is_empty() {\n+                    fmt.write_str(human_readable)\n+                } else if let Some(v) = value {\n+                    write!(fmt, \"<code>{}=\\\"{}\\\"</code>\", Escape(n), Escape(&*v.as_str()))\n+                } else {\n+                    write!(fmt, \"<code>{}</code>\", Escape(n))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::Cfg;\n+\n+    use syntax::symbol::Symbol;\n+    use syntax::ast::*;\n+    use syntax::codemap::dummy_spanned;\n+    use syntax_pos::DUMMY_SP;\n+\n+    fn word_cfg(s: &str) -> Cfg {\n+        Cfg::Cfg(Symbol::intern(s), None)\n+    }\n+\n+    fn name_value_cfg(name: &str, value: &str) -> Cfg {\n+        Cfg::Cfg(Symbol::intern(name), Some(Symbol::intern(value)))\n+    }\n+\n+    #[test]\n+    fn test_cfg_not() {\n+        assert_eq!(!Cfg::False, Cfg::True);\n+        assert_eq!(!Cfg::True, Cfg::False);\n+        assert_eq!(!word_cfg(\"test\"), Cfg::Not(Box::new(word_cfg(\"test\"))));\n+        assert_eq!(\n+            !Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+            Cfg::Not(Box::new(Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")])))\n+        );\n+        assert_eq!(\n+            !Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+            Cfg::Not(Box::new(Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")])))\n+        );\n+        assert_eq!(!Cfg::Not(Box::new(word_cfg(\"test\"))), word_cfg(\"test\"));\n+    }\n+\n+    #[test]\n+    fn test_cfg_and() {\n+        let mut x = Cfg::False;\n+        x &= Cfg::True;\n+        assert_eq!(x, Cfg::False);\n+\n+        x = word_cfg(\"test\");\n+        x &= Cfg::False;\n+        assert_eq!(x, Cfg::False);\n+\n+        x = word_cfg(\"test2\");\n+        x &= Cfg::True;\n+        assert_eq!(x, word_cfg(\"test2\"));\n+\n+        x = Cfg::True;\n+        x &= word_cfg(\"test3\");\n+        assert_eq!(x, word_cfg(\"test3\"));\n+\n+        x &= word_cfg(\"test4\");\n+        assert_eq!(x, Cfg::All(vec![word_cfg(\"test3\"), word_cfg(\"test4\")]));\n+\n+        x &= word_cfg(\"test5\");\n+        assert_eq!(x, Cfg::All(vec![word_cfg(\"test3\"), word_cfg(\"test4\"), word_cfg(\"test5\")]));\n+\n+        x &= Cfg::All(vec![word_cfg(\"test6\"), word_cfg(\"test7\")]);\n+        assert_eq!(x, Cfg::All(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+        ]));\n+\n+        let mut y = Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]);\n+        y &= x;\n+        assert_eq!(y, Cfg::All(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+            Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+        ]));\n+\n+        assert_eq!(\n+            word_cfg(\"a\") & word_cfg(\"b\") & word_cfg(\"c\"),\n+            Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\"), word_cfg(\"c\")])\n+        );\n+    }\n+\n+    #[test]\n+    fn test_cfg_or() {\n+        let mut x = Cfg::True;\n+        x |= Cfg::False;\n+        assert_eq!(x, Cfg::True);\n+\n+        x = word_cfg(\"test\");\n+        x |= Cfg::True;\n+        assert_eq!(x, Cfg::True);\n+\n+        x = word_cfg(\"test2\");\n+        x |= Cfg::False;\n+        assert_eq!(x, word_cfg(\"test2\"));\n+\n+        x = Cfg::False;\n+        x |= word_cfg(\"test3\");\n+        assert_eq!(x, word_cfg(\"test3\"));\n+\n+        x |= word_cfg(\"test4\");\n+        assert_eq!(x, Cfg::Any(vec![word_cfg(\"test3\"), word_cfg(\"test4\")]));\n+\n+        x |= word_cfg(\"test5\");\n+        assert_eq!(x, Cfg::Any(vec![word_cfg(\"test3\"), word_cfg(\"test4\"), word_cfg(\"test5\")]));\n+\n+        x |= Cfg::Any(vec![word_cfg(\"test6\"), word_cfg(\"test7\")]);\n+        assert_eq!(x, Cfg::Any(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+        ]));\n+\n+        let mut y = Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]);\n+        y |= x;\n+        assert_eq!(y, Cfg::Any(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+            Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+        ]));\n+\n+        assert_eq!(\n+            word_cfg(\"a\") | word_cfg(\"b\") | word_cfg(\"c\"),\n+            Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\"), word_cfg(\"c\")])\n+        );\n+    }\n+\n+    #[test]\n+    fn test_parse_ok() {\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"all\"),\n+            node: MetaItemKind::Word,\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"all\")));\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"all\"),\n+            node: MetaItemKind::NameValue(dummy_spanned(LitKind::Str(\n+                Symbol::intern(\"done\"),\n+                StrStyle::Cooked,\n+            ))),\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(name_value_cfg(\"all\", \"done\")));\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"all\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"b\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\")));\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"any\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"b\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") | word_cfg(\"b\")));\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"not\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(!word_cfg(\"a\")));\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"not\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"any\"),\n+                    node: MetaItemKind::List(vec![\n+                        dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                            name: Symbol::intern(\"a\"),\n+                            node: MetaItemKind::Word,\n+                            span: DUMMY_SP,\n+                        })),\n+                        dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                            name: Symbol::intern(\"all\"),\n+                            node: MetaItemKind::List(vec![\n+                                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                                    name: Symbol::intern(\"b\"),\n+                                    node: MetaItemKind::Word,\n+                                    span: DUMMY_SP,\n+                                })),\n+                                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                                    name: Symbol::intern(\"c\"),\n+                                    node: MetaItemKind::Word,\n+                                    span: DUMMY_SP,\n+                                })),\n+                            ]),\n+                            span: DUMMY_SP,\n+                        })),\n+                    ]),\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(!(word_cfg(\"a\") | (word_cfg(\"b\") & word_cfg(\"c\")))));\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"all\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"b\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"c\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\") & word_cfg(\"c\")));\n+    }\n+\n+    #[test]\n+    fn test_parse_err() {\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"foo\"),\n+            node: MetaItemKind::NameValue(dummy_spanned(LitKind::Bool(false))),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"not\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"b\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"not\"),\n+            node: MetaItemKind::List(vec![]),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"foo\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"all\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"foo\"),\n+                    node: MetaItemKind::List(vec![]),\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"b\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"any\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"foo\"),\n+                    node: MetaItemKind::List(vec![]),\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"not\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"foo\"),\n+                    node: MetaItemKind::List(vec![]),\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+    }\n+\n+    #[test]\n+    fn test_render_short_html() {\n+        assert_eq!(\n+            word_cfg(\"unix\").render_short_html(),\n+            \"Unix\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_os\", \"macos\").render_short_html(),\n+            \"macOS\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_pointer_width\", \"16\").render_short_html(),\n+            \"16-bit\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_endian\", \"little\").render_short_html(),\n+            \"Little-endian\"\n+        );\n+        assert_eq!(\n+            (!word_cfg(\"windows\")).render_short_html(),\n+            \"Non-Windows\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") & word_cfg(\"windows\")).render_short_html(),\n+            \"Unix and Windows\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") | word_cfg(\"windows\")).render_short_html(),\n+            \"Unix or Windows\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") & word_cfg(\"windows\") & word_cfg(\"debug_assertions\")\n+            ).render_short_html(),\n+            \"Unix and Windows and debug-assertions enabled\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\")\n+            ).render_short_html(),\n+            \"Unix or Windows or debug-assertions enabled\"\n+        );\n+        assert_eq!(\n+            (\n+                !(word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\"))\n+            ).render_short_html(),\n+            \"Neither Unix nor Windows nor debug-assertions enabled\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"unix\") & name_value_cfg(\"target_arch\", \"x86_64\")) |\n+                (word_cfg(\"windows\") & name_value_cfg(\"target_pointer_width\", \"64\"))\n+            ).render_short_html(),\n+            \"Unix and x86-64, or Windows and 64-bit\"\n+        );\n+        assert_eq!(\n+            (!(word_cfg(\"unix\") & word_cfg(\"windows\"))).render_short_html(),\n+            \"Not (Unix and Windows)\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"debug_assertions\") | word_cfg(\"windows\")) & word_cfg(\"unix\")\n+            ).render_short_html(),\n+            \"(Debug-assertions enabled or Windows) and Unix\"\n+        );\n+    }\n+\n+    #[test]\n+    fn test_render_long_html() {\n+        assert_eq!(\n+            word_cfg(\"unix\").render_long_html(),\n+            \"This is supported on <strong>Unix</strong> only.\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_os\", \"macos\").render_long_html(),\n+            \"This is supported on <strong>macOS</strong> only.\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_pointer_width\", \"16\").render_long_html(),\n+            \"This is supported on <strong>16-bit</strong> only.\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_endian\", \"little\").render_long_html(),\n+            \"This is supported on <strong>little-endian</strong> only.\"\n+        );\n+        assert_eq!(\n+            (!word_cfg(\"windows\")).render_long_html(),\n+            \"This is supported on <strong>non-Windows</strong> only.\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") & word_cfg(\"windows\")).render_long_html(),\n+            \"This is supported on <strong>Unix and Windows</strong> only.\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") | word_cfg(\"windows\")).render_long_html(),\n+            \"This is supported on <strong>Unix or Windows</strong> only.\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") & word_cfg(\"windows\") & word_cfg(\"debug_assertions\")\n+            ).render_long_html(),\n+            \"This is supported on <strong>Unix and Windows and debug-assertions enabled</strong> \\\n+                only.\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\")\n+            ).render_long_html(),\n+            \"This is supported on <strong>Unix or Windows or debug-assertions enabled</strong> \\\n+                only.\"\n+        );\n+        assert_eq!(\n+            (\n+                !(word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\"))\n+            ).render_long_html(),\n+            \"This is supported on <strong>neither Unix nor Windows nor debug-assertions \\\n+                enabled</strong>.\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"unix\") & name_value_cfg(\"target_arch\", \"x86_64\")) |\n+                (word_cfg(\"windows\") & name_value_cfg(\"target_pointer_width\", \"64\"))\n+            ).render_long_html(),\n+            \"This is supported on <strong>Unix and x86-64, or Windows and 64-bit</strong> only.\"\n+        );\n+        assert_eq!(\n+            (!(word_cfg(\"unix\") & word_cfg(\"windows\"))).render_long_html(),\n+            \"This is supported on <strong>not (Unix and Windows)</strong>.\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"debug_assertions\") | word_cfg(\"windows\")) & word_cfg(\"unix\")\n+            ).render_long_html(),\n+            \"This is supported on <strong>(debug-assertions enabled or Windows) and Unix</strong> \\\n+                only.\"\n+        );\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "57e72c3a40bf520bd641ccea0d8cb4a9741eb633", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 51, "deletions": 12, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a2b888675accccedec7601cc3bd67ca028b4757c", "patch": "@@ -52,8 +52,11 @@ use visit_ast;\n use html::item_type::ItemType;\n \n pub mod inline;\n+pub mod cfg;\n mod simplify;\n \n+use self::cfg::Cfg;\n+\n // extract the stability index for a node from tcx, if possible\n fn get_stability(cx: &DocContext, def_id: DefId) -> Option<Stability> {\n     cx.tcx.lookup_stability(def_id).clean(cx)\n@@ -536,31 +539,67 @@ impl<I: IntoIterator<Item=ast::NestedMetaItem>> NestedAttributesExt for I {\n pub struct Attributes {\n     pub doc_strings: Vec<String>,\n     pub other_attrs: Vec<ast::Attribute>,\n+    pub cfg: Option<Rc<Cfg>>,\n     pub span: Option<syntax_pos::Span>,\n }\n \n impl Attributes {\n-    pub fn from_ast(attrs: &[ast::Attribute]) -> Attributes {\n+    /// Extracts the content from an attribute `#[doc(cfg(content))]`.\n+    fn extract_cfg(mi: &ast::MetaItem) -> Option<&ast::MetaItem> {\n+        use syntax::ast::NestedMetaItemKind::MetaItem;\n+\n+        if let ast::MetaItemKind::List(ref nmis) = mi.node {\n+            if nmis.len() == 1 {\n+                if let MetaItem(ref cfg_mi) = nmis[0].node {\n+                    if cfg_mi.check_name(\"cfg\") {\n+                        if let ast::MetaItemKind::List(ref cfg_nmis) = cfg_mi.node {\n+                            if cfg_nmis.len() == 1 {\n+                                if let MetaItem(ref content_mi) = cfg_nmis[0].node {\n+                                    return Some(content_mi);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    pub fn from_ast(diagnostic: &::errors::Handler, attrs: &[ast::Attribute]) -> Attributes {\n         let mut doc_strings = vec![];\n         let mut sp = None;\n+        let mut cfg = Cfg::True;\n+\n         let other_attrs = attrs.iter().filter_map(|attr| {\n             attr.with_desugared_doc(|attr| {\n-                if let Some(value) = attr.value_str() {\n-                    if attr.check_name(\"doc\") {\n-                        doc_strings.push(value.to_string());\n-                        if sp.is_none() {\n-                            sp = Some(attr.span);\n+                if attr.check_name(\"doc\") {\n+                    if let Some(mi) = attr.meta() {\n+                        if let Some(value) = mi.value_str() {\n+                            // Extracted #[doc = \"...\"]\n+                            doc_strings.push(value.to_string());\n+                            if sp.is_none() {\n+                                sp = Some(attr.span);\n+                            }\n+                            return None;\n+                        } else if let Some(cfg_mi) = Attributes::extract_cfg(&mi) {\n+                            // Extracted #[doc(cfg(...))]\n+                            match Cfg::parse(cfg_mi) {\n+                                Ok(new_cfg) => cfg &= new_cfg,\n+                                Err(e) => diagnostic.span_err(e.span, e.msg),\n+                            }\n+                            return None;\n                         }\n-                        return None;\n                     }\n                 }\n-\n                 Some(attr.clone())\n             })\n         }).collect();\n         Attributes {\n-            doc_strings: doc_strings,\n-            other_attrs: other_attrs,\n+            doc_strings,\n+            other_attrs,\n+            cfg: if cfg == Cfg::True { None } else { Some(Rc::new(cfg)) },\n             span: sp,\n         }\n     }\n@@ -579,8 +618,8 @@ impl AttributesExt for Attributes {\n }\n \n impl Clean<Attributes> for [ast::Attribute] {\n-    fn clean(&self, _cx: &DocContext) -> Attributes {\n-        Attributes::from_ast(self)\n+    fn clean(&self, cx: &DocContext) -> Attributes {\n+        Attributes::from_ast(cx.sess().diagnostic(), self)\n     }\n }\n "}, {"sha": "95aa8e97dbbaca941b1341df02d0287b025457a3", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=a2b888675accccedec7601cc3bd67ca028b4757c", "patch": "@@ -1950,6 +1950,14 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n         stability.push(format!(\"<div class='stab deprecated'>{}</div>\", text))\n     }\n \n+    if let Some(ref cfg) = item.attrs.cfg {\n+        stability.push(format!(\"<div class='stab portability'>{}</div>\", if show_reason {\n+            cfg.render_long_html()\n+        } else {\n+            cfg.render_short_html()\n+        }));\n+    }\n+\n     stability\n }\n "}, {"sha": "08bf5a10fe9d981280810ff6bbd4ff9dac1e1301", "filename": "src/librustdoc/html/static/styles/main.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css?ref=a2b888675accccedec7601cc3bd67ca028b4757c", "patch": "@@ -152,6 +152,7 @@ a.test-arrow {\n \n .stab.unstable { background: #FFF5D6; border-color: #FFC600; }\n .stab.deprecated { background: #F3DFFF; border-color: #7F0087; }\n+.stab.portability { background: #C4ECFF; border-color: #7BA5DB; }\n \n #help > div {\n \tbackground: #e9e9e9;"}, {"sha": "9264015ed9edfae068ccc6d783af38e71726498f", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=a2b888675accccedec7601cc3bd67ca028b4757c", "patch": "@@ -26,6 +26,7 @@\n #![feature(test)]\n #![feature(unicode)]\n #![feature(vec_remove_item)]\n+#![feature(ascii_ctype)]\n \n extern crate arena;\n extern crate getopts;"}, {"sha": "146629486fabdf58788170ff1213c53703bba808", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=a2b888675accccedec7601cc3bd67ca028b4757c", "patch": "@@ -33,6 +33,9 @@ pub use self::strip_priv_imports::strip_priv_imports;\n mod unindent_comments;\n pub use self::unindent_comments::unindent_comments;\n \n+mod propagate_doc_cfg;\n+pub use self::propagate_doc_cfg::propagate_doc_cfg;\n+\n type Pass = (&'static str,                                      // name\n              fn(clean::Crate) -> plugins::PluginResult,         // fn\n              &'static str);                                     // description\n@@ -49,13 +52,16 @@ pub const PASSES: &'static [Pass] = &[\n       implies strip-priv-imports\"),\n     (\"strip-priv-imports\", strip_priv_imports,\n      \"strips all private import statements (`use`, `extern crate`) from a crate\"),\n+    (\"propagate-doc-cfg\", propagate_doc_cfg,\n+     \"propagates `#[doc(cfg(...))]` to child items\"),\n ];\n \n pub const DEFAULT_PASSES: &'static [&'static str] = &[\n     \"strip-hidden\",\n     \"strip-private\",\n     \"collapse-docs\",\n     \"unindent-comments\",\n+    \"propagate-doc-cfg\",\n ];\n \n "}, {"sha": "9e65fff5e2ac6f3f65c04f9a3af106a9e708c65a", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=a2b888675accccedec7601cc3bd67ca028b4757c", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+\n+use clean::{Crate, Item};\n+use clean::cfg::Cfg;\n+use fold::DocFolder;\n+use plugins::PluginResult;\n+\n+pub fn propagate_doc_cfg(cr: Crate) -> PluginResult {\n+    CfgPropagator { parent_cfg: None }.fold_crate(cr)\n+}\n+\n+struct CfgPropagator {\n+    parent_cfg: Option<Rc<Cfg>>,\n+}\n+\n+impl DocFolder for CfgPropagator {\n+    fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n+        let old_parent_cfg = self.parent_cfg.clone();\n+\n+        let new_cfg = match (self.parent_cfg.take(), item.attrs.cfg.take()) {\n+            (None, None) => None,\n+            (Some(rc), None) | (None, Some(rc)) => Some(rc),\n+            (Some(mut a), Some(b)) => {\n+                let b = Rc::try_unwrap(b).unwrap_or_else(|rc| Cfg::clone(&rc));\n+                *Rc::make_mut(&mut a) &= b;\n+                Some(a)\n+            }\n+        };\n+        self.parent_cfg = new_cfg.clone();\n+        item.attrs.cfg = new_cfg;\n+\n+        let result = self.fold_item_recur(item);\n+        self.parent_cfg = old_parent_cfg;\n+\n+        result\n+    }\n+}"}, {"sha": "fff047c99c034a7d17b8732f7e788742478caa9e", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=a2b888675accccedec7601cc3bd67ca028b4757c", "patch": "@@ -125,6 +125,7 @@ pub fn run(input: &str,\n         let map = hir::map::map_crate(&mut hir_forest, defs);\n         let krate = map.krate();\n         let mut hir_collector = HirCollector {\n+            sess: &sess,\n             collector: &mut collector,\n             map: &map\n         };\n@@ -578,6 +579,7 @@ impl Collector {\n }\n \n struct HirCollector<'a, 'hir: 'a> {\n+    sess: &'a session::Session,\n     collector: &'a mut Collector,\n     map: &'a hir::map::Map<'hir>\n }\n@@ -587,12 +589,18 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n                                             name: String,\n                                             attrs: &[ast::Attribute],\n                                             nested: F) {\n+        let mut attrs = Attributes::from_ast(self.sess.diagnostic(), attrs);\n+        if let Some(ref cfg) = attrs.cfg {\n+            if !cfg.matches(&self.sess.parse_sess, Some(&self.sess.features.borrow())) {\n+                return;\n+            }\n+        }\n+\n         let has_name = !name.is_empty();\n         if has_name {\n             self.collector.names.push(name);\n         }\n \n-        let mut attrs = Attributes::from_ast(attrs);\n         attrs.collapse_doc_comments();\n         attrs.unindent_doc_comments();\n         if let Some(doc) = attrs.doc_value() {"}, {"sha": "668732e6855b9b33a6bed4bc6305a669d24aca4f", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=a2b888675accccedec7601cc3bd67ca028b4757c", "patch": "@@ -364,6 +364,9 @@ declare_features! (\n     // global allocators and their internals\n     (active, global_allocator, \"1.20.0\", None),\n     (active, allocator_internals, \"1.20.0\", None),\n+\n+    // #[doc(cfg(...))]\n+    (active, doc_cfg, \"1.21.0\", Some(43781)),\n );\n \n declare_features! (\n@@ -1157,6 +1160,16 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             self.context.check_attribute(attr, false);\n         }\n \n+        if attr.check_name(\"doc\") {\n+            if let Some(content) = attr.meta_item_list() {\n+                if content.len() == 1 && content[0].check_name(\"cfg\") {\n+                    gate_feature_post!(&self, doc_cfg, attr.span,\n+                        \"#[doc(cfg(...))] is experimental\"\n+                    );\n+                }\n+            }\n+        }\n+\n         if self.context.features.proc_macro && attr::is_known(attr) {\n             return\n         }"}, {"sha": "1a77d918014572c3c4974867dec71738a8665d4a", "filename": "src/test/compile-fail/feature-gate-doc_cfg.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Ftest%2Fcompile-fail%2Ffeature-gate-doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Ftest%2Fcompile-fail%2Ffeature-gate-doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-doc_cfg.rs?ref=a2b888675accccedec7601cc3bd67ca028b4757c", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[doc(cfg(unix))] //~ ERROR: #[doc(cfg(...))] is experimental\n+fn main() {}"}, {"sha": "cfb37912fe757587e37f06e72b2cb4e7915d3680", "filename": "src/test/rustdoc/doc-cfg.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b888675accccedec7601cc3bd67ca028b4757c/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs?ref=a2b888675accccedec7601cc3bd67ca028b4757c", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(doc_cfg)]\n+\n+// @has doc_cfg/struct.Portable.html\n+// @!has - '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' ''\n+// @has - '//*[@id=\"method.unix_and_arm_only_function\"]' 'fn unix_and_arm_only_function()'\n+// @has - '//*[@class=\"stab portability\"]' 'This is supported on Unix and ARM only.'\n+pub struct Portable;\n+\n+// @has doc_cfg/unix_only/index.html \\\n+//  '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' \\\n+//  'This is supported on Unix only.'\n+// @matches - '//*[@class=\" module-item\"]//*[@class=\"stab portability\"]' '\\AUnix\\Z'\n+// @matches - '//*[@class=\" module-item\"]//*[@class=\"stab portability\"]' '\\AUnix and ARM\\Z'\n+// @count - '//*[@class=\"stab portability\"]' 3\n+#[doc(cfg(unix))]\n+pub mod unix_only {\n+    // @has doc_cfg/unix_only/fn.unix_only_function.html \\\n+    //  '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' \\\n+    //  'This is supported on Unix only.'\n+    // @count - '//*[@class=\"stab portability\"]' 1\n+    pub fn unix_only_function() {\n+        content::should::be::irrelevant();\n+    }\n+\n+    // @has doc_cfg/unix_only/trait.ArmOnly.html \\\n+    //  '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' \\\n+    //  'This is supported on Unix and ARM only.'\n+    // @count - '//*[@class=\"stab portability\"]' 2\n+    #[doc(cfg(target_arch = \"arm\"))]\n+    pub trait ArmOnly {\n+        fn unix_and_arm_only_function();\n+    }\n+\n+    impl ArmOnly for super::Portable {\n+        fn unix_and_arm_only_function() {}\n+    }\n+}\n\\ No newline at end of file"}]}