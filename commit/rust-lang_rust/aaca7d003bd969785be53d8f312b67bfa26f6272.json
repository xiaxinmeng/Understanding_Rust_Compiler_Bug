{"sha": "aaca7d003bd969785be53d8f312b67bfa26f6272", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhY2E3ZDAwM2JkOTY5Nzg1YmU1M2Q4ZjMxMmI2N2JmYTI2ZjYyNzI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-27T17:58:38Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-27T17:58:38Z"}, "message": "move scopes to file", "tree": {"sha": "9e3ab4d75d631fb1055fb6ab5c05f0a78153fadd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e3ab4d75d631fb1055fb6ab5c05f0a78153fadd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aaca7d003bd969785be53d8f312b67bfa26f6272", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aaca7d003bd969785be53d8f312b67bfa26f6272", "html_url": "https://github.com/rust-lang/rust/commit/aaca7d003bd969785be53d8f312b67bfa26f6272", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aaca7d003bd969785be53d8f312b67bfa26f6272/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "846114a6e95da696deb6a0f3243ad23c45074a00", "url": "https://api.github.com/repos/rust-lang/rust/commits/846114a6e95da696deb6a0f3243ad23c45074a00", "html_url": "https://github.com/rust-lang/rust/commit/846114a6e95da696deb6a0f3243ad23c45074a00"}], "stats": {"total": 476, "additions": 280, "deletions": 196}, "files": [{"sha": "282e533af0ba1659174d52d0ada638832a0a1b66", "filename": "code/package.json", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aaca7d003bd969785be53d8f312b67bfa26f6272/code%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/aaca7d003bd969785be53d8f312b67bfa26f6272/code%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/code%2Fpackage.json?ref=aaca7d003bd969785be53d8f312b67bfa26f6272", "patch": "@@ -51,6 +51,10 @@\n       }\n     ],\n     \"commands\": [\n+      {\n+        \"command\": \"libsyntax-rust.createFile\",\n+        \"title\": \"Show Rust syntax tree\"\n+      },\n       {\n         \"command\": \"libsyntax-rust.syntaxTree\",\n         \"title\": \"Show Rust syntax tree\""}, {"sha": "b9d0097763c116eeeecaa33fae412c15a98554f7", "filename": "code/src/extension.ts", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aaca7d003bd969785be53d8f312b67bfa26f6272/code%2Fsrc%2Fextension.ts", "raw_url": "https://github.com/rust-lang/rust/raw/aaca7d003bd969785be53d8f312b67bfa26f6272/code%2Fsrc%2Fextension.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/code%2Fsrc%2Fextension.ts?ref=aaca7d003bd969785be53d8f312b67bfa26f6272", "patch": "@@ -81,11 +81,21 @@ export function activate(context: vscode.ExtensionContext) {\n         let e = await vscode.window.showTextDocument(doc)\n         e.revealRange(range, vscode.TextEditorRevealType.InCenter)\n     })\n-    console.log(\"ping\")\n+\n     registerCommand('libsyntax-rust.run', async (cmd: ProcessSpec) => {\n         let task = createTask(cmd)\n         await vscode.tasks.executeTask(task)\n     })\n+    registerCommand('libsyntax-rust.createFile', async (uri_: string) => {\n+        console.log(`uri: ${uri_}`)\n+        let uri = vscode.Uri.parse(uri_)\n+        let edit = new vscode.WorkspaceEdit()\n+        edit.createFile(uri)\n+        await vscode.workspace.applyEdit(edit)\n+        let doc = await vscode.workspace.openTextDocument(uri)\n+        await vscode.window.showTextDocument(doc)\n+        console.log(\"Done\")\n+    })\n \n     dispose(vscode.workspace.registerTextDocumentContentProvider(\n         'libsyntax-rust',"}, {"sha": "49c39e1f36f85280ec19ee97bcbf1c89c222ef72", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/aaca7d003bd969785be53d8f312b67bfa26f6272/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaca7d003bd969785be53d8f312b67bfa26f6272/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=aaca7d003bd969785be53d8f312b67bfa26f6272", "patch": "@@ -12,12 +12,9 @@ extern crate rayon;\n mod symbol_index;\n mod module_map;\n \n-use once_cell::sync::OnceCell;\n-use rayon::prelude::*;\n-\n use std::{\n     fmt,\n-    path::{Path},\n+    path::{Path, PathBuf},\n     sync::{\n         Arc,\n         atomic::{AtomicBool, Ordering::SeqCst},\n@@ -26,13 +23,16 @@ use std::{\n     time::Instant,\n };\n \n+use once_cell::sync::OnceCell;\n+use rayon::prelude::*;\n+\n use libsyntax2::{\n     File,\n     TextUnit, TextRange, SmolStr,\n     ast::{self, AstNode, NameOwner},\n     SyntaxKind::*,\n };\n-use libeditor::{LineIndex, FileSymbol, find_node_at_offset};\n+use libeditor::{Diagnostic, LineIndex, FileSymbol, find_node_at_offset};\n \n use self::{\n     symbol_index::FileSymbols,\n@@ -130,6 +130,9 @@ impl WorldState {\n     }\n }\n \n+pub enum QuickFix {\n+    CreateFile(PathBuf),\n+}\n \n impl World {\n     pub fn file_syntax(&self, file_id: FileId) -> Result<File> {\n@@ -210,6 +213,29 @@ impl World {\n         Ok(vec![])\n     }\n \n+    pub fn diagnostics(&self, file_id: FileId) -> Result<Vec<(Diagnostic, Option<QuickFix>)>> {\n+        let syntax = self.file_syntax(file_id)?;\n+        let mut res = libeditor::diagnostics(&syntax)\n+            .into_iter()\n+            .map(|d| (d, None))\n+            .collect::<Vec<_>>();\n+        for module in syntax.ast().modules() {\n+            if module.has_semi() && self.resolve_module(file_id, module).is_empty() {\n+                if let Some(name) = module.name() {\n+                    let d = Diagnostic {\n+                        range: name.syntax().range(),\n+                        msg: \"unresolved module\".to_string(),\n+                    };\n+                    let quick_fix = self.data.module_map.suggested_child_mod_path(module)\n+                        .map(QuickFix::CreateFile);\n+\n+                    res.push((d, quick_fix))\n+                }\n+            }\n+        }\n+        Ok(res)\n+    }\n+\n     fn index_resolve(&self, name_ref: ast::NameRef) -> Vec<(FileId, FileSymbol)> {\n         let name = name_ref.text();\n         let mut query = Query::new(name.to_string());"}, {"sha": "4f480591ed7ea7da9d0217a155b7fba212ecbae6", "filename": "crates/libanalysis/src/module_map.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aaca7d003bd969785be53d8f312b67bfa26f6272/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaca7d003bd969785be53d8f312b67bfa26f6272/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs?ref=aaca7d003bd969785be53d8f312b67bfa26f6272", "patch": "@@ -93,6 +93,11 @@ impl ModuleMap {\n         res\n     }\n \n+    pub fn suggested_child_mod_path(&self, m: ast::Module) -> Option<PathBuf> {\n+        let name = m.name()?;\n+        Some(PathBuf::from(format!(\"../{}.rs\", name.text())))\n+    }\n+\n     fn links(\n         &self,\n         file_resolver: &FileResolver,"}, {"sha": "b3c357b02714637fb3ee9b3c6f3bf843c8f7a86c", "filename": "crates/libanalysis/tests/tests.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aaca7d003bd969785be53d8f312b67bfa26f6272/crates%2Flibanalysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaca7d003bd969785be53d8f312b67bfa26f6272/crates%2Flibanalysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Ftests%2Ftests.rs?ref=aaca7d003bd969785be53d8f312b67bfa26f6272", "patch": "@@ -44,6 +44,19 @@ fn test_resolve_module() {\n     );\n }\n \n+#[test]\n+fn test_unresolved_module_diagnostic() {\n+    let mut world = WorldState::new();\n+    world.change_file(FileId(1), Some(\"mod foo;\".to_string()));\n+\n+    let snap = world.snapshot(|_id, _path| None);\n+    let diagnostics = snap.diagnostics(FileId(1)).unwrap();\n+    assert_eq_dbg(\n+        r#\"[Diagnostic { range: [4; 7), msg: \"unresolved module\" }]\"#,\n+        &diagnostics,\n+    );\n+}\n+\n #[test]\n fn test_resolve_parent_module() {\n     let mut world = WorldState::new();"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "crates/libeditor/scope.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aaca7d003bd969785be53d8f312b67bfa26f6272/crates%2Flibeditor%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaca7d003bd969785be53d8f312b67bfa26f6272/crates%2Flibeditor%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fscope.rs?ref=aaca7d003bd969785be53d8f312b67bfa26f6272"}, {"sha": "242a3a43472d4fa597726ae829267606477e747b", "filename": "crates/libeditor/src/completion.rs", "status": "modified", "additions": 3, "deletions": 184, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/aaca7d003bd969785be53d8f312b67bfa26f6272/crates%2Flibeditor%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaca7d003bd969785be53d8f312b67bfa26f6272/crates%2Flibeditor%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fcompletion.rs?ref=aaca7d003bd969785be53d8f312b67bfa26f6272", "patch": "@@ -1,20 +1,14 @@\n-use std::{\n-    fmt,\n-    collections::HashMap,\n-};\n-\n use libsyntax2::{\n-    File, TextUnit, AstNode, SyntaxNodeRef, SyntaxNode, SmolStr,\n-    ast::{self, NameOwner},\n+    File, TextUnit, AstNode,\n+    ast::self,\n     algo::{\n         ancestors,\n-        walk::preorder,\n-        generate,\n     },\n };\n \n use {\n     AtomEdit, find_node_at_offset,\n+    scope::{FnScopes, compute_scopes},\n };\n \n #[derive(Debug)]\n@@ -43,178 +37,3 @@ fn complete(name_ref: ast::NameRef, scopes: &FnScopes) -> Vec<CompletionItem> {\n         })\n         .collect()\n }\n-\n-fn compute_scopes(fn_def: ast::FnDef) -> FnScopes {\n-    let mut scopes = FnScopes::new();\n-    let root = scopes.root_scope();\n-    fn_def.param_list().into_iter()\n-        .flat_map(|it| it.params())\n-        .filter_map(|it| it.pat())\n-        .for_each(|it| scopes.add_bindings(root, it));\n-\n-    if let Some(body) = fn_def.body() {\n-        compute_block_scopes(body, &mut scopes, root)\n-    }\n-    scopes\n-}\n-\n-fn compute_block_scopes(block: ast::Block, scopes: &mut FnScopes, mut scope: ScopeId) {\n-    for stmt in block.statements() {\n-        match stmt {\n-            ast::Stmt::LetStmt(stmt) => {\n-                scope = scopes.new_scope(scope);\n-                if let Some(pat) = stmt.pat() {\n-                    scopes.add_bindings(scope, pat);\n-                }\n-                if let Some(expr) = stmt.initializer() {\n-                    scopes.set_scope(expr.syntax(), scope)\n-                }\n-            }\n-            ast::Stmt::ExprStmt(expr_stmt) => {\n-                if let Some(expr) = expr_stmt.expr() {\n-                    scopes.set_scope(expr.syntax(), scope);\n-                    compute_expr_scopes(expr, scopes, scope);\n-                }\n-            }\n-        }\n-    }\n-    if let Some(expr) = block.expr() {\n-        scopes.set_scope(expr.syntax(), scope);\n-        compute_expr_scopes(expr, scopes, scope);\n-    }\n-}\n-\n-fn compute_expr_scopes(expr: ast::Expr, scopes: &mut FnScopes, scope: ScopeId) {\n-    match expr {\n-        ast::Expr::IfExpr(e) => {\n-            let cond_scope = e.condition().and_then(|cond| {\n-                compute_cond_scopes(cond, scopes, scope)\n-            });\n-            if let Some(block) = e.then_branch() {\n-                compute_block_scopes(block, scopes, cond_scope.unwrap_or(scope));\n-            }\n-            if let Some(block) = e.else_branch() {\n-                compute_block_scopes(block, scopes, scope);\n-            }\n-        },\n-        ast::Expr::WhileExpr(e) => {\n-            let cond_scope = e.condition().and_then(|cond| {\n-                compute_cond_scopes(cond, scopes, scope)\n-            });\n-            if let Some(block) = e.body() {\n-                compute_block_scopes(block, scopes, cond_scope.unwrap_or(scope));\n-            }\n-        },\n-        ast::Expr::BlockExpr(e) => {\n-            if let Some(block) = e.block() {\n-                compute_block_scopes(block, scopes, scope);\n-            }\n-        }\n-        // ForExpr(e) => TODO,\n-        _ => {\n-            expr.syntax().children()\n-                .filter_map(ast::Expr::cast)\n-                .for_each(|expr| compute_expr_scopes(expr, scopes, scope))\n-        }\n-    };\n-\n-    fn compute_cond_scopes(cond: ast::Condition, scopes: &mut FnScopes, scope: ScopeId) -> Option<ScopeId> {\n-        if let Some(expr) = cond.expr() {\n-            compute_expr_scopes(expr, scopes, scope);\n-        }\n-        if let Some(pat) = cond.pat() {\n-            let s = scopes.new_scope(scope);\n-            scopes.add_bindings(s, pat);\n-            Some(s)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-type ScopeId = usize;\n-\n-#[derive(Debug)]\n-struct FnScopes {\n-    scopes: Vec<ScopeData>,\n-    scope_for: HashMap<SyntaxNode, ScopeId>,\n-}\n-\n-impl FnScopes {\n-    fn new() -> FnScopes {\n-        FnScopes {\n-            scopes: vec![],\n-            scope_for: HashMap::new(),\n-        }\n-    }\n-    fn root_scope(&mut self) -> ScopeId {\n-        let res = self.scopes.len();\n-        self.scopes.push(ScopeData { parent: None, entries: vec![] });\n-        res\n-    }\n-    fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n-        let res = self.scopes.len();\n-        self.scopes.push(ScopeData { parent: Some(parent), entries: vec![] });\n-        res\n-    }\n-    fn add_bindings(&mut self, scope: ScopeId, pat: ast::Pat) {\n-        let entries = preorder(pat.syntax())\n-            .filter_map(ast::BindPat::cast)\n-            .filter_map(ScopeEntry::new);\n-        self.scopes[scope].entries.extend(entries);\n-    }\n-    fn set_scope(&mut self, node: SyntaxNodeRef, scope: ScopeId) {\n-        self.scope_for.insert(node.owned(), scope);\n-    }\n-    fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n-        &self.scopes[scope].entries\n-    }\n-    fn scope_for(&self, node: SyntaxNodeRef) -> Option<ScopeId> {\n-        ancestors(node)\n-            .filter_map(|it| self.scope_for.get(&it.owned()).map(|&scope| scope))\n-            .next()\n-    }\n-    fn scope_chain<'a>(&'a self, node: SyntaxNodeRef) -> impl Iterator<Item=ScopeId> + 'a {\n-        generate(self.scope_for(node), move |&scope| self.scopes[scope].parent)\n-    }\n-}\n-\n-#[derive(Debug)]\n-struct ScopeData {\n-    parent: Option<ScopeId>,\n-    entries: Vec<ScopeEntry>\n-}\n-\n-struct ScopeEntry {\n-    syntax: SyntaxNode\n-}\n-\n-impl ScopeEntry {\n-    fn new(pat: ast::BindPat) -> Option<ScopeEntry> {\n-        if pat.name().is_some() {\n-            Some(ScopeEntry { syntax: pat.syntax().owned() })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn name(&self) -> SmolStr {\n-        self.ast().name()\n-            .unwrap()\n-            .text()\n-    }\n-\n-    fn ast(&self) -> ast::BindPat {\n-        ast::BindPat::cast(self.syntax.borrowed())\n-            .unwrap()\n-    }\n-}\n-\n-impl fmt::Debug for ScopeEntry {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"ScopeEntry\")\n-         .field(\"name\", &self.name())\n-         .field(\"syntax\", &self.syntax)\n-         .finish()\n-    }\n-}"}, {"sha": "d39e56d81d195d19488fde3432e55b570b7c087f", "filename": "crates/libeditor/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aaca7d003bd969785be53d8f312b67bfa26f6272/crates%2Flibeditor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaca7d003bd969785be53d8f312b67bfa26f6272/crates%2Flibeditor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Flib.rs?ref=aaca7d003bd969785be53d8f312b67bfa26f6272", "patch": "@@ -9,6 +9,7 @@ mod edit;\n mod code_actions;\n mod typing;\n mod completion;\n+mod scope;\n \n use libsyntax2::{\n     File, TextUnit, TextRange, SyntaxNodeRef,"}, {"sha": "1fec0b24e4a9c2b363a4cc8582b8b10a2d3c8342", "filename": "crates/libeditor/src/scope.rs", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/aaca7d003bd969785be53d8f312b67bfa26f6272/crates%2Flibeditor%2Fsrc%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaca7d003bd969785be53d8f312b67bfa26f6272/crates%2Flibeditor%2Fsrc%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fscope.rs?ref=aaca7d003bd969785be53d8f312b67bfa26f6272", "patch": "@@ -0,0 +1,183 @@\n+use std::{\n+    fmt,\n+    collections::HashMap,\n+};\n+\n+use libsyntax2::{\n+    SyntaxNodeRef, SyntaxNode, SmolStr, AstNode,\n+    ast::{self, NameOwner},\n+    algo::{ancestors, generate, walk::preorder}\n+};\n+\n+pub fn compute_scopes(fn_def: ast::FnDef) -> FnScopes {\n+    let mut scopes = FnScopes::new();\n+    let root = scopes.root_scope();\n+    fn_def.param_list().into_iter()\n+        .flat_map(|it| it.params())\n+        .filter_map(|it| it.pat())\n+        .for_each(|it| scopes.add_bindings(root, it));\n+\n+    if let Some(body) = fn_def.body() {\n+        compute_block_scopes(body, &mut scopes, root)\n+    }\n+    scopes\n+}\n+\n+fn compute_block_scopes(block: ast::Block, scopes: &mut FnScopes, mut scope: ScopeId) {\n+    for stmt in block.statements() {\n+        match stmt {\n+            ast::Stmt::LetStmt(stmt) => {\n+                scope = scopes.new_scope(scope);\n+                if let Some(pat) = stmt.pat() {\n+                    scopes.add_bindings(scope, pat);\n+                }\n+                if let Some(expr) = stmt.initializer() {\n+                    scopes.set_scope(expr.syntax(), scope)\n+                }\n+            }\n+            ast::Stmt::ExprStmt(expr_stmt) => {\n+                if let Some(expr) = expr_stmt.expr() {\n+                    scopes.set_scope(expr.syntax(), scope);\n+                    compute_expr_scopes(expr, scopes, scope);\n+                }\n+            }\n+        }\n+    }\n+    if let Some(expr) = block.expr() {\n+        scopes.set_scope(expr.syntax(), scope);\n+        compute_expr_scopes(expr, scopes, scope);\n+    }\n+}\n+\n+fn compute_expr_scopes(expr: ast::Expr, scopes: &mut FnScopes, scope: ScopeId) {\n+    match expr {\n+        ast::Expr::IfExpr(e) => {\n+            let cond_scope = e.condition().and_then(|cond| {\n+                compute_cond_scopes(cond, scopes, scope)\n+            });\n+            if let Some(block) = e.then_branch() {\n+                compute_block_scopes(block, scopes, cond_scope.unwrap_or(scope));\n+            }\n+            if let Some(block) = e.else_branch() {\n+                compute_block_scopes(block, scopes, scope);\n+            }\n+        },\n+        ast::Expr::WhileExpr(e) => {\n+            let cond_scope = e.condition().and_then(|cond| {\n+                compute_cond_scopes(cond, scopes, scope)\n+            });\n+            if let Some(block) = e.body() {\n+                compute_block_scopes(block, scopes, cond_scope.unwrap_or(scope));\n+            }\n+        },\n+        ast::Expr::BlockExpr(e) => {\n+            if let Some(block) = e.block() {\n+                compute_block_scopes(block, scopes, scope);\n+            }\n+        }\n+        // ForExpr(e) => TODO,\n+        _ => {\n+            expr.syntax().children()\n+                .filter_map(ast::Expr::cast)\n+                .for_each(|expr| compute_expr_scopes(expr, scopes, scope))\n+        }\n+    };\n+\n+    fn compute_cond_scopes(cond: ast::Condition, scopes: &mut FnScopes, scope: ScopeId) -> Option<ScopeId> {\n+        if let Some(expr) = cond.expr() {\n+            compute_expr_scopes(expr, scopes, scope);\n+        }\n+        if let Some(pat) = cond.pat() {\n+            let s = scopes.new_scope(scope);\n+            scopes.add_bindings(s, pat);\n+            Some(s)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+type ScopeId = usize;\n+\n+#[derive(Debug)]\n+pub struct FnScopes {\n+    scopes: Vec<ScopeData>,\n+    scope_for: HashMap<SyntaxNode, ScopeId>,\n+}\n+\n+impl FnScopes {\n+    fn new() -> FnScopes {\n+        FnScopes {\n+            scopes: vec![],\n+            scope_for: HashMap::new(),\n+        }\n+    }\n+    pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n+        &self.scopes[scope].entries\n+    }\n+    pub fn scope_chain<'a>(&'a self, node: SyntaxNodeRef) -> impl Iterator<Item=ScopeId> + 'a {\n+        generate(self.scope_for(node), move |&scope| self.scopes[scope].parent)\n+    }\n+    fn root_scope(&mut self) -> ScopeId {\n+        let res = self.scopes.len();\n+        self.scopes.push(ScopeData { parent: None, entries: vec![] });\n+        res\n+    }\n+    fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n+        let res = self.scopes.len();\n+        self.scopes.push(ScopeData { parent: Some(parent), entries: vec![] });\n+        res\n+    }\n+    fn add_bindings(&mut self, scope: ScopeId, pat: ast::Pat) {\n+        let entries = preorder(pat.syntax())\n+            .filter_map(ast::BindPat::cast)\n+            .filter_map(ScopeEntry::new);\n+        self.scopes[scope].entries.extend(entries);\n+    }\n+    fn set_scope(&mut self, node: SyntaxNodeRef, scope: ScopeId) {\n+        self.scope_for.insert(node.owned(), scope);\n+    }\n+    fn scope_for(&self, node: SyntaxNodeRef) -> Option<ScopeId> {\n+        ancestors(node)\n+            .filter_map(|it| self.scope_for.get(&it.owned()).map(|&scope| scope))\n+            .next()\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct ScopeData {\n+    parent: Option<ScopeId>,\n+    entries: Vec<ScopeEntry>\n+}\n+\n+pub struct ScopeEntry {\n+    syntax: SyntaxNode\n+}\n+\n+impl ScopeEntry {\n+    fn new(pat: ast::BindPat) -> Option<ScopeEntry> {\n+        if pat.name().is_some() {\n+            Some(ScopeEntry { syntax: pat.syntax().owned() })\n+        } else {\n+            None\n+        }\n+    }\n+    pub fn name(&self) -> SmolStr {\n+        self.ast().name()\n+            .unwrap()\n+            .text()\n+    }\n+    fn ast(&self) -> ast::BindPat {\n+        ast::BindPat::cast(self.syntax.borrowed())\n+            .unwrap()\n+    }\n+}\n+\n+impl fmt::Debug for ScopeEntry {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"ScopeEntry\")\n+         .field(\"name\", &self.name())\n+         .field(\"syntax\", &self.syntax)\n+         .finish()\n+    }\n+}"}, {"sha": "e83c82c92dd7b4ca472d383ffd6c2a1b145f0193", "filename": "crates/libsyntax2/src/grammar/expressions/atom.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aaca7d003bd969785be53d8f312b67bfa26f6272/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaca7d003bd969785be53d8f312b67bfa26f6272/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=aaca7d003bd969785be53d8f312b67bfa26f6272", "patch": "@@ -29,8 +29,8 @@ pub(crate) fn literal(p: &mut Parser) -> Option<CompletedMarker> {\n pub(super) const ATOM_EXPR_FIRST: TokenSet =\n     token_set_union![\n         LITERAL_FIRST,\n-        token_set![L_PAREN, PIPE, MOVE_KW, IF_KW, WHILE_KW, MATCH_KW, UNSAFE_KW, L_CURLY, RETURN_KW,\n-                   IDENT, SELF_KW, SUPER_KW, COLONCOLON, BREAK_KW, CONTINUE_KW, LIFETIME ],\n+        token_set![L_CURLY, L_PAREN, L_BRACK, PIPE, MOVE_KW, IF_KW, WHILE_KW, MATCH_KW, UNSAFE_KW,\n+                   RETURN_KW, IDENT, SELF_KW, SUPER_KW, COLONCOLON, BREAK_KW, CONTINUE_KW, LIFETIME ],\n     ];\n \n pub(super) fn atom_expr(p: &mut Parser, r: Restrictions) -> Option<CompletedMarker> {"}, {"sha": "350eda7dfcdf4c82ecba599542724cc4c56e03e6", "filename": "crates/server/src/main_loop/handlers.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/aaca7d003bd969785be53d8f312b67bfa26f6272/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaca7d003bd969785be53d8f312b67bfa26f6272/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=aaca7d003bd969785be53d8f312b67bfa26f6272", "patch": "@@ -7,7 +7,7 @@ use languageserver_types::{\n     CompletionItem,\n };\n use serde_json::{to_value, from_value};\n-use libanalysis::{Query};\n+use libanalysis::{Query, QuickFix};\n use libeditor;\n use libsyntax2::{\n     TextUnit,\n@@ -177,6 +177,30 @@ pub fn handle_code_action(\n         };\n         res.push(cmd);\n     }\n+\n+    for (diag, quick_fix) in world.analysis().diagnostics(file_id)? {\n+        let quick_fix = match quick_fix {\n+            Some(quick_fix) => quick_fix,\n+            None => continue,\n+        };\n+        if !contains_offset_nonstrict(diag.range, offset) {\n+            continue;\n+        }\n+        let cmd = match quick_fix {\n+            QuickFix::CreateFile(path) => {\n+                let path = &path.to_str().unwrap()[3..]; // strip `../` b/c url is weird\n+                let uri = params.text_document.uri.join(path)\n+                    .unwrap();\n+                let uri = ::url_serde::Ser::new(&uri);\n+                Command {\n+                    title: \"Create file\".to_string(),\n+                    command: \"libsyntax-rust.createFile\".to_string(),\n+                    arguments: Some(vec![to_value(uri).unwrap()]),\n+                }\n+            }\n+        };\n+        res.push(cmd)\n+    }\n     return Ok(Some(res));\n }\n \n@@ -355,11 +379,10 @@ pub fn publish_diagnostics(\n     uri: Url\n ) -> Result<req::PublishDiagnosticsParams> {\n     let file_id = world.uri_to_file_id(&uri)?;\n-    let file = world.analysis().file_syntax(file_id)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n-    let diagnostics = libeditor::diagnostics(&file)\n+    let diagnostics = world.analysis().diagnostics(file_id)?\n         .into_iter()\n-        .map(|d| Diagnostic {\n+        .map(|(d, _quick_fix)| Diagnostic {\n             range: d.range.conv_with(&line_index),\n             severity: Some(DiagnosticSeverity::Error),\n             code: None,"}]}