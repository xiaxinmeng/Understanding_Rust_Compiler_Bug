{"sha": "09524bfd5ace53bfecddd669a5d90e5495eaa3de", "node_id": "C_kwDOAAsO6NoAKDA5NTI0YmZkNWFjZTUzYmZlY2RkZDY2OWE1ZDkwZTU0OTVlYWEzZGU", "commit": {"author": {"name": "Ali MJ Al-Nasrawy", "email": "alimjalnasrawy@gmail.com", "date": "2023-03-03T00:56:42Z"}, "committer": {"name": "Ali MJ Al-Nasrawy", "email": "alimjalnasrawy@gmail.com", "date": "2023-03-03T11:04:50Z"}, "message": "promote subject even if it has unnamed regions\n\nDon't require a region to have an `external_name` in order to be\npromoted.", "tree": {"sha": "33568b5654c8beacadbf8366ddf8d2d70310e38d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33568b5654c8beacadbf8366ddf8d2d70310e38d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09524bfd5ace53bfecddd669a5d90e5495eaa3de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09524bfd5ace53bfecddd669a5d90e5495eaa3de", "html_url": "https://github.com/rust-lang/rust/commit/09524bfd5ace53bfecddd669a5d90e5495eaa3de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09524bfd5ace53bfecddd669a5d90e5495eaa3de/comments", "author": {"login": "aliemjay", "id": 28497461, "node_id": "MDQ6VXNlcjI4NDk3NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/28497461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aliemjay", "html_url": "https://github.com/aliemjay", "followers_url": "https://api.github.com/users/aliemjay/followers", "following_url": "https://api.github.com/users/aliemjay/following{/other_user}", "gists_url": "https://api.github.com/users/aliemjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/aliemjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aliemjay/subscriptions", "organizations_url": "https://api.github.com/users/aliemjay/orgs", "repos_url": "https://api.github.com/users/aliemjay/repos", "events_url": "https://api.github.com/users/aliemjay/events{/privacy}", "received_events_url": "https://api.github.com/users/aliemjay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aliemjay", "id": 28497461, "node_id": "MDQ6VXNlcjI4NDk3NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/28497461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aliemjay", "html_url": "https://github.com/aliemjay", "followers_url": "https://api.github.com/users/aliemjay/followers", "following_url": "https://api.github.com/users/aliemjay/following{/other_user}", "gists_url": "https://api.github.com/users/aliemjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/aliemjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aliemjay/subscriptions", "organizations_url": "https://api.github.com/users/aliemjay/orgs", "repos_url": "https://api.github.com/users/aliemjay/repos", "events_url": "https://api.github.com/users/aliemjay/events{/privacy}", "received_events_url": "https://api.github.com/users/aliemjay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20b20b23eac9809172eeaab71a3952ec53d37ce6", "url": "https://api.github.com/repos/rust-lang/rust/commits/20b20b23eac9809172eeaab71a3952ec53d37ce6", "html_url": "https://github.com/rust-lang/rust/commit/20b20b23eac9809172eeaab71a3952ec53d37ce6"}], "stats": {"total": 133, "additions": 66, "deletions": 67}, "files": [{"sha": "eadd9bd7dfe2f7f0b97316c4e0a574d194b68320", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/09524bfd5ace53bfecddd669a5d90e5495eaa3de/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09524bfd5ace53bfecddd669a5d90e5495eaa3de/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=09524bfd5ace53bfecddd669a5d90e5495eaa3de", "patch": "@@ -12,8 +12,9 @@ use rustc_infer::infer::outlives::test_type_match;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound, VerifyIfEq};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin};\n use rustc_middle::mir::{\n-    Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n-    ConstraintCategory, Local, Location, ReturnConstraint, TerminatorKind,\n+    Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureOutlivesSubjectTy,\n+    ClosureRegionRequirements, ConstraintCategory, Local, Location, ReturnConstraint,\n+    TerminatorKind,\n };\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::traits::ObligationCauseCode;\n@@ -1084,18 +1085,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         true\n     }\n \n-    /// When we promote a type test `T: 'r`, we have to convert the\n-    /// type `T` into something we can store in a query result (so\n-    /// something allocated for `'tcx`). This is problematic if `ty`\n-    /// contains regions. During the course of NLL region checking, we\n-    /// will have replaced all of those regions with fresh inference\n-    /// variables. To create a test subject, we want to replace those\n-    /// inference variables with some region from the closure\n-    /// signature -- this is not always possible, so this is a\n-    /// fallible process. Presuming we do find a suitable region, we\n-    /// will use it's *external name*, which will be a `RegionKind`\n-    /// variant that can be used in query responses such as\n-    /// `ReEarlyBound`.\n+    /// When we promote a type test `T: 'r`, we have to replace all region\n+    /// variables in the type `T` with an equal universal region from the\n+    /// closure signature.\n+    /// This is not always possible, so this is a fallible process.\n     #[instrument(level = \"debug\", skip(self, infcx))]\n     fn try_promote_type_test_subject(\n         &self,\n@@ -1144,22 +1137,22 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // find an equivalent.\n             let upper_bound = self.non_local_universal_upper_bound(region_vid);\n             if self.region_contains(region_vid, upper_bound) {\n-                self.definitions[upper_bound].external_name.unwrap_or(r)\n+                tcx.mk_re_var(upper_bound)\n             } else {\n-                // In the case of a failure, use a `ReVar` result. This will\n-                // cause the `needs_infer` later on to return `None`.\n-                r\n+                // In the case of a failure, use `ReErased`. We will eventually\n+                // return `None` in this case.\n+                tcx.lifetimes.re_erased\n             }\n         });\n \n         debug!(\"try_promote_type_test_subject: folded ty = {:?}\", ty);\n \n-        // `needs_infer` will only be true if we failed to promote some region.\n-        if ty.needs_infer() {\n+        // This will be true if we failed to promote some region.\n+        if ty.has_erased_regions() {\n             return None;\n         }\n \n-        Some(ClosureOutlivesSubject::Ty(ty))\n+        Some(ClosureOutlivesSubject::Ty(ClosureOutlivesSubjectTy::new(tcx, ty)))\n     }\n \n     /// Given some universal or existential region `r`, finds a"}, {"sha": "a93561350062c630b4ed52587175fbada2ad26bf", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09524bfd5ace53bfecddd669a5d90e5495eaa3de/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09524bfd5ace53bfecddd669a5d90e5495eaa3de/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=09524bfd5ace53bfecddd669a5d90e5495eaa3de", "patch": "@@ -116,7 +116,9 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n             let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n             let subject = match outlives_requirement.subject {\n                 ClosureOutlivesSubject::Region(re) => closure_mapping[re].into(),\n-                ClosureOutlivesSubject::Ty(ty) => ty.into(),\n+                ClosureOutlivesSubject::Ty(subject_ty) => {\n+                    subject_ty.instantiate(self.tcx, |vid| closure_mapping[vid]).into()\n+                }\n             };\n \n             self.category = outlives_requirement.category;"}, {"sha": "87a2b9ec73e4193d3661faff2b8b9452ca0e0dce", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 45, "deletions": 12, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/09524bfd5ace53bfecddd669a5d90e5495eaa3de/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09524bfd5ace53bfecddd669a5d90e5495eaa3de/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=09524bfd5ace53bfecddd669a5d90e5495eaa3de", "patch": "@@ -8,7 +8,7 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_index::bit_set::BitMatrix;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use smallvec::SmallVec;\n@@ -289,13 +289,6 @@ pub struct ConstQualifs {\n /// instance of the closure is created, the corresponding free regions\n /// can be extracted from its type and constrained to have the given\n /// outlives relationship.\n-///\n-/// In some cases, we have to record outlives requirements between types and\n-/// regions as well. In that case, if those types include any regions, those\n-/// regions are recorded using their external names (`ReStatic`,\n-/// `ReEarlyBound`, `ReFree`). We use these because in a query response we\n-/// cannot use `ReVar` (which is what we use internally within the rest of the\n-/// NLL code).\n #[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct ClosureRegionRequirements<'tcx> {\n     /// The number of external regions defined on the closure. In our\n@@ -392,16 +385,56 @@ pub enum ClosureOutlivesSubject<'tcx> {\n     /// Subject is a type, typically a type parameter, but could also\n     /// be a projection. Indicates a requirement like `T: 'a` being\n     /// passed to the caller, where the type here is `T`.\n-    ///\n-    /// The type here is guaranteed not to contain any free regions at\n-    /// present.\n-    Ty(Ty<'tcx>),\n+    Ty(ClosureOutlivesSubjectTy<'tcx>),\n \n     /// Subject is a free region from the closure. Indicates a requirement\n     /// like `'a: 'b` being passed to the caller; the region here is `'a`.\n     Region(ty::RegionVid),\n }\n \n+/// Represents a `ty::Ty` for use in [`ClosureOutlivesSubject`].\n+///\n+/// This indirection is necessary because the type may include `ReVar` regions,\n+/// which is what we use internally within NLL code,\n+/// and we can't use `ReVar`s in a query response.\n+#[derive(Copy, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+pub struct ClosureOutlivesSubjectTy<'tcx> {\n+    inner: Ty<'tcx>,\n+}\n+\n+impl<'tcx> ClosureOutlivesSubjectTy<'tcx> {\n+    // All regions of `ty` must be of kind `ReVar`\n+    // and must point to an early-bound region in the closure's signature.\n+    pub fn new(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Self {\n+        let inner = tcx.fold_regions(ty, |r, depth| match r.kind() {\n+            ty::ReVar(vid) => {\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::new(vid.index()),\n+                    kind: ty::BrAnon(0u32, None),\n+                };\n+                tcx.mk_re_late_bound(depth, br)\n+            }\n+            _ => bug!(\"unexpected region in ClosureOutlivesSubjectTy: {r:?}\"),\n+        });\n+\n+        Self { inner }\n+    }\n+\n+    pub fn instantiate(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        mut map: impl FnMut(ty::RegionVid) -> ty::Region<'tcx>,\n+    ) -> Ty<'tcx> {\n+        tcx.fold_regions(self.inner, |r, depth| match r.kind() {\n+            ty::ReLateBound(debruijn, br) => {\n+                debug_assert_eq!(debruijn, depth);\n+                map(ty::RegionVid::new(br.var.index()))\n+            }\n+            _ => bug!(\"unexpected region {r:?}\"),\n+        })\n+    }\n+}\n+\n /// The constituent parts of a mir constant of kind ADT or array.\n #[derive(Copy, Clone, Debug, HashStable)]\n pub struct DestructuredConstant<'tcx> {"}, {"sha": "fce6f2fee7fdaa3e7b3e3d3e2444ad7211319ae8", "filename": "tests/ui/nll/closure-requirements/type-test-subject-opaque-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09524bfd5ace53bfecddd669a5d90e5495eaa3de/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-opaque-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09524bfd5ace53bfecddd669a5d90e5495eaa3de/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-opaque-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-opaque-1.rs?ref=09524bfd5ace53bfecddd669a5d90e5495eaa3de", "patch": "@@ -1,5 +1,5 @@\n-// check-fail\n-// known-bug: #107426\n+// Regression test for #107426.\n+// check-pass\n \n use std::marker::PhantomData;\n #[derive(Clone, Copy)]"}, {"sha": "e54bc8406de48b192c372f92a51ffaebbb3a0a0b", "filename": "tests/ui/nll/closure-requirements/type-test-subject-opaque-1.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20b20b23eac9809172eeaab71a3952ec53d37ce6/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-opaque-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20b20b23eac9809172eeaab71a3952ec53d37ce6/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-opaque-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-opaque-1.stderr?ref=20b20b23eac9809172eeaab71a3952ec53d37ce6", "patch": "@@ -1,8 +0,0 @@\n-error: `make_fn::{opaque#0}<'_>` does not live long enough\n-  --> $DIR/type-test-subject-opaque-1.rs:15:8\n-   |\n-LL |     || event(cx, open_toggle);\n-   |        ^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "b5a95c170099d24d69bccbe246de25b4e0cfc4dd", "filename": "tests/ui/nll/closure-requirements/type-test-subject-unnamed-region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09524bfd5ace53bfecddd669a5d90e5495eaa3de/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-unnamed-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09524bfd5ace53bfecddd669a5d90e5495eaa3de/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-unnamed-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-unnamed-region.rs?ref=09524bfd5ace53bfecddd669a5d90e5495eaa3de", "patch": "@@ -1,5 +1,5 @@\n-// check-fail\n-// known-bug: #108635\n+// See #108635 for description.\n+// check-pass\n \n trait Trait {\n     type Item<'a>: 'a;"}, {"sha": "201329bb005cae9f3e4e8df88c9072d61bdd52ad", "filename": "tests/ui/nll/closure-requirements/type-test-subject-unnamed-region.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/20b20b23eac9809172eeaab71a3952ec53d37ce6/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-unnamed-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20b20b23eac9809172eeaab71a3952ec53d37ce6/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-unnamed-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-unnamed-region.stderr?ref=20b20b23eac9809172eeaab71a3952ec53d37ce6", "patch": "@@ -1,21 +0,0 @@\n-error[E0310]: the associated type `<I as Trait>::Item<'_>` may not live long enough\n-  --> $DIR/type-test-subject-unnamed-region.rs:11:27\n-   |\n-LL |     let closure = |a, _b| assert_static(a);\n-   |                           ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `<I as Trait>::Item<'_>: 'static`...\n-   = note: ...so that the type `<I as Trait>::Item<'_>` will meet its required lifetime bounds\n-\n-error[E0310]: the associated type `<I as Trait>::Item<'_>` may not live long enough\n-  --> $DIR/type-test-subject-unnamed-region.rs:20:9\n-   |\n-LL |         assert_static(a);\n-   |         ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `<I as Trait>::Item<'_>: 'static`...\n-   = note: ...so that the type `<I as Trait>::Item<'_>` will meet its required lifetime bounds\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0310`."}]}