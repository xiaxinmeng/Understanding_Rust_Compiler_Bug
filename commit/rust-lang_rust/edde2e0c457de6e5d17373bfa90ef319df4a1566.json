{"sha": "edde2e0c457de6e5d17373bfa90ef319df4a1566", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkZGUyZTBjNDU3ZGU2ZTVkMTczNzNiZmE5MGVmMzE5ZGY0YTE1NjY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-12T12:43:41Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-12T12:43:41Z"}, "message": "Undo some pretty-printer damage in ty.rs", "tree": {"sha": "7a82ff51271b5056efdda8479e203d971096f5dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a82ff51271b5056efdda8479e203d971096f5dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edde2e0c457de6e5d17373bfa90ef319df4a1566", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edde2e0c457de6e5d17373bfa90ef319df4a1566", "html_url": "https://github.com/rust-lang/rust/commit/edde2e0c457de6e5d17373bfa90ef319df4a1566", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edde2e0c457de6e5d17373bfa90ef319df4a1566/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "982a1a47830ae0419db620374ffe2f0e018843cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/982a1a47830ae0419db620374ffe2f0e018843cf", "html_url": "https://github.com/rust-lang/rust/commit/982a1a47830ae0419db620374ffe2f0e018843cf"}], "stats": {"total": 160, "additions": 26, "deletions": 134}, "files": [{"sha": "80095bdd452c7ab76fb0e49505ea324ca04389f0", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 26, "deletions": 134, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/edde2e0c457de6e5d17373bfa90ef319df4a1566/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edde2e0c457de6e5d17373bfa90ef319df4a1566/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=edde2e0c457de6e5d17373bfa90ef319df4a1566", "patch": "@@ -972,40 +972,20 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n     cx.kind_cache.insert(ty, result);\n \n     alt struct(cx, ty) {\n-\n-\n-\n-\n-\n       // Scalar types are unique-kind, no substructure.\n       ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_uint. | ty_float. |\n       ty_machine(_) | ty_char. | ty_native(_) {\n         // no-op\n       }\n-\n-\n-\n-\n-\n       // A handful of other built-in are unique too.\n       ty_type. | ty_str. | ty_native_fn(_, _, _) {\n         // no-op\n       }\n-\n-\n-\n-\n-\n       // FIXME: obj is broken for now, since we aren't asserting\n       // anything about its fields.\n       ty_obj(_) {\n         result = kind_shared;\n       }\n-\n-\n-\n-\n-\n       // FIXME: the environment capture mode is not fully encoded\n       // here yet, leading to weirdness around closure.\n       ty_fn(proto, _, _, _, _) {\n@@ -1016,56 +996,32 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n               _ { ast::kind_unique }\n             }\n       }\n-\n-\n-\n-\n-\n       // Those with refcounts-to-inner raise pinned to shared,\n       // lower unique to shared. Therefore just set result to shared.\n       ty_box(mt) {\n         result = ast::kind_shared;\n       }\n-\n-\n-\n-\n-\n       // Pointers and unique boxes / vecs raise pinned to shared,\n       // otherwise pass through their pointee kind.\n       ty_ptr(tm) | ty_vec(tm) {\n         let k = type_kind(cx, tm.ty);\n         if k == ast::kind_pinned { k = ast::kind_shared }\n         result = kind::lower_kind(result, k);\n       }\n-\n-\n-\n-\n-\n       // Records lower to the lowest of their members.\n       ty_rec(flds) {\n         for f: field in flds {\n             result = kind::lower_kind(result, type_kind(cx, f.mt.ty));\n             if result == ast::kind_pinned { break; }\n         }\n       }\n-\n-\n-\n-\n       // Tuples lower to the lowest of their members.\n       ty_tup(tys) {\n         for ty: t in tys {\n             result = kind::lower_kind(result, type_kind(cx, ty));\n             if result == ast::kind_pinned { break; }\n         }\n       }\n-\n-\n-\n-\n-\n       // Tags lower to the lowest of their variants.\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n@@ -1079,50 +1035,24 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n             if result == ast::kind_pinned { break; }\n         }\n       }\n-\n-\n-\n-\n-\n       // Resources are always pinned.\n       ty_res(did, inner, tps) {\n         result = ast::kind_pinned;\n       }\n-\n-\n-\n-\n-\n       ty_var(_) {\n         fail;\n       }\n-\n-\n-\n-\n-\n       ty_param(_, k) {\n         result = kind::lower_kind(result, k);\n       }\n-\n-\n-\n-\n-\n       ty_constr(t, _) {\n         result = type_kind(cx, t);\n       }\n-\n-\n-\n-\n-\n       _ {\n         cx.sess.bug(\"missed case: \" + ty_to_str(cx, ty));\n       }\n     }\n \n-\n     cx.kind_cache.insert(ty, result);\n     ret result;\n }\n@@ -1193,37 +1123,35 @@ pure fn type_has_dynamic_size(cx: ctxt, ty: t) -> bool {\n // the value itself. I.e. types with mutable content that's not shared through\n // a pointer.\n fn type_allows_implicit_copy(cx: ctxt, ty: t) -> bool {\n-    ret !type_structurally_contains(cx, ty,\n-                                    fn (sty: sty) -> bool {\n-                                        ret alt sty {\n-                                              ty_param(_, _) { true }\n-                                              ty_vec(mt) {\n-                                                mt.mut != ast::imm\n-                                              }\n-                                              ty_rec(fields) {\n-                                                for field in fields {\n-                                                    if field.mt.mut !=\n-                                                           ast::imm {\n-                                                        ret true;\n-                                                    }\n-                                                }\n-                                                false\n-                                              }\n-                                              _ { false }\n-                                            };\n-                                    });\n+    ret !type_structurally_contains(cx, ty, fn (sty: sty) -> bool {\n+        ret alt sty {\n+          ty_param(_, _) { true }\n+          ty_vec(mt) {\n+            mt.mut != ast::imm\n+          }\n+          ty_rec(fields) {\n+            for field in fields {\n+                if field.mt.mut !=\n+                    ast::imm {\n+                    ret true;\n+                }\n+            }\n+            false\n+          }\n+          _ { false }\n+        };\n+    });\n }\n \n fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n-    ret type_structurally_contains(cx, ty,\n-                                   fn (sty: sty) -> bool {\n-                                       ret alt sty {\n-                                             ty_uniq(_) { ret true; }\n-                                             ty_vec(_) { true }\n-                                             ty_str. { true }\n-                                             _ { ret false; }\n-                                           };\n-                                   });\n+    ret type_structurally_contains(cx, ty, fn (sty: sty) -> bool {\n+        ret alt sty {\n+          ty_uniq(_) { ret true; }\n+          ty_vec(_) { true }\n+          ty_str. { true }\n+          _ { ret false; }\n+        };\n+    });\n }\n \n fn type_is_integral(cx: ctxt, ty: t) -> bool {\n@@ -1283,30 +1211,16 @@ fn type_is_signed(cx: ctxt, ty: t) -> bool {\n fn type_is_pod(cx: ctxt, ty: t) -> bool {\n     let result = true;\n     alt struct(cx, ty) {\n-\n-\n-\n-\n       // Scalar types\n       ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_float. | ty_uint. |\n       ty_machine(_) | ty_char. | ty_type. | ty_native(_) | ty_ptr(_) {\n         result = true;\n       }\n-\n-\n-\n-\n-\n       // Boxed types\n       ty_str. | ty_box(_) | ty_vec(_) | ty_fn(_, _, _, _, _) |\n       ty_native_fn(_, _, _) | ty_obj(_) {\n         result = false;\n       }\n-\n-\n-\n-\n-\n       // Structural types\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n@@ -1330,11 +1244,6 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n         result = type_is_pod(cx, substitute_type_params(cx, tps, inner));\n       }\n       ty_constr(subt, _) { result = type_is_pod(cx, subt); }\n-\n-\n-\n-\n-\n       ty_var(_) {\n         fail \"ty_var in type_is_pod\";\n       }\n@@ -1428,7 +1337,6 @@ fn hash_type_structure(st: sty) -> uint {\n         ret h;\n     }\n \n-\n     fn hash_fn(id: uint, args: [arg], rty: t) -> uint {\n         let h = id;\n         for a: arg in args { h += h << 5u + hash_ty(a.ty); }\n@@ -1475,10 +1383,6 @@ fn hash_type_structure(st: sty) -> uint {\n         ret h;\n       }\n \n-\n-\n-\n-\n       // ???\n       ty_fn(_, args, rty, _, _) {\n         ret hash_fn(27u, args, rty);\n@@ -2153,11 +2057,6 @@ mod unify {\n         // variable.\n \n         alt struct(cx.tcx, actual) {\n-\n-\n-\n-\n-\n           // If the RHS is a variable type, then just do the\n           // appropriate binding.\n           ty::ty_var(actual_id) {\n@@ -2171,8 +2070,6 @@ mod unify {\n                 }\n               }\n               _ {\n-\n-\n                 // Just bind the type variable to the expected type.\n                 alt record_var_binding(cx, actual_id, expected) {\n                   ures_ok(_) {/* fall through */ }\n@@ -2204,11 +2101,6 @@ mod unify {\n         }\n         alt struct(cx.tcx, expected) {\n           ty::ty_nil. { ret struct_cmp(cx, expected, actual); }\n-\n-\n-\n-\n-\n           // _|_ unifies with anything\n           ty::ty_bot. {\n             ret ures_ok(actual);"}]}