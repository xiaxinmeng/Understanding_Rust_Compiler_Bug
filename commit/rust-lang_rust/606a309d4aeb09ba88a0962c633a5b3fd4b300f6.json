{"sha": "606a309d4aeb09ba88a0962c633a5b3fd4b300f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwNmEzMDlkNGFlYjA5YmE4OGEwOTYyYzYzM2E1YjNmZDRiMzAwZjY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-11-19T09:22:54Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-11-19T13:02:42Z"}, "message": "Switch numeric suffix parsing to use the new system.\n\nThis moves errors and all handling of numeric suffixes into the parser\nrather than the lexer.", "tree": {"sha": "208fe1e045a2c0a1bd50df361739b5524737eb6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/208fe1e045a2c0a1bd50df361739b5524737eb6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/606a309d4aeb09ba88a0962c633a5b3fd4b300f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/606a309d4aeb09ba88a0962c633a5b3fd4b300f6", "html_url": "https://github.com/rust-lang/rust/commit/606a309d4aeb09ba88a0962c633a5b3fd4b300f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/606a309d4aeb09ba88a0962c633a5b3fd4b300f6/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6679595853705ca11f64984a055be60233321a4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6679595853705ca11f64984a055be60233321a4a", "html_url": "https://github.com/rust-lang/rust/commit/6679595853705ca11f64984a055be60233321a4a"}], "stats": {"total": 257, "additions": 108, "deletions": 149}, "files": [{"sha": "fbca4868255ff92353af1b88584ea3bd4d4f0eb9", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 4, "deletions": 70, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/606a309d4aeb09ba88a0962c633a5b3fd4b300f6/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606a309d4aeb09ba88a0962c633a5b3fd4b300f6/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=606a309d4aeb09ba88a0962c633a5b3fd4b300f6", "patch": "@@ -672,16 +672,6 @@ impl<'a> StringReader<'a> {\n                 '0'...'9' | '_' | '.' => {\n                     num_digits = self.scan_digits(10) + 1;\n                 }\n-                'u' | 'i' => {\n-                    self.scan_int_suffix();\n-                    return token::Integer(self.name_from(start_bpos));\n-                },\n-                'f' => {\n-                    let last_pos = self.last_pos;\n-                    self.scan_float_suffix();\n-                    self.check_float_base(start_bpos, last_pos, base);\n-                    return token::Float(self.name_from(start_bpos));\n-                }\n                 _ => {\n                     // just a 0\n                     return token::Integer(self.name_from(start_bpos));\n@@ -695,8 +685,6 @@ impl<'a> StringReader<'a> {\n \n         if num_digits == 0 {\n             self.err_span_(start_bpos, self.last_pos, \"no valid digits found for number\");\n-            // eat any suffix\n-            self.scan_int_suffix();\n             return token::Integer(token::intern(\"0\"));\n         }\n \n@@ -711,28 +699,19 @@ impl<'a> StringReader<'a> {\n             if self.curr.unwrap_or('\\0').is_digit_radix(10) {\n                 self.scan_digits(10);\n                 self.scan_float_exponent();\n-                self.scan_float_suffix();\n             }\n             let last_pos = self.last_pos;\n             self.check_float_base(start_bpos, last_pos, base);\n             return token::Float(self.name_from(start_bpos));\n-        } else if self.curr_is('f') {\n-            // or it might be an integer literal suffixed as a float\n-            self.scan_float_suffix();\n-            let last_pos = self.last_pos;\n-            self.check_float_base(start_bpos, last_pos, base);\n-            return token::Float(self.name_from(start_bpos));\n         } else {\n             // it might be a float if it has an exponent\n             if self.curr_is('e') || self.curr_is('E') {\n                 self.scan_float_exponent();\n-                self.scan_float_suffix();\n                 let last_pos = self.last_pos;\n                 self.check_float_base(start_bpos, last_pos, base);\n                 return token::Float(self.name_from(start_bpos));\n             }\n             // but we certainly have an integer!\n-            self.scan_int_suffix();\n             return token::Integer(self.name_from(start_bpos));\n         }\n     }\n@@ -869,55 +848,6 @@ impl<'a> StringReader<'a> {\n         true\n     }\n \n-    /// Scan over an int literal suffix.\n-    fn scan_int_suffix(&mut self) {\n-        match self.curr {\n-            Some('i') | Some('u') => {\n-                self.bump();\n-\n-                if self.curr_is('8') {\n-                    self.bump();\n-                } else if self.curr_is('1') {\n-                    if !self.nextch_is('6') {\n-                        self.err_span_(self.last_pos, self.pos,\n-                                      \"illegal int suffix\");\n-                    } else {\n-                        self.bump(); self.bump();\n-                    }\n-                } else if self.curr_is('3') {\n-                    if !self.nextch_is('2') {\n-                        self.err_span_(self.last_pos, self.pos,\n-                                      \"illegal int suffix\");\n-                    } else {\n-                        self.bump(); self.bump();\n-                    }\n-                } else if self.curr_is('6') {\n-                    if !self.nextch_is('4') {\n-                        self.err_span_(self.last_pos, self.pos,\n-                                      \"illegal int suffix\");\n-                    } else {\n-                        self.bump(); self.bump();\n-                    }\n-                }\n-            },\n-            _ => { }\n-        }\n-    }\n-\n-    /// Scan over a float literal suffix\n-    fn scan_float_suffix(&mut self) {\n-        if self.curr_is('f') {\n-            if (self.nextch_is('3') && self.nextnextch_is('2'))\n-            || (self.nextch_is('6') && self.nextnextch_is('4')) {\n-                self.bump();\n-                self.bump();\n-                self.bump();\n-            } else {\n-                self.err_span_(self.last_pos, self.pos, \"illegal float suffix\");\n-            }\n-        }\n-    }\n-\n     /// Scan over a float exponent.\n     fn scan_float_exponent(&mut self) {\n         if self.curr_is('e') || self.curr_is('E') {\n@@ -988,6 +918,7 @@ impl<'a> StringReader<'a> {\n         if is_dec_digit(c) {\n             let num = self.scan_number(c.unwrap());\n             let suffix = self.scan_optional_raw_name();\n+            debug!(\"next_token_inner: scanned number {}, {}\", num, suffix);\n             return token::Literal(num, suffix)\n         }\n \n@@ -1609,6 +1540,9 @@ mod test {\n         test!(\"1.0\", Float, \"1.0\");\n         test!(\"1.0e10\", Float, \"1.0e10\");\n \n+        assert_eq!(setup(&mk_sh(), \"2u\".to_string()).next_token().tok,\n+                   token::Literal(token::Integer(token::intern(\"2\")),\n+                                  Some(token::intern(\"u\"))));\n         assert_eq!(setup(&mk_sh(), \"r###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n                    token::Literal(token::StrRaw(token::intern(\"raw\"), 3),\n                                   Some(token::intern(\"suffix\"))));"}, {"sha": "d111108269dfea89728faba557fb413b9d49e52f", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 76, "deletions": 69, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/606a309d4aeb09ba88a0962c633a5b3fd4b300f6/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606a309d4aeb09ba88a0962c633a5b3fd4b300f6/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=606a309d4aeb09ba88a0962c633a5b3fd4b300f6", "patch": "@@ -511,28 +511,41 @@ pub fn raw_str_lit(lit: &str) -> String {\n     res\n }\n \n-pub fn float_lit(s: &str) -> ast::Lit_ {\n-    debug!(\"float_lit: {}\", s);\n-    // FIXME #2252: bounds checking float literals is defered until trans\n-    let s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n-    let s = s2.as_slice();\n-\n-    let mut ty = None;\n-\n-    if s.ends_with(\"f32\") {\n-        ty = Some(ast::TyF32);\n-    } else if s.ends_with(\"f64\") {\n-        ty = Some(ast::TyF64);\n-    }\n+// check if `s` looks like i32 or u1234 etc.\n+fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n+    s.len() > 1 &&\n+        first_chars.contains(&s.char_at(0)) &&\n+        s.slice_from(1).chars().all(|c| '0' <= c && c <= '9')\n+}\n \n+fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n+                      sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n+    debug!(\"filtered_float_lit: {}, {}\", data, suffix);\n+    match suffix {\n+        Some(\"f32\") => ast::LitFloat(data, ast::TyF32),\n+        Some(\"f64\") => ast::LitFloat(data, ast::TyF64),\n+        Some(suf) => {\n+            if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n+                // if it looks like a width, lets try to be helpful.\n+                sd.span_err(sp, &*format!(\"illegal width `{}` for float literal, \\\n+                                          valid widths are 32 and 64\", suf.slice_from(1)));\n+            } else {\n+                sd.span_err(sp, &*format!(\"illegal suffix `{}` for float literal, \\\n+                                          valid suffixes are `f32` and `f64`\", suf));\n+            }\n \n-    match ty {\n-        Some(t) => {\n-            ast::LitFloat(token::intern_and_get_ident(s.slice_to(s.len() - t.suffix_len())), t)\n-        },\n-        None => ast::LitFloatUnsuffixed(token::intern_and_get_ident(s))\n+            ast::LitFloatUnsuffixed(data)\n+        }\n+        None => ast::LitFloatUnsuffixed(data)\n     }\n }\n+pub fn float_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n+    debug!(\"float_lit: {}, {}\", s, suffix);\n+    // FIXME #2252: bounds checking float literals is defered until trans\n+    let s = s.chars().filter(|&c| c != '_').collect::<String>();\n+    let data = token::intern_and_get_ident(&*s);\n+    filtered_float_lit(data, suffix, sd, sp)\n+}\n \n /// Parse a string representing a byte literal into its final form. Similar to `char_lit`\n pub fn byte_lit(lit: &str) -> (u8, uint) {\n@@ -626,24 +639,19 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n     Rc::new(res)\n }\n \n-pub fn integer_lit(s: &str, sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n+pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n     // s can only be ascii, byte indexing is fine\n \n     let s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n     let mut s = s2.as_slice();\n \n-    debug!(\"parse_integer_lit: {}\", s);\n-\n-    if s.len() == 1 {\n-        let n = (s.char_at(0)).to_digit(10).unwrap();\n-        return ast::LitInt(n as u64, ast::UnsuffixedIntLit(ast::Sign::new(n)));\n-    }\n+    debug!(\"integer_lit: {}, {}\", s, suffix);\n \n     let mut base = 10;\n     let orig = s;\n     let mut ty = ast::UnsuffixedIntLit(ast::Plus);\n \n-    if s.char_at(0) == '0' {\n+    if s.char_at(0) == '0' && s.len() > 1 {\n         match s.char_at(1) {\n             'x' => base = 16,\n             'o' => base = 8,\n@@ -652,57 +660,56 @@ pub fn integer_lit(s: &str, sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n         }\n     }\n \n+    // 1f64 and 2f32 etc. are valid float literals.\n+    match suffix {\n+        Some(suf) if looks_like_width_suffix(&['f'], suf) => {\n+            match base {\n+                16u => sd.span_err(sp, \"hexadecimal float literal is not supported\"),\n+                8u => sd.span_err(sp, \"octal float literal is not supported\"),\n+                2u => sd.span_err(sp, \"binary float literal is not supported\"),\n+                _ => ()\n+            }\n+            let ident = token::intern_and_get_ident(&*s);\n+            return filtered_float_lit(ident, suffix, sd, sp)\n+        }\n+        _ => {}\n+    }\n+\n     if base != 10 {\n         s = s.slice_from(2);\n     }\n \n-    let last = s.len() - 1;\n-    match s.char_at(last) {\n-        'i' => ty = ast::SignedIntLit(ast::TyI, ast::Plus),\n-        'u' => ty = ast::UnsignedIntLit(ast::TyU),\n-        '8' => {\n-            if s.len() > 2 {\n-                match s.char_at(last - 1) {\n-                    'i' => ty = ast::SignedIntLit(ast::TyI8, ast::Plus),\n-                    'u' => ty = ast::UnsignedIntLit(ast::TyU8),\n-                    _ => { }\n-                }\n-            }\n-        },\n-        '6' => {\n-            if s.len() > 3 && s.char_at(last - 1) == '1' {\n-                match s.char_at(last - 2) {\n-                    'i' => ty = ast::SignedIntLit(ast::TyI16, ast::Plus),\n-                    'u' => ty = ast::UnsignedIntLit(ast::TyU16),\n-                    _ => { }\n-                }\n-            }\n-        },\n-        '2' => {\n-            if s.len() > 3 && s.char_at(last - 1) == '3' {\n-                match s.char_at(last - 2) {\n-                    'i' => ty = ast::SignedIntLit(ast::TyI32, ast::Plus),\n-                    'u' => ty = ast::UnsignedIntLit(ast::TyU32),\n-                    _ => { }\n-                }\n-            }\n-        },\n-        '4' => {\n-            if s.len() > 3 && s.char_at(last - 1) == '6' {\n-                match s.char_at(last - 2) {\n-                    'i' => ty = ast::SignedIntLit(ast::TyI64, ast::Plus),\n-                    'u' => ty = ast::UnsignedIntLit(ast::TyU64),\n-                    _ => { }\n+    if let Some(suf) = suffix {\n+        if suf.is_empty() { sd.span_bug(sp, \"found empty literal suffix in Some\")}\n+        ty = match suf {\n+            \"i\"   => ast::SignedIntLit(ast::TyI, ast::Plus),\n+            \"i8\"  => ast::SignedIntLit(ast::TyI8, ast::Plus),\n+            \"i16\" => ast::SignedIntLit(ast::TyI16, ast::Plus),\n+            \"i32\" => ast::SignedIntLit(ast::TyI32, ast::Plus),\n+            \"i64\" => ast::SignedIntLit(ast::TyI64, ast::Plus),\n+            \"u\"   => ast::UnsignedIntLit(ast::TyU),\n+            \"u8\"  => ast::UnsignedIntLit(ast::TyU8),\n+            \"u16\" => ast::UnsignedIntLit(ast::TyU16),\n+            \"u32\" => ast::UnsignedIntLit(ast::TyU32),\n+            \"u64\" => ast::UnsignedIntLit(ast::TyU64),\n+            _ => {\n+                // i<digits> and u<digits> look like widths, so lets\n+                // give an error message along those lines\n+                if looks_like_width_suffix(&['i', 'u'], suf) {\n+                    sd.span_err(sp, &*format!(\"illegal width `{}` for integer literal; \\\n+                                              valid widths are 8, 16, 32 and 64\",\n+                                              suf.slice_from(1)));\n+                } else {\n+                    sd.span_err(sp, &*format!(\"illegal suffix `{}` for numeric literal\", suf));\n                 }\n+\n+                ty\n             }\n-        },\n-        _ => { }\n+        }\n     }\n \n-    debug!(\"The suffix is {}, base {}, the new string is {}, the original \\\n-           string was {}\", ty, base, s, orig);\n-\n-    s = s.slice_to(s.len() - ty.suffix_len());\n+    debug!(\"integer_lit: the type is {}, base {}, the new string is {}, the original \\\n+           string was {}, the original suffix was {}\", ty, base, s, orig, suffix);\n \n     let res: u64 = match ::std::num::from_str_radix(s, base) {\n         Some(r) => r,"}, {"sha": "85364b8f65ffa4164cda080be0c8aab386d03bd8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/606a309d4aeb09ba88a0962c633a5b3fd4b300f6/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606a309d4aeb09ba88a0962c633a5b3fd4b300f6/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=606a309d4aeb09ba88a0962c633a5b3fd4b300f6", "patch": "@@ -652,9 +652,9 @@ impl<'a> Parser<'a> {\n             Some(suf) => {\n                 let text = suf.as_str();\n                 if text.is_empty() {\n-                    self.span_bug(sp, \"found empty non-None literal suffix\")\n+                    self.span_bug(sp, \"found empty literal suffix in Some\")\n                 }\n-                self.span_err(sp, &*format!(\"a {} with a suffix is illegal\", kind));\n+                self.span_err(sp, &*format!(\"{} with a suffix is illegal\", kind));\n             }\n         }\n     }\n@@ -1661,10 +1661,23 @@ impl<'a> Parser<'a> {\n                 let (suffix_illegal, out) = match lit {\n                     token::Byte(i) => (true, LitByte(parse::byte_lit(i.as_str()).val0())),\n                     token::Char(i) => (true, LitChar(parse::char_lit(i.as_str()).val0())),\n-                    token::Integer(s) => (false, parse::integer_lit(s.as_str(),\n-                                                            &self.sess.span_diagnostic,\n-                                                            self.last_span)),\n-                    token::Float(s) => (false, parse::float_lit(s.as_str())),\n+\n+                    // there are some valid suffixes for integer and\n+                    // float literals, so all the handling is done\n+                    // internally.\n+                    token::Integer(s) => {\n+                        (false, parse::integer_lit(s.as_str(),\n+                                                   suf.as_ref().map(|s| s.as_str()),\n+                                                   &self.sess.span_diagnostic,\n+                                                   self.last_span))\n+                    }\n+                    token::Float(s) => {\n+                        (false, parse::float_lit(s.as_str(),\n+                                                 suf.as_ref().map(|s| s.as_str()),\n+                                                  &self.sess.span_diagnostic,\n+                                                 self.last_span))\n+                    }\n+\n                     token::Str_(s) => {\n                         (true,\n                          LitStr(token::intern_and_get_ident(parse::str_lit(s.as_str()).as_slice()),"}, {"sha": "e142365a8ca078014f720c454d6c3d242682a5f7", "filename": "src/test/compile-fail/bad-lit-suffixes.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/606a309d4aeb09ba88a0962c633a5b3fd4b300f6/src%2Ftest%2Fcompile-fail%2Fbad-lit-suffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606a309d4aeb09ba88a0962c633a5b3fd4b300f6/src%2Ftest%2Fcompile-fail%2Fbad-lit-suffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-lit-suffixes.rs?ref=606a309d4aeb09ba88a0962c633a5b3fd4b300f6", "patch": "@@ -29,8 +29,13 @@ fn main() {\n     'a'suffix; //~ ERROR char literal with a suffix is illegal\n     b'a'suffix; //~ ERROR byte literal with a suffix is illegal\n \n-    1234suffix;\n-    0b101suffix;\n-    1.0suffix;\n-    1.0e10suffix;\n+    1234u1024; //~ ERROR illegal width `1024` for integer literal\n+    1234i1024; //~ ERROR illegal width `1024` for integer literal\n+    1234f1024; //~ ERROR illegal width `1024` for float literal\n+    1234.5f1024; //~ ERROR illegal width `1024` for float literal\n+\n+    1234suffix; //~ ERROR illegal suffix `suffix` for numeric literal\n+    0b101suffix; //~ ERROR illegal suffix `suffix` for numeric literal\n+    1.0suffix; //~ ERROR illegal suffix `suffix` for numeric literal\n+    1.0e10suffix; //~ ERROR illegal suffix `suffix` for numeric literal\n }"}]}