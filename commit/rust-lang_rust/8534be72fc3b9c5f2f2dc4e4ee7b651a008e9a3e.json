{"sha": "8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1MzRiZTcyZmMzYjljNWYyZjJkYzRlNGVlN2I2NTFhMDA4ZTlhM2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-17T00:09:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-17T00:09:49Z"}, "message": "Auto merge of #74422 - Manishearth:rollup-7mfrf6g, r=Manishearth\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #73101 (Resolve items for cross-crate imports relative to the original module)\n - #73269 (Enable some timeouts in SGX platform)\n - #74033 (Add build support for Cargo's build-std feature.)\n - #74351 (Do not render unstable items for rustc doc)\n - #74357 (Some `Symbol` related improvements)\n - #74371 (Improve ayu rustdoc theme)\n - #74386 (Add RISC-V GNU/Linux to src/tools/build-manifest as a host platform)\n - #74398 (Clean up E0723 explanation)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "9b6f6432be9c4a78fd4677f7a3125f3eb93e1a0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b6f6432be9c4a78fd4677f7a3125f3eb93e1a0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "html_url": "https://github.com/rust-lang/rust/commit/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c9e5df3a097e094641f16dab501ab1c4da10e9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c9e5df3a097e094641f16dab501ab1c4da10e9f", "html_url": "https://github.com/rust-lang/rust/commit/5c9e5df3a097e094641f16dab501ab1c4da10e9f"}, {"sha": "5bb9bef79577b9629b12800dcdae1d8fd52998c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bb9bef79577b9629b12800dcdae1d8fd52998c0", "html_url": "https://github.com/rust-lang/rust/commit/5bb9bef79577b9629b12800dcdae1d8fd52998c0"}], "stats": {"total": 2114, "additions": 1312, "deletions": 802}, "files": [{"sha": "28ff6b3b1ebf29a7c3b9c51d70fc920e6299b660", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -2056,6 +2056,7 @@ dependencies = [\n name = \"panic_abort\"\n version = \"0.0.0\"\n dependencies = [\n+ \"cfg-if\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -4552,6 +4553,7 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n+ \"cfg-if\",\n  \"core\",\n  \"getopts\",\n  \"libc\","}, {"sha": "dc385022440e04da18fa35401831f8cbf94fdf1a", "filename": "src/libpanic_abort/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibpanic_abort%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibpanic_abort%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2FCargo.toml?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -11,6 +11,7 @@ bench = false\n doc = false\n \n [dependencies]\n+cfg-if = { version = \"0.1.8\", features = ['rustc-dep-of-std'] }\n core = { path = \"../libcore\" }\n libc = { version = \"0.2\", default-features = false }\n compiler_builtins = \"0.1.0\""}, {"sha": "95f3966228a2fdfff744e8edb07792e991aa82e4", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -40,23 +40,26 @@ pub unsafe extern \"C\" fn __rust_panic_cleanup(_: *mut u8) -> *mut (dyn Any + Sen\n pub unsafe extern \"C\" fn __rust_start_panic(_payload: usize) -> u32 {\n     abort();\n \n-    #[cfg(any(unix, target_os = \"cloudabi\"))]\n-    unsafe fn abort() -> ! {\n-        libc::abort();\n-    }\n-\n-    #[cfg(any(windows, all(target_arch = \"wasm32\", not(target_os = \"emscripten\"))))]\n-    unsafe fn abort() -> ! {\n-        core::intrinsics::abort();\n-    }\n-\n-    #[cfg(any(target_os = \"hermit\", all(target_vendor = \"fortanix\", target_env = \"sgx\")))]\n-    unsafe fn abort() -> ! {\n-        // call std::sys::abort_internal\n-        extern \"C\" {\n-            pub fn __rust_abort() -> !;\n+    cfg_if::cfg_if! {\n+        if #[cfg(any(unix, target_os = \"cloudabi\"))] {\n+            unsafe fn abort() -> ! {\n+                libc::abort();\n+            }\n+        } else if #[cfg(any(target_os = \"hermit\",\n+                            all(target_vendor = \"fortanix\", target_env = \"sgx\")\n+        ))] {\n+            unsafe fn abort() -> ! {\n+                // call std::sys::abort_internal\n+                extern \"C\" {\n+                    pub fn __rust_abort() -> !;\n+                }\n+                __rust_abort();\n+            }\n+        } else {\n+            unsafe fn abort() -> ! {\n+                core::intrinsics::abort();\n+            }\n         }\n-        __rust_abort();\n     }\n }\n "}, {"sha": "430062d4ac44eb7ec576c0b1fc51d8d70b723c5f", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -41,21 +41,33 @@ cfg_if::cfg_if! {\n     if #[cfg(target_os = \"emscripten\")] {\n         #[path = \"emcc.rs\"]\n         mod real_imp;\n-    } else if #[cfg(target_arch = \"wasm32\")] {\n-        #[path = \"dummy.rs\"]\n-        mod real_imp;\n     } else if #[cfg(target_os = \"hermit\")] {\n         #[path = \"hermit.rs\"]\n         mod real_imp;\n     } else if #[cfg(target_env = \"msvc\")] {\n         #[path = \"seh.rs\"]\n         mod real_imp;\n-    } else {\n+    } else if #[cfg(any(\n+        all(target_family = \"windows\", target_env = \"gnu\"),\n+        target_os = \"cloudabi\",\n+        target_family = \"unix\",\n+        all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n+    ))] {\n         // Rust runtime's startup objects depend on these symbols, so make them public.\n         #[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n         pub use real_imp::eh_frame_registry::*;\n         #[path = \"gcc.rs\"]\n         mod real_imp;\n+    } else {\n+        // Targets that don't support unwinding.\n+        // - arch=wasm32\n+        // - os=none (\"bare metal\" targets)\n+        // - os=uefi\n+        // - nvptx64-nvidia-cuda\n+        // - avr-unknown-unknown\n+        // - mipsel-sony-psp\n+        #[path = \"dummy.rs\"]\n+        mod real_imp;\n     }\n }\n "}, {"sha": "f960bdecc579f642f0c1489e0eb94ae4eb8703c8", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -26,6 +26,7 @@\n #![feature(in_band_lifetimes)]\n #![feature(negative_impls)]\n #![feature(optin_builtin_traits)]\n+#![feature(restricted_std)]\n #![feature(rustc_attrs)]\n #![feature(min_specialization)]\n #![recursion_limit = \"256\"]"}, {"sha": "cef0da60a61c8c642693d930fc9079d9d9089e88", "filename": "src/librustc_builtin_macros/deriving/bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fbounds.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -16,9 +16,9 @@ pub fn expand_deriving_copy(\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: path_std!(cx, marker::Copy),\n+        path: path_std!(marker::Copy),\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: true,\n         methods: Vec::new(),"}, {"sha": "b307ee26c91d518e513cc31379a77f69698e2573", "filename": "src/librustc_builtin_macros/deriving/clone.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fclone.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -56,7 +56,7 @@ pub fn expand_deriving_clone(\n                 }\n             }\n             ItemKind::Union(..) => {\n-                bounds = vec![Literal(path_std!(cx, marker::Copy))];\n+                bounds = vec![Literal(path_std!(marker::Copy))];\n                 is_shallow = true;\n                 substructure = combine_substructure(Box::new(|c, s, sub| {\n                     cs_clone_shallow(\"Clone\", c, s, sub, true)\n@@ -78,14 +78,14 @@ pub fn expand_deriving_clone(\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: path_std!(cx, clone::Clone),\n+        path: path_std!(clone::Clone),\n         additional_bounds: bounds,\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: true,\n         methods: vec![MethodDef {\n             name: sym::clone,\n-            generics: LifetimeBounds::empty(),\n+            generics: Bounds::empty(),\n             explicit_self: borrowed_explicit_self(),\n             args: Vec::new(),\n             ret_ty: Self_,"}, {"sha": "d1b799cd6a112d841614ccba3f1d9731f70b76ef", "filename": "src/librustc_builtin_macros/deriving/cmp/eq.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Feq.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -22,14 +22,14 @@ pub fn expand_deriving_eq(\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: path_std!(cx, cmp::Eq),\n+        path: path_std!(cmp::Eq),\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: true,\n         methods: vec![MethodDef {\n             name: sym::assert_receiver_is_total_eq,\n-            generics: LifetimeBounds::empty(),\n+            generics: Bounds::empty(),\n             explicit_self: borrowed_explicit_self(),\n             args: vec![],\n             ret_ty: nil_ty(),\n@@ -43,13 +43,7 @@ pub fn expand_deriving_eq(\n         associated_types: Vec::new(),\n     };\n \n-    super::inject_impl_of_structural_trait(\n-        cx,\n-        span,\n-        item,\n-        path_std!(cx, marker::StructuralEq),\n-        push,\n-    );\n+    super::inject_impl_of_structural_trait(cx, span, item, path_std!(marker::StructuralEq), push);\n \n     trait_def.expand_ext(cx, mitem, item, push, true)\n }"}, {"sha": "3bf3860d32307d52c3f53d07fccf571f58ddf346", "filename": "src/librustc_builtin_macros/deriving/cmp/ord.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Ford.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -20,17 +20,17 @@ pub fn expand_deriving_ord(\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: path_std!(cx, cmp::Ord),\n+        path: path_std!(cmp::Ord),\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::cmp,\n-            generics: LifetimeBounds::empty(),\n+            generics: Bounds::empty(),\n             explicit_self: borrowed_explicit_self(),\n-            args: vec![(borrowed_self(), \"other\")],\n-            ret_ty: Literal(path_std!(cx, cmp::Ordering)),\n+            args: vec![(borrowed_self(), sym::other)],\n+            ret_ty: Literal(path_std!(cmp::Ordering)),\n             attributes: attrs,\n             is_unsafe: false,\n             unify_fieldless_variants: true,"}, {"sha": "d8edd641acd52dd945f038f942d2ce7ed61877d6", "filename": "src/librustc_builtin_macros/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -69,9 +69,9 @@ pub fn expand_deriving_partial_eq(\n             let attrs = vec![cx.attribute(inline)];\n             MethodDef {\n                 name: $name,\n-                generics: LifetimeBounds::empty(),\n+                generics: Bounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec![(borrowed_self(), \"other\")],\n+                args: vec![(borrowed_self(), sym::other)],\n                 ret_ty: Literal(path_local!(bool)),\n                 attributes: attrs,\n                 is_unsafe: false,\n@@ -85,7 +85,7 @@ pub fn expand_deriving_partial_eq(\n         cx,\n         span,\n         item,\n-        path_std!(cx, marker::StructuralPartialEq),\n+        path_std!(marker::StructuralPartialEq),\n         push,\n     );\n \n@@ -100,9 +100,9 @@ pub fn expand_deriving_partial_eq(\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: path_std!(cx, cmp::PartialEq),\n+        path: path_std!(cmp::PartialEq),\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: false,\n         methods,"}, {"sha": "39a747c856839455077a808c190eb83224299072", "filename": "src/librustc_builtin_macros/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -23,9 +23,9 @@ pub fn expand_deriving_partial_ord(\n             let attrs = vec![cx.attribute(inline)];\n             MethodDef {\n                 name: $name,\n-                generics: LifetimeBounds::empty(),\n+                generics: Bounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec![(borrowed_self(), \"other\")],\n+                args: vec![(borrowed_self(), sym::other)],\n                 ret_ty: Literal(path_local!(bool)),\n                 attributes: attrs,\n                 is_unsafe: false,\n@@ -37,9 +37,9 @@ pub fn expand_deriving_partial_ord(\n         }};\n     }\n \n-    let ordering_ty = Literal(path_std!(cx, cmp::Ordering));\n+    let ordering_ty = Literal(path_std!(cmp::Ordering));\n     let ret_ty = Literal(Path::new_(\n-        pathvec_std!(cx, option::Option),\n+        pathvec_std!(option::Option),\n         None,\n         vec![Box::new(ordering_ty)],\n         PathKind::Std,\n@@ -50,9 +50,9 @@ pub fn expand_deriving_partial_ord(\n \n     let partial_cmp_def = MethodDef {\n         name: sym::partial_cmp,\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         explicit_self: borrowed_explicit_self(),\n-        args: vec![(borrowed_self(), \"other\")],\n+        args: vec![(borrowed_self(), sym::other)],\n         ret_ty,\n         attributes: attrs,\n         is_unsafe: false,\n@@ -80,9 +80,9 @@ pub fn expand_deriving_partial_ord(\n     let trait_def = TraitDef {\n         span,\n         attributes: vec![],\n-        path: path_std!(cx, cmp::PartialOrd),\n+        path: path_std!(cmp::PartialOrd),\n         additional_bounds: vec![],\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: false,\n         methods,"}, {"sha": "76e21bc43c52d84ec614ded321737770031e515d", "filename": "src/librustc_builtin_macros/deriving/debug.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fdebug.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -18,22 +18,22 @@ pub fn expand_deriving_debug(\n ) {\n     // &mut ::std::fmt::Formatter\n     let fmtr =\n-        Ptr(Box::new(Literal(path_std!(cx, fmt::Formatter))), Borrowed(None, ast::Mutability::Mut));\n+        Ptr(Box::new(Literal(path_std!(fmt::Formatter))), Borrowed(None, ast::Mutability::Mut));\n \n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: path_std!(cx, fmt::Debug),\n+        path: path_std!(fmt::Debug),\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::fmt,\n-            generics: LifetimeBounds::empty(),\n+            generics: Bounds::empty(),\n             explicit_self: borrowed_explicit_self(),\n-            args: vec![(fmtr, \"f\")],\n-            ret_ty: Literal(path_std!(cx, fmt::Result)),\n+            args: vec![(fmtr, sym::f)],\n+            ret_ty: Literal(path_std!(fmt::Result)),\n             attributes: Vec::new(),\n             is_unsafe: false,\n             unify_fieldless_variants: false,\n@@ -62,7 +62,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     // We want to make sure we have the ctxt set so that we can use unstable methods\n     let span = cx.with_def_site_ctxt(span);\n     let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n-    let builder = cx.ident_of(\"debug_trait_builder\", span);\n+    let builder = Ident::new(sym::debug_trait_builder, span);\n     let builder_expr = cx.expr_ident(span, builder);\n \n     let fmt = substr.nonself_args[0].clone();\n@@ -71,7 +71,8 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     match vdata {\n         ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n             // tuple struct/\"normal\" variant\n-            let expr = cx.expr_method_call(span, fmt, cx.ident_of(\"debug_tuple\", span), vec![name]);\n+            let expr =\n+                cx.expr_method_call(span, fmt, Ident::new(sym::debug_tuple, span), vec![name]);\n             stmts.push(cx.stmt_let(span, true, builder, expr));\n \n             for field in fields {\n@@ -94,7 +95,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         ast::VariantData::Struct(..) => {\n             // normal struct/struct variant\n             let expr =\n-                cx.expr_method_call(span, fmt, cx.ident_of(\"debug_struct\", span), vec![name]);\n+                cx.expr_method_call(span, fmt, Ident::new(sym::debug_struct, span), vec![name]);\n             stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n \n             for field in fields {\n@@ -117,7 +118,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         }\n     }\n \n-    let expr = cx.expr_method_call(span, builder_expr, cx.ident_of(\"finish\", span), vec![]);\n+    let expr = cx.expr_method_call(span, builder_expr, Ident::new(sym::finish, span), vec![]);\n \n     stmts.push(cx.stmt_expr(expr));\n     let block = cx.block(span, stmts);"}, {"sha": "ce8c2dfe4d5a099ebc5890ab5b4ea9e40db82a4f", "filename": "src/librustc_builtin_macros/deriving/decodable.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fdecodable.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::ast;\n use rustc_ast::ast::{Expr, MetaItem, Mutability};\n use rustc_ast::ptr::P;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n pub fn expand_deriving_rustc_decodable(\n@@ -18,38 +18,37 @@ pub fn expand_deriving_rustc_decodable(\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    let krate = \"rustc_serialize\";\n-    let typaram = \"__D\";\n+    let krate = sym::rustc_serialize;\n+    let typaram = sym::__D;\n \n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: Path::new_(vec![krate, \"Decodable\"], None, vec![], PathKind::Global),\n+        path: Path::new_(vec![krate, sym::Decodable], None, vec![], PathKind::Global),\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::decode,\n-            generics: LifetimeBounds {\n-                lifetimes: Vec::new(),\n+            generics: Bounds {\n                 bounds: vec![(\n                     typaram,\n-                    vec![Path::new_(vec![krate, \"Decoder\"], None, vec![], PathKind::Global)],\n+                    vec![Path::new_(vec![krate, sym::Decoder], None, vec![], PathKind::Global)],\n                 )],\n             },\n             explicit_self: None,\n             args: vec![(\n                 Ptr(Box::new(Literal(Path::new_local(typaram))), Borrowed(None, Mutability::Mut)),\n-                \"d\",\n+                sym::d,\n             )],\n             ret_ty: Literal(Path::new_(\n-                pathvec_std!(cx, result::Result),\n+                pathvec_std!(result::Result),\n                 None,\n                 vec![\n                     Box::new(Self_),\n                     Box::new(Literal(Path::new_(\n-                        vec![typaram, \"Error\"],\n+                        vec![typaram, sym::Error],\n                         None,\n                         vec![],\n                         PathKind::Local,\n@@ -74,17 +73,17 @@ fn decodable_substructure(\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n     substr: &Substructure<'_>,\n-    krate: &str,\n+    krate: Symbol,\n ) -> P<Expr> {\n     let decoder = substr.nonself_args[0].clone();\n     let recurse = vec![\n-        cx.ident_of(krate, trait_span),\n-        cx.ident_of(\"Decodable\", trait_span),\n-        cx.ident_of(\"decode\", trait_span),\n+        Ident::new(krate, trait_span),\n+        Ident::new(sym::Decodable, trait_span),\n+        Ident::new(sym::decode, trait_span),\n     ];\n     let exprdecode = cx.expr_path(cx.path_global(trait_span, recurse));\n     // throw an underscore in front to suppress unused variable warnings\n-    let blkarg = cx.ident_of(\"_d\", trait_span);\n+    let blkarg = Ident::new(sym::_d, trait_span);\n     let blkdecoder = cx.expr_ident(trait_span, blkarg);\n \n     match *substr.fields {\n@@ -93,7 +92,7 @@ fn decodable_substructure(\n                 Unnamed(ref fields, _) => fields.len(),\n                 Named(ref fields) => fields.len(),\n             };\n-            let read_struct_field = cx.ident_of(\"read_struct_field\", trait_span);\n+            let read_struct_field = Ident::new(sym::read_struct_field, trait_span);\n \n             let path = cx.path_ident(trait_span, substr.type_ident);\n             let result =\n@@ -116,7 +115,7 @@ fn decodable_substructure(\n             cx.expr_method_call(\n                 trait_span,\n                 decoder,\n-                cx.ident_of(\"read_struct\", trait_span),\n+                Ident::new(sym::read_struct, trait_span),\n                 vec![\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.expr_usize(trait_span, nfields),\n@@ -125,11 +124,11 @@ fn decodable_substructure(\n             )\n         }\n         StaticEnum(_, ref fields) => {\n-            let variant = cx.ident_of(\"i\", trait_span);\n+            let variant = Ident::new(sym::i, trait_span);\n \n             let mut arms = Vec::with_capacity(fields.len() + 1);\n             let mut variants = Vec::with_capacity(fields.len());\n-            let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\", trait_span);\n+            let rvariant_arg = Ident::new(sym::read_enum_variant_arg, trait_span);\n \n             for (i, &(ident, v_span, ref parts)) in fields.iter().enumerate() {\n                 variants.push(cx.expr_str(v_span, ident.name));\n@@ -164,13 +163,13 @@ fn decodable_substructure(\n             let result = cx.expr_method_call(\n                 trait_span,\n                 blkdecoder,\n-                cx.ident_of(\"read_enum_variant\", trait_span),\n+                Ident::new(sym::read_enum_variant, trait_span),\n                 vec![variant_vec, lambda],\n             );\n             cx.expr_method_call(\n                 trait_span,\n                 decoder,\n-                cx.ident_of(\"read_enum\", trait_span),\n+                Ident::new(sym::read_enum, trait_span),\n                 vec![\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.lambda1(trait_span, result, blkarg),"}, {"sha": "8ca1be1efb635f7685382e853d35e7e57e34d55f", "filename": "src/librustc_builtin_macros/deriving/default.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -1,6 +1,5 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n-use crate::deriving::path_std;\n \n use rustc_ast::ast::{Expr, MetaItem};\n use rustc_ast::ptr::P;\n@@ -21,14 +20,14 @@ pub fn expand_deriving_default(\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: path_std!(cx, default::Default),\n+        path: Path::new(vec![kw::Default, sym::Default]),\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: kw::Default,\n-            generics: LifetimeBounds::empty(),\n+            generics: Bounds::empty(),\n             explicit_self: None,\n             args: Vec::new(),\n             ret_ty: Self_,"}, {"sha": "7a880357a594740939a7fd55bfe129668047d994", "filename": "src/librustc_builtin_macros/deriving/encodable.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fencodable.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -92,7 +92,7 @@ use crate::deriving::pathvec_std;\n use rustc_ast::ast::{Expr, ExprKind, MetaItem, Mutability};\n use rustc_ast::ptr::P;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n pub fn expand_deriving_rustc_encodable(\n@@ -102,38 +102,42 @@ pub fn expand_deriving_rustc_encodable(\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    let krate = \"rustc_serialize\";\n-    let typaram = \"__S\";\n+    let krate = sym::rustc_serialize;\n+    let typaram = sym::__S;\n \n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: Path::new_(vec![krate, \"Encodable\"], None, vec![], PathKind::Global),\n+        path: Path::new_(vec![krate, sym::Encodable], None, vec![], PathKind::Global),\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::encode,\n-            generics: LifetimeBounds {\n-                lifetimes: Vec::new(),\n+            generics: Bounds {\n                 bounds: vec![(\n                     typaram,\n-                    vec![Path::new_(vec![krate, \"Encoder\"], None, vec![], PathKind::Global)],\n+                    vec![Path::new_(vec![krate, sym::Encoder], None, vec![], PathKind::Global)],\n                 )],\n             },\n             explicit_self: borrowed_explicit_self(),\n             args: vec![(\n                 Ptr(Box::new(Literal(Path::new_local(typaram))), Borrowed(None, Mutability::Mut)),\n-                \"s\",\n+                // FIXME: we could use `sym::s` here, but making `s` a static\n+                // symbol changes the symbol index ordering in a way that makes\n+                // ui/lint/rfc-2457-non-ascii-idents/lint-confusable-idents.rs\n+                // fail. The linting code should be fixed so that its output\n+                // does not depend on the symbol index ordering.\n+                Symbol::intern(\"s\"),\n             )],\n             ret_ty: Literal(Path::new_(\n-                pathvec_std!(cx, result::Result),\n+                pathvec_std!(result::Result),\n                 None,\n                 vec![\n                     Box::new(Tuple(Vec::new())),\n                     Box::new(Literal(Path::new_(\n-                        vec![typaram, \"Error\"],\n+                        vec![typaram, sym::Error],\n                         None,\n                         vec![],\n                         PathKind::Local,\n@@ -158,24 +162,24 @@ fn encodable_substructure(\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n     substr: &Substructure<'_>,\n-    krate: &'static str,\n+    krate: Symbol,\n ) -> P<Expr> {\n     let encoder = substr.nonself_args[0].clone();\n     // throw an underscore in front to suppress unused variable warnings\n-    let blkarg = cx.ident_of(\"_e\", trait_span);\n+    let blkarg = Ident::new(sym::_e, trait_span);\n     let blkencoder = cx.expr_ident(trait_span, blkarg);\n     let fn_path = cx.expr_path(cx.path_global(\n         trait_span,\n         vec![\n-            cx.ident_of(krate, trait_span),\n-            cx.ident_of(\"Encodable\", trait_span),\n-            cx.ident_of(\"encode\", trait_span),\n+            Ident::new(krate, trait_span),\n+            Ident::new(sym::Encodable, trait_span),\n+            Ident::new(sym::encode, trait_span),\n         ],\n     ));\n \n     match *substr.fields {\n         Struct(_, ref fields) => {\n-            let emit_struct_field = cx.ident_of(\"emit_struct_field\", trait_span);\n+            let emit_struct_field = Ident::new(sym::emit_struct_field, trait_span);\n             let mut stmts = Vec::new();\n             for (i, &FieldInfo { name, ref self_, span, .. }) in fields.iter().enumerate() {\n                 let name = match name {\n@@ -215,7 +219,7 @@ fn encodable_substructure(\n             cx.expr_method_call(\n                 trait_span,\n                 encoder,\n-                cx.ident_of(\"emit_struct\", trait_span),\n+                Ident::new(sym::emit_struct, trait_span),\n                 vec![\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.expr_usize(trait_span, fields.len()),\n@@ -231,7 +235,7 @@ fn encodable_substructure(\n             // actually exist.\n             let me = cx.stmt_let(trait_span, false, blkarg, encoder);\n             let encoder = cx.expr_ident(trait_span, blkarg);\n-            let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\", trait_span);\n+            let emit_variant_arg = Ident::new(sym::emit_enum_variant_arg, trait_span);\n             let mut stmts = Vec::new();\n             if !fields.is_empty() {\n                 let last = fields.len() - 1;\n@@ -264,7 +268,7 @@ fn encodable_substructure(\n             let call = cx.expr_method_call(\n                 trait_span,\n                 blkencoder,\n-                cx.ident_of(\"emit_enum_variant\", trait_span),\n+                Ident::new(sym::emit_enum_variant, trait_span),\n                 vec![\n                     name,\n                     cx.expr_usize(trait_span, idx),\n@@ -276,7 +280,7 @@ fn encodable_substructure(\n             let ret = cx.expr_method_call(\n                 trait_span,\n                 encoder,\n-                cx.ident_of(\"emit_enum\", trait_span),\n+                Ident::new(sym::emit_enum, trait_span),\n                 vec![cx.expr_str(trait_span, substr.type_ident.name), blk],\n             );\n             cx.expr_block(cx.block(trait_span, vec![me, cx.stmt_expr(ret)]))"}, {"sha": "c43d1cf1888c494a012873b554e5c6b1a004a9c4", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -191,7 +191,7 @@ use rustc_span::source_map::respan;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n \n-use ty::{LifetimeBounds, Path, Ptr, PtrTy, Self_, Ty};\n+use ty::{Bounds, Path, Ptr, PtrTy, Self_, Ty};\n \n use crate::deriving;\n \n@@ -204,14 +204,14 @@ pub struct TraitDef<'a> {\n     pub attributes: Vec<ast::Attribute>,\n \n     /// Path of the trait, including any type parameters\n-    pub path: Path<'a>,\n+    pub path: Path,\n \n     /// Additional bounds required of any type parameters of the type,\n     /// other than the current trait\n-    pub additional_bounds: Vec<Ty<'a>>,\n+    pub additional_bounds: Vec<Ty>,\n \n     /// Any extra lifetimes and/or bounds, e.g., `D: serialize::Decoder`\n-    pub generics: LifetimeBounds<'a>,\n+    pub generics: Bounds,\n \n     /// Is it an `unsafe` trait?\n     pub is_unsafe: bool,\n@@ -221,25 +221,25 @@ pub struct TraitDef<'a> {\n \n     pub methods: Vec<MethodDef<'a>>,\n \n-    pub associated_types: Vec<(Ident, Ty<'a>)>,\n+    pub associated_types: Vec<(Ident, Ty)>,\n }\n \n pub struct MethodDef<'a> {\n     /// name of the method\n     pub name: Symbol,\n     /// List of generics, e.g., `R: rand::Rng`\n-    pub generics: LifetimeBounds<'a>,\n+    pub generics: Bounds,\n \n     /// Whether there is a self argument (outer Option) i.e., whether\n     /// this is a static function, and whether it is a pointer (inner\n     /// Option)\n     pub explicit_self: Option<Option<PtrTy>>,\n \n     /// Arguments other than the self argument\n-    pub args: Vec<(Ty<'a>, &'a str)>,\n+    pub args: Vec<(Ty, Symbol)>,\n \n     /// Returns type\n-    pub ret_ty: Ty<'a>,\n+    pub ret_ty: Ty,\n \n     pub attributes: Vec<ast::Attribute>,\n \n@@ -865,7 +865,7 @@ impl<'a> MethodDef<'a> {\n \n         for (ty, name) in self.args.iter() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = cx.ident_of(name, trait_.span);\n+            let ident = Ident::new(*name, trait_.span);\n             arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(trait_.span, ident);\n@@ -1170,8 +1170,10 @@ impl<'a> MethodDef<'a> {\n             )\n             .collect::<Vec<String>>();\n \n-        let self_arg_idents =\n-            self_arg_names.iter().map(|name| cx.ident_of(name, sp)).collect::<Vec<Ident>>();\n+        let self_arg_idents = self_arg_names\n+            .iter()\n+            .map(|name| Ident::from_str_and_span(name, sp))\n+            .collect::<Vec<Ident>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n         // a series of let statements mapping each self_arg to an int\n@@ -1180,7 +1182,7 @@ impl<'a> MethodDef<'a> {\n             .iter()\n             .map(|name| {\n                 let vi_suffix = format!(\"{}_vi\", &name[..]);\n-                cx.ident_of(&vi_suffix[..], trait_.span)\n+                Ident::from_str_and_span(&vi_suffix, trait_.span)\n             })\n             .collect::<Vec<Ident>>();\n \n@@ -1568,7 +1570,7 @@ impl<'a> TraitDef<'a> {\n         let mut ident_exprs = Vec::new();\n         for (i, struct_field) in struct_def.fields().iter().enumerate() {\n             let sp = struct_field.span.with_ctxt(self.span.ctxt());\n-            let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i), self.span);\n+            let ident = Ident::from_str_and_span(&format!(\"{}_{}\", prefix, i), self.span);\n             paths.push(ident.with_span_pos(sp));\n             let val = cx.expr_path(cx.path_ident(sp, ident));\n             let val = if use_temporaries { val } else { cx.expr_deref(sp, val) };"}, {"sha": "51314dbcffc06e5d50358f6f846632f16a53d499", "filename": "src/librustc_builtin_macros/deriving/generic/ty.rs", "status": "modified", "additions": 32, "deletions": 39, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::ast::{self, Expr, GenericArg, GenericParamKind, Generics, SelfKin\n use rustc_ast::ptr::P;\n use rustc_expand::base::ExtCtxt;\n use rustc_span::source_map::{respan, DUMMY_SP};\n-use rustc_span::symbol::{kw, Ident};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n \n /// The types of pointers\n@@ -24,10 +24,10 @@ pub enum PtrTy {\n /// A path, e.g., `::std::option::Option::<i32>` (global). Has support\n /// for type parameters and a lifetime.\n #[derive(Clone)]\n-pub struct Path<'a> {\n-    path: Vec<&'a str>,\n+pub struct Path {\n+    path: Vec<Symbol>,\n     lifetime: Option<Ident>,\n-    params: Vec<Box<Ty<'a>>>,\n+    params: Vec<Box<Ty>>,\n     kind: PathKind,\n }\n \n@@ -38,19 +38,19 @@ pub enum PathKind {\n     Std,\n }\n \n-impl<'a> Path<'a> {\n-    pub fn new(path: Vec<&str>) -> Path<'_> {\n+impl Path {\n+    pub fn new(path: Vec<Symbol>) -> Path {\n         Path::new_(path, None, Vec::new(), PathKind::Std)\n     }\n-    pub fn new_local(path: &str) -> Path<'_> {\n+    pub fn new_local(path: Symbol) -> Path {\n         Path::new_(vec![path], None, Vec::new(), PathKind::Local)\n     }\n-    pub fn new_<'r>(\n-        path: Vec<&'r str>,\n+    pub fn new_(\n+        path: Vec<Symbol>,\n         lifetime: Option<Ident>,\n-        params: Vec<Box<Ty<'r>>>,\n+        params: Vec<Box<Ty>>,\n         kind: PathKind,\n-    ) -> Path<'r> {\n+    ) -> Path {\n         Path { path, lifetime, params, kind }\n     }\n \n@@ -70,7 +70,7 @@ impl<'a> Path<'a> {\n         self_ty: Ident,\n         self_generics: &Generics,\n     ) -> ast::Path {\n-        let mut idents = self.path.iter().map(|s| cx.ident_of(*s, span)).collect();\n+        let mut idents = self.path.iter().map(|s| Ident::new(*s, span)).collect();\n         let lt = mk_lifetimes(cx, span, &self.lifetime);\n         let tys: Vec<P<ast::Ty>> =\n             self.params.iter().map(|t| t.to_ty(cx, span, self_ty, self_generics)).collect();\n@@ -94,33 +94,33 @@ impl<'a> Path<'a> {\n \n /// A type. Supports pointers, Self, and literals.\n #[derive(Clone)]\n-pub enum Ty<'a> {\n+pub enum Ty {\n     Self_,\n     /// &/Box/ Ty\n-    Ptr(Box<Ty<'a>>, PtrTy),\n+    Ptr(Box<Ty>, PtrTy),\n     /// `mod::mod::Type<[lifetime], [Params...]>`, including a plain type\n     /// parameter, and things like `i32`\n-    Literal(Path<'a>),\n+    Literal(Path),\n     /// includes unit\n-    Tuple(Vec<Ty<'a>>),\n+    Tuple(Vec<Ty>),\n }\n \n pub fn borrowed_ptrty() -> PtrTy {\n     Borrowed(None, ast::Mutability::Not)\n }\n-pub fn borrowed(ty: Box<Ty<'_>>) -> Ty<'_> {\n+pub fn borrowed(ty: Box<Ty>) -> Ty {\n     Ptr(ty, borrowed_ptrty())\n }\n \n pub fn borrowed_explicit_self() -> Option<Option<PtrTy>> {\n     Some(Some(borrowed_ptrty()))\n }\n \n-pub fn borrowed_self<'r>() -> Ty<'r> {\n+pub fn borrowed_self() -> Ty {\n     borrowed(Box::new(Self_))\n }\n \n-pub fn nil_ty<'r>() -> Ty<'r> {\n+pub fn nil_ty() -> Ty {\n     Tuple(Vec::new())\n }\n \n@@ -132,7 +132,7 @@ fn mk_lifetimes(cx: &ExtCtxt<'_>, span: Span, lt: &Option<Ident>) -> Vec<ast::Li\n     mk_lifetime(cx, span, lt).into_iter().collect()\n }\n \n-impl<'a> Ty<'a> {\n+impl Ty {\n     pub fn to_ty(\n         &self,\n         cx: &ExtCtxt<'_>,\n@@ -199,9 +199,9 @@ impl<'a> Ty<'a> {\n fn mk_ty_param(\n     cx: &ExtCtxt<'_>,\n     span: Span,\n-    name: &str,\n+    name: Symbol,\n     attrs: &[ast::Attribute],\n-    bounds: &[Path<'_>],\n+    bounds: &[Path],\n     self_ident: Ident,\n     self_generics: &Generics,\n ) -> ast::GenericParam {\n@@ -212,7 +212,7 @@ fn mk_ty_param(\n             cx.trait_bound(path)\n         })\n         .collect();\n-    cx.typaram(span, cx.ident_of(name, span), attrs.to_owned(), bounds, None)\n+    cx.typaram(span, Ident::new(name, span), attrs.to_owned(), bounds, None)\n }\n \n fn mk_generics(params: Vec<ast::GenericParam>, span: Span) -> Generics {\n@@ -223,16 +223,15 @@ fn mk_generics(params: Vec<ast::GenericParam>, span: Span) -> Generics {\n     }\n }\n \n-/// Lifetimes and bounds on type parameters\n+/// Bounds on type parameters.\n #[derive(Clone)]\n-pub struct LifetimeBounds<'a> {\n-    pub lifetimes: Vec<(&'a str, Vec<&'a str>)>,\n-    pub bounds: Vec<(&'a str, Vec<Path<'a>>)>,\n+pub struct Bounds {\n+    pub bounds: Vec<(Symbol, Vec<Path>)>,\n }\n \n-impl<'a> LifetimeBounds<'a> {\n-    pub fn empty() -> LifetimeBounds<'a> {\n-        LifetimeBounds { lifetimes: Vec::new(), bounds: Vec::new() }\n+impl Bounds {\n+    pub fn empty() -> Bounds {\n+        Bounds { bounds: Vec::new() }\n     }\n     pub fn to_generics(\n         &self,\n@@ -242,18 +241,12 @@ impl<'a> LifetimeBounds<'a> {\n         self_generics: &Generics,\n     ) -> Generics {\n         let generic_params = self\n-            .lifetimes\n+            .bounds\n             .iter()\n-            .map(|&(lt, ref bounds)| {\n-                let bounds = bounds\n-                    .iter()\n-                    .map(|b| ast::GenericBound::Outlives(cx.lifetime(span, Ident::from_str(b))));\n-                cx.lifetime_def(span, Ident::from_str(lt), vec![], bounds.collect())\n-            })\n-            .chain(self.bounds.iter().map(|t| {\n+            .map(|t| {\n                 let (name, ref bounds) = *t;\n                 mk_ty_param(cx, span, name, &[], &bounds, self_ty, self_generics)\n-            }))\n+            })\n             .collect();\n \n         mk_generics(generic_params, span)"}, {"sha": "d7195188085f01fc3df926a2c77b92e42329fd44", "filename": "src/librustc_builtin_macros/deriving/hash.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fhash.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -15,27 +15,24 @@ pub fn expand_deriving_hash(\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    let path = Path::new_(pathvec_std!(cx, hash::Hash), None, vec![], PathKind::Std);\n+    let path = Path::new_(pathvec_std!(hash::Hash), None, vec![], PathKind::Std);\n \n-    let typaram = \"__H\";\n+    let typaram = sym::__H;\n \n     let arg = Path::new_local(typaram);\n     let hash_trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n         path,\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::hash,\n-            generics: LifetimeBounds {\n-                lifetimes: Vec::new(),\n-                bounds: vec![(typaram, vec![path_std!(cx, hash::Hasher)])],\n-            },\n+            generics: Bounds { bounds: vec![(typaram, vec![path_std!(hash::Hasher)])] },\n             explicit_self: borrowed_explicit_self(),\n-            args: vec![(Ptr(Box::new(Literal(arg)), Borrowed(None, Mutability::Mut)), \"state\")],\n+            args: vec![(Ptr(Box::new(Literal(arg)), Borrowed(None, Mutability::Mut)), sym::state)],\n             ret_ty: nil_ty(),\n             attributes: vec![],\n             is_unsafe: false,"}, {"sha": "33c0edde98f0ba91854e82dcffe64aa32090c9b0", "filename": "src/librustc_builtin_macros/deriving/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -7,11 +7,11 @@ use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n macro path_local($x:ident) {\n-    generic::ty::Path::new_local(stringify!($x))\n+    generic::ty::Path::new_local(sym::$x)\n }\n \n-macro pathvec_std($cx:expr, $($rest:ident)::+) {{\n-    vec![ $( stringify!($rest) ),+ ]\n+macro pathvec_std($($rest:ident)::+) {{\n+    vec![ $( sym::$rest ),+ ]\n }}\n \n macro path_std($($x:tt)*) {\n@@ -84,7 +84,7 @@ fn inject_impl_of_structural_trait(\n     cx: &mut ExtCtxt<'_>,\n     span: Span,\n     item: &Annotatable,\n-    structural_path: generic::ty::Path<'_>,\n+    structural_path: generic::ty::Path,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n     let item = match *item {"}, {"sha": "55eab24b8a5105def8d34e6bfc591bd39c721bff", "filename": "src/librustc_builtin_macros/format.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -578,31 +578,31 @@ impl<'a, 'b> Context<'a, 'b> {\n         self.count_args_index_offset = sofar;\n     }\n \n-    fn rtpath(ecx: &ExtCtxt<'_>, s: &str) -> Vec<Ident> {\n-        ecx.std_path(&[sym::fmt, sym::rt, sym::v1, Symbol::intern(s)])\n+    fn rtpath(ecx: &ExtCtxt<'_>, s: Symbol) -> Vec<Ident> {\n+        ecx.std_path(&[sym::fmt, sym::rt, sym::v1, s])\n     }\n \n     fn build_count(&self, c: parse::Count) -> P<ast::Expr> {\n         let sp = self.macsp;\n         let count = |c, arg| {\n-            let mut path = Context::rtpath(self.ecx, \"Count\");\n-            path.push(self.ecx.ident_of(c, sp));\n+            let mut path = Context::rtpath(self.ecx, sym::Count);\n+            path.push(Ident::new(c, sp));\n             match arg {\n                 Some(arg) => self.ecx.expr_call_global(sp, path, vec![arg]),\n                 None => self.ecx.expr_path(self.ecx.path_global(sp, path)),\n             }\n         };\n         match c {\n-            parse::CountIs(i) => count(\"Is\", Some(self.ecx.expr_usize(sp, i))),\n+            parse::CountIs(i) => count(sym::Is, Some(self.ecx.expr_usize(sp, i))),\n             parse::CountIsParam(i) => {\n                 // This needs mapping too, as `i` is referring to a macro\n                 // argument. If `i` is not found in `count_positions` then\n                 // the error had already been emitted elsewhere.\n                 let i = self.count_positions.get(&i).cloned().unwrap_or(0)\n                     + self.count_args_index_offset;\n-                count(\"Param\", Some(self.ecx.expr_usize(sp, i)))\n+                count(sym::Param, Some(self.ecx.expr_usize(sp, i)))\n             }\n-            parse::CountImplied => count(\"Implied\", None),\n+            parse::CountImplied => count(sym::Implied, None),\n             // should never be the case, names are already resolved\n             parse::CountIsName(_) => panic!(\"should never happen\"),\n         }\n@@ -690,40 +690,40 @@ impl<'a, 'b> Context<'a, 'b> {\n                 // Build the format\n                 let fill = self.ecx.expr_lit(sp, ast::LitKind::Char(fill));\n                 let align = |name| {\n-                    let mut p = Context::rtpath(self.ecx, \"Alignment\");\n-                    p.push(self.ecx.ident_of(name, sp));\n+                    let mut p = Context::rtpath(self.ecx, sym::Alignment);\n+                    p.push(Ident::new(name, sp));\n                     self.ecx.path_global(sp, p)\n                 };\n                 let align = match arg.format.align {\n-                    parse::AlignLeft => align(\"Left\"),\n-                    parse::AlignRight => align(\"Right\"),\n-                    parse::AlignCenter => align(\"Center\"),\n-                    parse::AlignUnknown => align(\"Unknown\"),\n+                    parse::AlignLeft => align(sym::Left),\n+                    parse::AlignRight => align(sym::Right),\n+                    parse::AlignCenter => align(sym::Center),\n+                    parse::AlignUnknown => align(sym::Unknown),\n                 };\n                 let align = self.ecx.expr_path(align);\n                 let flags = self.ecx.expr_u32(sp, arg.format.flags);\n                 let prec = self.build_count(arg.format.precision);\n                 let width = self.build_count(arg.format.width);\n-                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n+                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, sym::FormatSpec));\n                 let fmt = self.ecx.expr_struct(\n                     sp,\n                     path,\n                     vec![\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\", sp), fill),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"align\", sp), align),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\", sp), flags),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\", sp), prec),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"width\", sp), width),\n+                        self.ecx.field_imm(sp, Ident::new(sym::fill, sp), fill),\n+                        self.ecx.field_imm(sp, Ident::new(sym::align, sp), align),\n+                        self.ecx.field_imm(sp, Ident::new(sym::flags, sp), flags),\n+                        self.ecx.field_imm(sp, Ident::new(sym::precision, sp), prec),\n+                        self.ecx.field_imm(sp, Ident::new(sym::width, sp), width),\n                     ],\n                 );\n \n-                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"Argument\"));\n+                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, sym::Argument));\n                 Some(self.ecx.expr_struct(\n                     sp,\n                     path,\n                     vec![\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"position\", sp), pos),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"format\", sp), fmt),\n+                        self.ecx.field_imm(sp, Ident::new(sym::position, sp), pos),\n+                        self.ecx.field_imm(sp, Ident::new(sym::format, sp), fmt),\n                     ],\n                 ))\n             }\n@@ -740,7 +740,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         let mut heads = Vec::with_capacity(self.args.len());\n \n         let names_pos: Vec<_> = (0..self.args.len())\n-            .map(|i| self.ecx.ident_of(&format!(\"arg{}\", i), self.macsp))\n+            .map(|i| Ident::from_str_and_span(&format!(\"arg{}\", i), self.macsp))\n             .collect();\n \n         // First, build up the static array which will become our precompiled"}, {"sha": "89446a1aa96f9a79346ef5421910b41154890f61", "filename": "src/librustc_builtin_macros/global_allocator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -58,7 +58,7 @@ impl AllocFnFactory<'_, '_> {\n         let mut abi_args = Vec::new();\n         let mut i = 0;\n         let mut mk = || {\n-            let name = self.cx.ident_of(&format!(\"arg{}\", i), self.span);\n+            let name = Ident::from_str_and_span(&format!(\"arg{}\", i), self.span);\n             i += 1;\n             name\n         };\n@@ -72,7 +72,7 @@ impl AllocFnFactory<'_, '_> {\n         let kind = ItemKind::Fn(ast::Defaultness::Final, sig, Generics::default(), block);\n         let item = self.cx.item(\n             self.span,\n-            self.cx.ident_of(&self.kind.fn_name(method.name), self.span),\n+            Ident::from_str_and_span(&self.kind.fn_name(method.name), self.span),\n             self.attrs(),\n             kind,\n         );"}, {"sha": "f044ce41e879ee8ff3782550c620f334beddcd9e", "filename": "src/librustc_builtin_macros/proc_macro_harness.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -384,12 +384,12 @@ fn mk_decls(\n     let proc_macro = Ident::new(sym::proc_macro, span);\n     let krate = cx.item(span, proc_macro, Vec::new(), ast::ItemKind::ExternCrate(None));\n \n-    let bridge = cx.ident_of(\"bridge\", span);\n-    let client = cx.ident_of(\"client\", span);\n-    let proc_macro_ty = cx.ident_of(\"ProcMacro\", span);\n-    let custom_derive = cx.ident_of(\"custom_derive\", span);\n-    let attr = cx.ident_of(\"attr\", span);\n-    let bang = cx.ident_of(\"bang\", span);\n+    let bridge = Ident::new(sym::bridge, span);\n+    let client = Ident::new(sym::client, span);\n+    let proc_macro_ty = Ident::new(sym::ProcMacro, span);\n+    let custom_derive = Ident::new(sym::custom_derive, span);\n+    let attr = Ident::new(sym::attr, span);\n+    let bang = Ident::new(sym::bang, span);\n \n     let krate_ref = RefCell::new(ast_krate);\n \n@@ -447,7 +447,7 @@ fn mk_decls(\n     let decls_static = cx\n         .item_static(\n             span,\n-            cx.ident_of(\"_DECLS\", span),\n+            Ident::new(sym::_DECLS, span),\n             cx.ty_rptr(\n                 span,\n                 cx.ty("}, {"sha": "460f947a792af5975b7627f6e7f003ec7b81d021", "filename": "src/librustc_builtin_macros/test.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -108,22 +108,38 @@ pub fn expand_test_or_bench(\n     let test_id = Ident::new(sym::test, attr_sp);\n \n     // creates test::$name\n-    let test_path = |name| cx.path(sp, vec![test_id, cx.ident_of(name, sp)]);\n+    let test_path = |name| cx.path(sp, vec![test_id, Ident::from_str_and_span(name, sp)]);\n \n     // creates test::ShouldPanic::$name\n-    let should_panic_path =\n-        |name| cx.path(sp, vec![test_id, cx.ident_of(\"ShouldPanic\", sp), cx.ident_of(name, sp)]);\n+    let should_panic_path = |name| {\n+        cx.path(\n+            sp,\n+            vec![\n+                test_id,\n+                Ident::from_str_and_span(\"ShouldPanic\", sp),\n+                Ident::from_str_and_span(name, sp),\n+            ],\n+        )\n+    };\n \n     // creates test::TestType::$name\n-    let test_type_path =\n-        |name| cx.path(sp, vec![test_id, cx.ident_of(\"TestType\", sp), cx.ident_of(name, sp)]);\n+    let test_type_path = |name| {\n+        cx.path(\n+            sp,\n+            vec![\n+                test_id,\n+                Ident::from_str_and_span(\"TestType\", sp),\n+                Ident::from_str_and_span(name, sp),\n+            ],\n+        )\n+    };\n \n     // creates $name: $expr\n-    let field = |name, expr| cx.field_imm(sp, cx.ident_of(name, sp), expr);\n+    let field = |name, expr| cx.field_imm(sp, Ident::from_str_and_span(name, sp), expr);\n \n     let test_fn = if is_bench {\n         // A simple ident for a lambda\n-        let b = cx.ident_of(\"b\", attr_sp);\n+        let b = Ident::from_str_and_span(\"b\", attr_sp);\n \n         cx.expr_call(\n             sp,"}, {"sha": "98c5c6936d779d07199d701029e647d529e8700f", "filename": "src/librustc_builtin_macros/test_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest_harness.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -270,7 +270,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     let mut test_runner = cx\n         .test_runner\n         .clone()\n-        .unwrap_or(ecx.path(sp, vec![test_id, ecx.ident_of(runner_name, sp)]));\n+        .unwrap_or(ecx.path(sp, vec![test_id, Ident::from_str_and_span(runner_name, sp)]));\n \n     test_runner.span = sp;\n "}, {"sha": "95d47ab21cbd38d0ae2d10f7e19e3cfd6ebac4c5", "filename": "src/librustc_error_codes/error_codes/E0723.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0723.md", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0723.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0723.md?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -1,4 +1,4 @@\n-An feature unstable in `const` contexts was used.\n+An unstable feature in `const` contexts was used.\n \n Erroneous code example:\n "}, {"sha": "64e2d5b3a467c84fd18b28223e40141680d8431b", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -1061,9 +1061,6 @@ impl<'a> ExtCtxt<'a> {\n     pub fn set_trace_macros(&mut self, x: bool) {\n         self.ecfg.trace_mac = x\n     }\n-    pub fn ident_of(&self, st: &str, sp: Span) -> Ident {\n-        Ident::from_str_and_span(st, sp)\n-    }\n     pub fn std_path(&self, components: &[Symbol]) -> Vec<Ident> {\n         let def_site = self.with_def_site_ctxt(DUMMY_SP);\n         iter::once(Ident::new(kw::DollarCrate, def_site))"}, {"sha": "81ff4b3157845e94b65b29cf19aa757ba8265a92", "filename": "src/librustc_expand/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbuild.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -368,7 +368,7 @@ impl<'a> ExtCtxt<'a> {\n         let err = self.std_path(&[sym::result, sym::Result, sym::Err]);\n         let err_path = self.path_global(sp, err);\n \n-        let binding_variable = self.ident_of(\"__try_var\", sp);\n+        let binding_variable = Ident::new(sym::__try_var, sp);\n         let binding_pat = self.pat_ident(sp, binding_variable);\n         let binding_expr = self.expr_ident(sp, binding_variable);\n "}, {"sha": "b311f8344bb6dc787f12a51db651f0489a8d8f24", "filename": "src/librustc_middle/mir/query.rs", "status": "modified", "additions": 88, "deletions": 4, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fquery.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -8,7 +8,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_index::bit_set::BitMatrix;\n use rustc_index::vec::IndexVec;\n-use rustc_span::{Span, Symbol};\n+use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use smallvec::SmallVec;\n use std::cell::Cell;\n@@ -18,7 +18,7 @@ use super::{Field, SourceInfo};\n \n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnsafetyViolationKind {\n-    /// Only permitted in regular `fn`s, prohibitted in `const fn`s.\n+    /// Only permitted in regular `fn`s, prohibited in `const fn`s.\n     General,\n     /// Permitted both in `const fn`s and regular `fn`s.\n     GeneralAndConstFn,\n@@ -35,13 +35,97 @@ pub enum UnsafetyViolationKind {\n     UnsafeFnBorrowPacked,\n }\n \n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum UnsafetyViolationDetails {\n+    CallToUnsafeFunction,\n+    UseOfInlineAssembly,\n+    InitializingTypeWith,\n+    CastOfPointerToInt,\n+    BorrowOfPackedField,\n+    UseOfMutableStatic,\n+    UseOfExternStatic,\n+    DerefOfRawPointer,\n+    AssignToNonCopyUnionField,\n+    AccessToUnionField,\n+    MutationOfLayoutConstrainedField,\n+    BorrowOfLayoutConstrainedField,\n+    CallToFunctionWith,\n+}\n+\n+impl UnsafetyViolationDetails {\n+    pub fn description_and_note(&self) -> (&'static str, &'static str) {\n+        use UnsafetyViolationDetails::*;\n+        match self {\n+            CallToUnsafeFunction => (\n+                \"call to unsafe function\",\n+                \"consult the function's documentation for information on how to avoid undefined \\\n+                 behavior\",\n+            ),\n+            UseOfInlineAssembly => (\n+                \"use of inline assembly\",\n+                \"inline assembly is entirely unchecked and can cause undefined behavior\",\n+            ),\n+            InitializingTypeWith => (\n+                \"initializing type with `rustc_layout_scalar_valid_range` attr\",\n+                \"initializing a layout restricted type's field with a value outside the valid \\\n+                 range is undefined behavior\",\n+            ),\n+            CastOfPointerToInt => {\n+                (\"cast of pointer to int\", \"casting pointers to integers in constants\")\n+            }\n+            BorrowOfPackedField => (\n+                \"borrow of packed field\",\n+                \"fields of packed structs might be misaligned: dereferencing a misaligned pointer \\\n+                 or even just creating a misaligned reference is undefined behavior\",\n+            ),\n+            UseOfMutableStatic => (\n+                \"use of mutable static\",\n+                \"mutable statics can be mutated by multiple threads: aliasing violations or data \\\n+                 races will cause undefined behavior\",\n+            ),\n+            UseOfExternStatic => (\n+                \"use of extern static\",\n+                \"extern statics are not controlled by the Rust type system: invalid data, \\\n+                 aliasing violations or data races will cause undefined behavior\",\n+            ),\n+            DerefOfRawPointer => (\n+                \"dereference of raw pointer\",\n+                \"raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules \\\n+                 and cause data races: all of these are undefined behavior\",\n+            ),\n+            AssignToNonCopyUnionField => (\n+                \"assignment to non-`Copy` union field\",\n+                \"the previous content of the field will be dropped, which causes undefined \\\n+                 behavior if the field was not properly initialized\",\n+            ),\n+            AccessToUnionField => (\n+                \"access to union field\",\n+                \"the field may not be properly initialized: using uninitialized data will cause \\\n+                 undefined behavior\",\n+            ),\n+            MutationOfLayoutConstrainedField => (\n+                \"mutation of layout constrained field\",\n+                \"mutating layout constrained fields cannot statically be checked for valid values\",\n+            ),\n+            BorrowOfLayoutConstrainedField => (\n+                \"borrow of layout constrained field with interior mutability\",\n+                \"references to fields of layout constrained fields lose the constraints. Coupled \\\n+                 with interior mutability, the field can be changed to invalid values\",\n+            ),\n+            CallToFunctionWith => (\n+                \"call to function with `#[target_feature]`\",\n+                \"can only be called if the required target features are available\",\n+            ),\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UnsafetyViolation {\n     pub source_info: SourceInfo,\n     pub lint_root: hir::HirId,\n-    pub description: Symbol,\n-    pub details: Symbol,\n     pub kind: UnsafetyViolationKind,\n+    pub details: UnsafetyViolationDetails,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]"}, {"sha": "043d85cb6efa632f7800517b8db3a03918ac5957", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -1440,12 +1440,12 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n         // FIXME(eddyb) `name` should never be empty, but it\n         // currently is for `extern { ... }` \"foreign modules\".\n-        let name = disambiguated_data.data.as_symbol().as_str();\n-        if !name.is_empty() {\n+        let name = disambiguated_data.data.as_symbol();\n+        if name != kw::Invalid {\n             if !self.empty_path {\n                 write!(self, \"::\")?;\n             }\n-            if Ident::from_str(&name).is_raw_guess() {\n+            if Ident::with_dummy_span(name).is_raw_guess() {\n                 write!(self, \"r#\")?;\n             }\n             write!(self, \"{}\", name)?;"}, {"sha": "0683dc0201129bddca91b54fc36d3a10b1df3c7f", "filename": "src/librustc_middle/ty/query/profiling_support.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_middle%2Fty%2Fquery%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_middle%2Fty%2Fquery%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fprofiling_support.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -60,12 +60,12 @@ impl<'p, 'c, 'tcx> QueryKeyStringBuilder<'p, 'c, 'tcx> {\n \n         match def_key.disambiguated_data.data {\n             DefPathData::CrateRoot => {\n-                name = self.tcx.original_crate_name(def_id.krate).as_str();\n+                name = self.tcx.original_crate_name(def_id.krate);\n                 dis = \"\";\n                 end_index = 3;\n             }\n             other => {\n-                name = other.as_symbol().as_str();\n+                name = other.as_symbol();\n                 if def_key.disambiguated_data.disambiguator == 0 {\n                     dis = \"\";\n                     end_index = 3;\n@@ -79,10 +79,11 @@ impl<'p, 'c, 'tcx> QueryKeyStringBuilder<'p, 'c, 'tcx> {\n             }\n         }\n \n+        let name = &*name.as_str();\n         let components = [\n             StringComponent::Ref(parent_string_id),\n             StringComponent::Value(\"::\"),\n-            StringComponent::Value(&name[..]),\n+            StringComponent::Value(name),\n             StringComponent::Value(dis),\n         ];\n "}, {"sha": "81d7ac089262206aa24957a226f5c50ea627701e", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 30, "deletions": 82, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint::builtin::{SAFE_PACKED_BORROWS, UNSAFE_OP_IN_UNSAFE_FN, UNUSED_UNSAFE};\n use rustc_session::lint::Level;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::sym;\n \n use std::ops::Bound;\n \n@@ -86,10 +86,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 let sig = func_ty.fn_sig(self.tcx);\n                 if let hir::Unsafety::Unsafe = sig.unsafety() {\n                     self.require_unsafe(\n-                        \"call to unsafe function\",\n-                        \"consult the function's documentation for information on how to avoid \\\n-                         undefined behavior\",\n                         UnsafetyViolationKind::GeneralAndConstFn,\n+                        UnsafetyViolationDetails::CallToUnsafeFunction,\n                     )\n                 }\n \n@@ -99,9 +97,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             }\n \n             TerminatorKind::InlineAsm { .. } => self.require_unsafe(\n-                \"use of inline assembly\",\n-                \"inline assembly is entirely unchecked and can cause undefined behavior\",\n                 UnsafetyViolationKind::General,\n+                UnsafetyViolationDetails::UseOfInlineAssembly,\n             ),\n         }\n         self.super_terminator(terminator, location);\n@@ -122,9 +119,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             }\n \n             StatementKind::LlvmInlineAsm { .. } => self.require_unsafe(\n-                \"use of inline assembly\",\n-                \"inline assembly is entirely unchecked and can cause undefined behavior\",\n                 UnsafetyViolationKind::General,\n+                UnsafetyViolationDetails::UseOfInlineAssembly,\n             ),\n         }\n         self.super_statement(statement, location);\n@@ -138,10 +134,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     match self.tcx.layout_scalar_valid_range(def.did) {\n                         (Bound::Unbounded, Bound::Unbounded) => {}\n                         _ => self.require_unsafe(\n-                            \"initializing type with `rustc_layout_scalar_valid_range` attr\",\n-                            \"initializing a layout restricted type's field with a value \\\n-                                outside the valid range is undefined behavior\",\n                             UnsafetyViolationKind::GeneralAndConstFn,\n+                            UnsafetyViolationDetails::InitializingTypeWith,\n                         ),\n                     }\n                 }\n@@ -163,9 +157,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 match (cast_in, cast_out) {\n                     (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) => {\n                         self.require_unsafe(\n-                            \"cast of pointer to int\",\n-                            \"casting pointers to integers in constants\",\n                             UnsafetyViolationKind::General,\n+                            UnsafetyViolationDetails::CastOfPointerToInt,\n                         );\n                     }\n                     _ => {}\n@@ -190,11 +183,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n         if context.is_borrow() {\n             if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n                 self.require_unsafe(\n-                    \"borrow of packed field\",\n-                    \"fields of packed structs might be misaligned: dereferencing a \\\n-                    misaligned pointer or even just creating a misaligned reference \\\n-                    is undefined behavior\",\n                     UnsafetyViolationKind::BorrowPacked,\n+                    UnsafetyViolationDetails::BorrowOfPackedField,\n                 );\n             }\n         }\n@@ -204,11 +194,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             if context.is_borrow() {\n                 if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n                     self.require_unsafe(\n-                        \"borrow of packed field\",\n-                        \"fields of packed structs might be misaligned: dereferencing a \\\n-                        misaligned pointer or even just creating a misaligned reference \\\n-                        is undefined behavior\",\n                         UnsafetyViolationKind::BorrowPacked,\n+                        UnsafetyViolationDetails::BorrowOfPackedField,\n                     );\n                 }\n             }\n@@ -219,19 +206,14 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     if let Some(box LocalInfo::StaticRef { def_id, .. }) = decl.local_info {\n                         if self.tcx.is_mutable_static(def_id) {\n                             self.require_unsafe(\n-                                \"use of mutable static\",\n-                                \"mutable statics can be mutated by multiple threads: aliasing \\\n-                            violations or data races will cause undefined behavior\",\n                                 UnsafetyViolationKind::General,\n+                                UnsafetyViolationDetails::UseOfMutableStatic,\n                             );\n                             return;\n                         } else if self.tcx.is_foreign_item(def_id) {\n                             self.require_unsafe(\n-                                \"use of extern static\",\n-                                \"extern statics are not controlled by the Rust type system: \\\n-                            invalid data, aliasing violations or data races will cause \\\n-                            undefined behavior\",\n                                 UnsafetyViolationKind::General,\n+                                UnsafetyViolationDetails::UseOfExternStatic,\n                             );\n                             return;\n                         }\n@@ -246,11 +228,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n             match base_ty.kind {\n                 ty::RawPtr(..) => self.require_unsafe(\n-                    \"dereference of raw pointer\",\n-                    \"raw pointers may be NULL, dangling or unaligned; they can violate \\\n-                         aliasing rules and cause data races: all of these are undefined \\\n-                         behavior\",\n                     UnsafetyViolationKind::General,\n+                    UnsafetyViolationDetails::DerefOfRawPointer,\n                 ),\n                 ty::Adt(adt, _) => {\n                     if adt.is_union() {\n@@ -271,21 +250,16 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                                 self.param_env,\n                             ) {\n                                 self.require_unsafe(\n-                                    \"assignment to non-`Copy` union field\",\n-                                    \"the previous content of the field will be dropped, which \\\n-                                     causes undefined behavior if the field was not properly \\\n-                                     initialized\",\n                                     UnsafetyViolationKind::GeneralAndConstFn,\n+                                    UnsafetyViolationDetails::AssignToNonCopyUnionField,\n                                 )\n                             } else {\n                                 // write to non-move union, safe\n                             }\n                         } else {\n                             self.require_unsafe(\n-                                \"access to union field\",\n-                                \"the field may not be properly initialized: using \\\n-                                 uninitialized data will cause undefined behavior\",\n                                 UnsafetyViolationKind::GeneralAndConstFn,\n+                                UnsafetyViolationDetails::AccessToUnionField,\n                             )\n                         }\n                     }\n@@ -298,26 +272,15 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n-    fn require_unsafe(\n-        &mut self,\n-        description: &'static str,\n-        details: &'static str,\n-        kind: UnsafetyViolationKind,\n-    ) {\n+    fn require_unsafe(&mut self, kind: UnsafetyViolationKind, details: UnsafetyViolationDetails) {\n         let source_info = self.source_info;\n         let lint_root = self.body.source_scopes[self.source_info.scope]\n             .local_data\n             .as_ref()\n             .assert_crate_local()\n             .lint_root;\n         self.register_violations(\n-            &[UnsafetyViolation {\n-                source_info,\n-                lint_root,\n-                description: Symbol::intern(description),\n-                details: Symbol::intern(details),\n-                kind,\n-            }],\n+            &[UnsafetyViolation { source_info, lint_root, kind, details }],\n             &[],\n         );\n     }\n@@ -434,12 +397,8 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                         if self.tcx.layout_scalar_valid_range(def.did)\n                             != (Bound::Unbounded, Bound::Unbounded)\n                         {\n-                            let (description, details) = if is_mut_use {\n-                                (\n-                                    \"mutation of layout constrained field\",\n-                                    \"mutating layout constrained fields cannot statically be \\\n-                                        checked for valid values\",\n-                                )\n+                            let details = if is_mut_use {\n+                                UnsafetyViolationDetails::MutationOfLayoutConstrainedField\n \n                             // Check `is_freeze` as late as possible to avoid cycle errors\n                             // with opaque types.\n@@ -448,21 +407,11 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                                 .ty\n                                 .is_freeze(self.tcx.at(self.source_info.span), self.param_env)\n                             {\n-                                (\n-                                    \"borrow of layout constrained field with interior \\\n-                                        mutability\",\n-                                    \"references to fields of layout constrained fields \\\n-                                        lose the constraints. Coupled with interior mutability, \\\n-                                        the field can be changed to invalid values\",\n-                                )\n+                                UnsafetyViolationDetails::BorrowOfLayoutConstrainedField\n                             } else {\n                                 continue;\n                             };\n-                            self.require_unsafe(\n-                                description,\n-                                details,\n-                                UnsafetyViolationKind::GeneralAndConstFn,\n-                            );\n+                            self.require_unsafe(UnsafetyViolationKind::GeneralAndConstFn, details);\n                         }\n                     }\n                 }\n@@ -480,9 +429,8 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         // Is `callee_features` a subset of `calling_features`?\n         if !callee_features.iter().all(|feature| self_features.contains(feature)) {\n             self.require_unsafe(\n-                \"call to function with `#[target_feature]`\",\n-                \"can only be called if the required target features are available\",\n                 UnsafetyViolationKind::GeneralAndConstFn,\n+                UnsafetyViolationDetails::CallToFunctionWith,\n             )\n         }\n     }\n@@ -675,9 +623,9 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n \n     let UnsafetyCheckResult { violations, unsafe_blocks } = tcx.unsafety_check_result(def_id);\n \n-    for &UnsafetyViolation { source_info, lint_root, description, details, kind } in\n-        violations.iter()\n-    {\n+    for &UnsafetyViolation { source_info, lint_root, kind, details } in violations.iter() {\n+        let (description, note) = details.description_and_note();\n+\n         // Report an error.\n         let unsafe_fn_msg =\n             if unsafe_op_in_unsafe_fn_allowed(tcx, lint_root) { \" function or\" } else { \"\" };\n@@ -693,8 +641,8 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                     description,\n                     unsafe_fn_msg,\n                 )\n-                .span_label(source_info.span, &*description.as_str())\n-                .note(&details.as_str())\n+                .span_label(source_info.span, description)\n+                .note(note)\n                 .emit();\n             }\n             UnsafetyViolationKind::BorrowPacked => {\n@@ -712,7 +660,7 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                                 \"{} is unsafe and requires unsafe{} block (error E0133)\",\n                                 description, unsafe_fn_msg,\n                             ))\n-                            .note(&details.as_str())\n+                            .note(note)\n                             .emit()\n                         },\n                     )\n@@ -727,8 +675,8 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                         \"{} is unsafe and requires unsafe block (error E0133)\",\n                         description,\n                     ))\n-                    .span_label(source_info.span, &*description.as_str())\n-                    .note(&details.as_str())\n+                    .span_label(source_info.span, description)\n+                    .note(note)\n                     .emit();\n                 },\n             ),\n@@ -756,8 +704,8 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                         \"{} is unsafe and requires unsafe block (error E0133)\",\n                         description,\n                     ))\n-                    .span_label(source_info.span, &*description.as_str())\n-                    .note(&details.as_str())\n+                    .span_label(source_info.span, description)\n+                    .note(note)\n                     .emit();\n                 })\n             }"}, {"sha": "5d972c70d139255f27b137c08895167d1c9f572d", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -502,7 +502,8 @@ impl Visitor<'tcx> for Checker<'tcx> {\n         match item.kind {\n             hir::ItemKind::ExternCrate(_) => {\n                 // compiler-generated `extern crate` items have a dummy span.\n-                if item.span.is_dummy() {\n+                // `std` is still checked for the `restricted-std` feature.\n+                if item.span.is_dummy() && item.ident.as_str() != \"std\" {\n                     return;\n                 }\n "}, {"sha": "45253fc878222affc6e6a60618b63e7f63a85834", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -111,12 +111,17 @@ impl<'a> Resolver<'a> {\n             (self.cstore().crate_name_untracked(def_id.krate), None)\n         } else {\n             let def_key = self.cstore().def_key(def_id);\n-            (\n-                // This unwrap is safe: crates must always have a name\n-                def_key.disambiguated_data.data.get_opt_name().unwrap(),\n-                // This unwrap is safe since we know this isn't the root\n-                Some(self.get_module(DefId { index: def_key.parent.unwrap(), ..def_id })),\n-            )\n+            let name = def_key\n+                .disambiguated_data\n+                .data\n+                .get_opt_name()\n+                .expect(\"given a DefId that wasn't a module\");\n+            // This unwrap is safe since we know this isn't the root\n+            let parent = Some(self.get_module(DefId {\n+                index: def_key.parent.expect(\"failed to get parent for module\"),\n+                ..def_id\n+            }));\n+            (name, parent)\n         };\n \n         // Allocate and return a new module with the information we found"}, {"sha": "686385e24ece8052b6d86ddb6713c302450dfd3c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -2978,7 +2978,7 @@ impl<'a> Resolver<'a> {\n         span: Span,\n         path_str: &str,\n         ns: Namespace,\n-        module_id: LocalDefId,\n+        module_id: DefId,\n     ) -> Result<(ast::Path, Res), ()> {\n         let path = if path_str.starts_with(\"::\") {\n             ast::Path {\n@@ -2998,7 +2998,7 @@ impl<'a> Resolver<'a> {\n                     .collect(),\n             }\n         };\n-        let module = self.module_map.get(&module_id).copied().unwrap_or(self.graph_root);\n+        let module = self.get_module(module_id);\n         let parent_scope = &ParentScope::module(module);\n         let res = self.resolve_ast_path(&path, ns, parent_scope).map_err(|_| ())?;\n         Ok((path, res))"}, {"sha": "5d332ddf5f3df1ccecf1165219bd67d875fdd1b9", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -122,19 +122,28 @@ symbols! {\n     // There is currently no checking that all symbols are used; that would be\n     // nice to have.\n     Symbols {\n+        Alignment,\n         Arc,\n+        Argument,\n         ArgumentV1,\n         Arguments,\n         C,\n+        Center,\n         Clone,\n         Copy,\n+        Count,\n         Debug,\n         Decodable,\n+        Decoder,\n         Default,\n         Encodable,\n+        Encoder,\n         Eq,\n         Equal,\n         Err,\n+        Error,\n+        FormatSpec,\n+        Formatter,\n         From,\n         Future,\n         FxHashMap,\n@@ -143,23 +152,29 @@ symbols! {\n         Hash,\n         HashMap,\n         HashSet,\n+        Hasher,\n+        Implied,\n         Input,\n         IntoIterator,\n+        Is,\n         ItemContext,\n         Iterator,\n         Layout,\n+        Left,\n         LintPass,\n         None,\n         Ok,\n         Option,\n         Ord,\n         Ordering,\n         Output,\n+        Param,\n         PartialEq,\n         PartialOrd,\n         Pending,\n         Pin,\n         Poll,\n+        ProcMacro,\n         ProcMacroHack,\n         ProceduralMasqueradeDummyType,\n         Range,\n@@ -172,20 +187,31 @@ symbols! {\n         Ready,\n         Result,\n         Return,\n+        Right,\n         RustcDecodable,\n         RustcEncodable,\n         Send,\n         Some,\n+        StructuralEq,\n+        StructuralPartialEq,\n         Sync,\n         Target,\n         Try,\n         Ty,\n         TyCtxt,\n         TyKind,\n+        Unknown,\n         Vec,\n         Yield,\n+        _DECLS,\n         _Self,\n+        __D,\n+        __H,\n+        __S,\n         __next,\n+        __try_var,\n+        _d,\n+        _e,\n         _task_context,\n         aarch64_target_feature,\n         abi,\n@@ -226,6 +252,7 @@ symbols! {\n         allowed,\n         always,\n         and,\n+        and_then,\n         any,\n         arbitrary_enum_discriminant,\n         arbitrary_self_types,\n@@ -256,6 +283,7 @@ symbols! {\n         automatically_derived,\n         avx512_target_feature,\n         await_macro,\n+        bang,\n         begin_panic,\n         bench,\n         bin,\n@@ -278,6 +306,7 @@ symbols! {\n         box_syntax,\n         braced_empty_structs,\n         breakpoint,\n+        bridge,\n         bswap,\n         c_variadic,\n         call,\n@@ -299,6 +328,7 @@ symbols! {\n         cfg_target_vendor,\n         cfg_version,\n         char,\n+        client,\n         clippy,\n         clone,\n         clone_closures,\n@@ -370,11 +400,15 @@ symbols! {\n         custom_derive,\n         custom_inner_attributes,\n         custom_test_frameworks,\n+        d,\n         dead_code,\n         dealloc,\n         debug,\n         debug_assertions,\n+        debug_struct,\n         debug_trait,\n+        debug_trait_builder,\n+        debug_tuple,\n         decl_macro,\n         declare_lint_pass,\n         decode,\n@@ -421,6 +455,11 @@ symbols! {\n         dyn_trait,\n         eh_catch_typeinfo,\n         eh_personality,\n+        emit_enum,\n+        emit_enum_variant,\n+        emit_enum_variant_arg,\n+        emit_struct,\n+        emit_struct_field,\n         enable,\n         enclosing_scope,\n         encode,\n@@ -448,6 +487,7 @@ symbols! {\n         extern_prelude,\n         extern_types,\n         external_doc,\n+        f,\n         f16c_target_feature,\n         f32,\n         f32_runtime,\n@@ -464,6 +504,9 @@ symbols! {\n         field,\n         field_init_shorthand,\n         file,\n+        fill,\n+        finish,\n+        flags,\n         float_to_int_unchecked,\n         floorf32,\n         floorf64,\n@@ -478,6 +521,7 @@ symbols! {\n         fn_once_output,\n         forbid,\n         forget,\n+        format,\n         format_args,\n         format_args_capture,\n         format_args_nl,\n@@ -519,6 +563,7 @@ symbols! {\n         html_no_source,\n         html_playground_url,\n         html_root_url,\n+        i,\n         i128,\n         i128_type,\n         i16,\n@@ -606,6 +651,7 @@ symbols! {\n         main,\n         managed_boxes,\n         manually_drop,\n+        map,\n         marker,\n         marker_trait_attr,\n         masked,\n@@ -708,6 +754,7 @@ symbols! {\n         options,\n         or,\n         or_patterns,\n+        other,\n         out,\n         overlapping_marker_traits,\n         owned_box,\n@@ -739,6 +786,7 @@ symbols! {\n         plugins,\n         pointer,\n         poll,\n+        position,\n         post_dash_lto: \"post-lto\",\n         powerpc_target_feature,\n         powf32,\n@@ -747,6 +795,7 @@ symbols! {\n         powif64,\n         pre_dash_lto: \"pre-lto\",\n         precise_pointer_size_matching,\n+        precision,\n         pref_align_of,\n         prefetch_read_data,\n         prefetch_read_instruction,\n@@ -783,6 +832,11 @@ symbols! {\n         raw_identifiers,\n         raw_ref_op,\n         re_rebalance_coherence,\n+        read_enum,\n+        read_enum_variant,\n+        read_enum_variant_arg,\n+        read_struct,\n+        read_struct_field,\n         readonly,\n         realloc,\n         reason,\n@@ -872,6 +926,7 @@ symbols! {\n         rustc_promotable,\n         rustc_regions,\n         rustc_reservation_impl,\n+        rustc_serialize,\n         rustc_specialization_trait,\n         rustc_stable,\n         rustc_std_internal_symbol,\n@@ -976,6 +1031,7 @@ symbols! {\n         stable,\n         staged_api,\n         start,\n+        state,\n         static_in_const,\n         static_nobundle,\n         static_recursion,\n@@ -1123,6 +1179,7 @@ symbols! {\n         wasm_import_module,\n         wasm_target_feature,\n         while_let,\n+        width,\n         windows,\n         windows_subsystem,\n         wrapping_add,"}, {"sha": "a9b045cee6087ce599742d817f77b58eb8532d57", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -26,7 +26,7 @@ use rustc_middle::ty::{\n     TypeFoldable, WithConstness,\n };\n use rustc_session::DiagnosticMessageId;\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{kw, sym};\n use rustc_span::{ExpnKind, MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n \n@@ -1524,7 +1524,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     (self.tcx.sess.source_map().span_to_snippet(span), &obligation.cause.code)\n                 {\n                     let generics = self.tcx.generics_of(*def_id);\n-                    if generics.params.iter().any(|p| p.name.as_str() != \"Self\")\n+                    if generics.params.iter().any(|p| p.name != kw::SelfUpper)\n                         && !snippet.ends_with('>')\n                     {\n                         // FIXME: To avoid spurious suggestions in functions where type arguments"}, {"sha": "f575548ddd6382bb7da09921310e6c286b22ceb6", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -322,12 +322,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let self_ty = self.tables.borrow().node_type(method_expr[0].hir_id);\n         let self_ty = format!(\"{:?}\", self_ty);\n-        let name = method_path.ident.as_str();\n+        let name = method_path.ident.name;\n         let is_as_ref_able = (self_ty.starts_with(\"&std::option::Option\")\n             || self_ty.starts_with(\"&std::result::Result\")\n             || self_ty.starts_with(\"std::option::Option\")\n             || self_ty.starts_with(\"std::result::Result\"))\n-            && (name == \"map\" || name == \"and_then\");\n+            && (name == sym::map || name == sym::and_then);\n         match (is_as_ref_able, self.sess().source_map().span_to_snippet(*method_span)) {\n             (true, Ok(src)) => {\n                 let suggestion = format!(\"as_ref().{}\", src);"}, {"sha": "6a52974534f8b66d627718e18327772272986310", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -430,7 +430,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                                 DUMMY_SP,\n                                 extern_name,\n                                 TypeNS,\n-                                LocalDefId { local_def_index: CRATE_DEF_INDEX },\n+                                LocalDefId { local_def_index: CRATE_DEF_INDEX }.to_def_id(),\n                             )\n                             .unwrap_or_else(|()| {\n                                 panic!(\"Unable to resolve external crate {}\", extern_name)"}, {"sha": "f872ed7010c7537ad3aae0cdec855f2e6a771213", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -2230,12 +2230,15 @@ fn stability_tags(item: &clean::Item) -> String {\n         tags += &tag_html(\"deprecated\", message);\n     }\n \n-    if let Some(stab) = item.stability.as_ref().filter(|s| s.level == stability::Unstable) {\n-        if stab.feature.as_deref() == Some(\"rustc_private\") {\n-            tags += &tag_html(\"internal\", \"Internal\");\n-        } else {\n-            tags += &tag_html(\"unstable\", \"Experimental\");\n-        }\n+    // The \"rustc_private\" crates are permanently unstable so it makes no sense\n+    // to render \"unstable\" everywhere.\n+    if item\n+        .stability\n+        .as_ref()\n+        .map(|s| s.level == stability::Unstable && s.feature.as_deref() != Some(\"rustc_private\"))\n+        == Some(true)\n+    {\n+        tags += &tag_html(\"unstable\", \"Experimental\");\n     }\n \n     if let Some(ref cfg) = item.attrs.cfg {\n@@ -2286,15 +2289,13 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n         ));\n     }\n \n-    if let Some(stab) = item.stability.as_ref().filter(|stab| stab.level == stability::Unstable) {\n-        let is_rustc_private = stab.feature.as_deref() == Some(\"rustc_private\");\n-\n-        let mut message = if is_rustc_private {\n-            \"<span class='emoji'>\u2699\ufe0f</span> This is an internal compiler API.\"\n-        } else {\n-            \"<span class='emoji'>\ud83d\udd2c</span> This is a nightly-only experimental API.\"\n-        }\n-        .to_owned();\n+    // Render unstable items. But don't render \"rustc_private\" crates (internal compiler crates).\n+    // Those crates are permanently unstable so it makes no sense to render \"unstable\" everywhere.\n+    if let Some(stab) = item.stability.as_ref().filter(|stab| {\n+        stab.level == stability::Unstable && stab.feature.as_deref() != Some(\"rustc_private\")\n+    }) {\n+        let mut message =\n+            \"<span class='emoji'>\ud83d\udd2c</span> This is a nightly-only experimental API.\".to_owned();\n \n         if let Some(feature) = stab.feature.as_deref() {\n             let mut feature = format!(\"<code>{}</code>\", Escape(&feature));\n@@ -2310,17 +2311,6 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n         }\n \n         if let Some(unstable_reason) = &stab.unstable_reason {\n-            // Provide a more informative message than the compiler help.\n-            let unstable_reason = if is_rustc_private {\n-                \"This crate is being loaded from the sysroot, a permanently unstable location \\\n-                for private compiler dependencies. It is not intended for general use. Prefer \\\n-                using a public version of this crate from \\\n-                [crates.io](https://crates.io) via [`Cargo.toml`]\\\n-                (https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html).\"\n-            } else {\n-                unstable_reason\n-            };\n-\n             let mut ids = cx.id_map.borrow_mut();\n             message = format!(\n                 \"<details><summary>{}</summary>{}</details>\",\n@@ -2336,8 +2326,7 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n             );\n         }\n \n-        let class = if is_rustc_private { \"internal\" } else { \"unstable\" };\n-        stability.push(format!(\"<div class='stab {}'>{}</div>\", class, message));\n+        stability.push(format!(\"<div class='stab unstable'>{}</div>\", message));\n     }\n \n     if let Some(ref cfg) = item.attrs.cfg {"}, {"sha": "1326acec51ce19b3f9a08eb280e234a6dc6c5c89", "filename": "src/librustdoc/html/static/themes/ayu.css", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -108,7 +108,7 @@ pre {\n }\n \n .sidebar .version {\n-\tborder-bottom-color: #DDD;\n+\tborder-bottom-color: #424c57;\n }\n \n .sidebar-title {\n@@ -198,7 +198,7 @@ pre.rust .comment, pre.rust .doccomment {\n }\n \n nav:not(.sidebar) {\n-\tborder-bottom-color: #e0e0e0;\n+\tborder-bottom-color: #424c57;\n }\n nav.main .current {\n \tborder-top-color: #5c6773;\n@@ -216,33 +216,26 @@ a {\n \tcolor: #39AFD7;\n }\n \n-.stab.internal a {\n-\tcolor: #304FFE;\n-}\n-\n .collapse-toggle {\n \tcolor: #999;\n }\n \n #crate-search {\n \tcolor: #c5c5c5;\n \tbackground-color: #141920;\n-\tborder-radius: 4px;\n-\tbox-shadow: none;\n-\tborder-color: #5c6773;\n+\tbox-shadow: 0 0 0 1px #424c57,0 0 0 2px transparent;\n+\tborder-color: #424c57;\n }\n \n .search-input {\n     color: #ffffff;\n     background-color: #141920;\n-    box-shadow: none;\n+    box-shadow: 0 0 0 1px #424c57,0 0 0 2px transparent;\n     transition: box-shadow 150ms ease-in-out;\n-    border-radius: 4px;\n-    margin-left: 8px;\n }\n \n #crate-search+.search-input:focus {\n-    box-shadow: 0px 6px 20px 0px black;\n+    box-shadow: 0 0 0 1px #148099,0 0 0 2px transparent;\n }\n \n .search-focus:disabled {\n@@ -254,7 +247,6 @@ a {\n }\n \n .stab.unstable,\n-.stab.internal,\n .stab.deprecated,\n .stab.portability {\n     color: #c5c5c5;\n@@ -462,7 +454,6 @@ pre.rust .doccomment {}\n .content .highlighted.type {}\n pre.rust .kw-2,pre.rust .prelude-ty {}\n .content span.trait,.content a.trait,.block a.current.trait {}\n-.stab.internal {}\n \n @media (max-width: 700px) {\n \t.sidebar-menu {"}, {"sha": "dc15220aa0690b6572c3f724a0247ca1e733b209", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -172,10 +172,6 @@ a {\n \tcolor: #D2991D;\n }\n \n-.stab.internal a {\n-\tcolor: #304FFE;\n-}\n-\n a.test-arrow {\n \tcolor: #dedede;\n }\n@@ -214,7 +210,6 @@ a.test-arrow {\n }\n \n .stab.unstable { background: #FFF5D6; border-color: #FFC600; color: #2f2f2f; }\n-.stab.internal { background: #FFB9B3; border-color: #B71C1C; color: #2f2f2f; }\n .stab.deprecated { background: #F3DFFF; border-color: #7F0087; color: #2f2f2f; }\n .stab.portability { background: #C4ECFF; border-color: #7BA5DB; color: #2f2f2f; }\n "}, {"sha": "64d59ca411a87eafb543407319c3fbdad6081a4a", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -173,10 +173,6 @@ a {\n \tcolor: #3873AD;\n }\n \n-.stab.internal a {\n-\tcolor: #304FFE;\n-}\n-\n a.test-arrow {\n \tcolor: #f5f5f5;\n }\n@@ -215,7 +211,6 @@ a.test-arrow {\n }\n \n .stab.unstable { background: #FFF5D6; border-color: #FFC600; }\n-.stab.internal { background: #FFB9B3; border-color: #B71C1C; }\n .stab.deprecated { background: #F3DFFF; border-color: #7F0087; }\n .stab.portability { background: #C4ECFF; border-color: #7BA5DB; }\n "}, {"sha": "b1db1328392e7bdbda4c67591ece25a777d14a44", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 46, "deletions": 37, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::def::{\n     Namespace::{self, *},\n     PerNS, Res,\n };\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::DefId;\n use rustc_middle::ty;\n use rustc_resolve::ParentScope;\n use rustc_session::lint;\n@@ -50,7 +50,8 @@ enum ErrorKind {\n \n struct LinkCollector<'a, 'tcx> {\n     cx: &'a DocContext<'tcx>,\n-    mod_ids: Vec<hir::HirId>,\n+    // NOTE: this may not necessarily be a module in the current crate\n+    mod_ids: Vec<DefId>,\n }\n \n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n@@ -62,7 +63,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &self,\n         path_str: &str,\n         current_item: &Option<String>,\n-        module_id: LocalDefId,\n+        module_id: DefId,\n     ) -> Result<(Res, Option<String>), ErrorKind> {\n         let cx = self.cx;\n \n@@ -124,7 +125,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     }\n \n     /// Resolves a string as a macro.\n-    fn macro_resolve(&self, path_str: &str, parent_id: Option<hir::HirId>) -> Option<Res> {\n+    fn macro_resolve(&self, path_str: &str, parent_id: Option<DefId>) -> Option<Res> {\n         let cx = self.cx;\n         let path = ast::Path::from_ident(Ident::from_str(path_str));\n         cx.enter_resolver(|resolver| {\n@@ -142,8 +143,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n                 return Some(res.map_id(|_| panic!(\"unexpected id\")));\n             }\n-            if let Some(module_id) = parent_id.or(self.mod_ids.last().cloned()) {\n-                let module_id = cx.tcx.hir().local_def_id(module_id);\n+            if let Some(module_id) = parent_id {\n                 if let Ok((_, res)) =\n                     resolver.resolve_str_path_error(DUMMY_SP, path_str, MacroNS, module_id)\n                 {\n@@ -167,15 +167,14 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         disambiguator: Option<&str>,\n         ns: Namespace,\n         current_item: &Option<String>,\n-        parent_id: Option<hir::HirId>,\n+        parent_id: Option<DefId>,\n         extra_fragment: &Option<String>,\n         item_opt: Option<&Item>,\n     ) -> Result<(Res, Option<String>), ErrorKind> {\n         let cx = self.cx;\n \n         // In case we're in a module, try to resolve the relative path.\n-        if let Some(module_id) = parent_id.or(self.mod_ids.last().cloned()) {\n-            let module_id = cx.tcx.hir().local_def_id(module_id);\n+        if let Some(module_id) = parent_id {\n             let result = cx.enter_resolver(|resolver| {\n                 resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n             });\n@@ -445,40 +444,40 @@ fn is_derive_trait_collision<T>(ns: &PerNS<Option<(Res, T)>>) -> bool {\n \n impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n-        let item_hir_id = if item.is_mod() {\n-            if let Some(def_id) = item.def_id.as_local() {\n-                Some(self.cx.tcx.hir().as_local_hir_id(def_id))\n-            } else {\n-                debug!(\"attempting to fold on a non-local item: {:?}\", item);\n-                return self.fold_item_recur(item);\n-            }\n-        } else {\n-            None\n-        };\n+        use rustc_middle::ty::DefIdTree;\n \n-        // FIXME: get the resolver to work with non-local resolve scopes.\n-        let parent_node = self.cx.as_local_hir_id(item.def_id).and_then(|hir_id| {\n-            // FIXME: this fails hard for impls in non-module scope, but is necessary for the\n-            // current `resolve()` implementation.\n-            match self.cx.as_local_hir_id(self.cx.tcx.parent_module(hir_id).to_def_id()).unwrap() {\n-                id if id != hir_id => Some(id),\n-                _ => None,\n+        let parent_node = if item.is_fake() {\n+            // FIXME: is this correct?\n+            None\n+        } else {\n+            let mut current = item.def_id;\n+            // The immediate parent might not always be a module.\n+            // Find the first parent which is.\n+            loop {\n+                if let Some(parent) = self.cx.tcx.parent(current) {\n+                    if self.cx.tcx.def_kind(parent) == DefKind::Mod {\n+                        break Some(parent);\n+                    }\n+                    current = parent;\n+                } else {\n+                    break None;\n+                }\n             }\n-        });\n+        };\n \n         if parent_node.is_some() {\n-            debug!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n+            trace!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n         }\n \n         let current_item = match item.inner {\n             ModuleItem(..) => {\n                 if item.attrs.inner_docs {\n-                    if item_hir_id.unwrap() != hir::CRATE_HIR_ID { item.name.clone() } else { None }\n+                    if item.def_id.is_top_level_module() { item.name.clone() } else { None }\n                 } else {\n-                    match parent_node.or(self.mod_ids.last().cloned()) {\n-                        Some(parent) if parent != hir::CRATE_HIR_ID => {\n+                    match parent_node.or(self.mod_ids.last().copied()) {\n+                        Some(parent) if !parent.is_top_level_module() => {\n                             // FIXME: can we pull the parent module's name from elsewhere?\n-                            Some(self.cx.tcx.hir().name(parent).to_string())\n+                            Some(self.cx.tcx.item_name(parent).to_string())\n                         }\n                         _ => None,\n                     }\n@@ -488,18 +487,22 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 for_.def_id().map(|did| self.cx.tcx.item_name(did).to_string())\n             }\n             // we don't display docs on `extern crate` items anyway, so don't process them.\n-            ExternCrateItem(..) => return self.fold_item_recur(item),\n+            ExternCrateItem(..) => {\n+                debug!(\"ignoring extern crate item {:?}\", item.def_id);\n+                return self.fold_item_recur(item);\n+            }\n             ImportItem(Import::Simple(ref name, ..)) => Some(name.clone()),\n             MacroItem(..) => None,\n             _ => item.name.clone(),\n         };\n \n         if item.is_mod() && item.attrs.inner_docs {\n-            self.mod_ids.push(item_hir_id.unwrap());\n+            self.mod_ids.push(item.def_id);\n         }\n \n         let cx = self.cx;\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_else(String::new);\n+        trace!(\"got documentation '{}'\", dox);\n \n         look_for_tests(&cx, &dox, &item, true);\n \n@@ -541,6 +544,8 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         });\n \n         for (ori_link, link_range) in markdown_links(&dox) {\n+            trace!(\"considering link '{}'\", ori_link);\n+\n             // Bail early for real links.\n             if ori_link.contains('/') {\n                 continue;\n@@ -641,8 +646,11 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 // we've already pushed this node onto the resolution stack but\n                 // for outer comments we explicitly try and resolve against the\n                 // parent_node first.\n-                let base_node =\n-                    if item.is_mod() && item.attrs.inner_docs { None } else { parent_node };\n+                let base_node = if item.is_mod() && item.attrs.inner_docs {\n+                    self.mod_ids.last().copied()\n+                } else {\n+                    parent_node\n+                };\n \n                 // replace `Self` with suitable item's parent name\n                 if path_str.starts_with(\"Self::\") {\n@@ -826,7 +834,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         }\n \n         if item.is_mod() && !item.attrs.inner_docs {\n-            self.mod_ids.push(item_hir_id.unwrap());\n+            self.mod_ids.push(item.def_id);\n         }\n \n         if item.is_mod() {\n@@ -864,6 +872,7 @@ fn build_diagnostic(\n         Some(hir_id) => hir_id,\n         None => {\n             // If non-local, no need to check anything.\n+            info!(\"ignoring warning from parent crate: {}\", err_msg);\n             return;\n         }\n     };"}, {"sha": "eb2753d62457a6fab85f31ec5e9337240387fd98", "filename": "src/libstd/build.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -62,5 +62,29 @@ fn main() {\n         }\n         println!(\"cargo:rustc-link-lib=c\");\n         println!(\"cargo:rustc-link-lib=compiler_rt\");\n+    } else if (target.contains(\"sgx\") && target.contains(\"fortanix\"))\n+        || target.contains(\"hermit\")\n+        || target.contains(\"l4re\")\n+        || target.contains(\"redox\")\n+        || target.contains(\"haiku\")\n+        || target.contains(\"vxworks\")\n+        || target.contains(\"wasm32\")\n+        || target.contains(\"asmjs\")\n+    {\n+        // These platforms don't have any special requirements.\n+    } else {\n+        // This is for Cargo's build-std support, to mark std as unstable for\n+        // typically no_std platforms.\n+        // This covers:\n+        // - os=none (\"bare metal\" targets)\n+        // - mipsel-sony-psp\n+        // - nvptx64-nvidia-cuda\n+        // - avr-unknown-unknown\n+        // - tvos (aarch64-apple-tvos, x86_64-apple-tvos)\n+        // - uefi (x86_64-unknown-uefi, i686-unknown-uefi)\n+        // - JSON targets\n+        // - Any new targets that have not been explicitly added above.\n+        println!(\"cargo:rustc-cfg=feature=\\\"restricted-std\\\"\");\n     }\n+    println!(\"cargo:rustc-env=STD_ENV_ARCH={}\", env::var(\"CARGO_CFG_TARGET_ARCH\").unwrap());\n }"}, {"sha": "6489e0709cb91f8dec8d51f3a61d3709c1bfef87", "filename": "src/libstd/env.rs", "status": "modified", "additions": 1, "deletions": 76, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -882,7 +882,7 @@ pub mod consts {\n     /// - s390x\n     /// - sparc64\n     #[stable(feature = \"env\", since = \"1.0.0\")]\n-    pub const ARCH: &str = super::arch::ARCH;\n+    pub const ARCH: &str = env!(\"STD_ENV_ARCH\");\n \n     /// The family of the operating system. Example value is `unix`.\n     ///\n@@ -966,81 +966,6 @@ pub mod consts {\n     pub const EXE_EXTENSION: &str = os::EXE_EXTENSION;\n }\n \n-#[cfg(target_arch = \"x86\")]\n-mod arch {\n-    pub const ARCH: &str = \"x86\";\n-}\n-\n-#[cfg(target_arch = \"x86_64\")]\n-mod arch {\n-    pub const ARCH: &str = \"x86_64\";\n-}\n-\n-#[cfg(target_arch = \"arm\")]\n-mod arch {\n-    pub const ARCH: &str = \"arm\";\n-}\n-\n-#[cfg(target_arch = \"aarch64\")]\n-mod arch {\n-    pub const ARCH: &str = \"aarch64\";\n-}\n-\n-#[cfg(target_arch = \"mips\")]\n-mod arch {\n-    pub const ARCH: &str = \"mips\";\n-}\n-\n-#[cfg(target_arch = \"mips64\")]\n-mod arch {\n-    pub const ARCH: &str = \"mips64\";\n-}\n-\n-#[cfg(target_arch = \"powerpc\")]\n-mod arch {\n-    pub const ARCH: &str = \"powerpc\";\n-}\n-\n-#[cfg(target_arch = \"powerpc64\")]\n-mod arch {\n-    pub const ARCH: &str = \"powerpc64\";\n-}\n-\n-#[cfg(target_arch = \"s390x\")]\n-mod arch {\n-    pub const ARCH: &str = \"s390x\";\n-}\n-\n-#[cfg(target_arch = \"sparc64\")]\n-mod arch {\n-    pub const ARCH: &str = \"sparc64\";\n-}\n-\n-#[cfg(target_arch = \"le32\")]\n-mod arch {\n-    pub const ARCH: &str = \"le32\";\n-}\n-\n-#[cfg(target_arch = \"asmjs\")]\n-mod arch {\n-    pub const ARCH: &str = \"asmjs\";\n-}\n-\n-#[cfg(target_arch = \"wasm32\")]\n-mod arch {\n-    pub const ARCH: &str = \"wasm32\";\n-}\n-\n-#[cfg(target_arch = \"hexagon\")]\n-mod arch {\n-    pub const ARCH: &'static str = \"hexagon\";\n-}\n-\n-#[cfg(target_arch = \"riscv64\")]\n-mod arch {\n-    pub const ARCH: &'static str = \"riscv64\";\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "b5ba0da7ae50dc494b640c2d8fea2229315757b4", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -198,7 +198,8 @@\n //! [primitive types]: ../book/ch03-02-data-types.html\n //! [rust-discord]: https://discord.gg/rust-lang\n \n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![cfg_attr(not(feature = \"restricted-std\"), stable(feature = \"rust1\", since = \"1.0.0\"))]\n+#![cfg_attr(feature = \"restricted-std\", unstable(feature = \"restricted_std\", issue = \"none\"))]\n #![doc(\n     html_root_url = \"https://doc.rust-lang.org/nightly/\",\n     html_playground_url = \"https://play.rust-lang.org/\",\n@@ -554,3 +555,9 @@ include!(\"primitive_docs.rs\");\n // the rustdoc documentation for the existing keywords. Using `include!`\n // because rustdoc only looks for these modules at the crate level.\n include!(\"keyword_docs.rs\");\n+\n+// This is required to avoid an unstable error when `restricted-std` is not\n+// enabled. The use of #![feature(restricted_std)] in rustc-std-workspace-std\n+// is unconditional, so the unstable feature needs to be defined somewhere.\n+#[cfg_attr(not(feature = \"restricted-std\"), unstable(feature = \"restricted_std\", issue = \"none\"))]\n+mod __restricted_std_workaround {}"}, {"sha": "9b90bfd68b50f3047ec1ee6e01245efe98311a11", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -694,7 +694,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn wait_timeout_wait() {\n         let m = Arc::new(Mutex::new(()));\n         let c = Arc::new(Condvar::new());\n@@ -714,7 +713,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn wait_timeout_while_wait() {\n         let m = Arc::new(Mutex::new(()));\n         let c = Arc::new(Condvar::new());\n@@ -739,7 +737,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn wait_timeout_while_wake() {\n         let pair = Arc::new((Mutex::new(false), Condvar::new()));\n         let pair_copy = pair.clone();\n@@ -763,7 +760,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn wait_timeout_wake() {\n         let m = Arc::new(Mutex::new(()));\n         let c = Arc::new(Condvar::new());"}, {"sha": "3ff50e9f213477716e1f39447a5d4451ca2cfc62", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -2088,7 +2088,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn oneshot_single_thread_recv_timeout() {\n         let (tx, rx) = channel();\n         tx.send(()).unwrap();\n@@ -2099,7 +2098,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn stress_recv_timeout_two_threads() {\n         let (tx, rx) = channel();\n         let stress = stress_factor() + 100;\n@@ -2130,7 +2128,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn recv_timeout_upgrade() {\n         let (tx, rx) = channel::<()>();\n         let timeout = Duration::from_millis(1);\n@@ -2142,7 +2139,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn stress_recv_timeout_shared() {\n         let (tx, rx) = channel();\n         let stress = stress_factor() + 100;\n@@ -2173,7 +2169,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn very_long_recv_timeout_wont_panic() {\n         let (tx, rx) = channel::<()>();\n         let join_handle = thread::spawn(move || rx.recv_timeout(Duration::from_secs(u64::MAX)));\n@@ -2195,7 +2190,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn shared_recv_timeout() {\n         let (tx, rx) = channel();\n         let total = 5;\n@@ -2425,7 +2419,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn recv_timeout() {\n         let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(rx.recv_timeout(Duration::from_millis(1)), Err(RecvTimeoutError::Timeout));\n@@ -2517,7 +2510,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn stress_recv_timeout_two_threads() {\n         let (tx, rx) = sync_channel::<i32>(0);\n \n@@ -2543,7 +2535,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn stress_recv_timeout_shared() {\n         const AMT: u32 = 1000;\n         const NTHREADS: u32 = 8;"}, {"sha": "7b5fac922d08a77151677b65d6118ccbb59f8881", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -48,7 +48,8 @@ cfg_if::cfg_if! {\n         mod sgx;\n         pub use self::sgx::*;\n     } else {\n-        compile_error!(\"libstd doesn't compile for this platform yet\");\n+        mod unsupported;\n+        pub use self::unsupported::*;\n     }\n }\n "}, {"sha": "73f1b951e74304b0d406ba631e0f9c26896fac79", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 89, "deletions": 3, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -1,6 +1,8 @@\n use crate::cmp;\n-use crate::io::{Error as IoError, IoSlice, IoSliceMut, Result as IoResult};\n-use crate::time::Duration;\n+use crate::convert::TryFrom;\n+use crate::io::{Error as IoError, ErrorKind, IoSlice, IoSliceMut, Result as IoResult};\n+use crate::sys::rand::rdrand64;\n+use crate::time::{Duration, Instant};\n \n pub(crate) mod alloc;\n #[macro_use]\n@@ -149,10 +151,94 @@ pub fn exit(panic: bool) -> ! {\n \n /// Usercall `wait`. See the ABI documentation for more information.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-pub fn wait(event_mask: u64, timeout: u64) -> IoResult<u64> {\n+pub fn wait(event_mask: u64, mut timeout: u64) -> IoResult<u64> {\n+    if timeout != WAIT_NO && timeout != WAIT_INDEFINITE {\n+        // We don't want people to rely on accuracy of timeouts to make\n+        // security decisions in an SGX enclave. That's why we add a random\n+        // amount not exceeding +/- 10% to the timeout value to discourage\n+        // people from relying on accuracy of timeouts while providing a way\n+        // to make things work in other cases. Note that in the SGX threat\n+        // model the enclave runner which is serving the wait usercall is not\n+        // trusted to ensure accurate timeouts.\n+        if let Ok(timeout_signed) = i64::try_from(timeout) {\n+            let tenth = timeout_signed / 10;\n+            let deviation = (rdrand64() as i64).checked_rem(tenth).unwrap_or(0);\n+            timeout = timeout_signed.saturating_add(deviation) as _;\n+        }\n+    }\n     unsafe { raw::wait(event_mask, timeout).from_sgx_result() }\n }\n \n+/// This function makes an effort to wait for a non-spurious event at least as\n+/// long as `duration`. Note that in general there is no guarantee about accuracy\n+/// of time and timeouts in SGX model. The enclave runner serving usercalls may\n+/// lie about current time and/or ignore timeout values.\n+///\n+/// Once the event is observed, `should_wake_up` will be used to determine\n+/// whether or not the event was spurious.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub fn wait_timeout<F>(event_mask: u64, duration: Duration, should_wake_up: F)\n+where\n+    F: Fn() -> bool,\n+{\n+    // Calls the wait usercall and checks the result. Returns true if event was\n+    // returned, and false if WouldBlock/TimedOut was returned.\n+    // If duration is None, it will use WAIT_NO.\n+    fn wait_checked(event_mask: u64, duration: Option<Duration>) -> bool {\n+        let timeout = duration.map_or(raw::WAIT_NO, |duration| {\n+            cmp::min((u64::MAX - 1) as u128, duration.as_nanos()) as u64\n+        });\n+        match wait(event_mask, timeout) {\n+            Ok(eventset) => {\n+                if event_mask == 0 {\n+                    rtabort!(\"expected wait() to return Err, found Ok.\");\n+                }\n+                rtassert!(eventset != 0 && eventset & !event_mask == 0);\n+                true\n+            }\n+            Err(e) => {\n+                rtassert!(e.kind() == ErrorKind::TimedOut || e.kind() == ErrorKind::WouldBlock);\n+                false\n+            }\n+        }\n+    }\n+\n+    match wait_checked(event_mask, Some(duration)) {\n+        false => return,                    // timed out\n+        true if should_wake_up() => return, // woken up\n+        true => {}                          // spurious event\n+    }\n+\n+    // Drain all cached events.\n+    // Note that `event_mask != 0` is implied if we get here.\n+    loop {\n+        match wait_checked(event_mask, None) {\n+            false => break,                     // no more cached events\n+            true if should_wake_up() => return, // woken up\n+            true => {}                          // spurious event\n+        }\n+    }\n+\n+    // Continue waiting, but take note of time spent waiting so we don't wait\n+    // forever. We intentionally don't call `Instant::now()` before this point\n+    // to avoid the cost of the `insecure_time` usercall in case there are no\n+    // spurious wakeups.\n+\n+    let start = Instant::now();\n+    let mut remaining = duration;\n+    loop {\n+        match wait_checked(event_mask, Some(remaining)) {\n+            false => return,                    // timed out\n+            true if should_wake_up() => return, // woken up\n+            true => {}                          // spurious event\n+        }\n+        remaining = match duration.checked_sub(start.elapsed()) {\n+            Some(remaining) => remaining,\n+            None => break,\n+        }\n+    }\n+}\n+\n /// Usercall `send`. See the ABI documentation for more information.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn send(event_set: u64, tcs: Option<Tcs>) -> IoResult<()> {"}, {"sha": "ed6dbcf497147f68834e71a85bdad2165fc50f6c", "filename": "src/libstd/sys/sgx/condvar.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -31,8 +31,10 @@ impl Condvar {\n         mutex.lock()\n     }\n \n-    pub unsafe fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n-        rtabort!(\"timeout not supported in SGX\");\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n+        let success = WaitQueue::wait_timeout(&self.inner, dur, || mutex.unlock());\n+        mutex.lock();\n+        success\n     }\n \n     #[inline]"}, {"sha": "1d32eb25424345578d63d378ad1fa3c9d463f4db", "filename": "src/libstd/sys/sgx/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -137,8 +137,8 @@ pub extern \"C\" fn __rust_abort() {\n     abort_internal();\n }\n \n-pub fn hashmap_random_keys() -> (u64, u64) {\n-    fn rdrand64() -> u64 {\n+pub mod rand {\n+    pub fn rdrand64() -> u64 {\n         unsafe {\n             let mut ret: u64 = 0;\n             for _ in 0..10 {\n@@ -149,7 +149,10 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n             rtabort!(\"Failed to obtain random data\");\n         }\n     }\n-    (rdrand64(), rdrand64())\n+}\n+\n+pub fn hashmap_random_keys() -> (u64, u64) {\n+    (self::rand::rdrand64(), self::rand::rdrand64())\n }\n \n pub use crate::sys_common::{AsInner, FromInner, IntoInner};"}, {"sha": "5895f70436efa4a6f36547fd36e24fb0bffd048f", "filename": "src/libstd/sys/sgx/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -73,8 +73,8 @@ impl Thread {\n         // FIXME: could store this pointer in TLS somewhere\n     }\n \n-    pub fn sleep(_dur: Duration) {\n-        rtabort!(\"can't sleep\"); // FIXME\n+    pub fn sleep(dur: Duration) {\n+        usercalls::wait_timeout(0, dur, || true);\n     }\n \n     pub fn join(self) {"}, {"sha": "070afa55f301927e3d5f7ac429a5fb930e3c595c", "filename": "src/libstd/sys/sgx/waitqueue.rs", "status": "modified", "additions": 112, "deletions": 17, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -1,16 +1,17 @@\n+//! A simple queue implementation for synchronization primitives.\n+//!\n+//! This queue is used to implement condition variable and mutexes.\n+//!\n+//! Users of this API are expected to use the `WaitVariable<T>` type. Since\n+//! that type is not `Sync`, it needs to be protected by e.g., a `SpinMutex` to\n+//! allow shared access.\n+//!\n+//! Since userspace may send spurious wake-ups, the wakeup event state is\n+//! recorded in the enclave. The wakeup event state is protected by a spinlock.\n+//! The queue and associated wait state are stored in a `WaitVariable`.\n use crate::num::NonZeroUsize;\n-/// A simple queue implementation for synchronization primitives.\n-///\n-/// This queue is used to implement condition variable and mutexes.\n-///\n-/// Users of this API are expected to use the `WaitVariable<T>` type. Since\n-/// that type is not `Sync`, it needs to be protected by e.g., a `SpinMutex` to\n-/// allow shared access.\n-///\n-/// Since userspace may send spurious wake-ups, the wakeup event state is\n-/// recorded in the enclave. The wakeup event state is protected by a spinlock.\n-/// The queue and associated wait state are stored in a `WaitVariable`.\n use crate::ops::{Deref, DerefMut};\n+use crate::time::Duration;\n \n use super::abi::thread;\n use super::abi::usercalls;\n@@ -158,6 +159,34 @@ impl WaitQueue {\n         }\n     }\n \n+    /// Adds the calling thread to the `WaitVariable`'s wait queue, then wait\n+    /// until a wakeup event or timeout. If event was observed, returns true.\n+    /// If not, it will remove the calling thread from the wait queue.\n+    pub fn wait_timeout<T, F: FnOnce()>(\n+        lock: &SpinMutex<WaitVariable<T>>,\n+        timeout: Duration,\n+        before_wait: F,\n+    ) -> bool {\n+        // very unsafe: check requirements of UnsafeList::push\n+        unsafe {\n+            let mut entry = UnsafeListEntry::new(SpinMutex::new(WaitEntry {\n+                tcs: thread::current(),\n+                wake: false,\n+            }));\n+            let entry_lock = lock.lock().queue.inner.push(&mut entry);\n+            before_wait();\n+            usercalls::wait_timeout(EV_UNPARK, timeout, || entry_lock.lock().wake);\n+            // acquire the wait queue's lock first to avoid deadlock.\n+            let mut guard = lock.lock();\n+            let success = entry_lock.lock().wake;\n+            if !success {\n+                // nobody is waking us up, so remove our entry from the wait queue.\n+                guard.queue.inner.remove(&mut entry);\n+            }\n+            success\n+        }\n+    }\n+\n     /// Either find the next waiter on the wait queue, or return the mutex\n     /// guard unchanged.\n     ///\n@@ -325,6 +354,31 @@ mod unsafe_list {\n                 Some((*first.as_ptr()).value.as_ref().unwrap())\n             }\n         }\n+\n+        /// Removes an entry from the list.\n+        ///\n+        /// # Safety\n+        ///\n+        /// The caller must ensure that `entry` has been pushed onto `self`\n+        /// prior to this call and has not moved since then.\n+        pub unsafe fn remove(&mut self, entry: &mut UnsafeListEntry<T>) {\n+            rtassert!(!self.is_empty());\n+            // BEFORE:\n+            //     /----\\ next ---> /-----\\ next ---> /----\\\n+            // ... |prev|           |entry|           |next| ...\n+            //     \\----/ <--- prev \\-----/ <--- prev \\----/\n+            //\n+            // AFTER:\n+            //     /----\\ next ---> /----\\\n+            // ... |prev|           |next| ...\n+            //     \\----/ <--- prev \\----/\n+            let mut prev = entry.prev;\n+            let mut next = entry.next;\n+            prev.as_mut().next = next;\n+            next.as_mut().prev = prev;\n+            entry.next = NonNull::dangling();\n+            entry.prev = NonNull::dangling();\n+        }\n     }\n \n     #[cfg(test)]\n@@ -354,6 +408,51 @@ mod unsafe_list {\n             }\n         }\n \n+        #[test]\n+        fn push_remove() {\n+            unsafe {\n+                let mut node = UnsafeListEntry::new(1234);\n+                let mut list = UnsafeList::new();\n+                assert_eq!(list.push(&mut node), &1234);\n+                list.remove(&mut node);\n+                assert_empty(&mut list);\n+            }\n+        }\n+\n+        #[test]\n+        fn push_remove_pop() {\n+            unsafe {\n+                let mut node1 = UnsafeListEntry::new(11);\n+                let mut node2 = UnsafeListEntry::new(12);\n+                let mut node3 = UnsafeListEntry::new(13);\n+                let mut node4 = UnsafeListEntry::new(14);\n+                let mut node5 = UnsafeListEntry::new(15);\n+                let mut list = UnsafeList::new();\n+                assert_eq!(list.push(&mut node1), &11);\n+                assert_eq!(list.push(&mut node2), &12);\n+                assert_eq!(list.push(&mut node3), &13);\n+                assert_eq!(list.push(&mut node4), &14);\n+                assert_eq!(list.push(&mut node5), &15);\n+\n+                list.remove(&mut node1);\n+                assert_eq!(list.pop().unwrap(), &12);\n+                list.remove(&mut node3);\n+                assert_eq!(list.pop().unwrap(), &14);\n+                list.remove(&mut node5);\n+                assert_empty(&mut list);\n+\n+                assert_eq!(list.push(&mut node1), &11);\n+                assert_eq!(list.pop().unwrap(), &11);\n+                assert_empty(&mut list);\n+\n+                assert_eq!(list.push(&mut node3), &13);\n+                assert_eq!(list.push(&mut node4), &14);\n+                list.remove(&mut node3);\n+                list.remove(&mut node4);\n+                assert_empty(&mut list);\n+            }\n+        }\n+\n         #[test]\n         fn complex_pushes_pops() {\n             unsafe {\n@@ -474,7 +573,7 @@ mod spin_mutex {\n         use super::*;\n         use crate::sync::Arc;\n         use crate::thread;\n-        use crate::time::{Duration, SystemTime};\n+        use crate::time::Duration;\n \n         #[test]\n         fn sleep() {\n@@ -485,11 +584,7 @@ mod spin_mutex {\n                 *mutex2.lock() = 1;\n             });\n \n-            // \"sleep\" for 50ms\n-            // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n-            let start = SystemTime::now();\n-            let max = Duration::from_millis(50);\n-            while start.elapsed().unwrap() < max {}\n+            thread::sleep(Duration::from_millis(50));\n \n             assert_eq!(*guard, 0);\n             drop(guard);"}, {"sha": "8d5d0a2f5ccd165987274b961b30887804b34045", "filename": "src/libstd/sys/unsupported/alloc.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Falloc.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,22 @@\n+use crate::alloc::{GlobalAlloc, Layout, System};\n+\n+#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+unsafe impl GlobalAlloc for System {\n+    #[inline]\n+    unsafe fn alloc(&self, _layout: Layout) -> *mut u8 {\n+        0 as *mut u8\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_zeroed(&self, _layout: Layout) -> *mut u8 {\n+        0 as *mut u8\n+    }\n+\n+    #[inline]\n+    unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {}\n+\n+    #[inline]\n+    unsafe fn realloc(&self, _ptr: *mut u8, _layout: Layout, _new_size: usize) -> *mut u8 {\n+        0 as *mut u8\n+    }\n+}"}, {"sha": "71d0c5fa13e18a1a6167cec35eb34317c3829df6", "filename": "src/libstd/sys/unsupported/args.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Fargs.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,38 @@\n+use crate::ffi::OsString;\n+\n+pub unsafe fn init(_argc: isize, _argv: *const *const u8) {}\n+pub unsafe fn cleanup() {}\n+\n+pub struct Args {}\n+\n+pub fn args() -> Args {\n+    Args {}\n+}\n+\n+impl Args {\n+    pub fn inner_debug(&self) -> &[OsString] {\n+        &[]\n+    }\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> {\n+        None\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(0))\n+    }\n+}\n+\n+impl ExactSizeIterator for Args {\n+    fn len(&self) -> usize {\n+        0\n+    }\n+}\n+\n+impl DoubleEndedIterator for Args {\n+    fn next_back(&mut self) -> Option<OsString> {\n+        None\n+    }\n+}"}, {"sha": "304cf906b2aeadba92007440bb5628e3c9ed8184", "filename": "src/libstd/sys/unsupported/cmath.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Fcmath.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "previous_filename": "src/libstd/sys/wasm/cmath.rs"}, {"sha": "80311d26819ad6166d44c20da3be670a36ccda67", "filename": "src/libstd/sys/unsupported/common.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Fcommon.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,48 @@\n+use crate::io as std_io;\n+\n+pub mod memchr {\n+    pub use core::slice::memchr::{memchr, memrchr};\n+}\n+\n+pub use crate::sys_common::os_str_bytes as os_str;\n+\n+// This is not necessarily correct. May want to consider making it part of the\n+// spec definition?\n+use crate::os::raw::c_char;\n+\n+#[cfg(not(test))]\n+pub fn init() {}\n+\n+pub fn unsupported<T>() -> std_io::Result<T> {\n+    Err(unsupported_err())\n+}\n+\n+pub fn unsupported_err() -> std_io::Error {\n+    std_io::Error::new(std_io::ErrorKind::Other, \"operation not supported on this platform\")\n+}\n+\n+pub fn decode_error_kind(_code: i32) -> crate::io::ErrorKind {\n+    crate::io::ErrorKind::Other\n+}\n+\n+pub fn abort_internal() -> ! {\n+    core::intrinsics::abort();\n+}\n+\n+pub fn hashmap_random_keys() -> (u64, u64) {\n+    (1, 2)\n+}\n+\n+// This enum is used as the storage for a bunch of types which can't actually\n+// exist.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub enum Void {}\n+\n+pub unsafe fn strlen(mut s: *const c_char) -> usize {\n+    let mut n = 0;\n+    while *s != 0 {\n+        n += 1;\n+        s = s.offset(1);\n+    }\n+    return n;\n+}"}, {"sha": "a578eee8ccce2a121809f814aee7dfadea286f52", "filename": "src/libstd/sys/unsupported/condvar.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Fcondvar.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -18,11 +18,11 @@ impl Condvar {\n     pub unsafe fn notify_all(&self) {}\n \n     pub unsafe fn wait(&self, _mutex: &Mutex) {\n-        panic!(\"can't block with web assembly\")\n+        panic!(\"condvar wait not supported\")\n     }\n \n     pub unsafe fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n-        panic!(\"can't block with web assembly\");\n+        panic!(\"condvar wait not supported\");\n     }\n \n     #[inline]", "previous_filename": "src/libstd/sys/wasm/condvar.rs"}, {"sha": "d2efec506c56bb25222113224bc919137fa37823", "filename": "src/libstd/sys/unsupported/env.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Fenv.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,9 @@\n+pub mod os {\n+    pub const FAMILY: &str = \"\";\n+    pub const OS: &str = \"\";\n+    pub const DLL_PREFIX: &str = \"\";\n+    pub const DLL_SUFFIX: &str = \"\";\n+    pub const DLL_EXTENSION: &str = \"\";\n+    pub const EXE_SUFFIX: &str = \"\";\n+    pub const EXE_EXTENSION: &str = \"\";\n+}"}, {"sha": "ecb5b51cccdcd965d85e9ee8e22ecb878d876719", "filename": "src/libstd/sys/unsupported/fs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Ffs.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "previous_filename": "src/libstd/sys/wasm/fs.rs"}, {"sha": "d5f475b4310fde64b7f0f50154c14d345ce3788f", "filename": "src/libstd/sys/unsupported/io.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Fio.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "previous_filename": "src/libstd/sys/wasm/io.rs"}, {"sha": "87f655eecd54e74a33bde42e0b88d1a85a144d19", "filename": "src/libstd/sys/unsupported/mod.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Fmod.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,24 @@\n+pub mod alloc;\n+pub mod args;\n+pub mod cmath;\n+pub mod condvar;\n+pub mod env;\n+pub mod fs;\n+pub mod io;\n+pub mod mutex;\n+pub mod net;\n+pub mod os;\n+pub mod path;\n+pub mod pipe;\n+pub mod process;\n+pub mod rwlock;\n+pub mod stack_overflow;\n+pub mod stdio;\n+pub mod thread;\n+#[cfg(target_thread_local)]\n+pub mod thread_local_dtor;\n+pub mod thread_local_key;\n+pub mod time;\n+\n+mod common;\n+pub use common::*;"}, {"sha": "9ef8af52eb5c247235557b5f2dc93f1cd7030dec", "filename": "src/libstd/sys/unsupported/mutex.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Fmutex.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -5,9 +5,10 @@ pub struct Mutex {\n }\n \n unsafe impl Send for Mutex {}\n-unsafe impl Sync for Mutex {} // no threads on wasm\n+unsafe impl Sync for Mutex {} // no threads on this platform\n \n impl Mutex {\n+    #[rustc_const_stable(feature = \"const_sys_mutex_new\", since = \"1.0.0\")]\n     pub const fn new() -> Mutex {\n         Mutex { locked: UnsafeCell::new(false) }\n     }\n@@ -42,8 +43,8 @@ impl Mutex {\n     pub unsafe fn destroy(&self) {}\n }\n \n-// All empty stubs because wasm has no threads yet, so lock acquisition always\n-// succeeds.\n+// All empty stubs because this platform does not yet support threads, so lock\n+// acquisition always succeeds.\n pub struct ReentrantMutex {}\n \n impl ReentrantMutex {", "previous_filename": "src/libstd/sys/wasm/mutex.rs"}, {"sha": "5c9f1098f9b7f0e8422840ffcce0a91d5ae1223b", "filename": "src/libstd/sys/unsupported/net.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Fnet.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "previous_filename": "src/libstd/sys/wasm/net.rs"}, {"sha": "0615780c242128e7938df11233230533d3c7e219", "filename": "src/libstd/sys/unsupported/os.rs", "status": "renamed", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Fos.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -1,10 +1,9 @@\n+use super::{unsupported, Void};\n use crate::error::Error as StdError;\n use crate::ffi::{OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::path::{self, PathBuf};\n-use crate::str;\n-use crate::sys::{unsupported, Void};\n \n pub fn errno() -> i32 {\n     0\n@@ -48,14 +47,14 @@ where\n \n impl fmt::Display for JoinPathsError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        \"not supported on wasm yet\".fmt(f)\n+        \"not supported on this platform yet\".fmt(f)\n     }\n }\n \n impl StdError for JoinPathsError {\n     #[allow(deprecated)]\n     fn description(&self) -> &str {\n-        \"not supported on wasm yet\"\n+        \"not supported on this platform yet\"\n     }\n }\n \n@@ -73,35 +72,33 @@ impl Iterator for Env {\n }\n \n pub fn env() -> Env {\n-    panic!(\"not supported on web assembly\")\n+    panic!(\"not supported on this platform\")\n }\n \n pub fn getenv(_: &OsStr) -> io::Result<Option<OsString>> {\n     Ok(None)\n }\n \n pub fn setenv(_: &OsStr, _: &OsStr) -> io::Result<()> {\n-    Err(io::Error::new(io::ErrorKind::Other, \"cannot set env vars on wasm32-unknown-unknown\"))\n+    Err(io::Error::new(io::ErrorKind::Other, \"cannot set env vars on this platform\"))\n }\n \n pub fn unsetenv(_: &OsStr) -> io::Result<()> {\n-    Err(io::Error::new(io::ErrorKind::Other, \"cannot unset env vars on wasm32-unknown-unknown\"))\n+    Err(io::Error::new(io::ErrorKind::Other, \"cannot unset env vars on this platform\"))\n }\n \n pub fn temp_dir() -> PathBuf {\n-    panic!(\"no filesystem on wasm\")\n+    panic!(\"no filesystem on this platform\")\n }\n \n pub fn home_dir() -> Option<PathBuf> {\n     None\n }\n \n pub fn exit(_code: i32) -> ! {\n-    unsafe {\n-        crate::arch::wasm32::unreachable();\n-    }\n+    crate::intrinsics::abort()\n }\n \n pub fn getpid() -> u32 {\n-    panic!(\"no pids on wasm\")\n+    panic!(\"no pids on this platform\")\n }", "previous_filename": "src/libstd/sys/wasm/os.rs"}, {"sha": "840a7ae04262508abc1bd81fd78a7f8fd4231363", "filename": "src/libstd/sys/unsupported/path.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Fpath.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "previous_filename": "src/libstd/sys/wasm/path.rs"}, {"sha": "10d0925823eb94660278ce2390c892c093d7e3c6", "filename": "src/libstd/sys/unsupported/pipe.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Fpipe.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "previous_filename": "src/libstd/sys/wasm/pipe.rs"}, {"sha": "4702e5c549228ea27e5c59777cb707b34ea5d248", "filename": "src/libstd/sys/unsupported/process.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Fprocess.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "previous_filename": "src/libstd/sys/wasm/process.rs"}, {"sha": "d37f34ac9352d305f8369a7cc06ca1f5cf9c9e49", "filename": "src/libstd/sys/unsupported/rwlock.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Frwlock.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -5,7 +5,7 @@ pub struct RWLock {\n }\n \n unsafe impl Send for RWLock {}\n-unsafe impl Sync for RWLock {} // no threads on wasm\n+unsafe impl Sync for RWLock {} // no threads on this platform\n \n impl RWLock {\n     pub const fn new() -> RWLock {", "previous_filename": "src/libstd/sys/wasm/rwlock.rs"}, {"sha": "32555394cd5a58fa3f5347bafd85af5f91350aab", "filename": "src/libstd/sys/unsupported/stack_overflow.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Fstack_overflow.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "previous_filename": "src/libstd/sys/wasm/stack_overflow.rs"}, {"sha": "5a4e4505e93bddce1805a1f163e2df0c66bc7cfd", "filename": "src/libstd/sys/unsupported/stdio.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Fstdio.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "previous_filename": "src/libstd/sys/wasm/stdio.rs"}, {"sha": "20ae309db30d7379c29095c4f4f339fd43a9ae71", "filename": "src/libstd/sys/unsupported/thread.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Fthread.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,41 @@\n+use super::{unsupported, Void};\n+use crate::ffi::CStr;\n+use crate::io;\n+use crate::time::Duration;\n+\n+pub struct Thread(Void);\n+\n+pub const DEFAULT_MIN_STACK_SIZE: usize = 4096;\n+\n+impl Thread {\n+    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n+    pub unsafe fn new(_stack: usize, _p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n+        unsupported()\n+    }\n+\n+    pub fn yield_now() {\n+        // do nothing\n+    }\n+\n+    pub fn set_name(_name: &CStr) {\n+        // nope\n+    }\n+\n+    pub fn sleep(_dur: Duration) {\n+        panic!(\"can't sleep\");\n+    }\n+\n+    pub fn join(self) {\n+        match self.0 {}\n+    }\n+}\n+\n+pub mod guard {\n+    pub type Guard = !;\n+    pub unsafe fn current() -> Option<Guard> {\n+        None\n+    }\n+    pub unsafe fn init() -> Option<Guard> {\n+        None\n+    }\n+}"}, {"sha": "85d660983029c830329066a7da06ae20962adb6b", "filename": "src/libstd/sys/unsupported/thread_local_dtor.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fthread_local_dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fthread_local_dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Fthread_local_dtor.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "previous_filename": "src/libstd/sys/wasm/thread_local_dtor.rs"}, {"sha": "c31b61cbf56d386785f2f43e3ce292eb70004232", "filename": "src/libstd/sys/unsupported/thread_local_key.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fthread_local_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Fthread_local_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Fthread_local_key.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -2,25 +2,25 @@ pub type Key = usize;\n \n #[inline]\n pub unsafe fn create(_dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n-    panic!(\"should not be used on the wasm target\");\n+    panic!(\"should not be used on this target\");\n }\n \n #[inline]\n pub unsafe fn set(_key: Key, _value: *mut u8) {\n-    panic!(\"should not be used on the wasm target\");\n+    panic!(\"should not be used on this target\");\n }\n \n #[inline]\n pub unsafe fn get(_key: Key) -> *mut u8 {\n-    panic!(\"should not be used on the wasm target\");\n+    panic!(\"should not be used on this target\");\n }\n \n #[inline]\n pub unsafe fn destroy(_key: Key) {\n-    panic!(\"should not be used on the wasm target\");\n+    panic!(\"should not be used on this target\");\n }\n \n #[inline]\n pub fn requires_synchronized_create() -> bool {\n-    panic!(\"should not be used on the wasm target\");\n+    panic!(\"should not be used on this target\");\n }", "previous_filename": "src/libstd/sys/wasm/thread_local_key.rs"}, {"sha": "8aaf1777f242721db24eb70e917c826e8c13e7e6", "filename": "src/libstd/sys/unsupported/time.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Funsupported%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funsupported%2Ftime.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -10,7 +10,7 @@ pub const UNIX_EPOCH: SystemTime = SystemTime(Duration::from_secs(0));\n \n impl Instant {\n     pub fn now() -> Instant {\n-        panic!(\"time not implemented on wasm32-unknown-unknown\")\n+        panic!(\"time not implemented on this platform\")\n     }\n \n     pub const fn zero() -> Instant {\n@@ -36,7 +36,7 @@ impl Instant {\n \n impl SystemTime {\n     pub fn now() -> SystemTime {\n-        panic!(\"time not implemented on wasm32-unknown-unknown\")\n+        panic!(\"time not implemented on this platform\")\n     }\n \n     pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {", "previous_filename": "src/libstd/sys/wasm/time.rs"}, {"sha": "2704ff484f9911c920329e86ebdb21dbeaf9372e", "filename": "src/libstd/sys/wasi/mod.rs", "status": "modified", "additions": 11, "deletions": 34, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -16,21 +16,18 @@\n \n use crate::io as std_io;\n use crate::mem;\n-use crate::os::raw::c_char;\n \n pub mod alloc;\n pub mod args;\n-#[path = \"../wasm/cmath.rs\"]\n+#[path = \"../unsupported/cmath.rs\"]\n pub mod cmath;\n-#[path = \"../wasm/condvar.rs\"]\n+#[path = \"../unsupported/condvar.rs\"]\n pub mod condvar;\n pub mod env;\n pub mod fd;\n pub mod fs;\n pub mod io;\n-#[path = \"../wasm/memchr.rs\"]\n-pub mod memchr;\n-#[path = \"../wasm/mutex.rs\"]\n+#[path = \"../unsupported/mutex.rs\"]\n pub mod mutex;\n pub mod net;\n pub mod os;\n@@ -39,28 +36,22 @@ pub mod ext;\n pub mod path;\n pub mod pipe;\n pub mod process;\n-#[path = \"../wasm/rwlock.rs\"]\n+#[path = \"../unsupported/rwlock.rs\"]\n pub mod rwlock;\n-#[path = \"../wasm/stack_overflow.rs\"]\n+#[path = \"../unsupported/stack_overflow.rs\"]\n pub mod stack_overflow;\n pub mod stdio;\n pub mod thread;\n-#[path = \"../wasm/thread_local_dtor.rs\"]\n+#[path = \"../unsupported/thread_local_dtor.rs\"]\n pub mod thread_local_dtor;\n-#[path = \"../wasm/thread_local_key.rs\"]\n+#[path = \"../unsupported/thread_local_key.rs\"]\n pub mod thread_local_key;\n pub mod time;\n \n-#[cfg(not(test))]\n-pub fn init() {}\n-\n-pub fn unsupported<T>() -> std_io::Result<T> {\n-    Err(unsupported_err())\n-}\n-\n-pub fn unsupported_err() -> std_io::Error {\n-    std_io::Error::new(std_io::ErrorKind::Other, \"operation not supported on wasm yet\")\n-}\n+#[path = \"../unsupported/common.rs\"]\n+#[allow(unused)]\n+mod common;\n+pub use common::*;\n \n pub fn decode_error_kind(errno: i32) -> std_io::ErrorKind {\n     use std_io::ErrorKind::*;\n@@ -86,20 +77,6 @@ pub fn decode_error_kind(errno: i32) -> std_io::ErrorKind {\n     }\n }\n \n-// This enum is used as the storage for a bunch of types which can't actually\n-// exist.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n-pub enum Void {}\n-\n-pub unsafe fn strlen(mut s: *const c_char) -> usize {\n-    let mut n = 0;\n-    while *s != 0 {\n-        n += 1;\n-        s = s.offset(1);\n-    }\n-    return n;\n-}\n-\n pub fn abort_internal() -> ! {\n     unsafe { libc::abort() }\n }"}, {"sha": "9967482197eb3642a1e1fef3d1cdc04b9c05711d", "filename": "src/libstd/sys/wasm/memchr.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c9e5df3a097e094641f16dab501ab1c4da10e9f/src%2Flibstd%2Fsys%2Fwasm%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9e5df3a097e094641f16dab501ab1c4da10e9f/src%2Flibstd%2Fsys%2Fwasm%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmemchr.rs?ref=5c9e5df3a097e094641f16dab501ab1c4da10e9f", "patch": "@@ -1 +0,0 @@\n-pub use core::slice::memchr::{memchr, memrchr};"}, {"sha": "3de58904043573d4d4020021156e98c8d0383c12", "filename": "src/libstd/sys/wasm/mod.rs", "status": "modified", "additions": 19, "deletions": 44, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -14,25 +14,35 @@\n //! compiling for wasm. That way it's a compile time error for something that's\n //! guaranteed to be a runtime error!\n \n-use crate::os::raw::c_char;\n-\n pub mod alloc;\n pub mod args;\n+#[path = \"../unsupported/cmath.rs\"]\n pub mod cmath;\n pub mod env;\n+#[path = \"../unsupported/fs.rs\"]\n pub mod fs;\n+#[path = \"../unsupported/io.rs\"]\n pub mod io;\n-pub mod memchr;\n+#[path = \"../unsupported/net.rs\"]\n pub mod net;\n+#[path = \"../unsupported/os.rs\"]\n pub mod os;\n+#[path = \"../unsupported/path.rs\"]\n pub mod path;\n+#[path = \"../unsupported/pipe.rs\"]\n pub mod pipe;\n+#[path = \"../unsupported/process.rs\"]\n pub mod process;\n+#[path = \"../unsupported/stack_overflow.rs\"]\n pub mod stack_overflow;\n+#[path = \"../unsupported/stdio.rs\"]\n pub mod stdio;\n pub mod thread;\n+#[path = \"../unsupported/thread_local_dtor.rs\"]\n pub mod thread_local_dtor;\n+#[path = \"../unsupported/thread_local_key.rs\"]\n pub mod thread_local_key;\n+#[path = \"../unsupported/time.rs\"]\n pub mod time;\n \n pub use crate::sys_common::os_str_bytes as os_str;\n@@ -46,50 +56,15 @@ cfg_if::cfg_if! {\n         #[path = \"rwlock_atomics.rs\"]\n         pub mod rwlock;\n     } else {\n+        #[path = \"../unsupported/condvar.rs\"]\n         pub mod condvar;\n+        #[path = \"../unsupported/mutex.rs\"]\n         pub mod mutex;\n+        #[path = \"../unsupported/rwlock.rs\"]\n         pub mod rwlock;\n     }\n }\n \n-#[cfg(not(test))]\n-pub fn init() {}\n-\n-pub fn unsupported<T>() -> crate::io::Result<T> {\n-    Err(unsupported_err())\n-}\n-\n-pub fn unsupported_err() -> crate::io::Error {\n-    crate::io::Error::new(crate::io::ErrorKind::Other, \"operation not supported on wasm yet\")\n-}\n-\n-pub fn decode_error_kind(_code: i32) -> crate::io::ErrorKind {\n-    crate::io::ErrorKind::Other\n-}\n-\n-// This enum is used as the storage for a bunch of types which can't actually\n-// exist.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n-pub enum Void {}\n-\n-pub unsafe fn strlen(mut s: *const c_char) -> usize {\n-    let mut n = 0;\n-    while *s != 0 {\n-        n += 1;\n-        s = s.offset(1);\n-    }\n-    return n;\n-}\n-\n-pub fn abort_internal() -> ! {\n-    unsafe { crate::arch::wasm32::unreachable() }\n-}\n-\n-// We don't have randomness yet, but I totally used a random number generator to\n-// generate these numbers.\n-//\n-// More seriously though this is just for DOS protection in hash maps. It's ok\n-// if we don't do that on wasm just yet.\n-pub fn hashmap_random_keys() -> (u64, u64) {\n-    (1, 2)\n-}\n+#[path = \"../unsupported/common.rs\"]\n+mod common;\n+pub use common::*;"}, {"sha": "840f9093e00f15dd2ece0c6f81526db752e82ec1", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -51,13 +51,9 @@ pub mod condvar;\n pub mod fs;\n pub mod io;\n pub mod mutex;\n-#[cfg(any(doc, // see `mod os`, docs are generated for multiple platforms\n-          unix,\n-          target_os = \"redox\",\n-          target_os = \"cloudabi\",\n-          target_os = \"hermit\",\n-          target_arch = \"wasm32\",\n-          all(target_vendor = \"fortanix\", target_env = \"sgx\")))]\n+// `doc` is required because `sys/mod.rs` imports `unix/ext/mod.rs` on Windows\n+// when generating documentation.\n+#[cfg(any(doc, not(windows)))]\n pub mod os_str_bytes;\n pub mod poison;\n pub mod process;\n@@ -74,6 +70,7 @@ cfg_if::cfg_if! {\n     if #[cfg(any(target_os = \"cloudabi\",\n                  target_os = \"l4re\",\n                  target_os = \"hermit\",\n+                 feature = \"restricted-std\",\n                  all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n                  all(target_vendor = \"fortanix\", target_env = \"sgx\")))] {\n         pub use crate::sys::net;"}, {"sha": "e66d8994147e13fc1ea4030fecc78966bd1b09d4", "filename": "src/libstd/sys_common/mutex.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys_common%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fsys_common%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmutex.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -17,6 +17,7 @@ impl Mutex {\n     /// Also, until `init` is called, behavior is undefined if this\n     /// mutex is ever used reentrantly, i.e., `raw_lock` or `try_lock`\n     /// are called by the thread currently holding the lock.\n+    #[rustc_const_stable(feature = \"const_sys_mutex_new\", since = \"1.0.0\")]\n     pub const fn new() -> Mutex {\n         Mutex(imp::Mutex::new())\n     }"}, {"sha": "202867258f1e403006c53b07932a67e2dfb9915f", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -1741,15 +1741,13 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn test_park_timeout_unpark_not_called() {\n         for _ in 0..10 {\n             thread::park_timeout(Duration::from_millis(10));\n         }\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn test_park_timeout_unpark_called_other_thread() {\n         for _ in 0..10 {\n             let th = thread::current();\n@@ -1764,7 +1762,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn sleep_ms_smoke() {\n         thread::sleep(Duration::from_millis(2));\n     }"}, {"sha": "a4748c5a46628d46727435a31a91e1e9169631bb", "filename": "src/libtest/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibtest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibtest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2FCargo.toml?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -10,6 +10,7 @@ path = \"lib.rs\"\n crate-type = [\"dylib\", \"rlib\"]\n \n [dependencies]\n+cfg-if = { version = \"0.1.8\", features = ['rustc-dep-of-std'] }\n getopts = { version = \"0.2.21\", features = ['rustc-dep-of-std'] }\n term = { path = \"../libterm\" }\n std = { path = \"../libstd\" }"}, {"sha": "2fe87247e3acfc0951bb5c751d5f73f76dbb9194", "filename": "src/libtest/helpers/concurrency.rs", "status": "modified", "additions": 69, "deletions": 102, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibtest%2Fhelpers%2Fconcurrency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibtest%2Fhelpers%2Fconcurrency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fhelpers%2Fconcurrency.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -14,61 +14,36 @@ pub fn get_concurrency() -> usize {\n         }\n         Err(..) => num_cpus(),\n     };\n+}\n \n-    #[cfg(windows)]\n-    #[allow(nonstandard_style)]\n-    fn num_cpus() -> usize {\n-        #[repr(C)]\n-        struct SYSTEM_INFO {\n-            wProcessorArchitecture: u16,\n-            wReserved: u16,\n-            dwPageSize: u32,\n-            lpMinimumApplicationAddress: *mut u8,\n-            lpMaximumApplicationAddress: *mut u8,\n-            dwActiveProcessorMask: *mut u8,\n-            dwNumberOfProcessors: u32,\n-            dwProcessorType: u32,\n-            dwAllocationGranularity: u32,\n-            wProcessorLevel: u16,\n-            wProcessorRevision: u16,\n-        }\n-        extern \"system\" {\n-            fn GetSystemInfo(info: *mut SYSTEM_INFO) -> i32;\n-        }\n-        unsafe {\n-            let mut sysinfo = std::mem::zeroed();\n-            GetSystemInfo(&mut sysinfo);\n-            sysinfo.dwNumberOfProcessors as usize\n+cfg_if::cfg_if! {\n+    if #[cfg(windows)] {\n+        #[allow(nonstandard_style)]\n+        fn num_cpus() -> usize {\n+            #[repr(C)]\n+            struct SYSTEM_INFO {\n+                wProcessorArchitecture: u16,\n+                wReserved: u16,\n+                dwPageSize: u32,\n+                lpMinimumApplicationAddress: *mut u8,\n+                lpMaximumApplicationAddress: *mut u8,\n+                dwActiveProcessorMask: *mut u8,\n+                dwNumberOfProcessors: u32,\n+                dwProcessorType: u32,\n+                dwAllocationGranularity: u32,\n+                wProcessorLevel: u16,\n+                wProcessorRevision: u16,\n+            }\n+            extern \"system\" {\n+                fn GetSystemInfo(info: *mut SYSTEM_INFO) -> i32;\n+            }\n+            unsafe {\n+                let mut sysinfo = std::mem::zeroed();\n+                GetSystemInfo(&mut sysinfo);\n+                sysinfo.dwNumberOfProcessors as usize\n+            }\n         }\n-    }\n-\n-    #[cfg(target_os = \"vxworks\")]\n-    fn num_cpus() -> usize {\n-        // FIXME: Implement num_cpus on vxWorks\n-        1\n-    }\n-\n-    #[cfg(target_os = \"redox\")]\n-    fn num_cpus() -> usize {\n-        // FIXME: Implement num_cpus on Redox\n-        1\n-    }\n-\n-    #[cfg(target_os = \"hermit\")]\n-    fn num_cpus() -> usize {\n-        // FIXME: Implement num_cpus on HermitCore\n-        1\n-    }\n-\n-    #[cfg(any(\n-        all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n-        all(target_vendor = \"fortanix\", target_env = \"sgx\")\n-    ))]\n-    fn num_cpus() -> usize {\n-        1\n-    }\n-\n-    #[cfg(any(\n+    } else if #[cfg(any(\n         target_os = \"android\",\n         target_os = \"cloudabi\",\n         target_os = \"emscripten\",\n@@ -78,23 +53,46 @@ pub fn get_concurrency() -> usize {\n         target_os = \"macos\",\n         target_os = \"solaris\",\n         target_os = \"illumos\",\n-    ))]\n-    fn num_cpus() -> usize {\n-        unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as usize }\n-    }\n-\n-    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"netbsd\"))]\n-    fn num_cpus() -> usize {\n-        use std::ptr;\n+    ))] {\n+        fn num_cpus() -> usize {\n+            unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as usize }\n+        }\n+    } else if #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"netbsd\"))] {\n+        fn num_cpus() -> usize {\n+            use std::ptr;\n \n-        let mut cpus: libc::c_uint = 0;\n-        let mut cpus_size = std::mem::size_of_val(&cpus);\n+            let mut cpus: libc::c_uint = 0;\n+            let mut cpus_size = std::mem::size_of_val(&cpus);\n \n-        unsafe {\n-            cpus = libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as libc::c_uint;\n+            unsafe {\n+                cpus = libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as libc::c_uint;\n+            }\n+            if cpus < 1 {\n+                let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n+                unsafe {\n+                    libc::sysctl(\n+                        mib.as_mut_ptr(),\n+                        2,\n+                        &mut cpus as *mut _ as *mut _,\n+                        &mut cpus_size as *mut _ as *mut _,\n+                        ptr::null_mut(),\n+                        0,\n+                    );\n+                }\n+                if cpus < 1 {\n+                    cpus = 1;\n+                }\n+            }\n+            cpus as usize\n         }\n-        if cpus < 1 {\n+    } else if #[cfg(target_os = \"openbsd\")] {\n+        fn num_cpus() -> usize {\n+            use std::ptr;\n+\n+            let mut cpus: libc::c_uint = 0;\n+            let mut cpus_size = std::mem::size_of_val(&cpus);\n             let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n+\n             unsafe {\n                 libc::sysctl(\n                     mib.as_mut_ptr(),\n@@ -108,43 +106,12 @@ pub fn get_concurrency() -> usize {\n             if cpus < 1 {\n                 cpus = 1;\n             }\n+            cpus as usize\n         }\n-        cpus as usize\n-    }\n-\n-    #[cfg(target_os = \"openbsd\")]\n-    fn num_cpus() -> usize {\n-        use std::ptr;\n-\n-        let mut cpus: libc::c_uint = 0;\n-        let mut cpus_size = std::mem::size_of_val(&cpus);\n-        let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n-\n-        unsafe {\n-            libc::sysctl(\n-                mib.as_mut_ptr(),\n-                2,\n-                &mut cpus as *mut _ as *mut _,\n-                &mut cpus_size as *mut _ as *mut _,\n-                ptr::null_mut(),\n-                0,\n-            );\n-        }\n-        if cpus < 1 {\n-            cpus = 1;\n+    } else {\n+        // FIXME: implement on vxWorks, Redox, HermitCore, Haiku, l4re\n+        fn num_cpus() -> usize {\n+            1\n         }\n-        cpus as usize\n-    }\n-\n-    #[cfg(target_os = \"haiku\")]\n-    fn num_cpus() -> usize {\n-        // FIXME: implement\n-        1\n-    }\n-\n-    #[cfg(target_os = \"l4re\")]\n-    fn num_cpus() -> usize {\n-        // FIXME: implement\n-        1\n     }\n }"}, {"sha": "874ecc3764572b8f328a81f368a0f98cd567e7ae", "filename": "src/libtest/helpers/isatty.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibtest%2Fhelpers%2Fisatty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibtest%2Fhelpers%2Fisatty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fhelpers%2Fisatty.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -1,34 +1,32 @@\n //! Helper module which provides a function to test\n //! if stdout is a tty.\n \n-#[cfg(any(\n-    target_os = \"cloudabi\",\n-    target_os = \"hermit\",\n-    all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n-    all(target_vendor = \"fortanix\", target_env = \"sgx\")\n-))]\n-pub fn stdout_isatty() -> bool {\n-    // FIXME: Implement isatty on SGX\n-    false\n-}\n-#[cfg(unix)]\n-pub fn stdout_isatty() -> bool {\n-    unsafe { libc::isatty(libc::STDOUT_FILENO) != 0 }\n-}\n-#[cfg(windows)]\n-pub fn stdout_isatty() -> bool {\n-    type DWORD = u32;\n-    type BOOL = i32;\n-    type HANDLE = *mut u8;\n-    type LPDWORD = *mut u32;\n-    const STD_OUTPUT_HANDLE: DWORD = -11i32 as DWORD;\n-    extern \"system\" {\n-        fn GetStdHandle(which: DWORD) -> HANDLE;\n-        fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;\n-    }\n-    unsafe {\n-        let handle = GetStdHandle(STD_OUTPUT_HANDLE);\n-        let mut out = 0;\n-        GetConsoleMode(handle, &mut out) != 0\n+cfg_if::cfg_if! {\n+    if #[cfg(unix)] {\n+        pub fn stdout_isatty() -> bool {\n+            unsafe { libc::isatty(libc::STDOUT_FILENO) != 0 }\n+        }\n+    } else if #[cfg(windows)] {\n+        pub fn stdout_isatty() -> bool {\n+            type DWORD = u32;\n+            type BOOL = i32;\n+            type HANDLE = *mut u8;\n+            type LPDWORD = *mut u32;\n+            const STD_OUTPUT_HANDLE: DWORD = -11i32 as DWORD;\n+            extern \"system\" {\n+                fn GetStdHandle(which: DWORD) -> HANDLE;\n+                fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;\n+            }\n+            unsafe {\n+                let handle = GetStdHandle(STD_OUTPUT_HANDLE);\n+                let mut out = 0;\n+                GetConsoleMode(handle, &mut out) != 0\n+            }\n+        }\n+    } else {\n+        // FIXME: Implement isatty on SGX\n+        pub fn stdout_isatty() -> bool {\n+            false\n+        }\n     }\n }"}, {"sha": "c4d10ab177be9534659df7ae4b69fe9355f47c07", "filename": "src/libunwind/lib.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibunwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Flibunwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flib.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -9,12 +9,31 @@\n \n cfg_if::cfg_if! {\n     if #[cfg(target_env = \"msvc\")] {\n-        // no extra unwinder support needed\n-    } else if #[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))] {\n-        // no unwinder on the system!\n-    } else {\n+        // Windows MSVC no extra unwinder support needed\n+    } else if #[cfg(any(\n+        target_os = \"l4re\",\n+        target_os = \"none\",\n+    ))] {\n+        // These \"unix\" family members do not have unwinder.\n+        // Note this also matches x86_64-linux-kernel.\n+    } else if #[cfg(any(\n+        unix,\n+        windows,\n+        target_os = \"cloudabi\",\n+        all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n+    ))] {\n         mod libunwind;\n         pub use libunwind::*;\n+    } else {\n+        // no unwinder on the system!\n+        // - wasm32 (not emscripten, which is \"unix\" family)\n+        // - os=none (\"bare metal\" targets)\n+        // - os=hermit\n+        // - os=uefi\n+        // - os=cuda\n+        // - nvptx64-nvidia-cuda\n+        // - mipsel-sony-psp\n+        // - Any new targets not listed above.\n     }\n }\n "}, {"sha": "86cf9fed3dab48cb176a2009969632bc26c7a647", "filename": "src/test/rustdoc-ui/intra-links-private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc-ui%2Fintra-links-private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc-ui%2Fintra-links-private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-private.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -1,7 +1,7 @@\n // check-pass\n // revisions: public private\n // [private]compile-flags: --document-private-items\n-#![cfg_attr(private, deny(intra_doc_resolution_failure))]\n+#![cfg_attr(private, deny(intra_doc_link_resolution_failure))]\n \n /// docs [DontDocMe]\n //[public]~^ WARNING `[DontDocMe]` public documentation for `DocMe` links to a private item"}, {"sha": "a1e322fb9a30704e45e120048864fd263fc8b8ae", "filename": "src/test/rustdoc/internal.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finternal.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -1,11 +1,13 @@\n // compile-flags: -Z force-unstable-if-unmarked\n \n-// @matches internal/index.html '//*[@class=\"docblock-short\"]/span[@class=\"stab internal\"]' \\\n-//      'Internal'\n+// Check that the unstable marker is not added for \"rustc_private\".\n+\n+// @!matches internal/index.html '//*[@class=\"docblock-short\"]/span[@class=\"stab unstable\"]'\n+// @!matches internal/index.html '//*[@class=\"docblock-short\"]/span[@class=\"stab internal\"]'\n // @matches - '//*[@class=\"docblock-short\"]' 'Docs'\n \n-// @has internal/struct.S.html '//*[@class=\"stab internal\"]' \\\n-//      'This is an internal compiler API. (rustc_private)'\n+// @!has internal/struct.S.html '//*[@class=\"stab unstable\"]'\n+// @!has internal/struct.S.html '//*[@class=\"stab internal\"]'\n /// Docs\n pub struct S;\n "}, {"sha": "adfa7f5754eb908320628b461947d12433550de4", "filename": "src/test/rustdoc/intra-doc-crate/additional_doc.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fadditional_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fadditional_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fadditional_doc.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,10 @@\n+// aux-build:additional_doc.rs\n+// build-aux-docs\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+extern crate my_rand;\n+\n+// @has 'additional_doc/trait.Rng.html' '//a[@href=\"../additional_doc/trait.Rng.html\"]' 'Rng'\n+// @has 'additional_doc/trait.Rng.html' '//a[@href=\"../my_rand/trait.RngCore.html\"]' 'RngCore'\n+/// This is an [`Rng`].\n+pub use my_rand::Rng;"}, {"sha": "8b8793e75ed59002a85a5820c310d453a6c389b6", "filename": "src/test/rustdoc/intra-doc-crate/auxiliary/additional_doc.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fadditional_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fadditional_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fadditional_doc.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,6 @@\n+#![crate_name = \"my_rand\"]\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+pub trait RngCore {}\n+/// Rng extends [`RngCore`].\n+pub trait Rng: RngCore {}"}, {"sha": "2ee5835a7df84c15509bed3a5f96a14a022b6574", "filename": "src/test/rustdoc/intra-doc-crate/auxiliary/intra-doc-basic.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fintra-doc-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fintra-doc-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fintra-doc-basic.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,7 @@\n+#![crate_name = \"a\"]\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+pub struct Foo;\n+\n+/// Link to [Foo]\n+pub struct Bar;"}, {"sha": "abd41fec13016a96cd543afc108e860db0d8793a", "filename": "src/test/rustdoc/intra-doc-crate/auxiliary/macro_inner.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fmacro_inner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fmacro_inner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fmacro_inner.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,10 @@\n+#![crate_name = \"macro_inner\"]\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+pub struct Foo;\n+\n+/// See also [`Foo`]\n+#[macro_export]\n+macro_rules! my_macro {\n+    () => {}\n+}"}, {"sha": "5d63d7e37b64dc6e3fea28cd5f23dd9aad0f20bb", "filename": "src/test/rustdoc/intra-doc-crate/auxiliary/module.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fmodule.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,7 @@\n+#![crate_name = \"module_inner\"]\n+#![deny(intra_doc_link_resolution_failure)]\n+/// [SomeType] links to [bar]\n+pub struct SomeType;\n+pub trait SomeTrait {}\n+/// [bar] links to [SomeTrait] and also [SomeType]\n+pub mod bar {}"}, {"sha": "0d5a954075df22c24bc813c3bccd7aaf6c2ac7ca", "filename": "src/test/rustdoc/intra-doc-crate/auxiliary/proc_macro.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fproc_macro.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,20 @@\n+// force-host\n+// no-prefer-dynamic\n+// compile-flags: --crate-type proc-macro\n+#![crate_type=\"proc-macro\"]\n+#![crate_name=\"proc_macro_inner\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+/// Links to [`OtherDerive`]\n+#[proc_macro_derive(DeriveA)]\n+pub fn a_derive(input: TokenStream) -> TokenStream {\n+    input\n+}\n+\n+#[proc_macro_derive(OtherDerive)]\n+pub fn other_derive(input: TokenStream) -> TokenStream {\n+    input\n+}"}, {"sha": "3a22d13e673ac221aa84bb4ba69091240f90f445", "filename": "src/test/rustdoc/intra-doc-crate/auxiliary/submodule-inner.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fsubmodule-inner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fsubmodule-inner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fsubmodule-inner.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,12 @@\n+#![crate_name = \"a\"]\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+pub mod bar {\n+   pub struct Bar;\n+}\n+\n+pub mod foo {\n+  use crate::bar;\n+  /// link to [bar::Bar]\n+  pub struct Foo;\n+}"}, {"sha": "b8ca4e44e1f16b7225a78cffd6e246272c0ead5c", "filename": "src/test/rustdoc/intra-doc-crate/auxiliary/submodule-outer.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fsubmodule-outer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fsubmodule-outer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fsubmodule-outer.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,13 @@\n+#![crate_name = \"bar\"]\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+pub trait Foo {\n+    /// [`Bar`] [`Baz`]\n+    fn foo();\n+}\n+\n+pub trait Bar {\n+}\n+\n+pub trait Baz {\n+}"}, {"sha": "c16e39d56f3d0d80dcb2b41e6457270ee18e0d9b", "filename": "src/test/rustdoc/intra-doc-crate/auxiliary/traits.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Ftraits.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,16 @@\n+#![crate_name = \"inner\"]\n+/// this is a trait\n+pub trait SomeTrait {\n+    /// this is a method for [a trait][SomeTrait]\n+    fn foo();\n+}\n+\n+pub mod bar {\n+    use super::SomeTrait;\n+\n+    pub struct BarStruct;\n+\n+    impl SomeTrait for BarStruct {\n+        fn foo() {}\n+    }\n+}"}, {"sha": "a245a0f84539c78cf46c572dc9d9ff7644a4e570", "filename": "src/test/rustdoc/intra-doc-crate/basic.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fbasic.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,9 @@\n+// aux-build:intra-doc-basic.rs\n+// build-aux-docs\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+// from https://github.com/rust-lang/rust/issues/65983\n+extern crate a;\n+\n+// @has 'basic/struct.Bar.html' '//a[@href=\"../a/struct.Foo.html\"]' 'Foo'\n+pub use a::Bar;"}, {"sha": "72fd57b6b0c7f7c7c38e7ec68bae803f373b009f", "filename": "src/test/rustdoc/intra-doc-crate/macro.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fmacro.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,12 @@\n+// ignore-tidy-linelength\n+// aux-build:macro_inner.rs\n+// aux-build:proc_macro.rs\n+// build-aux-docs\n+#![deny(intra_doc_link_resolution_failure)]\n+extern crate macro_inner;\n+extern crate proc_macro_inner;\n+\n+// @has 'macro/macro.my_macro.html' '//a[@href=\"../macro_inner/struct.Foo.html\"]' 'Foo'\n+pub use macro_inner::my_macro;\n+// @has 'macro/derive.DeriveA.html' '//a[@href=\"../proc_macro_inner/derive.OtherDerive.html\"]' 'OtherDerive'\n+pub use proc_macro_inner::DeriveA;"}, {"sha": "67fa7293f37fb49b32540aa49f0c09f39a611e69", "filename": "src/test/rustdoc/intra-doc-crate/module.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fmodule.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,8 @@\n+// outer.rs\n+// aux-build: module.rs\n+// build-aux-docs\n+#![deny(intra_doc_link_resolution_failure)]\n+extern crate module_inner;\n+// @has 'module/bar/index.html' '//a[@href=\"../../module_inner/trait.SomeTrait.html\"]' 'SomeTrait'\n+// @has 'module/bar/index.html' '//a[@href=\"../../module_inner/struct.SomeType.html\"]' 'SomeType'\n+pub use module_inner::bar;"}, {"sha": "b4b615bf9edada62d1f5749d1638060d1cf18be4", "filename": "src/test/rustdoc/intra-doc-crate/submodule-inner.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fsubmodule-inner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fsubmodule-inner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fsubmodule-inner.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,8 @@\n+// aux-build:submodule-inner.rs\n+// build-aux-docs\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+extern crate a;\n+\n+// @has 'submodule_inner/struct.Foo.html' '//a[@href=\"../a/bar/struct.Bar.html\"]' 'Bar'\n+pub use a::foo::Foo;"}, {"sha": "6b30ef8b3dec87ab7586b7bca682653fe0efbcb8", "filename": "src/test/rustdoc/intra-doc-crate/submodule-outer.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fsubmodule-outer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fsubmodule-outer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fsubmodule-outer.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,16 @@\n+// aux-build:submodule-outer.rs\n+// edition:2018\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+extern crate bar as bar_;\n+\n+// from https://github.com/rust-lang/rust/issues/60883\n+pub mod bar {\n+    pub use ::bar_::Bar;\n+}\n+\n+// NOTE: we re-exported both `Foo` and `Bar` here,\n+// NOTE: so they are inlined and therefore we link to the current module.\n+// @has 'submodule_outer/trait.Foo.html' '//a[@href=\"../submodule_outer/bar/trait.Bar.html\"]' 'Bar'\n+// @has 'submodule_outer/trait.Foo.html' '//a[@href=\"../submodule_outer/trait.Baz.html\"]' 'Baz'\n+pub use ::bar_::{Foo, Baz};"}, {"sha": "617331236902d947966062d856da433e89c7f922", "filename": "src/test/rustdoc/intra-doc-crate/traits.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Ftraits.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -0,0 +1,17 @@\n+// ignore-test\n+// ^ this is https://github.com/rust-lang/rust/issues/73829\n+// aux-build:traits.rs\n+// build-aux-docs\n+// ignore-tidy-line-length\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+extern crate inner;\n+use inner::SomeTrait;\n+\n+pub struct SomeStruct;\n+\n+ // @has 'traits/struct.SomeStruct.html' '//a[@href=\"../inner/trait.SomeTrait.html\"]' 'SomeTrait'\n+impl SomeTrait for SomeStruct {\n+    // @has 'traits/struct.SomeStruct.html' '//a[@href=\"../inner/trait.SomeTrait.html\"]' 'a trait'\n+    fn foo() {}\n+}"}, {"sha": "d7ebb73b3be7d7b6dc5a6de2c08a0bd884aee477", "filename": "src/test/rustdoc/intra-link-prim-precedence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-link-prim-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Frustdoc%2Fintra-link-prim-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-prim-precedence.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -1,5 +1,5 @@\n // ignore-tidy-linelength\n-#![deny(intra_doc_resolution_failure)]\n+#![deny(intra_doc_link_resolution_failure)]\n \n pub mod char {}\n "}, {"sha": "a2b11764a2fc64cfd46297caa3ab313676789d93", "filename": "src/test/ui/issues/issue-59020.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Fui%2Fissues%2Fissue-59020.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Fui%2Fissues%2Fissue-59020.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59020.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -1,7 +1,6 @@\n // edition:2018\n // run-pass\n // ignore-emscripten no threads support\n-// ignore-sgx no thread sleep support\n \n use std::thread;\n use std::time::Duration;"}, {"sha": "3e7e9a51cdd3ad044d8bee4281abad20283c0345", "filename": "src/test/ui/issues/issue-9396.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Fui%2Fissues%2Fissue-9396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Fui%2Fissues%2Fissue-9396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-9396.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -2,7 +2,6 @@\n #![allow(unused_must_use)]\n #![allow(deprecated)]\n // ignore-emscripten no threads support\n-// ignore-sgx no thread sleep support\n \n use std::sync::mpsc::{TryRecvError, channel};\n use std::thread;"}, {"sha": "a889542fec0be8a673acdb4ae1299898771c8759", "filename": "src/test/ui/mpsc_stress.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Fui%2Fmpsc_stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Fui%2Fmpsc_stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmpsc_stress.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -1,7 +1,6 @@\n // run-pass\n // compile-flags:--test\n // ignore-emscripten\n-// ignore-sgx no thread sleep support\n \n use std::sync::mpsc::channel;\n use std::sync::mpsc::TryRecvError;\n@@ -37,6 +36,8 @@ impl Barrier {\n     fn wait(self) {\n         self.shared.fetch_add(1, Ordering::SeqCst);\n         while self.shared.load(Ordering::SeqCst) != self.count {\n+            #[cfg(target_env = \"sgx\")]\n+            thread::yield_now();\n         }\n     }\n }"}, {"sha": "3b3a4a4f3250cb21d66b98a7a535a7618167fef5", "filename": "src/test/ui/sleep.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Fui%2Fsleep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Fui%2Fsleep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsleep.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -1,6 +1,5 @@\n // run-pass\n // ignore-emscripten no threads support\n-// ignore-sgx no thread sleep support\n \n use std::thread::{self, sleep};\n use std::time::Duration;"}, {"sha": "08b47dc531857c1ef493f5f94378f3f5d0eb6a29", "filename": "src/test/ui/tcp-stress.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Fui%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftest%2Fui%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftcp-stress.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -4,7 +4,6 @@\n // ignore-emscripten no threads or sockets support\n // ignore-netbsd system ulimit (Too many open files)\n // ignore-openbsd system ulimit (Too many open files)\n-// ignore-sgx no thread sleep support\n \n use std::io::prelude::*;\n use std::net::{TcpListener, TcpStream};"}, {"sha": "6ac89f2b1b82a4142670a507c77445f98737dfe2", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -34,6 +34,7 @@ static HOSTS: &[&str] = &[\n     \"powerpc-unknown-linux-gnu\",\n     \"powerpc64-unknown-linux-gnu\",\n     \"powerpc64le-unknown-linux-gnu\",\n+    \"riscv64gc-unknown-linux-gnu\",\n     \"s390x-unknown-linux-gnu\",\n     \"x86_64-apple-darwin\",\n     \"x86_64-pc-windows-gnu\","}, {"sha": "1d4772bb3d606a41a5dd4af3d1b9d9d8dd332ee1", "filename": "src/tools/clippy/clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -8,7 +8,7 @@ use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::{Ident, SymbolStr};\n+use rustc_span::symbol::{Ident, Symbol};\n use std::cmp::Ordering;\n \n declare_clippy_lint! {\n@@ -75,7 +75,7 @@ pub struct NonExpressiveNames {\n impl_lint_pass!(NonExpressiveNames => [SIMILAR_NAMES, MANY_SINGLE_CHAR_NAMES, JUST_UNDERSCORES_AND_DIGITS]);\n \n struct ExistingName {\n-    interned: SymbolStr,\n+    interned: Symbol,\n     span: Span,\n     len: usize,\n     exemptions: &'static [&'static str],\n@@ -218,18 +218,19 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n             let mut split_at = None;\n             match existing_name.len.cmp(&count) {\n                 Ordering::Greater => {\n-                    if existing_name.len - count != 1 || levenstein_not_1(&interned_name, &existing_name.interned) {\n+                    if existing_name.len - count != 1 || levenstein_not_1(&interned_name, &existing_name.interned.as_str()) {\n                         continue;\n                     }\n                 },\n                 Ordering::Less => {\n-                    if count - existing_name.len != 1 || levenstein_not_1(&existing_name.interned, &interned_name) {\n+                    if count - existing_name.len != 1 || levenstein_not_1(&existing_name.interned.as_str(), &interned_name) {\n                         continue;\n                     }\n                 },\n                 Ordering::Equal => {\n                     let mut interned_chars = interned_name.chars();\n-                    let mut existing_chars = existing_name.interned.chars();\n+                    let interned_str = existing_name.interned.as_str();\n+                    let mut existing_chars = interned_str.chars();\n                     let first_i = interned_chars.next().expect(\"we know we have at least one char\");\n                     let first_e = existing_chars.next().expect(\"we know we have at least one char\");\n                     let eq_or_numeric = |(a, b): (char, char)| a == b || a.is_numeric() && b.is_numeric();\n@@ -302,7 +303,7 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n         }\n         self.0.names.push(ExistingName {\n             exemptions: get_exemptions(&interned_name).unwrap_or(&[]),\n-            interned: interned_name,\n+            interned: ident.name,\n             span: ident.span,\n             len: count,\n         });"}, {"sha": "154082a0fdb530b8e81d1d4e47f3abced3f96b6b", "filename": "src/tools/clippy/clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -3,7 +3,7 @@ use rustc_ast::ast::{Item, ItemKind, UseTree, UseTreeKind};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::{Ident, SymbolStr};\n+use rustc_span::symbol::Ident;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for imports that remove \"unsafe\" from an item's\n@@ -73,6 +73,6 @@ fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext<'_>,\n }\n \n #[must_use]\n-fn contains_unsafe(name: &SymbolStr) -> bool {\n+fn contains_unsafe(name: &str) -> bool {\n     name.contains(\"Unsafe\") || name.contains(\"unsafe\")\n }"}, {"sha": "1e955c61ac85f1bb7f717c1d77b5fad3b5c1e4b3", "filename": "src/tools/rustc-std-workspace-std/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftools%2Frustc-std-workspace-std%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e/src%2Ftools%2Frustc-std-workspace-std%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustc-std-workspace-std%2Flib.rs?ref=8534be72fc3b9c5f2f2dc4e4ee7b651a008e9a3e", "patch": "@@ -1 +1,2 @@\n+#![feature(restricted_std)]\n pub use std::*;"}]}