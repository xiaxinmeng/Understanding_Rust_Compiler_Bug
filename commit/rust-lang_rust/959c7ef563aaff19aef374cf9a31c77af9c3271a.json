{"sha": "959c7ef563aaff19aef374cf9a31c77af9c3271a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1OWM3ZWY1NjNhYWZmMTlhZWYzNzRjZjlhMzFjNzdhZjljMzI3MWE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-16T00:26:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-16T00:26:32Z"}, "message": "Merge #10250\n\n10250: internal: Improve call_hierarchy and incoming/outgoing_calls r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "9cc4e7b47fe18d9ff03344bcfe296ed4722f5fbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cc4e7b47fe18d9ff03344bcfe296ed4722f5fbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/959c7ef563aaff19aef374cf9a31c77af9c3271a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhQo84CRBK7hj4Ov3rIwAACNoIACA6+Wr0MvMOA6Vi67LmOocL\nClCnZCjKOGVeZa7ZkFgKWP2Tb1+q3HyZJjoS+DI5dFhck6NhtWm0jJZGy5e5wRT9\nPXgOECBMbz1ndDaM51mLuHjdB7UfaYEbtb9UuW1/551YcKh0pRnQNj7dqBlFM7BL\nl6aTWnRpOXV5jYmFrqqeH83nHj/czEpSDtODtc/w5Kx1PBOQ2IeN0nR14eY7SZaB\n+2WTKkRzoTuDz61Q7llSXpZCI7diHq7JQPK0J5oTww38joZ2LN9/HDh4JA7WzTid\n0yOdhh1H/ry/V28AHE7xKhZXOL9jNpZXsV22ls/0/4Y3Jf18EEZNdTXOiCqmTf8=\n=awbk\n-----END PGP SIGNATURE-----\n", "payload": "tree 9cc4e7b47fe18d9ff03344bcfe296ed4722f5fbc\nparent c577e128fc3aa9d5cf113c24c7f425e2b68bb2b6\nparent d777eddf0dc477cb17b9a10a8c08e6373c196e5d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1631751992 +0000\ncommitter GitHub <noreply@github.com> 1631751992 +0000\n\nMerge #10250\n\n10250: internal: Improve call_hierarchy and incoming/outgoing_calls r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/959c7ef563aaff19aef374cf9a31c77af9c3271a", "html_url": "https://github.com/rust-lang/rust/commit/959c7ef563aaff19aef374cf9a31c77af9c3271a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/959c7ef563aaff19aef374cf9a31c77af9c3271a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c577e128fc3aa9d5cf113c24c7f425e2b68bb2b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c577e128fc3aa9d5cf113c24c7f425e2b68bb2b6", "html_url": "https://github.com/rust-lang/rust/commit/c577e128fc3aa9d5cf113c24c7f425e2b68bb2b6"}, {"sha": "d777eddf0dc477cb17b9a10a8c08e6373c196e5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d777eddf0dc477cb17b9a10a8c08e6373c196e5d", "html_url": "https://github.com/rust-lang/rust/commit/d777eddf0dc477cb17b9a10a8c08e6373c196e5d"}], "stats": {"total": 274, "additions": 177, "deletions": 97}, "files": [{"sha": "242b7b40e18916e6d1d9c4118778e5ef6a9d0ce3", "filename": "crates/ide/src/call_hierarchy.rs", "status": "modified", "additions": 177, "deletions": 91, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/959c7ef563aaff19aef374cf9a31c77af9c3271a/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/959c7ef563aaff19aef374cf9a31c77af9c3271a/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs?ref=959c7ef563aaff19aef374cf9a31c77af9c3271a", "patch": "@@ -3,12 +3,16 @@\n use indexmap::IndexMap;\n \n use hir::Semantics;\n-use ide_db::{call_info::FnCallNode, RootDatabase};\n-use syntax::{ast, AstNode, TextRange};\n-\n-use crate::{\n-    display::TryToNav, goto_definition, references, FilePosition, NavigationTarget, RangeInfo,\n+use ide_db::{\n+    call_info::FnCallNode,\n+    defs::{Definition, NameClass, NameRefClass},\n+    helpers::pick_best_token,\n+    search::FileReference,\n+    RootDatabase,\n };\n+use syntax::{ast, AstNode, SyntaxKind::NAME, TextRange};\n+\n+use crate::{display::TryToNav, goto_definition, FilePosition, NavigationTarget, RangeInfo};\n \n #[derive(Debug, Clone)]\n pub struct CallItem {\n@@ -17,12 +21,6 @@ pub struct CallItem {\n }\n \n impl CallItem {\n-    #[cfg(test)]\n-    pub(crate) fn assert_match(&self, expected: &str) {\n-        let actual = self.debug_render();\n-        test_utils::assert_eq_text!(expected.trim(), actual.trim(),);\n-    }\n-\n     #[cfg(test)]\n     pub(crate) fn debug_render(&self) -> String {\n         format!(\"{} : {:?}\", self.target.debug_render(), self.ranges)\n@@ -36,30 +34,45 @@ pub(crate) fn call_hierarchy(\n     goto_definition::goto_definition(db, position)\n }\n \n-pub(crate) fn incoming_calls(db: &RootDatabase, position: FilePosition) -> Option<Vec<CallItem>> {\n-    let sema = Semantics::new(db);\n-\n-    // 1. Find all refs\n-    // 2. Loop through refs and determine unique fndef. This will become our `from: CallHierarchyItem,` in the reply.\n-    // 3. Add ranges relative to the start of the fndef.\n-    let refs = references::find_all_refs(&sema, position, None)?;\n+pub(crate) fn incoming_calls(\n+    db: &RootDatabase,\n+    FilePosition { file_id, offset }: FilePosition,\n+) -> Option<Vec<CallItem>> {\n+    let sema = &Semantics::new(db);\n \n+    let file = sema.parse(file_id);\n+    let file = file.syntax();\n     let mut calls = CallLocations::default();\n \n-    for (file_id, references) in refs.into_iter().flat_map(|refs| refs.references) {\n-        let file = sema.parse(file_id);\n-        let file = file.syntax();\n-        for (relative_range, token) in references\n-            .into_iter()\n-            .filter_map(|(range, _)| Some(range).zip(file.token_at_offset(range.start()).next()))\n-        {\n-            let token = sema.descend_into_macros(token);\n+    let references = sema\n+        .find_nodes_at_offset_with_descend(file, offset)\n+        .filter_map(move |node| match node {\n+            ast::NameLike::NameRef(name_ref) => match NameRefClass::classify(sema, &name_ref)? {\n+                NameRefClass::Definition(\n+                    def @ Definition::ModuleDef(hir::ModuleDef::Function(_)),\n+                ) => Some(def),\n+                _ => None,\n+            },\n+            ast::NameLike::Name(name) => match NameClass::classify(sema, &name)? {\n+                NameClass::Definition(def @ Definition::ModuleDef(hir::ModuleDef::Function(_))) => {\n+                    Some(def)\n+                }\n+                _ => None,\n+            },\n+            ast::NameLike::Lifetime(_) => None,\n+        })\n+        .flat_map(|func| func.usages(sema).all());\n+\n+    for (_, references) in references {\n+        let references = references.into_iter().map(|FileReference { name, .. }| name);\n+        for name in references {\n             // This target is the containing function\n-            if let Some(nav) = token.ancestors().find_map(|node| {\n+            let nav = sema.ancestors_with_macros(name.syntax().clone()).find_map(|node| {\n                 let def = ast::Fn::cast(node).and_then(|fn_| sema.to_def(&fn_))?;\n                 def.try_to_nav(sema.db)\n-            }) {\n-                calls.add(&nav, relative_range);\n+            });\n+            if let Some(nav) = nav {\n+                calls.add(nav, sema.original_range(name.syntax()).range);\n             }\n         }\n     }\n@@ -72,15 +85,22 @@ pub(crate) fn outgoing_calls(db: &RootDatabase, position: FilePosition) -> Optio\n     let file_id = position.file_id;\n     let file = sema.parse(file_id);\n     let file = file.syntax();\n-    let token = file.token_at_offset(position.offset).next()?;\n-    let token = sema.descend_into_macros(token);\n-\n+    let token = pick_best_token(file.token_at_offset(position.offset), |kind| match kind {\n+        NAME => 1,\n+        _ => 0,\n+    })?;\n     let mut calls = CallLocations::default();\n \n-    token\n-        .parent()\n+    sema.descend_into_macros_many(token)\n         .into_iter()\n-        .flat_map(|it| it.descendants())\n+        .filter_map(|it| it.ancestors().nth(1).and_then(ast::Item::cast))\n+        .filter_map(|item| match item {\n+            ast::Item::Const(c) => c.body().map(|it| it.syntax().descendants()),\n+            ast::Item::Fn(f) => f.body().map(|it| it.syntax().descendants()),\n+            ast::Item::Static(s) => s.body().map(|it| it.syntax().descendants()),\n+            _ => None,\n+        })\n+        .flatten()\n         .filter_map(|node| FnCallNode::with_node_exact(&node))\n         .filter_map(|call_node| {\n             let name_ref = call_node.name_ref()?;\n@@ -99,7 +119,7 @@ pub(crate) fn outgoing_calls(db: &RootDatabase, position: FilePosition) -> Optio\n             }?;\n             Some((func_target, name_ref.syntax().text_range()))\n         })\n-        .for_each(|(nav, range)| calls.add(&nav, range));\n+        .for_each(|(nav, range)| calls.add(nav, range));\n \n     Some(calls.into_items())\n }\n@@ -110,8 +130,8 @@ struct CallLocations {\n }\n \n impl CallLocations {\n-    fn add(&mut self, target: &NavigationTarget, range: TextRange) {\n-        self.funcs.entry(target.clone()).or_default().push(range);\n+    fn add(&mut self, target: NavigationTarget, range: TextRange) {\n+        self.funcs.entry(target).or_default().push(range);\n     }\n \n     fn into_items(self) -> Vec<CallItem> {\n@@ -121,38 +141,34 @@ impl CallLocations {\n \n #[cfg(test)]\n mod tests {\n+    use expect_test::{expect, Expect};\n     use ide_db::base_db::FilePosition;\n+    use itertools::Itertools;\n \n     use crate::fixture;\n \n     fn check_hierarchy(\n         ra_fixture: &str,\n-        expected: &str,\n-        expected_incoming: &[&str],\n-        expected_outgoing: &[&str],\n+        expected: Expect,\n+        expected_incoming: Expect,\n+        expected_outgoing: Expect,\n     ) {\n         let (analysis, pos) = fixture::position(ra_fixture);\n \n         let mut navs = analysis.call_hierarchy(pos).unwrap().unwrap().info;\n         assert_eq!(navs.len(), 1);\n         let nav = navs.pop().unwrap();\n-        nav.assert_match(expected);\n+        expected.assert_eq(&nav.debug_render());\n \n         let item_pos =\n             FilePosition { file_id: nav.file_id, offset: nav.focus_or_full_range().start() };\n         let incoming_calls = analysis.incoming_calls(item_pos).unwrap().unwrap();\n-        assert_eq!(incoming_calls.len(), expected_incoming.len());\n-\n-        for call in 0..incoming_calls.len() {\n-            incoming_calls[call].assert_match(expected_incoming[call]);\n-        }\n+        expected_incoming\n+            .assert_eq(&incoming_calls.into_iter().map(|call| call.debug_render()).join(\"\\n\"));\n \n         let outgoing_calls = analysis.outgoing_calls(item_pos).unwrap().unwrap();\n-        assert_eq!(outgoing_calls.len(), expected_outgoing.len());\n-\n-        for call in 0..outgoing_calls.len() {\n-            outgoing_calls[call].assert_match(expected_outgoing[call]);\n-        }\n+        expected_outgoing\n+            .assert_eq(&outgoing_calls.into_iter().map(|call| call.debug_render()).join(\"\\n\"));\n     }\n \n     #[test]\n@@ -165,9 +181,9 @@ fn caller() {\n     call$0ee();\n }\n \"#,\n-            \"callee Function FileId(0) 0..14 3..9\",\n-            &[\"caller Function FileId(0) 15..44 18..24 : [33..39]\"],\n-            &[],\n+            expect![[\"callee Function FileId(0) 0..14 3..9\"]],\n+            expect![[\"caller Function FileId(0) 15..44 18..24 : [33..39]\"]],\n+            expect![[]],\n         );\n     }\n \n@@ -181,9 +197,9 @@ fn caller() {\n     callee();\n }\n \"#,\n-            \"callee Function FileId(0) 0..14 3..9\",\n-            &[\"caller Function FileId(0) 15..44 18..24 : [33..39]\"],\n-            &[],\n+            expect![[\"callee Function FileId(0) 0..14 3..9\"]],\n+            expect![[\"caller Function FileId(0) 15..44 18..24 : [33..39]\"]],\n+            expect![[]],\n         );\n     }\n \n@@ -198,9 +214,9 @@ fn caller() {\n     callee();\n }\n \"#,\n-            \"callee Function FileId(0) 0..14 3..9\",\n-            &[\"caller Function FileId(0) 15..58 18..24 : [33..39, 47..53]\"],\n-            &[],\n+            expect![[\"callee Function FileId(0) 0..14 3..9\"]],\n+            expect![[\"caller Function FileId(0) 15..58 18..24 : [33..39, 47..53]\"]],\n+            expect![[]],\n         );\n     }\n \n@@ -218,12 +234,11 @@ fn caller2() {\n     callee();\n }\n \"#,\n-            \"callee Function FileId(0) 0..14 3..9\",\n-            &[\n-                \"caller1 Function FileId(0) 15..45 18..25 : [34..40]\",\n-                \"caller2 Function FileId(0) 47..77 50..57 : [66..72]\",\n-            ],\n-            &[],\n+            expect![[\"callee Function FileId(0) 0..14 3..9\"]],\n+            expect![[\"\n+                caller1 Function FileId(0) 15..45 18..25 : [34..40]\n+                caller2 Function FileId(0) 47..77 50..57 : [66..72]\"]],\n+            expect![[]],\n         );\n     }\n \n@@ -247,12 +262,11 @@ mod tests {\n     }\n }\n \"#,\n-            \"callee Function FileId(0) 0..14 3..9\",\n-            &[\n-                \"caller1 Function FileId(0) 15..45 18..25 : [34..40]\",\n-                \"test_caller Function FileId(0) 95..149 110..121 : [134..140]\",\n-            ],\n-            &[],\n+            expect![[\"callee Function FileId(0) 0..14 3..9\"]],\n+            expect![[r#\"\n+                caller1 Function FileId(0) 15..45 18..25 : [34..40]\n+                test_caller Function FileId(0) 95..149 110..121 : [134..140]\"#]],\n+            expect![[]],\n         );\n     }\n \n@@ -271,9 +285,9 @@ fn caller() {\n //- /foo/mod.rs\n pub fn callee() {}\n \"#,\n-            \"callee Function FileId(1) 0..18 7..13\",\n-            &[\"caller Function FileId(0) 27..56 30..36 : [45..51]\"],\n-            &[],\n+            expect![[\"callee Function FileId(1) 0..18 7..13\"]],\n+            expect![[\"caller Function FileId(0) 27..56 30..36 : [45..51]\"]],\n+            expect![[]],\n         );\n     }\n \n@@ -288,9 +302,9 @@ fn call$0er() {\n     callee();\n }\n \"#,\n-            \"caller Function FileId(0) 15..58 18..24\",\n-            &[],\n-            &[\"callee Function FileId(0) 0..14 3..9 : [33..39, 47..53]\"],\n+            expect![[\"caller Function FileId(0) 15..58 18..24\"]],\n+            expect![[]],\n+            expect![[\"callee Function FileId(0) 0..14 3..9 : [33..39, 47..53]\"]],\n         );\n     }\n \n@@ -309,9 +323,9 @@ fn call$0er() {\n //- /foo/mod.rs\n pub fn callee() {}\n \"#,\n-            \"caller Function FileId(0) 27..56 30..36\",\n-            &[],\n-            &[\"callee Function FileId(1) 0..18 7..13 : [45..51]\"],\n+            expect![[\"caller Function FileId(0) 27..56 30..36\"]],\n+            expect![[]],\n+            expect![[\"callee Function FileId(1) 0..18 7..13 : [45..51]\"]],\n         );\n     }\n \n@@ -332,9 +346,9 @@ fn caller3() {\n \n }\n \"#,\n-            \"caller2 Function FileId(0) 33..64 36..43\",\n-            &[\"caller1 Function FileId(0) 0..31 3..10 : [19..26]\"],\n-            &[\"caller3 Function FileId(0) 66..83 69..76 : [52..59]\"],\n+            expect![[\"caller2 Function FileId(0) 33..64 36..43\"]],\n+            expect![[\"caller1 Function FileId(0) 0..31 3..10 : [19..26]\"]],\n+            expect![[\"caller3 Function FileId(0) 66..83 69..76 : [52..59]\"]],\n         );\n     }\n \n@@ -352,9 +366,9 @@ fn main() {\n     a$0()\n }\n \"#,\n-            \"a Function FileId(0) 0..18 3..4\",\n-            &[\"main Function FileId(0) 31..52 34..38 : [47..48]\"],\n-            &[\"b Function FileId(0) 20..29 23..24 : [13..14]\"],\n+            expect![[\"a Function FileId(0) 0..18 3..4\"]],\n+            expect![[\"main Function FileId(0) 31..52 34..38 : [47..48]\"]],\n+            expect![[\"b Function FileId(0) 20..29 23..24 : [13..14]\"]],\n         );\n \n         check_hierarchy(\n@@ -369,9 +383,81 @@ fn main() {\n     a()\n }\n \"#,\n-            \"b Function FileId(0) 20..29 23..24\",\n-            &[\"a Function FileId(0) 0..18 3..4 : [13..14]\"],\n-            &[],\n+            expect![[\"b Function FileId(0) 20..29 23..24\"]],\n+            expect![[\"a Function FileId(0) 0..18 3..4 : [13..14]\"]],\n+            expect![[]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_call_hierarchy_in_macros_incoming() {\n+        check_hierarchy(\n+            r#\"\n+macro_rules! define {\n+    ($ident:ident) => {\n+        fn $ident {}\n+    }\n+}\n+macro_rules! call {\n+    ($ident:ident) => {\n+        $ident()\n+    }\n+}\n+define!(callee)\n+fn caller() {\n+    call!(call$0ee);\n+}\n+\"#,\n+            expect![[r#\"callee Function FileId(0) 144..159 152..158\"#]],\n+            expect![[r#\"caller Function FileId(0) 160..194 163..169 : [184..190]\"#]],\n+            expect![[]],\n+        );\n+        check_hierarchy(\n+            r#\"\n+macro_rules! define {\n+    ($ident:ident) => {\n+        fn $ident {}\n+    }\n+}\n+macro_rules! call {\n+    ($ident:ident) => {\n+        $ident()\n+    }\n+}\n+define!(cal$0lee)\n+fn caller() {\n+    call!(callee);\n+}\n+\"#,\n+            expect![[r#\"callee Function FileId(0) 144..159 152..158\"#]],\n+            expect![[r#\"caller Function FileId(0) 160..194 163..169 : [184..190]\"#]],\n+            expect![[]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_call_hierarchy_in_macros_outgoing() {\n+        check_hierarchy(\n+            r#\"\n+macro_rules! define {\n+    ($ident:ident) => {\n+        fn $ident {}\n+    }\n+}\n+macro_rules! call {\n+    ($ident:ident) => {\n+        $ident()\n+    }\n+}\n+define!(callee)\n+fn caller$0() {\n+    call!(callee);\n+}\n+\"#,\n+            expect![[r#\"caller Function FileId(0) 160..194 163..169\"#]],\n+            expect![[]],\n+            // FIXME\n+            expect![[]],\n         );\n     }\n }"}, {"sha": "6978e4b88ff7df4d53fb74c7b9e553a60e765389", "filename": "crates/ide/src/display/navigation_target.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/959c7ef563aaff19aef374cf9a31c77af9c3271a/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/959c7ef563aaff19aef374cf9a31c77af9c3271a/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=959c7ef563aaff19aef374cf9a31c77af9c3271a", "patch": "@@ -112,12 +112,6 @@ impl NavigationTarget {\n         module.to_nav(db)\n     }\n \n-    #[cfg(test)]\n-    pub(crate) fn assert_match(&self, expected: &str) {\n-        let actual = self.debug_render();\n-        test_utils::assert_eq_text!(expected.trim(), actual.trim(),);\n-    }\n-\n     #[cfg(test)]\n     pub(crate) fn debug_render(&self) -> String {\n         let mut buf = format!("}]}