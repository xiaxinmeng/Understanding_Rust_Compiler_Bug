{"sha": "28081a6aa6a13199e6ee3c09ab544139eb23a3fa", "node_id": "C_kwDOAAsO6NoAKDI4MDgxYTZhYTZhMTMxOTllNmVlM2MwOWFiNTQ0MTM5ZWIyM2EzZmE", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-01-23T06:22:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-23T06:22:04Z"}, "message": "Rollup merge of #106854 - steffahn:drop_linear_arc_rebased, r=Mark-Simulacrum\n\nAdd `Arc::into_inner` for safely discarding `Arc`s without calling the destructor on the inner type.\n\nACP: rust-lang/libs-team#162\n\nReviving #79665.\n\nI want to get this merged this time; this does not contain changes (apart from very minor changes in comments/docs).\n\nSee #79665 for further description of the PR. The only \u201cunresolved\u201d points that led to that PR being closed, AFAICT, were\n\n* The desire to also implement a `Rc::into_inner` function\n  * however, this can very well also happen as a subsequent PR\n* Possible need for further discussion on the naming \u201c`into_inner`\u201d (?)\n  * `into_inner` seems fine to me; also, this PR introduces unstable API, and names can be changed later, too\n* ~~I don't know if a tracking issue for the feature flag is supposed to be opened before or after this PR gets merged (if *before*, then I can add the issue number to the `#[unstable\u2026]` attribute)~~ There is a [tracking issue](https://github.com/rust-lang/rust/issues/106894) now.\n\nI say \u201cunresolved\u201d in quotation marks because from my point of view, if reviewers agree, the PR can be merged immediately and as-is :-)", "tree": {"sha": "5a7408ed472ff3e8de6d2446862eb0157609d795", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a7408ed472ff3e8de6d2446862eb0157609d795"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28081a6aa6a13199e6ee3c09ab544139eb23a3fa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjzieMCRBK7hj4Ov3rIwAAJ88IABj0J0+WqJ9joAECqIcyt/h0\nPum5DC2/UEuqPXrKHWr7h3LzWVx8qa+eKkcfdJwLoe3HpNHhMMmva+7wTxNwJLuE\nFxPPioxXgpC+G2PDHgwdsfBhF95IkAp3sq5I4K+IGTEveP4fkIp0L578NADqmvHR\nmXjvUkg2xhxi+xFcP8J11F0IPK4e+hqCiYHYIr/DwHTSZ9vwu45rqR+y3yERsIFW\nc/jPUESDvBVqLbBCOftM61ClwNimDsXTWhs3wwoOkIbbXR0dEBhnAmHKXWOcpNB5\nNOBafi0taD2yOlVehvtojjFIoL4uZ7VQifUjiaXe1lbslBjMICEvwCGnrNCWZ1Q=\n=UvQ5\n-----END PGP SIGNATURE-----\n", "payload": "tree 5a7408ed472ff3e8de6d2446862eb0157609d795\nparent 3d4c3125bebdcc8a4cc6de2a9925c7259fde2b63\nparent 33696fa9cab5bec947147d65833233b957b5edd5\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1674454924 +0530\ncommitter GitHub <noreply@github.com> 1674454924 +0530\n\nRollup merge of #106854 - steffahn:drop_linear_arc_rebased, r=Mark-Simulacrum\n\nAdd `Arc::into_inner` for safely discarding `Arc`s without calling the destructor on the inner type.\n\nACP: rust-lang/libs-team#162\n\nReviving #79665.\n\nI want to get this merged this time; this does not contain changes (apart from very minor changes in comments/docs).\n\nSee #79665 for further description of the PR. The only \u201cunresolved\u201d points that led to that PR being closed, AFAICT, were\n\n* The desire to also implement a `Rc::into_inner` function\n  * however, this can very well also happen as a subsequent PR\n* Possible need for further discussion on the naming \u201c`into_inner`\u201d (?)\n  * `into_inner` seems fine to me; also, this PR introduces unstable API, and names can be changed later, too\n* ~~I don't know if a tracking issue for the feature flag is supposed to be opened before or after this PR gets merged (if *before*, then I can add the issue number to the `#[unstable\u2026]` attribute)~~ There is a [tracking issue](https://github.com/rust-lang/rust/issues/106894) now.\n\nI say \u201cunresolved\u201d in quotation marks because from my point of view, if reviewers agree, the PR can be merged immediately and as-is :-)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28081a6aa6a13199e6ee3c09ab544139eb23a3fa", "html_url": "https://github.com/rust-lang/rust/commit/28081a6aa6a13199e6ee3c09ab544139eb23a3fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28081a6aa6a13199e6ee3c09ab544139eb23a3fa/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d4c3125bebdcc8a4cc6de2a9925c7259fde2b63", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d4c3125bebdcc8a4cc6de2a9925c7259fde2b63", "html_url": "https://github.com/rust-lang/rust/commit/3d4c3125bebdcc8a4cc6de2a9925c7259fde2b63"}, {"sha": "33696fa9cab5bec947147d65833233b957b5edd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/33696fa9cab5bec947147d65833233b957b5edd5", "html_url": "https://github.com/rust-lang/rust/commit/33696fa9cab5bec947147d65833233b957b5edd5"}], "stats": {"total": 177, "additions": 177, "deletions": 0}, "files": [{"sha": "9bc9182f7b53c3b170d0634ed959164f5b4204ea", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/28081a6aa6a13199e6ee3c09ab544139eb23a3fa/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28081a6aa6a13199e6ee3c09ab544139eb23a3fa/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=28081a6aa6a13199e6ee3c09ab544139eb23a3fa", "patch": "@@ -654,6 +654,20 @@ impl<T> Arc<T> {\n     ///\n     /// This will succeed even if there are outstanding weak references.\n     ///\n+    // FIXME: when `Arc::into_inner` is stabilized, add this paragraph:\n+    /*\n+    /// It is strongly recommended to use [`Arc::into_inner`] instead if you don't\n+    /// want to keep the `Arc` in the [`Err`] case.\n+    /// Immediately dropping the [`Err`] payload, like in the expression\n+    /// `Arc::try_unwrap(this).ok()`, can still cause the strong count to\n+    /// drop to zero and the inner value of the `Arc` to be dropped:\n+    /// For instance if two threads execute this expression in parallel, then\n+    /// there is a race condition. The threads could first both check whether they\n+    /// have the last clone of their `Arc` via `Arc::try_unwrap`, and then\n+    /// both drop their `Arc` in the call to [`ok`][`Result::ok`],\n+    /// taking the strong count from two down to zero.\n+    ///\n+     */\n     /// # Examples\n     ///\n     /// ```\n@@ -685,6 +699,137 @@ impl<T> Arc<T> {\n             Ok(elem)\n         }\n     }\n+\n+    /// Returns the inner value, if the `Arc` has exactly one strong reference.\n+    ///\n+    /// Otherwise, [`None`] is returned and the `Arc` is dropped.\n+    ///\n+    /// This will succeed even if there are outstanding weak references.\n+    ///\n+    /// If `Arc::into_inner` is called on every clone of this `Arc`,\n+    /// it is guaranteed that exactly one of the calls returns the inner value.\n+    /// This means in particular that the inner value is not dropped.\n+    ///\n+    /// The similar expression `Arc::try_unwrap(this).ok()` does not\n+    /// offer such a guarantee. See the last example below.\n+    //\n+    // FIXME: when `Arc::into_inner` is stabilized, add this to end\n+    // of the previous sentence:\n+    /*\n+    /// and the documentation of [`Arc::try_unwrap`].\n+     */\n+    ///\n+    /// # Examples\n+    ///\n+    /// Minimal example demonstrating the guarantee that `Arc::into_inner` gives.\n+    /// ```\n+    /// #![feature(arc_into_inner)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(3);\n+    /// let y = Arc::clone(&x);\n+    ///\n+    /// // Two threads calling `Arc::into_inner` on both clones of an `Arc`:\n+    /// let x_thread = std::thread::spawn(|| Arc::into_inner(x));\n+    /// let y_thread = std::thread::spawn(|| Arc::into_inner(y));\n+    ///\n+    /// let x_inner_value = x_thread.join().unwrap();\n+    /// let y_inner_value = y_thread.join().unwrap();\n+    ///\n+    /// // One of the threads is guaranteed to receive the inner value:\n+    /// assert!(matches!(\n+    ///     (x_inner_value, y_inner_value),\n+    ///     (None, Some(3)) | (Some(3), None)\n+    /// ));\n+    /// // The result could also be `(None, None)` if the threads called\n+    /// // `Arc::try_unwrap(x).ok()` and `Arc::try_unwrap(y).ok()` instead.\n+    /// ```\n+    ///\n+    /// A more practical example demonstrating the need for `Arc::into_inner`:\n+    /// ```\n+    /// #![feature(arc_into_inner)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// // Definition of a simple singly linked list using `Arc`:\n+    /// #[derive(Clone)]\n+    /// struct LinkedList<T>(Option<Arc<Node<T>>>);\n+    /// struct Node<T>(T, Option<Arc<Node<T>>>);\n+    ///\n+    /// // Dropping a long `LinkedList<T>` relying on the destructor of `Arc`\n+    /// // can cause a stack overflow. To prevent this, we can provide a\n+    /// // manual `Drop` implementation that does the destruction in a loop:\n+    /// impl<T> Drop for LinkedList<T> {\n+    ///     fn drop(&mut self) {\n+    ///         let mut link = self.0.take();\n+    ///         while let Some(arc_node) = link.take() {\n+    ///             if let Some(Node(_value, next)) = Arc::into_inner(arc_node) {\n+    ///                 link = next;\n+    ///             }\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// // Implementation of `new` and `push` omitted\n+    /// impl<T> LinkedList<T> {\n+    ///     /* ... */\n+    /// #   fn new() -> Self {\n+    /// #       LinkedList(None)\n+    /// #   }\n+    /// #   fn push(&mut self, x: T) {\n+    /// #       self.0 = Some(Arc::new(Node(x, self.0.take())));\n+    /// #   }\n+    /// }\n+    ///\n+    /// // The following code could have still caused a stack overflow\n+    /// // despite the manual `Drop` impl if that `Drop` impl had used\n+    /// // `Arc::try_unwrap(arc).ok()` instead of `Arc::into_inner(arc)`.\n+    ///\n+    /// // Create a long list and clone it\n+    /// let mut x = LinkedList::new();\n+    /// for i in 0..100000 {\n+    ///     x.push(i); // Adds i to the front of x\n+    /// }\n+    /// let y = x.clone();\n+    ///\n+    /// // Drop the clones in parallel\n+    /// let x_thread = std::thread::spawn(|| drop(x));\n+    /// let y_thread = std::thread::spawn(|| drop(y));\n+    /// x_thread.join().unwrap();\n+    /// y_thread.join().unwrap();\n+    /// ```\n+\n+    // FIXME: when `Arc::into_inner` is stabilized, adjust above documentation\n+    // and the documentation of `Arc::try_unwrap` according to the `FIXME`s. Also\n+    // open an issue on rust-lang/rust-clippy, asking for a lint against\n+    // `Arc::try_unwrap(...).ok()`.\n+    #[inline]\n+    #[unstable(feature = \"arc_into_inner\", issue = \"106894\")]\n+    pub fn into_inner(this: Self) -> Option<T> {\n+        // Make sure that the ordinary `Drop` implementation isn\u2019t called as well\n+        let mut this = mem::ManuallyDrop::new(this);\n+\n+        // Following the implementation of `drop` and `drop_slow`\n+        if this.inner().strong.fetch_sub(1, Release) != 1 {\n+            return None;\n+        }\n+\n+        acquire!(this.inner().strong);\n+\n+        // SAFETY: This mirrors the line\n+        //\n+        //     unsafe { ptr::drop_in_place(Self::get_mut_unchecked(self)) };\n+        //\n+        // in `drop_slow`. Instead of dropping the value behind the pointer,\n+        // it is read and eventually returned; `ptr::read` has the same\n+        // safety conditions as `ptr::drop_in_place`.\n+        let inner = unsafe { ptr::read(Self::get_mut_unchecked(&mut this)) };\n+\n+        drop(Weak { ptr: this.ptr });\n+\n+        Some(inner)\n+    }\n }\n \n impl<T> Arc<[T]> {"}, {"sha": "863d58bdf4d9cdad35f341f1aeb519a67f9bb63f", "filename": "library/alloc/src/sync/tests.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/28081a6aa6a13199e6ee3c09ab544139eb23a3fa/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28081a6aa6a13199e6ee3c09ab544139eb23a3fa/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs?ref=28081a6aa6a13199e6ee3c09ab544139eb23a3fa", "patch": "@@ -101,6 +101,38 @@ fn try_unwrap() {\n     assert_eq!(Arc::try_unwrap(x), Ok(5));\n }\n \n+#[test]\n+fn into_inner() {\n+    for _ in 0..100\n+    // ^ Increase chances of hitting potential race conditions\n+    {\n+        let x = Arc::new(3);\n+        let y = Arc::clone(&x);\n+        let r_thread = std::thread::spawn(|| Arc::into_inner(x));\n+        let s_thread = std::thread::spawn(|| Arc::into_inner(y));\n+        let r = r_thread.join().expect(\"r_thread panicked\");\n+        let s = s_thread.join().expect(\"s_thread panicked\");\n+        assert!(\n+            matches!((r, s), (None, Some(3)) | (Some(3), None)),\n+            \"assertion failed: unexpected result `{:?}`\\\n+            \\n  expected `(None, Some(3))` or `(Some(3), None)`\",\n+            (r, s),\n+        );\n+    }\n+\n+    let x = Arc::new(3);\n+    assert_eq!(Arc::into_inner(x), Some(3));\n+\n+    let x = Arc::new(4);\n+    let y = Arc::clone(&x);\n+    assert_eq!(Arc::into_inner(x), None);\n+    assert_eq!(Arc::into_inner(y), Some(4));\n+\n+    let x = Arc::new(5);\n+    let _w = Arc::downgrade(&x);\n+    assert_eq!(Arc::into_inner(x), Some(5));\n+}\n+\n #[test]\n fn into_from_raw() {\n     let x = Arc::new(Box::new(\"hello\"));"}]}