{"sha": "579e31929feff51dcaf8d444648eff8de735f91a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3OWUzMTkyOWZlZmY1MWRjYWY4ZDQ0NDY0OGVmZjhkZTczNWY5MWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-15T10:10:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-15T10:10:35Z"}, "message": "Auto merge of #25400 - nrc:save-api, r=huonw\n\nAlso start factoring out an API for compiler tools to use and fix a bug that was preventing DXR indexing Rust properly.\r\n\r\nr? @huonw", "tree": {"sha": "31f5dc79e20d511d9fea4c0d0732c70afb4b4066", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31f5dc79e20d511d9fea4c0d0732c70afb4b4066"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/579e31929feff51dcaf8d444648eff8de735f91a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/579e31929feff51dcaf8d444648eff8de735f91a", "html_url": "https://github.com/rust-lang/rust/commit/579e31929feff51dcaf8d444648eff8de735f91a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/579e31929feff51dcaf8d444648eff8de735f91a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "072cba9a536013534352bceddbb417b3df41e8da", "url": "https://api.github.com/repos/rust-lang/rust/commits/072cba9a536013534352bceddbb417b3df41e8da", "html_url": "https://github.com/rust-lang/rust/commit/072cba9a536013534352bceddbb417b3df41e8da"}, {"sha": "7555e7081df536796aa7163a456b6f8cc4649595", "url": "https://api.github.com/repos/rust-lang/rust/commits/7555e7081df536796aa7163a456b6f8cc4649595", "html_url": "https://github.com/rust-lang/rust/commit/7555e7081df536796aa7163a456b6f8cc4649595"}], "stats": {"total": 3266, "additions": 1756, "deletions": 1510}, "files": [{"sha": "7f66d3a833fde3e8fa4b31646902116ad3c690f7", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "added", "additions": 1486, "deletions": 0, "changes": 1486, "blob_url": "https://github.com/rust-lang/rust/blob/579e31929feff51dcaf8d444648eff8de735f91a/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579e31929feff51dcaf8d444648eff8de735f91a/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=579e31929feff51dcaf8d444648eff8de735f91a", "patch": "@@ -0,0 +1,1486 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Output a CSV file containing the output from rustc's analysis. The data is\n+//! primarily designed to be used as input to the DXR tool, specifically its\n+//! Rust plugin. It could also be used by IDEs or other code browsing, search, or\n+//! cross-referencing tools.\n+//!\n+//! Dumping the analysis is implemented by walking the AST and getting a bunch of\n+//! info out from all over the place. We use Def IDs to identify objects. The\n+//! tricky part is getting syntactic (span, source text) and semantic (reference\n+//! Def IDs) information for parts of expressions which the compiler has discarded.\n+//! E.g., in a path `foo::bar::baz`, the compiler only keeps a span for the whole\n+//! path and a reference to `baz`, but we want spans and references for all three\n+//! idents.\n+//!\n+//! SpanUtils is used to manipulate spans. In particular, to extract sub-spans\n+//! from spans (e.g., the span for `bar` from the above example path).\n+//! Recorder is used for recording the output in csv format. FmtStrs separates\n+//! the format of the output away from extracting it from the compiler.\n+//! DumpCsvVisitor walks the AST and processes it.\n+\n+\n+use super::{escape, generated_code, recorder, SaveContext, PathCollector};\n+\n+use session::Session;\n+\n+use middle::def;\n+use middle::ty::{self, Ty};\n+\n+use std::cell::Cell;\n+use std::fs::File;\n+use std::path::Path;\n+\n+use syntax::ast_util;\n+use syntax::ast::{self, NodeId, DefId};\n+use syntax::ast_map::NodeItem;\n+use syntax::codemap::*;\n+use syntax::parse::token::{self, get_ident, keywords};\n+use syntax::owned_slice::OwnedSlice;\n+use syntax::visit::{self, Visitor};\n+use syntax::print::pprust::{path_to_string, ty_to_string};\n+use syntax::ptr::P;\n+\n+use super::span_utils::SpanUtils;\n+use super::recorder::{Recorder, FmtStrs};\n+\n+use util::ppaux;\n+\n+\n+pub struct DumpCsvVisitor<'l, 'tcx: 'l> {\n+    save_ctxt: SaveContext<'l, 'tcx>,\n+    sess: &'l Session,\n+    analysis: &'l ty::CrateAnalysis<'tcx>,\n+\n+    span: SpanUtils<'l>,\n+    fmt: FmtStrs<'l>,\n+\n+    cur_scope: NodeId\n+}\n+\n+impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n+    pub fn new(sess: &'l Session,\n+               analysis: &'l ty::CrateAnalysis<'tcx>,\n+               output_file: Box<File>) -> DumpCsvVisitor<'l, 'tcx> {\n+        DumpCsvVisitor {\n+            sess: sess,\n+            save_ctxt: SaveContext::new(sess, analysis, SpanUtils {\n+                sess: sess,\n+                err_count: Cell::new(0)\n+            }),\n+            analysis: analysis,\n+            span: SpanUtils {\n+                sess: sess,\n+                err_count: Cell::new(0)\n+            },\n+            fmt: FmtStrs::new(box Recorder {\n+                                out: output_file,\n+                                dump_spans: false,\n+                            },\n+                            SpanUtils {\n+                                sess: sess,\n+                                err_count: Cell::new(0)\n+                            }),\n+            cur_scope: 0\n+        }\n+    }\n+\n+    fn nest<F>(&mut self, scope_id: NodeId, f: F) where\n+        F: FnOnce(&mut DumpCsvVisitor<'l, 'tcx>),\n+    {\n+        let parent_scope = self.cur_scope;\n+        self.cur_scope = scope_id;\n+        f(self);\n+        self.cur_scope = parent_scope;\n+    }\n+\n+    pub fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {\n+        // The current crate.\n+        self.fmt.crate_str(krate.span, name);\n+\n+        // Dump info about all the external crates referenced from this crate.\n+        for c in &self.save_ctxt.get_external_crates() {\n+            self.fmt.external_crate_str(krate.span, &c.name, c.number);\n+        }\n+        self.fmt.recorder.record(\"end_external_crates\\n\");\n+    }\n+\n+    // Return all non-empty prefixes of a path.\n+    // For each prefix, we return the span for the last segment in the prefix and\n+    // a str representation of the entire prefix.\n+    fn process_path_prefixes(&self, path: &ast::Path) -> Vec<(Span, String)> {\n+        let spans = self.span.spans_for_path_segments(path);\n+\n+        // Paths to enums seem to not match their spans - the span includes all the\n+        // variants too. But they seem to always be at the end, so I hope we can cope with\n+        // always using the first ones. So, only error out if we don't have enough spans.\n+        // What could go wrong...?\n+        if spans.len() < path.segments.len() {\n+            error!(\"Mis-calculated spans for path '{}'. \\\n+                    Found {} spans, expected {}. Found spans:\",\n+                   path_to_string(path), spans.len(), path.segments.len());\n+            for s in &spans {\n+                let loc = self.sess.codemap().lookup_char_pos(s.lo);\n+                error!(\"    '{}' in {}, line {}\",\n+                       self.span.snippet(*s), loc.file.name, loc.line);\n+            }\n+            return vec!();\n+        }\n+\n+        let mut result: Vec<(Span, String)> = vec!();\n+\n+        let mut segs = vec!();\n+        for (i, (seg, span)) in path.segments.iter().zip(spans.iter()).enumerate() {\n+            segs.push(seg.clone());\n+            let sub_path = ast::Path{span: *span, // span for the last segment\n+                                     global: path.global,\n+                                     segments: segs};\n+            let qualname = if i == 0 && path.global {\n+                format!(\"::{}\", path_to_string(&sub_path))\n+            } else {\n+                path_to_string(&sub_path)\n+            };\n+            result.push((*span, qualname));\n+            segs = sub_path.segments;\n+        }\n+\n+        result\n+    }\n+\n+    // The global arg allows us to override the global-ness of the path (which\n+    // actually means 'does the path start with `::`', rather than 'is the path\n+    // semantically global). We use the override for `use` imports (etc.) where\n+    // the syntax is non-global, but the semantics are global.\n+    fn write_sub_paths(&mut self, path: &ast::Path, global: bool) {\n+        let sub_paths = self.process_path_prefixes(path);\n+        for (i, &(ref span, ref qualname)) in sub_paths.iter().enumerate() {\n+            let qualname = if i == 0 && global && !path.global {\n+                format!(\"::{}\", qualname)\n+            } else {\n+                qualname.clone()\n+            };\n+            self.fmt.sub_mod_ref_str(path.span,\n+                                     *span,\n+                                     &qualname[..],\n+                                     self.cur_scope);\n+        }\n+    }\n+\n+    // As write_sub_paths, but does not process the last ident in the path (assuming it\n+    // will be processed elsewhere). See note on write_sub_paths about global.\n+    fn write_sub_paths_truncated(&mut self, path: &ast::Path, global: bool) {\n+        let sub_paths = self.process_path_prefixes(path);\n+        let len = sub_paths.len();\n+        if len <= 1 {\n+            return;\n+        }\n+\n+        let sub_paths = &sub_paths[..len-1];\n+        for (i, &(ref span, ref qualname)) in sub_paths.iter().enumerate() {\n+            let qualname = if i == 0 && global && !path.global {\n+                format!(\"::{}\", qualname)\n+            } else {\n+                qualname.clone()\n+            };\n+            self.fmt.sub_mod_ref_str(path.span,\n+                                     *span,\n+                                     &qualname[..],\n+                                     self.cur_scope);\n+        }\n+    }\n+\n+    // As write_sub_paths, but expects a path of the form module_path::trait::method\n+    // Where trait could actually be a struct too.\n+    fn write_sub_path_trait_truncated(&mut self, path: &ast::Path) {\n+        let sub_paths = self.process_path_prefixes(path);\n+        let len = sub_paths.len();\n+        if len <= 1 {\n+            return;\n+        }\n+        let sub_paths = &sub_paths[.. (len-1)];\n+\n+        // write the trait part of the sub-path\n+        let (ref span, ref qualname) = sub_paths[len-2];\n+        self.fmt.sub_type_ref_str(path.span,\n+                                  *span,\n+                                  &qualname[..]);\n+\n+        // write the other sub-paths\n+        if len <= 2 {\n+            return;\n+        }\n+        let sub_paths = &sub_paths[..len-2];\n+        for &(ref span, ref qualname) in sub_paths {\n+            self.fmt.sub_mod_ref_str(path.span,\n+                                     *span,\n+                                     &qualname[..],\n+                                     self.cur_scope);\n+        }\n+    }\n+\n+    // looks up anything, not just a type\n+    fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n+        if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n+            self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n+                                  ref_id));\n+        }\n+        let def = self.analysis.ty_cx.def_map.borrow().get(&ref_id).unwrap().full_def();\n+        match def {\n+            def::DefPrimTy(_) => None,\n+            _ => Some(def.def_id()),\n+        }\n+    }\n+\n+    fn lookup_def_kind(&self, ref_id: NodeId, span: Span) -> Option<recorder::Row> {\n+        let def_map = self.analysis.ty_cx.def_map.borrow();\n+        if !def_map.contains_key(&ref_id) {\n+            self.sess.span_bug(span, &format!(\"def_map has no key for {} in lookup_def_kind\",\n+                                             ref_id));\n+        }\n+        let def = def_map.get(&ref_id).unwrap().full_def();\n+        match def {\n+            def::DefMod(_) |\n+            def::DefForeignMod(_) => Some(recorder::ModRef),\n+            def::DefStruct(_) => Some(recorder::StructRef),\n+            def::DefTy(..) |\n+            def::DefAssociatedTy(..) |\n+            def::DefTrait(_) => Some(recorder::TypeRef),\n+            def::DefStatic(_, _) |\n+            def::DefConst(_) |\n+            def::DefAssociatedConst(..) |\n+            def::DefLocal(_) |\n+            def::DefVariant(_, _, _) |\n+            def::DefUpvar(..) => Some(recorder::VarRef),\n+\n+            def::DefFn(..) => Some(recorder::FnRef),\n+\n+            def::DefSelfTy(..) |\n+            def::DefRegion(_) |\n+            def::DefLabel(_) |\n+            def::DefTyParam(..) |\n+            def::DefUse(_) |\n+            def::DefMethod(..) |\n+            def::DefPrimTy(_) => {\n+                self.sess.span_bug(span, &format!(\"lookup_def_kind for unexpected item: {:?}\",\n+                                                 def));\n+            },\n+        }\n+    }\n+\n+    fn process_formals(&mut self, formals: &Vec<ast::Arg>, qualname: &str) {\n+        for arg in formals {\n+            self.visit_pat(&arg.pat);\n+            let mut collector = PathCollector::new();\n+            collector.visit_pat(&arg.pat);\n+            let span_utils = self.span.clone();\n+            for &(id, ref p, _, _) in &collector.collected_paths {\n+                let typ =\n+                    ppaux::ty_to_string(\n+                        &self.analysis.ty_cx,\n+                        *self.analysis.ty_cx.node_types().get(&id).unwrap());\n+                // get the span only for the name of the variable (I hope the path is only ever a\n+                // variable name, but who knows?)\n+                self.fmt.formal_str(p.span,\n+                                    span_utils.span_for_last_ident(p.span),\n+                                    id,\n+                                    qualname,\n+                                    &path_to_string(p),\n+                                    &typ[..]);\n+            }\n+        }\n+    }\n+\n+    fn process_method(&mut self, sig: &ast::MethodSig,\n+                      body: Option<&ast::Block>,\n+                      id: ast::NodeId, name: ast::Name,\n+                      span: Span) {\n+        if generated_code(span) {\n+            return;\n+        }\n+\n+        debug!(\"process_method: {}:{}\", id, token::get_name(name));\n+\n+        let mut scope_id;\n+        // The qualname for a method is the trait name or name of the struct in an impl in\n+        // which the method is declared in, followed by the method's name.\n+        let qualname = match ty::impl_of_method(&self.analysis.ty_cx,\n+                                                ast_util::local_def(id)) {\n+            Some(impl_id) => match self.analysis.ty_cx.map.get(impl_id.node) {\n+                NodeItem(item) => {\n+                    scope_id = item.id;\n+                    match item.node {\n+                        ast::ItemImpl(_, _, _, _, ref ty, _) => {\n+                            let mut result = String::from_str(\"<\");\n+                            result.push_str(&ty_to_string(&**ty));\n+\n+                            match ty::trait_of_item(&self.analysis.ty_cx,\n+                                                    ast_util::local_def(id)) {\n+                                Some(def_id) => {\n+                                    result.push_str(\" as \");\n+                                    result.push_str(\n+                                        &ty::item_path_str(&self.analysis.ty_cx, def_id));\n+                                },\n+                                None => {}\n+                            }\n+                            result.push_str(\">\");\n+                            result\n+                        }\n+                        _ => {\n+                            self.sess.span_bug(span,\n+                                &format!(\"Container {} for method {} not an impl?\",\n+                                         impl_id.node, id));\n+                        },\n+                    }\n+                },\n+                _ => {\n+                    self.sess.span_bug(span,\n+                        &format!(\"Container {} for method {} is not a node item {:?}\",\n+                                 impl_id.node, id, self.analysis.ty_cx.map.get(impl_id.node)));\n+                },\n+            },\n+            None => match ty::trait_of_item(&self.analysis.ty_cx,\n+                                            ast_util::local_def(id)) {\n+                Some(def_id) => {\n+                    scope_id = def_id.node;\n+                    match self.analysis.ty_cx.map.get(def_id.node) {\n+                        NodeItem(_) => {\n+                            format!(\"::{}\", ty::item_path_str(&self.analysis.ty_cx, def_id))\n+                        }\n+                        _ => {\n+                            self.sess.span_bug(span,\n+                                &format!(\"Could not find container {} for method {}\",\n+                                         def_id.node, id));\n+                        }\n+                    }\n+                },\n+                None => {\n+                    self.sess.span_bug(span,\n+                        &format!(\"Could not find container for method {}\", id));\n+                },\n+            },\n+        };\n+\n+        let qualname = &format!(\"{}::{}\", qualname, &token::get_name(name));\n+\n+        // record the decl for this def (if it has one)\n+        let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n+                                             ast_util::local_def(id))\n+            .and_then(|new_id| {\n+                let def_id = new_id.def_id();\n+                if def_id.node != 0 && def_id != ast_util::local_def(id) {\n+                    Some(def_id)\n+                } else {\n+                    None\n+                }\n+            });\n+\n+        let sub_span = self.span.sub_span_after_keyword(span, keywords::Fn);\n+        if body.is_some() {\n+            self.fmt.method_str(span,\n+                                sub_span,\n+                                id,\n+                                qualname,\n+                                decl_id,\n+                                scope_id);\n+            self.process_formals(&sig.decl.inputs, qualname);\n+        } else {\n+            self.fmt.method_decl_str(span,\n+                                     sub_span,\n+                                     id,\n+                                     qualname,\n+                                     scope_id);\n+        }\n+\n+        // walk arg and return types\n+        for arg in &sig.decl.inputs {\n+            self.visit_ty(&arg.ty);\n+        }\n+\n+        if let ast::Return(ref ret_ty) = sig.decl.output {\n+            self.visit_ty(ret_ty);\n+        }\n+\n+        // walk the fn body\n+        if let Some(body) = body {\n+            self.nest(id, |v| v.visit_block(body));\n+        }\n+\n+        self.process_generic_params(&sig.generics,\n+                                    span,\n+                                    qualname,\n+                                    id);\n+    }\n+\n+    fn process_trait_ref(&mut self,\n+                         trait_ref: &ast::TraitRef) {\n+        match self.lookup_type_ref(trait_ref.ref_id) {\n+            Some(id) => {\n+                let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n+                self.fmt.ref_str(recorder::TypeRef,\n+                                 trait_ref.path.span,\n+                                 sub_span,\n+                                 id,\n+                                 self.cur_scope);\n+                visit::walk_path(self, &trait_ref.path);\n+            },\n+            None => ()\n+        }\n+    }\n+\n+    fn process_struct_field_def(&mut self,\n+                                field: &ast::StructField,\n+                                qualname: &str,\n+                                scope_id: NodeId) {\n+        match field.node.kind {\n+            ast::NamedField(ident, _) => {\n+                let name = get_ident(ident);\n+                let qualname = format!(\"{}::{}\", qualname, name);\n+                let typ =\n+                    ppaux::ty_to_string(\n+                        &self.analysis.ty_cx,\n+                        *self.analysis.ty_cx.node_types().get(&field.node.id).unwrap());\n+                match self.span.sub_span_before_token(field.span, token::Colon) {\n+                    Some(sub_span) => self.fmt.field_str(field.span,\n+                                                         Some(sub_span),\n+                                                         field.node.id,\n+                                                         &name[..],\n+                                                         &qualname[..],\n+                                                         &typ[..],\n+                                                         scope_id),\n+                    None => self.sess.span_bug(field.span,\n+                                               &format!(\"Could not find sub-span for field {}\",\n+                                                       qualname)),\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    // Dump generic params bindings, then visit_generics\n+    fn process_generic_params(&mut self,\n+                              generics:&ast::Generics,\n+                              full_span: Span,\n+                              prefix: &str,\n+                              id: NodeId) {\n+        // We can't only use visit_generics since we don't have spans for param\n+        // bindings, so we reparse the full_span to get those sub spans.\n+        // However full span is the entire enum/fn/struct block, so we only want\n+        // the first few to match the number of generics we're looking for.\n+        let param_sub_spans = self.span.spans_for_ty_params(full_span,\n+                                                           (generics.ty_params.len() as isize));\n+        for (param, param_ss) in generics.ty_params.iter().zip(param_sub_spans.iter()) {\n+            // Append $id to name to make sure each one is unique\n+            let name = format!(\"{}::{}${}\",\n+                               prefix,\n+                               escape(self.span.snippet(*param_ss)),\n+                               id);\n+            self.fmt.typedef_str(full_span,\n+                                 Some(*param_ss),\n+                                 param.id,\n+                                 &name[..],\n+                                 \"\");\n+        }\n+        self.visit_generics(generics);\n+    }\n+\n+    fn process_fn(&mut self,\n+                  item: &ast::Item,\n+                  decl: &ast::FnDecl,\n+                  ty_params: &ast::Generics,\n+                  body: &ast::Block) {\n+        let fn_data = self.save_ctxt.get_item_data(item);\n+        if let super::Data::FunctionData(fn_data) = fn_data {\n+            self.fmt.fn_str(item.span,\n+                            Some(fn_data.span),\n+                            fn_data.id,\n+                            &fn_data.qualname,\n+                            fn_data.scope);\n+\n+\n+            self.process_formals(&decl.inputs, &fn_data.qualname);\n+            self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n+        } else {\n+            unreachable!();\n+        }\n+\n+        for arg in &decl.inputs {\n+            self.visit_ty(&arg.ty);\n+        }\n+\n+        if let ast::Return(ref ret_ty) = decl.output {\n+            self.visit_ty(&ret_ty);\n+        }\n+\n+        self.nest(item.id, |v| v.visit_block(&body));\n+    }\n+\n+    fn process_static_or_const_item(&mut self,\n+                                    item: &ast::Item,\n+                                    typ: &ast::Ty,\n+                                    expr: &ast::Expr)\n+    {\n+        let var_data = self.save_ctxt.get_item_data(item);\n+        if let super::Data::VariableData(var_data) = var_data {\n+            self.fmt.static_str(item.span,\n+                                Some(var_data.span),\n+                                var_data.id,\n+                                &var_data.name,\n+                                &var_data.qualname,\n+                                &var_data.value,\n+                                &var_data.type_value,\n+                                var_data.scope);\n+        } else {\n+            unreachable!();\n+        }\n+\n+        self.visit_ty(&typ);\n+        self.visit_expr(expr);\n+    }\n+\n+    fn process_const(&mut self,\n+                     id: ast::NodeId,\n+                     ident: &ast::Ident,\n+                     span: Span,\n+                     typ: &ast::Ty,\n+                     expr: &ast::Expr)\n+    {\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(id));\n+\n+        let sub_span = self.span.sub_span_after_keyword(span,\n+                                                        keywords::Const);\n+\n+        self.fmt.static_str(span,\n+                            sub_span,\n+                            id,\n+                            &get_ident((*ident).clone()),\n+                            &qualname[..],\n+                            &self.span.snippet(expr.span),\n+                            &ty_to_string(&*typ),\n+                            self.cur_scope);\n+\n+        // walk type and init value\n+        self.visit_ty(typ);\n+        self.visit_expr(expr);\n+    }\n+\n+    fn process_struct(&mut self,\n+                      item: &ast::Item,\n+                      def: &ast::StructDef,\n+                      ty_params: &ast::Generics) {\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+\n+        let ctor_id = match def.ctor_id {\n+            Some(node_id) => node_id,\n+            None => -1,\n+        };\n+        let val = self.span.snippet(item.span);\n+        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Struct);\n+        self.fmt.struct_str(item.span,\n+                            sub_span,\n+                            item.id,\n+                            ctor_id,\n+                            &qualname[..],\n+                            self.cur_scope,\n+                            &val[..]);\n+\n+        // fields\n+        for field in &def.fields {\n+            self.process_struct_field_def(field, &qualname[..], item.id);\n+            self.visit_ty(&*field.node.ty);\n+        }\n+\n+        self.process_generic_params(ty_params, item.span, &qualname[..], item.id);\n+    }\n+\n+    fn process_enum(&mut self,\n+                    item: &ast::Item,\n+                    enum_definition: &ast::EnumDef,\n+                    ty_params: &ast::Generics) {\n+        let enum_name = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+        let val = self.span.snippet(item.span);\n+        match self.span.sub_span_after_keyword(item.span, keywords::Enum) {\n+            Some(sub_span) => self.fmt.enum_str(item.span,\n+                                                Some(sub_span),\n+                                                item.id,\n+                                                &enum_name[..],\n+                                                self.cur_scope,\n+                                                &val[..]),\n+            None => self.sess.span_bug(item.span,\n+                                       &format!(\"Could not find subspan for enum {}\",\n+                                               enum_name)),\n+        }\n+        for variant in &enum_definition.variants {\n+            let name = get_ident(variant.node.name);\n+            let name = &name;\n+            let mut qualname = enum_name.clone();\n+            qualname.push_str(\"::\");\n+            qualname.push_str(name);\n+            let val = self.span.snippet(variant.span);\n+            match variant.node.kind {\n+                ast::TupleVariantKind(ref args) => {\n+                    // first ident in span is the variant's name\n+                    self.fmt.tuple_variant_str(variant.span,\n+                                               self.span.span_for_first_ident(variant.span),\n+                                               variant.node.id,\n+                                               name,\n+                                               &qualname[..],\n+                                               &enum_name[..],\n+                                               &val[..],\n+                                               item.id);\n+                    for arg in args {\n+                        self.visit_ty(&*arg.ty);\n+                    }\n+                }\n+                ast::StructVariantKind(ref struct_def) => {\n+                    let ctor_id = match struct_def.ctor_id {\n+                        Some(node_id) => node_id,\n+                        None => -1,\n+                    };\n+                    self.fmt.struct_variant_str(\n+                        variant.span,\n+                        self.span.span_for_first_ident(variant.span),\n+                        variant.node.id,\n+                        ctor_id,\n+                        &qualname[..],\n+                        &enum_name[..],\n+                        &val[..],\n+                        item.id);\n+\n+                    for field in &struct_def.fields {\n+                        self.process_struct_field_def(field, &qualname, variant.node.id);\n+                        self.visit_ty(&*field.node.ty);\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.process_generic_params(ty_params, item.span, &enum_name[..], item.id);\n+    }\n+\n+    fn process_impl(&mut self,\n+                    item: &ast::Item,\n+                    type_parameters: &ast::Generics,\n+                    trait_ref: &Option<ast::TraitRef>,\n+                    typ: &ast::Ty,\n+                    impl_items: &[P<ast::ImplItem>]) {\n+        let trait_id = trait_ref.as_ref().and_then(|tr| self.lookup_type_ref(tr.ref_id));\n+        match typ.node {\n+            // Common case impl for a struct or something basic.\n+            ast::TyPath(None, ref path) => {\n+                let sub_span = self.span.sub_span_for_type_name(path.span);\n+                let self_id = self.lookup_type_ref(typ.id).map(|id| {\n+                    self.fmt.ref_str(recorder::TypeRef,\n+                                     path.span,\n+                                     sub_span,\n+                                     id,\n+                                     self.cur_scope);\n+                    id\n+                });\n+                self.fmt.impl_str(path.span,\n+                                  sub_span,\n+                                  item.id,\n+                                  self_id,\n+                                  trait_id,\n+                                  self.cur_scope);\n+            },\n+            _ => {\n+                // Less useful case, impl for a compound type.\n+                self.visit_ty(&*typ);\n+\n+                let sub_span = self.span.sub_span_for_type_name(typ.span);\n+                self.fmt.impl_str(typ.span,\n+                                  sub_span,\n+                                  item.id,\n+                                  None,\n+                                  trait_id,\n+                                  self.cur_scope);\n+            }\n+        }\n+\n+        match *trait_ref {\n+            Some(ref trait_ref) => self.process_trait_ref(trait_ref),\n+            None => (),\n+        }\n+\n+        self.process_generic_params(type_parameters, item.span, \"\", item.id);\n+        for impl_item in impl_items {\n+            self.visit_impl_item(impl_item);\n+        }\n+    }\n+\n+    fn process_trait(&mut self,\n+                     item: &ast::Item,\n+                     generics: &ast::Generics,\n+                     trait_refs: &OwnedSlice<ast::TyParamBound>,\n+                     methods: &[P<ast::TraitItem>]) {\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+        let val = self.span.snippet(item.span);\n+        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n+        self.fmt.trait_str(item.span,\n+                           sub_span,\n+                           item.id,\n+                           &qualname[..],\n+                           self.cur_scope,\n+                           &val[..]);\n+\n+        // super-traits\n+        for super_bound in &**trait_refs {\n+            let trait_ref = match *super_bound {\n+                ast::TraitTyParamBound(ref trait_ref, _) => {\n+                    trait_ref\n+                }\n+                ast::RegionTyParamBound(..) => {\n+                    continue;\n+                }\n+            };\n+\n+            let trait_ref = &trait_ref.trait_ref;\n+            match self.lookup_type_ref(trait_ref.ref_id) {\n+                Some(id) => {\n+                    let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n+                    self.fmt.ref_str(recorder::TypeRef,\n+                                     trait_ref.path.span,\n+                                     sub_span,\n+                                     id,\n+                                     self.cur_scope);\n+                    self.fmt.inherit_str(trait_ref.path.span,\n+                                         sub_span,\n+                                         id,\n+                                         item.id);\n+                },\n+                None => ()\n+            }\n+        }\n+\n+        // walk generics and methods\n+        self.process_generic_params(generics, item.span, &qualname[..], item.id);\n+        for method in methods {\n+            self.visit_trait_item(method)\n+        }\n+    }\n+\n+    fn process_mod(&mut self,\n+                   item: &ast::Item,  // The module in question, represented as an item.\n+                   m: &ast::Mod) {\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+\n+        let cm = self.sess.codemap();\n+        let filename = cm.span_to_filename(m.inner);\n+\n+        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Mod);\n+        self.fmt.mod_str(item.span,\n+                         sub_span,\n+                         item.id,\n+                         &qualname[..],\n+                         self.cur_scope,\n+                         &filename[..]);\n+\n+        self.nest(item.id, |v| visit::walk_mod(v, m));\n+    }\n+\n+    fn process_path(&mut self,\n+                    id: NodeId,\n+                    span: Span,\n+                    path: &ast::Path,\n+                    ref_kind: Option<recorder::Row>) {\n+        if generated_code(span) {\n+            return\n+        }\n+\n+        let def_map = self.analysis.ty_cx.def_map.borrow();\n+        if !def_map.contains_key(&id) {\n+            self.sess.span_bug(span,\n+                               &format!(\"def_map has no key for {} in visit_expr\", id));\n+        }\n+        let def = def_map.get(&id).unwrap().full_def();\n+        let sub_span = self.span.span_for_last_ident(span);\n+        match def {\n+            def::DefUpvar(..) |\n+            def::DefLocal(..) |\n+            def::DefStatic(..) |\n+            def::DefConst(..) |\n+            def::DefAssociatedConst(..) |\n+            def::DefVariant(..) => self.fmt.ref_str(ref_kind.unwrap_or(recorder::VarRef),\n+                                                    span,\n+                                                    sub_span,\n+                                                    def.def_id(),\n+                                                    self.cur_scope),\n+            def::DefStruct(def_id) => self.fmt.ref_str(recorder::StructRef,\n+                                                       span,\n+                                                       sub_span,\n+                                                       def_id,\n+                                                       self.cur_scope),\n+            def::DefTy(def_id, _) => self.fmt.ref_str(recorder::TypeRef,\n+                                                      span,\n+                                                      sub_span,\n+                                                      def_id,\n+                                                      self.cur_scope),\n+            def::DefMethod(declid, provenence) => {\n+                let sub_span = self.span.sub_span_for_meth_name(span);\n+                let defid = if declid.krate == ast::LOCAL_CRATE {\n+                    let ti = ty::impl_or_trait_item(&self.analysis.ty_cx,\n+                                                    declid);\n+                    match provenence {\n+                        def::FromTrait(def_id) => {\n+                            Some(ty::trait_items(&self.analysis.ty_cx,\n+                                                 def_id)\n+                                    .iter()\n+                                    .find(|mr| {\n+                                        mr.name() == ti.name()\n+                                    })\n+                                    .unwrap()\n+                                    .def_id())\n+                        }\n+                        def::FromImpl(def_id) => {\n+                            let impl_items = self.analysis\n+                                                 .ty_cx\n+                                                 .impl_items\n+                                                 .borrow();\n+                            Some(impl_items.get(&def_id)\n+                                           .unwrap()\n+                                           .iter()\n+                                           .find(|mr| {\n+                                                ty::impl_or_trait_item(\n+                                                    &self.analysis.ty_cx,\n+                                                    mr.def_id()\n+                                                ).name() == ti.name()\n+                                            })\n+                                           .unwrap()\n+                                           .def_id())\n+                        }\n+                    }\n+                } else {\n+                    None\n+                };\n+                self.fmt.meth_call_str(span,\n+                                       sub_span,\n+                                       defid,\n+                                       Some(declid),\n+                                       self.cur_scope);\n+            },\n+            def::DefFn(def_id, _) => {\n+                self.fmt.fn_call_str(span,\n+                                     sub_span,\n+                                     def_id,\n+                                     self.cur_scope)\n+            }\n+            _ => self.sess.span_bug(span,\n+                                    &format!(\"Unexpected def kind while looking \\\n+                                              up path in `{}`: `{:?}`\",\n+                                             self.span.snippet(span),\n+                                             def)),\n+        }\n+        // modules or types in the path prefix\n+        match def {\n+            def::DefMethod(did, _) => {\n+                let ti = ty::impl_or_trait_item(&self.analysis.ty_cx, did);\n+                if let ty::MethodTraitItem(m) = ti {\n+                    if m.explicit_self == ty::StaticExplicitSelfCategory {\n+                        self.write_sub_path_trait_truncated(path);\n+                    }\n+                }\n+            }\n+            def::DefLocal(_) |\n+            def::DefStatic(_,_) |\n+            def::DefConst(..) |\n+            def::DefAssociatedConst(..) |\n+            def::DefStruct(_) |\n+            def::DefVariant(..) |\n+            def::DefFn(..) => self.write_sub_paths_truncated(path, false),\n+            _ => {},\n+        }\n+    }\n+\n+    fn process_struct_lit(&mut self,\n+                          ex: &ast::Expr,\n+                          path: &ast::Path,\n+                          fields: &Vec<ast::Field>,\n+                          base: &Option<P<ast::Expr>>) {\n+        if generated_code(path.span) {\n+            return\n+        }\n+\n+        self.write_sub_paths_truncated(path, false);\n+\n+        let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, ex).sty;\n+        let struct_def = match *ty {\n+            ty::ty_struct(def_id, _) => {\n+                let sub_span = self.span.span_for_last_ident(path.span);\n+                self.fmt.ref_str(recorder::StructRef,\n+                                 path.span,\n+                                 sub_span,\n+                                 def_id,\n+                                 self.cur_scope);\n+                Some(def_id)\n+            }\n+            _ => None\n+        };\n+\n+        for field in fields {\n+            match struct_def {\n+                Some(struct_def) => {\n+                    let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n+                    for f in &fields {\n+                        if generated_code(field.ident.span) {\n+                            continue;\n+                        }\n+                        if f.name == field.ident.node.name {\n+                            // We don't really need a sub-span here, but no harm done\n+                            let sub_span = self.span.span_for_last_ident(field.ident.span);\n+                            self.fmt.ref_str(recorder::VarRef,\n+                                             field.ident.span,\n+                                             sub_span,\n+                                             f.id,\n+                                             self.cur_scope);\n+                        }\n+                    }\n+                }\n+                None => {}\n+            }\n+\n+            self.visit_expr(&*field.expr)\n+        }\n+        visit::walk_expr_opt(self, base)\n+    }\n+\n+    fn process_method_call(&mut self,\n+                           ex: &ast::Expr,\n+                           args: &Vec<P<ast::Expr>>) {\n+        let method_map = self.analysis.ty_cx.method_map.borrow();\n+        let method_callee = method_map.get(&ty::MethodCall::expr(ex.id)).unwrap();\n+        let (def_id, decl_id) = match method_callee.origin {\n+            ty::MethodStatic(def_id) |\n+            ty::MethodStaticClosure(def_id) => {\n+                // method invoked on an object with a concrete type (not a static method)\n+                let decl_id =\n+                    match ty::trait_item_of_item(&self.analysis.ty_cx,\n+                                                 def_id) {\n+                        None => None,\n+                        Some(decl_id) => Some(decl_id.def_id()),\n+                    };\n+\n+                // This incantation is required if the method referenced is a\n+                // trait's default implementation.\n+                let def_id = match ty::impl_or_trait_item(&self.analysis\n+                                                               .ty_cx,\n+                                                          def_id) {\n+                    ty::MethodTraitItem(method) => {\n+                        method.provided_source.unwrap_or(def_id)\n+                    }\n+                    _ => self.sess\n+                             .span_bug(ex.span,\n+                                       \"save::process_method_call: non-method \\\n+                                        DefId in MethodStatic or MethodStaticClosure\"),\n+                };\n+                (Some(def_id), decl_id)\n+            }\n+            ty::MethodTypeParam(ref mp) => {\n+                // method invoked on a type parameter\n+                let trait_item = ty::trait_item(&self.analysis.ty_cx,\n+                                                mp.trait_ref.def_id,\n+                                                mp.method_num);\n+                (None, Some(trait_item.def_id()))\n+            }\n+            ty::MethodTraitObject(ref mo) => {\n+                // method invoked on a trait instance\n+                let trait_item = ty::trait_item(&self.analysis.ty_cx,\n+                                                mo.trait_ref.def_id,\n+                                                mo.method_num);\n+                (None, Some(trait_item.def_id()))\n+            }\n+        };\n+        let sub_span = self.span.sub_span_for_meth_name(ex.span);\n+        self.fmt.meth_call_str(ex.span,\n+                               sub_span,\n+                               def_id,\n+                               decl_id,\n+                               self.cur_scope);\n+\n+        // walk receiver and args\n+        visit::walk_exprs(self, &args[..]);\n+    }\n+\n+    fn process_pat(&mut self, p:&ast::Pat) {\n+        if generated_code(p.span) {\n+            return\n+        }\n+\n+        match p.node {\n+            ast::PatStruct(ref path, ref fields, _) => {\n+                visit::walk_path(self, path);\n+\n+                let def = self.analysis.ty_cx.def_map.borrow().get(&p.id).unwrap().full_def();\n+                let struct_def = match def {\n+                    def::DefConst(..) | def::DefAssociatedConst(..) => None,\n+                    def::DefVariant(_, variant_id, _) => Some(variant_id),\n+                    _ => {\n+                        match ty::ty_to_def_id(ty::node_id_to_type(&self.analysis.ty_cx, p.id)) {\n+                            None => {\n+                                self.sess.span_bug(p.span,\n+                                                   &format!(\"Could not find struct_def for `{}`\",\n+                                                            self.span.snippet(p.span)));\n+                            }\n+                            Some(def_id) => Some(def_id),\n+                        }\n+                    }\n+                };\n+\n+                if let Some(struct_def) = struct_def {\n+                    let struct_fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n+                    for &Spanned { node: ref field, span } in fields {\n+                        let sub_span = self.span.span_for_first_ident(span);\n+                        for f in &struct_fields {\n+                            if f.name == field.ident.name {\n+                                self.fmt.ref_str(recorder::VarRef,\n+                                                 span,\n+                                                 sub_span,\n+                                                 f.id,\n+                                                 self.cur_scope);\n+                                break;\n+                            }\n+                        }\n+                        self.visit_pat(&*field.pat);\n+                    }\n+                }\n+            }\n+            _ => visit::walk_pat(self, p)\n+        }\n+    }\n+}\n+\n+impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        if generated_code(item.span) {\n+            return\n+        }\n+\n+        match item.node {\n+            ast::ItemUse(ref use_item) => {\n+                match use_item.node {\n+                    ast::ViewPathSimple(ident, ref path) => {\n+                        let sub_span = self.span.span_for_last_ident(path.span);\n+                        let mod_id = match self.lookup_type_ref(item.id) {\n+                            Some(def_id) => {\n+                                match self.lookup_def_kind(item.id, path.span) {\n+                                    Some(kind) => self.fmt.ref_str(kind,\n+                                                                   path.span,\n+                                                                   sub_span,\n+                                                                   def_id,\n+                                                                   self.cur_scope),\n+                                    None => {},\n+                                }\n+                                Some(def_id)\n+                            },\n+                            None => None,\n+                        };\n+\n+                        // 'use' always introduces an alias, if there is not an explicit\n+                        // one, there is an implicit one.\n+                        let sub_span =\n+                            match self.span.sub_span_after_keyword(use_item.span, keywords::As) {\n+                                Some(sub_span) => Some(sub_span),\n+                                None => sub_span,\n+                            };\n+\n+                        self.fmt.use_alias_str(path.span,\n+                                               sub_span,\n+                                               item.id,\n+                                               mod_id,\n+                                               &get_ident(ident),\n+                                               self.cur_scope);\n+                        self.write_sub_paths_truncated(path, true);\n+                    }\n+                    ast::ViewPathGlob(ref path) => {\n+                        // Make a comma-separated list of names of imported modules.\n+                        let mut name_string = String::new();\n+                        let glob_map = &self.analysis.glob_map;\n+                        let glob_map = glob_map.as_ref().unwrap();\n+                        if glob_map.contains_key(&item.id) {\n+                            for n in glob_map.get(&item.id).unwrap() {\n+                                if !name_string.is_empty() {\n+                                    name_string.push_str(\", \");\n+                                }\n+                                name_string.push_str(n.as_str());\n+                            }\n+                        }\n+\n+                        let sub_span = self.span.sub_span_of_token(path.span,\n+                                                                   token::BinOp(token::Star));\n+                        self.fmt.use_glob_str(path.span,\n+                                              sub_span,\n+                                              item.id,\n+                                              &name_string,\n+                                              self.cur_scope);\n+                        self.write_sub_paths(path, true);\n+                    }\n+                    ast::ViewPathList(ref path, ref list) => {\n+                        for plid in list {\n+                            match plid.node {\n+                                ast::PathListIdent { id, .. } => {\n+                                    match self.lookup_type_ref(id) {\n+                                        Some(def_id) =>\n+                                            match self.lookup_def_kind(id, plid.span) {\n+                                                Some(kind) => {\n+                                                    self.fmt.ref_str(\n+                                                        kind, plid.span,\n+                                                        Some(plid.span),\n+                                                        def_id, self.cur_scope);\n+                                                }\n+                                                None => ()\n+                                            },\n+                                        None => ()\n+                                    }\n+                                },\n+                                ast::PathListMod { .. } => ()\n+                            }\n+                        }\n+\n+                        self.write_sub_paths(path, true);\n+                    }\n+                }\n+            }\n+            ast::ItemExternCrate(ref s) => {\n+                let name = get_ident(item.ident);\n+                let name = &name;\n+                let location = match *s {\n+                    Some(s) => s.to_string(),\n+                    None => name.to_string(),\n+                };\n+                let alias_span = self.span.span_for_last_ident(item.span);\n+                let cnum = match self.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n+                    Some(cnum) => cnum,\n+                    None => 0,\n+                };\n+                self.fmt.extern_crate_str(item.span,\n+                                          alias_span,\n+                                          item.id,\n+                                          cnum,\n+                                          name,\n+                                          &location[..],\n+                                          self.cur_scope);\n+            }\n+            ast::ItemFn(ref decl, _, _, ref ty_params, ref body) =>\n+                self.process_fn(item, &**decl, ty_params, &**body),\n+            ast::ItemStatic(ref typ, _, ref expr) =>\n+                self.process_static_or_const_item(item, typ, expr),\n+            ast::ItemConst(ref typ, ref expr) =>\n+                self.process_static_or_const_item(item, &typ, &expr),\n+            ast::ItemStruct(ref def, ref ty_params) => self.process_struct(item, &**def, ty_params),\n+            ast::ItemEnum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n+            ast::ItemImpl(_, _,\n+                          ref ty_params,\n+                          ref trait_ref,\n+                          ref typ,\n+                          ref impl_items) => {\n+                self.process_impl(item,\n+                                  ty_params,\n+                                  trait_ref,\n+                                  &**typ,\n+                                  impl_items)\n+            }\n+            ast::ItemTrait(_, ref generics, ref trait_refs, ref methods) =>\n+                self.process_trait(item, generics, trait_refs, methods),\n+            ast::ItemMod(ref m) => self.process_mod(item, m),\n+            ast::ItemTy(ref ty, ref ty_params) => {\n+                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+                let value = ty_to_string(&**ty);\n+                let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n+                self.fmt.typedef_str(item.span,\n+                                     sub_span,\n+                                     item.id,\n+                                     &qualname[..],\n+                                     &value[..]);\n+\n+                self.visit_ty(&**ty);\n+                self.process_generic_params(ty_params, item.span, &qualname, item.id);\n+            },\n+            ast::ItemMac(_) => (),\n+            _ => visit::walk_item(self, item),\n+        }\n+    }\n+\n+    fn visit_generics(&mut self, generics: &ast::Generics) {\n+        for param in &*generics.ty_params {\n+            for bound in &*param.bounds {\n+                if let ast::TraitTyParamBound(ref trait_ref, _) = *bound {\n+                    self.process_trait_ref(&trait_ref.trait_ref);\n+                }\n+            }\n+            if let Some(ref ty) = param.default {\n+                self.visit_ty(&**ty);\n+            }\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+        match trait_item.node {\n+            ast::ConstTraitItem(ref ty, Some(ref expr)) => {\n+                self.process_const(trait_item.id, &trait_item.ident,\n+                                   trait_item.span, &*ty, &*expr);\n+            }\n+            ast::MethodTraitItem(ref sig, ref body) => {\n+                self.process_method(sig, body.as_ref().map(|x| &**x),\n+                                    trait_item.id, trait_item.ident.name, trait_item.span);\n+            }\n+            ast::ConstTraitItem(_, None) |\n+            ast::TypeTraitItem(..) => {}\n+        }\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n+        match impl_item.node {\n+            ast::ConstImplItem(ref ty, ref expr) => {\n+                self.process_const(impl_item.id, &impl_item.ident,\n+                                   impl_item.span, &ty, &expr);\n+            }\n+            ast::MethodImplItem(ref sig, ref body) => {\n+                self.process_method(sig, Some(body), impl_item.id,\n+                                    impl_item.ident.name, impl_item.span);\n+            }\n+            ast::TypeImplItem(_) |\n+            ast::MacImplItem(_) => {}\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, t: &ast::Ty) {\n+        if generated_code(t.span) {\n+            return\n+        }\n+\n+        match t.node {\n+            ast::TyPath(_, ref path) => {\n+                match self.lookup_type_ref(t.id) {\n+                    Some(id) => {\n+                        let sub_span = self.span.sub_span_for_type_name(t.span);\n+                        self.fmt.ref_str(recorder::TypeRef,\n+                                         t.span,\n+                                         sub_span,\n+                                         id,\n+                                         self.cur_scope);\n+                    },\n+                    None => ()\n+                }\n+\n+                self.write_sub_paths_truncated(path, false);\n+\n+                visit::walk_path(self, path);\n+            },\n+            _ => visit::walk_ty(self, t),\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, ex: &ast::Expr) {\n+        if generated_code(ex.span) {\n+            return\n+        }\n+\n+        match ex.node {\n+            ast::ExprCall(ref _f, ref _args) => {\n+                // Don't need to do anything for function calls,\n+                // because just walking the callee path does what we want.\n+                visit::walk_expr(self, ex);\n+            }\n+            ast::ExprPath(_, ref path) => {\n+                self.process_path(ex.id, path.span, path, None);\n+                visit::walk_expr(self, ex);\n+            }\n+            ast::ExprStruct(ref path, ref fields, ref base) =>\n+                self.process_struct_lit(ex, path, fields, base),\n+            ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n+            ast::ExprField(ref sub_ex, ident) => {\n+                if generated_code(sub_ex.span) {\n+                    return\n+                }\n+\n+                self.visit_expr(&**sub_ex);\n+                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty;\n+                match *ty {\n+                    ty::ty_struct(def_id, _) => {\n+                        let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n+                        for f in &fields {\n+                            if f.name == ident.node.name {\n+                                let sub_span = self.span.span_for_last_ident(ex.span);\n+                                self.fmt.ref_str(recorder::VarRef,\n+                                                 ex.span,\n+                                                 sub_span,\n+                                                 f.id,\n+                                                 self.cur_scope);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    _ => self.sess.span_bug(ex.span,\n+                                            &format!(\"Expected struct type, found {:?}\", ty)),\n+                }\n+            },\n+            ast::ExprTupField(ref sub_ex, idx) => {\n+                if generated_code(sub_ex.span) {\n+                    return\n+                }\n+\n+                self.visit_expr(&**sub_ex);\n+\n+                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty;\n+                match *ty {\n+                    ty::ty_struct(def_id, _) => {\n+                        let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n+                        for (i, f) in fields.iter().enumerate() {\n+                            if i == idx.node {\n+                                let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n+                                self.fmt.ref_str(recorder::VarRef,\n+                                                 ex.span,\n+                                                 sub_span,\n+                                                 f.id,\n+                                                 self.cur_scope);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    ty::ty_tup(_) => {}\n+                    _ => self.sess.span_bug(ex.span,\n+                                            &format!(\"Expected struct or tuple \\\n+                                                      type, found {:?}\", ty)),\n+                }\n+            },\n+            ast::ExprClosure(_, ref decl, ref body) => {\n+                if generated_code(body.span) {\n+                    return\n+                }\n+\n+                let mut id = String::from_str(\"$\");\n+                id.push_str(&ex.id.to_string());\n+                self.process_formals(&decl.inputs, &id[..]);\n+\n+                // walk arg and return types\n+                for arg in &decl.inputs {\n+                    self.visit_ty(&*arg.ty);\n+                }\n+\n+                if let ast::Return(ref ret_ty) = decl.output {\n+                    self.visit_ty(&**ret_ty);\n+                }\n+\n+                // walk the body\n+                self.nest(ex.id, |v| v.visit_block(&**body));\n+            },\n+            _ => {\n+                visit::walk_expr(self, ex)\n+            }\n+        }\n+    }\n+\n+    fn visit_mac(&mut self, _: &ast::Mac) {\n+        // Just stop, macros are poison to us.\n+    }\n+\n+    fn visit_pat(&mut self, p: &ast::Pat) {\n+        self.process_pat(p);\n+    }\n+\n+    fn visit_arm(&mut self, arm: &ast::Arm) {\n+        let mut collector = PathCollector::new();\n+        for pattern in &arm.pats {\n+            // collect paths from the arm's patterns\n+            collector.visit_pat(&pattern);\n+            self.visit_pat(&pattern);\n+        }\n+\n+        // This is to get around borrow checking, because we need mut self to call process_path.\n+        let mut paths_to_process = vec![];\n+        // process collected paths\n+        for &(id, ref p, immut, ref_kind) in &collector.collected_paths {\n+            let def_map = self.analysis.ty_cx.def_map.borrow();\n+            if !def_map.contains_key(&id) {\n+                self.sess.span_bug(p.span,\n+                                   &format!(\"def_map has no key for {} in visit_arm\",\n+                                           id));\n+            }\n+            let def = def_map.get(&id).unwrap().full_def();\n+            match def {\n+                def::DefLocal(id)  => {\n+                    let value = if immut == ast::MutImmutable {\n+                        self.span.snippet(p.span).to_string()\n+                    } else {\n+                        \"<mutable>\".to_string()\n+                    };\n+\n+                    assert!(p.segments.len() == 1, \"qualified path for local variable def in arm\");\n+                    self.fmt.variable_str(p.span,\n+                                          Some(p.span),\n+                                          id,\n+                                          &path_to_string(p),\n+                                          &value[..],\n+                                          \"\")\n+                }\n+                def::DefVariant(..) | def::DefTy(..) | def::DefStruct(..) => {\n+                    paths_to_process.push((id, p.clone(), Some(ref_kind)))\n+                }\n+                // FIXME(nrc) what are these doing here?\n+                def::DefStatic(_, _) |\n+                def::DefConst(..) |\n+                def::DefAssociatedConst(..) => {}\n+                _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n+                            def)\n+            }\n+        }\n+        for &(id, ref path, ref_kind) in &paths_to_process {\n+            self.process_path(id, path.span, path, ref_kind);\n+        }\n+        visit::walk_expr_opt(self, &arm.guard);\n+        self.visit_expr(&*arm.body);\n+    }\n+\n+    fn visit_stmt(&mut self, s: &ast::Stmt) {\n+        if generated_code(s.span) {\n+            return\n+        }\n+\n+        visit::walk_stmt(self, s)\n+    }\n+\n+    fn visit_local(&mut self, l: &ast::Local) {\n+        if generated_code(l.span) {\n+            return\n+        }\n+\n+        // The local could declare multiple new vars, we must walk the\n+        // pattern and collect them all.\n+        let mut collector = PathCollector::new();\n+        collector.visit_pat(&l.pat);\n+        self.visit_pat(&l.pat);\n+\n+        let value = self.span.snippet(l.span);\n+\n+        for &(id, ref p, immut, _) in &collector.collected_paths {\n+            let value = if immut == ast::MutImmutable {\n+                value.to_string()\n+            } else {\n+                \"<mutable>\".to_string()\n+            };\n+            let types = self.analysis.ty_cx.node_types();\n+            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, *types.get(&id).unwrap());\n+            // Get the span only for the name of the variable (I hope the path\n+            // is only ever a variable name, but who knows?).\n+            let sub_span = self.span.span_for_last_ident(p.span);\n+            // Rust uses the id of the pattern for var lookups, so we'll use it too.\n+            self.fmt.variable_str(p.span,\n+                                  sub_span,\n+                                  id,\n+                                  &path_to_string(p),\n+                                  &value[..],\n+                                  &typ[..]);\n+        }\n+\n+        // Just walk the initialiser and type (don't want to walk the pattern again).\n+        visit::walk_ty_opt(self, &l.ty);\n+        visit::walk_expr_opt(self, &l.init);\n+    }\n+}"}, {"sha": "c5c4a75ef823bcae29a0567985f4f066db5085fd", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 151, "deletions": 1454, "changes": 1605, "blob_url": "https://github.com/rust-lang/rust/blob/579e31929feff51dcaf8d444648eff8de735f91a/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579e31929feff51dcaf8d444648eff8de735f91a/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=579e31929feff51dcaf8d444648eff8de735f91a", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,1504 +8,207 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Output a CSV file containing the output from rustc's analysis. The data is\n-//! primarily designed to be used as input to the DXR tool, specifically its\n-//! Rust plugin. It could also be used by IDEs or other code browsing, search, or\n-//! cross-referencing tools.\n-//!\n-//! Dumping the analysis is implemented by walking the AST and getting a bunch of\n-//! info out from all over the place. We use Def IDs to identify objects. The\n-//! tricky part is getting syntactic (span, source text) and semantic (reference\n-//! Def IDs) information for parts of expressions which the compiler has discarded.\n-//! E.g., in a path `foo::bar::baz`, the compiler only keeps a span for the whole\n-//! path and a reference to `baz`, but we want spans and references for all three\n-//! idents.\n-//!\n-//! SpanUtils is used to manipulate spans. In particular, to extract sub-spans\n-//! from spans (e.g., the span for `bar` from the above example path).\n-//! Recorder is used for recording the output in csv format. FmtStrs separates\n-//! the format of the output away from extracting it from the compiler.\n-//! DxrVisitor walks the AST and processes it.\n-\n use session::Session;\n+use middle::ty;\n \n-use middle::def;\n-use middle::ty::{self, Ty};\n-\n-use std::cell::Cell;\n use std::env;\n use std::fs::{self, File};\n use std::path::{Path, PathBuf};\n \n-use syntax::ast_util;\n+use syntax::{attr};\n use syntax::ast::{self, NodeId, DefId};\n-use syntax::ast_map::NodeItem;\n-use syntax::attr;\n+use syntax::ast_util;\n use syntax::codemap::*;\n use syntax::parse::token::{self, get_ident, keywords};\n-use syntax::owned_slice::OwnedSlice;\n use syntax::visit::{self, Visitor};\n-use syntax::print::pprust::{path_to_string, ty_to_string};\n-use syntax::ptr::P;\n+use syntax::print::pprust::ty_to_string;\n \n-use self::span_utils::SpanUtils;\n-use self::recorder::{Recorder, FmtStrs};\n \n-use util::ppaux;\n+use self::span_utils::SpanUtils;\n \n mod span_utils;\n mod recorder;\n \n-// Helper function to escape quotes in a string\n-fn escape(s: String) -> String {\n-    s.replace(\"\\\"\", \"\\\"\\\"\")\n-}\n-\n-// If the expression is a macro expansion or other generated code, run screaming and don't index.\n-fn generated_code(span: Span) -> bool {\n-    span.expn_id != NO_EXPANSION || span  == DUMMY_SP\n-}\n+mod dump_csv;\n \n-struct DxrVisitor<'l, 'tcx: 'l> {\n+pub struct SaveContext<'l, 'tcx: 'l> {\n     sess: &'l Session,\n     analysis: &'l ty::CrateAnalysis<'tcx>,\n+    span_utils: SpanUtils<'l>,\n+}\n+\n+pub struct CrateData {\n+    pub name: String,\n+    pub number: u32,\n+}\n \n-    collected_paths: Vec<(NodeId, ast::Path, bool, recorder::Row)>,\n-    collecting: bool,\n+/// Data for any entity in the Rust language. The actual data contained varied\n+/// with the kind of entity being queried. See the nested structs for details.\n+pub enum Data {\n+    /// Data for all kinds of functions and methods.\n+    FunctionData(FunctionData),\n+    /// Data for local and global variables (consts and statics).\n+    VariableData(VariableData),\n+}\n \n-    span: SpanUtils<'l>,\n-    fmt: FmtStrs<'l>,\n+/// Data for all kinds of functions and methods.\n+pub struct FunctionData {\n+    pub id: NodeId,\n+    pub name: String,\n+    pub qualname: String,\n+    pub declaration: Option<DefId>,\n+    pub span: Span,\n+    pub scope: NodeId,\n+}\n \n-    cur_scope: NodeId\n+/// Data for local and global variables (consts and statics).\n+pub struct VariableData {\n+    pub id: NodeId,\n+    pub name: String,\n+    pub qualname: String,\n+    pub span: Span,\n+    pub scope: NodeId,\n+    pub value: String,\n+    pub type_value: String,\n }\n \n-impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n-    fn nest<F>(&mut self, scope_id: NodeId, f: F) where\n-        F: FnOnce(&mut DxrVisitor<'l, 'tcx>),\n-    {\n-        let parent_scope = self.cur_scope;\n-        self.cur_scope = scope_id;\n-        f(self);\n-        self.cur_scope = parent_scope;\n+impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n+    pub fn new(sess: &'l Session,\n+               analysis: &'l ty::CrateAnalysis<'tcx>,\n+               span_utils: SpanUtils<'l>)\n+               -> SaveContext<'l, 'tcx> {\n+        SaveContext {\n+            sess: sess,\n+            analysis: analysis,\n+            span_utils: span_utils,\n+        }\n     }\n \n-    fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {\n-        // the current crate\n-        self.fmt.crate_str(krate.span, name);\n+    // List external crates used by the current crate.\n+    pub fn get_external_crates(&self) -> Vec<CrateData> {\n+        let mut result = Vec::new();\n \n-        // dump info about all the external crates referenced from this crate\n         self.sess.cstore.iter_crate_data(|n, cmd| {\n-            self.fmt.external_crate_str(krate.span, &cmd.name, n);\n+            result.push(CrateData { name: cmd.name.clone(), number: n });\n         });\n-        self.fmt.recorder.record(\"end_external_crates\\n\");\n-    }\n-\n-    // Return all non-empty prefixes of a path.\n-    // For each prefix, we return the span for the last segment in the prefix and\n-    // a str representation of the entire prefix.\n-    fn process_path_prefixes(&self, path: &ast::Path) -> Vec<(Span, String)> {\n-        let spans = self.span.spans_for_path_segments(path);\n-\n-        // Paths to enums seem to not match their spans - the span includes all the\n-        // variants too. But they seem to always be at the end, so I hope we can cope with\n-        // always using the first ones. So, only error out if we don't have enough spans.\n-        // What could go wrong...?\n-        if spans.len() < path.segments.len() {\n-            error!(\"Mis-calculated spans for path '{}'. \\\n-                    Found {} spans, expected {}. Found spans:\",\n-                   path_to_string(path), spans.len(), path.segments.len());\n-            for s in &spans {\n-                let loc = self.sess.codemap().lookup_char_pos(s.lo);\n-                error!(\"    '{}' in {}, line {}\",\n-                       self.span.snippet(*s), loc.file.name, loc.line);\n-            }\n-            return vec!();\n-        }\n-\n-        let mut result: Vec<(Span, String)> = vec!();\n-\n-        let mut segs = vec!();\n-        for (i, (seg, span)) in path.segments.iter().zip(spans.iter()).enumerate() {\n-            segs.push(seg.clone());\n-            let sub_path = ast::Path{span: *span, // span for the last segment\n-                                     global: path.global,\n-                                     segments: segs};\n-            let qualname = if i == 0 && path.global {\n-                format!(\"::{}\", path_to_string(&sub_path))\n-            } else {\n-                path_to_string(&sub_path)\n-            };\n-            result.push((*span, qualname));\n-            segs = sub_path.segments;\n-        }\n \n         result\n     }\n \n-    // The global arg allows us to override the global-ness of the path (which\n-    // actually means 'does the path start with `::`', rather than 'is the path\n-    // semantically global). We use the override for `use` imports (etc.) where\n-    // the syntax is non-global, but the semantics are global.\n-    fn write_sub_paths(&mut self, path: &ast::Path, global: bool) {\n-        let sub_paths = self.process_path_prefixes(path);\n-        for (i, &(ref span, ref qualname)) in sub_paths.iter().enumerate() {\n-            let qualname = if i == 0 && global && !path.global {\n-                format!(\"::{}\", qualname)\n-            } else {\n-                qualname.clone()\n-            };\n-            self.fmt.sub_mod_ref_str(path.span,\n-                                     *span,\n-                                     &qualname[..],\n-                                     self.cur_scope);\n-        }\n-    }\n-\n-    // As write_sub_paths, but does not process the last ident in the path (assuming it\n-    // will be processed elsewhere). See note on write_sub_paths about global.\n-    fn write_sub_paths_truncated(&mut self, path: &ast::Path, global: bool) {\n-        let sub_paths = self.process_path_prefixes(path);\n-        let len = sub_paths.len();\n-        if len <= 1 {\n-            return;\n-        }\n-\n-        let sub_paths = &sub_paths[..len-1];\n-        for (i, &(ref span, ref qualname)) in sub_paths.iter().enumerate() {\n-            let qualname = if i == 0 && global && !path.global {\n-                format!(\"::{}\", qualname)\n-            } else {\n-                qualname.clone()\n-            };\n-            self.fmt.sub_mod_ref_str(path.span,\n-                                     *span,\n-                                     &qualname[..],\n-                                     self.cur_scope);\n-        }\n-    }\n-\n-    // As write_sub_paths, but expects a path of the form module_path::trait::method\n-    // Where trait could actually be a struct too.\n-    fn write_sub_path_trait_truncated(&mut self, path: &ast::Path) {\n-        let sub_paths = self.process_path_prefixes(path);\n-        let len = sub_paths.len();\n-        if len <= 1 {\n-            return;\n-        }\n-        let sub_paths = &sub_paths[.. (len-1)];\n-\n-        // write the trait part of the sub-path\n-        let (ref span, ref qualname) = sub_paths[len-2];\n-        self.fmt.sub_type_ref_str(path.span,\n-                                  *span,\n-                                  &qualname[..]);\n-\n-        // write the other sub-paths\n-        if len <= 2 {\n-            return;\n-        }\n-        let sub_paths = &sub_paths[..len-2];\n-        for &(ref span, ref qualname) in sub_paths {\n-            self.fmt.sub_mod_ref_str(path.span,\n-                                     *span,\n-                                     &qualname[..],\n-                                     self.cur_scope);\n-        }\n-    }\n-\n-    // looks up anything, not just a type\n-    fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n-        if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n-            self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n-                                  ref_id));\n-        }\n-        let def = self.analysis.ty_cx.def_map.borrow().get(&ref_id).unwrap().full_def();\n-        match def {\n-            def::DefPrimTy(_) => None,\n-            _ => Some(def.def_id()),\n-        }\n-    }\n-\n-    fn lookup_def_kind(&self, ref_id: NodeId, span: Span) -> Option<recorder::Row> {\n-        let def_map = self.analysis.ty_cx.def_map.borrow();\n-        if !def_map.contains_key(&ref_id) {\n-            self.sess.span_bug(span, &format!(\"def_map has no key for {} in lookup_def_kind\",\n-                                             ref_id));\n-        }\n-        let def = def_map.get(&ref_id).unwrap().full_def();\n-        match def {\n-            def::DefMod(_) |\n-            def::DefForeignMod(_) => Some(recorder::ModRef),\n-            def::DefStruct(_) => Some(recorder::StructRef),\n-            def::DefTy(..) |\n-            def::DefAssociatedTy(..) |\n-            def::DefTrait(_) => Some(recorder::TypeRef),\n-            def::DefStatic(_, _) |\n-            def::DefConst(_) |\n-            def::DefAssociatedConst(..) |\n-            def::DefLocal(_) |\n-            def::DefVariant(_, _, _) |\n-            def::DefUpvar(..) => Some(recorder::VarRef),\n-\n-            def::DefFn(..) => Some(recorder::FnRef),\n-\n-            def::DefSelfTy(..) |\n-            def::DefRegion(_) |\n-            def::DefLabel(_) |\n-            def::DefTyParam(..) |\n-            def::DefUse(_) |\n-            def::DefMethod(..) |\n-            def::DefPrimTy(_) => {\n-                self.sess.span_bug(span, &format!(\"lookup_def_kind for unexpected item: {:?}\",\n-                                                 def));\n-            },\n-        }\n-    }\n-\n-    fn process_formals(&mut self, formals: &Vec<ast::Arg>, qualname: &str) {\n-        for arg in formals {\n-            assert!(self.collected_paths.is_empty() && !self.collecting);\n-            self.collecting = true;\n-            self.visit_pat(&*arg.pat);\n-            self.collecting = false;\n-            let span_utils = self.span.clone();\n-            for &(id, ref p, _, _) in &self.collected_paths {\n-                let typ =\n-                    ppaux::ty_to_string(\n-                        &self.analysis.ty_cx,\n-                        *self.analysis.ty_cx.node_types().get(&id).unwrap());\n-                // get the span only for the name of the variable (I hope the path is only ever a\n-                // variable name, but who knows?)\n-                self.fmt.formal_str(p.span,\n-                                    span_utils.span_for_last_ident(p.span),\n-                                    id,\n-                                    qualname,\n-                                    &path_to_string(p),\n-                                    &typ[..]);\n+    pub fn get_item_data(&self, item: &ast::Item) -> Data {\n+        match item.node {\n+            ast::Item_::ItemFn(..) => {\n+                let name = self.analysis.ty_cx.map.path_to_string(item.id);\n+                let qualname = format!(\"::{}\", name);\n+                let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Fn);\n+\n+                Data::FunctionData(FunctionData {\n+                    id: item.id,\n+                    name: name,\n+                    qualname: qualname,\n+                    declaration: None,\n+                    span: sub_span.unwrap(),\n+                    scope: self.analysis.ty_cx.map.get_parent(item.id),\n+                })\n             }\n-            self.collected_paths.clear();\n-        }\n-    }\n-\n-    fn process_method(&mut self, sig: &ast::MethodSig,\n-                      body: Option<&ast::Block>,\n-                      id: ast::NodeId, name: ast::Name,\n-                      span: Span) {\n-        if generated_code(span) {\n-            return;\n-        }\n-\n-        debug!(\"process_method: {}:{}\", id, token::get_name(name));\n-\n-        let mut scope_id;\n-        // The qualname for a method is the trait name or name of the struct in an impl in\n-        // which the method is declared in, followed by the method's name.\n-        let qualname = match ty::impl_of_method(&self.analysis.ty_cx,\n-                                                ast_util::local_def(id)) {\n-            Some(impl_id) => match self.analysis.ty_cx.map.get(impl_id.node) {\n-                NodeItem(item) => {\n-                    scope_id = item.id;\n-                    match item.node {\n-                        ast::ItemImpl(_, _, _, _, ref ty, _) => {\n-                            let mut result = String::from_str(\"<\");\n-                            result.push_str(&ty_to_string(&**ty));\n-\n-                            match ty::trait_of_item(&self.analysis.ty_cx,\n-                                                    ast_util::local_def(id)) {\n-                                Some(def_id) => {\n-                                    result.push_str(\" as \");\n-                                    result.push_str(\n-                                        &ty::item_path_str(&self.analysis.ty_cx, def_id));\n-                                },\n-                                None => {}\n-                            }\n-                            result.push_str(\">\");\n-                            result\n-                        }\n-                        _ => {\n-                            self.sess.span_bug(span,\n-                                &format!(\"Container {} for method {} not an impl?\",\n-                                         impl_id.node, id));\n-                        },\n-                    }\n-                },\n-                _ => {\n-                    self.sess.span_bug(span,\n-                        &format!(\"Container {} for method {} is not a node item {:?}\",\n-                                 impl_id.node, id, self.analysis.ty_cx.map.get(impl_id.node)));\n-                },\n-            },\n-            None => match ty::trait_of_item(&self.analysis.ty_cx,\n-                                            ast_util::local_def(id)) {\n-                Some(def_id) => {\n-                    scope_id = def_id.node;\n-                    match self.analysis.ty_cx.map.get(def_id.node) {\n-                        NodeItem(_) => {\n-                            format!(\"::{}\", ty::item_path_str(&self.analysis.ty_cx, def_id))\n-                        }\n-                        _ => {\n-                            self.sess.span_bug(span,\n-                                &format!(\"Could not find container {} for method {}\",\n-                                         def_id.node, id));\n-                        }\n-                    }\n-                },\n-                None => {\n-                    self.sess.span_bug(span,\n-                        &format!(\"Could not find container for method {}\", id));\n-                },\n-            },\n-        };\n-\n-        let qualname = &format!(\"{}::{}\", qualname, &token::get_name(name));\n-\n-        // record the decl for this def (if it has one)\n-        let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n-                                             ast_util::local_def(id))\n-            .and_then(|new_id| {\n-                let def_id = new_id.def_id();\n-                if def_id.node != 0 && def_id != ast_util::local_def(id) {\n-                    Some(def_id)\n-                } else {\n-                    None\n-                }\n-            });\n-\n-        let sub_span = self.span.sub_span_after_keyword(span, keywords::Fn);\n-        if body.is_some() {\n-            self.fmt.method_str(span,\n-                                sub_span,\n-                                id,\n-                                qualname,\n-                                decl_id,\n-                                scope_id);\n-            self.process_formals(&sig.decl.inputs, qualname);\n-        } else {\n-            self.fmt.method_decl_str(span,\n-                                     sub_span,\n-                                     id,\n-                                     qualname,\n-                                     scope_id);\n-        }\n-\n-        // walk arg and return types\n-        for arg in &sig.decl.inputs {\n-            self.visit_ty(&arg.ty);\n-        }\n-\n-        if let ast::Return(ref ret_ty) = sig.decl.output {\n-            self.visit_ty(ret_ty);\n-        }\n-\n-        // walk the fn body\n-        if let Some(body) = body {\n-            self.nest(id, |v| v.visit_block(body));\n-        }\n-\n-        self.process_generic_params(&sig.generics,\n-                                    span,\n-                                    qualname,\n-                                    id);\n-    }\n-\n-    fn process_trait_ref(&mut self,\n-                         trait_ref: &ast::TraitRef) {\n-        match self.lookup_type_ref(trait_ref.ref_id) {\n-            Some(id) => {\n-                let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n-                self.fmt.ref_str(recorder::TypeRef,\n-                                 trait_ref.path.span,\n-                                 sub_span,\n-                                 id,\n-                                 self.cur_scope);\n-                visit::walk_path(self, &trait_ref.path);\n-            },\n-            None => ()\n-        }\n-    }\n-\n-    fn process_struct_field_def(&mut self,\n-                                field: &ast::StructField,\n-                                qualname: &str,\n-                                scope_id: NodeId) {\n-        match field.node.kind {\n-            ast::NamedField(ident, _) => {\n-                let name = get_ident(ident);\n-                let qualname = format!(\"{}::{}\", qualname, name);\n-                let typ =\n-                    ppaux::ty_to_string(\n-                        &self.analysis.ty_cx,\n-                        *self.analysis.ty_cx.node_types().get(&field.node.id).unwrap());\n-                match self.span.sub_span_before_token(field.span, token::Colon) {\n-                    Some(sub_span) => self.fmt.field_str(field.span,\n-                                                         Some(sub_span),\n-                                                         field.node.id,\n-                                                         &name[..],\n-                                                         &qualname[..],\n-                                                         &typ[..],\n-                                                         scope_id),\n-                    None => self.sess.span_bug(field.span,\n-                                               &format!(\"Could not find sub-span for field {}\",\n-                                                       qualname)),\n-                }\n-            },\n-            _ => (),\n-        }\n-    }\n-\n-    // Dump generic params bindings, then visit_generics\n-    fn process_generic_params(&mut self,\n-                              generics:&ast::Generics,\n-                              full_span: Span,\n-                              prefix: &str,\n-                              id: NodeId) {\n-        // We can't only use visit_generics since we don't have spans for param\n-        // bindings, so we reparse the full_span to get those sub spans.\n-        // However full span is the entire enum/fn/struct block, so we only want\n-        // the first few to match the number of generics we're looking for.\n-        let param_sub_spans = self.span.spans_for_ty_params(full_span,\n-                                                           (generics.ty_params.len() as isize));\n-        for (param, param_ss) in generics.ty_params.iter().zip(param_sub_spans.iter()) {\n-            // Append $id to name to make sure each one is unique\n-            let name = format!(\"{}::{}${}\",\n-                               prefix,\n-                               escape(self.span.snippet(*param_ss)),\n-                               id);\n-            self.fmt.typedef_str(full_span,\n-                                 Some(*param_ss),\n-                                 param.id,\n-                                 &name[..],\n-                                 \"\");\n-        }\n-        self.visit_generics(generics);\n-    }\n-\n-    fn process_fn(&mut self,\n-                  item: &ast::Item,\n-                  decl: &ast::FnDecl,\n-                  ty_params: &ast::Generics,\n-                  body: &ast::Block) {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n-\n-        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Fn);\n-        self.fmt.fn_str(item.span,\n-                        sub_span,\n-                        item.id,\n-                        &qualname[..],\n-                        self.cur_scope);\n-\n-        self.process_formals(&decl.inputs, &qualname[..]);\n-\n-        // walk arg and return types\n-        for arg in &decl.inputs {\n-            self.visit_ty(&*arg.ty);\n-        }\n-\n-        if let ast::Return(ref ret_ty) = decl.output {\n-            self.visit_ty(&**ret_ty);\n-        }\n-\n-        // walk the body\n-        self.nest(item.id, |v| v.visit_block(&*body));\n-\n-        self.process_generic_params(ty_params, item.span, &qualname[..], item.id);\n-    }\n-\n-    fn process_static(&mut self,\n-                      item: &ast::Item,\n-                      typ: &ast::Ty,\n-                      mt: ast::Mutability,\n-                      expr: &ast::Expr)\n-    {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n-\n-        // If the variable is immutable, save the initialising expression.\n-        let (value, keyword) = match mt {\n-            ast::MutMutable => (String::from_str(\"<mutable>\"), keywords::Mut),\n-            ast::MutImmutable => (self.span.snippet(expr.span), keywords::Static),\n-        };\n-\n-        let sub_span = self.span.sub_span_after_keyword(item.span, keyword);\n-        self.fmt.static_str(item.span,\n-                            sub_span,\n-                            item.id,\n-                            &get_ident(item.ident),\n-                            &qualname[..],\n-                            &value[..],\n-                            &ty_to_string(&*typ),\n-                            self.cur_scope);\n-\n-        // walk type and init value\n-        self.visit_ty(&*typ);\n-        self.visit_expr(expr);\n-    }\n-\n-    fn process_const(&mut self,\n-                     id: ast::NodeId,\n-                     ident: &ast::Ident,\n-                     span: Span,\n-                     typ: &ast::Ty,\n-                     expr: &ast::Expr)\n-    {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(id));\n-\n-        let sub_span = self.span.sub_span_after_keyword(span,\n-                                                        keywords::Const);\n-        self.fmt.static_str(span,\n-                            sub_span,\n-                            id,\n-                            &get_ident((*ident).clone()),\n-                            &qualname[..],\n-                            \"\",\n-                            &ty_to_string(&*typ),\n-                            self.cur_scope);\n-\n-        // walk type and init value\n-        self.visit_ty(typ);\n-        self.visit_expr(expr);\n-    }\n-\n-    fn process_struct(&mut self,\n-                      item: &ast::Item,\n-                      def: &ast::StructDef,\n-                      ty_params: &ast::Generics) {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n-\n-        let ctor_id = match def.ctor_id {\n-            Some(node_id) => node_id,\n-            None => -1,\n-        };\n-        let val = self.span.snippet(item.span);\n-        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Struct);\n-        self.fmt.struct_str(item.span,\n-                            sub_span,\n-                            item.id,\n-                            ctor_id,\n-                            &qualname[..],\n-                            self.cur_scope,\n-                            &val[..]);\n-\n-        // fields\n-        for field in &def.fields {\n-            self.process_struct_field_def(field, &qualname[..], item.id);\n-            self.visit_ty(&*field.node.ty);\n-        }\n-\n-        self.process_generic_params(ty_params, item.span, &qualname[..], item.id);\n-    }\n+            ast::ItemStatic(ref typ, mt, ref expr) => {\n+                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n \n-    fn process_enum(&mut self,\n-                    item: &ast::Item,\n-                    enum_definition: &ast::EnumDef,\n-                    ty_params: &ast::Generics) {\n-        let enum_name = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n-        let val = self.span.snippet(item.span);\n-        match self.span.sub_span_after_keyword(item.span, keywords::Enum) {\n-            Some(sub_span) => self.fmt.enum_str(item.span,\n-                                                Some(sub_span),\n-                                                item.id,\n-                                                &enum_name[..],\n-                                                self.cur_scope,\n-                                                &val[..]),\n-            None => self.sess.span_bug(item.span,\n-                                       &format!(\"Could not find subspan for enum {}\",\n-                                               enum_name)),\n-        }\n-        for variant in &enum_definition.variants {\n-            let name = get_ident(variant.node.name);\n-            let name = &name;\n-            let mut qualname = enum_name.clone();\n-            qualname.push_str(\"::\");\n-            qualname.push_str(name);\n-            let val = self.span.snippet(variant.span);\n-            match variant.node.kind {\n-                ast::TupleVariantKind(ref args) => {\n-                    // first ident in span is the variant's name\n-                    self.fmt.tuple_variant_str(variant.span,\n-                                               self.span.span_for_first_ident(variant.span),\n-                                               variant.node.id,\n-                                               name,\n-                                               &qualname[..],\n-                                               &enum_name[..],\n-                                               &val[..],\n-                                               item.id);\n-                    for arg in args {\n-                        self.visit_ty(&*arg.ty);\n-                    }\n-                }\n-                ast::StructVariantKind(ref struct_def) => {\n-                    let ctor_id = match struct_def.ctor_id {\n-                        Some(node_id) => node_id,\n-                        None => -1,\n-                    };\n-                    self.fmt.struct_variant_str(\n-                        variant.span,\n-                        self.span.span_for_first_ident(variant.span),\n-                        variant.node.id,\n-                        ctor_id,\n-                        &qualname[..],\n-                        &enum_name[..],\n-                        &val[..],\n-                        item.id);\n+                // If the variable is immutable, save the initialising expression.\n+                let (value, keyword) = match mt {\n+                    ast::MutMutable => (String::from_str(\"<mutable>\"), keywords::Mut),\n+                    ast::MutImmutable => (self.span_utils.snippet(expr.span), keywords::Static),\n+                };\n \n-                    for field in &struct_def.fields {\n-                        self.process_struct_field_def(field, &qualname, variant.node.id);\n-                        self.visit_ty(&*field.node.ty);\n-                    }\n-                }\n+                let sub_span = self.span_utils.sub_span_after_keyword(item.span, keyword);\n+\n+                Data::VariableData(VariableData {\n+                    id: item.id,\n+                    name: get_ident(item.ident).to_string(),\n+                    qualname: qualname,\n+                    span: sub_span.unwrap(),\n+                    scope: self.analysis.ty_cx.map.get_parent(item.id),\n+                    value: value,\n+                    type_value: ty_to_string(&typ),\n+                })\n             }\n-        }\n-\n-        self.process_generic_params(ty_params, item.span, &enum_name[..], item.id);\n-    }\n-\n-    fn process_impl(&mut self,\n-                    item: &ast::Item,\n-                    type_parameters: &ast::Generics,\n-                    trait_ref: &Option<ast::TraitRef>,\n-                    typ: &ast::Ty,\n-                    impl_items: &[P<ast::ImplItem>]) {\n-        let trait_id = trait_ref.as_ref().and_then(|tr| self.lookup_type_ref(tr.ref_id));\n-        match typ.node {\n-            // Common case impl for a struct or something basic.\n-            ast::TyPath(None, ref path) => {\n-                let sub_span = self.span.sub_span_for_type_name(path.span);\n-                let self_id = self.lookup_type_ref(typ.id).map(|id| {\n-                    self.fmt.ref_str(recorder::TypeRef,\n-                                     path.span,\n-                                     sub_span,\n-                                     id,\n-                                     self.cur_scope);\n-                    id\n-                });\n-                self.fmt.impl_str(path.span,\n-                                  sub_span,\n-                                  item.id,\n-                                  self_id,\n-                                  trait_id,\n-                                  self.cur_scope);\n-            },\n-            _ => {\n-                // Less useful case, impl for a compound type.\n-                self.visit_ty(&*typ);\n-\n-                let sub_span = self.span.sub_span_for_type_name(typ.span);\n-                self.fmt.impl_str(typ.span,\n-                                  sub_span,\n-                                  item.id,\n-                                  None,\n-                                  trait_id,\n-                                  self.cur_scope);\n+            ast::ItemConst(ref typ, ref expr) => {\n+                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+                let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Const);\n+\n+                Data::VariableData(VariableData {\n+                    id: item.id,\n+                    name: get_ident(item.ident).to_string(),\n+                    qualname: qualname,\n+                    span: sub_span.unwrap(),\n+                    scope: self.analysis.ty_cx.map.get_parent(item.id),\n+                    value: self.span_utils.snippet(expr.span),\n+                    type_value: ty_to_string(&typ),\n+                })\n             }\n-        }\n-\n-        match *trait_ref {\n-            Some(ref trait_ref) => self.process_trait_ref(trait_ref),\n-            None => (),\n-        }\n-\n-        self.process_generic_params(type_parameters, item.span, \"\", item.id);\n-        for impl_item in impl_items {\n-            self.visit_impl_item(impl_item);\n-        }\n-    }\n-\n-    fn process_trait(&mut self,\n-                     item: &ast::Item,\n-                     generics: &ast::Generics,\n-                     trait_refs: &OwnedSlice<ast::TyParamBound>,\n-                     methods: &[P<ast::TraitItem>]) {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n-        let val = self.span.snippet(item.span);\n-        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n-        self.fmt.trait_str(item.span,\n-                           sub_span,\n-                           item.id,\n-                           &qualname[..],\n-                           self.cur_scope,\n-                           &val[..]);\n-\n-        // super-traits\n-        for super_bound in &**trait_refs {\n-            let trait_ref = match *super_bound {\n-                ast::TraitTyParamBound(ref trait_ref, _) => {\n-                    trait_ref\n-                }\n-                ast::RegionTyParamBound(..) => {\n-                    continue;\n-                }\n-            };\n-\n-            let trait_ref = &trait_ref.trait_ref;\n-            match self.lookup_type_ref(trait_ref.ref_id) {\n-                Some(id) => {\n-                    let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n-                    self.fmt.ref_str(recorder::TypeRef,\n-                                     trait_ref.path.span,\n-                                     sub_span,\n-                                     id,\n-                                     self.cur_scope);\n-                    self.fmt.inherit_str(trait_ref.path.span,\n-                                         sub_span,\n-                                         id,\n-                                         item.id);\n-                },\n-                None => ()\n+            _ => {\n+                // FIXME\n+                unimplemented!();\n             }\n         }\n-\n-        // walk generics and methods\n-        self.process_generic_params(generics, item.span, &qualname[..], item.id);\n-        for method in methods {\n-            self.visit_trait_item(method)\n-        }\n     }\n \n-    fn process_mod(&mut self,\n-                   item: &ast::Item,  // The module in question, represented as an item.\n-                   m: &ast::Mod) {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n-\n-        let cm = self.sess.codemap();\n-        let filename = cm.span_to_filename(m.inner);\n-\n-        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Mod);\n-        self.fmt.mod_str(item.span,\n-                         sub_span,\n-                         item.id,\n-                         &qualname[..],\n-                         self.cur_scope,\n-                         &filename[..]);\n-\n-        self.nest(item.id, |v| visit::walk_mod(v, m));\n+    pub fn get_data_for_id(&self, _id: &NodeId) -> Data {\n+        // FIXME\n+        unimplemented!();\n     }\n+}\n \n-    fn process_path(&mut self,\n-                    id: NodeId,\n-                    span: Span,\n-                    path: &ast::Path,\n-                    ref_kind: Option<recorder::Row>) {\n-        if generated_code(span) {\n-            return\n-        }\n-\n-        let def_map = self.analysis.ty_cx.def_map.borrow();\n-        if !def_map.contains_key(&id) {\n-            self.sess.span_bug(span,\n-                               &format!(\"def_map has no key for {} in visit_expr\", id));\n-        }\n-        let def = def_map.get(&id).unwrap().full_def();\n-        let sub_span = self.span.span_for_last_ident(span);\n-        match def {\n-            def::DefUpvar(..) |\n-            def::DefLocal(..) |\n-            def::DefStatic(..) |\n-            def::DefConst(..) |\n-            def::DefAssociatedConst(..) |\n-            def::DefVariant(..) => self.fmt.ref_str(ref_kind.unwrap_or(recorder::VarRef),\n-                                                    span,\n-                                                    sub_span,\n-                                                    def.def_id(),\n-                                                    self.cur_scope),\n-            def::DefStruct(def_id) => self.fmt.ref_str(recorder::StructRef,\n-                                                       span,\n-                                                       sub_span,\n-                                                       def_id,\n-                                                       self.cur_scope),\n-            def::DefTy(def_id, _) => self.fmt.ref_str(recorder::TypeRef,\n-                                                      span,\n-                                                      sub_span,\n-                                                      def_id,\n-                                                      self.cur_scope),\n-            def::DefMethod(declid, provenence) => {\n-                let sub_span = self.span.sub_span_for_meth_name(span);\n-                let defid = if declid.krate == ast::LOCAL_CRATE {\n-                    let ti = ty::impl_or_trait_item(&self.analysis.ty_cx,\n-                                                    declid);\n-                    match provenence {\n-                        def::FromTrait(def_id) => {\n-                            Some(ty::trait_items(&self.analysis.ty_cx,\n-                                                 def_id)\n-                                    .iter()\n-                                    .find(|mr| {\n-                                        mr.name() == ti.name()\n-                                    })\n-                                    .unwrap()\n-                                    .def_id())\n-                        }\n-                        def::FromImpl(def_id) => {\n-                            let impl_items = self.analysis\n-                                                 .ty_cx\n-                                                 .impl_items\n-                                                 .borrow();\n-                            Some(impl_items.get(&def_id)\n-                                           .unwrap()\n-                                           .iter()\n-                                           .find(|mr| {\n-                                                ty::impl_or_trait_item(\n-                                                    &self.analysis.ty_cx,\n-                                                    mr.def_id()\n-                                                ).name() == ti.name()\n-                                            })\n-                                           .unwrap()\n-                                           .def_id())\n-                        }\n-                    }\n-                } else {\n-                    None\n-                };\n-                self.fmt.meth_call_str(span,\n-                                       sub_span,\n-                                       defid,\n-                                       Some(declid),\n-                                       self.cur_scope);\n-            },\n-            def::DefFn(def_id, _) => {\n-                self.fmt.fn_call_str(span,\n-                                     sub_span,\n-                                     def_id,\n-                                     self.cur_scope)\n-            }\n-            _ => self.sess.span_bug(span,\n-                                    &format!(\"Unexpected def kind while looking \\\n-                                              up path in `{}`: `{:?}`\",\n-                                             self.span.snippet(span),\n-                                             def)),\n-        }\n-        // modules or types in the path prefix\n-        match def {\n-            def::DefMethod(did, _) => {\n-                let ti = ty::impl_or_trait_item(&self.analysis.ty_cx, did);\n-                if let ty::MethodTraitItem(m) = ti {\n-                    if m.explicit_self == ty::StaticExplicitSelfCategory {\n-                        self.write_sub_path_trait_truncated(path);\n-                    }\n-                }\n-            }\n-            def::DefLocal(_) |\n-            def::DefStatic(_,_) |\n-            def::DefConst(..) |\n-            def::DefAssociatedConst(..) |\n-            def::DefStruct(_) |\n-            def::DefVariant(..) |\n-            def::DefFn(..) => self.write_sub_paths_truncated(path, false),\n-            _ => {},\n-        }\n-    }\n-\n-    fn process_struct_lit(&mut self,\n-                          ex: &ast::Expr,\n-                          path: &ast::Path,\n-                          fields: &Vec<ast::Field>,\n-                          base: &Option<P<ast::Expr>>) {\n-        if generated_code(path.span) {\n-            return\n-        }\n-\n-        self.write_sub_paths_truncated(path, false);\n-\n-        let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, ex).sty;\n-        let struct_def = match *ty {\n-            ty::ty_struct(def_id, _) => {\n-                let sub_span = self.span.span_for_last_ident(path.span);\n-                self.fmt.ref_str(recorder::StructRef,\n-                                 path.span,\n-                                 sub_span,\n-                                 def_id,\n-                                 self.cur_scope);\n-                Some(def_id)\n-            }\n-            _ => None\n-        };\n-\n-        for field in fields {\n-            match struct_def {\n-                Some(struct_def) => {\n-                    let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n-                    for f in &fields {\n-                        if generated_code(field.ident.span) {\n-                            continue;\n-                        }\n-                        if f.name == field.ident.node.name {\n-                            // We don't really need a sub-span here, but no harm done\n-                            let sub_span = self.span.span_for_last_ident(field.ident.span);\n-                            self.fmt.ref_str(recorder::VarRef,\n-                                             field.ident.span,\n-                                             sub_span,\n-                                             f.id,\n-                                             self.cur_scope);\n-                        }\n-                    }\n-                }\n-                None => {}\n-            }\n+// An AST visitor for collecting paths from patterns.\n+struct PathCollector {\n+    // The Row field identifies the kind of pattern.\n+    collected_paths: Vec<(NodeId, ast::Path, ast::Mutability, recorder::Row)>,\n+}\n \n-            self.visit_expr(&*field.expr)\n+impl PathCollector {\n+    fn new() -> PathCollector {\n+        PathCollector {\n+            collected_paths: vec![],\n         }\n-        visit::walk_expr_opt(self, base)\n-    }\n-\n-    fn process_method_call(&mut self,\n-                           ex: &ast::Expr,\n-                           args: &Vec<P<ast::Expr>>) {\n-        let method_map = self.analysis.ty_cx.method_map.borrow();\n-        let method_callee = method_map.get(&ty::MethodCall::expr(ex.id)).unwrap();\n-        let (def_id, decl_id) = match method_callee.origin {\n-            ty::MethodStatic(def_id) |\n-            ty::MethodStaticClosure(def_id) => {\n-                // method invoked on an object with a concrete type (not a static method)\n-                let decl_id =\n-                    match ty::trait_item_of_item(&self.analysis.ty_cx,\n-                                                 def_id) {\n-                        None => None,\n-                        Some(decl_id) => Some(decl_id.def_id()),\n-                    };\n-\n-                // This incantation is required if the method referenced is a\n-                // trait's default implementation.\n-                let def_id = match ty::impl_or_trait_item(&self.analysis\n-                                                               .ty_cx,\n-                                                          def_id) {\n-                    ty::MethodTraitItem(method) => {\n-                        method.provided_source.unwrap_or(def_id)\n-                    }\n-                    _ => self.sess\n-                             .span_bug(ex.span,\n-                                       \"save::process_method_call: non-method \\\n-                                        DefId in MethodStatic or MethodStaticClosure\"),\n-                };\n-                (Some(def_id), decl_id)\n-            }\n-            ty::MethodTypeParam(ref mp) => {\n-                // method invoked on a type parameter\n-                let trait_item = ty::trait_item(&self.analysis.ty_cx,\n-                                                mp.trait_ref.def_id,\n-                                                mp.method_num);\n-                (None, Some(trait_item.def_id()))\n-            }\n-            ty::MethodTraitObject(ref mo) => {\n-                // method invoked on a trait instance\n-                let trait_item = ty::trait_item(&self.analysis.ty_cx,\n-                                                mo.trait_ref.def_id,\n-                                                mo.method_num);\n-                (None, Some(trait_item.def_id()))\n-            }\n-        };\n-        let sub_span = self.span.sub_span_for_meth_name(ex.span);\n-        self.fmt.meth_call_str(ex.span,\n-                               sub_span,\n-                               def_id,\n-                               decl_id,\n-                               self.cur_scope);\n-\n-        // walk receiver and args\n-        visit::walk_exprs(self, &args[..]);\n     }\n+}\n \n-    fn process_pat(&mut self, p:&ast::Pat) {\n+impl<'v> Visitor<'v> for PathCollector {\n+    fn visit_pat(&mut self, p: &ast::Pat) {\n         if generated_code(p.span) {\n-            return\n+            return;\n         }\n \n         match p.node {\n-            ast::PatStruct(ref path, ref fields, _) => {\n-                self.collected_paths.push((p.id, path.clone(), false, recorder::StructRef));\n-                visit::walk_path(self, path);\n-\n-                let def = self.analysis.ty_cx.def_map.borrow().get(&p.id).unwrap().full_def();\n-                let struct_def = match def {\n-                    def::DefConst(..) | def::DefAssociatedConst(..) => None,\n-                    def::DefVariant(_, variant_id, _) => Some(variant_id),\n-                    _ => {\n-                        match ty::ty_to_def_id(ty::node_id_to_type(&self.analysis.ty_cx, p.id)) {\n-                            None => {\n-                                self.sess.span_bug(p.span,\n-                                                   &format!(\"Could not find struct_def for `{}`\",\n-                                                            self.span.snippet(p.span)));\n-                            }\n-                            Some(def_id) => Some(def_id),\n-                        }\n-                    }\n-                };\n-\n-                if let Some(struct_def) = struct_def {\n-                    let struct_fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n-                    for &Spanned { node: ref field, span } in fields {\n-                        let sub_span = self.span.span_for_first_ident(span);\n-                        for f in &struct_fields {\n-                            if f.name == field.ident.name {\n-                                self.fmt.ref_str(recorder::VarRef,\n-                                                 span,\n-                                                 sub_span,\n-                                                 f.id,\n-                                                 self.cur_scope);\n-                                break;\n-                            }\n-                        }\n-                        self.visit_pat(&*field.pat);\n-                    }\n-                }\n+            ast::PatStruct(ref path, _, _) => {\n+                self.collected_paths.push((p.id,\n+                                           path.clone(),\n+                                           ast::MutMutable,\n+                                           recorder::StructRef));\n             }\n             ast::PatEnum(ref path, _) |\n             ast::PatQPath(_, ref path) => {\n-                self.collected_paths.push((p.id, path.clone(), false, recorder::VarRef));\n-                visit::walk_pat(self, p);\n+                self.collected_paths.push((p.id, path.clone(), ast::MutMutable, recorder::VarRef));\n             }\n-            ast::PatIdent(bm, ref path1, ref optional_subpattern) => {\n+            ast::PatIdent(bm, ref path1, _) => {\n+                debug!(\"PathCollector, visit ident in pat {}: {:?} {:?}\",\n+                       token::get_ident(path1.node),\n+                       p.span,\n+                       path1.span);\n                 let immut = match bm {\n                     // Even if the ref is mut, you can't change the ref, only\n                     // the data pointed at, so showing the initialising expression\n                     // is still worthwhile.\n-                    ast::BindByRef(_) => true,\n-                    ast::BindByValue(mt) => {\n-                        match mt {\n-                            ast::MutMutable => false,\n-                            ast::MutImmutable => true,\n-                        }\n-                    }\n+                    ast::BindByRef(_) => ast::MutImmutable,\n+                    ast::BindByValue(mt) => mt,\n                 };\n                 // collect path for either visit_local or visit_arm\n-                let path = ast_util::ident_to_path(path1.span,path1.node);\n+                let path = ast_util::ident_to_path(path1.span, path1.node);\n                 self.collected_paths.push((p.id, path, immut, recorder::VarRef));\n-                match *optional_subpattern {\n-                    None => {}\n-                    Some(ref subpattern) => self.visit_pat(&**subpattern)\n-                }\n-            }\n-            _ => visit::walk_pat(self, p)\n-        }\n-    }\n-}\n-\n-impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        if generated_code(item.span) {\n-            return\n-        }\n-\n-        match item.node {\n-            ast::ItemUse(ref use_item) => {\n-                match use_item.node {\n-                    ast::ViewPathSimple(ident, ref path) => {\n-                        let sub_span = self.span.span_for_last_ident(path.span);\n-                        let mod_id = match self.lookup_type_ref(item.id) {\n-                            Some(def_id) => {\n-                                match self.lookup_def_kind(item.id, path.span) {\n-                                    Some(kind) => self.fmt.ref_str(kind,\n-                                                                   path.span,\n-                                                                   sub_span,\n-                                                                   def_id,\n-                                                                   self.cur_scope),\n-                                    None => {},\n-                                }\n-                                Some(def_id)\n-                            },\n-                            None => None,\n-                        };\n-\n-                        // 'use' always introduces an alias, if there is not an explicit\n-                        // one, there is an implicit one.\n-                        let sub_span =\n-                            match self.span.sub_span_after_keyword(use_item.span, keywords::As) {\n-                                Some(sub_span) => Some(sub_span),\n-                                None => sub_span,\n-                            };\n-\n-                        self.fmt.use_alias_str(path.span,\n-                                               sub_span,\n-                                               item.id,\n-                                               mod_id,\n-                                               &get_ident(ident),\n-                                               self.cur_scope);\n-                        self.write_sub_paths_truncated(path, true);\n-                    }\n-                    ast::ViewPathGlob(ref path) => {\n-                        // Make a comma-separated list of names of imported modules.\n-                        let mut name_string = String::new();\n-                        let glob_map = &self.analysis.glob_map;\n-                        let glob_map = glob_map.as_ref().unwrap();\n-                        if glob_map.contains_key(&item.id) {\n-                            for n in glob_map.get(&item.id).unwrap() {\n-                                if !name_string.is_empty() {\n-                                    name_string.push_str(\", \");\n-                                }\n-                                name_string.push_str(n.as_str());\n-                            }\n-                        }\n-\n-                        let sub_span = self.span.sub_span_of_token(path.span,\n-                                                                   token::BinOp(token::Star));\n-                        self.fmt.use_glob_str(path.span,\n-                                              sub_span,\n-                                              item.id,\n-                                              &name_string,\n-                                              self.cur_scope);\n-                        self.write_sub_paths(path, true);\n-                    }\n-                    ast::ViewPathList(ref path, ref list) => {\n-                        for plid in list {\n-                            match plid.node {\n-                                ast::PathListIdent { id, .. } => {\n-                                    match self.lookup_type_ref(id) {\n-                                        Some(def_id) =>\n-                                            match self.lookup_def_kind(id, plid.span) {\n-                                                Some(kind) => {\n-                                                    self.fmt.ref_str(\n-                                                        kind, plid.span,\n-                                                        Some(plid.span),\n-                                                        def_id, self.cur_scope);\n-                                                }\n-                                                None => ()\n-                                            },\n-                                        None => ()\n-                                    }\n-                                },\n-                                ast::PathListMod { .. } => ()\n-                            }\n-                        }\n-\n-                        self.write_sub_paths(path, true);\n-                    }\n-                }\n-            }\n-            ast::ItemExternCrate(ref s) => {\n-                let name = get_ident(item.ident);\n-                let name = &name;\n-                let location = match *s {\n-                    Some(s) => s.to_string(),\n-                    None => name.to_string(),\n-                };\n-                let alias_span = self.span.span_for_last_ident(item.span);\n-                let cnum = match self.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n-                    Some(cnum) => cnum,\n-                    None => 0,\n-                };\n-                self.fmt.extern_crate_str(item.span,\n-                                          alias_span,\n-                                          item.id,\n-                                          cnum,\n-                                          name,\n-                                          &location[..],\n-                                          self.cur_scope);\n-            }\n-            ast::ItemFn(ref decl, _, _, ref ty_params, ref body) =>\n-                self.process_fn(item, &**decl, ty_params, &**body),\n-            ast::ItemStatic(ref typ, mt, ref expr) =>\n-                self.process_static(item, &**typ, mt, &**expr),\n-            ast::ItemConst(ref typ, ref expr) =>\n-                self.process_const(item.id, &item.ident, item.span, &*typ, &*expr),\n-            ast::ItemStruct(ref def, ref ty_params) => self.process_struct(item, &**def, ty_params),\n-            ast::ItemEnum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n-            ast::ItemImpl(_, _,\n-                          ref ty_params,\n-                          ref trait_ref,\n-                          ref typ,\n-                          ref impl_items) => {\n-                self.process_impl(item,\n-                                  ty_params,\n-                                  trait_ref,\n-                                  &**typ,\n-                                  impl_items)\n-            }\n-            ast::ItemTrait(_, ref generics, ref trait_refs, ref methods) =>\n-                self.process_trait(item, generics, trait_refs, methods),\n-            ast::ItemMod(ref m) => self.process_mod(item, m),\n-            ast::ItemTy(ref ty, ref ty_params) => {\n-                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n-                let value = ty_to_string(&**ty);\n-                let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n-                self.fmt.typedef_str(item.span,\n-                                     sub_span,\n-                                     item.id,\n-                                     &qualname[..],\n-                                     &value[..]);\n-\n-                self.visit_ty(&**ty);\n-                self.process_generic_params(ty_params, item.span, &qualname, item.id);\n-            },\n-            ast::ItemMac(_) => (),\n-            _ => visit::walk_item(self, item),\n-        }\n-    }\n-\n-    fn visit_generics(&mut self, generics: &ast::Generics) {\n-        for param in &*generics.ty_params {\n-            for bound in &*param.bounds {\n-                if let ast::TraitTyParamBound(ref trait_ref, _) = *bound {\n-                    self.process_trait_ref(&trait_ref.trait_ref);\n-                }\n-            }\n-            if let Some(ref ty) = param.default {\n-                self.visit_ty(&**ty);\n-            }\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n-        match trait_item.node {\n-            ast::ConstTraitItem(ref ty, Some(ref expr)) => {\n-                self.process_const(trait_item.id, &trait_item.ident,\n-                                   trait_item.span, &*ty, &*expr);\n-            }\n-            ast::MethodTraitItem(ref sig, ref body) => {\n-                self.process_method(sig, body.as_ref().map(|x| &**x),\n-                                    trait_item.id, trait_item.ident.name, trait_item.span);\n-            }\n-            ast::ConstTraitItem(_, None) |\n-            ast::TypeTraitItem(..) => {}\n-        }\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n-        match impl_item.node {\n-            ast::ConstImplItem(ref ty, ref expr) => {\n-                self.process_const(impl_item.id, &impl_item.ident,\n-                                   impl_item.span, &ty, &expr);\n-            }\n-            ast::MethodImplItem(ref sig, ref body) => {\n-                self.process_method(sig, Some(body), impl_item.id,\n-                                    impl_item.ident.name, impl_item.span);\n-            }\n-            ast::TypeImplItem(_) |\n-            ast::MacImplItem(_) => {}\n-        }\n-    }\n-\n-    fn visit_ty(&mut self, t: &ast::Ty) {\n-        if generated_code(t.span) {\n-            return\n-        }\n-\n-        match t.node {\n-            ast::TyPath(_, ref path) => {\n-                match self.lookup_type_ref(t.id) {\n-                    Some(id) => {\n-                        let sub_span = self.span.sub_span_for_type_name(t.span);\n-                        self.fmt.ref_str(recorder::TypeRef,\n-                                         t.span,\n-                                         sub_span,\n-                                         id,\n-                                         self.cur_scope);\n-                    },\n-                    None => ()\n-                }\n-\n-                self.write_sub_paths_truncated(path, false);\n-\n-                visit::walk_path(self, path);\n-            },\n-            _ => visit::walk_ty(self, t),\n-        }\n-    }\n-\n-    fn visit_expr(&mut self, ex: &ast::Expr) {\n-        if generated_code(ex.span) {\n-            return\n-        }\n-\n-        match ex.node {\n-            ast::ExprCall(ref _f, ref _args) => {\n-                // Don't need to do anything for function calls,\n-                // because just walking the callee path does what we want.\n-                visit::walk_expr(self, ex);\n             }\n-            ast::ExprPath(_, ref path) => {\n-                self.process_path(ex.id, path.span, path, None);\n-                visit::walk_expr(self, ex);\n-            }\n-            ast::ExprStruct(ref path, ref fields, ref base) =>\n-                self.process_struct_lit(ex, path, fields, base),\n-            ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n-            ast::ExprField(ref sub_ex, ident) => {\n-                if generated_code(sub_ex.span) {\n-                    return\n-                }\n-\n-                self.visit_expr(&**sub_ex);\n-                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty;\n-                match *ty {\n-                    ty::ty_struct(def_id, _) => {\n-                        let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n-                        for f in &fields {\n-                            if f.name == ident.node.name {\n-                                let sub_span = self.span.span_for_last_ident(ex.span);\n-                                self.fmt.ref_str(recorder::VarRef,\n-                                                 ex.span,\n-                                                 sub_span,\n-                                                 f.id,\n-                                                 self.cur_scope);\n-                                break;\n-                            }\n-                        }\n-                    }\n-                    _ => self.sess.span_bug(ex.span,\n-                                            &format!(\"Expected struct type, found {:?}\", ty)),\n-                }\n-            },\n-            ast::ExprTupField(ref sub_ex, idx) => {\n-                if generated_code(sub_ex.span) {\n-                    return\n-                }\n-\n-                self.visit_expr(&**sub_ex);\n-\n-                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty;\n-                match *ty {\n-                    ty::ty_struct(def_id, _) => {\n-                        let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n-                        for (i, f) in fields.iter().enumerate() {\n-                            if i == idx.node {\n-                                let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n-                                self.fmt.ref_str(recorder::VarRef,\n-                                                 ex.span,\n-                                                 sub_span,\n-                                                 f.id,\n-                                                 self.cur_scope);\n-                                break;\n-                            }\n-                        }\n-                    }\n-                    ty::ty_tup(_) => {}\n-                    _ => self.sess.span_bug(ex.span,\n-                                            &format!(\"Expected struct or tuple \\\n-                                                      type, found {:?}\", ty)),\n-                }\n-            },\n-            ast::ExprClosure(_, ref decl, ref body) => {\n-                if generated_code(body.span) {\n-                    return\n-                }\n-\n-                let mut id = String::from_str(\"$\");\n-                id.push_str(&ex.id.to_string());\n-                self.process_formals(&decl.inputs, &id[..]);\n-\n-                // walk arg and return types\n-                for arg in &decl.inputs {\n-                    self.visit_ty(&*arg.ty);\n-                }\n-\n-                if let ast::Return(ref ret_ty) = decl.output {\n-                    self.visit_ty(&**ret_ty);\n-                }\n-\n-                // walk the body\n-                self.nest(ex.id, |v| v.visit_block(&**body));\n-            },\n-            _ => {\n-                visit::walk_expr(self, ex)\n-            },\n+            _ => {}\n         }\n-    }\n-\n-    fn visit_mac(&mut self, _: &ast::Mac) {\n-        // Just stop, macros are poison to us.\n-    }\n-\n-    fn visit_pat(&mut self, p: &ast::Pat) {\n-        self.process_pat(p);\n-        if !self.collecting {\n-            self.collected_paths.clear();\n-        }\n-    }\n-\n-    fn visit_arm(&mut self, arm: &ast::Arm) {\n-        assert!(self.collected_paths.is_empty() && !self.collecting);\n-        self.collecting = true;\n-        for pattern in &arm.pats {\n-            // collect paths from the arm's patterns\n-            self.visit_pat(&**pattern);\n-        }\n-\n-        // This is to get around borrow checking, because we need mut self to call process_path.\n-        let mut paths_to_process = vec![];\n-        // process collected paths\n-        for &(id, ref p, ref immut, ref_kind) in &self.collected_paths {\n-            let def_map = self.analysis.ty_cx.def_map.borrow();\n-            if !def_map.contains_key(&id) {\n-                self.sess.span_bug(p.span,\n-                                   &format!(\"def_map has no key for {} in visit_arm\",\n-                                           id));\n-            }\n-            let def = def_map.get(&id).unwrap().full_def();\n-            match def {\n-                def::DefLocal(id)  => {\n-                    let value = if *immut {\n-                        self.span.snippet(p.span).to_string()\n-                    } else {\n-                        \"<mutable>\".to_string()\n-                    };\n-\n-                    assert!(p.segments.len() == 1, \"qualified path for local variable def in arm\");\n-                    self.fmt.variable_str(p.span,\n-                                          Some(p.span),\n-                                          id,\n-                                          &path_to_string(p),\n-                                          &value[..],\n-                                          \"\")\n-                }\n-                def::DefVariant(..) | def::DefTy(..) | def::DefStruct(..) => {\n-                    paths_to_process.push((id, p.clone(), Some(ref_kind)))\n-                }\n-                // FIXME(nrc) what are these doing here?\n-                def::DefStatic(_, _) |\n-                def::DefConst(..) |\n-                def::DefAssociatedConst(..) => {}\n-                _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n-                            def)\n-            }\n-        }\n-        for &(id, ref path, ref_kind) in &paths_to_process {\n-            self.process_path(id, path.span, path, ref_kind);\n-        }\n-        self.collecting = false;\n-        self.collected_paths.clear();\n-        visit::walk_expr_opt(self, &arm.guard);\n-        self.visit_expr(&*arm.body);\n-    }\n-\n-    fn visit_stmt(&mut self, s: &ast::Stmt) {\n-        if generated_code(s.span) {\n-            return\n-        }\n-\n-        visit::walk_stmt(self, s)\n-    }\n-\n-    fn visit_local(&mut self, l: &ast::Local) {\n-        if generated_code(l.span) {\n-            return\n-        }\n-\n-        // The local could declare multiple new vars, we must walk the\n-        // pattern and collect them all.\n-        assert!(self.collected_paths.is_empty() && !self.collecting);\n-        self.collecting = true;\n-        self.visit_pat(&*l.pat);\n-        self.collecting = false;\n-\n-        let value = self.span.snippet(l.span);\n-\n-        for &(id, ref p, ref immut, _) in &self.collected_paths {\n-            let value = if *immut { value.to_string() } else { \"<mutable>\".to_string() };\n-            let types = self.analysis.ty_cx.node_types();\n-            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, *types.get(&id).unwrap());\n-            // Get the span only for the name of the variable (I hope the path\n-            // is only ever a variable name, but who knows?).\n-            let sub_span = self.span.span_for_last_ident(p.span);\n-            // Rust uses the id of the pattern for var lookups, so we'll use it too.\n-            self.fmt.variable_str(p.span,\n-                                  sub_span,\n-                                  id,\n-                                  &path_to_string(p),\n-                                  &value[..],\n-                                  &typ[..]);\n-        }\n-        self.collected_paths.clear();\n-\n-        // Just walk the initialiser and type (don't want to walk the pattern again).\n-        visit::walk_ty_opt(self, &l.ty);\n-        visit::walk_expr_opt(self, &l.init);\n+        visit::walk_pat(self, p);\n     }\n }\n \n@@ -1562,27 +265,21 @@ pub fn process_crate(sess: &Session,\n     };\n     root_path.pop();\n \n-    let mut visitor = DxrVisitor {\n-        sess: sess,\n-        analysis: analysis,\n-        collected_paths: vec!(),\n-        collecting: false,\n-        fmt: FmtStrs::new(box Recorder {\n-                            out: output_file,\n-                            dump_spans: false,\n-                        },\n-                        SpanUtils {\n-                            sess: sess,\n-                            err_count: Cell::new(0)\n-                        }),\n-        span: SpanUtils {\n-            sess: sess,\n-            err_count: Cell::new(0)\n-        },\n-        cur_scope: 0\n-    };\n+    let mut visitor = dump_csv::DumpCsvVisitor::new(sess, analysis, output_file);\n \n     visitor.dump_crate_info(&cratename[..], krate);\n-\n     visit::walk_crate(&mut visitor, krate);\n }\n+\n+// Utility functions for the module.\n+\n+// Helper function to escape quotes in a string\n+fn escape(s: String) -> String {\n+    s.replace(\"\\\"\", \"\\\"\\\"\")\n+}\n+\n+// If the expression is a macro expansion or other generated code, run screaming\n+// and don't index.\n+fn generated_code(span: Span) -> bool {\n+    span.expn_id != NO_EXPANSION || span  == DUMMY_SP\n+}"}, {"sha": "193902d981d690b30cf3795d6f58af419818038e", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/579e31929feff51dcaf8d444648eff8de735f91a/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579e31929feff51dcaf8d444648eff8de735f91a/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=579e31929feff51dcaf8d444648eff8de735f91a", "patch": "@@ -62,6 +62,9 @@ macro_rules! svec {\n     })\n }\n \n+// FIXME recorder should operate on super::Data, rather than lots of ad hoc\n+// data.\n+\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum Row {\n     Variable,"}, {"sha": "c3ac805af27ec1fcd6b5d684af0f353cb987b93d", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/579e31929feff51dcaf8d444648eff8de735f91a/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579e31929feff51dcaf8d444648eff8de735f91a/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=579e31929feff51dcaf8d444648eff8de735f91a", "patch": "@@ -230,14 +230,14 @@ impl<'a> SpanUtils<'a> {\n     // Reparse span and return an owned vector of sub spans of the first limit\n     // identifier tokens in the given nesting level.\n     // example with Foo<Bar<T,V>, Bar<T,V>>\n-    // Nesting = 0: all idents outside of brackets: Vec<Foo>\n-    // Nesting = 1: idents within one level of brackets: Vec<Bar, Bar>\n+    // Nesting = 0: all idents outside of brackets: [Foo]\n+    // Nesting = 1: idents within one level of brackets: [Bar, Bar]\n     pub fn spans_with_brackets(&self, span: Span, nesting: isize, limit: isize) -> Vec<Span> {\n         let mut result: Vec<Span> = vec!();\n \n         let mut toks = self.retokenise_span(span);\n         // We keep track of how many brackets we're nested in\n-        let mut bracket_count = 0;\n+        let mut bracket_count: isize = 0;\n         let mut found_ufcs_sep = false;\n         loop {\n             let ts = toks.real_token();\n@@ -255,19 +255,26 @@ impl<'a> SpanUtils<'a> {\n             }\n             bracket_count += match ts.tok {\n                 token::Lt => 1,\n-                token::Gt => {\n-                    // Ignore the `>::` in `<Type as Trait>::AssocTy`.\n-                    if !found_ufcs_sep && bracket_count == 0 {\n-                        found_ufcs_sep = true;\n-                        0\n-                    } else {\n-                        -1\n-                    }\n-                }\n+                token::Gt => -1,\n                 token::BinOp(token::Shl) => 2,\n                 token::BinOp(token::Shr) => -2,\n                 _ => 0\n             };\n+\n+            // Ignore the `>::` in `<Type as Trait>::AssocTy`.\n+\n+            // The root cause of this hack is that the AST representation of\n+            // qpaths is horrible. It treats <A as B>::C as a path with two\n+            // segments, B and C and notes that there is also a self type A at\n+            // position 0. Because we don't have spans for individual idents,\n+            // only the whole path, we have to iterate over the tokens in the\n+            // path, trying to pull out the non-nested idents (e.g., avoiding 'a\n+            // in `<A as B<'a>>::C`). So we end up with a span for `B>::C` from\n+            // the start of the first ident to the end of the path.\n+            if !found_ufcs_sep && bracket_count == -1 {\n+                found_ufcs_sep = true;\n+                bracket_count += 1;\n+            }\n             if ts.tok.is_ident() && bracket_count == nesting {\n                 result.push(self.make_sub_span(span, Some(ts.sp)).unwrap());\n             }\n@@ -335,7 +342,7 @@ impl<'a> SpanUtils<'a> {\n     }\n \n \n-    // Returns a list of the spans of idents in a patch.\n+    // Returns a list of the spans of idents in a path.\n     // E.g., For foo::bar<x,t>::baz, we return [foo, bar, baz] (well, their spans)\n     pub fn spans_for_path_segments(&self, path: &ast::Path) -> Vec<Span> {\n         if generated_code(path.span) {"}, {"sha": "701bdee1109ed323fc9f9e69fb8dbb5cf466a33d", "filename": "src/test/run-make/save-analysis/Makefile", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/579e31929feff51dcaf8d444648eff8de735f91a/src%2Ftest%2Frun-make%2Fsave-analysis%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/579e31929feff51dcaf8d444648eff8de735f91a/src%2Ftest%2Frun-make%2Fsave-analysis%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2FMakefile?ref=579e31929feff51dcaf8d444648eff8de735f91a", "patch": "@@ -1,3 +1,6 @@\n -include ../tools.mk\n-all:\n+all: code\n+krate2: krate2.rs\n+\t$(RUSTC) $< \n+code: foo.rs krate2\n \t$(RUSTC) foo.rs -Zsave-analysis"}, {"sha": "07b99dff4e0faba4f50409149672207e09d5295a", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "modified", "additions": 74, "deletions": 42, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/579e31929feff51dcaf8d444648eff8de735f91a/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579e31929feff51dcaf8d444648eff8de735f91a/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=579e31929feff51dcaf8d444648eff8de735f91a", "patch": "@@ -9,43 +9,52 @@\n // except according to those terms.\n \n #![ crate_name = \"test\" ]\n-#![allow(unstable)]\n-#![feature(box_syntax, rustc_private, core, zero_one)]\n+#![feature(box_syntax)]\n+#![feature(rustc_private)]\n+\n \n extern crate graphviz;\n // A simple rust project\n \n+extern crate krate2;\n+extern crate krate2 as krate3;\n extern crate flate as myflate;\n \n+use graphviz::RenderOption;\n use std::collections::{HashMap,HashSet};\n use std::cell::RefCell;\n+use std::io::Write;\n \n \n use sub::sub2 as msalias;\n use sub::sub2;\n use sub::sub2::nested_struct as sub_struct;\n-use std::num::One;\n \n use std::mem::size_of;\n \n+use std::char::from_u32;\n+\n static uni: &'static str = \"Les Mis\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9rables\";\n static yy: usize = 25;\n \n-static bob: Option<&'static [isize]> = None;\n+static bob: Option<graphviz::RenderOption> = None;\n \n // buglink test - see issue #1337.\n \n fn test_alias<I: Iterator>(i: Option<<I as Iterator>::Item>) {\n-    let s = sub_struct{ field2: 45, };\n+    let s = sub_struct{ field2: 45u32, };\n \n     // import tests\n-    fn foo(x: &One) {}\n+    fn foo(x: &Write) {}\n+    let _: Option<_> = from_u32(45);\n \n-    let x = 42;\n+    let x = 42usize;\n \n+    krate2::hello();\n+    krate3::hello();\n     myflate::deflate_bytes(&[]);\n \n-    let x = (3, 4);\n+    let x = (3isize, 4usize);\n     let y = x.1;\n }\n \n@@ -55,15 +64,21 @@ fn test_tup_struct(x: TupStruct) -> isize {\n     x.1\n }\n \n+fn println(s: &str) {\n+    std::io::stdout().write_all(s.as_bytes());\n+}\n+\n mod sub {\n     pub mod sub2 {\n+        use std::io::Write;\n         pub mod sub3 {\n+            use std::io::Write;\n             pub fn hello() {\n-                println!(\"hello from module 3\");\n+                ::println(\"hello from module 3\");\n             }\n         }\n         pub fn hello() {\n-            println!(\"hello from a module\");\n+            ::println(\"hello from a module\");\n         }\n \n         pub struct nested_struct {\n@@ -93,14 +108,14 @@ struct some_fields {\n type SF = some_fields;\n \n trait SuperTrait {\n-    fn dummy(&self) { }\n+    fn qux(&self) { panic!(); }\n }\n \n trait SomeTrait: SuperTrait {\n     fn Method(&self, x: u32) -> u32;\n \n     fn prov(&self, x: u32) -> u32 {\n-        println!(\"{}\", &x.to_string());\n+        println(&x.to_string());\n         42\n     }\n     fn provided_method(&self) -> u32 {\n@@ -116,7 +131,7 @@ trait SubTrait: SomeTrait {\n \n impl SomeTrait for some_fields {\n     fn Method(&self, x: u32) -> u32 {\n-        println!(\"{}\", &x.to_string());\n+        println(&x.to_string());\n         self.field1\n     }\n }\n@@ -128,14 +143,15 @@ impl SubTrait for some_fields {}\n \n impl some_fields {\n     fn stat(x: u32) -> u32 {\n-        println!(\"{}\", &x.to_string());\n+        println(&x.to_string());\n         42\n     }\n     fn stat2(x: &some_fields) -> u32 {\n         42\n     }\n \n     fn align_to<T>(&mut self) {\n+\n     }\n \n     fn test(&mut self) {\n@@ -188,61 +204,58 @@ enum SomeStructEnum {\n \n fn matchSomeEnum(val: SomeEnum) {\n     match val {\n-        SomeEnum::Ints(int1, int2) => { println!(\"{}\", &(int1+int2).to_string()); }\n-        SomeEnum::Floats(float1, float2) => { println!(\"{}\", &(float2*float1).to_string()); }\n-        SomeEnum::Strings(_, _, s3) => { println!(\"{}\", s3); }\n-        SomeEnum::MyTypes(mt1, mt2) => {\n-            println!(\"{}\", &(mt1.field1 - mt2.field1).to_string());\n-        }\n+        SomeEnum::Ints(int1, int2) => { println(&(int1+int2).to_string()); }\n+        SomeEnum::Floats(float1, float2) => { println(&(float2*float1).to_string()); }\n+        SomeEnum::Strings(_, _, s3) => { println(s3); }\n+        SomeEnum::MyTypes(mt1, mt2) => { println(&(mt1.field1 - mt2.field1).to_string()); }\n     }\n }\n \n fn matchSomeStructEnum(se: SomeStructEnum) {\n     match se {\n-        SomeStructEnum::EnumStruct{a:a, ..} => println!(\"{}\", &a.to_string()),\n-        SomeStructEnum::EnumStruct2{f1:f1, f2:f_2} => println!(\"{}\", &f_2.field1.to_string()),\n-        SomeStructEnum::EnumStruct3{f1, ..} => println!(\"{}\", &f1.field1.to_string()),\n+        SomeStructEnum::EnumStruct{a:a, ..} => println(&a.to_string()),\n+        SomeStructEnum::EnumStruct2{f1:f1, f2:f_2} => println(&f_2.field1.to_string()),\n+        SomeStructEnum::EnumStruct3{f1, ..} => println(&f1.field1.to_string()),\n     }\n }\n \n \n fn matchSomeStructEnum2(se: SomeStructEnum) {\n     use SomeStructEnum::*;\n     match se {\n-        EnumStruct{a: ref aaa, ..} => println!(\"{}\", &aaa.to_string()),\n-        EnumStruct2{f1, f2: f2} => println!(\"{}\", &f1.field1.to_string()),\n-        EnumStruct3{f1, f3: SomeEnum::Ints(_, _), f2} => println!(\"{}\", &f1.field1.to_string()),\n+        EnumStruct{a: ref aaa, ..} => println(&aaa.to_string()),\n+        EnumStruct2{f1, f2: f2} => println(&f1.field1.to_string()),\n+        EnumStruct3{f1, f3: SomeEnum::Ints(_, _), f2} => println(&f1.field1.to_string()),\n         _ => {},\n     }\n }\n \n fn matchSomeOtherEnum(val: SomeOtherEnum) {\n     use SomeOtherEnum::{SomeConst2, SomeConst3};\n     match val {\n-        SomeOtherEnum::SomeConst1 => { println!(\"I'm const1.\"); }\n-        SomeConst2 | SomeConst3 => { println!(\"I'm const2 or const3.\"); }\n+        SomeOtherEnum::SomeConst1 => { println(\"I'm const1.\"); }\n+        SomeConst2 | SomeConst3 => { println(\"I'm const2 or const3.\"); }\n     }\n }\n \n fn hello<X: SomeTrait>((z, a) : (u32, String), ex: X) {\n     SameDir2::hello(43);\n \n-    println!(\"{}\", &yy.to_string());\n+    println(&yy.to_string());\n     let (x, y): (u32, u32) = (5, 3);\n-    println!(\"{}\", &x.to_string());\n-    println!(\"{}\", &z.to_string());\n+    println(&x.to_string());\n+    println(&z.to_string());\n     let x: u32 = x;\n-    println!(\"{}\", &x.to_string());\n+    println(&x.to_string());\n     let x = \"hello\";\n-    println!(\"{}\", x);\n+    println(x);\n \n     let x = 32.0f32;\n     let _ = (x + ((x * x) + 1.0).sqrt()).ln();\n \n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-    let s: Box<SomeTrait> = Box::new(some_fields {field1: 43});\n+    let s: Box<SomeTrait> = box some_fields {field1: 43};\n     let s2: Box<some_fields> =  box some_fields {field1: 43};\n-    let s3: Box<_> = box nofields;\n+    let s3 = box nofields;\n \n     s.Method(43);\n     s3.Method(43);\n@@ -253,8 +266,6 @@ fn hello<X: SomeTrait>((z, a) : (u32, String), ex: X) {\n     let y: u32 = 56;\n     // static method on struct\n     let r = some_fields::stat(y);\n-    // trait static method, calls override\n-    let r = SubTrait::stat2(&*s2);\n     // trait static method, calls default\n     let r = SubTrait::stat2(&*s3);\n \n@@ -277,7 +288,7 @@ pub struct blah {\n }\n \n fn main() { // foo\n-    let s: Box<_> = box some_fields {field1: 43};\n+    let s = box some_fields {field1: 43};\n     hello((43, \"a\".to_string()), *s);\n     sub::sub2::hello();\n     sub2::sub3::hello();\n@@ -306,7 +317,7 @@ fn main() { // foo\n     let s3: some_fields = some_fields{ field1: 55};\n     let s4: msalias::nested_struct = sub::sub2::nested_struct{ field2: 55};\n     let s4: msalias::nested_struct = sub2::nested_struct{ field2: 55};\n-    println!(\"{}\", &s2.field1.to_string());\n+    println(&s2.field1.to_string());\n     let s5: MyType = box some_fields{ field1: 55};\n     let s = SameDir::SameStruct{name: \"Bob\".to_string()};\n     let s = SubDir::SubStruct{name:\"Bob\".to_string()};\n@@ -316,9 +327,18 @@ fn main() { // foo\n     matchSomeEnum(s7);\n     let s8: SomeOtherEnum = SomeOtherEnum::SomeConst2;\n     matchSomeOtherEnum(s8);\n-    let s9: SomeStructEnum =\n-        SomeStructEnum::EnumStruct2{f1: box some_fields{field1:10}, f2: box s2};\n+    let s9: SomeStructEnum = SomeStructEnum::EnumStruct2{ f1: box some_fields{ field1:10 },\n+                                                          f2: box s2 };\n     matchSomeStructEnum(s9);\n+\n+    for x in &vec![1, 2, 3] {\n+        let _y = x;\n+    }\n+\n+    let s7: SomeEnum = SomeEnum::Strings(\"one\", \"two\", \"three\");\n+    if let SomeEnum::Strings(..) = s7 {\n+        println!(\"hello!\");\n+    }\n }\n \n impl Iterator for nofields {\n@@ -332,3 +352,15 @@ impl Iterator for nofields {\n         panic!()\n     }\n }\n+\n+trait Pattern<'a> {\n+    type Searcher;\n+}\n+\n+struct CharEqPattern;\n+\n+impl<'a> Pattern<'a> for CharEqPattern {\n+    type Searcher = CharEqPattern;\n+}\n+\n+struct CharSearcher<'a>(<CharEqPattern as Pattern<'a>>::Searcher);"}, {"sha": "2c6f517ff3882a3cdddf99c13e7d5dc7037b5720", "filename": "src/test/run-make/save-analysis/krate2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/579e31929feff51dcaf8d444648eff8de735f91a/src%2Ftest%2Frun-make%2Fsave-analysis%2Fkrate2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579e31929feff51dcaf8d444648eff8de735f91a/src%2Ftest%2Frun-make%2Fsave-analysis%2Fkrate2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Fkrate2.rs?ref=579e31929feff51dcaf8d444648eff8de735f91a", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![ crate_name = \"krate2\" ]\n+#![ crate_type = \"lib\" ]\n+\n+use std::io::Write;\n+\n+pub fn hello() {\n+    std::io::stdout().write_all(b\"hello world!\\n\");\n+}"}]}