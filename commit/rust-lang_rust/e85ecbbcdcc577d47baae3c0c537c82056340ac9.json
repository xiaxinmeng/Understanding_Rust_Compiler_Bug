{"sha": "e85ecbbcdcc577d47baae3c0c537c82056340ac9", "node_id": "C_kwDOAAsO6NoAKGU4NWVjYmJjZGNjNTc3ZDQ3YmFhZTNjMGM1MzdjODIwNTYzNDBhYzk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-13T19:58:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-13T19:58:37Z"}, "message": "Rollup merge of #110233 - nbdd0121:intrinsic, r=tmiasko\n\nMake rust-intrinsic ABI unwindable\n\nFix #104451, fix https://github.com/rust-lang/miri/issues/2839\n\nr? `@RalfJung`", "tree": {"sha": "e767cbd887e147bd04de445d85e5a4fd9781b804", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e767cbd887e147bd04de445d85e5a4fd9781b804"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e85ecbbcdcc577d47baae3c0c537c82056340ac9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkOF7tCRBK7hj4Ov3rIwAA+PYIALBQ76/s+oT3nMSvVjup55Vs\nYlOqRHFiHBzPIJREKG46n6IcQKbxnR25FcfNNRKkaOx35ou6v3xyEKmdMIBewORN\nwIMrGg0MTz4LVRWh19SCmmveg52lLcWySc+pD4NdhY4uaTuWpxWueJbj9cnh0bFZ\ni03iRd/Kn6KVfzTcA3jlkVJbE1pt61lpET28h68Gq14lH68OWOeOrJLO6w5Vzoz7\nmRP64EjyOitz6A6RkXWtpw+yh0BmMucrT9ar9uJLbalFoXoQgLwlGlMo45YLAw2t\n/I61IOj3THll5aKNmyPKX0QszS313zTZ0Vw0YvQZZV4N9m56i+CyQ19nQTdOEyY=\n=WgqS\n-----END PGP SIGNATURE-----\n", "payload": "tree e767cbd887e147bd04de445d85e5a4fd9781b804\nparent 232eb698edecb9bc7d5f2bcb9305fdd1291ff63f\nparent b07a470d1ae47bbae86df0b9dc6de624bcdf0357\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1681415917 +0200\ncommitter GitHub <noreply@github.com> 1681415917 +0200\n\nRollup merge of #110233 - nbdd0121:intrinsic, r=tmiasko\n\nMake rust-intrinsic ABI unwindable\n\nFix #104451, fix https://github.com/rust-lang/miri/issues/2839\n\nr? `@RalfJung`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e85ecbbcdcc577d47baae3c0c537c82056340ac9", "html_url": "https://github.com/rust-lang/rust/commit/e85ecbbcdcc577d47baae3c0c537c82056340ac9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e85ecbbcdcc577d47baae3c0c537c82056340ac9/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "232eb698edecb9bc7d5f2bcb9305fdd1291ff63f", "url": "https://api.github.com/repos/rust-lang/rust/commits/232eb698edecb9bc7d5f2bcb9305fdd1291ff63f", "html_url": "https://github.com/rust-lang/rust/commit/232eb698edecb9bc7d5f2bcb9305fdd1291ff63f"}, {"sha": "b07a470d1ae47bbae86df0b9dc6de624bcdf0357", "url": "https://api.github.com/repos/rust-lang/rust/commits/b07a470d1ae47bbae86df0b9dc6de624bcdf0357", "html_url": "https://github.com/rust-lang/rust/commit/b07a470d1ae47bbae86df0b9dc6de624bcdf0357"}], "stats": {"total": 302, "additions": 289, "deletions": 13}, "files": [{"sha": "195d951f9f366af83a45f198e182d692ab289829", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e85ecbbcdcc577d47baae3c0c537c82056340ac9/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ecbbcdcc577d47baae3c0c537c82056340ac9/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=e85ecbbcdcc577d47baae3c0c537c82056340ac9", "patch": "@@ -1226,10 +1226,11 @@ pub fn fn_can_unwind(tcx: TyCtxt<'_>, fn_def_id: Option<DefId>, abi: SpecAbi) ->\n         | AvrNonBlockingInterrupt\n         | CCmseNonSecureCall\n         | Wasm\n-        | RustIntrinsic\n         | PlatformIntrinsic\n         | Unadjusted => false,\n-        Rust | RustCall | RustCold => tcx.sess.panic_strategy() == PanicStrategy::Unwind,\n+        Rust | RustCall | RustCold | RustIntrinsic => {\n+            tcx.sess.panic_strategy() == PanicStrategy::Unwind\n+        }\n     }\n }\n "}, {"sha": "c4f554c8c6bf99c57d2dfeeee6636975e37911a8", "filename": "library/core/src/ffi/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e85ecbbcdcc577d47baae3c0c537c82056340ac9/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ecbbcdcc577d47baae3c0c537c82056340ac9/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs?ref=e85ecbbcdcc577d47baae3c0c537c82056340ac9", "patch": "@@ -615,12 +615,15 @@ impl<'f> Drop for VaListImpl<'f> {\n extern \"rust-intrinsic\" {\n     /// Destroy the arglist `ap` after initialization with `va_start` or\n     /// `va_copy`.\n+    #[rustc_nounwind]\n     fn va_end(ap: &mut VaListImpl<'_>);\n \n     /// Copies the current location of arglist `src` to the arglist `dst`.\n+    #[rustc_nounwind]\n     fn va_copy<'f>(dest: *mut VaListImpl<'f>, src: &VaListImpl<'f>);\n \n     /// Loads an argument of type `T` from the `va_list` `ap` and increment the\n     /// argument `ap` points to.\n+    #[rustc_nounwind]\n     fn va_arg<T: sealed_trait::VaArgSafe>(ap: &mut VaListImpl<'_>) -> T;\n }"}, {"sha": "a7c100e1b23ed6d87fd8c0bf00e48bf0c6a966c3", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 231, "deletions": 1, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/e85ecbbcdcc577d47baae3c0c537c82056340ac9/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ecbbcdcc577d47baae3c0c537c82056340ac9/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=e85ecbbcdcc577d47baae3c0c537c82056340ac9", "patch": "@@ -84,104 +84,119 @@ extern \"rust-intrinsic\" {\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Relaxed`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_relaxed_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Relaxed`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_relaxed_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Relaxed`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_relaxed_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Acquire`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acquire_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Acquire`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acquire_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Acquire`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acquire_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Release`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_release_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Release`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_release_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Release`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_release_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acqrel_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acqrel_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acqrel_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::SeqCst`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_seqcst_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::SeqCst`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_seqcst_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::SeqCst`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_seqcst_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Stores a value if the current value is the same as the `old` value.\n@@ -190,411 +205,477 @@ extern \"rust-intrinsic\" {\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Relaxed`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_relaxed_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Relaxed`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_relaxed_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Relaxed`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_relaxed_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Acquire`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acquire_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Acquire`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acquire_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Acquire`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acquire_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Release`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_release_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Release`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_release_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Release`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_release_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acqrel_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acqrel_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acqrel_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::SeqCst`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_seqcst_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::SeqCst`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_seqcst_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::SeqCst`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_seqcst_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `load` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::load`].\n+    #[rustc_nounwind]\n     pub fn atomic_load_seqcst<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `load` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::load`].\n+    #[rustc_nounwind]\n     pub fn atomic_load_acquire<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `load` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::load`].\n+    #[rustc_nounwind]\n     pub fn atomic_load_relaxed<T: Copy>(src: *const T) -> T;\n+    #[rustc_nounwind]\n     pub fn atomic_load_unordered<T: Copy>(src: *const T) -> T;\n \n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `store` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::store`].\n+    #[rustc_nounwind]\n     pub fn atomic_store_seqcst<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `store` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::store`].\n+    #[rustc_nounwind]\n     pub fn atomic_store_release<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `store` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::store`].\n+    #[rustc_nounwind]\n     pub fn atomic_store_relaxed<T: Copy>(dst: *mut T, val: T);\n+    #[rustc_nounwind]\n     pub fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);\n \n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicI32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_min_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicI32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_min_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicI32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_min_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n@@ -607,93 +688,108 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicI32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_min_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::SeqCst`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_fence_seqcst();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::Acquire`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_fence_acquire();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::Release`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_fence_release();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::AcqRel`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_fence_acqrel();\n \n     /// A compiler-only memory barrier.\n@@ -706,6 +802,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::SeqCst`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_singlethreadfence_seqcst();\n     /// A compiler-only memory barrier.\n     ///\n@@ -717,6 +814,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::Acquire`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_singlethreadfence_acquire();\n     /// A compiler-only memory barrier.\n     ///\n@@ -728,6 +826,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::Release`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_singlethreadfence_release();\n     /// A compiler-only memory barrier.\n     ///\n@@ -739,6 +838,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::AcqRel`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_singlethreadfence_acqrel();\n \n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n@@ -750,6 +850,7 @@ extern \"rust-intrinsic\" {\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn prefetch_read_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n@@ -760,6 +861,7 @@ extern \"rust-intrinsic\" {\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn prefetch_write_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n@@ -770,6 +872,7 @@ extern \"rust-intrinsic\" {\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn prefetch_read_instruction<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n@@ -780,6 +883,7 @@ extern \"rust-intrinsic\" {\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn prefetch_write_instruction<T>(data: *const T, locality: i32);\n \n     /// Magic intrinsic that derives its meaning from attributes\n@@ -792,6 +896,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// This intrinsic should not be used outside of the compiler.\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn rustc_peek<T>(_: T) -> T;\n \n     /// Aborts the execution of the process.\n@@ -810,6 +915,7 @@ extern \"rust-intrinsic\" {\n     /// process will probably terminate with a signal like `SIGABRT`, `SIGILL`, `SIGTRAP`, `SIGSEGV` or\n     /// `SIGBUS`.  The precise behaviour is not guaranteed and not stable.\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn abort() -> !;\n \n     /// Informs the optimizer that this point in the code is not reachable,\n@@ -821,6 +927,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is [`core::hint::unreachable_unchecked`].\n     #[rustc_const_stable(feature = \"const_unreachable_unchecked\", since = \"1.57.0\")]\n+    #[rustc_nounwind]\n     pub fn unreachable() -> !;\n \n     /// Informs the optimizer that a condition is always true.\n@@ -834,6 +941,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_assume\", issue = \"76972\")]\n+    #[rustc_nounwind]\n     pub fn assume(b: bool);\n \n     /// Hints to the compiler that branch condition is likely to be true.\n@@ -849,6 +957,7 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_likely\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn likely(b: bool) -> bool;\n \n     /// Hints to the compiler that branch condition is likely to be false.\n@@ -864,11 +973,13 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_likely\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn unlikely(b: bool) -> bool;\n \n     /// Executes a breakpoint trap, for inspection by a debugger.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn breakpoint();\n \n     /// The size of a type in bytes.\n@@ -884,6 +995,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::mem::size_of`].\n     #[rustc_const_stable(feature = \"const_size_of\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn size_of<T>() -> usize;\n \n     /// The minimum alignment of a type.\n@@ -896,23 +1008,27 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::mem::align_of`].\n     #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn min_align_of<T>() -> usize;\n     /// The preferred alignment of a type.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     /// It's \"tracking issue\" is [#91971](https://github.com/rust-lang/rust/issues/91971).\n     #[rustc_const_unstable(feature = \"const_pref_align_of\", issue = \"91971\")]\n+    #[rustc_nounwind]\n     pub fn pref_align_of<T>() -> usize;\n \n     /// The size of the referenced value in bytes.\n     ///\n     /// The stabilized version of this intrinsic is [`mem::size_of_val`].\n     #[rustc_const_unstable(feature = \"const_size_of_val\", issue = \"46571\")]\n+    #[rustc_nounwind]\n     pub fn size_of_val<T: ?Sized>(_: *const T) -> usize;\n     /// The required alignment of the referenced value.\n     ///\n     /// The stabilized version of this intrinsic is [`core::mem::align_of_val`].\n     #[rustc_const_unstable(feature = \"const_align_of_val\", issue = \"46571\")]\n+    #[rustc_nounwind]\n     pub fn min_align_of_val<T: ?Sized>(_: *const T) -> usize;\n \n     /// Gets a static string slice containing the name of a type.\n@@ -925,6 +1041,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::any::type_name`].\n     #[rustc_const_unstable(feature = \"const_type_name\", issue = \"63084\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn type_name<T: ?Sized>() -> &'static str;\n \n     /// Gets an identifier which is globally unique to the specified type. This\n@@ -939,6 +1056,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::any::TypeId::of`].\n     #[rustc_const_unstable(feature = \"const_type_id\", issue = \"77125\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:\n@@ -947,6 +1065,7 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_stable(feature = \"const_assert_type\", since = \"1.59.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn assert_inhabited<T>();\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` does not permit\n@@ -955,13 +1074,15 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_assert_type2\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn assert_zero_valid<T>();\n \n     /// A guard for `std::mem::uninitialized`. This will statically either panic, or do nothing.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_assert_type2\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn assert_mem_uninitialized_valid<T>();\n \n     /// Gets a reference to a static `Location` indicating where it was called.\n@@ -974,6 +1095,7 @@ extern \"rust-intrinsic\" {\n     /// Consider using [`core::panic::Location::caller`] instead.\n     #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"76156\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn caller_location() -> &'static crate::panic::Location<'static>;\n \n     /// Moves a value out of scope without running drop glue.\n@@ -987,6 +1109,7 @@ extern \"rust-intrinsic\" {\n     /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_intrinsic_forget\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn forget<T: ?Sized>(_: T);\n \n     /// Reinterprets the bits of a value of one type as another type.\n@@ -1250,6 +1373,7 @@ extern \"rust-intrinsic\" {\n     #[rustc_allowed_through_unstable_modules]\n     #[rustc_const_stable(feature = \"const_transmute\", since = \"1.56.0\")]\n     #[rustc_diagnostic_item = \"transmute\"]\n+    #[rustc_nounwind]\n     pub fn transmute<Src, Dst>(src: Src) -> Dst;\n \n     /// Returns `true` if the actual type given as `T` requires drop\n@@ -1267,6 +1391,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`mem::needs_drop`](crate::mem::needs_drop).\n     #[rustc_const_stable(feature = \"const_needs_drop\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn needs_drop<T: ?Sized>() -> bool;\n \n     /// Calculates the offset from a pointer.\n@@ -1284,6 +1409,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`pointer::offset`].\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n+    #[rustc_nounwind]\n     pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Calculates the offset from a pointer, potentially wrapping.\n@@ -1301,6 +1427,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`pointer::wrapping_offset`].\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n+    #[rustc_nounwind]\n     pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Masks out bits of the pointer according to a mask.\n@@ -1312,6 +1439,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Consider using [`pointer::mask`] instead.\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn ptr_mask<T>(ptr: *const T, mask: usize) -> *const T;\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\n@@ -1322,6 +1450,7 @@ extern \"rust-intrinsic\" {\n     /// unless size is equal to zero.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n     /// a size of `count * size_of::<T>()` and an alignment of\n@@ -1331,6 +1460,7 @@ extern \"rust-intrinsic\" {\n     /// unless size is equal to zero.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n     /// size of `count * size_of::<T>()` and an alignment of\n@@ -1340,158 +1470,187 @@ extern \"rust-intrinsic\" {\n     /// unless size is equal to zero.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n     /// Performs a volatile load from the `src` pointer.\n     ///\n     /// The stabilized version of this intrinsic is [`core::ptr::read_volatile`].\n+    #[rustc_nounwind]\n     pub fn volatile_load<T>(src: *const T) -> T;\n     /// Performs a volatile store to the `dst` pointer.\n     ///\n     /// The stabilized version of this intrinsic is [`core::ptr::write_volatile`].\n+    #[rustc_nounwind]\n     pub fn volatile_store<T>(dst: *mut T, val: T);\n \n     /// Performs a volatile load from the `src` pointer\n     /// The pointer is not required to be aligned.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn unaligned_volatile_load<T>(src: *const T) -> T;\n     /// Performs a volatile store to the `dst` pointer.\n     /// The pointer is not required to be aligned.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn unaligned_volatile_store<T>(dst: *mut T, val: T);\n \n     /// Returns the square root of an `f32`\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::sqrt`](../../std/primitive.f32.html#method.sqrt)\n+    #[rustc_nounwind]\n     pub fn sqrtf32(x: f32) -> f32;\n     /// Returns the square root of an `f64`\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::sqrt`](../../std/primitive.f64.html#method.sqrt)\n+    #[rustc_nounwind]\n     pub fn sqrtf64(x: f64) -> f64;\n \n     /// Raises an `f32` to an integer power.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::powi`](../../std/primitive.f32.html#method.powi)\n+    #[rustc_nounwind]\n     pub fn powif32(a: f32, x: i32) -> f32;\n     /// Raises an `f64` to an integer power.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::powi`](../../std/primitive.f64.html#method.powi)\n+    #[rustc_nounwind]\n     pub fn powif64(a: f64, x: i32) -> f64;\n \n     /// Returns the sine of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::sin`](../../std/primitive.f32.html#method.sin)\n+    #[rustc_nounwind]\n     pub fn sinf32(x: f32) -> f32;\n     /// Returns the sine of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::sin`](../../std/primitive.f64.html#method.sin)\n+    #[rustc_nounwind]\n     pub fn sinf64(x: f64) -> f64;\n \n     /// Returns the cosine of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::cos`](../../std/primitive.f32.html#method.cos)\n+    #[rustc_nounwind]\n     pub fn cosf32(x: f32) -> f32;\n     /// Returns the cosine of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::cos`](../../std/primitive.f64.html#method.cos)\n+    #[rustc_nounwind]\n     pub fn cosf64(x: f64) -> f64;\n \n     /// Raises an `f32` to an `f32` power.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::powf`](../../std/primitive.f32.html#method.powf)\n+    #[rustc_nounwind]\n     pub fn powf32(a: f32, x: f32) -> f32;\n     /// Raises an `f64` to an `f64` power.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::powf`](../../std/primitive.f64.html#method.powf)\n+    #[rustc_nounwind]\n     pub fn powf64(a: f64, x: f64) -> f64;\n \n     /// Returns the exponential of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::exp`](../../std/primitive.f32.html#method.exp)\n+    #[rustc_nounwind]\n     pub fn expf32(x: f32) -> f32;\n     /// Returns the exponential of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::exp`](../../std/primitive.f64.html#method.exp)\n+    #[rustc_nounwind]\n     pub fn expf64(x: f64) -> f64;\n \n     /// Returns 2 raised to the power of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::exp2`](../../std/primitive.f32.html#method.exp2)\n+    #[rustc_nounwind]\n     pub fn exp2f32(x: f32) -> f32;\n     /// Returns 2 raised to the power of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::exp2`](../../std/primitive.f64.html#method.exp2)\n+    #[rustc_nounwind]\n     pub fn exp2f64(x: f64) -> f64;\n \n     /// Returns the natural logarithm of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::ln`](../../std/primitive.f32.html#method.ln)\n+    #[rustc_nounwind]\n     pub fn logf32(x: f32) -> f32;\n     /// Returns the natural logarithm of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::ln`](../../std/primitive.f64.html#method.ln)\n+    #[rustc_nounwind]\n     pub fn logf64(x: f64) -> f64;\n \n     /// Returns the base 10 logarithm of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::log10`](../../std/primitive.f32.html#method.log10)\n+    #[rustc_nounwind]\n     pub fn log10f32(x: f32) -> f32;\n     /// Returns the base 10 logarithm of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::log10`](../../std/primitive.f64.html#method.log10)\n+    #[rustc_nounwind]\n     pub fn log10f64(x: f64) -> f64;\n \n     /// Returns the base 2 logarithm of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::log2`](../../std/primitive.f32.html#method.log2)\n+    #[rustc_nounwind]\n     pub fn log2f32(x: f32) -> f32;\n     /// Returns the base 2 logarithm of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::log2`](../../std/primitive.f64.html#method.log2)\n+    #[rustc_nounwind]\n     pub fn log2f64(x: f64) -> f64;\n \n     /// Returns `a * b + c` for `f32` values.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::mul_add`](../../std/primitive.f32.html#method.mul_add)\n+    #[rustc_nounwind]\n     pub fn fmaf32(a: f32, b: f32, c: f32) -> f32;\n     /// Returns `a * b + c` for `f64` values.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::mul_add`](../../std/primitive.f64.html#method.mul_add)\n+    #[rustc_nounwind]\n     pub fn fmaf64(a: f64, b: f64, c: f64) -> f64;\n \n     /// Returns the absolute value of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::abs`](../../std/primitive.f32.html#method.abs)\n+    #[rustc_nounwind]\n     pub fn fabsf32(x: f32) -> f32;\n     /// Returns the absolute value of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::abs`](../../std/primitive.f64.html#method.abs)\n+    #[rustc_nounwind]\n     pub fn fabsf64(x: f64) -> f64;\n \n     /// Returns the minimum of two `f32` values.\n@@ -1504,6 +1663,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`f32::min`]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn minnumf32(x: f32, y: f32) -> f32;\n     /// Returns the minimum of two `f64` values.\n     ///\n@@ -1515,6 +1675,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`f64::min`]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn minnumf64(x: f64, y: f64) -> f64;\n     /// Returns the maximum of two `f32` values.\n     ///\n@@ -1526,6 +1687,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`f32::max`]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn maxnumf32(x: f32, y: f32) -> f32;\n     /// Returns the maximum of two `f64` values.\n     ///\n@@ -1537,132 +1699,155 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`f64::max`]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn maxnumf64(x: f64, y: f64) -> f64;\n \n     /// Copies the sign from `y` to `x` for `f32` values.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::copysign`](../../std/primitive.f32.html#method.copysign)\n+    #[rustc_nounwind]\n     pub fn copysignf32(x: f32, y: f32) -> f32;\n     /// Copies the sign from `y` to `x` for `f64` values.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::copysign`](../../std/primitive.f64.html#method.copysign)\n+    #[rustc_nounwind]\n     pub fn copysignf64(x: f64, y: f64) -> f64;\n \n     /// Returns the largest integer less than or equal to an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::floor`](../../std/primitive.f32.html#method.floor)\n+    #[rustc_nounwind]\n     pub fn floorf32(x: f32) -> f32;\n     /// Returns the largest integer less than or equal to an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::floor`](../../std/primitive.f64.html#method.floor)\n+    #[rustc_nounwind]\n     pub fn floorf64(x: f64) -> f64;\n \n     /// Returns the smallest integer greater than or equal to an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::ceil`](../../std/primitive.f32.html#method.ceil)\n+    #[rustc_nounwind]\n     pub fn ceilf32(x: f32) -> f32;\n     /// Returns the smallest integer greater than or equal to an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::ceil`](../../std/primitive.f64.html#method.ceil)\n+    #[rustc_nounwind]\n     pub fn ceilf64(x: f64) -> f64;\n \n     /// Returns the integer part of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::trunc`](../../std/primitive.f32.html#method.trunc)\n+    #[rustc_nounwind]\n     pub fn truncf32(x: f32) -> f32;\n     /// Returns the integer part of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::trunc`](../../std/primitive.f64.html#method.trunc)\n+    #[rustc_nounwind]\n     pub fn truncf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`. May raise an inexact floating-point exception\n     /// if the argument is not an integer.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::round_ties_even`](../../std/primitive.f32.html#method.round_ties_even)\n+    #[rustc_nounwind]\n     pub fn rintf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`. May raise an inexact floating-point exception\n     /// if the argument is not an integer.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::round_ties_even`](../../std/primitive.f64.html#method.round_ties_even)\n+    #[rustc_nounwind]\n     pub fn rintf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn nearbyintf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn nearbyintf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`. Rounds half-way cases away from zero.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::round`](../../std/primitive.f32.html#method.round)\n+    #[rustc_nounwind]\n     pub fn roundf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`. Rounds half-way cases away from zero.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::round`](../../std/primitive.f64.html#method.round)\n+    #[rustc_nounwind]\n     pub fn roundf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`. Rounds half-way cases to the number\n     /// with an even least significant digit.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[cfg(not(bootstrap))]\n+    #[rustc_nounwind]\n     pub fn roundevenf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`. Rounds half-way cases to the number\n     /// with an even least significant digit.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[cfg(not(bootstrap))]\n+    #[rustc_nounwind]\n     pub fn roundevenf64(x: f64) -> f64;\n \n     /// Float addition that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn fadd_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float subtraction that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn fsub_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float multiplication that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn fmul_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float division that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn fdiv_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float remainder that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn frem_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Convert with LLVM\u2019s fptoui/fptosi, which may return undef for values out of range\n     /// (<https://github.com/rust-lang/rust/issues/10184>)\n     ///\n     /// Stabilized as [`f32::to_int_unchecked`] and [`f64::to_int_unchecked`].\n+    #[rustc_nounwind]\n     pub fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n \n     /// Returns the number of bits set in an integer type `T`\n@@ -1677,6 +1862,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::count_ones`]\n     #[rustc_const_stable(feature = \"const_ctpop\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn ctpop<T: Copy>(x: T) -> T;\n \n     /// Returns the number of leading unset bits (zeroes) in an integer type `T`.\n@@ -1715,6 +1901,7 @@ extern \"rust-intrinsic\" {\n     /// ```\n     #[rustc_const_stable(feature = \"const_ctlz\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn ctlz<T: Copy>(x: T) -> T;\n \n     /// Like `ctlz`, but extra-unsafe as it returns `undef` when\n@@ -1734,6 +1921,7 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(num_leading, 3);\n     /// ```\n     #[rustc_const_stable(feature = \"constctlz\", since = \"1.50.0\")]\n+    #[rustc_nounwind]\n     pub fn ctlz_nonzero<T: Copy>(x: T) -> T;\n \n     /// Returns the number of trailing unset bits (zeroes) in an integer type `T`.\n@@ -1772,6 +1960,7 @@ extern \"rust-intrinsic\" {\n     /// ```\n     #[rustc_const_stable(feature = \"const_cttz\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn cttz<T: Copy>(x: T) -> T;\n \n     /// Like `cttz`, but extra-unsafe as it returns `undef` when\n@@ -1791,6 +1980,7 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(num_trailing, 3);\n     /// ```\n     #[rustc_const_stable(feature = \"const_cttz_nonzero\", since = \"1.53.0\")]\n+    #[rustc_nounwind]\n     pub fn cttz_nonzero<T: Copy>(x: T) -> T;\n \n     /// Reverses the bytes in an integer type `T`.\n@@ -1805,6 +1995,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::swap_bytes`]\n     #[rustc_const_stable(feature = \"const_bswap\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn bswap<T: Copy>(x: T) -> T;\n \n     /// Reverses the bits in an integer type `T`.\n@@ -1819,6 +2010,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::reverse_bits`]\n     #[rustc_const_stable(feature = \"const_bitreverse\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn bitreverse<T: Copy>(x: T) -> T;\n \n     /// Performs checked integer addition.\n@@ -1833,6 +2025,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::overflowing_add`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn add_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer subtraction\n@@ -1847,6 +2040,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::overflowing_sub`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn sub_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer multiplication\n@@ -1861,13 +2055,15 @@ extern \"rust-intrinsic\" {\n     /// [`u32::overflowing_mul`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn mul_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs an exact division, resulting in undefined behavior where\n     /// `x % y != 0` or `y == 0` or `x == T::MIN && y == -1`\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_exact_div\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn exact_div<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked division, resulting in undefined behavior\n@@ -1877,6 +2073,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_div` method. For example,\n     /// [`u32::checked_div`]\n     #[rustc_const_stable(feature = \"const_int_unchecked_div\", since = \"1.52.0\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_div<T: Copy>(x: T, y: T) -> T;\n     /// Returns the remainder of an unchecked division, resulting in\n     /// undefined behavior when `y == 0` or `x == T::MIN && y == -1`\n@@ -1885,6 +2082,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_rem` method. For example,\n     /// [`u32::checked_rem`]\n     #[rustc_const_stable(feature = \"const_int_unchecked_rem\", since = \"1.52.0\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_rem<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked left shift, resulting in undefined behavior when\n@@ -1894,6 +2092,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_shl` method. For example,\n     /// [`u32::checked_shl`]\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_shl<T: Copy>(x: T, y: T) -> T;\n     /// Performs an unchecked right shift, resulting in undefined behavior when\n     /// `y < 0` or `y >= N`, where N is the width of T in bits.\n@@ -1902,27 +2101,31 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_shr` method. For example,\n     /// [`u32::checked_shr`]\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_shr<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked addition, resulting in\n     /// undefined behavior when `x + y > T::MAX` or `x + y < T::MIN`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_add<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked subtraction, resulting in\n     /// undefined behavior when `x - y > T::MAX` or `x - y < T::MIN`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_sub<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked multiplication, resulting in\n     /// undefined behavior when `x * y > T::MAX` or `x * y < T::MIN`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_mul<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs rotate left.\n@@ -1937,6 +2140,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::rotate_left`]\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn rotate_left<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs rotate right.\n@@ -1951,6 +2155,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::rotate_right`]\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn rotate_right<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n@@ -1965,6 +2170,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::wrapping_add`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn wrapping_add<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n@@ -1978,6 +2184,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::wrapping_sub`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn wrapping_sub<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n@@ -1991,6 +2198,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::wrapping_mul`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn wrapping_mul<T: Copy>(a: T, b: T) -> T;\n \n     /// Computes `a + b`, saturating at numeric bounds.\n@@ -2005,6 +2213,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::saturating_add`]\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn saturating_add<T: Copy>(a: T, b: T) -> T;\n     /// Computes `a - b`, saturating at numeric bounds.\n     ///\n@@ -2018,6 +2227,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::saturating_sub`]\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn saturating_sub<T: Copy>(a: T, b: T) -> T;\n \n     /// This is an implementation detail of [`crate::ptr::read`] and should\n@@ -2028,6 +2238,7 @@ extern \"rust-intrinsic\" {\n     /// trivially obeys runtime-MIR rules about derefs in operands.\n     #[cfg(not(bootstrap))]\n     #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n+    #[rustc_nounwind]\n     pub fn read_via_copy<T>(p: *const T) -> T;\n \n     /// Returns the value of the discriminant for the variant in 'v';\n@@ -2041,6 +2252,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::mem::discriminant`].\n     #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn discriminant_value<T>(v: &T) -> <T as DiscriminantKind>::Discriminant;\n \n     /// Returns the number of variants of the type `T` cast to a `usize`;\n@@ -2054,6 +2266,7 @@ extern \"rust-intrinsic\" {\n     /// The to-be-stabilized version of this intrinsic is [`mem::variant_count`].\n     #[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn variant_count<T>() -> usize;\n \n     /// Rust's \"try catch\" construct which invokes the function pointer `try_fn`\n@@ -2063,18 +2276,24 @@ extern \"rust-intrinsic\" {\n     /// takes the data pointer and a pointer to the target-specific exception\n     /// object that was caught. For more information see the compiler's\n     /// source as well as std's catch implementation.\n+    ///\n+    /// `catch_fn` must not unwind.\n+    #[rustc_nounwind]\n     pub fn r#try(try_fn: fn(*mut u8), data: *mut u8, catch_fn: fn(*mut u8, *mut u8)) -> i32;\n \n     /// Emits a `!nontemporal` store according to LLVM (see their docs).\n     /// Probably will never become stable.\n+    #[rustc_nounwind]\n     pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n \n     /// See documentation of `<*const T>::offset_from` for details.\n     #[rustc_const_stable(feature = \"const_ptr_offset_from\", since = \"1.65.0\")]\n+    #[rustc_nounwind]\n     pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n \n     /// See documentation of `<*const T>::sub_ptr` for details.\n     #[rustc_const_unstable(feature = \"const_ptr_sub_ptr\", issue = \"95892\")]\n+    #[rustc_nounwind]\n     pub fn ptr_offset_from_unsigned<T>(ptr: *const T, base: *const T) -> usize;\n \n     /// See documentation of `<*const T>::guaranteed_eq` for details.\n@@ -2088,6 +2307,7 @@ extern \"rust-intrinsic\" {\n     /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn ptr_guaranteed_cmp<T>(ptr: *const T, other: *const T) -> u8;\n \n     /// Allocates a block of memory at compile time.\n@@ -2099,6 +2319,7 @@ extern \"rust-intrinsic\" {\n     ///    - At compile time, a compile error occurs if this constraint is violated.\n     ///    - At runtime, it is not checked.\n     #[rustc_const_unstable(feature = \"const_heap\", issue = \"79597\")]\n+    #[rustc_nounwind]\n     pub fn const_allocate(size: usize, align: usize) -> *mut u8;\n \n     /// Deallocates a memory which allocated by `intrinsics::const_allocate` at compile time.\n@@ -2112,6 +2333,7 @@ extern \"rust-intrinsic\" {\n     /// - If the `ptr` is created in an another const, this intrinsic doesn't deallocate it.\n     /// - If the `ptr` is pointing to a local variable, this intrinsic doesn't deallocate it.\n     #[rustc_const_unstable(feature = \"const_heap\", issue = \"79597\")]\n+    #[rustc_nounwind]\n     pub fn const_deallocate(ptr: *mut u8, size: usize, align: usize);\n \n     /// Determines whether the raw bytes of the two values are equal.\n@@ -2136,21 +2358,25 @@ extern \"rust-intrinsic\" {\n     /// (The implementation is allowed to branch on the results of comparisons,\n     /// which is UB if any of their inputs are `undef`.)\n     #[rustc_const_unstable(feature = \"const_intrinsic_raw_eq\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn raw_eq<T>(a: &T, b: &T) -> bool;\n \n     /// See documentation of [`std::hint::black_box`] for details.\n     ///\n     /// [`std::hint::black_box`]: crate::hint::black_box\n     #[rustc_const_unstable(feature = \"const_black_box\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn black_box<T>(dummy: T) -> T;\n \n     /// `ptr` must point to a vtable.\n     /// The intrinsic will return the size stored in that vtable.\n+    #[rustc_nounwind]\n     pub fn vtable_size(ptr: *const ()) -> usize;\n \n     /// `ptr` must point to a vtable.\n     /// The intrinsic will return the alignment stored in that vtable.\n+    #[rustc_nounwind]\n     pub fn vtable_align(ptr: *const ()) -> usize;\n \n     /// Selects which function to call depending on the context.\n@@ -2215,10 +2441,11 @@ extern \"rust-intrinsic\" {\n         G: FnOnce<ARG, Output = RET>,\n         F: FnOnce<ARG, Output = RET>;\n \n-    #[cfg(not(bootstrap))]\n     /// This method creates a pointer to any `Some` value. If the argument is\n     /// `None`, an invalid within-bounds pointer (that is still acceptable for\n     /// constructing an empty slice) is returned.\n+    #[cfg(not(bootstrap))]\n+    #[rustc_nounwind]\n     pub fn option_payload_ptr<T>(arg: *const Option<T>) -> *const T;\n }\n \n@@ -2392,6 +2619,7 @@ pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -\n pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n     extern \"rust-intrinsic\" {\n         #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n+        #[rustc_nounwind]\n         pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n@@ -2482,6 +2710,7 @@ pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: us\n pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n     extern \"rust-intrinsic\" {\n         #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n+        #[rustc_nounwind]\n         fn copy<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n@@ -2554,6 +2783,7 @@ pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n     extern \"rust-intrinsic\" {\n         #[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"86302\")]\n+        #[rustc_nounwind]\n         fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n     }\n "}, {"sha": "818f1a919d0d5f2c3602dd7ccd7217680370a708", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e85ecbbcdcc577d47baae3c0c537c82056340ac9/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ecbbcdcc577d47baae3c0c537c82056340ac9/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=e85ecbbcdcc577d47baae3c0c537c82056340ac9", "patch": "@@ -1371,6 +1371,7 @@ pub const unsafe fn write<T>(dst: *mut T, src: T) {\n     // as `intrinsics::copy_nonoverlapping` is a wrapper function.\n     extern \"rust-intrinsic\" {\n         #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n+        #[rustc_nounwind]\n         fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n     }\n "}, {"sha": "a46a29cbad6081400329485378ea87808bbc2512", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e85ecbbcdcc577d47baae3c0c537c82056340ac9/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ecbbcdcc577d47baae3c0c537c82056340ac9/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=e85ecbbcdcc577d47baae3c0c537c82056340ac9", "patch": "@@ -498,6 +498,7 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     // This function cannot be marked as `unsafe` because `intrinsics::r#try`\n     // expects normal function pointers.\n     #[inline]\n+    #[rustc_nounwind] // `intrinsic::r#try` requires catch fn to be nounwind\n     fn do_catch<F: FnOnce() -> R, R>(data: *mut u8, payload: *mut u8) {\n         // SAFETY: this is the responsibility of the caller, see above.\n         //"}, {"sha": "f50c0eb4788970b4e46b8270ab0bd8bdb065b394", "filename": "tests/mir-opt/issue_104451_unwindable_intrinsics.main.AbortUnwindingCalls.after.mir", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e85ecbbcdcc577d47baae3c0c537c82056340ac9/tests%2Fmir-opt%2Fissue_104451_unwindable_intrinsics.main.AbortUnwindingCalls.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/e85ecbbcdcc577d47baae3c0c537c82056340ac9/tests%2Fmir-opt%2Fissue_104451_unwindable_intrinsics.main.AbortUnwindingCalls.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissue_104451_unwindable_intrinsics.main.AbortUnwindingCalls.after.mir?ref=e85ecbbcdcc577d47baae3c0c537c82056340ac9", "patch": "@@ -0,0 +1,25 @@\n+// MIR for `main` after AbortUnwindingCalls\n+\n+fn main() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/issue_104451_unwindable_intrinsics.rs:+0:11: +0:11\n+    let mut _1: !;                       // in scope 0 at $DIR/issue_104451_unwindable_intrinsics.rs:+2:9: +2:62\n+    let mut _2: ();                      // in scope 0 at $DIR/issue_104451_unwindable_intrinsics.rs:+2:45: +2:47\n+    scope 1 {\n+    }\n+\n+    bb0: {\n+        StorageLive(_1);                 // scope 1 at $DIR/issue_104451_unwindable_intrinsics.rs:+2:9: +2:62\n+        StorageLive(_2);                 // scope 1 at $DIR/issue_104451_unwindable_intrinsics.rs:+2:45: +2:47\n+        _2 = ();                         // scope 1 at $DIR/issue_104451_unwindable_intrinsics.rs:+2:45: +2:47\n+        _1 = const_eval_select::<(), fn() -> ! {ow_ct}, fn() -> ! {ow_ct}, !>(move _2, ow_ct, ow_ct); // scope 1 at $DIR/issue_104451_unwindable_intrinsics.rs:+2:9: +2:62\n+                                         // mir::Constant\n+                                         // + span: $DIR/issue_104451_unwindable_intrinsics.rs:8:9: 8:44\n+                                         // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn((), fn() -> ! {ow_ct}, fn() -> ! {ow_ct}) -> ! {const_eval_select::<(), fn() -> ! {ow_ct}, fn() -> ! {ow_ct}, !>}, val: Value(<ZST>) }\n+                                         // mir::Constant\n+                                         // + span: $DIR/issue_104451_unwindable_intrinsics.rs:8:49: 8:54\n+                                         // + literal: Const { ty: fn() -> ! {ow_ct}, val: Value(<ZST>) }\n+                                         // mir::Constant\n+                                         // + span: $DIR/issue_104451_unwindable_intrinsics.rs:8:56: 8:61\n+                                         // + literal: Const { ty: fn() -> ! {ow_ct}, val: Value(<ZST>) }\n+    }\n+}"}, {"sha": "9babd4aaed512c9ba4fa837a2500bc31abd1693c", "filename": "tests/mir-opt/issue_104451_unwindable_intrinsics.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e85ecbbcdcc577d47baae3c0c537c82056340ac9/tests%2Fmir-opt%2Fissue_104451_unwindable_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ecbbcdcc577d47baae3c0c537c82056340ac9/tests%2Fmir-opt%2Fissue_104451_unwindable_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissue_104451_unwindable_intrinsics.rs?ref=e85ecbbcdcc577d47baae3c0c537c82056340ac9", "patch": "@@ -0,0 +1,14 @@\n+// Check that `UnwindAction::Unreachable` is not generated for unwindable intrinsics.\n+// ignore-wasm32 compiled with panic=abort by default\n+#![feature(core_intrinsics)]\n+\n+// EMIT_MIR issue_104451_unwindable_intrinsics.main.AbortUnwindingCalls.after.mir\n+fn main() {\n+    unsafe {\n+        core::intrinsics::const_eval_select((), ow_ct, ow_ct)\n+    }\n+}\n+\n+const fn ow_ct() -> ! {\n+    panic!();\n+}"}, {"sha": "e95c3f9bcc707ca1e7a03b05182754e1c1c0469b", "filename": "tests/mir-opt/lower_intrinsics.assume.LowerIntrinsics.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e85ecbbcdcc577d47baae3c0c537c82056340ac9/tests%2Fmir-opt%2Flower_intrinsics.assume.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e85ecbbcdcc577d47baae3c0c537c82056340ac9/tests%2Fmir-opt%2Flower_intrinsics.assume.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.assume.LowerIntrinsics.diff?ref=e85ecbbcdcc577d47baae3c0c537c82056340ac9", "patch": "@@ -11,7 +11,7 @@\n           StorageLive(_1);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:9: +2:38\n -         _1 = std::intrinsics::assume(const true) -> [return: bb1, unwind unreachable]; // scope 1 at $DIR/lower_intrinsics.rs:+2:9: +2:38\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:105:9: 105:32\n+-                                          // + span: $DIR/lower_intrinsics.rs:106:9: 106:32\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(bool) {std::intrinsics::assume}, val: Value(<ZST>) }\n +         assume(const true);              // scope 1 at $DIR/lower_intrinsics.rs:+2:9: +2:38\n +         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:9: +2:38"}, {"sha": "a54e9a9320ee18967df8fb4e212b65d178593dba", "filename": "tests/mir-opt/lower_intrinsics.f_copy_nonoverlapping.LowerIntrinsics.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e85ecbbcdcc577d47baae3c0c537c82056340ac9/tests%2Fmir-opt%2Flower_intrinsics.f_copy_nonoverlapping.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e85ecbbcdcc577d47baae3c0c537c82056340ac9/tests%2Fmir-opt%2Flower_intrinsics.f_copy_nonoverlapping.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.f_copy_nonoverlapping.LowerIntrinsics.diff?ref=e85ecbbcdcc577d47baae3c0c537c82056340ac9", "patch": "@@ -49,7 +49,7 @@\n           StorageDead(_9);                 // scope 3 at $DIR/lower_intrinsics.rs:+4:90: +4:91\n -         _3 = copy_nonoverlapping::<i32>(move _4, move _8, const 0_usize) -> [return: bb1, unwind unreachable]; // scope 3 at $DIR/lower_intrinsics.rs:+4:9: +4:95\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:98:9: 98:28\n+-                                          // + span: $DIR/lower_intrinsics.rs:99:9: 99:28\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const i32, *mut i32, usize) {copy_nonoverlapping::<i32>}, val: Value(<ZST>) }\n +         copy_nonoverlapping(dst = move _8, src = move _4, count = const 0_usize); // scope 3 at $DIR/lower_intrinsics.rs:+4:9: +4:95\n +         goto -> bb1;                     // scope 3 at $DIR/lower_intrinsics.rs:+4:9: +4:95"}, {"sha": "cc5079af7f45d6263f4885dfa3e86198a206cc6c", "filename": "tests/mir-opt/lower_intrinsics.option_payload.LowerIntrinsics.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e85ecbbcdcc577d47baae3c0c537c82056340ac9/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e85ecbbcdcc577d47baae3c0c537c82056340ac9/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff?ref=e85ecbbcdcc577d47baae3c0c537c82056340ac9", "patch": "@@ -24,7 +24,7 @@\n           _4 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+2:55: +2:56\n -         _3 = option_payload_ptr::<usize>(move _4) -> [return: bb1, unwind unreachable]; // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:132:18: 132:54\n+-                                          // + span: $DIR/lower_intrinsics.rs:133:18: 133:54\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Option<usize>) -> *const usize {option_payload_ptr::<usize>}, val: Value(<ZST>) }\n +         _3 = &raw const (((*_4) as Some).0: usize); // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n +         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n@@ -37,7 +37,7 @@\n           _6 = &raw const (*_2);           // scope 2 at $DIR/lower_intrinsics.rs:+3:55: +3:56\n -         _5 = option_payload_ptr::<String>(move _6) -> [return: bb2, unwind unreachable]; // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:133:18: 133:54\n+-                                          // + span: $DIR/lower_intrinsics.rs:134:18: 134:54\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Option<String>) -> *const String {option_payload_ptr::<String>}, val: Value(<ZST>) }\n +         _5 = &raw const (((*_6) as Some).0: std::string::String); // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n +         goto -> bb2;                     // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57"}, {"sha": "5805df48f544f4c3d2f5ab5753f0c8db5e287608", "filename": "tests/mir-opt/lower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e85ecbbcdcc577d47baae3c0c537c82056340ac9/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e85ecbbcdcc577d47baae3c0c537c82056340ac9/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff?ref=e85ecbbcdcc577d47baae3c0c537c82056340ac9", "patch": "@@ -13,7 +13,7 @@\n           _2 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n -         _0 = read_via_copy::<i32>(move _2) -> [return: bb1, unwind unreachable]; // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:118:14: 118:45\n+-                                          // + span: $DIR/lower_intrinsics.rs:119:14: 119:45\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const i32) -> i32 {read_via_copy::<i32>}, val: Value(<ZST>) }\n +         _0 = (*_2);                      // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n +         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48"}, {"sha": "95b2ec49d8076bef26930caf0b3cb8ab0a1669d3", "filename": "tests/mir-opt/lower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e85ecbbcdcc577d47baae3c0c537c82056340ac9/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e85ecbbcdcc577d47baae3c0c537c82056340ac9/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff?ref=e85ecbbcdcc577d47baae3c0c537c82056340ac9", "patch": "@@ -13,7 +13,7 @@\n           _2 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n -         _0 = read_via_copy::<Never>(move _2) -> unwind unreachable; // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:123:14: 123:45\n+-                                          // + span: $DIR/lower_intrinsics.rs:124:14: 124:45\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Never) -> Never {read_via_copy::<Never>}, val: Value(<ZST>) }\n +         unreachable;                     // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n       }"}, {"sha": "33fef930ad34b11c6d98d276d413b8be88579bc4", "filename": "tests/mir-opt/lower_intrinsics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e85ecbbcdcc577d47baae3c0c537c82056340ac9/tests%2Fmir-opt%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ecbbcdcc577d47baae3c0c537c82056340ac9/tests%2Fmir-opt%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.rs?ref=e85ecbbcdcc577d47baae3c0c537c82056340ac9", "patch": "@@ -1,7 +1,7 @@\n // unit-test: LowerIntrinsics\n // ignore-wasm32 compiled with panic=abort by default\n \n-#![feature(core_intrinsics, intrinsics)]\n+#![feature(core_intrinsics, intrinsics, rustc_attrs)]\n #![crate_type = \"lib\"]\n \n // EMIT_MIR lower_intrinsics.wrapping.LowerIntrinsics.diff\n@@ -87,6 +87,7 @@ pub fn discriminant<T>(t: T) {\n \n extern \"rust-intrinsic\" {\n     // Cannot use `std::intrinsics::copy_nonoverlapping` as that is a wrapper function\n+    #[rustc_nounwind]\n     fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n }\n "}, {"sha": "9cf4fbb88f3899a84cf319e137b224de3a472ca4", "filename": "tests/mir-opt/lower_intrinsics.with_overflow.LowerIntrinsics.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e85ecbbcdcc577d47baae3c0c537c82056340ac9/tests%2Fmir-opt%2Flower_intrinsics.with_overflow.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e85ecbbcdcc577d47baae3c0c537c82056340ac9/tests%2Fmir-opt%2Flower_intrinsics.with_overflow.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.with_overflow.LowerIntrinsics.diff?ref=e85ecbbcdcc577d47baae3c0c537c82056340ac9", "patch": "@@ -32,7 +32,7 @@\n           _5 = _2;                         // scope 0 at $DIR/lower_intrinsics.rs:+1:53: +1:54\n -         _3 = add_with_overflow::<i32>(move _4, move _5) -> [return: bb1, unwind unreachable]; // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:55\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:111:14: 111:49\n+-                                          // + span: $DIR/lower_intrinsics.rs:112:14: 112:49\n -                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> (i32, bool) {add_with_overflow::<i32>}, val: Value(<ZST>) }\n +         _3 = CheckedAdd(move _4, move _5); // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:55\n +         goto -> bb1;                     // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:55\n@@ -48,7 +48,7 @@\n           _8 = _2;                         // scope 1 at $DIR/lower_intrinsics.rs:+2:53: +2:54\n -         _6 = sub_with_overflow::<i32>(move _7, move _8) -> [return: bb2, unwind unreachable]; // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:55\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:112:14: 112:49\n+-                                          // + span: $DIR/lower_intrinsics.rs:113:14: 113:49\n -                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> (i32, bool) {sub_with_overflow::<i32>}, val: Value(<ZST>) }\n +         _6 = CheckedSub(move _7, move _8); // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:55\n +         goto -> bb2;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:55\n@@ -64,7 +64,7 @@\n           _11 = _2;                        // scope 2 at $DIR/lower_intrinsics.rs:+3:53: +3:54\n -         _9 = mul_with_overflow::<i32>(move _10, move _11) -> [return: bb3, unwind unreachable]; // scope 2 at $DIR/lower_intrinsics.rs:+3:14: +3:55\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:113:14: 113:49\n+-                                          // + span: $DIR/lower_intrinsics.rs:114:14: 114:49\n -                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> (i32, bool) {mul_with_overflow::<i32>}, val: Value(<ZST>) }\n +         _9 = CheckedMul(move _10, move _11); // scope 2 at $DIR/lower_intrinsics.rs:+3:14: +3:55\n +         goto -> bb3;                     // scope 2 at $DIR/lower_intrinsics.rs:+3:14: +3:55"}]}