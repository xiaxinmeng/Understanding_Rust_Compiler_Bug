{"sha": "98740a59da4f73617351098c118d707134e561a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NzQwYTU5ZGE0ZjczNjE3MzUxMDk4YzExOGQ3MDcxMzRlNTYxYTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-25T15:42:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-26T00:04:05Z"}, "message": "detect ambig. calls to iface bounds, use transactions\n\ncc #2433", "tree": {"sha": "76c8556b15f12d4f6cd0e801f0433b857cf58535", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76c8556b15f12d4f6cd0e801f0433b857cf58535"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98740a59da4f73617351098c118d707134e561a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98740a59da4f73617351098c118d707134e561a8", "html_url": "https://github.com/rust-lang/rust/commit/98740a59da4f73617351098c118d707134e561a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98740a59da4f73617351098c118d707134e561a8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93633ea7343d74c6447ed814c7435e9b1a3ff67a", "url": "https://api.github.com/repos/rust-lang/rust/commits/93633ea7343d74c6447ed814c7435e9b1a3ff67a", "html_url": "https://github.com/rust-lang/rust/commit/93633ea7343d74c6447ed814c7435e9b1a3ff67a"}], "stats": {"total": 120, "additions": 96, "deletions": 24}, "files": [{"sha": "7da1f27d3daf5cc019130176374ac3af215f6e4f", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98740a59da4f73617351098c118d707134e561a8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98740a59da4f73617351098c118d707134e561a8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=98740a59da4f73617351098c118d707134e561a8", "patch": "@@ -527,6 +527,10 @@ impl methods for @fn_ctxt {\n         infer::mk_subty(self.infcx, sub, sup)\n     }\n \n+    fn can_mk_subty(sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n+        infer::can_mk_subty(self.infcx, sub, sup)\n+    }\n+\n     fn mk_eqty(sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n         infer::mk_eqty(self.infcx, sub, sup)\n     }"}, {"sha": "af27d8d8da19a4bf6b7f106956743ad53b746809", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/98740a59da4f73617351098c118d707134e561a8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98740a59da4f73617351098c118d707134e561a8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=98740a59da4f73617351098c118d707134e561a8", "patch": "@@ -45,6 +45,7 @@ impl methods for lookup {\n         let tcx = self.tcx();\n         let mut iface_bnd_idx = 0u; // count only iface bounds\n         let bounds = tcx.ty_param_bounds.get(did.node);\n+        let mut candidates = [];\n         for vec::each(*bounds) {|bound|\n             let (iid, bound_substs) = alt bound {\n               ty::bound_copy | ty::bound_send | ty::bound_const {\n@@ -74,14 +75,33 @@ impl methods for lookup {\n                 // permitted).\n                 let substs = {self_ty: some(self.self_ty)\n                               with bound_substs};\n-\n-                ret some(self.write_mty_from_m(\n-                    substs, ifce_methods[pos],\n-                    method_param(iid, pos, n, iface_bnd_idx)));\n+                candidates += [(substs, ifce_methods[pos],\n+                                iid, pos, n, iface_bnd_idx)];\n               }\n             }\n         }\n-        ret none;\n+\n+        if candidates.len() == 0u {\n+            ret none;\n+        }\n+\n+        if candidates.len() > 1u {\n+            self.tcx().sess.span_err(\n+                self.expr.span,\n+                \"multiple applicable methods in scope\");\n+\n+            for candidates.eachi { |i, candidate|\n+                let (_, _, iid, _, _, _) = candidate;\n+                self.tcx().sess.span_note(\n+                    self.expr.span,\n+                    #fmt[\"candidate #%u derives from the bound `%s`\",\n+                         (i+1u), ty::item_path_str(self.tcx(), iid)]);\n+            }\n+        }\n+\n+        let (substs, mty, iid, pos, n, iface_bnd_idx) = candidates[0u];\n+        ret some(self.write_mty_from_m(\n+            substs, mty, method_param(iid, pos, n, iface_bnd_idx)));\n     }\n \n     fn method_from_iface(\n@@ -197,10 +217,11 @@ impl methods for lookup {\n \n                     // if we can assign the caller to the callee, that's a\n                     // potential match.  Collect those in the vector.\n-                    alt self.fcx.mk_subty(ty, self_ty) {\n+                    alt self.fcx.can_mk_subty(ty, self_ty) {\n                       result::err(_) { /* keep looking */ }\n                       result::ok(_) {\n-                        results += [(self_substs, m.n_tps, m.did)];\n+                        results += [(ty, self_ty, self_substs,\n+                                     m.n_tps, m.did)];\n                       }\n                     }\n                 }\n@@ -216,7 +237,7 @@ impl methods for lookup {\n                     // but I cannot for the life of me figure out how to\n                     // annotate resolve to preserve this information.\n                     for results.eachi { |i, result|\n-                        let (_, _, did) = result;\n+                        let (_, _, _, _, did) = result;\n                         let span = if did.crate == ast::local_crate {\n                             alt check self.tcx().items.get(did.node) {\n                               ast_map::node_method(m, _, _) { m.span }\n@@ -226,13 +247,21 @@ impl methods for lookup {\n                         };\n                         self.tcx().sess.span_note(\n                             span,\n-                            #fmt[\"candidate #%u is %s\",\n+                            #fmt[\"candidate #%u is `%s`\",\n                                  (i+1u),\n                                  ty::item_path_str(self.tcx(), did)]);\n                     }\n                 }\n \n-                let (self_substs, n_tps, did) = results[0];\n+                let (ty, self_ty, self_substs, n_tps, did) = results[0];\n+                alt self.fcx.mk_subty(ty, self_ty) {\n+                  result::ok(_) {}\n+                  result::err(_) {\n+                    self.tcx().sess.span_bug(\n+                        self.expr.span,\n+                        \"what was a subtype now is not?\");\n+                  }\n+                }\n                 let fty = self.ty_from_did(did);\n                 ret some(self.write_mty_from_fty(\n                     self_substs, n_tps, fty,"}, {"sha": "d13123496b1a5e8136f59d37fcabecbcd4bdfc8e", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/98740a59da4f73617351098c118d707134e561a8/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98740a59da4f73617351098c118d707134e561a8/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=98740a59da4f73617351098c118d707134e561a8", "patch": "@@ -160,7 +160,7 @@ import util::common::{indent, indenter};\n \n export infer_ctxt;\n export new_infer_ctxt;\n-export mk_subty;\n+export mk_subty, can_mk_subty;\n export mk_subr;\n export mk_eqty;\n export mk_assignty;\n@@ -235,6 +235,11 @@ fn mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     indent {|| cx.commit {|| sub(cx).tys(a, b) } }.to_ures()\n }\n \n+fn can_mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n+    #debug[\"can_mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n+    indent {|| cx.probe {|| sub(cx).tys(a, b) } }.to_ures()\n+}\n+\n fn mk_subr(cx: infer_ctxt, a: ty::region, b: ty::region) -> ures {\n     #debug[\"mk_subr(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n     indent {|| cx.commit {|| sub(cx).regions(a, b) } }.to_ures()\n@@ -388,7 +393,17 @@ fn uok() -> ures {\n     ok(())\n }\n \n+fn rollback_to<V:copy vid, T:copy>(\n+    vb: vals_and_bindings<V, T>, len: uint) {\n+\n+    while vb.bindings.len() != len {\n+        let (vid, old_v) = vec::pop(vb.bindings);\n+        vb.vals.insert(vid.to_uint(), old_v);\n+    }\n+}\n+\n impl transaction_methods for infer_ctxt {\n+    #[doc = \"Execute `f` and commit the bindings if successful\"]\n     fn commit<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n \n         assert self.vb.bindings.len() == 0u;\n@@ -404,17 +419,9 @@ impl transaction_methods for infer_ctxt {\n         ret r;\n     }\n \n+    #[doc = \"Execute `f`, unroll bindings on failure\"]\n     fn try<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n \n-        fn rollback_to<V:copy vid, T:copy>(\n-            vb: vals_and_bindings<V, T>, len: uint) {\n-\n-            while vb.bindings.len() != len {\n-                let (vid, old_v) = vec::pop(vb.bindings);\n-                vb.vals.insert(vid.to_uint(), old_v);\n-            }\n-        }\n-\n         let vbl = self.vb.bindings.len();\n         let rbl = self.rb.bindings.len();\n         #debug[\"try(vbl=%u, rbl=%u)\", vbl, rbl];\n@@ -429,6 +436,16 @@ impl transaction_methods for infer_ctxt {\n         }\n         ret r;\n     }\n+\n+    #[doc = \"Execute `f` then unroll any bindings it creates\"]\n+    fn probe<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n+        assert self.vb.bindings.len() == 0u;\n+        assert self.rb.bindings.len() == 0u;\n+        let r <- f();\n+        rollback_to(self.vb, 0u);\n+        rollback_to(self.rb, 0u);\n+        ret r;\n+    }\n }\n \n impl methods for infer_ctxt {"}, {"sha": "0eed1c8f89fb7e2842fa5615459c3d4197b2c13e", "filename": "src/test/compile-fail/ambig_impl_1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98740a59da4f73617351098c118d707134e561a8/src%2Ftest%2Fcompile-fail%2Fambig_impl_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98740a59da4f73617351098c118d707134e561a8/src%2Ftest%2Fcompile-fail%2Fambig_impl_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_1.rs?ref=98740a59da4f73617351098c118d707134e561a8", "patch": "@@ -1,3 +1,3 @@\n-impl methods1 for uint { fn me() -> uint { self } } //! NOTE candidate #1 is methods1::me\n-impl methods2 for uint { fn me() -> uint { self } } //! NOTE candidate #2 is methods2::me\n+impl methods1 for uint { fn me() -> uint { self } } //! NOTE candidate #1 is `methods1::me`\n+impl methods2 for uint { fn me() -> uint { self } } //! NOTE candidate #2 is `methods2::me`\n fn main() { 1u.me(); } //! ERROR multiple applicable methods in scope"}, {"sha": "5bd20db144f5e5fbe632be0fee7dc63729d7c460", "filename": "src/test/compile-fail/ambig_impl_2_exe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98740a59da4f73617351098c118d707134e561a8/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98740a59da4f73617351098c118d707134e561a8/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs?ref=98740a59da4f73617351098c118d707134e561a8", "patch": "@@ -2,6 +2,6 @@\n // aux-build:ambig_impl_2_lib.rs\n use ambig_impl_2_lib;\n import ambig_impl_2_lib::methods1;\n-impl methods2 for uint { fn me() -> uint { self } } //! NOTE candidate #2 is methods2::me\n+impl methods2 for uint { fn me() -> uint { self } } //! NOTE candidate #2 is `methods2::me`\n fn main() { 1u.me(); } //! ERROR multiple applicable methods in scope\n-//!^ NOTE candidate #1 is ambig_impl_2_lib::methods1::me\n+//!^ NOTE candidate #1 is `ambig_impl_2_lib::methods1::me`"}, {"sha": "d14e57a21f4108515cacb69db69860d34e197662", "filename": "src/test/compile-fail/ambig_impl_bounds.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98740a59da4f73617351098c118d707134e561a8/src%2Ftest%2Fcompile-fail%2Fambig_impl_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98740a59da4f73617351098c118d707134e561a8/src%2Ftest%2Fcompile-fail%2Fambig_impl_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_bounds.rs?ref=98740a59da4f73617351098c118d707134e561a8", "patch": "@@ -0,0 +1,10 @@\n+iface A { fn foo(); }\n+iface B { fn foo(); }\n+\n+fn foo<T: A B>(t: T) {\n+    t.foo(); //! ERROR multiple applicable methods in scope\n+    //!^ NOTE candidate #1 derives from the bound `A`\n+    //!^^ NOTE candidate #2 derives from the bound `B`\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "2f020742d5404392860554530ff7b1eddb3ae409", "filename": "src/test/compile-fail/ambig_impl_unify.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98740a59da4f73617351098c118d707134e561a8/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98740a59da4f73617351098c118d707134e561a8/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs?ref=98740a59da4f73617351098c118d707134e561a8", "patch": "@@ -0,0 +1,12 @@\n+impl methods for [uint] {\n+    fn foo() -> int {1} //! NOTE candidate #1 is `methods::foo`\n+}\n+\n+impl methods for [int] {\n+    fn foo() -> int {2} //! NOTE candidate #2 is `methods::foo`\n+}\n+\n+fn main() {\n+    let x = [];\n+    x.foo(); //! ERROR multiple applicable methods in scope\n+}\n\\ No newline at end of file"}]}