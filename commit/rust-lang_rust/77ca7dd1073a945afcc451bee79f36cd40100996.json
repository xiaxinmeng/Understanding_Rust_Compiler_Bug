{"sha": "77ca7dd1073a945afcc451bee79f36cd40100996", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3Y2E3ZGQxMDczYTk0NWFmY2M0NTFiZWU3OWYzNmNkNDAxMDA5OTY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-08-03T01:56:18Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-08-16T22:30:39Z"}, "message": "rustdoc: redirects from sane, namespaced URLs to Rustdoc's ridiculous ones\n\ncc #35020 which does this properly", "tree": {"sha": "85ab47f1fcf2c267d04b07516d9e7f826d99a1af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85ab47f1fcf2c267d04b07516d9e7f826d99a1af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77ca7dd1073a945afcc451bee79f36cd40100996", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77ca7dd1073a945afcc451bee79f36cd40100996", "html_url": "https://github.com/rust-lang/rust/commit/77ca7dd1073a945afcc451bee79f36cd40100996", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77ca7dd1073a945afcc451bee79f36cd40100996/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a41454bf651a8629ec4b08365eae65b095504cab", "url": "https://api.github.com/repos/rust-lang/rust/commits/a41454bf651a8629ec4b08365eae65b095504cab", "html_url": "https://github.com/rust-lang/rust/commit/a41454bf651a8629ec4b08365eae65b095504cab"}], "stats": {"total": 65, "additions": 48, "deletions": 17}, "files": [{"sha": "6b462a76f04ed4a7dc03a31622b1ea02cf0d68eb", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/77ca7dd1073a945afcc451bee79f36cd40100996/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ca7dd1073a945afcc451bee79f36cd40100996/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=77ca7dd1073a945afcc451bee79f36cd40100996", "patch": "@@ -168,3 +168,9 @@ impl NameSpace {\n         }\n     }\n }\n+\n+impl fmt::Display for NameSpace {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.to_static_str().fmt(f)\n+    }\n+}"}, {"sha": "51068d5648e4dd21067b22f7e2d8de6c15cdf498", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 42, "deletions": 17, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/77ca7dd1073a945afcc451bee79f36cd40100996/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ca7dd1073a945afcc451bee79f36cd40100996/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=77ca7dd1073a945afcc451bee79f36cd40100996", "patch": "@@ -41,7 +41,7 @@ use std::collections::{BTreeMap, HashMap, HashSet};\n use std::default::Default;\n use std::error;\n use std::fmt::{self, Display, Formatter};\n-use std::fs::{self, File};\n+use std::fs::{self, File, OpenOptions};\n use std::io::prelude::*;\n use std::io::{self, BufWriter, BufReader};\n use std::iter::repeat;\n@@ -1409,11 +1409,23 @@ impl Context {\n             self.render_item(&mut buf, &item, true).unwrap();\n             // buf will be empty if the item is stripped and there is no redirect for it\n             if !buf.is_empty() {\n-                let joint_dst = self.dst.join(&item_path(item_type(&item),\n-                                                         item.name.as_ref().unwrap()));\n+                let name = item.name.as_ref().unwrap();\n+                let item_type = item_type(&item);\n+                let file_name = &item_path(item_type, name);\n+                let joint_dst = self.dst.join(file_name);\n                 try_err!(fs::create_dir_all(&self.dst), &self.dst);\n                 let mut dst = try_err!(File::create(&joint_dst), &joint_dst);\n                 try_err!(dst.write_all(&buf), &joint_dst);\n+\n+                // Redirect from a sane URL using the namespace to Rustdoc's\n+                // URL for the page.\n+                let redir_name = format!(\"{}.{}.html\", name, item_type.name_space());\n+                let redir_dst = self.dst.join(redir_name);\n+                if let Ok(mut redirect_out) = OpenOptions::new().create_new(true)\n+                                                                .write(true)\n+                                                                .open(&redir_dst) {\n+                    try_err!(layout::redirect(&mut redirect_out, file_name), &redir_dst);\n+                }\n             }\n         }\n         Ok(())\n@@ -2270,9 +2282,12 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         if fields.peek().is_some() {\n             write!(w, \"<h2 class='fields'>Fields</h2>\")?;\n             for (field, ty) in fields {\n-                write!(w, \"<span id='{item_type}.{name}' class='{item_type}'><code>{name}: {ty}</code>\n-                           </span><span class='stab {stab}'></span>\",\n+                write!(w, \"<span id='{item_type}.{name}' class='{item_type}'>\n+                           <a id='{name}.{name_space}'>\n+                           <code>{name}: {ty}</code>\n+                           </a></span><span class='stab {stab}'></span>\",\n                        item_type = ItemType::StructField,\n+                       name_space = ItemType::StructField.name_space(),\n                        stab = field.stability_class(),\n                        name = field.name.as_ref().unwrap(),\n                        ty = ty)?;\n@@ -2341,8 +2356,10 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     if !e.variants.is_empty() {\n         write!(w, \"<h2 class='variants'>Variants</h2>\\n\")?;\n         for variant in &e.variants {\n-            write!(w, \"<span id='{item_type}.{name}' class='variant'><code>{name}\",\n+            write!(w, \"<span id='{item_type}.{name}' class='variant'>\\\n+                       <a id='{name}.{name_space}'><code>{name}\",\n                    item_type = ItemType::Variant,\n+                   name_space = ItemType::Variant.name_space(),\n                    name = variant.name.as_ref().unwrap())?;\n             if let clean::VariantItem(ref var) = variant.inner {\n                 if let clean::TupleVariant(ref tys) = var.kind {\n@@ -2356,7 +2373,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                     write!(w, \")\")?;\n                 }\n             }\n-            write!(w, \"</code></span>\")?;\n+            write!(w, \"</code></a></span>\")?;\n             document(w, cx, variant)?;\n \n             use clean::{Variant, StructVariant};\n@@ -2368,9 +2385,12 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                     if let StructFieldItem(ref ty) = field.inner {\n                         write!(w, \"<tr><td \\\n                                    id='variant.{v}.field.{f}'>\\\n-                                   <code>{f}:&nbsp;{t}</code></td><td>\",\n+                                   <a id='{v}.{vns}.{f}.{fns}'>\\\n+                                   <code>{f}:&nbsp;{t}</code></a></td><td>\",\n                                v = variant.name.as_ref().unwrap(),\n                                f = field.name.as_ref().unwrap(),\n+                               vns = ItemType::Variant.name_space(),\n+                               fns = ItemType::StructField.name_space(),\n                                t = *ty)?;\n                         document(w, cx, field)?;\n                         write!(w, \"</td></tr>\")?;\n@@ -2605,36 +2625,41 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                 if !is_static || render_static {\n                     let id = derive_id(format!(\"{}.{}\", item_type, name));\n                     write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                    write!(w, \"<a id='{}.{}'>\", name, item_type.name_space())?;\n                     write!(w, \"<code>\")?;\n                     render_assoc_item(w, item, link.anchor(&id))?;\n                     write!(w, \"</code>\")?;\n                     render_stability_since_raw(w, item.stable_since(), outer_version)?;\n-                    write!(w, \"</h4>\\n\")?;\n+                    write!(w, \"</a></h4>\\n\")?;\n                 }\n             }\n             clean::TypedefItem(ref tydef, _) => {\n                 let id = derive_id(format!(\"{}.{}\", ItemType::AssociatedType, name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, item_type)?;\n+                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<a id='{}.{}'><code>\", name, item_type.name_space())?;\n                 assoc_type(w, item, &Vec::new(), Some(&tydef.type_), link.anchor(&id))?;\n-                write!(w, \"</code></h4>\\n\")?;\n+                write!(w, \"</code></a></h4>\\n\")?;\n             }\n             clean::AssociatedConstItem(ref ty, ref default) => {\n                 let id = derive_id(format!(\"{}.{}\", item_type, name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, item_type)?;\n+                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<a id='{}.{}'><code>\", name, item_type.name_space())?;\n                 assoc_const(w, item, ty, default.as_ref(), link.anchor(&id))?;\n-                write!(w, \"</code></h4>\\n\")?;\n+                write!(w, \"</code></a></h4>\\n\")?;\n             }\n             clean::ConstantItem(ref c) => {\n                 let id = derive_id(format!(\"{}.{}\", item_type, name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, item_type)?;\n+                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<a id='{}.{}'><code>\", name, item_type.name_space())?;\n                 assoc_const(w, item, &c.type_, Some(&c.expr), link.anchor(&id))?;\n-                write!(w, \"</code></h4>\\n\")?;\n+                write!(w, \"</code></a></h4>\\n\")?;\n             }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n                 let id = derive_id(format!(\"{}.{}\", item_type, name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, item_type)?;\n+                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<a id='{}.{}'><code>\", name, item_type.name_space())?;\n                 assoc_type(w, item, bounds, default.as_ref(), link.anchor(&id))?;\n-                write!(w, \"</code></h4>\\n\")?;\n+                write!(w, \"</code></a></h4>\\n\")?;\n             }\n             clean::StrippedItem(..) => return Ok(()),\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)"}]}