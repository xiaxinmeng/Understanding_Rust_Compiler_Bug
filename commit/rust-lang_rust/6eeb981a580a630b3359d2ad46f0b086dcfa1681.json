{"sha": "6eeb981a580a630b3359d2ad46f0b086dcfa1681", "node_id": "C_kwDOAAsO6NoAKDZlZWI5ODFhNTgwYTYzMGIzMzU5ZDJhZDQ2ZjBiMDg2ZGNmYTE2ODE", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2023-01-31T02:46:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-31T02:46:22Z"}, "message": "Rollup merge of #107245 - compiler-errors:new-solver-unsizing, r=lcnr\n\nImplement unsizing in the new trait solver\n\nThis makes hello world compile! Ignore the first commit, that's just #107146 which is waiting on merge.\n\nI'll leave some comments inline about design choices that might be debatable.\n\nr? `@lcnr` (until we have a new trait solver reviewer group...)", "tree": {"sha": "6492b62b58e3d6d993014426618453b7573ce862", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6492b62b58e3d6d993014426618453b7573ce862"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6eeb981a580a630b3359d2ad46f0b086dcfa1681", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj2ID+CRBK7hj4Ov3rIwAAwd4IAIK/wihUJCHhhQ4xO0w+fZ+u\nDvAG9I98W2wYVWLBMvqBupZsMEo/qg4zJguYzunX0zDN2roVc20O0h/Am4fyRN+J\nkPT8le4hze8W1uPdCEkRBToVDuMddUdaERPZpDCf18/ZECMoLnsb05oUuFnJZNoe\nZOFtGGrR92jyME/k5MdeyIMfUzs0wl5qaec0Vo8sZs1C0sqGpiFOJRWbfIgi4nQr\nFHzoI+ZryN8JLgroqDludd/PhiY3YWS3bMjAMNA+h9JRqdpA2CEXfil63mTyBR0j\nqs3RVJvw+mQCNkiWiA7Wzxo2QE395XSlGpA5VbXiQwlXmixSpRHd+ySA1+xdD+8=\n=UuPl\n-----END PGP SIGNATURE-----\n", "payload": "tree 6492b62b58e3d6d993014426618453b7573ce862\nparent 487e83b711b96d84ce2edfc4cb4ba792c10b589e\nparent f7fc0b712103d8832b305efa72e4c9851161bbdf\nauthor Yuki Okushi <jtitor@2k36.org> 1675133182 +0900\ncommitter GitHub <noreply@github.com> 1675133182 +0900\n\nRollup merge of #107245 - compiler-errors:new-solver-unsizing, r=lcnr\n\nImplement unsizing in the new trait solver\n\nThis makes hello world compile! Ignore the first commit, that's just #107146 which is waiting on merge.\n\nI'll leave some comments inline about design choices that might be debatable.\n\nr? `@lcnr` (until we have a new trait solver reviewer group...)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6eeb981a580a630b3359d2ad46f0b086dcfa1681", "html_url": "https://github.com/rust-lang/rust/commit/6eeb981a580a630b3359d2ad46f0b086dcfa1681", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6eeb981a580a630b3359d2ad46f0b086dcfa1681/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "487e83b711b96d84ce2edfc4cb4ba792c10b589e", "url": "https://api.github.com/repos/rust-lang/rust/commits/487e83b711b96d84ce2edfc4cb4ba792c10b589e", "html_url": "https://github.com/rust-lang/rust/commit/487e83b711b96d84ce2edfc4cb4ba792c10b589e"}, {"sha": "f7fc0b712103d8832b305efa72e4c9851161bbdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7fc0b712103d8832b305efa72e4c9851161bbdf", "html_url": "https://github.com/rust-lang/rust/commit/f7fc0b712103d8832b305efa72e4c9851161bbdf"}], "stats": {"total": 312, "additions": 307, "deletions": 5}, "files": [{"sha": "5690b6536bbc0b9e8ce7a96414999fed495a5a40", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb981a580a630b3359d2ad46f0b086dcfa1681/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb981a580a630b3359d2ad46f0b086dcfa1681/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=6eeb981a580a630b3359d2ad46f0b086dcfa1681", "patch": "@@ -173,6 +173,21 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n+\n+    // The most common forms of unsizing are array to slice, and concrete (Sized)\n+    // type into a `dyn Trait`. ADTs and Tuples can also have their final field\n+    // unsized if it's generic.\n+    fn consider_builtin_unsize_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n+\n+    // `dyn Trait1` can be unsized to `dyn Trait2` if they are the same trait, or\n+    // if `Trait2` is a (transitive) supertrait of `Trait2`.\n+    fn consider_builtin_dyn_upcast_candidates(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> Vec<CanonicalResponse<'tcx>>;\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n@@ -303,6 +318,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             G::consider_builtin_future_candidate(self, goal)\n         } else if lang_items.gen_trait() == Some(trait_def_id) {\n             G::consider_builtin_generator_candidate(self, goal)\n+        } else if lang_items.unsize_trait() == Some(trait_def_id) {\n+            G::consider_builtin_unsize_candidate(self, goal)\n         } else {\n             Err(NoSolution)\n         };\n@@ -313,6 +330,14 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             }\n             Err(NoSolution) => (),\n         }\n+\n+        // There may be multiple unsize candidates for a trait with several supertraits:\n+        // `trait Foo: Bar<A> + Bar<B>` and `dyn Foo: Unsize<dyn Bar<_>>`\n+        if lang_items.unsize_trait() == Some(trait_def_id) {\n+            for result in G::consider_builtin_dyn_upcast_candidates(self, goal) {\n+                candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result });\n+            }\n+        }\n     }\n \n     fn assemble_param_env_candidates<G: GoalKind<'tcx>>("}, {"sha": "879f18843c9171def566dea30e95cf45e33d6d4c", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb981a580a630b3359d2ad46f0b086dcfa1681/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb981a580a630b3359d2ad46f0b086dcfa1681/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=6eeb981a580a630b3359d2ad46f0b086dcfa1681", "patch": "@@ -554,6 +554,20 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             .to_predicate(tcx),\n         )\n     }\n+\n+    fn consider_builtin_unsize_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"`Unsize` does not have an associated type: {:?}\", goal);\n+    }\n+\n+    fn consider_builtin_dyn_upcast_candidates(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> Vec<super::CanonicalResponse<'tcx>> {\n+        bug!(\"`Unsize` does not have an associated type: {:?}\", goal);\n+    }\n }\n \n /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code."}, {"sha": "29ee9da38e08be5b391709294baac16b1630236b", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 202, "deletions": 1, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb981a580a630b3359d2ad46f0b086dcfa1681/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb981a580a630b3359d2ad46f0b086dcfa1681/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=6eeb981a580a630b3359d2ad46f0b086dcfa1681", "patch": "@@ -4,10 +4,11 @@ use std::iter;\n \n use super::assembly::{self, Candidate, CandidateSource};\n use super::infcx_ext::InferCtxtExt;\n-use super::{Certainty, EvalCtxt, Goal, QueryResult};\n+use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n use rustc_middle::ty::{TraitPredicate, TypeVisitable};\n@@ -238,6 +239,206 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             .to_predicate(tcx),\n         )\n     }\n+\n+    fn consider_builtin_unsize_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        let tcx = ecx.tcx();\n+        let a_ty = goal.predicate.self_ty();\n+        let b_ty = goal.predicate.trait_ref.substs.type_at(1);\n+        if b_ty.is_ty_var() {\n+            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n+        }\n+        ecx.infcx.probe(|_| {\n+            match (a_ty.kind(), b_ty.kind()) {\n+                // Trait upcasting, or `dyn Trait + Auto + 'a` -> `dyn Trait + 'b`\n+                (&ty::Dynamic(_, _, ty::Dyn), &ty::Dynamic(_, _, ty::Dyn)) => {\n+                    // Dyn upcasting is handled separately, since due to upcasting,\n+                    // when there are two supertraits that differ by substs, we\n+                    // may return more than one query response.\n+                    return Err(NoSolution);\n+                }\n+                // `T` -> `dyn Trait` unsizing\n+                (_, &ty::Dynamic(data, region, ty::Dyn)) => {\n+                    // Can only unsize to an object-safe type\n+                    if data\n+                        .principal_def_id()\n+                        .map_or(false, |def_id| !tcx.check_is_object_safe(def_id))\n+                    {\n+                        return Err(NoSolution);\n+                    }\n+\n+                    let Some(sized_def_id) = tcx.lang_items().sized_trait() else {\n+                        return Err(NoSolution);\n+                    };\n+                    let nested_goals: Vec<_> = data\n+                        .iter()\n+                        // Check that the type implements all of the predicates of the def-id.\n+                        // (i.e. the principal, all of the associated types match, and any auto traits)\n+                        .map(|pred| goal.with(tcx, pred.with_self_ty(tcx, a_ty)))\n+                        .chain([\n+                            // The type must be Sized to be unsized.\n+                            goal.with(\n+                                tcx,\n+                                ty::Binder::dummy(tcx.mk_trait_ref(sized_def_id, [a_ty])),\n+                            ),\n+                            // The type must outlive the lifetime of the `dyn` we're unsizing into.\n+                            goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_ty, region))),\n+                        ])\n+                        .collect();\n+\n+                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                }\n+                // `[T; n]` -> `[T]` unsizing\n+                (&ty::Array(a_elem_ty, ..), &ty::Slice(b_elem_ty)) => {\n+                    // We just require that the element type stays the same\n+                    let nested_goals = ecx.infcx.eq(goal.param_env, a_elem_ty, b_elem_ty)?;\n+                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                }\n+                // Struct unsizing `Struct<T>` -> `Struct<U>` where `T: Unsize<U>`\n+                (&ty::Adt(a_def, a_substs), &ty::Adt(b_def, b_substs))\n+                    if a_def.is_struct() && a_def.did() == b_def.did() =>\n+                {\n+                    let unsizing_params = tcx.unsizing_params_for_adt(a_def.did());\n+                    // We must be unsizing some type parameters. This also implies\n+                    // that the struct has a tail field.\n+                    if unsizing_params.is_empty() {\n+                        return Err(NoSolution);\n+                    }\n+\n+                    let tail_field = a_def\n+                        .non_enum_variant()\n+                        .fields\n+                        .last()\n+                        .expect(\"expected unsized ADT to have a tail field\");\n+                    let tail_field_ty = tcx.bound_type_of(tail_field.did);\n+\n+                    let a_tail_ty = tail_field_ty.subst(tcx, a_substs);\n+                    let b_tail_ty = tail_field_ty.subst(tcx, b_substs);\n+\n+                    // Substitute just the unsizing params from B into A. The type after\n+                    // this substitution must be equal to B. This is so we don't unsize\n+                    // unrelated type parameters.\n+                    let new_a_substs = tcx.mk_substs(a_substs.iter().enumerate().map(|(i, a)| {\n+                        if unsizing_params.contains(i as u32) { b_substs[i] } else { a }\n+                    }));\n+                    let unsized_a_ty = tcx.mk_adt(a_def, new_a_substs);\n+\n+                    // Finally, we require that `TailA: Unsize<TailB>` for the tail field\n+                    // types.\n+                    let mut nested_goals = ecx.infcx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n+                    nested_goals.push(goal.with(\n+                        tcx,\n+                        ty::Binder::dummy(\n+                            tcx.mk_trait_ref(goal.predicate.def_id(), [a_tail_ty, b_tail_ty]),\n+                        ),\n+                    ));\n+\n+                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                }\n+                // Tuple unsizing `(.., T)` -> `(.., U)` where `T: Unsize<U>`\n+                (&ty::Tuple(a_tys), &ty::Tuple(b_tys))\n+                    if a_tys.len() == b_tys.len() && !a_tys.is_empty() =>\n+                {\n+                    let (a_last_ty, a_rest_tys) = a_tys.split_last().unwrap();\n+                    let b_last_ty = b_tys.last().unwrap();\n+\n+                    // Substitute just the tail field of B., and require that they're equal.\n+                    let unsized_a_ty = tcx.mk_tup(a_rest_tys.iter().chain([b_last_ty]));\n+                    let mut nested_goals = ecx.infcx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n+\n+                    // Similar to ADTs, require that the rest of the fields are equal.\n+                    nested_goals.push(goal.with(\n+                        tcx,\n+                        ty::Binder::dummy(\n+                            tcx.mk_trait_ref(goal.predicate.def_id(), [*a_last_ty, *b_last_ty]),\n+                        ),\n+                    ));\n+\n+                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                }\n+                _ => Err(NoSolution),\n+            }\n+        })\n+    }\n+\n+    fn consider_builtin_dyn_upcast_candidates(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> Vec<CanonicalResponse<'tcx>> {\n+        let tcx = ecx.tcx();\n+\n+        let a_ty = goal.predicate.self_ty();\n+        let b_ty = goal.predicate.trait_ref.substs.type_at(1);\n+        let ty::Dynamic(a_data, a_region, ty::Dyn) = *a_ty.kind() else {\n+            return vec![];\n+        };\n+        let ty::Dynamic(b_data, b_region, ty::Dyn) = *b_ty.kind() else {\n+            return vec![];\n+        };\n+\n+        // All of a's auto traits need to be in b's auto traits.\n+        let auto_traits_compatible =\n+            b_data.auto_traits().all(|b| a_data.auto_traits().any(|a| a == b));\n+        if !auto_traits_compatible {\n+            return vec![];\n+        }\n+\n+        let mut unsize_dyn_to_principal = |principal: Option<ty::PolyExistentialTraitRef<'tcx>>| {\n+            ecx.infcx.probe(|_| -> Result<_, NoSolution> {\n+                // Require that all of the trait predicates from A match B, except for\n+                // the auto traits. We do this by constructing a new A type with B's\n+                // auto traits, and equating these types.\n+                let new_a_data = principal\n+                    .into_iter()\n+                    .map(|trait_ref| trait_ref.map_bound(ty::ExistentialPredicate::Trait))\n+                    .chain(a_data.iter().filter(|a| {\n+                        matches!(a.skip_binder(), ty::ExistentialPredicate::Projection(_))\n+                    }))\n+                    .chain(\n+                        b_data\n+                            .auto_traits()\n+                            .map(ty::ExistentialPredicate::AutoTrait)\n+                            .map(ty::Binder::dummy),\n+                    );\n+                let new_a_data = tcx.mk_poly_existential_predicates(new_a_data);\n+                let new_a_ty = tcx.mk_dynamic(new_a_data, b_region, ty::Dyn);\n+\n+                // We also require that A's lifetime outlives B's lifetime.\n+                let mut nested_obligations = ecx.infcx.eq(goal.param_env, new_a_ty, b_ty)?;\n+                nested_obligations.push(\n+                    goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_region, b_region))),\n+                );\n+\n+                ecx.evaluate_all_and_make_canonical_response(nested_obligations)\n+            })\n+        };\n+\n+        let mut responses = vec![];\n+        // If the principal def ids match (or are both none), then we're not doing\n+        // trait upcasting. We're just removing auto traits (or shortening the lifetime).\n+        if a_data.principal_def_id() == b_data.principal_def_id() {\n+            if let Ok(response) = unsize_dyn_to_principal(a_data.principal()) {\n+                responses.push(response);\n+            }\n+        } else if let Some(a_principal) = a_data.principal()\n+            && let Some(b_principal) = b_data.principal()\n+        {\n+            for super_trait_ref in supertraits(tcx, a_principal.with_self_ty(tcx, a_ty)) {\n+                if super_trait_ref.def_id() != b_principal.def_id() {\n+                    continue;\n+                }\n+                let erased_trait_ref = super_trait_ref\n+                    .map_bound(|trait_ref| ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref));\n+                if let Ok(response) = unsize_dyn_to_principal(Some(erased_trait_ref)) {\n+                    responses.push(response);\n+                }\n+            }\n+        }\n+\n+        responses\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {"}, {"sha": "41e837e8b754e64608bb58321c5f28b287f56ac2", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb981a580a630b3359d2ad46f0b086dcfa1681/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb981a580a630b3359d2ad46f0b086dcfa1681/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=6eeb981a580a630b3359d2ad46f0b086dcfa1681", "patch": "@@ -426,10 +426,6 @@ fn unsizing_params_for_adt<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> BitSet<u32\n         },\n     };\n \n-    // FIXME(eddyb) cache this (including computing `unsizing_params`)\n-    // by putting it in a query; it would only need the `DefId` as it\n-    // looks at declared field types, not anything substituted.\n-\n     // The last field of the structure has to exist and contain type/const parameters.\n     let Some((tail_field, prefix_fields)) =\n         def.non_enum_variant().fields.split_last() else"}, {"sha": "87ed9cfd10ae456e734d9ce8c4d575d9415086bd", "filename": "tests/ui/traits/new-solver/unsize-good.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb981a580a630b3359d2ad46f0b086dcfa1681/tests%2Fui%2Ftraits%2Fnew-solver%2Funsize-good.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb981a580a630b3359d2ad46f0b086dcfa1681/tests%2Fui%2Ftraits%2Fnew-solver%2Funsize-good.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Funsize-good.rs?ref=6eeb981a580a630b3359d2ad46f0b086dcfa1681", "patch": "@@ -0,0 +1,25 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+#![feature(unsized_tuple_coercion)]\n+\n+trait Foo {}\n+\n+impl Foo for i32 {}\n+\n+fn main() {\n+    // Unsizing via struct\n+    let _: Box<dyn Foo> = Box::new(1i32);\n+\n+    // Slice unsizing\n+    let y = [1, 2, 3];\n+    let _: &[i32] = &y;\n+\n+    // Tuple unsizing\n+    let hi = (1i32,);\n+    let _: &(dyn Foo,) = &hi;\n+\n+    // Dropping auto traits\n+    let a: &(dyn Foo + Send) = &1;\n+    let _: &dyn Foo = a;\n+}"}, {"sha": "c19c82acf24ffd690b2cd9b23ccc8d29f2a7af49", "filename": "tests/ui/traits/new-solver/upcast-right-substs.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb981a580a630b3359d2ad46f0b086dcfa1681/tests%2Fui%2Ftraits%2Fnew-solver%2Fupcast-right-substs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb981a580a630b3359d2ad46f0b086dcfa1681/tests%2Fui%2Ftraits%2Fnew-solver%2Fupcast-right-substs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fupcast-right-substs.rs?ref=6eeb981a580a630b3359d2ad46f0b086dcfa1681", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+#![feature(trait_upcasting)]\n+\n+trait Foo: Bar<i32> + Bar<u32> {}\n+\n+trait Bar<T> {}\n+\n+fn main() {\n+    let x: &dyn Foo = todo!();\n+    let y: &dyn Bar<i32> = x;\n+    let z: &dyn Bar<u32> = x;\n+}"}, {"sha": "f2d04d932bbcbf9efb6b3f8aa6b4e5c4927673aa", "filename": "tests/ui/traits/new-solver/upcast-wrong-substs.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb981a580a630b3359d2ad46f0b086dcfa1681/tests%2Fui%2Ftraits%2Fnew-solver%2Fupcast-wrong-substs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb981a580a630b3359d2ad46f0b086dcfa1681/tests%2Fui%2Ftraits%2Fnew-solver%2Fupcast-wrong-substs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fupcast-wrong-substs.rs?ref=6eeb981a580a630b3359d2ad46f0b086dcfa1681", "patch": "@@ -0,0 +1,13 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+#![feature(trait_upcasting)]\n+\n+trait Foo: Bar<i32> + Bar<u32> {}\n+\n+trait Bar<T> {}\n+\n+fn main() {\n+    let x: &dyn Foo = todo!();\n+    let y: &dyn Bar<usize> = x;\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "8623f395f5978e8b71d29571f623a2203bc86870", "filename": "tests/ui/traits/new-solver/upcast-wrong-substs.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb981a580a630b3359d2ad46f0b086dcfa1681/tests%2Fui%2Ftraits%2Fnew-solver%2Fupcast-wrong-substs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb981a580a630b3359d2ad46f0b086dcfa1681/tests%2Fui%2Ftraits%2Fnew-solver%2Fupcast-wrong-substs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fupcast-wrong-substs.stderr?ref=6eeb981a580a630b3359d2ad46f0b086dcfa1681", "patch": "@@ -0,0 +1,14 @@\n+error[E0308]: mismatched types\n+  --> $DIR/upcast-wrong-substs.rs:11:30\n+   |\n+LL |     let y: &dyn Bar<usize> = x;\n+   |            ---------------   ^ expected trait `Bar`, found trait `Foo`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected reference `&dyn Bar<usize>`\n+              found reference `&dyn Foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}