{"sha": "510abef5da1427c542e7b37dcea805c7b022984c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxMGFiZWY1ZGExNDI3YzU0MmU3YjM3ZGNlYTgwNWM3YjAyMjk4NGM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-02T16:23:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-02T16:23:06Z"}, "message": "Merge #7130\n\n7130: Add extract_assignment assist r=Jesse-Bakker a=Jesse-Bakker\n\nAdd extract-assignment assist (#7006).\r\n\r\nAssist is for now only implemented on if/match-statements where the assigment is the last statement in every block,\r\nas for other cases, one would have to check whether the assignment has effects on the rest of the block and\r\nextract a temporary variable for it in the block.\r\n\r\n\n\nCo-authored-by: Jesse Bakker <github@jessebakker.com>", "tree": {"sha": "f049cbe7e0653b48bc6003bcb1afd86db4b72cf1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f049cbe7e0653b48bc6003bcb1afd86db4b72cf1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/510abef5da1427c542e7b37dcea805c7b022984c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf8J3qCRBK7hj4Ov3rIwAAdHIIAFKDSywrYVGSqyZcVomUgtbQ\nK8WZqU1ZpSXP9FLY2BeBs+9f1DtA2qrL3BkmlQkziuisXEhFvyBX5t0v5AJKrEQy\n4WtfQpXiLFIZZmzFOmN9WYRtUESyJIzASKu3L6MKB1mlBK+V5Pb9320Hfr0k26Tx\nLE1o+zbhOW/fgC6nokcwBYN4T1S5H9oEJH7ypw3TpaZIiZrK+yJKNZ8TTFSKF2p6\nimZlTzW73nw+SmsI2N1ernEpBTO5jkNyX6sH1UlWmyatvOduCz0e6KHjLKivEdyu\nuWQVY27rebomZ3GdxRSkUkEqo2GAaHLHAlEoKD2jZ24n18UWxSLHwBPzK975YFY=\n=44es\n-----END PGP SIGNATURE-----\n", "payload": "tree f049cbe7e0653b48bc6003bcb1afd86db4b72cf1\nparent 3b347eaa4eae6d15921bd618471576b48c81afef\nparent bfe6a8e71afc0d3bee47261f83647b28eca0aae6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1609604586 +0000\ncommitter GitHub <noreply@github.com> 1609604586 +0000\n\nMerge #7130\n\n7130: Add extract_assignment assist r=Jesse-Bakker a=Jesse-Bakker\n\nAdd extract-assignment assist (#7006).\r\n\r\nAssist is for now only implemented on if/match-statements where the assigment is the last statement in every block,\r\nas for other cases, one would have to check whether the assignment has effects on the rest of the block and\r\nextract a temporary variable for it in the block.\r\n\r\n\n\nCo-authored-by: Jesse Bakker <github@jessebakker.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/510abef5da1427c542e7b37dcea805c7b022984c", "html_url": "https://github.com/rust-lang/rust/commit/510abef5da1427c542e7b37dcea805c7b022984c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/510abef5da1427c542e7b37dcea805c7b022984c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b347eaa4eae6d15921bd618471576b48c81afef", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b347eaa4eae6d15921bd618471576b48c81afef", "html_url": "https://github.com/rust-lang/rust/commit/3b347eaa4eae6d15921bd618471576b48c81afef"}, {"sha": "bfe6a8e71afc0d3bee47261f83647b28eca0aae6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfe6a8e71afc0d3bee47261f83647b28eca0aae6", "html_url": "https://github.com/rust-lang/rust/commit/bfe6a8e71afc0d3bee47261f83647b28eca0aae6"}], "stats": {"total": 356, "additions": 356, "deletions": 0}, "files": [{"sha": "281cf5d24e225c4c838372792bf2b55ff38f84ff", "filename": "crates/assists/src/handlers/extract_assignment.rs", "status": "added", "additions": 325, "deletions": 0, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/510abef5da1427c542e7b37dcea805c7b022984c/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510abef5da1427c542e7b37dcea805c7b022984c/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_assignment.rs?ref=510abef5da1427c542e7b37dcea805c7b022984c", "patch": "@@ -0,0 +1,325 @@\n+use hir::AsName;\n+use syntax::{\n+    ast::{self, edit::AstNodeEdit, make},\n+    AstNode,\n+};\n+use test_utils::mark;\n+\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId, AssistKind,\n+};\n+\n+// Assist: extract_assignment\n+//\n+// Extracts variable assigment to outside an if or match statement.\n+//\n+// ```\n+// fn main() {\n+//     let mut foo = 6;\n+//\n+//     if true {\n+//         <|>foo = 5;\n+//     } else {\n+//         foo = 4;\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     let mut foo = 6;\n+//\n+//     foo = if true {\n+//         5\n+//     } else {\n+//         4\n+//     };\n+// }\n+// ```\n+pub(crate) fn extract_assigment(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let name = ctx.find_node_at_offset::<ast::NameRef>()?.as_name();\n+\n+    let (old_stmt, new_stmt) = if let Some(if_expr) = ctx.find_node_at_offset::<ast::IfExpr>() {\n+        (\n+            ast::Expr::cast(if_expr.syntax().to_owned())?,\n+            exprify_if(&if_expr, &name)?.indent(if_expr.indent_level()),\n+        )\n+    } else if let Some(match_expr) = ctx.find_node_at_offset::<ast::MatchExpr>() {\n+        (ast::Expr::cast(match_expr.syntax().to_owned())?, exprify_match(&match_expr, &name)?)\n+    } else {\n+        return None;\n+    };\n+\n+    let expr_stmt = make::expr_stmt(new_stmt);\n+\n+    acc.add(\n+        AssistId(\"extract_assignment\", AssistKind::RefactorExtract),\n+        \"Extract assignment\",\n+        old_stmt.syntax().text_range(),\n+        move |edit| {\n+            edit.replace(old_stmt.syntax().text_range(), format!(\"{} = {};\", name, expr_stmt));\n+        },\n+    )\n+}\n+\n+fn exprify_match(match_expr: &ast::MatchExpr, name: &hir::Name) -> Option<ast::Expr> {\n+    let new_arm_list = match_expr\n+        .match_arm_list()?\n+        .arms()\n+        .map(|arm| {\n+            if let ast::Expr::BlockExpr(block) = arm.expr()? {\n+                let new_block = exprify_block(&block, name)?.indent(block.indent_level());\n+                Some(arm.replace_descendant(block, new_block))\n+            } else {\n+                None\n+            }\n+        })\n+        .collect::<Option<Vec<_>>>()?;\n+    let new_arm_list = match_expr\n+        .match_arm_list()?\n+        .replace_descendants(match_expr.match_arm_list()?.arms().zip(new_arm_list));\n+    Some(make::expr_match(match_expr.expr()?, new_arm_list))\n+}\n+\n+fn exprify_if(statement: &ast::IfExpr, name: &hir::Name) -> Option<ast::Expr> {\n+    let then_branch = exprify_block(&statement.then_branch()?, name)?;\n+    let else_branch = match statement.else_branch()? {\n+        ast::ElseBranch::Block(ref block) => ast::ElseBranch::Block(exprify_block(block, name)?),\n+        ast::ElseBranch::IfExpr(expr) => {\n+            mark::hit!(test_extract_assigment_chained_if);\n+            ast::ElseBranch::IfExpr(ast::IfExpr::cast(\n+                exprify_if(&expr, name)?.syntax().to_owned(),\n+            )?)\n+        }\n+    };\n+    Some(make::expr_if(statement.condition()?, then_branch, Some(else_branch)))\n+}\n+\n+fn exprify_block(block: &ast::BlockExpr, name: &hir::Name) -> Option<ast::BlockExpr> {\n+    if block.expr().is_some() {\n+        return None;\n+    }\n+\n+    let mut stmts: Vec<_> = block.statements().collect();\n+    let stmt = stmts.pop()?;\n+\n+    if let ast::Stmt::ExprStmt(stmt) = stmt {\n+        if let ast::Expr::BinExpr(expr) = stmt.expr()? {\n+            if expr.op_kind()? == ast::BinOp::Assignment\n+                && &expr.lhs()?.name_ref()?.as_name() == name\n+            {\n+                // The last statement in the block is an assignment to the name we want\n+                return Some(make::block_expr(stmts, Some(expr.rhs()?)));\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    #[test]\n+    fn test_extract_assignment_if() {\n+        check_assist(\n+            extract_assigment,\n+            r#\"\n+fn foo() {\n+    let mut a = 1;\n+\n+    if true {\n+        <|>a = 2;\n+    } else {\n+        a = 3;\n+    }\n+}\"#,\n+            r#\"\n+fn foo() {\n+    let mut a = 1;\n+\n+    a = if true {\n+        2\n+    } else {\n+        3\n+    };\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_assignment_match() {\n+        check_assist(\n+            extract_assigment,\n+            r#\"\n+fn foo() {\n+    let mut a = 1;\n+\n+    match 1 {\n+        1 => {\n+            <|>a = 2;\n+        },\n+        2 => {\n+            a = 3;\n+        },\n+        3 => {\n+            a = 4;\n+        }\n+    }\n+}\"#,\n+            r#\"\n+fn foo() {\n+    let mut a = 1;\n+\n+    a = match 1 {\n+        1 => {\n+            2\n+        },\n+        2 => {\n+            3\n+        },\n+        3 => {\n+            4\n+        }\n+    };\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_assignment_not_last_not_applicable() {\n+        check_assist_not_applicable(\n+            extract_assigment,\n+            r#\"\n+fn foo() {\n+    let mut a = 1;\n+\n+    if true {\n+        <|>a = 2;\n+        b = a;\n+    } else {\n+        a = 3;\n+    }\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_extract_assignment_chained_if() {\n+        mark::check!(test_extract_assigment_chained_if);\n+        check_assist(\n+            extract_assigment,\n+            r#\"\n+fn foo() {\n+    let mut a = 1;\n+\n+    if true {\n+        <|>a = 2;\n+    } else if false {\n+        a = 3;\n+    } else {\n+        a = 4;\n+    }\n+}\"#,\n+            r#\"\n+fn foo() {\n+    let mut a = 1;\n+\n+    a = if true {\n+        2\n+    } else if false {\n+        3\n+    } else {\n+        4\n+    };\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_assigment_retains_stmts() {\n+        check_assist(\n+            extract_assigment,\n+            r#\"\n+fn foo() {\n+    let mut a = 1;\n+\n+    if true {\n+        let b = 2;\n+        <|>a = 2;\n+    } else {\n+        let b = 3;\n+        a = 3;\n+    }\n+}\"#,\n+            r#\"\n+fn foo() {\n+    let mut a = 1;\n+\n+    a = if true {\n+        let b = 2;\n+        2\n+    } else {\n+        let b = 3;\n+        3\n+    };\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_assignment_let_stmt_not_applicable() {\n+        check_assist_not_applicable(\n+            extract_assigment,\n+            r#\"\n+fn foo() {\n+    let mut a = 1;\n+\n+    let b = if true {\n+        <|>a = 2\n+    } else {\n+        a = 3\n+    };\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_assignment_if_missing_assigment_not_applicable() {\n+        check_assist_not_applicable(\n+            extract_assigment,\n+            r#\"\n+fn foo() {\n+    let mut a = 1;\n+\n+    if true {\n+        <|>a = 2;\n+    } else {}\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_assignment_match_missing_assigment_not_applicable() {\n+        check_assist_not_applicable(\n+            extract_assigment,\n+            r#\"\n+fn foo() {\n+    let mut a = 1;\n+\n+    match 1 {\n+        1 => {\n+            <|>a = 2;\n+        },\n+        2 => {\n+            a = 3;\n+        },\n+        3 => {},\n+    }\n+}\"#,\n+        )\n+    }\n+}"}, {"sha": "212464f859d48dddb341f2b96455621784d7d3e2", "filename": "crates/assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/510abef5da1427c542e7b37dcea805c7b022984c/crates%2Fassists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510abef5da1427c542e7b37dcea805c7b022984c/crates%2Fassists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Flib.rs?ref=510abef5da1427c542e7b37dcea805c7b022984c", "patch": "@@ -116,6 +116,7 @@ mod handlers {\n     mod convert_integer_literal;\n     mod early_return;\n     mod expand_glob_import;\n+    mod extract_assignment;\n     mod extract_module_to_file;\n     mod extract_struct_from_enum_variant;\n     mod extract_variable;\n@@ -167,6 +168,7 @@ mod handlers {\n             convert_integer_literal::convert_integer_literal,\n             early_return::convert_to_guarded_return,\n             expand_glob_import::expand_glob_import,\n+            extract_assignment::extract_assigment,\n             extract_module_to_file::extract_module_to_file,\n             extract_struct_from_enum_variant::extract_struct_from_enum_variant,\n             extract_variable::extract_variable,"}, {"sha": "b91a816e89892504a1c0181a691f29cb486edf2b", "filename": "crates/assists/src/tests/generated.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/510abef5da1427c542e7b37dcea805c7b022984c/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510abef5da1427c542e7b37dcea805c7b022984c/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs?ref=510abef5da1427c542e7b37dcea805c7b022984c", "patch": "@@ -237,6 +237,35 @@ fn qux(bar: Bar, baz: Baz) {}\n     )\n }\n \n+#[test]\n+fn doctest_extract_assignment() {\n+    check_doc_test(\n+        \"extract_assignment\",\n+        r#####\"\n+fn main() {\n+    let mut foo = 6;\n+\n+    if true {\n+        <|>foo = 5;\n+    } else {\n+        foo = 4;\n+    }\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    let mut foo = 6;\n+\n+    foo = if true {\n+        5\n+    } else {\n+        4\n+    };\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_extract_module_to_file() {\n     check_doc_test("}]}