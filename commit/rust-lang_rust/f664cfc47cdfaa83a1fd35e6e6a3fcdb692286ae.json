{"sha": "f664cfc47cdfaa83a1fd35e6e6a3fcdb692286ae", "node_id": "C_kwDOAAsO6NoAKGY2NjRjZmM0N2NkZmFhODNhMWZkMzVlNmU2YTNmY2RiNjkyMjg2YWU", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2021-10-22T22:49:38Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-01-18T22:25:24Z"}, "message": "Make generator and async-await tests pass\n\nThe main change needed to make this work is to do a pessimistic over-\napproximation for AssignOps. The existing ScopeTree analysis in\nregion.rs works by doing both left to right and right to left order and\nthen choosing the most conservative ordering. This behavior is needed\nbecause AssignOp's evaluation order depends on whether it is a primitive\ntype or an overloaded operator, which runs as a method call.\n\nThis change mimics the same behavior as region.rs in\ngenerator_interior.rs.\n\nIssue #57478", "tree": {"sha": "a39004501dedab6cb64ff855d376fc49d7071f5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a39004501dedab6cb64ff855d376fc49d7071f5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f664cfc47cdfaa83a1fd35e6e6a3fcdb692286ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f664cfc47cdfaa83a1fd35e6e6a3fcdb692286ae", "html_url": "https://github.com/rust-lang/rust/commit/f664cfc47cdfaa83a1fd35e6e6a3fcdb692286ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f664cfc47cdfaa83a1fd35e6e6a3fcdb692286ae/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4dee401700170c95c649682d62ad150d6b5fdeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4dee401700170c95c649682d62ad150d6b5fdeb", "html_url": "https://github.com/rust-lang/rust/commit/c4dee401700170c95c649682d62ad150d6b5fdeb"}], "stats": {"total": 144, "additions": 106, "deletions": 38}, "files": [{"sha": "baeb78139ac9669332c307ab153b786433d97e43", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 104, "deletions": 35, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/f664cfc47cdfaa83a1fd35e6e6a3fcdb692286ae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f664cfc47cdfaa83a1fd35e6e6a3fcdb692286ae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=f664cfc47cdfaa83a1fd35e6e6a3fcdb692286ae", "patch": "@@ -15,6 +15,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::HirIdSet;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind};\n+use rustc_middle::hir::place::{Place, PlaceBase};\n use rustc_middle::middle::region::{self, YieldData};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n@@ -222,30 +223,37 @@ pub fn resolve_interior<'a, 'tcx>(\n ) {\n     let body = fcx.tcx.hir().body(body_id);\n \n-    let mut drop_range_visitor = DropRangeVisitor::default();\n-\n-    // Run ExprUseVisitor to find where values are consumed.\n-    ExprUseVisitor::new(\n-        &mut drop_range_visitor,\n-        &fcx.infcx,\n-        def_id.expect_local(),\n-        fcx.param_env,\n-        &fcx.typeck_results.borrow(),\n-    )\n-    .consume_body(body);\n-    intravisit::walk_body(&mut drop_range_visitor, body);\n-\n-    let mut visitor = InteriorVisitor {\n-        fcx,\n-        types: FxIndexSet::default(),\n-        region_scope_tree: fcx.tcx.region_scope_tree(def_id),\n-        expr_count: 0,\n-        kind,\n-        prev_unresolved_span: None,\n-        guard_bindings: <_>::default(),\n-        guard_bindings_set: <_>::default(),\n-        linted_values: <_>::default(),\n-        drop_ranges: drop_range_visitor.drop_ranges,\n+    let mut visitor = {\n+        let mut drop_range_visitor = DropRangeVisitor {\n+            consumed_places: <_>::default(),\n+            borrowed_places: <_>::default(),\n+            drop_ranges: vec![<_>::default()],\n+            expr_count: 0,\n+        };\n+\n+        // Run ExprUseVisitor to find where values are consumed.\n+        ExprUseVisitor::new(\n+            &mut drop_range_visitor,\n+            &fcx.infcx,\n+            def_id.expect_local(),\n+            fcx.param_env,\n+            &fcx.typeck_results.borrow(),\n+        )\n+        .consume_body(body);\n+        intravisit::walk_body(&mut drop_range_visitor, body);\n+\n+        InteriorVisitor {\n+            fcx,\n+            types: FxIndexSet::default(),\n+            region_scope_tree: fcx.tcx.region_scope_tree(def_id),\n+            expr_count: 0,\n+            kind,\n+            prev_unresolved_span: None,\n+            guard_bindings: <_>::default(),\n+            guard_bindings_set: <_>::default(),\n+            linted_values: <_>::default(),\n+            drop_ranges: drop_range_visitor.drop_ranges.pop().unwrap(),\n+        }\n     };\n     intravisit::walk_body(&mut visitor, body);\n \n@@ -656,17 +664,37 @@ fn check_must_not_suspend_def(\n }\n \n /// This struct facilitates computing the ranges for which a place is uninitialized.\n-#[derive(Default)]\n struct DropRangeVisitor {\n     consumed_places: HirIdSet,\n-    drop_ranges: HirIdMap<DropRange>,\n+    borrowed_places: HirIdSet,\n+    drop_ranges: Vec<HirIdMap<DropRange>>,\n     expr_count: usize,\n }\n \n impl DropRangeVisitor {\n     fn record_drop(&mut self, hir_id: HirId) {\n-        debug!(\"marking {:?} as dropped at {}\", hir_id, self.expr_count);\n-        self.drop_ranges.insert(hir_id, DropRange { dropped_at: self.expr_count });\n+        let drop_ranges = self.drop_ranges.last_mut().unwrap();\n+        if self.borrowed_places.contains(&hir_id) {\n+            debug!(\"not marking {:?} as dropped because it is borrowed at some point\", hir_id);\n+        } else if self.consumed_places.contains(&hir_id) {\n+            debug!(\"marking {:?} as dropped at {}\", hir_id, self.expr_count);\n+            drop_ranges.insert(hir_id, DropRange { dropped_at: self.expr_count });\n+        }\n+    }\n+\n+    fn push_drop_scope(&mut self) {\n+        self.drop_ranges.push(<_>::default());\n+    }\n+\n+    fn pop_and_merge_drop_scope(&mut self) {\n+        let mut old_last = self.drop_ranges.pop().unwrap();\n+        let drop_ranges = self.drop_ranges.last_mut().unwrap();\n+        for (k, v) in old_last.drain() {\n+            match drop_ranges.get(&k).cloned() {\n+                Some(v2) => drop_ranges.insert(k, v.intersect(&v2)),\n+                None => drop_ranges.insert(k, v),\n+            };\n+        }\n     }\n \n     /// ExprUseVisitor's consume callback doesn't go deep enough for our purposes in all\n@@ -685,6 +713,14 @@ impl DropRangeVisitor {\n     }\n }\n \n+fn place_hir_id(place: &Place<'_>) -> Option<HirId> {\n+    match place.base {\n+        PlaceBase::Rvalue | PlaceBase::StaticItem => None,\n+        PlaceBase::Local(hir_id)\n+        | PlaceBase::Upvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id }, .. }) => Some(hir_id),\n+    }\n+}\n+\n impl<'tcx> expr_use_visitor::Delegate<'tcx> for DropRangeVisitor {\n     fn consume(\n         &mut self,\n@@ -693,14 +729,16 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for DropRangeVisitor {\n     ) {\n         debug!(\"consume {:?}; diag_expr_id={:?}\", place_with_id, diag_expr_id);\n         self.consumed_places.insert(place_with_id.hir_id);\n+        place_hir_id(&place_with_id.place).map(|place| self.consumed_places.insert(place));\n     }\n \n     fn borrow(\n         &mut self,\n-        _place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n         _diag_expr_id: hir::HirId,\n         _bk: rustc_middle::ty::BorrowKind,\n     ) {\n+        place_hir_id(&place_with_id.place).map(|place| self.borrowed_places.insert(place));\n     }\n \n     fn mutate(\n@@ -726,17 +764,44 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_expr(&mut self, expr: &Expr<'_>) {\n-        intravisit::walk_expr(self, expr);\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        match expr.kind {\n+            ExprKind::AssignOp(_, lhs, rhs) => {\n+                // These operations are weird because their order of evaluation depends on whether\n+                // the operator is overloaded. In a perfect world, we'd just ask the type checker\n+                // whether this is a method call, but we also need to match the expression IDs\n+                // from RegionResolutionVisitor. RegionResolutionVisitor doesn't know the order,\n+                // so it runs both orders and picks the most conservative. We'll mirror that here.\n+                let mut old_count = self.expr_count;\n+                intravisit::walk_expr(self, lhs);\n+                intravisit::walk_expr(self, rhs);\n+\n+                self.push_drop_scope();\n+                std::mem::swap(&mut old_count, &mut self.expr_count);\n+                intravisit::walk_expr(self, rhs);\n+                intravisit::walk_expr(self, lhs);\n+\n+                // We should have visited the same number of expressions in either order.\n+                assert_eq!(old_count, self.expr_count);\n+\n+                self.pop_and_merge_drop_scope();\n+            }\n+            _ => intravisit::walk_expr(self, expr),\n+        }\n \n         self.expr_count += 1;\n+        self.consume_expr(expr);\n+    }\n \n-        if self.consumed_places.contains(&expr.hir_id) {\n-            self.consume_expr(expr);\n-        }\n+    fn visit_pat(&mut self, pat: &'tcx Pat<'tcx>) {\n+        intravisit::walk_pat(self, pat);\n+\n+        // Increment expr_count here to match what InteriorVisitor expects.\n+        self.expr_count += 1;\n     }\n }\n \n+#[derive(Clone)]\n struct DropRange {\n     /// The post-order id of the point where this expression is dropped.\n     ///\n@@ -745,7 +810,11 @@ struct DropRange {\n }\n \n impl DropRange {\n+    fn intersect(&self, other: &Self) -> Self {\n+        Self { dropped_at: self.dropped_at.max(other.dropped_at) }\n+    }\n+\n     fn contains(&self, id: usize) -> bool {\n-        id >= self.dropped_at\n+        id > self.dropped_at\n     }\n }"}, {"sha": "210d9ff3f2d320460f066c917c7387f7581d02ce", "filename": "src/test/ui/async-await/async-fn-nonsend.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f664cfc47cdfaa83a1fd35e6e6a3fcdb692286ae/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f664cfc47cdfaa83a1fd35e6e6a3fcdb692286ae/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs?ref=f664cfc47cdfaa83a1fd35e6e6a3fcdb692286ae", "patch": "@@ -36,7 +36,7 @@ async fn non_send_temporary_in_match() {\n }\n \n async fn non_sync_with_method_call() {\n-\n+    // FIXME: it would be nice for this to work\n     let f: &mut std::fmt::Formatter = panic!();\n     if non_sync().fmt(f).unwrap() == () {\n         fut().await;\n@@ -47,9 +47,8 @@ fn assert_send(_: impl Send) {}\n \n pub fn pass_assert() {\n     assert_send(local_dropped_before_await());\n-\n     assert_send(non_send_temporary_in_match());\n     //~^ ERROR future cannot be sent between threads safely\n     assert_send(non_sync_with_method_call());\n-\n+    //~^ ERROR future cannot be sent between threads safely\n }"}]}