{"sha": "83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzY2VkNjdkMGI2Y2NjYjBkZThmM2RmMTMzZjdiNTgwZGI2Zjc0YzU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-30T22:10:03Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-30T22:30:42Z"}, "message": "librustdoc: De-export compiletest, combine-tests, libcargo, libfuzzer, and librustdoc. rs=deexporting", "tree": {"sha": "057af423a943f5213ecfbc1f799973692a0dbd5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/057af423a943f5213ecfbc1f799973692a0dbd5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "html_url": "https://github.com/rust-lang/rust/commit/83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d73bf6295231115bed44d2dc452c9971a25f84c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d73bf6295231115bed44d2dc452c9971a25f84c6", "html_url": "https://github.com/rust-lang/rust/commit/d73bf6295231115bed44d2dc452c9971a25f84c6"}], "stats": {"total": 469, "additions": 213, "deletions": 256}, "files": [{"sha": "9d4becd63d39099206baead664de903482b30f56", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -12,16 +12,15 @@ use core::prelude::*;\n \n use cmp;\n \n-enum mode { mode_compile_fail, mode_run_fail, mode_run_pass, mode_pretty, }\n-\n-impl mode : cmp::Eq {\n-    pure fn eq(&self, other: &mode) -> bool {\n-        (*other) as int == (*self) as int\n-    }\n-    pure fn ne(&self, other: &mode) -> bool { !(*self).eq(other) }\n+#[deriving_eq]\n+pub enum mode {\n+    mode_compile_fail,\n+    mode_run_fail,\n+    mode_run_pass,\n+    mode_pretty,\n }\n \n-type config = {\n+pub type config = {\n     // The library paths required for running the compiler\n     compile_lib_path: ~str,\n "}, {"sha": "4f9c86b70f074f957dd6c07574d01e6321d9de1b", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -11,7 +11,6 @@\n #[crate_type = \"bin\"];\n \n #[no_core];\n-#[legacy_exports];\n #[legacy_records];\n \n #[allow(vecs_implicitly_copyable)];\n@@ -24,17 +23,11 @@ extern mod std(vers = \"0.6\");\n \n use core::*;\n \n-#[legacy_exports]\n mod procsrv;\n-#[legacy_exports]\n mod util;\n-#[legacy_exports]\n mod header;\n-#[legacy_exports]\n mod runtest;\n-#[legacy_exports]\n mod common;\n-#[legacy_exports]\n mod errors;\n \n use std::getopts;\n@@ -51,14 +44,14 @@ use common::mode_pretty;\n use common::mode;\n use util::logv;\n \n-fn main() {\n+pub fn main() {\n     let args = os::args();\n     let config = parse_config(args);\n     log_config(config);\n     run_tests(config);\n }\n \n-fn parse_config(args: ~[~str]) -> config {\n+pub fn parse_config(args: ~[~str]) -> config {\n     let opts =\n         ~[getopts::reqopt(~\"compile-lib-path\"),\n           getopts::reqopt(~\"run-lib-path\"),\n@@ -105,7 +98,7 @@ fn parse_config(args: ~[~str]) -> config {\n          verbose: getopts::opt_present(matches, ~\"verbose\")};\n }\n \n-fn log_config(config: config) {\n+pub fn log_config(config: config) {\n     let c = config;\n     logv(c, fmt!(\"configuration:\"));\n     logv(c, fmt!(\"compile_lib_path: %s\", config.compile_lib_path));\n@@ -124,15 +117,15 @@ fn log_config(config: config) {\n     logv(c, fmt!(\"\\n\"));\n }\n \n-fn opt_str(maybestr: Option<~str>) -> ~str {\n+pub fn opt_str(maybestr: Option<~str>) -> ~str {\n     match maybestr { option::Some(s) => s, option::None => ~\"(none)\" }\n }\n \n-fn str_opt(maybestr: ~str) -> Option<~str> {\n+pub fn str_opt(maybestr: ~str) -> Option<~str> {\n     if maybestr != ~\"(none)\" { option::Some(maybestr) } else { option::None }\n }\n \n-fn str_mode(s: ~str) -> mode {\n+pub fn str_mode(s: ~str) -> mode {\n     match s {\n       ~\"compile-fail\" => mode_compile_fail,\n       ~\"run-fail\" => mode_run_fail,\n@@ -142,7 +135,7 @@ fn str_mode(s: ~str) -> mode {\n     }\n }\n \n-fn mode_str(mode: mode) -> ~str {\n+pub fn mode_str(mode: mode) -> ~str {\n     match mode {\n       mode_compile_fail => ~\"compile-fail\",\n       mode_run_fail => ~\"run-fail\",\n@@ -151,22 +144,22 @@ fn mode_str(mode: mode) -> ~str {\n     }\n }\n \n-fn run_tests(config: config) {\n+pub fn run_tests(config: config) {\n     let opts = test_opts(config);\n     let tests = make_tests(config);\n     let res = test::run_tests_console(&opts, tests);\n     if !res { fail ~\"Some tests failed\"; }\n }\n \n-fn test_opts(config: config) -> test::TestOpts {\n+pub fn test_opts(config: config) -> test::TestOpts {\n     test::TestOpts {\n         filter: config.filter,\n         run_ignored: config.run_ignored,\n         logfile: config.logfile.map(|s| s.to_str()),\n     }\n }\n \n-fn make_tests(config: config) -> ~[test::TestDesc] {\n+pub fn make_tests(config: config) -> ~[test::TestDesc] {\n     debug!(\"making tests from %s\",\n            config.src_base.to_str());\n     let mut tests = ~[];\n@@ -180,7 +173,7 @@ fn make_tests(config: config) -> ~[test::TestDesc] {\n     move tests\n }\n \n-fn is_test(config: config, testfile: &Path) -> bool {\n+pub fn is_test(config: config, testfile: &Path) -> bool {\n     // Pretty-printer does not work with .rc files yet\n     let valid_extensions =\n         match config.mode {\n@@ -203,7 +196,7 @@ fn is_test(config: config, testfile: &Path) -> bool {\n     return valid;\n }\n \n-fn make_test(config: config, testfile: &Path) ->\n+pub fn make_test(config: config, testfile: &Path) ->\n    test::TestDesc {\n     test::TestDesc {\n         name: make_test_name(config, testfile),\n@@ -213,11 +206,11 @@ fn make_test(config: config, testfile: &Path) ->\n     }\n }\n \n-fn make_test_name(config: config, testfile: &Path) -> ~str {\n+pub fn make_test_name(config: config, testfile: &Path) -> ~str {\n     fmt!(\"[%s] %s\", mode_str(config.mode), testfile.to_str())\n }\n \n-fn make_test_closure(config: config, testfile: &Path) -> test::TestFn {\n+pub fn make_test_closure(config: config, testfile: &Path) -> test::TestFn {\n     let testfile = testfile.to_str();\n     fn~() { runtest::run(config, testfile) }\n }"}, {"sha": "d41a4b7360c78719c01027de186f663df0b9ce82", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -15,13 +15,10 @@ use io;\n use io::ReaderUtil;\n use str;\n \n-export load_errors;\n-export ExpectedError;\n-\n-struct ExpectedError { line: uint, kind: ~str, msg: ~str }\n+pub struct ExpectedError { line: uint, kind: ~str, msg: ~str }\n \n // Load any test directives embedded in the file\n-fn load_errors(testfile: &Path) -> ~[ExpectedError] {\n+pub fn load_errors(testfile: &Path) -> ~[ExpectedError] {\n     let mut error_patterns = ~[];\n     let rdr = io::file_reader(testfile).get();\n     let mut line_num = 1u;"}, {"sha": "64192e523db9f49392361970b29214b18d611332", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -17,11 +17,7 @@ use io::ReaderUtil;\n use os;\n use str;\n \n-export TestProps;\n-export load_props;\n-export is_test_ignored;\n-\n-struct TestProps {\n+pub struct TestProps {\n     // Lines that should be expected, in order, on standard out\n     error_patterns: ~[~str],\n     // Extra flags to pass to the compiler\n@@ -36,7 +32,7 @@ struct TestProps {\n }\n \n // Load any test directives embedded in the file\n-fn load_props(testfile: &Path) -> TestProps {\n+pub fn load_props(testfile: &Path) -> TestProps {\n     let mut error_patterns = ~[];\n     let mut aux_builds = ~[];\n     let mut exec_env = ~[];\n@@ -73,7 +69,7 @@ fn load_props(testfile: &Path) -> TestProps {\n     };\n }\n \n-fn is_test_ignored(config: config, testfile: &Path) -> bool {\n+pub fn is_test_ignored(config: config, testfile: &Path) -> bool {\n     let mut found = false;\n     for iter_header(testfile) |ln| {\n         if parse_name_directive(ln, ~\"xfail-test\") { return true; }"}, {"sha": "8e575ca36f6cb3f2e222e93b4fab92d9b97ac467", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -22,8 +22,6 @@ use str;\n use task;\n use vec;\n \n-export run;\n-\n #[cfg(target_os = \"win32\")]\n fn target_env(lib_path: ~str, prog: ~str) -> ~[(~str,~str)] {\n \n@@ -54,12 +52,11 @@ fn target_env(_lib_path: ~str, _prog: ~str) -> ~[(~str,~str)] {\n struct Result {status: int, out: ~str, err: ~str}\n \n // FIXME (#2659): This code is duplicated in core::run::program_output\n-fn run(lib_path: ~str,\n-       prog: ~str,\n-       args: ~[~str],\n-       env: ~[(~str, ~str)],\n-       input: Option<~str>) -> Result {\n-\n+pub fn run(lib_path: ~str,\n+           prog: ~str,\n+           args: ~[~str],\n+           env: ~[(~str, ~str)],\n+           input: Option<~str>) -> Result {\n     let pipe_in = os::pipe();\n     let pipe_out = os::pipe();\n     let pipe_err = os::pipe();"}, {"sha": "e9c37115c49a52dab2af08cbb16e57a988797c69", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -31,9 +31,7 @@ use procsrv;\n use util;\n use util::logv;\n \n-export run;\n-\n-fn run(config: config, testfile: ~str) {\n+pub fn run(config: config, testfile: ~str) {\n     if config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line.\n         io::stdout().write_str(~\"\\n\\n\");"}, {"sha": "e4028549f28a28f2842ff9eaff4c415211e0e13f", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -17,7 +17,7 @@ use os::getenv;\n use common;\n use common::config;\n \n-fn make_new_path(path: ~str) -> ~str {\n+pub fn make_new_path(path: ~str) -> ~str {\n \n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n@@ -31,23 +31,23 @@ fn make_new_path(path: ~str) -> ~str {\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"freebsd\")]\n-fn lib_path_env_var() -> ~str { ~\"LD_LIBRARY_PATH\" }\n+pub fn lib_path_env_var() -> ~str { ~\"LD_LIBRARY_PATH\" }\n \n #[cfg(target_os = \"macos\")]\n-fn lib_path_env_var() -> ~str { ~\"DYLD_LIBRARY_PATH\" }\n+pub fn lib_path_env_var() -> ~str { ~\"DYLD_LIBRARY_PATH\" }\n \n #[cfg(target_os = \"win32\")]\n-fn lib_path_env_var() -> ~str { ~\"PATH\" }\n+pub fn lib_path_env_var() -> ~str { ~\"PATH\" }\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n-fn path_div() -> ~str { ~\":\" }\n+pub fn path_div() -> ~str { ~\":\" }\n \n #[cfg(target_os = \"win32\")]\n-fn path_div() -> ~str { ~\";\" }\n+pub fn path_div() -> ~str { ~\";\" }\n \n-fn logv(config: config, s: ~str) {\n+pub fn logv(config: config, s: ~str) {\n     log(debug, s);\n     if config.verbose { io::println(s); }\n }"}, {"sha": "8e1a916e2f19ebd022548b568661948b77bd2c0e", "filename": "src/etc/combine-tests.py", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Fetc%2Fcombine-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Fetc%2Fcombine-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcombine-tests.py?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -37,14 +37,12 @@ def scrub(b):\n c = open(\"tmp/run_pass_stage2.rc\", \"w\")\n i = 0\n c.write(\"// AUTO-GENERATED FILE: DO NOT EDIT\\n\")\n-c.write(\"#[legacy_exports];\\n\")\n c.write(\"#[link(name=\\\"run_pass_stage2\\\", vers=\\\"0.1\\\")];\\n\")\n for t in stage2_tests:\n     p = os.path.join(run_pass, t)\n     p = p.replace(\"\\\\\", \"\\\\\\\\\")\n     c.write(\"#[path = \\\"%s\\\"]\" % p);\n-    c.write(\"#[legacy_exports]\");\n-    c.write(\"mod t_%d;\\n\" % i)\n+    c.write(\"pub mod t_%d;\\n\" % i)\n     i += 1\n c.close()\n "}, {"sha": "f2a7c5c3cf4eb70a3313a9dea0bf97344075518f", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 81, "deletions": 87, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -26,7 +26,6 @@\n #[crate_type = \"lib\"];\n \n #[no_core];\n-#[legacy_exports];\n \n #[legacy_modes];\n \n@@ -42,7 +41,6 @@ extern mod std(vers = \"0.6\");\n extern mod rustc(vers = \"0.6\");\n extern mod syntax(vers = \"0.6\");\n \n-#[legacy_exports]\n mod pgp;\n \n use rustc::metadata::filesearch::{get_cargo_root, get_cargo_root_nearest};\n@@ -62,7 +60,7 @@ use syntax::diagnostic::span_handler;\n use syntax::diagnostic;\n use syntax::{ast, codemap, parse, visit, attr};\n \n-struct Package {\n+pub struct Package {\n     name: ~str,\n     uuid: ~str,\n     url: ~str,\n@@ -73,7 +71,7 @@ struct Package {\n     versions: ~[(~str, ~str)]\n }\n \n-impl Package : cmp::Ord {\n+pub impl Package : cmp::Ord {\n     pure fn lt(&self, other: &Package) -> bool {\n         if (*self).name.lt(&(*other).name) { return true; }\n         if (*other).name.lt(&(*self).name) { return false; }\n@@ -95,7 +93,7 @@ impl Package : cmp::Ord {\n     pure fn gt(&self, other: &Package) -> bool { (*other).lt(&(*self))  }\n }\n \n-struct Source {\n+pub struct Source {\n     name: ~str,\n     mut url: ~str,\n     mut method: ~str,\n@@ -104,7 +102,7 @@ struct Source {\n     packages: DVec<Package>\n }\n \n-struct Cargo {\n+pub struct Cargo {\n     pgp: bool,\n     root: Path,\n     installdir: Path,\n@@ -118,7 +116,7 @@ struct Cargo {\n     opts: Options\n }\n \n-struct Crate {\n+pub struct Crate {\n     name: ~str,\n     vers: ~str,\n     uuid: ~str,\n@@ -128,28 +126,22 @@ struct Crate {\n     deps: ~[~str]\n }\n \n-struct Options {\n+pub struct Options {\n     test: bool,\n     mode: Mode,\n     free: ~[~str],\n     help: bool,\n }\n \n-enum Mode { SystemMode, UserMode, LocalMode }\n+#[deriving_eq]\n+pub enum Mode { SystemMode, UserMode, LocalMode }\n \n-impl Mode : cmp::Eq {\n-    pure fn eq(&self, other: &Mode) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &Mode) -> bool { !(*self).eq(other) }\n-}\n-\n-fn opts() -> ~[getopts::Opt] {\n+pub fn opts() -> ~[getopts::Opt] {\n     ~[optflag(~\"g\"), optflag(~\"G\"), optflag(~\"test\"),\n      optflag(~\"h\"), optflag(~\"help\")]\n }\n \n-fn info(msg: ~str) {\n+pub fn info(msg: ~str) {\n     let out = io::stdout();\n \n     if term::color_supported() {\n@@ -160,7 +152,7 @@ fn info(msg: ~str) {\n     } else { out.write_line(~\"info: \" + msg); }\n }\n \n-fn warn(msg: ~str) {\n+pub fn warn(msg: ~str) {\n     let out = io::stdout();\n \n     if term::color_supported() {\n@@ -171,7 +163,7 @@ fn warn(msg: ~str) {\n     }else { out.write_line(~\"warning: \" + msg); }\n }\n \n-fn error(msg: ~str) {\n+pub fn error(msg: ~str) {\n     let out = io::stdout();\n \n     if term::color_supported() {\n@@ -183,7 +175,7 @@ fn error(msg: ~str) {\n     else { out.write_line(~\"error: \" + msg); }\n }\n \n-fn is_uuid(id: ~str) -> bool {\n+pub fn is_uuid(id: ~str) -> bool {\n     let parts = str::split_str(id, ~\"-\");\n     if vec::len(parts) == 5u {\n         let mut correct = 0u;\n@@ -225,7 +217,7 @@ fn is_uuid(id: ~str) -> bool {\n }\n \n #[test]\n-fn test_is_uuid() {\n+pub fn test_is_uuid() {\n     assert is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaafAF09\");\n     assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaaa-aaaaaaaaaaaa\");\n     assert !is_uuid(~\"\");\n@@ -238,7 +230,7 @@ fn test_is_uuid() {\n // FIXME (#2661): implement url/URL parsing so we don't have to resort\n // to weak checks\n \n-fn has_archive_extension(p: ~str) -> bool {\n+pub fn has_archive_extension(p: ~str) -> bool {\n     str::ends_with(p, ~\".tar\") ||\n     str::ends_with(p, ~\".tar.gz\") ||\n     str::ends_with(p, ~\".tar.bz2\") ||\n@@ -254,11 +246,11 @@ fn has_archive_extension(p: ~str) -> bool {\n     str::ends_with(p, ~\".txz\")\n }\n \n-fn is_archive_path(u: ~str) -> bool {\n+pub fn is_archive_path(u: ~str) -> bool {\n     has_archive_extension(u) && os::path_exists(&Path(u))\n }\n \n-fn is_archive_url(u: ~str) -> bool {\n+pub fn is_archive_url(u: ~str) -> bool {\n     // FIXME (#2661): this requires the protocol bit - if we had proper\n     // url parsing, we wouldn't need it\n \n@@ -268,14 +260,14 @@ fn is_archive_url(u: ~str) -> bool {\n     }\n }\n \n-fn is_git_url(url: ~str) -> bool {\n+pub fn is_git_url(url: ~str) -> bool {\n     if str::ends_with(url, ~\"/\") { str::ends_with(url, ~\".git/\") }\n     else {\n         str::starts_with(url, ~\"git://\") || str::ends_with(url, ~\".git\")\n     }\n }\n \n-fn assume_source_method(url: ~str) -> ~str {\n+pub fn assume_source_method(url: ~str) -> ~str {\n     if is_git_url(url) {\n         return ~\"git\";\n     }\n@@ -286,9 +278,9 @@ fn assume_source_method(url: ~str) -> ~str {\n     ~\"curl\"\n }\n \n-fn load_link(mis: ~[@ast::meta_item]) -> (Option<~str>,\n-                                         Option<~str>,\n-                                         Option<~str>) {\n+pub fn load_link(mis: ~[@ast::meta_item]) -> (Option<~str>,\n+                                              Option<~str>,\n+                                              Option<~str>) {\n     let mut name = None;\n     let mut vers = None;\n     let mut uuid = None;\n@@ -309,7 +301,7 @@ fn load_link(mis: ~[@ast::meta_item]) -> (Option<~str>,\n     (name, vers, uuid)\n }\n \n-fn load_crate(filename: &Path) -> Option<Crate> {\n+pub fn load_crate(filename: &Path) -> Option<Crate> {\n     let sess = parse::new_parse_sess(None);\n     let c = parse::parse_crate_from_file(filename, ~[], sess);\n \n@@ -428,26 +420,26 @@ fn load_crate(filename: &Path) -> Option<Crate> {\n     }\n }\n \n-fn print(s: ~str) {\n+pub fn print(s: ~str) {\n     io::stdout().write_line(s);\n }\n \n-fn rest(s: ~str, start: uint) -> ~str {\n+pub fn rest(s: ~str, start: uint) -> ~str {\n     if (start >= str::len(s)) {\n         ~\"\"\n     } else {\n         str::slice(s, start, str::len(s))\n     }\n }\n \n-fn need_dir(s: &Path) {\n+pub fn need_dir(s: &Path) {\n     if os::path_is_dir(s) { return; }\n     if !os::make_dir(s, 493_i32 /* oct: 755 */) {\n         fail fmt!(\"can't make_dir %s\", s.to_str());\n     }\n }\n \n-fn valid_pkg_name(s: &str) -> bool {\n+pub fn valid_pkg_name(s: &str) -> bool {\n     fn is_valid_digit(+c: char) -> bool {\n         ('0' <= c && c <= '9') ||\n         ('a' <= c && c <= 'z') ||\n@@ -459,7 +451,7 @@ fn valid_pkg_name(s: &str) -> bool {\n     s.all(is_valid_digit)\n }\n \n-fn parse_source(name: ~str, j: &json::Json) -> @Source {\n+pub fn parse_source(name: ~str, j: &json::Json) -> @Source {\n     if !valid_pkg_name(name) {\n         fail fmt!(\"'%s' is an invalid source name\", name);\n     }\n@@ -497,7 +489,8 @@ fn parse_source(name: ~str, j: &json::Json) -> @Source {\n     };\n }\n \n-fn try_parse_sources(filename: &Path, sources: map::HashMap<~str, @Source>) {\n+pub fn try_parse_sources(filename: &Path,\n+                         sources: map::HashMap<~str, @Source>) {\n     if !os::path_exists(filename)  { return; }\n     let c = io::read_whole_file_str(filename);\n     match json::from_str(c.get()) {\n@@ -512,7 +505,7 @@ fn try_parse_sources(filename: &Path, sources: map::HashMap<~str, @Source>) {\n     }\n }\n \n-fn load_one_source_package(src: @Source, p: &json::Object) {\n+pub fn load_one_source_package(src: @Source, p: &json::Object) {\n     let name = match p.find(&~\"name\") {\n         Some(&json::String(n)) => {\n             if !valid_pkg_name(n) {\n@@ -614,7 +607,7 @@ fn load_one_source_package(src: @Source, p: &json::Object) {\n     log(debug, ~\"  loaded package: \" + src.name + ~\"/\" + name);\n }\n \n-fn load_source_info(c: &Cargo, src: @Source) {\n+pub fn load_source_info(c: &Cargo, src: @Source) {\n     let dir = c.sourcedir.push(src.name);\n     let srcfile = dir.push(\"source.json\");\n     if !os::path_exists(&srcfile) { return; }\n@@ -635,7 +628,7 @@ fn load_source_info(c: &Cargo, src: @Source) {\n         }\n     };\n }\n-fn load_source_packages(c: &Cargo, src: @Source) {\n+pub fn load_source_packages(c: &Cargo, src: @Source) {\n     log(debug, ~\"loading source: \" + src.name);\n     let dir = c.sourcedir.push(src.name);\n     let pkgfile = dir.push(\"packages.json\");\n@@ -665,7 +658,7 @@ fn load_source_packages(c: &Cargo, src: @Source) {\n     };\n }\n \n-fn build_cargo_options(argv: ~[~str]) -> Options {\n+pub fn build_cargo_options(argv: ~[~str]) -> Options {\n     let matches = &match getopts::getopts(argv, opts()) {\n         result::Ok(m) => m,\n         result::Err(f) => {\n@@ -696,7 +689,7 @@ fn build_cargo_options(argv: ~[~str]) -> Options {\n     Options {test: test, mode: mode, free: matches.free, help: help}\n }\n \n-fn configure(opts: Options) -> Cargo {\n+pub fn configure(opts: Options) -> Cargo {\n     let home = match get_cargo_root() {\n         Ok(home) => home,\n         Err(_err) => get_cargo_sysroot().get()\n@@ -754,7 +747,7 @@ fn configure(opts: Options) -> Cargo {\n     move c\n }\n \n-fn for_each_package(c: &Cargo, b: fn(s: @Source, p: &Package)) {\n+pub fn for_each_package(c: &Cargo, b: fn(s: @Source, p: &Package)) {\n     for c.sources.each_value |v| {\n         for v.packages.each |p| {\n             b(v, p);\n@@ -763,7 +756,7 @@ fn for_each_package(c: &Cargo, b: fn(s: @Source, p: &Package)) {\n }\n \n // Runs all programs in directory <buildpath>\n-fn run_programs(buildpath: &Path) {\n+pub fn run_programs(buildpath: &Path) {\n     let newv = os::list_dir_path(buildpath);\n     for newv.each |ct| {\n         run::run_program(ct.to_str(), ~[]);\n@@ -772,8 +765,8 @@ fn run_programs(buildpath: &Path) {\n \n // Runs rustc in <path + subdir> with the given flags\n // and returns <patho + subdir>\n-fn run_in_buildpath(what: &str, path: &Path, subdir: &Path, cf: &Path,\n-                    extra_flags: ~[~str]) -> Option<Path> {\n+pub fn run_in_buildpath(what: &str, path: &Path, subdir: &Path, cf: &Path,\n+                        extra_flags: ~[~str]) -> Option<Path> {\n     let buildpath = path.push_rel(subdir);\n     need_dir(&buildpath);\n     debug!(\"%s: %s -> %s\", what, cf.to_str(), buildpath.to_str());\n@@ -788,7 +781,7 @@ fn run_in_buildpath(what: &str, path: &Path, subdir: &Path, cf: &Path,\n     Some(buildpath)\n }\n \n-fn test_one_crate(_c: &Cargo, path: &Path, cf: &Path) {\n+pub fn test_one_crate(_c: &Cargo, path: &Path, cf: &Path) {\n     let buildpath = match run_in_buildpath(~\"testing\", path,\n                                            &Path(\"test\"),\n                                            cf,\n@@ -799,7 +792,7 @@ fn test_one_crate(_c: &Cargo, path: &Path, cf: &Path) {\n   run_programs(&buildpath);\n }\n \n-fn install_one_crate(c: &Cargo, path: &Path, cf: &Path) {\n+pub fn install_one_crate(c: &Cargo, path: &Path, cf: &Path) {\n     let buildpath = match run_in_buildpath(~\"installing\", path,\n                                            &Path(\"build\"),\n                                            cf, ~[]) {\n@@ -829,7 +822,7 @@ fn install_one_crate(c: &Cargo, path: &Path, cf: &Path) {\n }\n \n \n-fn rustc_sysroot() -> ~str {\n+pub fn rustc_sysroot() -> ~str {\n     match os::self_exe_path() {\n         Some(path) => {\n             let rustc = path.push_many([~\"..\", ~\"bin\", ~\"rustc\"]);\n@@ -840,7 +833,7 @@ fn rustc_sysroot() -> ~str {\n     }\n }\n \n-fn install_source(c: &Cargo, path: &Path) {\n+pub fn install_source(c: &Cargo, path: &Path) {\n     debug!(\"source: %s\", path.to_str());\n     os::change_dir(path);\n \n@@ -879,7 +872,7 @@ fn install_source(c: &Cargo, path: &Path) {\n     }\n }\n \n-fn install_git(c: &Cargo, wd: &Path, url: ~str, reference: Option<~str>) {\n+pub fn install_git(c: &Cargo, wd: &Path, url: ~str, reference: Option<~str>) {\n     run::program_output(~\"git\", ~[~\"clone\", url, wd.to_str()]);\n     if reference.is_some() {\n         let r = reference.get();\n@@ -890,7 +883,7 @@ fn install_git(c: &Cargo, wd: &Path, url: ~str, reference: Option<~str>) {\n     install_source(c, wd);\n }\n \n-fn install_curl(c: &Cargo, wd: &Path, url: ~str) {\n+pub fn install_curl(c: &Cargo, wd: &Path, url: ~str) {\n     let tarpath = wd.push(\"pkg.tar\");\n     let p = run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\",\n                                          tarpath.to_str(), url]);\n@@ -903,14 +896,14 @@ fn install_curl(c: &Cargo, wd: &Path, url: ~str) {\n     install_source(c, wd);\n }\n \n-fn install_file(c: &Cargo, wd: &Path, path: &Path) {\n+pub fn install_file(c: &Cargo, wd: &Path, path: &Path) {\n     run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n                                   ~\"-C\", wd.to_str(),\n                                   ~\"-f\", path.to_str()]);\n     install_source(c, wd);\n }\n \n-fn install_package(c: &Cargo, src: ~str, wd: &Path, pkg: Package) {\n+pub fn install_package(c: &Cargo, src: ~str, wd: &Path, pkg: Package) {\n     let url = copy pkg.url;\n     let method = match pkg.method {\n         ~\"git\" => ~\"git\",\n@@ -928,8 +921,7 @@ fn install_package(c: &Cargo, src: ~str, wd: &Path, pkg: Package) {\n     }\n }\n \n-fn cargo_suggestion(c: &Cargo, fallback: fn())\n-{\n+pub fn cargo_suggestion(c: &Cargo, fallback: fn()) {\n     if c.sources.size() == 0u {\n         error(~\"no sources defined - you may wish to run \" +\n               ~\"`cargo init`\");\n@@ -938,7 +930,7 @@ fn cargo_suggestion(c: &Cargo, fallback: fn())\n     fallback();\n }\n \n-fn install_uuid(c: &Cargo, wd: &Path, uuid: ~str) {\n+pub fn install_uuid(c: &Cargo, wd: &Path, uuid: ~str) {\n     let mut ps = ~[];\n     for_each_package(c, |s, p| {\n         if p.uuid == uuid {\n@@ -962,7 +954,7 @@ fn install_uuid(c: &Cargo, wd: &Path, uuid: ~str) {\n     }\n }\n \n-fn install_named(c: &Cargo, wd: &Path, name: ~str) {\n+pub fn install_named(c: &Cargo, wd: &Path, name: ~str) {\n     let mut ps = ~[];\n     for_each_package(c, |s, p| {\n         if p.name == name {\n@@ -986,7 +978,7 @@ fn install_named(c: &Cargo, wd: &Path, name: ~str) {\n     }\n }\n \n-fn install_uuid_specific(c: &Cargo, wd: &Path, src: ~str, uuid: ~str) {\n+pub fn install_uuid_specific(c: &Cargo, wd: &Path, src: ~str, uuid: ~str) {\n     match c.sources.find(src) {\n         Some(s) => {\n             for s.packages.each |p| {\n@@ -1001,7 +993,7 @@ fn install_uuid_specific(c: &Cargo, wd: &Path, src: ~str, uuid: ~str) {\n     error(~\"can't find package: \" + src + ~\"/\" + uuid);\n }\n \n-fn install_named_specific(c: &Cargo, wd: &Path, src: ~str, name: ~str) {\n+pub fn install_named_specific(c: &Cargo, wd: &Path, src: ~str, name: ~str) {\n     match c.sources.find(src) {\n         Some(s) => {\n             for s.packages.each |p| {\n@@ -1016,7 +1008,7 @@ fn install_named_specific(c: &Cargo, wd: &Path, src: ~str, name: ~str) {\n     error(~\"can't find package: \" + src + ~\"/\" + name);\n }\n \n-fn cmd_uninstall(c: &Cargo) {\n+pub fn cmd_uninstall(c: &Cargo) {\n     if vec::len(c.opts.free) < 3u {\n         cmd_usage();\n         return;\n@@ -1068,7 +1060,7 @@ fn cmd_uninstall(c: &Cargo) {\n     }\n }\n \n-fn install_query(c: &Cargo, wd: &Path, target: ~str) {\n+pub fn install_query(c: &Cargo, wd: &Path, target: ~str) {\n     match c.dep_cache.find(target) {\n         Some(inst) => {\n             if inst {\n@@ -1128,15 +1120,15 @@ fn install_query(c: &Cargo, wd: &Path, target: ~str) {\n     }\n }\n \n-fn get_temp_workdir(c: &Cargo) -> Path {\n+pub fn get_temp_workdir(c: &Cargo) -> Path {\n     match tempfile::mkdtemp(&c.workdir, \"cargo\") {\n       Some(wd) => wd,\n       None => fail fmt!(\"needed temp dir: %s\",\n                         c.workdir.to_str())\n     }\n }\n \n-fn cmd_install(c: &Cargo) {\n+pub fn cmd_install(c: &Cargo) {\n     unsafe {\n         let wd = get_temp_workdir(c);\n \n@@ -1162,15 +1154,15 @@ fn cmd_install(c: &Cargo) {\n     }\n }\n \n-fn sync(c: &Cargo) {\n+pub fn sync(c: &Cargo) {\n     for c.sources.each_key |k| {\n         let mut s = c.sources.get(k);\n         sync_one(c, s);\n         c.sources.insert(k, s);\n     }\n }\n \n-fn sync_one_file(c: &Cargo, dir: &Path, src: @Source) -> bool {\n+pub fn sync_one_file(c: &Cargo, dir: &Path, src: @Source) -> bool {\n     let name = src.name;\n     let srcfile = dir.push(\"source.json.new\");\n     let destsrcfile = dir.push(\"source.json\");\n@@ -1248,7 +1240,7 @@ fn sync_one_file(c: &Cargo, dir: &Path, src: @Source) -> bool {\n     return true;\n }\n \n-fn sync_one_git(c: &Cargo, dir: &Path, src: @Source) -> bool {\n+pub fn sync_one_git(c: &Cargo, dir: &Path, src: @Source) -> bool {\n     let name = src.name;\n     let srcfile = dir.push(\"source.json\");\n     let pkgfile = dir.push(\"packages.json\");\n@@ -1351,7 +1343,7 @@ fn sync_one_git(c: &Cargo, dir: &Path, src: @Source) -> bool {\n     return true;\n }\n \n-fn sync_one_curl(c: &Cargo, dir: &Path, src: @Source) -> bool {\n+pub fn sync_one_curl(c: &Cargo, dir: &Path, src: @Source) -> bool {\n     let name = src.name;\n     let srcfile = dir.push(\"source.json.new\");\n     let destsrcfile = dir.push(\"source.json\");\n@@ -1467,7 +1459,7 @@ fn sync_one_curl(c: &Cargo, dir: &Path, src: @Source) -> bool {\n     return true;\n }\n \n-fn sync_one(c: &Cargo, src: @Source) {\n+pub fn sync_one(c: &Cargo, src: @Source) {\n     let name = src.name;\n     let dir = c.sourcedir.push(name);\n \n@@ -1487,7 +1479,7 @@ fn sync_one(c: &Cargo, src: @Source) {\n     }\n }\n \n-fn cmd_init(c: &Cargo) {\n+pub fn cmd_init(c: &Cargo) {\n     let srcurl = ~\"http://www.rust-lang.org/cargo/sources.json\";\n     let sigurl = ~\"http://www.rust-lang.org/cargo/sources.json.sig\";\n \n@@ -1525,7 +1517,7 @@ fn cmd_init(c: &Cargo) {\n     info(fmt!(\"initialized .cargo in %s\", c.root.to_str()));\n }\n \n-fn print_pkg(s: @Source, p: &Package) {\n+pub fn print_pkg(s: @Source, p: &Package) {\n     let mut m = s.name + ~\"/\" + p.name + ~\" (\" + p.uuid + ~\")\";\n     if vec::len(p.tags) > 0u {\n         m = m + ~\" [\" + str::connect(p.tags, ~\", \") + ~\"]\";\n@@ -1536,7 +1528,7 @@ fn print_pkg(s: @Source, p: &Package) {\n     }\n }\n \n-fn print_source(s: @Source) {\n+pub fn print_source(s: @Source) {\n     info(s.name + ~\" (\" + s.url + ~\")\");\n \n     let pks = sort::merge_sort(s.packages.get(), sys::shape_lt);\n@@ -1557,7 +1549,7 @@ fn print_source(s: @Source) {\n     }));\n }\n \n-fn cmd_list(c: &Cargo) {\n+pub fn cmd_list(c: &Cargo) {\n     sync(c);\n \n     if vec::len(c.opts.free) >= 3u {\n@@ -1583,7 +1575,7 @@ fn cmd_list(c: &Cargo) {\n     }\n }\n \n-fn cmd_search(c: &Cargo) {\n+pub fn cmd_search(c: &Cargo) {\n     if vec::len(c.opts.free) < 3u {\n         cmd_usage();\n         return;\n@@ -1604,7 +1596,7 @@ fn cmd_search(c: &Cargo) {\n     info(fmt!(\"found %d packages\", n));\n }\n \n-fn install_to_dir(srcfile: &Path, destdir: &Path) {\n+pub fn install_to_dir(srcfile: &Path, destdir: &Path) {\n     let newfile = destdir.push(srcfile.filename().get());\n \n     let status = run::run_program(~\"cp\", ~[~\"-r\", srcfile.to_str(),\n@@ -1616,7 +1608,7 @@ fn install_to_dir(srcfile: &Path, destdir: &Path) {\n     }\n }\n \n-fn dump_cache(c: &Cargo) {\n+pub fn dump_cache(c: &Cargo) {\n     need_dir(&c.root);\n \n     let out = c.root.push(\"cache.json\");\n@@ -1626,7 +1618,8 @@ fn dump_cache(c: &Cargo) {\n         copy_warn(&out, &c.root.push(\"cache.json.old\"));\n     }\n }\n-fn dump_sources(c: &Cargo) {\n+\n+pub fn dump_sources(c: &Cargo) {\n     if c.sources.size() < 1u {\n         return;\n     }\n@@ -1673,14 +1666,14 @@ fn dump_sources(c: &Cargo) {\n     }\n }\n \n-fn copy_warn(srcfile: &Path, destfile: &Path) {\n+pub fn copy_warn(srcfile: &Path, destfile: &Path) {\n     if !os::copy_file(srcfile, destfile) {\n         warn(fmt!(\"copying %s to %s failed\",\n                   srcfile.to_str(), destfile.to_str()));\n     }\n }\n \n-fn cmd_sources(c: &Cargo) {\n+pub fn cmd_sources(c: &Cargo) {\n     if vec::len(c.opts.free) < 3u {\n         for c.sources.each_value |v| {\n             info(fmt!(\"%s (%s) via %s\",\n@@ -1845,7 +1838,7 @@ fn cmd_sources(c: &Cargo) {\n     }\n }\n \n-fn cmd_usage() {\n+pub fn cmd_usage() {\n     print(~\"Usage: cargo <cmd> [options] [args..]\n e.g. cargo install <name>\n \n@@ -1860,14 +1853,14 @@ Options:\n \");\n }\n \n-fn cmd_usage_init() {\n+pub fn cmd_usage_init() {\n     print(~\"cargo init\n \n Re-initialize cargo in ~/.cargo. Clears all sources and then adds the\n default sources from <www.rust-lang.org/sources.json>.\");\n }\n \n-fn cmd_usage_install() {\n+pub fn cmd_usage_install() {\n     print(~\"cargo install\n cargo install [source/]<name>[@version]\n cargo install [source/]<uuid>[@version]\n@@ -1886,7 +1879,7 @@ the current working directory. If a source is provided, only install\n from that source, otherwise it installs from any source.\");\n }\n \n-fn cmd_usage_uninstall() {\n+pub fn cmd_usage_uninstall() {\n     print(~\"cargo uninstall [source/]<name>[@version]\n cargo uninstall [source/]<uuid>[@version]\n cargo uninstall <meta-name>[@version]\n@@ -1903,21 +1896,21 @@ If a crate was installed directly (git, tarball, etc.), you can remove\n it by metadata.\");\n }\n \n-fn cmd_usage_list() {\n+pub fn cmd_usage_list() {\n     print(~\"cargo list [sources..]\n \n If no arguments are provided, list all sources and their packages.\n If source names are provided, list those sources and their packages.\n \");\n }\n \n-fn cmd_usage_search() {\n+pub fn cmd_usage_search() {\n     print(~\"cargo search <query | '*'> [tags..]\n \n Search packages.\");\n }\n \n-fn cmd_usage_sources() {\n+pub fn cmd_usage_sources() {\n     print(~\"cargo sources\n cargo sources add <name> <url>\n cargo sources remove <name>\n@@ -1936,7 +1929,7 @@ Commands:\n     set-method      Change the method for a source.\");\n }\n \n-fn main() {\n+pub fn main() {\n     let argv = os::args();\n     let o = build_cargo_options(argv);\n \n@@ -1987,3 +1980,4 @@ fn main() {\n     dump_cache(c);\n     dump_sources(c);\n }\n+"}, {"sha": "7eee0f9b96b15e419f4e760e92c8e5b08204ff39", "filename": "src/libcargo/pgp.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibcargo%2Fpgp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibcargo%2Fpgp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fpgp.rs?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -12,11 +12,11 @@ use core::os;\n use core::path::Path;\n use core::run;\n \n-fn gpgv(args: ~[~str]) -> { status: int, out: ~str, err: ~str } {\n+pub fn gpgv(args: ~[~str]) -> { status: int, out: ~str, err: ~str } {\n     return run::program_output(~\"gpgv\", args);\n }\n \n-fn signing_key() -> ~str {\n+pub fn signing_key() -> ~str {\n     ~\"\n -----BEGIN PGP PUBLIC KEY BLOCK-----\n Version: SKS 1.1.0\n@@ -68,16 +68,16 @@ HI1jilzwKSXuV2EmyBk3tKh9NwscT/A78pr30FxxPUg3v72raNgusTo=\n \"\n }\n \n-fn signing_key_fp() -> ~str {\n+pub fn signing_key_fp() -> ~str {\n     ~\"FE79 EDB0 3DEF B0D8 27D2  6C41 0B2D 6A28 3033 6376\"\n }\n \n-fn supported() -> bool {\n+pub fn supported() -> bool {\n     let r = gpgv(~[~\"--version\"]);\n     r.status == 0\n }\n \n-fn init(root: &Path) {\n+pub fn init(root: &Path) {\n     let p = root.push(\"gpg\");\n     if !os::path_is_dir(&p) {\n         os::make_dir(&p, 0x1c0i32);\n@@ -92,7 +92,7 @@ fn init(root: &Path) {\n     }\n }\n \n-fn add(root: &Path, key: &Path) {\n+pub fn add(root: &Path, key: &Path) {\n     let path = root.push(\"gpg\");\n     let p =\n         run::program_output(~\"gpg\", ~[~\"--homedir\", path.to_str(),\n@@ -102,7 +102,7 @@ fn add(root: &Path, key: &Path) {\n     }\n }\n \n-fn verify(root: &Path, data: &Path, sig: &Path) -> bool {\n+pub fn verify(root: &Path, data: &Path, sig: &Path) -> bool {\n     let path = root.push(\"gpg\");\n     let res = gpgv(~[~\"--homedir\", path.to_str(),\n                   ~\"--keyring\", ~\"pubring.gpg\","}, {"sha": "03b96e34e75826eabd80165d752bcb30f3bf185c", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 55, "deletions": 57, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -20,7 +20,6 @@\n #[no_core];\n \n #[legacy_modes];\n-#[legacy_exports];\n \n #[allow(vecs_implicitly_copyable)];\n #[allow(non_camel_case_types)];\n@@ -40,27 +39,22 @@ use syntax::parse;\n use syntax::print::pprust;\n use syntax::diagnostic;\n \n-enum test_mode { tm_converge, tm_run, }\n-struct Context { mode: test_mode } // + rng\n+#[deriving_eq]\n+pub enum test_mode { tm_converge, tm_run, }\n \n-impl test_mode : cmp::Eq {\n-    pure fn eq(&self, other: &test_mode) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &test_mode) -> bool { !(*self).eq(other) }\n-}\n+pub struct Context { mode: test_mode } // + rng\n \n-fn write_file(filename: &Path, content: ~str) {\n+pub fn write_file(filename: &Path, content: ~str) {\n     result::get(\n         &io::file_writer(filename, ~[io::Create, io::Truncate]))\n         .write_str(content);\n }\n \n-fn contains(haystack: ~str, needle: ~str) -> bool {\n+pub fn contains(haystack: ~str, needle: ~str) -> bool {\n     str::contains(haystack, needle)\n }\n \n-fn find_rust_files(files: &mut ~[Path], path: &Path) {\n+pub fn find_rust_files(files: &mut ~[Path], path: &Path) {\n     if path.filetype() == Some(~\".rs\") && !contains(path.to_str(), ~\"utf8\") {\n         // ignoring \"utf8\" tests because something is broken\n         files.push(*path);\n@@ -74,7 +68,7 @@ fn find_rust_files(files: &mut ~[Path], path: &Path) {\n }\n \n \n-fn common_exprs() -> ~[ast::expr] {\n+pub fn common_exprs() -> ~[ast::expr] {\n     fn dse(e: ast::expr_) -> ast::expr {\n         ast::expr {\n             id: 0,\n@@ -104,11 +98,11 @@ fn common_exprs() -> ~[ast::expr] {\n     ]\n }\n \n-pure fn safe_to_steal_expr(e: @ast::expr, tm: test_mode) -> bool {\n+pub pure fn safe_to_steal_expr(e: @ast::expr, tm: test_mode) -> bool {\n     safe_to_use_expr(*e, tm)\n }\n \n-pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n+pub pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n     match tm {\n       tm_converge => {\n         match e.node {\n@@ -142,33 +136,37 @@ pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n     }\n }\n \n-fn safe_to_steal_ty(t: @ast::Ty, tm: test_mode) -> bool {\n+pub fn safe_to_steal_ty(t: @ast::Ty, tm: test_mode) -> bool {\n     // Restrictions happen to be the same.\n     safe_to_replace_ty(t.node, tm)\n }\n \n // Not type-parameterized: https://github.com/mozilla/rust/issues/898 (FIXED)\n-fn stash_expr_if(c: fn@(@ast::expr, test_mode)->bool,\n-                 es: @mut ~[ast::expr],\n-                 e: @ast::expr,\n-                 tm: test_mode) {\n+pub fn stash_expr_if(c: fn@(@ast::expr, test_mode)->bool,\n+                     es: @mut ~[ast::expr],\n+                     e: @ast::expr,\n+                     tm: test_mode) {\n     if c(e, tm) {\n         *es += ~[*e];\n-    } else {/* now my indices are wrong :( */ }\n+    } else {\n+        /* now my indices are wrong :( */\n+    }\n }\n \n-fn stash_ty_if(c: fn@(@ast::Ty, test_mode)->bool,\n-               es: @mut ~[ast::Ty],\n-               e: @ast::Ty,\n-               tm: test_mode) {\n+pub fn stash_ty_if(c: fn@(@ast::Ty, test_mode)->bool,\n+                   es: @mut ~[ast::Ty],\n+                   e: @ast::Ty,\n+                   tm: test_mode) {\n     if c(e, tm) {\n         es.push(*e);\n-    } else {/* now my indices are wrong :( */ }\n+    } else {\n+        /* now my indices are wrong :( */\n+    }\n }\n \n-struct StolenStuff {exprs: ~[ast::expr], tys: ~[ast::Ty]}\n+pub struct StolenStuff {exprs: ~[ast::expr], tys: ~[ast::Ty]}\n \n-fn steal(crate: ast::crate, tm: test_mode) -> StolenStuff {\n+pub fn steal(crate: ast::crate, tm: test_mode) -> StolenStuff {\n     let exprs = @mut ~[];\n     let tys = @mut ~[];\n     let v = visit::mk_simple_visitor(@visit::SimpleVisitor {\n@@ -181,7 +179,7 @@ fn steal(crate: ast::crate, tm: test_mode) -> StolenStuff {\n }\n \n \n-fn safe_to_replace_expr(e: ast::expr_, _tm: test_mode) -> bool {\n+pub fn safe_to_replace_expr(e: ast::expr_, _tm: test_mode) -> bool {\n     match e {\n       // https://github.com/mozilla/rust/issues/652\n       ast::expr_if(*) => { false }\n@@ -194,7 +192,7 @@ fn safe_to_replace_expr(e: ast::expr_, _tm: test_mode) -> bool {\n     }\n }\n \n-fn safe_to_replace_ty(t: ast::ty_, _tm: test_mode) -> bool {\n+pub fn safe_to_replace_ty(t: ast::ty_, _tm: test_mode) -> bool {\n     match t {\n       ast::ty_infer => { false } // always implicit, always top level\n       ast::ty_bot => { false }   // in source, can only appear\n@@ -205,8 +203,8 @@ fn safe_to_replace_ty(t: ast::ty_, _tm: test_mode) -> bool {\n }\n \n // Replace the |i|th expr (in fold order) of |crate| with |newexpr|.\n-fn replace_expr_in_crate(crate: ast::crate, i: uint,\n-                         newexpr: ast::expr, tm: test_mode) ->\n+pub fn replace_expr_in_crate(crate: ast::crate, i: uint,\n+                             newexpr: ast::expr, tm: test_mode) ->\n    ast::crate {\n     let j: @mut uint = @mut 0u;\n     fn fold_expr_rep(j_: @mut uint, i_: uint, newexpr_: ast::expr_,\n@@ -233,8 +231,8 @@ fn replace_expr_in_crate(crate: ast::crate, i: uint,\n \n \n // Replace the |i|th ty (in fold order) of |crate| with |newty|.\n-fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n-                       tm: test_mode) -> ast::crate {\n+pub fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n+                           tm: test_mode) -> ast::crate {\n     let j: @mut uint = @mut 0u;\n     fn fold_ty_rep(j_: @mut uint, i_: uint, newty_: ast::ty_,\n                    original: ast::ty_, fld: fold::ast_fold,\n@@ -254,17 +252,17 @@ fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n     *crate2\n }\n \n-fn under(n: uint, it: fn(uint)) {\n+pub fn under(n: uint, it: fn(uint)) {\n     let mut i: uint = 0u;\n     while i < n { it(i); i += 1u; }\n }\n \n-fn as_str(f: fn@(+x: io::Writer)) -> ~str {\n+pub fn as_str(f: fn@(+x: io::Writer)) -> ~str {\n     io::with_str_writer(f)\n }\n \n-fn check_variants_of_ast(crate: ast::crate, codemap: @codemap::CodeMap,\n-                         filename: &Path, cx: Context) {\n+pub fn check_variants_of_ast(crate: ast::crate, codemap: @codemap::CodeMap,\n+                             filename: &Path, cx: Context) {\n     let stolen = steal(crate, cx.mode);\n     let extra_exprs = do common_exprs().filtered |a| {\n         safe_to_use_expr(*a, cx.mode)\n@@ -276,7 +274,7 @@ fn check_variants_of_ast(crate: ast::crate, codemap: @codemap::CodeMap,\n                      pprust::ty_to_str, replace_ty_in_crate, cx);\n }\n \n-fn check_variants_T<T: Copy>(\n+pub fn check_variants_T<T: Copy>(\n   crate: ast::crate,\n   codemap: @codemap::CodeMap,\n   filename: &Path,\n@@ -334,12 +332,12 @@ fn check_variants_T<T: Copy>(\n     }\n }\n \n-fn last_part(filename: ~str) -> ~str {\n+pub fn last_part(filename: ~str) -> ~str {\n   let ix = option::get(str::rfind_char(filename, '/'));\n   str::slice(filename, ix + 1u, str::len(filename) - 3u)\n }\n \n-enum happiness {\n+pub enum happiness {\n     passed,\n     cleanly_rejected(~str),\n     known_bug(~str),\n@@ -351,8 +349,8 @@ enum happiness {\n // - that would be tricky, requiring use of tasks or serialization\n //   or randomness.\n // This seems to find plenty of bugs as it is :)\n-fn check_whole_compiler(code: ~str, suggested_filename_prefix: &Path,\n-                        allow_running: bool) {\n+pub fn check_whole_compiler(code: ~str, suggested_filename_prefix: &Path,\n+                            allow_running: bool) {\n     let filename = &suggested_filename_prefix.with_filetype(\"rs\");\n     write_file(filename, code);\n \n@@ -376,19 +374,19 @@ fn check_whole_compiler(code: ~str, suggested_filename_prefix: &Path,\n     }\n }\n \n-fn removeIfExists(filename: &Path) {\n+pub fn removeIfExists(filename: &Path) {\n     // So sketchy!\n     assert !contains(filename.to_str(), ~\" \");\n     run::program_output(~\"bash\", ~[~\"-c\", ~\"rm \" + filename.to_str()]);\n }\n \n-fn removeDirIfExists(filename: &Path) {\n+pub fn removeDirIfExists(filename: &Path) {\n     // So sketchy!\n     assert !contains(filename.to_str(), ~\" \");\n     run::program_output(~\"bash\", ~[~\"-c\", ~\"rm -r \" + filename.to_str()]);\n }\n \n-fn check_running(exe_filename: &Path) -> happiness {\n+pub fn check_running(exe_filename: &Path) -> happiness {\n     let p = run::program_output(\n         ~\"/Users/jruderman/scripts/timed_run_rust_program.py\",\n         ~[exe_filename.to_str()]);\n@@ -427,7 +425,7 @@ fn check_running(exe_filename: &Path) -> happiness {\n     }\n }\n \n-fn check_compiling(filename: &Path) -> happiness {\n+pub fn check_compiling(filename: &Path) -> happiness {\n     let p = run::program_output(\n         ~\"/Users/jruderman/code/rust/build/x86_64-apple-darwin/\\\n          stage1/bin/rustc\",\n@@ -460,7 +458,7 @@ fn check_compiling(filename: &Path) -> happiness {\n }\n \n \n-fn parse_and_print(code: @~str) -> ~str {\n+pub fn parse_and_print(code: @~str) -> ~str {\n     let filename = Path(\"tmp.rs\");\n     let sess = parse::new_parse_sess(option::None);\n     write_file(&filename, *code);\n@@ -481,7 +479,7 @@ fn parse_and_print(code: @~str) -> ~str {\n     }\n }\n \n-fn has_raw_pointers(c: ast::crate) -> bool {\n+pub fn has_raw_pointers(c: ast::crate) -> bool {\n     let has_rp = @mut false;\n     fn visit_ty(flag: @mut bool, t: @ast::Ty) {\n         match t.node {\n@@ -497,7 +495,7 @@ fn has_raw_pointers(c: ast::crate) -> bool {\n     return *has_rp;\n }\n \n-fn content_is_dangerous_to_run(code: ~str) -> bool {\n+pub fn content_is_dangerous_to_run(code: ~str) -> bool {\n     let dangerous_patterns =\n         ~[~\"xfail-test\",\n          ~\"import\",  // espeically fs, run\n@@ -509,15 +507,15 @@ fn content_is_dangerous_to_run(code: ~str) -> bool {\n     return false;\n }\n \n-fn content_is_dangerous_to_compile(code: ~str) -> bool {\n+pub fn content_is_dangerous_to_compile(code: ~str) -> bool {\n     let dangerous_patterns =\n         ~[~\"xfail-test\"];\n \n     for dangerous_patterns.each |p| { if contains(code, *p) { return true; } }\n     return false;\n }\n \n-fn content_might_not_converge(code: ~str) -> bool {\n+pub fn content_might_not_converge(code: ~str) -> bool {\n     let confusing_patterns =\n         ~[~\"xfail-test\",\n          ~\"xfail-pretty\",\n@@ -533,7 +531,7 @@ fn content_might_not_converge(code: ~str) -> bool {\n     return false;\n }\n \n-fn file_might_not_converge(filename: &Path) -> bool {\n+pub fn file_might_not_converge(filename: &Path) -> bool {\n     let confusing_files = ~[\n       ~\"expr-alt.rs\", // pretty-printing \"(a = b) = c\"\n                      // vs \"a = b = c\" and wrapping\n@@ -552,7 +550,7 @@ fn file_might_not_converge(filename: &Path) -> bool {\n     return false;\n }\n \n-fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n+pub fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n \n     let mut i = 0u;\n     let mut newv = code;\n@@ -579,7 +577,7 @@ fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n     }\n }\n \n-fn check_convergence(files: &[Path]) {\n+pub fn check_convergence(files: &[Path]) {\n     error!(\"pp convergence tests: %u files\", vec::len(files));\n     for files.each |file| {\n         if !file_might_not_converge(file) {\n@@ -594,7 +592,7 @@ fn check_convergence(files: &[Path]) {\n     }\n }\n \n-fn check_variants(files: &[Path], cx: Context) {\n+pub fn check_variants(files: &[Path], cx: Context) {\n     for files.each |file| {\n         if cx.mode == tm_converge &&\n             file_might_not_converge(file) {\n@@ -639,7 +637,7 @@ fn check_variants(files: &[Path], cx: Context) {\n     }\n }\n \n-fn main() {\n+pub fn main() {\n     let args = os::args();\n     if vec::len(args) != 2u {\n         error!(\"usage: %s <testdir>\", args[0]);"}, {"sha": "4a046aaf50338d21ec7e99930c8cbc3ef71bcd28", "filename": "src/librustdoc/demo.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibrustdoc%2Fdemo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibrustdoc%2Fdemo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdemo.rs?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -75,7 +75,6 @@ fn take_my_order_please(\n }\n \n mod fortress_of_solitude {\n-    #[legacy_exports];\n     /*!\n      * Superman's vacation home\n      *\n@@ -90,7 +89,6 @@ mod fortress_of_solitude {\n }\n \n mod blade_runner {\n-    #[legacy_exports];\n     /*!\n      * Blade Runner is probably the best movie ever\n      *"}, {"sha": "b652c8d8eb4e474ecc5b351bf5a3d5689577813d", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -343,85 +343,83 @@ fn should_extract_struct_fields() {\n \n #[cfg(test)]\n mod test {\n-    #[legacy_exports];\n-\n     use astsrv;\n     use doc;\n     use extract::{extract, from_srv};\n     use parse;\n \n     use core::vec;\n \n-    fn mk_doc(+source: ~str) -> doc::Doc {\n+    pub fn mk_doc(+source: ~str) -> doc::Doc {\n         let ast = parse::from_str(source);\n         extract(ast, ~\"\")\n     }\n \n     #[test]\n-    fn extract_empty_crate() {\n+    pub fn extract_empty_crate() {\n         let doc = mk_doc(~\"\");\n         assert vec::is_empty(doc.cratemod().mods());\n         assert vec::is_empty(doc.cratemod().fns());\n     }\n \n     #[test]\n-    fn extract_mods() {\n+    pub fn extract_mods() {\n         let doc = mk_doc(~\"mod a { mod b { } mod c { } }\");\n         assert doc.cratemod().mods()[0].name() == ~\"a\";\n         assert doc.cratemod().mods()[0].mods()[0].name() == ~\"b\";\n         assert doc.cratemod().mods()[0].mods()[1].name() == ~\"c\";\n     }\n \n     #[test]\n-    fn extract_foreign_mods() {\n+    pub fn extract_foreign_mods() {\n         let doc = mk_doc(~\"extern mod a { }\");\n         assert doc.cratemod().nmods()[0].name() == ~\"a\";\n     }\n \n     #[test]\n-    fn extract_fns_from_foreign_mods() {\n+    pub fn extract_fns_from_foreign_mods() {\n         let doc = mk_doc(~\"extern mod a { fn a(); }\");\n         assert doc.cratemod().nmods()[0].fns[0].name() == ~\"a\";\n     }\n \n     #[test]\n-    fn extract_mods_deep() {\n+    pub fn extract_mods_deep() {\n         let doc = mk_doc(~\"mod a { mod b { mod c { } } }\");\n         assert doc.cratemod().mods()[0].mods()[0].mods()[0].name() == ~\"c\";\n     }\n \n     #[test]\n-    fn extract_should_set_mod_ast_id() {\n+    pub fn extract_should_set_mod_ast_id() {\n         let doc = mk_doc(~\"mod a { }\");\n         assert doc.cratemod().mods()[0].id() != 0;\n     }\n \n     #[test]\n-    fn extract_fns() {\n+    pub fn extract_fns() {\n         let doc = mk_doc(\n             ~\"fn a() { } \\\n              mod b {\n-                 #[legacy_exports]; fn c() { } }\");\n+             } }\");\n         assert doc.cratemod().fns()[0].name() == ~\"a\";\n         assert doc.cratemod().mods()[0].fns()[0].name() == ~\"c\";\n     }\n \n     #[test]\n-    fn extract_should_set_fn_ast_id() {\n+    pub fn extract_should_set_fn_ast_id() {\n         let doc = mk_doc(~\"fn a() { }\");\n         assert doc.cratemod().fns()[0].id() != 0;\n     }\n \n     #[test]\n-    fn extract_should_use_default_crate_name() {\n+    pub fn extract_should_use_default_crate_name() {\n         let source = ~\"\";\n         let ast = parse::from_str(source);\n         let doc = extract(ast, ~\"burp\");\n         assert doc.cratemod().name() == ~\"burp\";\n     }\n \n     #[test]\n-    fn extract_from_seq_srv() {\n+    pub fn extract_from_seq_srv() {\n         let source = ~\"\";\n         do astsrv::from_str(source) |srv| {\n             let doc = from_srv(srv, ~\"name\");"}, {"sha": "b908187953f71036e3c1ee90533dd865cb9c8f49", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -96,7 +96,7 @@ fn should_write_modules_last() {\n         ~\"mod a { }\\\n          fn b() { }\\\n          mod c {\n-             #[legacy_exports]; }\\\n+         }\\\n          fn d() { }\"\n     );\n \n@@ -371,7 +371,7 @@ fn should_write_sections() {\n          # Header\\n\\\n          Body\\\"]\\\n          mod a {\n-             #[legacy_exports]; }\");\n+         }\");\n     assert str::contains(markdown, ~\"#### Header\\n\\nBody\\n\\n\");\n }\n \n@@ -832,8 +832,6 @@ fn should_write_struct_header() {\n \n #[cfg(test)]\n mod test {\n-    #[legacy_exports];\n-\n     use astsrv;\n     use attr_pass;\n     use config;\n@@ -853,14 +851,14 @@ mod test {\n     use core::path::Path;\n     use core::str;\n \n-    fn render(+source: ~str) -> ~str {\n+    pub fn render(+source: ~str) -> ~str {\n         let (srv, doc) = create_doc_srv(source);\n         let markdown = write_markdown_str_srv(srv, doc);\n         debug!(\"markdown: %s\", markdown);\n         markdown\n     }\n \n-    fn create_doc_srv(+source: ~str) -> (astsrv::Srv, doc::Doc) {\n+    pub fn create_doc_srv(+source: ~str) -> (astsrv::Srv, doc::Doc) {\n         do astsrv::from_str(source) |srv| {\n \n             let config = config::Config {\n@@ -890,20 +888,20 @@ mod test {\n         }\n     }\n \n-    fn create_doc(+source: ~str) -> doc::Doc {\n+    pub fn create_doc(+source: ~str) -> doc::Doc {\n         let (_, doc) = create_doc_srv(source);\n         doc\n     }\n \n-    fn write_markdown_str(\n+    pub fn write_markdown_str(\n         +doc: doc::Doc\n     ) -> ~str {\n         let (writer_factory, po) = markdown_writer::future_writer_factory();\n         write_markdown(doc, move writer_factory);\n         return oldcomm::recv(po).second();\n     }\n \n-    fn write_markdown_str_srv(\n+    pub fn write_markdown_str_srv(\n         srv: astsrv::Srv,\n         +doc: doc::Doc\n     ) -> ~str {\n@@ -914,13 +912,13 @@ mod test {\n     }\n \n     #[test]\n-    fn write_markdown_should_write_mod_headers() {\n+    pub fn write_markdown_should_write_mod_headers() {\n         let markdown = render(~\"mod moo { }\");\n         assert str::contains(markdown, ~\"# Module `moo`\");\n     }\n \n     #[test]\n-    fn should_leave_blank_line_after_header() {\n+    pub fn should_leave_blank_line_after_header() {\n         let markdown = render(~\"mod morp { }\");\n         assert str::contains(markdown, ~\"Module `morp`\\n\\n\");\n     }"}, {"sha": "b1bc0ee9b28e087bc3b4ba0b1328980abdfb0c1f", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -272,14 +272,12 @@ fn should_name_mod_file_names_by_path() {\n \n #[cfg(test)]\n mod test {\n-    #[legacy_exports];\n-\n     use astsrv;\n     use doc;\n     use extract;\n     use path_pass;\n \n-    fn mk_doc(+name: ~str, +source: ~str) -> doc::Doc {\n+    pub fn mk_doc(+name: ~str, +source: ~str) -> doc::Doc {\n         do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, name);\n             let doc = (path_pass::mk_pass().f)(srv, doc);"}, {"sha": "4d6cb29f68df32ae1970ae3a26ca272aba0a2ff3", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -10,8 +10,6 @@\n \n //! Prune things that are private\n \n-#[legacy_exports];\n-\n use core::prelude::*;\n \n use astsrv;\n@@ -24,10 +22,7 @@ use core::util;\n use core::vec;\n use syntax::ast;\n \n-export mk_pass;\n-export run;\n-\n-fn mk_pass() -> Pass {\n+pub fn mk_pass() -> Pass {\n     Pass {\n         name: ~\"prune_private\",\n         f: run"}, {"sha": "7e7363802ed24c1569b362eb8b0716df82c2bda5", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -171,7 +171,7 @@ fn should_create_section_headers() {\n          # Header\\n\\\n          Body\\\"]\\\n          mod a {\n-             #[legacy_exports]; }\");\n+         }\");\n     assert str::contains(\n         doc.cratemod().mods()[0].item.sections[0].header,\n         ~\"Header\");\n@@ -184,7 +184,7 @@ fn should_create_section_bodies() {\n          # Header\\n\\\n          Body\\\"]\\\n          mod a {\n-             #[legacy_exports]; }\");\n+         }\");\n     assert str::contains(\n         doc.cratemod().mods()[0].item.sections[0].body,\n         ~\"Body\");\n@@ -197,7 +197,7 @@ fn should_not_create_sections_from_indented_headers() {\n          Text\\n             # Header\\n\\\n          Body\\\"]\\\n          mod a {\n-             #[legacy_exports]; }\");\n+         }\");\n     assert vec::is_empty(doc.cratemod().mods()[0].item.sections);\n }\n \n@@ -209,7 +209,7 @@ fn should_remove_section_text_from_main_desc() {\n          # Header\\n\\\n          Body\\\"]\\\n          mod a {\n-             #[legacy_exports]; }\");\n+         }\");\n     assert !str::contains(\n         doc.cratemod().mods()[0].desc().get(),\n         ~\"Header\");\n@@ -225,7 +225,7 @@ fn should_eliminate_desc_if_it_is_just_whitespace() {\n          # Header\\n\\\n          Body\\\"]\\\n          mod a {\n-             #[legacy_exports]; }\");\n+         }\");\n     assert doc.cratemod().mods()[0].desc() == None;\n }\n "}, {"sha": "ad737567d01708bbaac82837c9d1dcae5c118cfd", "filename": "src/librustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_type_pass.rs?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -46,7 +46,7 @@ fn test() {\n     let source =\n         ~\"mod imod { } \\\n          extern mod inmod {\n-             #[legacy_exports]; } \\\n+         } \\\n          const iconst: int = 0; \\\n          fn ifn() { } \\\n          enum ienum { ivar } \\"}, {"sha": "76a10dba33cccdf52256380ba861c54a13b706af", "filename": "src/librustdoc/trim_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibrustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ced67d0b6cccb0de8f3df133f7b580db6f74c5/src%2Flibrustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftrim_pass.rs?ref=83ced67d0b6cccb0de8f3df133f7b580db6f74c5", "patch": "@@ -31,7 +31,7 @@ pub fn mk_pass() -> Pass {\n fn should_trim_text() {\n     let doc = test::mk_doc(~\"#[doc = \\\" desc \\\"] \\\n                             mod m {\n-                                #[legacy_exports]; }\");\n+                            }\");\n     assert doc.cratemod().mods()[0].desc() == Some(~\"desc\");\n }\n "}]}