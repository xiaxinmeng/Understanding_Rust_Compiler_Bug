{"sha": "88866a4c20ebe150b9b72dc361653922f7d497dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4ODY2YTRjMjBlYmUxNTBiOWI3MmRjMzYxNjUzOTIyZjdkNDk3ZGQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-28T01:23:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-28T20:43:43Z"}, "message": "rustdoc: Show type parameters on external paths\n\nThis removes the internal type representation of an `External` type and instead\nrelies on passing around DefId structures and interpreting them accordingly.\n\nProgress on #9539, but there's still the problem of a crate => url mapping.", "tree": {"sha": "0d8e4fc1afeb80a7a78a3eb129e4797f61a80444", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d8e4fc1afeb80a7a78a3eb129e4797f61a80444"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88866a4c20ebe150b9b72dc361653922f7d497dd", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88866a4c20ebe150b9b72dc361653922f7d497dd", "html_url": "https://github.com/rust-lang/rust/commit/88866a4c20ebe150b9b72dc361653922f7d497dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88866a4c20ebe150b9b72dc361653922f7d497dd/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8973d7c3f5022fb6207a8137bd10ffd61fb747fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8973d7c3f5022fb6207a8137bd10ffd61fb747fd", "html_url": "https://github.com/rust-lang/rust/commit/8973d7c3f5022fb6207a8137bd10ffd61fb747fd"}], "stats": {"total": 93, "additions": 34, "deletions": 59}, "files": [{"sha": "d470d703581c10427958547ef50ba25853a4e1e2", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/88866a4c20ebe150b9b72dc361653922f7d497dd/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88866a4c20ebe150b9b72dc361653922f7d497dd/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=88866a4c20ebe150b9b72dc361653922f7d497dd", "patch": "@@ -540,9 +540,11 @@ impl Clean<TraitMethod> for ast::trait_method {\n #[deriving(Clone, Encodable, Decodable)]\n pub enum Type {\n     /// structs/enums/traits (anything that'd be an ast::ty_path)\n-    ResolvedPath { path: Path, typarams: Option<~[TyParamBound]>, id: ast::NodeId },\n-    /// Reference to an item in an external crate (fully qualified path)\n-    External(~str, ~str),\n+    ResolvedPath {\n+        path: Path,\n+        typarams: Option<~[TyParamBound]>,\n+        did: ast::DefId\n+    },\n     // I have no idea how to usefully use this.\n     TyParamBinder(ast::NodeId),\n     /// For parameterized types, so the consumer of the JSON don't go looking\n@@ -1148,39 +1150,7 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n         },\n         x => fail!(\"resolved type maps to a weird def %?\", x),\n     };\n-\n-    if def_id.crate != ast::CRATE_NODE_ID {\n-        use rustc::metadata::decoder::*;\n-\n-        let sess = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess;\n-        let cratedata = ::rustc::metadata::cstore::get_crate_data(sess.cstore, def_id.crate);\n-        let doc = lookup_item(def_id.node, cratedata.data);\n-        let path = syntax::ast_map::path_to_str_with_sep(item_path(doc), \"::\", sess.intr());\n-        let ty = match def_like_to_def(item_to_def_like(doc, def_id, def_id.crate)) {\n-            DefFn(*) => ~\"fn\",\n-            DefTy(*) => ~\"enum\",\n-            DefTrait(*) => ~\"trait\",\n-            DefPrimTy(p) => match p {\n-                ty_str => ~\"str\",\n-                ty_bool => ~\"bool\",\n-                ty_int(t) => match t.to_str() {\n-                    ~\"\" => ~\"i\",\n-                    s => s\n-                },\n-                ty_uint(t) => t.to_str(),\n-                ty_float(t) => t.to_str(),\n-                ty_char => ~\"char\",\n-            },\n-            DefTyParam(*) => ~\"generic\",\n-            DefStruct(*) => ~\"struct\",\n-            DefTyParamBinder(*) => ~\"typaram_binder\",\n-            x => fail!(\"resolved external maps to a weird def %?\", x),\n-        };\n-        let cname = cratedata.name.to_owned();\n-        External(cname + \"::\" + path, ty)\n-    } else {\n-        ResolvedPath {path: path.clone(), typarams: tpbs, id: def_id.node}\n-    }\n+    ResolvedPath{ path: path, typarams: tpbs, did: def_id }\n }\n \n fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {"}, {"sha": "66796252770d4adb04048d016657f25cb40c68db", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/88866a4c20ebe150b9b72dc361653922f7d497dd/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88866a4c20ebe150b9b72dc361653922f7d497dd/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=88866a4c20ebe150b9b72dc361653922f7d497dd", "patch": "@@ -97,7 +97,7 @@ impl fmt::Default for clean::Path {\n     }\n }\n \n-fn resolved_path(w: &mut io::Writer, id: ast::NodeId,\n+fn resolved_path(w: &mut io::Writer, did: ast::DefId,\n                  path: &clean::Path, print_all: bool) {\n     // The generics will get written to both the title and link\n     let mut generics = ~\"\";\n@@ -144,9 +144,10 @@ fn resolved_path(w: &mut io::Writer, id: ast::NodeId,\n \n         do local_data::get(cache_key) |cache| {\n             do cache.unwrap().read |cache| {\n-                match cache.paths.find(&id) {\n+                match cache.paths.find(&did.node) {\n                     // This is a documented path, link to it!\n-                    Some(&(ref fqp, shortty)) => {\n+                    // FIXME(#9539): this is_local check should not exist\n+                    Some(&(ref fqp, shortty)) if ast_util::is_local(did) => {\n                         let fqn = fqp.connect(\"::\");\n                         let same = loc.iter().zip(fqp.iter())\n                                       .take_while(|&(a, b)| *a == *b).len();\n@@ -180,7 +181,7 @@ fn resolved_path(w: &mut io::Writer, id: ast::NodeId,\n                         write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>{}\",\n                                shortty, url, fqn, last.name, generics);\n                     }\n-                    None => {\n+                    _ => {\n                         if print_all {\n                             let amt = path.segments.len() - 1;\n                             for seg in path.segments.iter().take(amt) {\n@@ -205,8 +206,8 @@ impl fmt::Default for clean::Type {\n                     }\n                 }\n             }\n-            clean::ResolvedPath{id, typarams: ref typarams, path: ref path} => {\n-                resolved_path(f.buf, id, path, false);\n+            clean::ResolvedPath{did, typarams: ref typarams, path: ref path} => {\n+                resolved_path(f.buf, did, path, false);\n                 match *typarams {\n                     Some(ref params) => {\n                         f.buf.write(\"&lt;\".as_bytes());\n@@ -219,10 +220,6 @@ impl fmt::Default for clean::Type {\n                     None => {}\n                 }\n             }\n-            // XXX: this should be a link\n-            clean::External(ref a, _) => {\n-                write!(f.buf, \"{}\", *a);\n-            }\n             clean::Self(*) => f.buf.write(\"Self\".as_bytes()),\n             clean::Primitive(prim) => {\n                 let s = match prim {\n@@ -421,8 +418,8 @@ impl fmt::Default for clean::ViewPath {\n impl fmt::Default for clean::ImportSource {\n     fn fmt(v: &clean::ImportSource, f: &mut fmt::Formatter) {\n         match v.did {\n-            Some(did) if ast_util::is_local(did) => {\n-                resolved_path(f.buf, did.node, &v.path, true);\n+            Some(did) => {\n+                resolved_path(f.buf, did, &v.path, true);\n             }\n             _ => {\n                 for (i, seg) in v.path.segments.iter().enumerate() {\n@@ -437,7 +434,7 @@ impl fmt::Default for clean::ImportSource {\n impl fmt::Default for clean::ViewListIdent {\n     fn fmt(v: &clean::ViewListIdent, f: &mut fmt::Formatter) {\n         match v.source {\n-            Some(did) if ast_util::is_local(did) => {\n+            Some(did) => {\n                 let path = clean::Path {\n                     global: false,\n                     segments: ~[clean::PathSegment {\n@@ -446,7 +443,7 @@ impl fmt::Default for clean::ViewListIdent {\n                         types: ~[],\n                     }]\n                 };\n-                resolved_path(f.buf, did.node, &path, false);\n+                resolved_path(f.buf, did, &path, false);\n             }\n             _ => write!(f.buf, \"{}\", v.name),\n         }"}, {"sha": "f5f67ad750b66fd10716cdc56167abc61edb3be9", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/88866a4c20ebe150b9b72dc361653922f7d497dd/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88866a4c20ebe150b9b72dc361653922f7d497dd/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=88866a4c20ebe150b9b72dc361653922f7d497dd", "patch": "@@ -30,6 +30,7 @@ use extra::json::ToJson;\n use extra::sort;\n \n use syntax::ast;\n+use syntax::ast_util::is_local;\n use syntax::attr;\n \n use clean;\n@@ -325,7 +326,8 @@ impl DocFolder for Cache {\n         match item.inner {\n             clean::ImplItem(ref i) => {\n                 match i.trait_ {\n-                    Some(clean::ResolvedPath{ id, _ }) => {\n+                    Some(clean::ResolvedPath{ did, _ }) if is_local(did) => {\n+                        let id = did.node;\n                         let v = do self.implementors.find_or_insert_with(id) |_|{\n                             ~[]\n                         };\n@@ -412,8 +414,8 @@ impl DocFolder for Cache {\n             }\n             clean::ImplItem(ref i) => {\n                 match i.for_ {\n-                    clean::ResolvedPath{ id, _ } => {\n-                        self.parent_stack.push(id); true\n+                    clean::ResolvedPath{ did, _ } if is_local(did) => {\n+                        self.parent_stack.push(did.node); true\n                     }\n                     _ => false\n                 }\n@@ -428,7 +430,8 @@ impl DocFolder for Cache {\n                 match item.inner {\n                     clean::ImplItem(i) => {\n                         match i.for_ {\n-                            clean::ResolvedPath { id, _ } => {\n+                            clean::ResolvedPath { did, _ } if is_local(did) => {\n+                                let id = did.node;\n                                 let v = do self.impls.find_or_insert_with(id) |_| {\n                                     ~[]\n                                 };\n@@ -1179,7 +1182,7 @@ fn render_impl(w: &mut io::Writer, i: &clean::Impl) {\n         Some(ref ty) => {\n             write!(w, \"{} for \", *ty);\n             match *ty {\n-                clean::ResolvedPath { id, _ } => Some(id),\n+                clean::ResolvedPath { did, _ } => Some(did),\n                 _ => None,\n             }\n         }\n@@ -1201,7 +1204,11 @@ fn render_impl(w: &mut io::Writer, i: &clean::Impl) {\n         }\n \n         // No documentation? Attempt to slurp in the trait's documentation\n-        let trait_id = match trait_id { Some(id) => id, None => loop };\n+        let trait_id = match trait_id {\n+            None => loop,\n+            Some(id) if is_local(id) => loop,\n+            Some(id) => id.node,\n+        };\n         do local_data::get(cache_key) |cache| {\n             do cache.unwrap().read |cache| {\n                 let name = meth.name.get_ref().as_slice();\n@@ -1307,7 +1314,7 @@ impl<'self> fmt::Default for Source<'self> {\n         }\n         write!(fmt.buf, \"<pre class='line-numbers'>\");\n         for i in range(1, lines + 1) {\n-            write!(fmt.buf, \"<span id='{0}'>{0:1$u}</span>\\n\", i, cols);\n+            write!(fmt.buf, \"<span id='{0:u}'>{0:1$u}</span>\\n\", i, cols);\n         }\n         write!(fmt.buf, \"</pre>\");\n         write!(fmt.buf, \"<pre class='rust'>\");"}, {"sha": "bbb20b31272ad8b9cf03707416d1612841d76e7b", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/88866a4c20ebe150b9b72dc361653922f7d497dd/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88866a4c20ebe150b9b72dc361653922f7d497dd/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=88866a4c20ebe150b9b72dc361653922f7d497dd", "patch": "@@ -13,6 +13,7 @@ use std::uint;\n use std::hashmap::HashSet;\n \n use syntax::ast;\n+use syntax::ast_util::is_local;\n \n use clean;\n use clean::Item;\n@@ -130,8 +131,8 @@ pub fn strip_private(mut crate: clean::Crate) -> plugins::PluginResult {\n             match i.inner {\n                 clean::ImplItem(ref imp) => {\n                     match imp.trait_ {\n-                        Some(clean::ResolvedPath{ id, _ }) => {\n-                            if !self.contains(&id) {\n+                        Some(clean::ResolvedPath{ did, _ }) => {\n+                            if is_local(did) && !self.contains(&did.node) {\n                                 return None;\n                             }\n                         }"}]}