{"sha": "e057a156f286328430c6a75fc9909d5102f164e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwNTdhMTU2ZjI4NjMyODQzMGM2YTc1ZmM5OTA5ZDUxMDJmMTY0ZTk=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-17T11:49:12Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-17T11:49:16Z"}, "message": "Shorten ty_to_repr(ty).size() to ty_size(ty).", "tree": {"sha": "0b8b355ff6cf297acedb6e3969a41ff65bb1fe12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b8b355ff6cf297acedb6e3969a41ff65bb1fe12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e057a156f286328430c6a75fc9909d5102f164e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e057a156f286328430c6a75fc9909d5102f164e9", "html_url": "https://github.com/rust-lang/rust/commit/e057a156f286328430c6a75fc9909d5102f164e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e057a156f286328430c6a75fc9909d5102f164e9/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49a26b93ca07f32d22713387c0f379862eacee30", "url": "https://api.github.com/repos/rust-lang/rust/commits/49a26b93ca07f32d22713387c0f379862eacee30", "html_url": "https://github.com/rust-lang/rust/commit/49a26b93ca07f32d22713387c0f379862eacee30"}], "stats": {"total": 86, "additions": 45, "deletions": 41}, "files": [{"sha": "cde232e419e444edb4ea0307fff1d519d859417c", "filename": "src/interpreter.rs", "status": "modified", "additions": 45, "deletions": 41, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e057a156f286328430c6a75fc9909d5102f164e9/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e057a156f286328430c6a75fc9909d5102f164e9/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=e057a156f286328430c6a75fc9909d5102f164e9", "patch": "@@ -155,7 +155,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n         let mut locals = Vec::with_capacity(num_args + num_vars + num_temps);\n \n         for (arg_decl, arg_operand) in mir.arg_decls.iter().zip(args) {\n-            let size = self.ty_to_repr(arg_decl.ty).size();\n+            let size = self.ty_size(arg_decl.ty);\n             let dest = self.memory.allocate(size);\n             let src = try!(self.eval_operand(arg_operand));\n             try!(self.memory.copy(src, dest, size));\n@@ -165,7 +165,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n         let var_tys = mir.var_decls.iter().map(|v| v.ty);\n         let temp_tys = mir.temp_decls.iter().map(|t| t.ty);\n         locals.extend(var_tys.chain(temp_tys).map(|ty| {\n-            let size = self.ty_to_repr(ty).size();\n+            let size = self.ty_size(ty);\n             self.memory.allocate(size)\n         }));\n \n@@ -255,13 +255,13 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                                 match &self.tcx.item_name(def_id).as_str()[..] {\n                                     \"size_of\" => {\n                                         let ty = *substs.types.get(subst::FnSpace, 0);\n-                                        let size = self.ty_to_repr(ty).size() as u64;\n+                                        let size = self.ty_size(ty) as u64;\n                                         try!(self.memory.write_uint(dest, size, dest_repr.size()));\n                                     }\n \n                                     \"offset\" => {\n                                         let pointee_ty = *substs.types.get(subst::FnSpace, 0);\n-                                        let pointee_size = self.ty_to_repr(pointee_ty).size() as isize;\n+                                        let pointee_size = self.ty_size(pointee_ty) as isize;\n                                         let ptr_arg = try!(self.eval_operand(&args[0]));\n                                         let offset_arg = try!(self.eval_operand(&args[1]));\n                                         let ptr = try!(self.memory.read_ptr(ptr_arg));\n@@ -397,7 +397,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n             }\n \n             Box(ty) => {\n-                let size = self.ty_to_repr(ty).size();\n+                let size = self.ty_size(ty);\n                 let ptr = self.memory.allocate(size);\n                 self.memory.write_ptr(dest, ptr)\n             }\n@@ -561,40 +561,8 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n         }\n     }\n \n-    fn make_aggregate_repr<V>(&self, variant_fields: V) -> Repr\n-        where V: IntoIterator, V::Item: IntoIterator<Item = ty::Ty<'tcx>>\n-    {\n-        let mut variants = Vec::new();\n-        let mut max_variant_size = 0;\n-\n-        for field_tys in variant_fields {\n-            let mut fields = Vec::new();\n-            let mut size = 0;\n-\n-            for ty in field_tys {\n-                let field_size = self.ty_to_repr(ty).size();\n-                let offest = size;\n-                size += field_size;\n-                fields.push(FieldRepr { offset: offest, size: field_size });\n-            }\n-\n-            if size > max_variant_size { max_variant_size = size; }\n-            variants.push(fields);\n-        }\n-\n-        let discr_size = match variants.len() {\n-            n if n <= 1       => 0,\n-            n if n <= 1 << 8  => 1,\n-            n if n <= 1 << 16 => 2,\n-            n if n <= 1 << 32 => 4,\n-            _                 => 8,\n-        };\n-        Repr::Aggregate {\n-            discr_size: discr_size,\n-            size: max_variant_size + discr_size,\n-            variants: variants,\n-        }\n-\n+    fn ty_size(&self, ty: ty::Ty<'tcx>) -> usize {\n+        self.ty_to_repr(ty).size()\n     }\n \n     fn ty_to_repr(&self, ty: ty::Ty<'tcx>) -> &'arena Repr {\n@@ -630,7 +598,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n             }\n \n             ty::TyArray(ref elem_ty, length) => Repr::Array {\n-                elem_size: self.ty_to_repr(elem_ty).size(),\n+                elem_size: self.ty_size(elem_ty),\n                 length: length,\n             },\n \n@@ -652,6 +620,42 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n         repr_ref\n     }\n \n+    fn make_aggregate_repr<V>(&self, variant_fields: V) -> Repr\n+        where V: IntoIterator, V::Item: IntoIterator<Item = ty::Ty<'tcx>>\n+    {\n+        let mut variants = Vec::new();\n+        let mut max_variant_size = 0;\n+\n+        for field_tys in variant_fields {\n+            let mut fields = Vec::new();\n+            let mut size = 0;\n+\n+            for ty in field_tys {\n+                let field_size = self.ty_size(ty);\n+                let offest = size;\n+                size += field_size;\n+                fields.push(FieldRepr { offset: offest, size: field_size });\n+            }\n+\n+            if size > max_variant_size { max_variant_size = size; }\n+            variants.push(fields);\n+        }\n+\n+        let discr_size = match variants.len() {\n+            n if n <= 1       => 0,\n+            n if n <= 1 << 8  => 1,\n+            n if n <= 1 << 16 => 2,\n+            n if n <= 1 << 32 => 4,\n+            _                 => 8,\n+        };\n+        Repr::Aggregate {\n+            discr_size: discr_size,\n+            size: max_variant_size + discr_size,\n+            variants: variants,\n+        }\n+\n+    }\n+\n     fn current_frame(&self) -> &Frame<'a, 'tcx> {\n         self.stack.last().expect(\"no call frames exist\")\n     }\n@@ -805,7 +809,7 @@ pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>)\n                 let mut miri = Interpreter::new(tcx, mir_map, &repr_arena);\n                 let return_ptr = match mir.return_ty {\n                     ty::FnConverging(ty) => {\n-                        let size = miri.ty_to_repr(ty).size();\n+                        let size = miri.ty_size(ty);\n                         Some(miri.memory.allocate(size))\n                     }\n                     ty::FnDiverging => None,"}]}