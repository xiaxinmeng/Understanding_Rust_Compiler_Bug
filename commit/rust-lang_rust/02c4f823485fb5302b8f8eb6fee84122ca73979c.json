{"sha": "02c4f823485fb5302b8f8eb6fee84122ca73979c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyYzRmODIzNDg1ZmI1MzAyYjhmOGViNmZlZTg0MTIyY2E3Mzk3OWM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-21T08:16:46Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-21T08:16:46Z"}, "message": "simple test for item map", "tree": {"sha": "48a495152b3aad1183c5f74419c61748f26c64e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48a495152b3aad1183c5f74419c61748f26c64e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02c4f823485fb5302b8f8eb6fee84122ca73979c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02c4f823485fb5302b8f8eb6fee84122ca73979c", "html_url": "https://github.com/rust-lang/rust/commit/02c4f823485fb5302b8f8eb6fee84122ca73979c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02c4f823485fb5302b8f8eb6fee84122ca73979c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36aad851383c7fd1ca5ffaa99ba8cc96b85378c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/36aad851383c7fd1ca5ffaa99ba8cc96b85378c1", "html_url": "https://github.com/rust-lang/rust/commit/36aad851383c7fd1ca5ffaa99ba8cc96b85378c1"}], "stats": {"total": 135, "additions": 118, "deletions": 17}, "files": [{"sha": "9a5cd4b247ca84f3628c796e07ef0f3f97b5670a", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02c4f823485fb5302b8f8eb6fee84122ca73979c/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c4f823485fb5302b8f8eb6fee84122ca73979c/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=02c4f823485fb5302b8f8eb6fee84122ca73979c", "patch": "@@ -8,7 +8,7 @@ use crate::{\n     db,\n     descriptors::{\n         DescriptorDatabase, FnScopesQuery, FnSyntaxQuery, ModuleScopeQuery, ModuleTreeQuery,\n-        SubmodulesQuery, ItemMapQuery,\n+        SubmodulesQuery, ItemMapQuery, InputModuleItemsQuery,\n     },\n     symbol_index::SymbolIndex,\n     syntax_ptr::SyntaxPtr,\n@@ -86,6 +86,7 @@ salsa::database_storage! {\n         impl DescriptorDatabase {\n             fn module_tree() for ModuleTreeQuery;\n             fn fn_scopes() for FnScopesQuery;\n+            fn _input_module_items() for InputModuleItemsQuery;\n             fn _item_map() for ItemMapQuery;\n             fn _module_scope() for ModuleScopeQuery;\n             fn _fn_syntax() for FnSyntaxQuery;"}, {"sha": "a32042b846b1f1b4c263fdf65465294e6420ebea", "filename": "crates/ra_analysis/src/descriptors/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02c4f823485fb5302b8f8eb6fee84122ca73979c/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c4f823485fb5302b8f8eb6fee84122ca73979c/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs?ref=02c4f823485fb5302b8f8eb6fee84122ca73979c", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::{\n use crate::{\n     db::SyntaxDatabase,\n     descriptors::function::{resolve_local_name, FnId, FnScopes},\n-    descriptors::module::{ModuleId, ModuleScope, ModuleTree, ModuleSource, nameres::ItemMap},\n+    descriptors::module::{ModuleId, ModuleScope, ModuleTree, ModuleSource, nameres::{ItemMap, InputModuleItems}},\n     input::SourceRootId,\n     loc2id::IdDatabase,\n     syntax_ptr::LocalSyntaxPtr,\n@@ -25,6 +25,10 @@ salsa::query_group! {\n             use fn function::imp::fn_scopes;\n         }\n \n+        fn _input_module_items(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<InputModuleItems>> {\n+            type InputModuleItemsQuery;\n+            use fn module::nameres::input_module_items;\n+        }\n         fn _item_map(source_root_id: SourceRootId) -> Cancelable<Arc<ItemMap>> {\n             type ItemMapQuery;\n             use fn module::nameres::item_map;"}, {"sha": "95d9bcc279b96ea983c3edc54c00fcc6bcde93d6", "filename": "crates/ra_analysis/src/descriptors/module/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02c4f823485fb5302b8f8eb6fee84122ca73979c/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c4f823485fb5302b8f8eb6fee84122ca73979c/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs?ref=02c4f823485fb5302b8f8eb6fee84122ca73979c", "patch": "@@ -149,6 +149,13 @@ pub(crate) struct ModuleTree {\n }\n \n impl ModuleTree {\n+    fn modules<'a>(&'a self) -> impl Iterator<Item = ModuleId> + 'a {\n+        self.mods\n+            .iter()\n+            .enumerate()\n+            .map(|(idx, _)| ModuleId(idx as u32))\n+    }\n+\n     fn modules_for_source(&self, source: ModuleSource) -> Vec<ModuleId> {\n         self.mods\n             .iter()"}, {"sha": "2fae93c9db30f65f9e7ba0a20f91a3cc88b40633", "filename": "crates/ra_analysis/src/descriptors/module/nameres.rs", "status": "modified", "additions": 104, "deletions": 15, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/02c4f823485fb5302b8f8eb6fee84122ca73979c/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c4f823485fb5302b8f8eb6fee84122ca73979c/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fnameres.rs?ref=02c4f823485fb5302b8f8eb6fee84122ca73979c", "patch": "@@ -5,17 +5,17 @@ use rustc_hash::FxHashMap;\n \n use ra_syntax::{\n     SmolStr, SyntaxKind::{self, *},\n-    ast::{self, NameOwner, AstNode}\n+    ast::{self, NameOwner, AstNode, ModuleItemOwner}\n };\n \n use crate::{\n     Cancelable,\n     loc2id::{DefId, DefLoc},\n     descriptors::{\n         DescriptorDatabase,\n-        module::{ModuleId, ModuleTree},\n+        module::{ModuleId, ModuleTree, ModuleSourceNode},\n     },\n-    syntax_ptr::{LocalSyntaxPtr, SyntaxPtr},\n+    syntax_ptr::{LocalSyntaxPtr},\n     input::SourceRootId,\n };\n \n@@ -25,37 +25,79 @@ use crate::{\n /// This stands in-between raw syntax and name resolution and alow us to avoid\n /// recomputing name res: if `InputModuleItems` are the same, we can avoid\n /// running name resolution.\n-#[derive(Debug, Default)]\n-struct InputModuleItems {\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub(crate) struct InputModuleItems {\n     items: Vec<ModuleItem>,\n     glob_imports: Vec<Path>,\n     imports: Vec<Path>,\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n struct Path {\n     kind: PathKind,\n     segments: Vec<(LocalSyntaxPtr, SmolStr)>,\n }\n \n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n enum PathKind {\n     Abs,\n     Self_,\n     Super,\n     Crate,\n }\n \n+pub(crate) fn input_module_items(\n+    db: &impl DescriptorDatabase,\n+    source_root: SourceRootId,\n+    module_id: ModuleId,\n+) -> Cancelable<Arc<InputModuleItems>> {\n+    let module_tree = db._module_tree(source_root)?;\n+    let source = module_id.source(&module_tree);\n+    let res = match source.resolve(db) {\n+        ModuleSourceNode::SourceFile(it) => {\n+            let items = it.borrowed().items();\n+            InputModuleItems::new(items)\n+        }\n+        ModuleSourceNode::Module(it) => {\n+            let items = it\n+                .borrowed()\n+                .item_list()\n+                .into_iter()\n+                .flat_map(|it| it.items());\n+            InputModuleItems::new(items)\n+        }\n+    };\n+    Ok(Arc::new(res))\n+}\n+\n pub(crate) fn item_map(\n     db: &impl DescriptorDatabase,\n     source_root: SourceRootId,\n ) -> Cancelable<Arc<ItemMap>> {\n-    unimplemented!()\n+    let module_tree = db._module_tree(source_root)?;\n+    let input = module_tree\n+        .modules()\n+        .map(|id| {\n+            let items = db._input_module_items(source_root, id)?;\n+            Ok((id, items))\n+        })\n+        .collect::<Cancelable<FxHashMap<_, _>>>()?;\n+\n+    let mut resolver = Resolver {\n+        db: db,\n+        input: &input,\n+        source_root,\n+        module_tree,\n+        result: ItemMap::default(),\n+    };\n+    resolver.resolve()?;\n+    let res = resolver.result;\n+    Ok(Arc::new(res))\n }\n \n /// Item map is the result of the name resolution. Item map contains, for each\n /// module, the set of visible items.\n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Default, Debug, PartialEq, Eq)]\n pub(crate) struct ItemMap {\n     per_module: FxHashMap<ModuleId, ModuleItems>,\n }\n@@ -86,15 +128,15 @@ struct PerNs<T> {\n     values: Option<T>,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, PartialEq, Eq)]\n struct ModuleItem {\n     ptr: LocalSyntaxPtr,\n     name: SmolStr,\n     kind: SyntaxKind,\n     vis: Vis,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, PartialEq, Eq)]\n enum Vis {\n     Priv,\n     Other,\n@@ -116,11 +158,13 @@ impl InputModuleItems {\n             ast::ModuleItem::FnDef(it) => self.items.push(ModuleItem::new(it)?),\n             ast::ModuleItem::TraitDef(it) => self.items.push(ModuleItem::new(it)?),\n             ast::ModuleItem::TypeDef(it) => self.items.push(ModuleItem::new(it)?),\n-            ast::ModuleItem::ImplItem(it) => {\n+            ast::ModuleItem::ImplItem(_) => {\n                 // impls don't define items\n             }\n             ast::ModuleItem::UseItem(it) => self.add_use_item(it),\n-            ast::ModuleItem::ExternCrateItem(it) => (),\n+            ast::ModuleItem::ExternCrateItem(_) => {\n+                // TODO\n+            }\n             ast::ModuleItem::ConstDef(it) => self.items.push(ModuleItem::new(it)?),\n             ast::ModuleItem::StaticDef(it) => self.items.push(ModuleItem::new(it)?),\n             ast::ModuleItem::Module(it) => self.items.push(ModuleItem::new(it)?),\n@@ -227,7 +271,7 @@ impl ModuleItem {\n \n struct Resolver<'a, DB> {\n     db: &'a DB,\n-    input: &'a FxHashMap<ModuleId, InputModuleItems>,\n+    input: &'a FxHashMap<ModuleId, Arc<InputModuleItems>>,\n     source_root: SourceRootId,\n     module_tree: Arc<ModuleTree>,\n     result: ItemMap,\n@@ -237,14 +281,16 @@ impl<'a, DB> Resolver<'a, DB>\n where\n     DB: DescriptorDatabase,\n {\n-    fn resolve(&mut self) {\n+    fn resolve(&mut self) -> Cancelable<()> {\n         for (&module_id, items) in self.input.iter() {\n             self.populate_module(module_id, items)\n         }\n \n         for &module_id in self.input.keys() {\n+            crate::db::check_canceled(self.db)?;\n             self.resolve_imports(module_id);\n         }\n+        Ok(())\n     }\n \n     fn populate_module(&mut self, module_id: ModuleId, input: &InputModuleItems) {\n@@ -346,3 +392,46 @@ where\n         f(module_items)\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        mock_analysis::analysis_and_position,\n+        descriptors::{DescriptorDatabase, module::ModuleDescriptor},\n+        input::FilesDatabase,\n+};\n+    use super::*;\n+\n+    fn item_map(fixture: &str) -> (Arc<ItemMap>, ModuleId) {\n+        let (analysis, pos) = analysis_and_position(fixture);\n+        let db = analysis.imp.db;\n+        let source_root = db.file_source_root(pos.file_id);\n+        let descr = ModuleDescriptor::guess_from_position(&*db, pos)\n+            .unwrap()\n+            .unwrap();\n+        let module_id = descr.module_id;\n+        (db._item_map(source_root).unwrap(), module_id)\n+    }\n+\n+    #[test]\n+    fn test_item_map() {\n+        let (item_map, module_id) = item_map(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+\n+            use crate::foo::bar::Baz;\n+            <|>\n+\n+            //- /foo/mod.rs\n+            pub mod bar;\n+\n+            //- /foo/bar.rs\n+            pub struct Baz;\n+        \",\n+        );\n+        let name = SmolStr::from(\"Baz\");\n+        let resolution = &item_map.per_module[&module_id].items[&name];\n+        assert!(resolution.def_id.is_some());\n+    }\n+}"}]}