{"sha": "058e02145786ce50c86dd590d792271839907642", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1OGUwMjE0NTc4NmNlNTBjODZkZDU5MGQ3OTIyNzE4Mzk5MDc2NDI=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-08-02T13:42:08Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-08-02T13:49:26Z"}, "message": "Use Lift derive proc-macro in librustc_traits.", "tree": {"sha": "7cd228376a734394885fbaa32a029a3588170023", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cd228376a734394885fbaa32a029a3588170023"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/058e02145786ce50c86dd590d792271839907642", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/058e02145786ce50c86dd590d792271839907642", "html_url": "https://github.com/rust-lang/rust/commit/058e02145786ce50c86dd590d792271839907642", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/058e02145786ce50c86dd590d792271839907642/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2baefd3206b29b06f1cb55b91be9a2e380e7d2de", "url": "https://api.github.com/repos/rust-lang/rust/commits/2baefd3206b29b06f1cb55b91be9a2e380e7d2de", "html_url": "https://github.com/rust-lang/rust/commit/2baefd3206b29b06f1cb55b91be9a2e380e7d2de"}], "stats": {"total": 262, "additions": 23, "deletions": 239}, "files": [{"sha": "52ced9a53b16ea5565af1473a9e6d3ec578203b1", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/058e02145786ce50c86dd590d792271839907642/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/058e02145786ce50c86dd590d792271839907642/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=058e02145786ce50c86dd590d792271839907642", "patch": "@@ -27,7 +27,7 @@ pub enum ErrorHandled {\n     TooGeneric,\n }\n \n-CloneTypeFoldableImpls! {\n+CloneTypeFoldableAndLiftImpls! {\n     ErrorHandled,\n }\n "}, {"sha": "585f29386a8e0e15c06f2595c2213dd72829c9a3", "filename": "src/librustc_middle/traits/mod.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/058e02145786ce50c86dd590d792271839907642/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/058e02145786ce50c86dd590d792271839907642/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fmod.rs?ref=058e02145786ce50c86dd590d792271839907642", "patch": "@@ -30,7 +30,6 @@ pub type ChalkCanonicalGoal<'tcx> = Canonical<'tcx, ChalkEnvironmentAndGoal<'tcx\n \n pub use self::ImplSource::*;\n pub use self::ObligationCauseCode::*;\n-pub use self::SelectionError::*;\n \n pub use self::chalk::{\n     ChalkEnvironmentAndGoal, ChalkEnvironmentClause, RustInterner as ChalkRustInterner,\n@@ -86,7 +85,7 @@ pub enum Reveal {\n ///\n /// We do not want to intern this as there are a lot of obligation causes which\n /// only live for a short period of time.\n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq, Eq, Hash, Lift)]\n pub struct ObligationCause<'tcx> {\n     /// `None` for `ObligationCause::dummy`, `Some` otherwise.\n     data: Option<Rc<ObligationCauseData<'tcx>>>,\n@@ -111,7 +110,7 @@ impl Deref for ObligationCause<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct ObligationCauseData<'tcx> {\n     pub span: Span,\n \n@@ -169,14 +168,14 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct UnifyReceiverContext<'tcx> {\n     pub assoc_item: ty::AssocItem,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub substs: SubstsRef<'tcx>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from the span.\n     MiscObligation,\n@@ -343,7 +342,7 @@ impl ObligationCauseCode<'_> {\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(ObligationCauseCode<'_>, 32);\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct MatchExpressionArmCause<'tcx> {\n     pub arm_span: Span,\n     pub source: hir::MatchSource,\n@@ -359,7 +358,7 @@ pub struct IfExpressionCause {\n     pub semicolon: Option<Span>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct DerivedObligationCause<'tcx> {\n     /// The trait reference of the parent obligation that led to the\n     /// current obligation. Note that only trait obligations lead to\n@@ -371,7 +370,7 @@ pub struct DerivedObligationCause<'tcx> {\n     pub parent_code: Rc<ObligationCauseCode<'tcx>>,\n }\n \n-#[derive(Clone, Debug, TypeFoldable)]\n+#[derive(Clone, Debug, TypeFoldable, Lift)]\n pub enum SelectionError<'tcx> {\n     Unimplemented,\n     OutputTypeParameterMismatch(\n@@ -427,7 +426,7 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n /// ### The type parameter `N`\n ///\n /// See explanation on `ImplSourceUserDefinedData`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub enum ImplSource<'tcx, N> {\n     /// ImplSource identifying a particular impl.\n     ImplSourceUserDefined(ImplSourceUserDefinedData<'tcx, N>),\n@@ -558,14 +557,14 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n /// is `Obligation`, as one might expect. During codegen, however, this\n /// is `()`, because codegen only requires a shallow resolution of an\n /// impl, and nested obligations are satisfied later.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceUserDefinedData<'tcx, N> {\n     pub impl_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceGeneratorData<'tcx, N> {\n     pub generator_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n@@ -574,7 +573,7 @@ pub struct ImplSourceGeneratorData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceClosureData<'tcx, N> {\n     pub closure_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n@@ -583,18 +582,18 @@ pub struct ImplSourceClosureData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceAutoImplData<N> {\n     pub trait_def_id: DefId,\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceBuiltinData<N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceObjectData<'tcx, N> {\n     /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n     pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n@@ -607,17 +606,17 @@ pub struct ImplSourceObjectData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceFnPointerData<'tcx, N> {\n     pub fn_ty: Ty<'tcx>,\n     pub nested: Vec<N>,\n }\n \n // FIXME(@lcnr): This should be  refactored and merged with other builtin vtables.\n-#[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ImplSourceDiscriminantKindData;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceTraitAliasData<'tcx, N> {\n     pub alias_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,"}, {"sha": "d73fc628ceb70af2ddfef6740c4ea6b7878e980a", "filename": "src/librustc_middle/traits/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 220, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/058e02145786ce50c86dd590d792271839907642/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/058e02145786ce50c86dd590d792271839907642/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs?ref=058e02145786ce50c86dd590d792271839907642", "patch": "@@ -1,8 +1,6 @@\n use crate::traits;\n-use crate::ty::{Lift, TyCtxt};\n \n use std::fmt;\n-use std::rc::Rc;\n \n // Structural impls for the structs in `traits`.\n \n@@ -107,222 +105,7 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceTraitAliasData<'tcx,\n ///////////////////////////////////////////////////////////////////////////\n // Lift implementations\n \n-impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n-    type Lifted = traits::SelectionError<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            super::Unimplemented => Some(super::Unimplemented),\n-            super::OutputTypeParameterMismatch(a, b, ref err) => {\n-                tcx.lift(&(a, b)).and_then(|(a, b)| {\n-                    tcx.lift(err).map(|err| super::OutputTypeParameterMismatch(a, b, err))\n-                })\n-            }\n-            super::TraitNotObjectSafe(def_id) => Some(super::TraitNotObjectSafe(def_id)),\n-            super::ConstEvalFailure(err) => Some(super::ConstEvalFailure(err)),\n-            super::Overflow => Some(super::Overflow),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n-    type Lifted = traits::ObligationCauseCode<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            super::ReturnNoExpression => Some(super::ReturnNoExpression),\n-            super::MiscObligation => Some(super::MiscObligation),\n-            super::SliceOrArrayElem => Some(super::SliceOrArrayElem),\n-            super::TupleElem => Some(super::TupleElem),\n-            super::ProjectionWf(proj) => tcx.lift(&proj).map(super::ProjectionWf),\n-            super::ItemObligation(def_id) => Some(super::ItemObligation(def_id)),\n-            super::BindingObligation(def_id, span) => Some(super::BindingObligation(def_id, span)),\n-            super::ReferenceOutlivesReferent(ty) => {\n-                tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n-            }\n-            super::ObjectTypeBound(ty, r) => {\n-                tcx.lift(&ty).and_then(|ty| tcx.lift(&r).map(|r| super::ObjectTypeBound(ty, r)))\n-            }\n-            super::ObjectCastObligation(ty) => tcx.lift(&ty).map(super::ObjectCastObligation),\n-            super::Coercion { source, target } => {\n-                Some(super::Coercion { source: tcx.lift(&source)?, target: tcx.lift(&target)? })\n-            }\n-            super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n-            super::TupleInitializerSized => Some(super::TupleInitializerSized),\n-            super::StructInitializerSized => Some(super::StructInitializerSized),\n-            super::VariableType(id) => Some(super::VariableType(id)),\n-            super::ReturnValue(id) => Some(super::ReturnValue(id)),\n-            super::ReturnType => Some(super::ReturnType),\n-            super::SizedArgumentType(sp) => Some(super::SizedArgumentType(sp)),\n-            super::SizedReturnType => Some(super::SizedReturnType),\n-            super::SizedYieldType => Some(super::SizedYieldType),\n-            super::InlineAsmSized => Some(super::InlineAsmSized),\n-            super::RepeatVec(suggest_flag) => Some(super::RepeatVec(suggest_flag)),\n-            super::FieldSized { adt_kind, span, last } => {\n-                Some(super::FieldSized { adt_kind, span, last })\n-            }\n-            super::ConstSized => Some(super::ConstSized),\n-            super::ConstPatternStructural => Some(super::ConstPatternStructural),\n-            super::SharedStatic => Some(super::SharedStatic),\n-            super::BuiltinDerivedObligation(ref cause) => {\n-                tcx.lift(cause).map(super::BuiltinDerivedObligation)\n-            }\n-            super::ImplDerivedObligation(ref cause) => {\n-                tcx.lift(cause).map(super::ImplDerivedObligation)\n-            }\n-            super::DerivedObligation(ref cause) => tcx.lift(cause).map(super::DerivedObligation),\n-            super::CompareImplConstObligation => Some(super::CompareImplConstObligation),\n-            super::CompareImplMethodObligation {\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            } => Some(super::CompareImplMethodObligation {\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            }),\n-            super::CompareImplTypeObligation { item_name, impl_item_def_id, trait_item_def_id } => {\n-                Some(super::CompareImplTypeObligation {\n-                    item_name,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                })\n-            }\n-            super::ExprAssignable => Some(super::ExprAssignable),\n-            super::MatchExpressionArm(box super::MatchExpressionArmCause {\n-                arm_span,\n-                source,\n-                ref prior_arms,\n-                last_ty,\n-                scrut_hir_id,\n-            }) => tcx.lift(&last_ty).map(|last_ty| {\n-                super::MatchExpressionArm(box super::MatchExpressionArmCause {\n-                    arm_span,\n-                    source,\n-                    prior_arms: prior_arms.clone(),\n-                    last_ty,\n-                    scrut_hir_id,\n-                })\n-            }),\n-            super::Pattern { span, root_ty, origin_expr } => {\n-                tcx.lift(&root_ty).map(|root_ty| super::Pattern { span, root_ty, origin_expr })\n-            }\n-            super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }) => {\n-                Some(super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }))\n-            }\n-            super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n-            super::MainFunctionType => Some(super::MainFunctionType),\n-            super::StartFunctionType => Some(super::StartFunctionType),\n-            super::IntrinsicType => Some(super::IntrinsicType),\n-            super::MethodReceiver => Some(super::MethodReceiver),\n-            super::UnifyReceiver(ref ctxt) => tcx.lift(ctxt).map(|ctxt| super::UnifyReceiver(ctxt)),\n-            super::BlockTailExpression(id) => Some(super::BlockTailExpression(id)),\n-            super::TrivialBound => Some(super::TrivialBound),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::UnifyReceiverContext<'a> {\n-    type Lifted = traits::UnifyReceiverContext<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.param_env).and_then(|param_env| {\n-            tcx.lift(&self.substs).map(|substs| traits::UnifyReceiverContext {\n-                assoc_item: self.assoc_item,\n-                param_env,\n-                substs,\n-            })\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n-    type Lifted = traits::DerivedObligationCause<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.parent_trait_ref).and_then(|trait_ref| {\n-            tcx.lift(&*self.parent_code).map(|code| traits::DerivedObligationCause {\n-                parent_trait_ref: trait_ref,\n-                parent_code: Rc::new(code),\n-            })\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n-    type Lifted = traits::ObligationCause<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.code).map(|code| traits::ObligationCause::new(self.span, self.body_id, code))\n-    }\n-}\n-\n-// For codegen only.\n-impl<'a, 'tcx> Lift<'tcx> for traits::ImplSource<'a, ()> {\n-    type Lifted = traits::ImplSource<'tcx, ()>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match self.clone() {\n-            traits::ImplSourceUserDefined(traits::ImplSourceUserDefinedData {\n-                impl_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n-                traits::ImplSourceUserDefined(traits::ImplSourceUserDefinedData {\n-                    impl_def_id,\n-                    substs,\n-                    nested,\n-                })\n-            }),\n-            traits::ImplSourceAutoImpl(t) => Some(traits::ImplSourceAutoImpl(t)),\n-            traits::ImplSourceGenerator(traits::ImplSourceGeneratorData {\n-                generator_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n-                traits::ImplSourceGenerator(traits::ImplSourceGeneratorData {\n-                    generator_def_id,\n-                    substs,\n-                    nested,\n-                })\n-            }),\n-            traits::ImplSourceClosure(traits::ImplSourceClosureData {\n-                closure_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n-                traits::ImplSourceClosure(traits::ImplSourceClosureData {\n-                    closure_def_id,\n-                    substs,\n-                    nested,\n-                })\n-            }),\n-            traits::ImplSourceFnPointer(traits::ImplSourceFnPointerData { fn_ty, nested }) => {\n-                tcx.lift(&fn_ty).map(|fn_ty| {\n-                    traits::ImplSourceFnPointer(traits::ImplSourceFnPointerData { fn_ty, nested })\n-                })\n-            }\n-            traits::ImplSourceDiscriminantKind(traits::ImplSourceDiscriminantKindData) => {\n-                Some(traits::ImplSourceDiscriminantKind(traits::ImplSourceDiscriminantKindData))\n-            }\n-            traits::ImplSourceParam(n) => Some(traits::ImplSourceParam(n)),\n-            traits::ImplSourceBuiltin(n) => Some(traits::ImplSourceBuiltin(n)),\n-            traits::ImplSourceObject(traits::ImplSourceObjectData {\n-                upcast_trait_ref,\n-                vtable_base,\n-                nested,\n-            }) => tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n-                traits::ImplSourceObject(traits::ImplSourceObjectData {\n-                    upcast_trait_ref: trait_ref,\n-                    vtable_base,\n-                    nested,\n-                })\n-            }),\n-            traits::ImplSourceTraitAlias(traits::ImplSourceTraitAliasData {\n-                alias_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n-                traits::ImplSourceTraitAlias(traits::ImplSourceTraitAliasData {\n-                    alias_def_id,\n-                    substs,\n-                    nested,\n-                })\n-            }),\n-        }\n-    }\n+CloneTypeFoldableAndLiftImpls! {\n+    super::IfExpressionCause,\n+    super::ImplSourceDiscriminantKindData,\n }"}, {"sha": "dfa9e38a466ebe2151005687d798b6ab70483a31", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/058e02145786ce50c86dd590d792271839907642/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/058e02145786ce50c86dd590d792271839907642/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=058e02145786ce50c86dd590d792271839907642", "patch": "@@ -282,6 +282,7 @@ CloneTypeFoldableAndLiftImpls! {\n     ::rustc_hir::def::Res,\n     ::rustc_hir::def_id::DefId,\n     ::rustc_hir::def_id::LocalDefId,\n+    ::rustc_hir::HirId,\n     ::rustc_hir::LlvmInlineAsmInner,\n     ::rustc_hir::MatchSource,\n     ::rustc_hir::Mutability,\n@@ -298,6 +299,7 @@ CloneTypeFoldableAndLiftImpls! {\n     // really meant to be folded. In general, we can only fold a fully\n     // general `Region`.\n     crate::ty::BoundRegion,\n+    crate::ty::AssocItem,\n     crate::ty::Placeholder<crate::ty::BoundRegion>,\n     crate::ty::ClosureKind,\n     crate::ty::FreeRegion,"}]}