{"sha": "c2f46df5a534dd1f3610e63bdd0d1d9c9635ec89", "node_id": "C_kwDOAAsO6NoAKGMyZjQ2ZGY1YTUzNGRkMWYzNjEwZTYzYmRkMGQxZDljOTYzNWVjODk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-25T21:19:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-25T21:19:55Z"}, "message": "Rollup merge of #107256 - JakobDegen:delete-sai, r=cjgillot\n\nDelete `SimplifyArmIdentity` and `SimplifyBranchSame` mir opts\n\nI had attempted to fix the first of these opts in #94177 . However, despite that PR already being a full re-write, it still did not fix some of the core soundness issues. The optimizations that are attempted here are likely to be desirable, but I do not expect any of the currently written code to survive into a sound implementation. Deleting the code keeps us from having to maintain the passes in the meantime.\n\nCloses #77359 , closes #72800 , closes #78628\n\nr? ```@cjgillot```", "tree": {"sha": "a5a9e7d87714cf3250b30c56ad6cb6876181a38d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5a9e7d87714cf3250b30c56ad6cb6876181a38d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2f46df5a534dd1f3610e63bdd0d1d9c9635ec89", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj0Zz7CRBK7hj4Ov3rIwAANuUIADQzTmrooXmP5awPHWoYPvtE\nKhaCw0I2D9RIK+FwbpfAPvZ9F5+h4lFh5DPm/S0jZ7CL/RecgUeBDvJTtgszSnyj\neNdM1mR42VNWbV9coYQsZwgWKUfu2rmZaI8lXcn2yBAgTuielr3dnpnTCZY3fffH\nqOe9W4OuAZybP0SWmwufnu7igzO/8V4fO2aVQ9bjZKpYH7Ka3jIilflTsW/Rv+Tt\nd6N7SjM5Y57bUmChPwiobp816Ab/1Mgh8I1EovhDJt0knHCLHqLxBsrrz/lRMEdX\naQUHbZ89BEazT+F9neYBXqtaHIM70Qf+toQp4b7DWthMUflbm8todhf1L9ITG2s=\n=I35T\n-----END PGP SIGNATURE-----\n", "payload": "tree a5a9e7d87714cf3250b30c56ad6cb6876181a38d\nparent c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f\nparent ad7393668f7f54372b974baa37854601756bacc3\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1674681595 +0100\ncommitter GitHub <noreply@github.com> 1674681595 +0100\n\nRollup merge of #107256 - JakobDegen:delete-sai, r=cjgillot\n\nDelete `SimplifyArmIdentity` and `SimplifyBranchSame` mir opts\n\nI had attempted to fix the first of these opts in #94177 . However, despite that PR already being a full re-write, it still did not fix some of the core soundness issues. The optimizations that are attempted here are likely to be desirable, but I do not expect any of the currently written code to survive into a sound implementation. Deleting the code keeps us from having to maintain the passes in the meantime.\n\nCloses #77359 , closes #72800 , closes #78628\n\nr? ```@cjgillot```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2f46df5a534dd1f3610e63bdd0d1d9c9635ec89", "html_url": "https://github.com/rust-lang/rust/commit/c2f46df5a534dd1f3610e63bdd0d1d9c9635ec89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2f46df5a534dd1f3610e63bdd0d1d9c9635ec89/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f", "html_url": "https://github.com/rust-lang/rust/commit/c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f"}, {"sha": "ad7393668f7f54372b974baa37854601756bacc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad7393668f7f54372b974baa37854601756bacc3", "html_url": "https://github.com/rust-lang/rust/commit/ad7393668f7f54372b974baa37854601756bacc3"}], "stats": {"total": 1041, "additions": 0, "deletions": 1041}, "files": [{"sha": "4a598862d10f8ad61e218fd28ef28026e48dae00", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2f46df5a534dd1f3610e63bdd0d1d9c9635ec89/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f46df5a534dd1f3610e63bdd0d1d9c9635ec89/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=c2f46df5a534dd1f3610e63bdd0d1d9c9635ec89", "patch": "@@ -90,7 +90,6 @@ mod shim;\n pub mod simplify;\n mod simplify_branches;\n mod simplify_comparison_integral;\n-mod simplify_try;\n mod sroa;\n mod uninhabited_enum_branching;\n mod unreachable_prop;\n@@ -567,8 +566,6 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n             &o1(simplify_branches::SimplifyConstCondition::new(\"after-const-prop\")),\n             &early_otherwise_branch::EarlyOtherwiseBranch,\n             &simplify_comparison_integral::SimplifyComparisonIntegral,\n-            &simplify_try::SimplifyArmIdentity,\n-            &simplify_try::SimplifyBranchSame,\n             &dead_store_elimination::DeadStoreElimination,\n             &dest_prop::DestinationPropagation,\n             &o1(simplify_branches::SimplifyConstCondition::new(\"final\")),"}, {"sha": "e4f3ace9a93dafced0e7a50fefd1e1d8a597433c", "filename": "compiler/rustc_mir_transform/src/simplify_try.rs", "status": "removed", "additions": 0, "deletions": 822, "changes": 822, "blob_url": "https://github.com/rust-lang/rust/blob/c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs?ref=c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f", "patch": "@@ -1,822 +0,0 @@\n-//! The general point of the optimizations provided here is to simplify something like:\n-//!\n-//! ```rust\n-//! # fn foo<T, E>(x: Result<T, E>) -> Result<T, E> {\n-//! match x {\n-//!     Ok(x) => Ok(x),\n-//!     Err(x) => Err(x)\n-//! }\n-//! # }\n-//! ```\n-//!\n-//! into just `x`.\n-\n-use crate::{simplify, MirPass};\n-use itertools::Itertools as _;\n-use rustc_index::{bit_set::BitSet, vec::IndexVec};\n-use rustc_middle::mir::visit::{NonUseContext, PlaceContext, Visitor};\n-use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, List, Ty, TyCtxt};\n-use rustc_target::abi::VariantIdx;\n-use std::iter::{once, Enumerate, Peekable};\n-use std::slice::Iter;\n-\n-/// Simplifies arms of form `Variant(x) => Variant(x)` to just a move.\n-///\n-/// This is done by transforming basic blocks where the statements match:\n-///\n-/// ```ignore (MIR)\n-/// _LOCAL_TMP = ((_LOCAL_1 as Variant ).FIELD: TY );\n-/// _TMP_2 = _LOCAL_TMP;\n-/// ((_LOCAL_0 as Variant).FIELD: TY) = move _TMP_2;\n-/// discriminant(_LOCAL_0) = VAR_IDX;\n-/// ```\n-///\n-/// into:\n-///\n-/// ```ignore (MIR)\n-/// _LOCAL_0 = move _LOCAL_1\n-/// ```\n-pub struct SimplifyArmIdentity;\n-\n-#[derive(Debug)]\n-struct ArmIdentityInfo<'tcx> {\n-    /// Storage location for the variant's field\n-    local_temp_0: Local,\n-    /// Storage location holding the variant being read from\n-    local_1: Local,\n-    /// The variant field being read from\n-    vf_s0: VarField<'tcx>,\n-    /// Index of the statement which loads the variant being read\n-    get_variant_field_stmt: usize,\n-\n-    /// Tracks each assignment to a temporary of the variant's field\n-    field_tmp_assignments: Vec<(Local, Local)>,\n-\n-    /// Storage location holding the variant's field that was read from\n-    local_tmp_s1: Local,\n-    /// Storage location holding the enum that we are writing to\n-    local_0: Local,\n-    /// The variant field being written to\n-    vf_s1: VarField<'tcx>,\n-\n-    /// Storage location that the discriminant is being written to\n-    set_discr_local: Local,\n-    /// The variant being written\n-    set_discr_var_idx: VariantIdx,\n-\n-    /// Index of the statement that should be overwritten as a move\n-    stmt_to_overwrite: usize,\n-    /// SourceInfo for the new move\n-    source_info: SourceInfo,\n-\n-    /// Indices of matching Storage{Live,Dead} statements encountered.\n-    /// (StorageLive index,, StorageDead index, Local)\n-    storage_stmts: Vec<(usize, usize, Local)>,\n-\n-    /// The statements that should be removed (turned into nops)\n-    stmts_to_remove: Vec<usize>,\n-\n-    /// Indices of debug variables that need to be adjusted to point to\n-    // `{local_0}.{dbg_projection}`.\n-    dbg_info_to_adjust: Vec<usize>,\n-\n-    /// The projection used to rewrite debug info.\n-    dbg_projection: &'tcx List<PlaceElem<'tcx>>,\n-}\n-\n-fn get_arm_identity_info<'a, 'tcx>(\n-    stmts: &'a [Statement<'tcx>],\n-    locals_count: usize,\n-    debug_info: &'a [VarDebugInfo<'tcx>],\n-) -> Option<ArmIdentityInfo<'tcx>> {\n-    // This can't possibly match unless there are at least 3 statements in the block\n-    // so fail fast on tiny blocks.\n-    if stmts.len() < 3 {\n-        return None;\n-    }\n-\n-    let mut tmp_assigns = Vec::new();\n-    let mut nop_stmts = Vec::new();\n-    let mut storage_stmts = Vec::new();\n-    let mut storage_live_stmts = Vec::new();\n-    let mut storage_dead_stmts = Vec::new();\n-\n-    type StmtIter<'a, 'tcx> = Peekable<Enumerate<Iter<'a, Statement<'tcx>>>>;\n-\n-    fn is_storage_stmt(stmt: &Statement<'_>) -> bool {\n-        matches!(stmt.kind, StatementKind::StorageLive(_) | StatementKind::StorageDead(_))\n-    }\n-\n-    /// Eats consecutive Statements which match `test`, performing the specified `action` for each.\n-    /// The iterator `stmt_iter` is not advanced if none were matched.\n-    fn try_eat<'a, 'tcx>(\n-        stmt_iter: &mut StmtIter<'a, 'tcx>,\n-        test: impl Fn(&'a Statement<'tcx>) -> bool,\n-        mut action: impl FnMut(usize, &'a Statement<'tcx>),\n-    ) {\n-        while stmt_iter.peek().map_or(false, |(_, stmt)| test(stmt)) {\n-            let (idx, stmt) = stmt_iter.next().unwrap();\n-\n-            action(idx, stmt);\n-        }\n-    }\n-\n-    /// Eats consecutive `StorageLive` and `StorageDead` Statements.\n-    /// The iterator `stmt_iter` is not advanced if none were found.\n-    fn try_eat_storage_stmts(\n-        stmt_iter: &mut StmtIter<'_, '_>,\n-        storage_live_stmts: &mut Vec<(usize, Local)>,\n-        storage_dead_stmts: &mut Vec<(usize, Local)>,\n-    ) {\n-        try_eat(stmt_iter, is_storage_stmt, |idx, stmt| {\n-            if let StatementKind::StorageLive(l) = stmt.kind {\n-                storage_live_stmts.push((idx, l));\n-            } else if let StatementKind::StorageDead(l) = stmt.kind {\n-                storage_dead_stmts.push((idx, l));\n-            }\n-        })\n-    }\n-\n-    fn is_tmp_storage_stmt(stmt: &Statement<'_>) -> bool {\n-        use rustc_middle::mir::StatementKind::Assign;\n-        if let Assign(box (place, Rvalue::Use(Operand::Copy(p) | Operand::Move(p)))) = &stmt.kind {\n-            place.as_local().is_some() && p.as_local().is_some()\n-        } else {\n-            false\n-        }\n-    }\n-\n-    /// Eats consecutive `Assign` Statements.\n-    // The iterator `stmt_iter` is not advanced if none were found.\n-    fn try_eat_assign_tmp_stmts(\n-        stmt_iter: &mut StmtIter<'_, '_>,\n-        tmp_assigns: &mut Vec<(Local, Local)>,\n-        nop_stmts: &mut Vec<usize>,\n-    ) {\n-        try_eat(stmt_iter, is_tmp_storage_stmt, |idx, stmt| {\n-            use rustc_middle::mir::StatementKind::Assign;\n-            if let Assign(box (place, Rvalue::Use(Operand::Copy(p) | Operand::Move(p)))) =\n-                &stmt.kind\n-            {\n-                tmp_assigns.push((place.as_local().unwrap(), p.as_local().unwrap()));\n-                nop_stmts.push(idx);\n-            }\n-        })\n-    }\n-\n-    fn find_storage_live_dead_stmts_for_local(\n-        local: Local,\n-        stmts: &[Statement<'_>],\n-    ) -> Option<(usize, usize)> {\n-        trace!(\"looking for {:?}\", local);\n-        let mut storage_live_stmt = None;\n-        let mut storage_dead_stmt = None;\n-        for (idx, stmt) in stmts.iter().enumerate() {\n-            if stmt.kind == StatementKind::StorageLive(local) {\n-                storage_live_stmt = Some(idx);\n-            } else if stmt.kind == StatementKind::StorageDead(local) {\n-                storage_dead_stmt = Some(idx);\n-            }\n-        }\n-\n-        Some((storage_live_stmt?, storage_dead_stmt.unwrap_or(usize::MAX)))\n-    }\n-\n-    // Try to match the expected MIR structure with the basic block we're processing.\n-    // We want to see something that looks like:\n-    // ```\n-    // (StorageLive(_) | StorageDead(_));*\n-    // _LOCAL_INTO = ((_LOCAL_FROM as Variant).FIELD: TY);\n-    // (StorageLive(_) | StorageDead(_));*\n-    // (tmp_n+1 = tmp_n);*\n-    // (StorageLive(_) | StorageDead(_));*\n-    // (tmp_n+1 = tmp_n);*\n-    // ((LOCAL_FROM as Variant).FIELD: TY) = move tmp;\n-    // discriminant(LOCAL_FROM) = VariantIdx;\n-    // (StorageLive(_) | StorageDead(_));*\n-    // ```\n-    let mut stmt_iter = stmts.iter().enumerate().peekable();\n-\n-    try_eat_storage_stmts(&mut stmt_iter, &mut storage_live_stmts, &mut storage_dead_stmts);\n-\n-    let (get_variant_field_stmt, stmt) = stmt_iter.next()?;\n-    let (local_tmp_s0, local_1, vf_s0, dbg_projection) = match_get_variant_field(stmt)?;\n-\n-    try_eat_storage_stmts(&mut stmt_iter, &mut storage_live_stmts, &mut storage_dead_stmts);\n-\n-    try_eat_assign_tmp_stmts(&mut stmt_iter, &mut tmp_assigns, &mut nop_stmts);\n-\n-    try_eat_storage_stmts(&mut stmt_iter, &mut storage_live_stmts, &mut storage_dead_stmts);\n-\n-    try_eat_assign_tmp_stmts(&mut stmt_iter, &mut tmp_assigns, &mut nop_stmts);\n-\n-    let (idx, stmt) = stmt_iter.next()?;\n-    let (local_tmp_s1, local_0, vf_s1) = match_set_variant_field(stmt)?;\n-    nop_stmts.push(idx);\n-\n-    let (idx, stmt) = stmt_iter.next()?;\n-    let (set_discr_local, set_discr_var_idx) = match_set_discr(stmt)?;\n-    let discr_stmt_source_info = stmt.source_info;\n-    nop_stmts.push(idx);\n-\n-    try_eat_storage_stmts(&mut stmt_iter, &mut storage_live_stmts, &mut storage_dead_stmts);\n-\n-    for (live_idx, live_local) in storage_live_stmts {\n-        if let Some(i) = storage_dead_stmts.iter().rposition(|(_, l)| *l == live_local) {\n-            let (dead_idx, _) = storage_dead_stmts.swap_remove(i);\n-            storage_stmts.push((live_idx, dead_idx, live_local));\n-\n-            if live_local == local_tmp_s0 {\n-                nop_stmts.push(get_variant_field_stmt);\n-            }\n-        }\n-    }\n-    // We sort primitive usize here so we can use unstable sort\n-    nop_stmts.sort_unstable();\n-\n-    // Use one of the statements we're going to discard between the point\n-    // where the storage location for the variant field becomes live and\n-    // is killed.\n-    let (live_idx, dead_idx) = find_storage_live_dead_stmts_for_local(local_tmp_s0, stmts)?;\n-    let stmt_to_overwrite =\n-        nop_stmts.iter().find(|stmt_idx| live_idx < **stmt_idx && **stmt_idx < dead_idx);\n-\n-    let mut tmp_assigned_vars = BitSet::new_empty(locals_count);\n-    for (l, r) in &tmp_assigns {\n-        tmp_assigned_vars.insert(*l);\n-        tmp_assigned_vars.insert(*r);\n-    }\n-\n-    let dbg_info_to_adjust: Vec<_> = debug_info\n-        .iter()\n-        .enumerate()\n-        .filter_map(|(i, var_info)| {\n-            if let VarDebugInfoContents::Place(p) = var_info.value {\n-                if tmp_assigned_vars.contains(p.local) {\n-                    return Some(i);\n-                }\n-            }\n-\n-            None\n-        })\n-        .collect();\n-\n-    Some(ArmIdentityInfo {\n-        local_temp_0: local_tmp_s0,\n-        local_1,\n-        vf_s0,\n-        get_variant_field_stmt,\n-        field_tmp_assignments: tmp_assigns,\n-        local_tmp_s1,\n-        local_0,\n-        vf_s1,\n-        set_discr_local,\n-        set_discr_var_idx,\n-        stmt_to_overwrite: *stmt_to_overwrite?,\n-        source_info: discr_stmt_source_info,\n-        storage_stmts,\n-        stmts_to_remove: nop_stmts,\n-        dbg_info_to_adjust,\n-        dbg_projection,\n-    })\n-}\n-\n-fn optimization_applies<'tcx>(\n-    opt_info: &ArmIdentityInfo<'tcx>,\n-    local_decls: &IndexVec<Local, LocalDecl<'tcx>>,\n-    local_uses: &IndexVec<Local, usize>,\n-    var_debug_info: &[VarDebugInfo<'tcx>],\n-) -> bool {\n-    trace!(\"testing if optimization applies...\");\n-\n-    // FIXME(wesleywiser): possibly relax this restriction?\n-    if opt_info.local_0 == opt_info.local_1 {\n-        trace!(\"NO: moving into ourselves\");\n-        return false;\n-    } else if opt_info.vf_s0 != opt_info.vf_s1 {\n-        trace!(\"NO: the field-and-variant information do not match\");\n-        return false;\n-    } else if local_decls[opt_info.local_0].ty != local_decls[opt_info.local_1].ty {\n-        // FIXME(Centril,oli-obk): possibly relax to same layout?\n-        trace!(\"NO: source and target locals have different types\");\n-        return false;\n-    } else if (opt_info.local_0, opt_info.vf_s0.var_idx)\n-        != (opt_info.set_discr_local, opt_info.set_discr_var_idx)\n-    {\n-        trace!(\"NO: the discriminants do not match\");\n-        return false;\n-    }\n-\n-    // Verify the assignment chain consists of the form b = a; c = b; d = c; etc...\n-    if opt_info.field_tmp_assignments.is_empty() {\n-        trace!(\"NO: no assignments found\");\n-        return false;\n-    }\n-    let mut last_assigned_to = opt_info.field_tmp_assignments[0].1;\n-    let source_local = last_assigned_to;\n-    for (l, r) in &opt_info.field_tmp_assignments {\n-        if *r != last_assigned_to {\n-            trace!(\"NO: found unexpected assignment {:?} = {:?}\", l, r);\n-            return false;\n-        }\n-\n-        last_assigned_to = *l;\n-    }\n-\n-    // Check that the first and last used locals are only used twice\n-    // since they are of the form:\n-    //\n-    // ```\n-    // _first = ((_x as Variant).n: ty);\n-    // _n = _first;\n-    // ...\n-    // ((_y as Variant).n: ty) = _n;\n-    // discriminant(_y) = z;\n-    // ```\n-    for (l, r) in &opt_info.field_tmp_assignments {\n-        if local_uses[*l] != 2 {\n-            warn!(\"NO: FAILED assignment chain local {:?} was used more than twice\", l);\n-            return false;\n-        } else if local_uses[*r] != 2 {\n-            warn!(\"NO: FAILED assignment chain local {:?} was used more than twice\", r);\n-            return false;\n-        }\n-    }\n-\n-    // Check that debug info only points to full Locals and not projections.\n-    for dbg_idx in &opt_info.dbg_info_to_adjust {\n-        let dbg_info = &var_debug_info[*dbg_idx];\n-        if let VarDebugInfoContents::Place(p) = dbg_info.value {\n-            if !p.projection.is_empty() {\n-                trace!(\"NO: debug info for {:?} had a projection {:?}\", dbg_info.name, p);\n-                return false;\n-            }\n-        }\n-    }\n-\n-    if source_local != opt_info.local_temp_0 {\n-        trace!(\n-            \"NO: start of assignment chain does not match enum variant temp: {:?} != {:?}\",\n-            source_local,\n-            opt_info.local_temp_0\n-        );\n-        return false;\n-    } else if last_assigned_to != opt_info.local_tmp_s1 {\n-        trace!(\n-            \"NO: end of assignment chain does not match written enum temp: {:?} != {:?}\",\n-            last_assigned_to,\n-            opt_info.local_tmp_s1\n-        );\n-        return false;\n-    }\n-\n-    trace!(\"SUCCESS: optimization applies!\");\n-    true\n-}\n-\n-impl<'tcx> MirPass<'tcx> for SimplifyArmIdentity {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        // FIXME(77359): This optimization can result in unsoundness.\n-        if !tcx.sess.opts.unstable_opts.unsound_mir_opts {\n-            return;\n-        }\n-\n-        let source = body.source;\n-        trace!(\"running SimplifyArmIdentity on {:?}\", source);\n-\n-        let local_uses = LocalUseCounter::get_local_uses(body);\n-        for bb in body.basic_blocks.as_mut() {\n-            if let Some(opt_info) =\n-                get_arm_identity_info(&bb.statements, body.local_decls.len(), &body.var_debug_info)\n-            {\n-                trace!(\"got opt_info = {:#?}\", opt_info);\n-                if !optimization_applies(\n-                    &opt_info,\n-                    &body.local_decls,\n-                    &local_uses,\n-                    &body.var_debug_info,\n-                ) {\n-                    debug!(\"optimization skipped for {:?}\", source);\n-                    continue;\n-                }\n-\n-                // Also remove unused Storage{Live,Dead} statements which correspond\n-                // to temps used previously.\n-                for (live_idx, dead_idx, local) in &opt_info.storage_stmts {\n-                    // The temporary that we've read the variant field into is scoped to this block,\n-                    // so we can remove the assignment.\n-                    if *local == opt_info.local_temp_0 {\n-                        bb.statements[opt_info.get_variant_field_stmt].make_nop();\n-                    }\n-\n-                    for (left, right) in &opt_info.field_tmp_assignments {\n-                        if local == left || local == right {\n-                            bb.statements[*live_idx].make_nop();\n-                            bb.statements[*dead_idx].make_nop();\n-                        }\n-                    }\n-                }\n-\n-                // Right shape; transform\n-                for stmt_idx in opt_info.stmts_to_remove {\n-                    bb.statements[stmt_idx].make_nop();\n-                }\n-\n-                let stmt = &mut bb.statements[opt_info.stmt_to_overwrite];\n-                stmt.source_info = opt_info.source_info;\n-                stmt.kind = StatementKind::Assign(Box::new((\n-                    opt_info.local_0.into(),\n-                    Rvalue::Use(Operand::Move(opt_info.local_1.into())),\n-                )));\n-\n-                bb.statements.retain(|stmt| stmt.kind != StatementKind::Nop);\n-\n-                // Fix the debug info to point to the right local\n-                for dbg_index in opt_info.dbg_info_to_adjust {\n-                    let dbg_info = &mut body.var_debug_info[dbg_index];\n-                    assert!(\n-                        matches!(dbg_info.value, VarDebugInfoContents::Place(_)),\n-                        \"value was not a Place\"\n-                    );\n-                    if let VarDebugInfoContents::Place(p) = &mut dbg_info.value {\n-                        assert!(p.projection.is_empty());\n-                        p.local = opt_info.local_0;\n-                        p.projection = opt_info.dbg_projection;\n-                    }\n-                }\n-\n-                trace!(\"block is now {:?}\", bb.statements);\n-            }\n-        }\n-    }\n-}\n-\n-struct LocalUseCounter {\n-    local_uses: IndexVec<Local, usize>,\n-}\n-\n-impl LocalUseCounter {\n-    fn get_local_uses(body: &Body<'_>) -> IndexVec<Local, usize> {\n-        let mut counter = LocalUseCounter { local_uses: IndexVec::from_elem(0, &body.local_decls) };\n-        counter.visit_body(body);\n-        counter.local_uses\n-    }\n-}\n-\n-impl Visitor<'_> for LocalUseCounter {\n-    fn visit_local(&mut self, local: Local, context: PlaceContext, _location: Location) {\n-        if context.is_storage_marker()\n-            || context == PlaceContext::NonUse(NonUseContext::VarDebugInfo)\n-        {\n-            return;\n-        }\n-\n-        self.local_uses[local] += 1;\n-    }\n-}\n-\n-/// Match on:\n-/// ```ignore (MIR)\n-/// _LOCAL_INTO = ((_LOCAL_FROM as Variant).FIELD: TY);\n-/// ```\n-fn match_get_variant_field<'tcx>(\n-    stmt: &Statement<'tcx>,\n-) -> Option<(Local, Local, VarField<'tcx>, &'tcx List<PlaceElem<'tcx>>)> {\n-    match &stmt.kind {\n-        StatementKind::Assign(box (\n-            place_into,\n-            Rvalue::Use(Operand::Copy(pf) | Operand::Move(pf)),\n-        )) => {\n-            let local_into = place_into.as_local()?;\n-            let (local_from, vf) = match_variant_field_place(*pf)?;\n-            Some((local_into, local_from, vf, pf.projection))\n-        }\n-        _ => None,\n-    }\n-}\n-\n-/// Match on:\n-/// ```ignore (MIR)\n-/// ((_LOCAL_FROM as Variant).FIELD: TY) = move _LOCAL_INTO;\n-/// ```\n-fn match_set_variant_field<'tcx>(stmt: &Statement<'tcx>) -> Option<(Local, Local, VarField<'tcx>)> {\n-    match &stmt.kind {\n-        StatementKind::Assign(box (place_from, Rvalue::Use(Operand::Move(place_into)))) => {\n-            let local_into = place_into.as_local()?;\n-            let (local_from, vf) = match_variant_field_place(*place_from)?;\n-            Some((local_into, local_from, vf))\n-        }\n-        _ => None,\n-    }\n-}\n-\n-/// Match on:\n-/// ```ignore (MIR)\n-/// discriminant(_LOCAL_TO_SET) = VAR_IDX;\n-/// ```\n-fn match_set_discr(stmt: &Statement<'_>) -> Option<(Local, VariantIdx)> {\n-    match &stmt.kind {\n-        StatementKind::SetDiscriminant { place, variant_index } => {\n-            Some((place.as_local()?, *variant_index))\n-        }\n-        _ => None,\n-    }\n-}\n-\n-#[derive(PartialEq, Debug)]\n-struct VarField<'tcx> {\n-    field: Field,\n-    field_ty: Ty<'tcx>,\n-    var_idx: VariantIdx,\n-}\n-\n-/// Match on `((_LOCAL as Variant).FIELD: TY)`.\n-fn match_variant_field_place(place: Place<'_>) -> Option<(Local, VarField<'_>)> {\n-    match place.as_ref() {\n-        PlaceRef {\n-            local,\n-            projection: &[ProjectionElem::Downcast(_, var_idx), ProjectionElem::Field(field, ty)],\n-        } => Some((local, VarField { field, field_ty: ty, var_idx })),\n-        _ => None,\n-    }\n-}\n-\n-/// Simplifies `SwitchInt(_) -> [targets]`,\n-/// where all the `targets` have the same form,\n-/// into `goto -> target_first`.\n-pub struct SimplifyBranchSame;\n-\n-impl<'tcx> MirPass<'tcx> for SimplifyBranchSame {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        // This optimization is disabled by default for now due to\n-        // soundness concerns; see issue #89485 and PR #89489.\n-        if !tcx.sess.opts.unstable_opts.unsound_mir_opts {\n-            return;\n-        }\n-\n-        trace!(\"Running SimplifyBranchSame on {:?}\", body.source);\n-        let finder = SimplifyBranchSameOptimizationFinder { body, tcx };\n-        let opts = finder.find();\n-\n-        let did_remove_blocks = opts.len() > 0;\n-        for opt in opts.iter() {\n-            trace!(\"SUCCESS: Applying optimization {:?}\", opt);\n-            // Replace `SwitchInt(..) -> [bb_first, ..];` with a `goto -> bb_first;`.\n-            body.basic_blocks_mut()[opt.bb_to_opt_terminator].terminator_mut().kind =\n-                TerminatorKind::Goto { target: opt.bb_to_goto };\n-        }\n-\n-        if did_remove_blocks {\n-            // We have dead blocks now, so remove those.\n-            simplify::remove_dead_blocks(tcx, body);\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-struct SimplifyBranchSameOptimization {\n-    /// All basic blocks are equal so go to this one\n-    bb_to_goto: BasicBlock,\n-    /// Basic block where the terminator can be simplified to a goto\n-    bb_to_opt_terminator: BasicBlock,\n-}\n-\n-struct SwitchTargetAndValue {\n-    target: BasicBlock,\n-    // None in case of the `otherwise` case\n-    value: Option<u128>,\n-}\n-\n-struct SimplifyBranchSameOptimizationFinder<'a, 'tcx> {\n-    body: &'a Body<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-impl<'tcx> SimplifyBranchSameOptimizationFinder<'_, 'tcx> {\n-    fn find(&self) -> Vec<SimplifyBranchSameOptimization> {\n-        self.body\n-            .basic_blocks\n-            .iter_enumerated()\n-            .filter_map(|(bb_idx, bb)| {\n-                let (discr_switched_on, targets_and_values) = match &bb.terminator().kind {\n-                    TerminatorKind::SwitchInt { targets, discr, .. } => {\n-                        let targets_and_values: Vec<_> = targets.iter()\n-                            .map(|(val, target)| SwitchTargetAndValue { target, value: Some(val) })\n-                            .chain(once(SwitchTargetAndValue { target: targets.otherwise(), value: None }))\n-                            .collect();\n-                        (discr, targets_and_values)\n-                    },\n-                    _ => return None,\n-                };\n-\n-                // find the adt that has its discriminant read\n-                // assuming this must be the last statement of the block\n-                let adt_matched_on = match &bb.statements.last()?.kind {\n-                    StatementKind::Assign(box (place, rhs))\n-                        if Some(*place) == discr_switched_on.place() =>\n-                    {\n-                        match rhs {\n-                            Rvalue::Discriminant(adt_place) if adt_place.ty(self.body, self.tcx).ty.is_enum() => adt_place,\n-                            _ => {\n-                                trace!(\"NO: expected a discriminant read of an enum instead of: {:?}\", rhs);\n-                                return None;\n-                            }\n-                        }\n-                    }\n-                    other => {\n-                        trace!(\"NO: expected an assignment of a discriminant read to a place. Found: {:?}\", other);\n-                        return None\n-                    },\n-                };\n-\n-                let mut iter_bbs_reachable = targets_and_values\n-                    .iter()\n-                    .map(|target_and_value| (target_and_value, &self.body.basic_blocks[target_and_value.target]))\n-                    .filter(|(_, bb)| {\n-                        // Reaching `unreachable` is UB so assume it doesn't happen.\n-                        bb.terminator().kind != TerminatorKind::Unreachable\n-                    })\n-                    .peekable();\n-\n-                let bb_first = iter_bbs_reachable.peek().map_or(&targets_and_values[0], |(idx, _)| *idx);\n-                let mut all_successors_equivalent = StatementEquality::TrivialEqual;\n-\n-                // All successor basic blocks must be equal or contain statements that are pairwise considered equal.\n-                for ((target_and_value_l,bb_l), (target_and_value_r,bb_r)) in iter_bbs_reachable.tuple_windows() {\n-                    let trivial_checks = bb_l.is_cleanup == bb_r.is_cleanup\n-                                            && bb_l.terminator().kind == bb_r.terminator().kind\n-                                            && bb_l.statements.len() == bb_r.statements.len();\n-                    let statement_check = || {\n-                        bb_l.statements.iter().zip(&bb_r.statements).try_fold(StatementEquality::TrivialEqual, |acc,(l,r)| {\n-                            let stmt_equality = self.statement_equality(*adt_matched_on, &l, target_and_value_l, &r, target_and_value_r);\n-                            if matches!(stmt_equality, StatementEquality::NotEqual) {\n-                                // short circuit\n-                                None\n-                            } else {\n-                                Some(acc.combine(&stmt_equality))\n-                            }\n-                        })\n-                        .unwrap_or(StatementEquality::NotEqual)\n-                    };\n-                    if !trivial_checks {\n-                        all_successors_equivalent = StatementEquality::NotEqual;\n-                        break;\n-                    }\n-                    all_successors_equivalent = all_successors_equivalent.combine(&statement_check());\n-                };\n-\n-                match all_successors_equivalent{\n-                    StatementEquality::TrivialEqual => {\n-                        // statements are trivially equal, so just take first\n-                        trace!(\"Statements are trivially equal\");\n-                        Some(SimplifyBranchSameOptimization {\n-                            bb_to_goto: bb_first.target,\n-                            bb_to_opt_terminator: bb_idx,\n-                        })\n-                    }\n-                    StatementEquality::ConsideredEqual(bb_to_choose) => {\n-                        trace!(\"Statements are considered equal\");\n-                        Some(SimplifyBranchSameOptimization {\n-                            bb_to_goto: bb_to_choose,\n-                            bb_to_opt_terminator: bb_idx,\n-                        })\n-                    }\n-                    StatementEquality::NotEqual => {\n-                        trace!(\"NO: not all successors of basic block {:?} were equivalent\", bb_idx);\n-                        None\n-                    }\n-                }\n-            })\n-            .collect()\n-    }\n-\n-    /// Tests if two statements can be considered equal\n-    ///\n-    /// Statements can be trivially equal if the kinds match.\n-    /// But they can also be considered equal in the following case A:\n-    /// ```ignore (MIR)\n-    /// discriminant(_0) = 0;   // bb1\n-    /// _0 = move _1;           // bb2\n-    /// ```\n-    /// In this case the two statements are equal iff\n-    /// - `_0` is an enum where the variant index 0 is fieldless, and\n-    /// -  bb1 was targeted by a switch where the discriminant of `_1` was switched on\n-    fn statement_equality(\n-        &self,\n-        adt_matched_on: Place<'tcx>,\n-        x: &Statement<'tcx>,\n-        x_target_and_value: &SwitchTargetAndValue,\n-        y: &Statement<'tcx>,\n-        y_target_and_value: &SwitchTargetAndValue,\n-    ) -> StatementEquality {\n-        let helper = |rhs: &Rvalue<'tcx>,\n-                      place: &Place<'tcx>,\n-                      variant_index: VariantIdx,\n-                      switch_value: u128,\n-                      side_to_choose| {\n-            let place_type = place.ty(self.body, self.tcx).ty;\n-            let adt = match *place_type.kind() {\n-                ty::Adt(adt, _) if adt.is_enum() => adt,\n-                _ => return StatementEquality::NotEqual,\n-            };\n-            // We need to make sure that the switch value that targets the bb with\n-            // SetDiscriminant is the same as the variant discriminant.\n-            let variant_discr = adt.discriminant_for_variant(self.tcx, variant_index).val;\n-            if variant_discr != switch_value {\n-                trace!(\n-                    \"NO: variant discriminant {} does not equal switch value {}\",\n-                    variant_discr,\n-                    switch_value\n-                );\n-                return StatementEquality::NotEqual;\n-            }\n-            let variant_is_fieldless = adt.variant(variant_index).fields.is_empty();\n-            if !variant_is_fieldless {\n-                trace!(\"NO: variant {:?} was not fieldless\", variant_index);\n-                return StatementEquality::NotEqual;\n-            }\n-\n-            match rhs {\n-                Rvalue::Use(operand) if operand.place() == Some(adt_matched_on) => {\n-                    StatementEquality::ConsideredEqual(side_to_choose)\n-                }\n-                _ => {\n-                    trace!(\n-                        \"NO: RHS of assignment was {:?}, but expected it to match the adt being matched on in the switch, which is {:?}\",\n-                        rhs,\n-                        adt_matched_on\n-                    );\n-                    StatementEquality::NotEqual\n-                }\n-            }\n-        };\n-        match (&x.kind, &y.kind) {\n-            // trivial case\n-            (x, y) if x == y => StatementEquality::TrivialEqual,\n-\n-            // check for case A\n-            (\n-                StatementKind::Assign(box (_, rhs)),\n-                &StatementKind::SetDiscriminant { ref place, variant_index },\n-            ) if y_target_and_value.value.is_some() => {\n-                // choose basic block of x, as that has the assign\n-                helper(\n-                    rhs,\n-                    place,\n-                    variant_index,\n-                    y_target_and_value.value.unwrap(),\n-                    x_target_and_value.target,\n-                )\n-            }\n-            (\n-                &StatementKind::SetDiscriminant { ref place, variant_index },\n-                &StatementKind::Assign(box (_, ref rhs)),\n-            ) if x_target_and_value.value.is_some() => {\n-                // choose basic block of y, as that has the assign\n-                helper(\n-                    rhs,\n-                    place,\n-                    variant_index,\n-                    x_target_and_value.value.unwrap(),\n-                    y_target_and_value.target,\n-                )\n-            }\n-            _ => {\n-                trace!(\"NO: statements `{:?}` and `{:?}` not considered equal\", x, y);\n-                StatementEquality::NotEqual\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Eq, PartialEq)]\n-enum StatementEquality {\n-    /// The two statements are trivially equal; same kind\n-    TrivialEqual,\n-    /// The two statements are considered equal, but may be of different kinds. The BasicBlock field is the basic block to jump to when performing the branch-same optimization.\n-    /// For example, `_0 = _1` and `discriminant(_0) = discriminant(0)` are considered equal if 0 is a fieldless variant of an enum. But we don't want to jump to the basic block with the SetDiscriminant, as that is not legal if _1 is not the 0 variant index\n-    ConsideredEqual(BasicBlock),\n-    /// The two statements are not equal\n-    NotEqual,\n-}\n-\n-impl StatementEquality {\n-    fn combine(&self, other: &StatementEquality) -> StatementEquality {\n-        use StatementEquality::*;\n-        match (self, other) {\n-            (TrivialEqual, TrivialEqual) => TrivialEqual,\n-            (TrivialEqual, ConsideredEqual(b)) | (ConsideredEqual(b), TrivialEqual) => {\n-                ConsideredEqual(*b)\n-            }\n-            (ConsideredEqual(b1), ConsideredEqual(b2)) => {\n-                if b1 == b2 {\n-                    ConsideredEqual(*b1)\n-                } else {\n-                    NotEqual\n-                }\n-            }\n-            (_, NotEqual) | (NotEqual, _) => NotEqual,\n-        }\n-    }\n-}"}, {"sha": "9780332d8bf18813d2658000920e92e91f7e8824", "filename": "tests/mir-opt/76803_regression.encode.SimplifyBranchSame.diff", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f/tests%2Fmir-opt%2F76803_regression.encode.SimplifyBranchSame.diff", "raw_url": "https://github.com/rust-lang/rust/raw/c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f/tests%2Fmir-opt%2F76803_regression.encode.SimplifyBranchSame.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2F76803_regression.encode.SimplifyBranchSame.diff?ref=c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f", "patch": "@@ -1,29 +0,0 @@\n-- // MIR for `encode` before SimplifyBranchSame\n-+ // MIR for `encode` after SimplifyBranchSame\n-  \n-  fn encode(_1: Type) -> Type {\n-      debug v => _1;                       // in scope 0 at $DIR/76803_regression.rs:+0:15: +0:16\n-      let mut _0: Type;                    // return place in scope 0 at $DIR/76803_regression.rs:+0:27: +0:31\n-      let mut _2: isize;                   // in scope 0 at $DIR/76803_regression.rs:+2:9: +2:16\n-  \n-      bb0: {\n-          _2 = discriminant(_1);           // scope 0 at $DIR/76803_regression.rs:+1:11: +1:12\n-          switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/76803_regression.rs:+1:5: +1:12\n-      }\n-  \n-      bb1: {\n-          _0 = move _1;                    // scope 0 at $DIR/76803_regression.rs:+3:14: +3:15\n-          goto -> bb3;                     // scope 0 at $DIR/76803_regression.rs:+3:14: +3:15\n-      }\n-  \n-      bb2: {\n-          Deinit(_0);                      // scope 0 at $DIR/76803_regression.rs:+2:20: +2:27\n-          discriminant(_0) = 1;            // scope 0 at $DIR/76803_regression.rs:+2:20: +2:27\n-          goto -> bb3;                     // scope 0 at $DIR/76803_regression.rs:+2:20: +2:27\n-      }\n-  \n-      bb3: {\n-          return;                          // scope 0 at $DIR/76803_regression.rs:+5:2: +5:2\n-      }\n-  }\n-  "}, {"sha": "05dc3c97841099c6ff1741fcf55d5504eca1229a", "filename": "tests/mir-opt/76803_regression.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f/tests%2Fmir-opt%2F76803_regression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f/tests%2Fmir-opt%2F76803_regression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2F76803_regression.rs?ref=c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f", "patch": "@@ -1,19 +0,0 @@\n-// compile-flags: -Z mir-opt-level=1\n-// EMIT_MIR 76803_regression.encode.SimplifyBranchSame.diff\n-\n-#[derive(Debug, Eq, PartialEq)]\n-pub enum Type {\n-    A,\n-    B,\n-}\n-\n-pub fn encode(v: Type) -> Type {\n-    match v {\n-        Type::A => Type::B,\n-        _ => v,\n-    }\n-}\n-\n-fn main() {\n-    assert_eq!(Type::B, encode(Type::A));\n-}"}, {"sha": "bf3bcfdb5944266469c7ac301f05337fbd97b776", "filename": "tests/mir-opt/issue_73223.main.SimplifyArmIdentity.diff", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f/tests%2Fmir-opt%2Fissue_73223.main.SimplifyArmIdentity.diff", "raw_url": "https://github.com/rust-lang/rust/raw/c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f/tests%2Fmir-opt%2Fissue_73223.main.SimplifyArmIdentity.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissue_73223.main.SimplifyArmIdentity.diff?ref=c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f", "patch": "@@ -1,156 +0,0 @@\n-- // MIR for `main` before SimplifyArmIdentity\n-+ // MIR for `main` after SimplifyArmIdentity\n-  \n-  fn main() -> () {\n-      let mut _0: ();                      // return place in scope 0 at $DIR/issue_73223.rs:+0:11: +0:11\n-      let _1: i32;                         // in scope 0 at $DIR/issue_73223.rs:+1:9: +1:14\n-      let mut _2: std::option::Option<i32>; // in scope 0 at $DIR/issue_73223.rs:+1:23: +1:30\n-      let mut _3: isize;                   // in scope 0 at $DIR/issue_73223.rs:+2:9: +2:16\n-      let _4: i32;                         // in scope 0 at $DIR/issue_73223.rs:+2:14: +2:15\n-      let mut _6: i32;                     // in scope 0 at $DIR/issue_73223.rs:+6:22: +6:27\n-      let mut _7: &i32;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _8: &i32;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _11: bool;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _12: bool;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _13: i32;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _14: i32;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let _16: !;                          // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _17: core::panicking::AssertKind; // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _18: &i32;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let _19: &i32;                       // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _20: &i32;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let _21: &i32;                       // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _22: std::option::Option<std::fmt::Arguments<'_>>; // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _24: &i32;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _25: &i32;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      scope 1 {\n-          debug split => _1;               // in scope 1 at $DIR/issue_73223.rs:+1:9: +1:14\n-          let _5: std::option::Option<i32>; // in scope 1 at $DIR/issue_73223.rs:+6:9: +6:14\n-          scope 3 {\n-              debug _prev => _5;           // in scope 3 at $DIR/issue_73223.rs:+6:9: +6:14\n-              let _9: &i32;                // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-              let _10: &i32;               // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-              let mut _23: &i32;           // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-              scope 4 {\n-                  debug left_val => _9;    // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                  debug right_val => _10;  // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                  let _15: core::panicking::AssertKind; // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                  scope 5 {\n-                      debug kind => _15;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                  }\n-              }\n-          }\n-      }\n-      scope 2 {\n-          debug v => _4;                   // in scope 2 at $DIR/issue_73223.rs:+2:14: +2:15\n-      }\n-  \n-      bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/issue_73223.rs:+1:9: +1:14\n-          StorageLive(_2);                 // scope 0 at $DIR/issue_73223.rs:+1:23: +1:30\n-          Deinit(_2);                      // scope 0 at $DIR/issue_73223.rs:+1:23: +1:30\n-          ((_2 as Some).0: i32) = const 1_i32; // scope 0 at $DIR/issue_73223.rs:+1:23: +1:30\n-          discriminant(_2) = 1;            // scope 0 at $DIR/issue_73223.rs:+1:23: +1:30\n-          _3 = const 1_isize;              // scope 0 at $DIR/issue_73223.rs:+1:23: +1:30\n-          goto -> bb3;                     // scope 0 at $DIR/issue_73223.rs:+1:17: +1:30\n-      }\n-  \n-      bb1: {\n-          StorageDead(_2);                 // scope 0 at $DIR/issue_73223.rs:+4:6: +4:7\n-          StorageDead(_1);                 // scope 0 at $DIR/issue_73223.rs:+8:1: +8:2\n-          return;                          // scope 0 at $DIR/issue_73223.rs:+8:2: +8:2\n-      }\n-  \n-      bb2: {\n-          unreachable;                     // scope 0 at $DIR/issue_73223.rs:+1:23: +1:30\n-      }\n-  \n-      bb3: {\n-          StorageLive(_4);                 // scope 0 at $DIR/issue_73223.rs:+2:14: +2:15\n-          _4 = ((_2 as Some).0: i32);      // scope 0 at $DIR/issue_73223.rs:+2:14: +2:15\n-          _1 = _4;                         // scope 2 at $DIR/issue_73223.rs:+2:20: +2:21\n-          StorageDead(_4);                 // scope 0 at $DIR/issue_73223.rs:+2:20: +2:21\n-          StorageDead(_2);                 // scope 0 at $DIR/issue_73223.rs:+4:6: +4:7\n-          StorageLive(_5);                 // scope 1 at $DIR/issue_73223.rs:+6:9: +6:14\n-          StorageLive(_6);                 // scope 1 at $DIR/issue_73223.rs:+6:22: +6:27\n-          _6 = _1;                         // scope 1 at $DIR/issue_73223.rs:+6:22: +6:27\n-          Deinit(_5);                      // scope 1 at $DIR/issue_73223.rs:+6:17: +6:28\n-          ((_5 as Some).0: i32) = move _6; // scope 1 at $DIR/issue_73223.rs:+6:17: +6:28\n-          discriminant(_5) = 1;            // scope 1 at $DIR/issue_73223.rs:+6:17: +6:28\n-          StorageDead(_6);                 // scope 1 at $DIR/issue_73223.rs:+6:27: +6:28\n-          StorageLive(_24);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_25);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_7);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _7 = &_1;                        // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_8);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _23 = const _;                   // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                                           // mir::Constant\n-                                           // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                                           // + literal: Const { ty: &i32, val: Unevaluated(main, [], Some(promoted[0])) }\n-          _8 = _23;                        // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          Deinit(_24);                     // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          Deinit(_25);                     // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _24 = move _7;                   // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _25 = move _8;                   // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_8);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_7);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_9);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _9 = _24;                        // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_10);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _10 = _25;                       // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_11);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_12);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_13);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _13 = (*_9);                     // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_14);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _14 = const 1_i32;               // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _12 = Eq(move _13, const 1_i32); // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_14);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_13);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _11 = Not(move _12);             // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_12);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          switchInt(move _11) -> [0: bb5, otherwise: bb4]; // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      }\n-  \n-      bb4: {\n-          StorageLive(_15);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          Deinit(_15);                     // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          discriminant(_15) = 0;           // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_16);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_17);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _17 = const core::panicking::AssertKind::Eq; // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                                           // mir::Constant\n-                                           // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                                           // + literal: Const { ty: core::panicking::AssertKind, val: Value(Scalar(0x00)) }\n-          StorageLive(_18);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_19);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _19 = _9;                        // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _18 = _19;                       // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_20);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_21);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _21 = _10;                       // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _20 = _21;                       // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_22);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          Deinit(_22);                     // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          discriminant(_22) = 0;           // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _16 = core::panicking::assert_failed::<i32, i32>(const core::panicking::AssertKind::Eq, move _18, move _20, move _22); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                                           // mir::Constant\n-                                           // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                                           // + literal: Const { ty: for<'a, 'b, 'c> fn(core::panicking::AssertKind, &'a i32, &'b i32, Option<Arguments<'c>>) -> ! {core::panicking::assert_failed::<i32, i32>}, val: Value(<ZST>) }\n-                                           // mir::Constant\n-                                           // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                                           // + literal: Const { ty: core::panicking::AssertKind, val: Value(Scalar(0x00)) }\n-      }\n-  \n-      bb5: {\n-          StorageDead(_11);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_10);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_9);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_24);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_25);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_5);                 // scope 1 at $DIR/issue_73223.rs:+8:1: +8:2\n-          StorageDead(_1);                 // scope 0 at $DIR/issue_73223.rs:+8:1: +8:2\n-          return;                          // scope 0 at $DIR/issue_73223.rs:+8:2: +8:2\n-      }\n-  }\n-  "}, {"sha": "be114cab719c0c77fb5abdb715f464b549126fdc", "filename": "tests/mir-opt/issue_73223.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f/tests%2Fmir-opt%2Fissue_73223.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f/tests%2Fmir-opt%2Fissue_73223.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissue_73223.rs?ref=c20e0daf32b355e2a0ab9972cf19b2aa64c4d64f", "patch": "@@ -1,12 +0,0 @@\n-fn main() {\n-    let split = match Some(1) {\n-        Some(v) => v,\n-        None => return,\n-    };\n-\n-    let _prev = Some(split);\n-    assert_eq!(split, 1);\n-}\n-\n-\n-// EMIT_MIR issue_73223.main.SimplifyArmIdentity.diff"}]}