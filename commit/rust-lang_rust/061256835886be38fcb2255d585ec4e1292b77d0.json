{"sha": "061256835886be38fcb2255d585ec4e1292b77d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MTI1NjgzNTg4NmJlMzhmY2IyMjU1ZDU4NWVjNGUxMjkyYjc3ZDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-24T12:28:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-24T12:28:44Z"}, "message": "Auto merge of #71509 - Dylan-DPC:rollup-n8s37rm, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #71235 (Tweak `'static` suggestion code)\n - #71318 (miri-unleash tests: ensure they fire even with 'allow(const_err)')\n - #71428 (Let compiletest recognize gdb 10.x)\n - #71475 (Miri Frame: use mir::Location to represent position in function)\n - #71476 (more compact way to adjust test sizes for Miri)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "824994c9e189927b671453c26ac58e0ce72b7976", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/824994c9e189927b671453c26ac58e0ce72b7976"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/061256835886be38fcb2255d585ec4e1292b77d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/061256835886be38fcb2255d585ec4e1292b77d0", "html_url": "https://github.com/rust-lang/rust/commit/061256835886be38fcb2255d585ec4e1292b77d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/061256835886be38fcb2255d585ec4e1292b77d0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b958790b336738540d027d645718713849638d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b958790b336738540d027d645718713849638d7", "html_url": "https://github.com/rust-lang/rust/commit/0b958790b336738540d027d645718713849638d7"}, {"sha": "08ca4472679057539e71fdb78b9e45e74c6932db", "url": "https://api.github.com/repos/rust-lang/rust/commits/08ca4472679057539e71fdb78b9e45e74c6932db", "html_url": "https://github.com/rust-lang/rust/commit/08ca4472679057539e71fdb78b9e45e74c6932db"}], "stats": {"total": 1327, "additions": 829, "deletions": 498}, "files": [{"sha": "0a3f33003233f2dc5c1a7928afa5562bf05e03eb", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -386,10 +386,8 @@ fn test_vec_from_vecdeque() {\n         assert!(vec.into_iter().eq(vd));\n     }\n \n-    #[cfg(not(miri))] // Miri is too slow\n-    let max_pwr = 7;\n-    #[cfg(miri)]\n-    let max_pwr = 5;\n+    // Miri is too slow\n+    let max_pwr = if cfg!(miri) { 5 } else { 7 };\n \n     for cap_pwr in 0..max_pwr {\n         // Make capacity as a (2^x)-1, so that the ring size is 2^x"}, {"sha": "057afd41824e745b062e22cd5139ed7c5a3df422", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -409,16 +409,14 @@ fn panic_safe() {\n     }\n     let mut rng = thread_rng();\n     const DATASZ: usize = 32;\n-    #[cfg(not(miri))] // Miri is too slow\n-    const NTEST: usize = 10;\n-    #[cfg(miri)]\n-    const NTEST: usize = 1;\n+    // Miri is too slow\n+    let ntest = if cfg!(miri) { 1 } else { 10 };\n \n     // don't use 0 in the data -- we want to catch the zeroed-out case.\n     let data = (1..=DATASZ).collect::<Vec<_>>();\n \n     // since it's a fuzzy test, run several tries.\n-    for _ in 0..NTEST {\n+    for _ in 0..ntest {\n         for i in 1..=DATASZ {\n             DROP_COUNTER.store(0, Ordering::SeqCst);\n "}, {"sha": "731a1b5f875b7c32bcf1f046684287df1b5c599d", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -28,10 +28,8 @@ const MIN_INSERTS_HEIGHT_2: usize = NODE_CAPACITY + (NODE_CAPACITY + 1) * NODE_C\n #[test]\n fn test_basic_large() {\n     let mut map = BTreeMap::new();\n-    #[cfg(not(miri))] // Miri is too slow\n-    let size = 10000;\n-    #[cfg(miri)]\n-    let size = MIN_INSERTS_HEIGHT_2;\n+    // Miri is too slow\n+    let size = if cfg!(miri) { MIN_INSERTS_HEIGHT_2 } else { 10000 };\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n@@ -155,10 +153,8 @@ fn test_basic_small() {\n \n #[test]\n fn test_iter() {\n-    #[cfg(not(miri))] // Miri is too slow\n-    let size = 10000;\n-    #[cfg(miri)]\n-    let size = 200;\n+    // Miri is too slow\n+    let size = if cfg!(miri) { 200 } else { 10000 };\n \n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n@@ -180,10 +176,8 @@ fn test_iter() {\n \n #[test]\n fn test_iter_rev() {\n-    #[cfg(not(miri))] // Miri is too slow\n-    let size = 10000;\n-    #[cfg(miri)]\n-    let size = 200;\n+    // Miri is too slow\n+    let size = if cfg!(miri) { 200 } else { 10000 };\n \n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n@@ -289,10 +283,8 @@ fn test_values_mut() {\n \n #[test]\n fn test_iter_mixed() {\n-    #[cfg(not(miri))] // Miri is too slow\n-    let size = 10000;\n-    #[cfg(miri)]\n-    let size = 200;\n+    // Miri is too slow\n+    let size = if cfg!(miri) { 200 } else { 10000 };\n \n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n@@ -525,10 +517,8 @@ fn test_range_backwards_4() {\n \n #[test]\n fn test_range_1000() {\n-    #[cfg(not(miri))] // Miri is too slow\n-    let size = 1000;\n-    #[cfg(miri)]\n-    let size = MIN_INSERTS_HEIGHT_2 as u32;\n+    // Miri is too slow\n+    let size = if cfg!(miri) { MIN_INSERTS_HEIGHT_2 as u32 } else { 1000 };\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test(map: &BTreeMap<u32, u32>, size: u32, min: Bound<&u32>, max: Bound<&u32>) {\n@@ -566,10 +556,8 @@ fn test_range_borrowed_key() {\n #[test]\n fn test_range() {\n     let size = 200;\n-    #[cfg(not(miri))] // Miri is too slow\n-    let step = 1;\n-    #[cfg(miri)]\n-    let step = 66;\n+    // Miri is too slow\n+    let step = if cfg!(miri) { 66 } else { 1 };\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     for i in (0..size).step_by(step) {\n@@ -589,10 +577,8 @@ fn test_range() {\n #[test]\n fn test_range_mut() {\n     let size = 200;\n-    #[cfg(not(miri))] // Miri is too slow\n-    let step = 1;\n-    #[cfg(miri)]\n-    let step = 66;\n+    // Miri is too slow\n+    let step = if cfg!(miri) { 66 } else { 1 };\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     for i in (0..size).step_by(step) {\n@@ -1263,10 +1249,8 @@ fn test_split_off_empty_left() {\n \n #[test]\n fn test_split_off_large_random_sorted() {\n-    #[cfg(not(miri))] // Miri is too slow\n-    let mut data = rand_data(1529);\n-    #[cfg(miri)]\n-    let mut data = rand_data(529);\n+    // Miri is too slow\n+    let mut data = if cfg!(miri) { rand_data(529) } else { rand_data(1529) };\n     // special case with maximum height.\n     data.sort();\n "}, {"sha": "75251ca0d51e9b8b4c49f4f057d03da80f886e54", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -621,10 +621,8 @@ fn test_split_off_empty_left() {\n \n #[test]\n fn test_split_off_large_random_sorted() {\n-    #[cfg(not(miri))] // Miri is too slow\n-    let mut data = rand_data(1529);\n-    #[cfg(miri)]\n-    let mut data = rand_data(529);\n+    // Miri is too slow\n+    let mut data = if cfg!(miri) { rand_data(529) } else { rand_data(1529) };\n     // special case with maximum height.\n     data.sort();\n "}, {"sha": "75b76bb73ed9e83c327f949c833fb5f9f4022ca9", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -463,15 +463,9 @@ fn test_sort() {\n \n #[test]\n fn test_sort_stability() {\n-    #[cfg(not(miri))] // Miri is too slow\n-    let large_range = 500..510;\n-    #[cfg(not(miri))] // Miri is too slow\n-    let rounds = 10;\n-\n-    #[cfg(miri)]\n-    let large_range = 0..0; // empty range\n-    #[cfg(miri)]\n-    let rounds = 1;\n+    // Miri is too slow\n+    let large_range = if cfg!(miri) { 0..0 } else { 500..510 };\n+    let rounds = if cfg!(miri) { 1 } else { 10 };\n \n     for len in (2..25).chain(large_range) {\n         for _ in 0..rounds {\n@@ -1727,15 +1721,9 @@ fn panic_safe() {\n \n     let mut rng = thread_rng();\n \n-    #[cfg(not(miri))] // Miri is too slow\n-    let lens = (1..20).chain(70..MAX_LEN);\n-    #[cfg(not(miri))] // Miri is too slow\n-    let moduli = &[5, 20, 50];\n-\n-    #[cfg(miri)]\n-    let lens = 1..10;\n-    #[cfg(miri)]\n-    let moduli = &[5];\n+    // Miri is too slow\n+    let lens = if cfg!(miri) { (1..10).chain(20..21) } else { (1..20).chain(70..MAX_LEN) };\n+    let moduli: &[u32] = if cfg!(miri) { &[5] } else { &[5, 20, 50] };\n \n     for len in lens {\n         for &modulus in moduli {"}, {"sha": "762dc4be44d6208950d4bd03e2fba8de66c45fcc", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -954,16 +954,14 @@ fn test_append_permutations() {\n         out\n     }\n \n-    #[cfg(not(miri))] // Miri is too slow\n-    const MAX: usize = 5;\n-    #[cfg(miri)]\n-    const MAX: usize = 3;\n+    // Miri is too slow\n+    let max = if cfg!(miri) { 3 } else { 5 };\n \n     // Many different permutations of both the `VecDeque` getting appended to\n     // and the one getting appended are generated to check `append`.\n     // This ensures all 6 code paths of `append` are tested.\n-    for src_push_back in 0..MAX {\n-        for src_push_front in 0..MAX {\n+    for src_push_back in 0..max {\n+        for src_push_front in 0..max {\n             // doesn't pop more values than are pushed\n             for src_pop_back in 0..(src_push_back + src_push_front) {\n                 for src_pop_front in 0..(src_push_back + src_push_front - src_pop_back) {\n@@ -974,8 +972,8 @@ fn test_append_permutations() {\n                         src_pop_front,\n                     );\n \n-                    for dst_push_back in 0..MAX {\n-                        for dst_push_front in 0..MAX {\n+                    for dst_push_back in 0..max {\n+                        for dst_push_front in 0..max {\n                             for dst_pop_back in 0..(dst_push_back + dst_push_front) {\n                                 for dst_pop_front in\n                                     0..(dst_push_back + dst_push_front - dst_pop_back)"}, {"sha": "da203b5f3620ef7606115ebf7bfe1a3a6bba02b4", "filename": "src/libcore/tests/num/flt2dec/estimator.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -52,12 +52,10 @@ fn test_estimate_scaling_factor() {\n     assert_almost_eq!(estimate_scaling_factor(1, -1074), -323);\n     assert_almost_eq!(estimate_scaling_factor(0x1fffffffffffff, 971), 309);\n \n-    #[cfg(not(miri))] // Miri is too slow\n-    let iter = -1074..972;\n-    #[cfg(miri)]\n-    let iter = (-1074..972).step_by(37);\n+    // Miri is too slow\n+    let step = if cfg!(miri) { 37 } else { 1 };\n \n-    for i in iter {\n+    for i in (-1074..972).step_by(step) {\n         let expected = super::ldexp_f64(1.0, i).log10().ceil();\n         assert_almost_eq!(estimate_scaling_factor(1, i as i16), expected as i16);\n     }"}, {"sha": "0ebc0881f5223870ec8b546c302adb0aa9c9c30c", "filename": "src/libcore/tests/num/flt2dec/random.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -138,13 +138,11 @@ where\n #[test]\n fn shortest_random_equivalence_test() {\n     use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n-    #[cfg(not(miri))] // Miri is too slow\n-    const N: usize = 10_000;\n-    #[cfg(miri)]\n-    const N: usize = 10;\n+    // Miri is too slow\n+    let n = if cfg!(miri) { 10 } else { 10_000 };\n \n-    f64_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, N);\n-    f32_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, N);\n+    f64_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, n);\n+    f32_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, n);\n }\n \n #[test]\n@@ -173,35 +171,31 @@ fn shortest_f64_hard_random_equivalence_test() {\n #[test]\n fn exact_f32_random_equivalence_test() {\n     use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n-    #[cfg(not(miri))] // Miri is too slow\n-    const N: usize = 1_000;\n-    #[cfg(miri)]\n-    const N: usize = 3;\n+    // Miri is too slow\n+    let n = if cfg!(miri) { 3 } else { 1_000 };\n \n     for k in 1..21 {\n         f32_random_equivalence_test(\n             |d, buf| format_exact_opt(d, buf, i16::MIN),\n             |d, buf| fallback(d, buf, i16::MIN),\n             k,\n-            N,\n+            n,\n         );\n     }\n }\n \n #[test]\n fn exact_f64_random_equivalence_test() {\n     use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n-    #[cfg(not(miri))] // Miri is too slow\n-    const N: usize = 1_000;\n-    #[cfg(miri)]\n-    const N: usize = 3;\n+    // Miri is too slow\n+    let n = if cfg!(miri) { 3 } else { 1_000 };\n \n     for k in 1..21 {\n         f64_random_equivalence_test(\n             |d, buf| format_exact_opt(d, buf, i16::MIN),\n             |d, buf| fallback(d, buf, i16::MIN),\n             k,\n-            N,\n+            n,\n         );\n     }\n }"}, {"sha": "54a585415bce2b512a93a3d52ff85052d242b816", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -1227,15 +1227,9 @@ fn sort_unstable() {\n     use core::slice::heapsort;\n     use rand::{rngs::StdRng, seq::SliceRandom, Rng, SeedableRng};\n \n-    #[cfg(not(miri))] // Miri is too slow\n-    let large_range = 500..510;\n-    #[cfg(not(miri))] // Miri is too slow\n-    let rounds = 100;\n-\n-    #[cfg(miri)]\n-    let large_range = 0..0; // empty range\n-    #[cfg(miri)]\n-    let rounds = 1;\n+    // Miri is too slow\n+    let large_range = if cfg!(miri) { 0..0 } else { 500..510 };\n+    let rounds = if cfg!(miri) { 1 } else { 100 };\n \n     let mut v = [0; 600];\n     let mut tmp = [0; 600];"}, {"sha": "cf6dde813096bf73014ed97405380a4990eef762", "filename": "src/librustc_ast_lowering/path.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibrustc_ast_lowering%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibrustc_ast_lowering%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpath.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -273,7 +273,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .next();\n         if !generic_args.parenthesized && !has_lifetimes {\n             generic_args.args = self\n-                .elided_path_lifetimes(path_span, expected_lifetimes)\n+                .elided_path_lifetimes(\n+                    first_generic_span.map(|s| s.shrink_to_lo()).unwrap_or(segment.ident.span),\n+                    expected_lifetimes,\n+                )\n                 .map(GenericArg::Lifetime)\n                 .chain(generic_args.args.into_iter())\n                 .collect();"}, {"sha": "45abde434772834a99d7b58c256d4a97cee22ce0", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -81,14 +81,9 @@ pub struct Frame<'mir, 'tcx, Tag = (), Extra = ()> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n     ////////////////////////////////////////////////////////////////////////////////\n-    /// The block that is currently executed (or will be executed after the above call stacks\n-    /// return).\n     /// If this is `None`, we are unwinding and this function doesn't need any clean-up.\n     /// Just continue the same as with `Resume`.\n-    pub block: Option<mir::BasicBlock>,\n-\n-    /// The index of the currently evaluated statement.\n-    pub stmt: usize,\n+    pub loc: Option<mir::Location>,\n }\n \n #[derive(Clone, Eq, PartialEq, Debug, HashStable)] // Miri debug-prints these\n@@ -168,8 +163,7 @@ impl<'mir, 'tcx, Tag> Frame<'mir, 'tcx, Tag> {\n             return_to_block: self.return_to_block,\n             return_place: self.return_place,\n             locals: self.locals,\n-            block: self.block,\n-            stmt: self.stmt,\n+            loc: self.loc,\n             extra,\n         }\n     }\n@@ -178,10 +172,10 @@ impl<'mir, 'tcx, Tag> Frame<'mir, 'tcx, Tag> {\n impl<'mir, 'tcx, Tag, Extra> Frame<'mir, 'tcx, Tag, Extra> {\n     /// Return the `SourceInfo` of the current instruction.\n     pub fn current_source_info(&self) -> Option<mir::SourceInfo> {\n-        self.block.map(|block| {\n-            let block = &self.body.basic_blocks()[block];\n-            if self.stmt < block.statements.len() {\n-                block.statements[self.stmt].source_info\n+        self.loc.map(|loc| {\n+            let block = &self.body.basic_blocks()[loc.block];\n+            if loc.statement_index < block.statements.len() {\n+                block.statements[loc.statement_index].source_info\n             } else {\n                 block.terminator().source_info\n             }\n@@ -615,14 +609,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // first push a stack frame so we have access to the local substs\n         let pre_frame = Frame {\n             body,\n-            block: Some(mir::START_BLOCK),\n+            loc: Some(mir::Location::START),\n             return_to_block,\n             return_place,\n             // empty local array, we fill it in below, after we are inside the stack frame and\n             // all methods actually know about the frame\n             locals: IndexVec::new(),\n             instance,\n-            stmt: 0,\n             extra: (),\n         };\n         let frame = M::init_frame_extra(self, pre_frame)?;\n@@ -666,9 +659,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Jump to the given block.\n     #[inline]\n     pub fn go_to_block(&mut self, target: mir::BasicBlock) {\n-        let frame = self.frame_mut();\n-        frame.block = Some(target);\n-        frame.stmt = 0;\n+        self.frame_mut().loc = Some(mir::Location { block: target, statement_index: 0 });\n     }\n \n     /// *Return* to the given `target` basic block.\n@@ -690,9 +681,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// If `target` is `None`, that indicates the function does not need cleanup during\n     /// unwinding, and we will just keep propagating that upwards.\n     pub fn unwind_to_block(&mut self, target: Option<mir::BasicBlock>) {\n-        let frame = self.frame_mut();\n-        frame.block = target;\n-        frame.stmt = 0;\n+        self.frame_mut().loc = target.map(|block| mir::Location { block, statement_index: 0 });\n     }\n \n     /// Pops the current frame from the stack, deallocating the\n@@ -719,9 +708,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Sanity check `unwinding`.\n         assert_eq!(\n             unwinding,\n-            match self.frame().block {\n+            match self.frame().loc {\n                 None => true,\n-                Some(block) => self.body().basic_blocks()[block].is_cleanup,\n+                Some(loc) => self.body().basic_blocks()[loc.block].is_cleanup,\n             }\n         );\n \n@@ -973,13 +962,14 @@ where\n     Tag: HashStable<StableHashingContext<'ctx>>,\n {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'ctx>, hasher: &mut StableHasher) {\n-        self.body.hash_stable(hcx, hasher);\n-        self.instance.hash_stable(hcx, hasher);\n-        self.return_to_block.hash_stable(hcx, hasher);\n-        self.return_place.as_ref().map(|r| &**r).hash_stable(hcx, hasher);\n-        self.locals.hash_stable(hcx, hasher);\n-        self.block.hash_stable(hcx, hasher);\n-        self.stmt.hash_stable(hcx, hasher);\n-        self.extra.hash_stable(hcx, hasher);\n+        // Exhaustive match on fields to make sure we forget no field.\n+        let Frame { body, instance, return_to_block, return_place, locals, loc, extra } = self;\n+        body.hash_stable(hcx, hasher);\n+        instance.hash_stable(hcx, hasher);\n+        return_to_block.hash_stable(hcx, hasher);\n+        return_place.as_ref().map(|r| &**r).hash_stable(hcx, hasher);\n+        locals.hash_stable(hcx, hasher);\n+        loc.hash_stable(hcx, hasher);\n+        extra.hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "bb4c0156c88cf8d3e4308a66487a94c90fc03ead", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -46,8 +46,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(false);\n         }\n \n-        let block = match self.frame().block {\n-            Some(block) => block,\n+        let loc = match self.frame().loc {\n+            Some(loc) => loc,\n             None => {\n                 // We are unwinding and this fn has no cleanup code.\n                 // Just go on unwinding.\n@@ -56,13 +56,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 return Ok(true);\n             }\n         };\n-        let stmt_id = self.frame().stmt;\n-        let body = self.body();\n-        let basic_block = &body.basic_blocks()[block];\n+        let basic_block = &self.body().basic_blocks()[loc.block];\n \n         let old_frames = self.frame_idx();\n \n-        if let Some(stmt) = basic_block.statements.get(stmt_id) {\n+        if let Some(stmt) = basic_block.statements.get(loc.statement_index) {\n             assert_eq!(old_frames, self.frame_idx());\n             self.statement(stmt)?;\n             return Ok(true);\n@@ -126,7 +124,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             LlvmInlineAsm { .. } => throw_unsup_format!(\"inline assembly is not supported\"),\n         }\n \n-        self.stack_mut()[frame_idx].stmt += 1;\n+        self.stack_mut()[frame_idx].loc.as_mut().unwrap().statement_index += 1;\n         Ok(())\n     }\n \n@@ -279,8 +277,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         self.eval_terminator(terminator)?;\n         if !self.stack().is_empty() {\n-            if let Some(block) = self.frame().block {\n-                info!(\"// executing {:?}\", block);\n+            if let Some(loc) = self.frame().loc {\n+                info!(\"// executing {:?}\", loc.block);\n             }\n         }\n         Ok(())"}, {"sha": "9f9ec0f6a7834794fcc599226e052606216c63f5", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -52,7 +52,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Call { ref func, ref args, destination, ref cleanup, .. } => {\n                 let old_stack = self.frame_idx();\n-                let old_bb = self.frame().block;\n+                let old_loc = self.frame().loc;\n                 let func = self.eval_operand(func, None)?;\n                 let (fn_val, abi) = match func.layout.ty.kind {\n                     ty::FnPtr(sig) => {\n@@ -79,7 +79,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.eval_fn_call(fn_val, abi, &args[..], ret, *cleanup)?;\n                 // Sanity-check that `eval_fn_call` either pushed a new frame or\n                 // did a jump to another block.\n-                if self.frame_idx() == old_stack && self.frame().block == old_bb {\n+                if self.frame_idx() == old_stack && self.frame().loc == old_loc {\n                     span_bug!(terminator.source_info.span, \"evaluating this call made no progress\");\n                 }\n             }"}, {"sha": "c25a3524dc1087f4c6f92003d3a443fdd2e0116c", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 111, "deletions": 87, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -1034,101 +1034,125 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         lifetime_names: &FxHashSet<ast::Ident>,\n         params: &[ElisionFailureInfo],\n     ) {\n-        if count > 1 {\n-            err.span_label(span, format!(\"expected {} lifetime parameters\", count));\n-        } else {\n-            let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok();\n-            let suggest_existing = |err: &mut DiagnosticBuilder<'_>, sugg| {\n-                err.span_suggestion(\n-                    span,\n-                    \"consider using the named lifetime\",\n-                    sugg,\n-                    Applicability::MaybeIncorrect,\n-                );\n-            };\n-            let suggest_new = |err: &mut DiagnosticBuilder<'_>, sugg: &str| {\n-                err.span_label(span, \"expected named lifetime parameter\");\n+        let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok();\n \n-                for missing in self.missing_named_lifetime_spots.iter().rev() {\n-                    let mut introduce_suggestion = vec![];\n-                    let msg;\n-                    let should_break;\n-                    introduce_suggestion.push(match missing {\n-                        MissingLifetimeSpot::Generics(generics) => {\n-                            msg = \"consider introducing a named lifetime parameter\".to_string();\n-                            should_break = true;\n-                            if let Some(param) = generics.params.iter().find(|p| match p.kind {\n-                                hir::GenericParamKind::Type {\n-                                    synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n-                                    ..\n-                                } => false,\n-                                _ => true,\n-                            }) {\n-                                (param.span.shrink_to_lo(), \"'a, \".to_string())\n-                            } else {\n-                                (generics.span, \"<'a>\".to_string())\n-                            }\n-                        }\n-                        MissingLifetimeSpot::HigherRanked { span, span_type } => {\n-                            msg = format!(\n-                                \"consider making the {} lifetime-generic with a new `'a` lifetime\",\n-                                span_type.descr(),\n-                            );\n-                            should_break = false;\n-                            err.note(\n-                                \"for more information on higher-ranked polymorphism, visit \\\n-                             https://doc.rust-lang.org/nomicon/hrtb.html\",\n-                            );\n-                            (*span, span_type.suggestion(\"'a\"))\n-                        }\n-                    });\n-                    for param in params {\n-                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span)\n-                        {\n-                            if snippet.starts_with('&') && !snippet.starts_with(\"&'\") {\n-                                introduce_suggestion\n-                                    .push((param.span, format!(\"&'a {}\", &snippet[1..])));\n-                            } else if snippet.starts_with(\"&'_ \") {\n-                                introduce_suggestion\n-                                    .push((param.span, format!(\"&'a {}\", &snippet[4..])));\n-                            }\n+        err.span_label(\n+            span,\n+            &format!(\n+                \"expected {} lifetime parameter{}\",\n+                if count == 1 { \"named\".to_string() } else { count.to_string() },\n+                pluralize!(count)\n+            ),\n+        );\n+\n+        let suggest_existing = |err: &mut DiagnosticBuilder<'_>, sugg| {\n+            err.span_suggestion_verbose(\n+                span,\n+                &format!(\"consider using the `{}` lifetime\", lifetime_names.iter().next().unwrap()),\n+                sugg,\n+                Applicability::MaybeIncorrect,\n+            );\n+        };\n+        let suggest_new = |err: &mut DiagnosticBuilder<'_>, sugg: &str| {\n+            for missing in self.missing_named_lifetime_spots.iter().rev() {\n+                let mut introduce_suggestion = vec![];\n+                let msg;\n+                let should_break;\n+                introduce_suggestion.push(match missing {\n+                    MissingLifetimeSpot::Generics(generics) => {\n+                        msg = \"consider introducing a named lifetime parameter\".to_string();\n+                        should_break = true;\n+                        if let Some(param) = generics.params.iter().find(|p| match p.kind {\n+                            hir::GenericParamKind::Type {\n+                                synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+                                ..\n+                            } => false,\n+                            _ => true,\n+                        }) {\n+                            (param.span.shrink_to_lo(), \"'a, \".to_string())\n+                        } else {\n+                            (generics.span, \"<'a>\".to_string())\n                         }\n                     }\n-                    introduce_suggestion.push((span, sugg.to_string()));\n-                    err.multipart_suggestion(\n-                        &msg,\n-                        introduce_suggestion,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    if should_break {\n-                        break;\n+                    MissingLifetimeSpot::HigherRanked { span, span_type } => {\n+                        msg = format!(\n+                            \"consider making the {} lifetime-generic with a new `'a` lifetime\",\n+                            span_type.descr(),\n+                        );\n+                        should_break = false;\n+                        err.note(\n+                            \"for more information on higher-ranked polymorphism, visit \\\n+                            https://doc.rust-lang.org/nomicon/hrtb.html\",\n+                        );\n+                        (*span, span_type.suggestion(\"'a\"))\n+                    }\n+                });\n+                for param in params {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span) {\n+                        if snippet.starts_with('&') && !snippet.starts_with(\"&'\") {\n+                            introduce_suggestion\n+                                .push((param.span, format!(\"&'a {}\", &snippet[1..])));\n+                        } else if snippet.starts_with(\"&'_ \") {\n+                            introduce_suggestion\n+                                .push((param.span, format!(\"&'a {}\", &snippet[4..])));\n+                        }\n                     }\n                 }\n-            };\n-\n-            match (lifetime_names.len(), lifetime_names.iter().next(), snippet.as_deref()) {\n-                (1, Some(name), Some(\"&\")) => {\n-                    suggest_existing(err, format!(\"&{} \", name));\n-                }\n-                (1, Some(name), Some(\"'_\")) => {\n-                    suggest_existing(err, name.to_string());\n-                }\n-                (1, Some(name), Some(snippet)) if !snippet.ends_with('>') => {\n-                    suggest_existing(err, format!(\"{}<{}>\", snippet, name));\n-                }\n-                (0, _, Some(\"&\")) => {\n-                    suggest_new(err, \"&'a \");\n-                }\n-                (0, _, Some(\"'_\")) => {\n-                    suggest_new(err, \"'a\");\n-                }\n-                (0, _, Some(snippet)) if !snippet.ends_with('>') => {\n-                    suggest_new(err, &format!(\"{}<'a>\", snippet));\n+                introduce_suggestion.push((span, sugg.to_string()));\n+                err.multipart_suggestion(&msg, introduce_suggestion, Applicability::MaybeIncorrect);\n+                if should_break {\n+                    break;\n                 }\n-                _ => {\n-                    err.span_label(span, \"expected lifetime parameter\");\n+            }\n+        };\n+\n+        match (lifetime_names.len(), lifetime_names.iter().next(), snippet.as_deref()) {\n+            (1, Some(name), Some(\"&\")) => {\n+                suggest_existing(err, format!(\"&{} \", name));\n+            }\n+            (1, Some(name), Some(\"'_\")) => {\n+                suggest_existing(err, name.to_string());\n+            }\n+            (1, Some(name), Some(\"\")) => {\n+                suggest_existing(err, format!(\"{}, \", name).repeat(count));\n+            }\n+            (1, Some(name), Some(snippet)) if !snippet.ends_with('>') => {\n+                suggest_existing(\n+                    err,\n+                    format!(\n+                        \"{}<{}>\",\n+                        snippet,\n+                        std::iter::repeat(name.to_string())\n+                            .take(count)\n+                            .collect::<Vec<_>>()\n+                            .join(\", \")\n+                    ),\n+                );\n+            }\n+            (0, _, Some(\"&\")) if count == 1 => {\n+                suggest_new(err, \"&'a \");\n+            }\n+            (0, _, Some(\"'_\")) if count == 1 => {\n+                suggest_new(err, \"'a\");\n+            }\n+            (0, _, Some(snippet)) if !snippet.ends_with('>') && count == 1 => {\n+                suggest_new(err, &format!(\"{}<'a>\", snippet));\n+            }\n+            (n, ..) if n > 1 => {\n+                let spans: Vec<Span> = lifetime_names.iter().map(|lt| lt.span).collect();\n+                err.span_note(spans, \"these named lifetimes are available to use\");\n+                if Some(\"\") == snippet.as_deref() {\n+                    // This happens when we have `Foo<T>` where we point at the space before `T`,\n+                    // but this can be confusing so we give a suggestion with placeholders.\n+                    err.span_suggestion_verbose(\n+                        span,\n+                        \"consider using one of the available lifetimes here\",\n+                        \"'lifetime, \".repeat(count),\n+                        Applicability::HasPlaceholders,\n+                    );\n                 }\n             }\n+            _ => {}\n         }\n     }\n }"}, {"sha": "0deb0af448e7bb69ece3042ab23fd47e218846a6", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 15, "deletions": 40, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -2393,52 +2393,28 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         };\n \n         let mut err = self.report_missing_lifetime_specifiers(span, lifetime_refs.len());\n-        let mut add_label = true;\n \n         if let Some(params) = error {\n-            if lifetime_refs.len() == 1 {\n-                add_label = add_label && self.report_elision_failure(&mut err, params, span);\n+            // If there's no lifetime available, suggest `'static`.\n+            if self.report_elision_failure(&mut err, params) && lifetime_names.is_empty() {\n+                lifetime_names.insert(ast::Ident::from_str(\"'static\"));\n             }\n         }\n-        if add_label {\n-            self.add_missing_lifetime_specifiers_label(\n-                &mut err,\n-                span,\n-                lifetime_refs.len(),\n-                &lifetime_names,\n-                error.map(|p| &p[..]).unwrap_or(&[]),\n-            );\n-        }\n-\n+        self.add_missing_lifetime_specifiers_label(\n+            &mut err,\n+            span,\n+            lifetime_refs.len(),\n+            &lifetime_names,\n+            error.map(|p| &p[..]).unwrap_or(&[]),\n+        );\n         err.emit();\n     }\n \n-    fn suggest_lifetime(&self, db: &mut DiagnosticBuilder<'_>, span: Span, msg: &str) -> bool {\n-        match self.tcx.sess.source_map().span_to_snippet(span) {\n-            Ok(ref snippet) => {\n-                let (sugg, applicability) = if snippet == \"&\" {\n-                    (\"&'static \".to_owned(), Applicability::MachineApplicable)\n-                } else if snippet == \"'_\" {\n-                    (\"'static\".to_owned(), Applicability::MachineApplicable)\n-                } else {\n-                    (format!(\"{} + 'static\", snippet), Applicability::MaybeIncorrect)\n-                };\n-                db.span_suggestion(span, msg, sugg, applicability);\n-                false\n-            }\n-            Err(_) => {\n-                db.help(msg);\n-                true\n-            }\n-        }\n-    }\n-\n     fn report_elision_failure(\n         &mut self,\n         db: &mut DiagnosticBuilder<'_>,\n         params: &[ElisionFailureInfo],\n-        span: Span,\n-    ) -> bool {\n+    ) -> bool /* add `'static` lifetime to lifetime list */ {\n         let mut m = String::new();\n         let len = params.len();\n \n@@ -2487,29 +2463,28 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 \"this function's return type contains a borrowed value, \\\n                  but there is no value for it to be borrowed from\",\n             );\n-            self.suggest_lifetime(db, span, \"consider giving it a 'static lifetime\")\n+            true\n         } else if elided_len == 0 {\n             db.help(\n                 \"this function's return type contains a borrowed value with \\\n                  an elided lifetime, but the lifetime cannot be derived from \\\n                  the arguments\",\n             );\n-            let msg = \"consider giving it an explicit bounded or 'static lifetime\";\n-            self.suggest_lifetime(db, span, msg)\n+            true\n         } else if elided_len == 1 {\n             db.help(&format!(\n                 \"this function's return type contains a borrowed value, \\\n                  but the signature does not say which {} it is borrowed from\",\n                 m\n             ));\n-            true\n+            false\n         } else {\n             db.help(&format!(\n                 \"this function's return type contains a borrowed value, \\\n                  but the signature does not say whether it is borrowed from {}\",\n                 m\n             ));\n-            true\n+            false\n         }\n     }\n "}, {"sha": "e8252d96350dbf1de05583dda8bb51051a83aeef", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -657,7 +657,8 @@ impl MultiSpan {\n         MultiSpan { primary_spans: vec![primary_span], span_labels: vec![] }\n     }\n \n-    pub fn from_spans(vec: Vec<Span>) -> MultiSpan {\n+    pub fn from_spans(mut vec: Vec<Span>) -> MultiSpan {\n+        vec.sort();\n         MultiSpan { primary_spans: vec, span_labels: vec![] }\n     }\n "}, {"sha": "706dca999fa32de762a2e21f8aa84fa56aa5fdf0", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -1017,18 +1017,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n \n-        let path_span = if let [segment] = &trait_ref.path.segments[..] {\n-            // FIXME: `trait_ref.path.span` can point to a full path with multiple\n-            // segments, even though `trait_ref.path.segments` is of length `1`. Work\n-            // around that bug here, even though it should be fixed elsewhere.\n-            // This would otherwise cause an invalid suggestion. For an example, look at\n-            // `src/test/ui/issues/issue-28344.rs`.\n-            segment.ident.span\n-        } else {\n-            trait_ref.path.span\n-        };\n         let (substs, assoc_bindings, arg_count_correct) = self.create_substs_for_ast_trait_ref(\n-            path_span,\n+            trait_ref.path.span,\n             trait_def_id,\n             self_ty,\n             trait_ref.path.segments.last().unwrap(),\n@@ -1729,6 +1719,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     self.ast_region_to_region(lifetime, None)\n                 } else {\n                     self.re_infer(None, span).unwrap_or_else(|| {\n+                        // FIXME: these can be redundant with E0106, but not always.\n                         struct_span_err!(\n                             tcx.sess,\n                             span,"}, {"sha": "00f44129cc8b72126cc4f02f48e0179db6bff23d", "filename": "src/test/ui/associated-types/bound-lifetime-in-binding-only.elision.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.elision.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -2,9 +2,13 @@ error[E0106]: missing lifetime specifier\n   --> $DIR/bound-lifetime-in-binding-only.rs:52:23\n    |\n LL | fn elision<T: Fn() -> &i32>() {\n-   |                       ^ help: consider giving it a 'static lifetime: `&'static`\n+   |                       ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn elision<T: Fn() -> &'static i32>() {\n+   |                       ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "a5242707c7105b1a83cb9018764e18cc87679587", "filename": "src/test/ui/associated-types/bound-lifetime-in-return-only.elision.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.elision.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -2,9 +2,13 @@ error[E0106]: missing lifetime specifier\n   --> $DIR/bound-lifetime-in-return-only.rs:34:23\n    |\n LL | fn elision(_: fn() -> &i32) {\n-   |                       ^ help: consider giving it a 'static lifetime: `&'static`\n+   |                       ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn elision(_: fn() -> &'static i32) {\n+   |                       ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "ca42263dfed7b0622a542acfb79ab7a77dd42c09", "filename": "src/test/ui/async-await/issues/issue-63388-2.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -4,9 +4,13 @@ error[E0106]: missing lifetime specifier\n LL |         foo: &dyn Foo, bar: &'a dyn Foo\n    |              --------       -----------\n LL |     ) -> &dyn Foo\n-   |          ^ help: consider using the named lifetime: `&'a`\n+   |          ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `foo` or `bar`\n+help: consider using the `'a` lifetime\n+   |\n+LL |     ) -> &'a dyn Foo\n+   |          ^^^\n \n error: aborting due to previous error\n "}, {"sha": "4626a4bc2dcff84d7599d26c4aed6369f37af457", "filename": "src/test/ui/c-variadic/variadic-ffi-6.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-6.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -2,9 +2,13 @@ error[E0106]: missing lifetime specifier\n   --> $DIR/variadic-ffi-6.rs:7:6\n    |\n LL | ) -> &usize {\n-   |      ^ help: consider giving it an explicit bounded or 'static lifetime: `&'static`\n+   |      ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+help: consider using the `'static` lifetime\n+   |\n+LL | ) -> &'static usize {\n+   |      ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "a99e6327987f0cd6d02f2c6342d0f7f09c052696", "filename": "src/test/ui/consts/miri_unleashed/abi-mismatch.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -2,15 +2,20 @@\n // compile-flags: -Z unleash-the-miri-inside-of-you\n \n #![feature(const_extern_fn)]\n+#![allow(const_err)]\n \n const extern \"C\" fn c_fn() {}\n \n const fn call_rust_fn(my_fn: extern \"Rust\" fn()) {\n-    my_fn(); //~ ERROR any use of this value will cause an error\n+    my_fn();\n     //~^ WARN skipping const checks\n+    //~| ERROR could not evaluate static initializer\n+    //~| NOTE calling a function with ABI C using caller ABI Rust\n+    //~| NOTE inside `call_rust_fn`\n }\n \n-const VAL: () = call_rust_fn(unsafe { std::mem::transmute(c_fn as extern \"C\" fn()) });\n+static VAL: () = call_rust_fn(unsafe { std::mem::transmute(c_fn as extern \"C\" fn()) });\n //~^ WARN skipping const checks\n+//~| NOTE inside `VAL`\n \n fn main() {}"}, {"sha": "674a293d2815e88bf052dd0ec76597b1e5b77c7e", "filename": "src/test/ui/consts/miri_unleashed/abi-mismatch.stderr", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -1,29 +1,27 @@\n warning: skipping const checks\n-  --> $DIR/abi-mismatch.rs:9:5\n+  --> $DIR/abi-mismatch.rs:10:5\n    |\n LL |     my_fn();\n    |     ^^^^^^^\n \n warning: skipping const checks\n-  --> $DIR/abi-mismatch.rs:13:39\n+  --> $DIR/abi-mismatch.rs:17:40\n    |\n-LL | const VAL: () = call_rust_fn(unsafe { std::mem::transmute(c_fn as extern \"C\" fn()) });\n-   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | static VAL: () = call_rust_fn(unsafe { std::mem::transmute(c_fn as extern \"C\" fn()) });\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: any use of this value will cause an error\n-  --> $DIR/abi-mismatch.rs:9:5\n+error[E0080]: could not evaluate static initializer\n+  --> $DIR/abi-mismatch.rs:10:5\n    |\n LL |     my_fn();\n    |     ^^^^^^^\n    |     |\n    |     calling a function with ABI C using caller ABI Rust\n-   |     inside `call_rust_fn` at $DIR/abi-mismatch.rs:9:5\n-   |     inside `VAL` at $DIR/abi-mismatch.rs:13:17\n+   |     inside `call_rust_fn` at $DIR/abi-mismatch.rs:10:5\n ...\n-LL | const VAL: () = call_rust_fn(unsafe { std::mem::transmute(c_fn as extern \"C\" fn()) });\n-   | --------------------------------------------------------------------------------------\n-   |\n-   = note: `#[deny(const_err)]` on by default\n+LL | static VAL: () = call_rust_fn(unsafe { std::mem::transmute(c_fn as extern \"C\" fn()) });\n+   |                  --------------------------------------------------------------------- inside `VAL` at $DIR/abi-mismatch.rs:17:18\n \n error: aborting due to previous error; 2 warnings emitted\n \n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "1b18470eded42c4d315a9ff8fd2a6d29f653e954", "filename": "src/test/ui/consts/miri_unleashed/box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fbox.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -1,6 +1,6 @@\n // compile-flags: -Zunleash-the-miri-inside-of-you\n #![feature(const_mut_refs, box_syntax)]\n-#![deny(const_err)]\n+#![allow(const_err)]\n \n use std::mem::ManuallyDrop;\n "}, {"sha": "11f4a30d1779b3c3a2182b014197ae73584ade2d", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -1,39 +1,37 @@\n+// build-fail\n // compile-flags: -Zunleash-the-miri-inside-of-you\n-#![warn(const_err)]\n+#![allow(const_err)]\n \n #![feature(const_raw_ptr_deref)]\n \n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;\n \n-const REF_INTERIOR_MUT: &usize = { //~ ERROR undefined behavior to use this value\n-    static FOO: AtomicUsize = AtomicUsize::new(0);\n-    unsafe { &*(&FOO as *const _ as *const usize) }\n-    //~^ WARN skipping const checks\n-};\n+// These tests only cause an error when *using* the const.\n \n const MUTATE_INTERIOR_MUT: usize = {\n     static FOO: AtomicUsize = AtomicUsize::new(0);\n-    FOO.fetch_add(1, Ordering::Relaxed) //~ WARN any use of this value will cause an error\n+    FOO.fetch_add(1, Ordering::Relaxed)\n     //~^ WARN skipping const checks\n     //~| WARN skipping const checks\n };\n \n const READ_INTERIOR_MUT: usize = {\n     static FOO: AtomicUsize = AtomicUsize::new(0);\n-    unsafe { *(&FOO as *const _ as *const usize) } //~ WARN any use of this value will cause an err\n+    unsafe { *(&FOO as *const _ as *const usize) }\n     //~^ WARN skipping const checks\n };\n \n static mut MUTABLE: u32 = 0;\n-const READ_MUT: u32 = unsafe { MUTABLE }; //~ WARN any use of this value will cause an error\n+const READ_MUT: u32 = unsafe { MUTABLE };\n //~^ WARN skipping const checks\n //~| WARN skipping const checks\n \n-// ok some day perhaps\n-const READ_IMMUT: &usize = { //~ ERROR it is undefined behavior to use this value\n-    static FOO: usize = 0;\n-    &FOO\n-    //~^ WARN skipping const checks\n-};\n-fn main() {}\n+fn main() {\n+    MUTATE_INTERIOR_MUT;\n+    //~^ ERROR: erroneous constant used\n+    READ_INTERIOR_MUT;\n+    //~^ ERROR: erroneous constant used\n+    READ_MUT;\n+    //~^ ERROR: erroneous constant used\n+}"}, {"sha": "788762808f13b1f3e0c7b4390a8f7e9008a135f5", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static.stderr", "status": "modified", "additions": 18, "deletions": 73, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -1,106 +1,51 @@\n warning: skipping const checks\n-  --> $DIR/const_refers_to_static.rs:11:18\n-   |\n-LL |     unsafe { &*(&FOO as *const _ as *const usize) }\n-   |                  ^^^\n-\n-warning: skipping const checks\n-  --> $DIR/const_refers_to_static.rs:17:5\n+  --> $DIR/const_refers_to_static.rs:14:5\n    |\n LL |     FOO.fetch_add(1, Ordering::Relaxed)\n    |     ^^^\n \n warning: skipping const checks\n-  --> $DIR/const_refers_to_static.rs:17:5\n+  --> $DIR/const_refers_to_static.rs:14:5\n    |\n LL |     FOO.fetch_add(1, Ordering::Relaxed)\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: skipping const checks\n-  --> $DIR/const_refers_to_static.rs:24:17\n+  --> $DIR/const_refers_to_static.rs:21:17\n    |\n LL |     unsafe { *(&FOO as *const _ as *const usize) }\n    |                 ^^^\n \n warning: skipping const checks\n-  --> $DIR/const_refers_to_static.rs:29:32\n+  --> $DIR/const_refers_to_static.rs:26:32\n    |\n LL | const READ_MUT: u32 = unsafe { MUTABLE };\n    |                                ^^^^^^^\n \n warning: skipping const checks\n-  --> $DIR/const_refers_to_static.rs:29:32\n+  --> $DIR/const_refers_to_static.rs:26:32\n    |\n LL | const READ_MUT: u32 = unsafe { MUTABLE };\n    |                                ^^^^^^^\n \n-warning: skipping const checks\n-  --> $DIR/const_refers_to_static.rs:36:6\n+error[E0080]: erroneous constant used\n+  --> $DIR/const_refers_to_static.rs:31:5\n    |\n-LL |     &FOO\n-   |      ^^^\n+LL |     MUTATE_INTERIOR_MUT;\n+   |     ^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/const_refers_to_static.rs:9:1\n+error[E0080]: erroneous constant used\n+  --> $DIR/const_refers_to_static.rs:33:5\n    |\n-LL | / const REF_INTERIOR_MUT: &usize = {\n-LL | |     static FOO: AtomicUsize = AtomicUsize::new(0);\n-LL | |     unsafe { &*(&FOO as *const _ as *const usize) }\n-LL | |\n-LL | | };\n-   | |__^ type validation failed: encountered a reference pointing to a static variable\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+LL |     READ_INTERIOR_MUT;\n+   |     ^^^^^^^^^^^^^^^^^ referenced constant has errors\n \n-warning: any use of this value will cause an error\n-  --> $DIR/const_refers_to_static.rs:17:5\n-   |\n-LL | / const MUTATE_INTERIOR_MUT: usize = {\n-LL | |     static FOO: AtomicUsize = AtomicUsize::new(0);\n-LL | |     FOO.fetch_add(1, Ordering::Relaxed)\n-   | |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ calling non-const function `std::sync::atomic::AtomicUsize::fetch_add`\n-LL | |\n-LL | |\n-LL | | };\n-   | |__-\n-   |\n-note: the lint level is defined here\n-  --> $DIR/const_refers_to_static.rs:2:9\n-   |\n-LL | #![warn(const_err)]\n-   |         ^^^^^^^^^\n-\n-warning: any use of this value will cause an error\n-  --> $DIR/const_refers_to_static.rs:24:14\n-   |\n-LL | / const READ_INTERIOR_MUT: usize = {\n-LL | |     static FOO: AtomicUsize = AtomicUsize::new(0);\n-LL | |     unsafe { *(&FOO as *const _ as *const usize) }\n-   | |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constant accesses static\n-LL | |\n-LL | | };\n-   | |__-\n-\n-warning: any use of this value will cause an error\n-  --> $DIR/const_refers_to_static.rs:29:32\n-   |\n-LL | const READ_MUT: u32 = unsafe { MUTABLE };\n-   | -------------------------------^^^^^^^---\n-   |                                |\n-   |                                constant accesses static\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/const_refers_to_static.rs:34:1\n-   |\n-LL | / const READ_IMMUT: &usize = {\n-LL | |     static FOO: usize = 0;\n-LL | |     &FOO\n-LL | |\n-LL | | };\n-   | |__^ type validation failed: encountered a reference pointing to a static variable\n+error[E0080]: erroneous constant used\n+  --> $DIR/const_refers_to_static.rs:35:5\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+LL |     READ_MUT;\n+   |     ^^^^^^^^ referenced constant has errors\n \n-error: aborting due to 2 previous errors; 10 warnings emitted\n+error: aborting due to 3 previous errors; 5 warnings emitted\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "2704f2a7d73c1d1e6b5d6df90f9350941c5036a3", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static2.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -0,0 +1,24 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+#![allow(const_err)]\n+\n+#![feature(const_raw_ptr_deref)]\n+\n+use std::sync::atomic::AtomicUsize;\n+use std::sync::atomic::Ordering;\n+\n+// These tests cause immediate error when *defining* the const.\n+\n+const REF_INTERIOR_MUT: &usize = { //~ ERROR undefined behavior to use this value\n+    static FOO: AtomicUsize = AtomicUsize::new(0);\n+    unsafe { &*(&FOO as *const _ as *const usize) }\n+    //~^ WARN skipping const checks\n+};\n+\n+// ok some day perhaps\n+const READ_IMMUT: &usize = { //~ ERROR it is undefined behavior to use this value\n+    static FOO: usize = 0;\n+    &FOO\n+    //~^ WARN skipping const checks\n+};\n+\n+fn main() {}"}, {"sha": "2a233d63efef8348d491425c3ca04d34ca8ea496", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static2.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -0,0 +1,39 @@\n+warning: skipping const checks\n+  --> $DIR/const_refers_to_static2.rs:13:18\n+   |\n+LL |     unsafe { &*(&FOO as *const _ as *const usize) }\n+   |                  ^^^\n+\n+warning: skipping const checks\n+  --> $DIR/const_refers_to_static2.rs:20:6\n+   |\n+LL |     &FOO\n+   |      ^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/const_refers_to_static2.rs:11:1\n+   |\n+LL | / const REF_INTERIOR_MUT: &usize = {\n+LL | |     static FOO: AtomicUsize = AtomicUsize::new(0);\n+LL | |     unsafe { &*(&FOO as *const _ as *const usize) }\n+LL | |\n+LL | | };\n+   | |__^ type validation failed: encountered a reference pointing to a static variable\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/const_refers_to_static2.rs:18:1\n+   |\n+LL | / const READ_IMMUT: &usize = {\n+LL | |     static FOO: usize = 0;\n+LL | |     &FOO\n+LL | |\n+LL | | };\n+   | |__^ type validation failed: encountered a reference pointing to a static variable\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error: aborting due to 2 previous errors; 2 warnings emitted\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "3b9208dd12609c014e30e28855e07af4768521e9", "filename": "src/test/ui/consts/miri_unleashed/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fdrop.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -1,6 +1,6 @@\n // compile-flags: -Zunleash-the-miri-inside-of-you\n // error-pattern: calling non-const function `<std::vec::Vec<i32> as std::ops::Drop>::drop`\n-#![deny(const_err)]\n+#![allow(const_err)]\n \n use std::mem::ManuallyDrop;\n "}, {"sha": "5cc8808be5dc13ccbed087c648afedd5ad7b10de", "filename": "src/test/ui/consts/miri_unleashed/mutable_const.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -1,19 +1,27 @@\n // compile-flags: -Zunleash-the-miri-inside-of-you\n+// normalize-stderr-test \"alloc[0-9]+\" -> \"allocN\"\n \n #![feature(const_raw_ptr_deref)]\n #![feature(const_mut_refs)]\n-#![deny(const_err)]\n+#![deny(const_err)] // The `allow` variant is tested by `mutable_const2`.\n+//~^ NOTE lint level\n+// Here we check that even though `MUTABLE_BEHIND_RAW` is created from a mutable\n+// allocation, we intern that allocation as *immutable* and reject writes to it.\n+// We avoid the `delay_span_bug` ICE by having compilation fail via the `deny` above.\n \n use std::cell::UnsafeCell;\n \n // make sure we do not just intern this as mutable\n const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n //~^ WARN: skipping const checks\n \n-const MUTATING_BEHIND_RAW: () = {\n+const MUTATING_BEHIND_RAW: () = { //~ NOTE\n     // Test that `MUTABLE_BEHIND_RAW` is actually immutable, by doing this at const time.\n     unsafe {\n         *MUTABLE_BEHIND_RAW = 99 //~ ERROR any use of this value will cause an error\n+        //~^ NOTE: which is read-only\n+        // FIXME would be good to match more of the error message here, but looks like we\n+        // normalize *after* checking the annoations here.\n     }\n };\n "}, {"sha": "34993247fca80c2aec65fdbf36a595a0528dc531", "filename": "src/test/ui/consts/miri_unleashed/mutable_const.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -1,25 +1,26 @@\n warning: skipping const checks\n-  --> $DIR/mutable_const.rs:10:38\n+  --> $DIR/mutable_const.rs:15:38\n    |\n LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n    |                                      ^^^^^^^^^^^^^^^^^^^^\n \n error: any use of this value will cause an error\n-  --> $DIR/mutable_const.rs:16:9\n+  --> $DIR/mutable_const.rs:21:9\n    |\n LL | / const MUTATING_BEHIND_RAW: () = {\n LL | |     // Test that `MUTABLE_BEHIND_RAW` is actually immutable, by doing this at const time.\n LL | |     unsafe {\n LL | |         *MUTABLE_BEHIND_RAW = 99\n-   | |         ^^^^^^^^^^^^^^^^^^^^^^^^ writing to alloc2 which is read-only\n+   | |         ^^^^^^^^^^^^^^^^^^^^^^^^ writing to allocN which is read-only\n+...  |\n LL | |     }\n LL | | };\n    | |__-\n    |\n note: the lint level is defined here\n-  --> $DIR/mutable_const.rs:5:9\n+  --> $DIR/mutable_const.rs:6:9\n    |\n-LL | #![deny(const_err)]\n+LL | #![deny(const_err)] // The `allow` variant is tested by `mutable_const2`.\n    |         ^^^^^^^^^\n \n error: aborting due to previous error; 1 warning emitted"}, {"sha": "c2c7fb18e2a630ffb92f199b974e45a59a3b2ec0", "filename": "src/test/ui/consts/miri_unleashed/mutable_const2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -3,11 +3,11 @@\n // rustc-env:RUST_BACKTRACE=0\n // normalize-stderr-test \"note: rustc 1.* running on .*\" -> \"note: rustc VERSION running on TARGET\"\n // normalize-stderr-test \"note: compiler flags: .*\" -> \"note: compiler flags: FLAGS\"\n-// normalize-stderr-test \"interpret/intern.rs:[0-9]*:[0-9]*\" -> \"interpret/intern.rs:LL:CC\"\n+// normalize-stderr-test \"interpret/intern.rs:[0-9]+:[0-9]+\" -> \"interpret/intern.rs:LL:CC\"\n \n #![feature(const_raw_ptr_deref)]\n #![feature(const_mut_refs)]\n-#![deny(const_err)]\n+#![allow(const_err)]\n \n use std::cell::UnsafeCell;\n "}, {"sha": "9d8d5f513c76babf6a95c579f53be6b32e1d39b6", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_ice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -3,7 +3,7 @@\n // rustc-env:RUST_BACKTRACE=0\n // normalize-stderr-test \"note: rustc 1.* running on .*\" -> \"note: rustc VERSION running on TARGET\"\n // normalize-stderr-test \"note: compiler flags: .*\" -> \"note: compiler flags: FLAGS\"\n-// normalize-stderr-test \"interpret/intern.rs:[0-9]*:[0-9]*\" -> \"interpret/intern.rs:LL:CC\"\n+// normalize-stderr-test \"interpret/intern.rs:[0-9]+:[0-9]+\" -> \"interpret/intern.rs:LL:CC\"\n \n #![allow(const_err)]\n "}, {"sha": "902fe0aa1e7e4e724e422da393610e22b915c1e6", "filename": "src/test/ui/consts/miri_unleashed/mutating_global.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutating_global.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutating_global.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutating_global.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -1,14 +1,15 @@\n // compile-flags: -Zunleash-the-miri-inside-of-you\n+#![allow(const_err)]\n \n // Make sure we cannot mutate globals.\n \n static mut GLOBAL: i32 = 0;\n \n-const MUTATING_GLOBAL: () = {\n+static MUTATING_GLOBAL: () = {\n     unsafe {\n-        GLOBAL = 99 //~ ERROR any use of this value will cause an error\n-        //~^ WARN skipping const checks\n-        //~| WARN skipping const checks\n+        GLOBAL = 99\n+        //~^ ERROR could not evaluate static initializer\n+        //~| NOTE modifying a static's initial value\n     }\n };\n "}, {"sha": "ba9dd56190ac12d07035b6e12a9a5a6dfc738ffe", "filename": "src/test/ui/consts/miri_unleashed/mutating_global.stderr", "status": "modified", "additions": 5, "deletions": 25, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutating_global.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutating_global.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutating_global.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -1,29 +1,9 @@\n-warning: skipping const checks\n-  --> $DIR/mutating_global.rs:9:9\n+error[E0080]: could not evaluate static initializer\n+  --> $DIR/mutating_global.rs:10:9\n    |\n LL |         GLOBAL = 99\n-   |         ^^^^^^\n+   |         ^^^^^^^^^^^ modifying a static's initial value from another static's initializer\n \n-warning: skipping const checks\n-  --> $DIR/mutating_global.rs:9:9\n-   |\n-LL |         GLOBAL = 99\n-   |         ^^^^^^\n-\n-error: any use of this value will cause an error\n-  --> $DIR/mutating_global.rs:9:9\n-   |\n-LL | / const MUTATING_GLOBAL: () = {\n-LL | |     unsafe {\n-LL | |         GLOBAL = 99\n-   | |         ^^^^^^^^^^^ modifying a static's initial value from another static's initializer\n-LL | |\n-LL | |\n-LL | |     }\n-LL | | };\n-   | |__-\n-   |\n-   = note: `#[deny(const_err)]` on by default\n-\n-error: aborting due to previous error; 2 warnings emitted\n+error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "b401884139d9f4e400efd8ec09e933708de0bc91", "filename": "src/test/ui/consts/miri_unleashed/non_const_fn.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fnon_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fnon_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fnon_const_fn.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -1,17 +1,13 @@\n-// build-fail\n // compile-flags: -Zunleash-the-miri-inside-of-you\n \n-#![warn(const_err)]\n+#![allow(const_err)]\n \n // A test demonstrating that we prevent calling non-const fn during CTFE.\n \n fn foo() {}\n \n-const C: () = foo(); //~ WARN: skipping const checks\n-//~^ WARN any use of this value will cause an error\n+static C: () = foo(); //~ WARN: skipping const checks\n+//~^ ERROR could not evaluate static initializer\n+//~| NOTE calling non-const function `foo`\n \n-fn main() {\n-    println!(\"{:?}\", C);\n-    //~^ ERROR: evaluation of constant expression failed\n-    //~| WARN: erroneous constant used [const_err]\n-}\n+fn main() {}"}, {"sha": "d20cd6d6f0b9e557533eb2e16d944b28958c2cef", "filename": "src/test/ui/consts/miri_unleashed/non_const_fn.stderr", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fnon_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fnon_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fnon_const_fn.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -1,35 +1,15 @@\n warning: skipping const checks\n-  --> $DIR/non_const_fn.rs:10:15\n+  --> $DIR/non_const_fn.rs:9:16\n    |\n-LL | const C: () = foo();\n-   |               ^^^^^\n+LL | static C: () = foo();\n+   |                ^^^^^\n \n-warning: any use of this value will cause an error\n-  --> $DIR/non_const_fn.rs:10:15\n+error[E0080]: could not evaluate static initializer\n+  --> $DIR/non_const_fn.rs:9:16\n    |\n-LL | const C: () = foo();\n-   | --------------^^^^^-\n-   |               |\n-   |               calling non-const function `foo`\n-   |\n-note: the lint level is defined here\n-  --> $DIR/non_const_fn.rs:4:9\n-   |\n-LL | #![warn(const_err)]\n-   |         ^^^^^^^^^\n-\n-error[E0080]: evaluation of constant expression failed\n-  --> $DIR/non_const_fn.rs:14:22\n-   |\n-LL |     println!(\"{:?}\", C);\n-   |                      ^ referenced constant has errors\n-\n-warning: erroneous constant used\n-  --> $DIR/non_const_fn.rs:14:22\n-   |\n-LL |     println!(\"{:?}\", C);\n-   |                      ^ referenced constant has errors\n+LL | static C: () = foo();\n+   |                ^^^^^ calling non-const function `foo`\n \n-error: aborting due to previous error; 3 warnings emitted\n+error: aborting due to previous error; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "feecb6d80e771ee8f88446d934a7c96f7a22fcd4", "filename": "src/test/ui/foreign-fn-return-lifetime.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fforeign-fn-return-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fforeign-fn-return-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fforeign-fn-return-lifetime.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -2,9 +2,13 @@ error[E0106]: missing lifetime specifier\n   --> $DIR/foreign-fn-return-lifetime.rs:5:19\n    |\n LL |     pub fn f() -> &u8;\n-   |                   ^ help: consider giving it a 'static lifetime: `&'static`\n+   |                   ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     pub fn f() -> &'static u8;\n+   |                   ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "1106a067822809242f77551d939a532a6643b37f", "filename": "src/test/ui/generics/issue-65285-incorrect-explicit-lifetime-name-needed.stderr", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -5,16 +5,33 @@ LL | fn should_error<T>() where T : Into<&u32> {}\n    |                                     ^ explicit lifetime name needed here\n \n error[E0106]: missing lifetime specifier\n-  --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:9:19\n+  --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:9:21\n    |\n LL |     fn foo<'b, L: X<&'b Nested<K>>>();\n-   |                   ^^^^^^^^^^^^^^^^ expected lifetime parameter\n+   |                     ^ expected named lifetime parameter\n+   |\n+note: these named lifetimes are available to use\n+  --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:8:9\n+   |\n+LL | trait X<'a, K: 'a> {\n+   |         ^^\n+LL |     fn foo<'b, L: X<&'b Nested<K>>>();\n+   |            ^^\n+help: consider using one of the available lifetimes here\n+   |\n+LL |     fn foo<'b, L: X<'lifetime, &'b Nested<K>>>();\n+   |                     ^^^^^^^^^^\n \n error[E0106]: missing lifetime specifier\n-  --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:13:15\n+  --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:13:17\n    |\n LL | fn bar<'b, L: X<&'b Nested<i32>>>(){}\n-   |               ^^^^^^^^^^^^^^^^^^ expected lifetime parameter\n+   |                 ^ expected named lifetime parameter\n+   |\n+help: consider using the `'b` lifetime\n+   |\n+LL | fn bar<'b, L: X<'b, &'b Nested<i32>>>(){}\n+   |                 ^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "a231f73d06729bc5dc9d22dfc238c62d08e4d4a3", "filename": "src/test/ui/issues/issue-13497.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fissues%2Fissue-13497.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fissues%2Fissue-13497.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13497.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -2,9 +2,13 @@ error[E0106]: missing lifetime specifier\n   --> $DIR/issue-13497.rs:2:5\n    |\n LL |     &str\n-   |     ^ help: consider giving it a 'static lifetime: `&'static`\n+   |     ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     &'static str\n+   |     ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "3df58d66d1f8e34a94edd61b741c60260dd99c68", "filename": "src/test/ui/issues/issue-26638.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fissues%2Fissue-26638.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fissues%2Fissue-26638.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26638.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -14,17 +14,25 @@ error[E0106]: missing lifetime specifier\n   --> $DIR/issue-26638.rs:4:40\n    |\n LL | fn parse_type_2(iter: fn(&u8)->&u8) -> &str { iter() }\n-   |                                        ^ help: consider giving it an explicit bounded or 'static lifetime: `&'static`\n+   |                                        ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn parse_type_2(iter: fn(&u8)->&u8) -> &'static str { iter() }\n+   |                                        ^^^^^^^^\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/issue-26638.rs:7:22\n    |\n LL | fn parse_type_3() -> &str { unimplemented!() }\n-   |                      ^ help: consider giving it a 'static lifetime: `&'static`\n+   |                      ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn parse_type_3() -> &'static str { unimplemented!() }\n+   |                      ^^^^^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "5809b5bd661e0e7c195bc971973459f90d630c7b", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-requires-explicit-lifetime.stderr", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-requires-explicit-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-requires-explicit-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-requires-explicit-lifetime.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -2,9 +2,13 @@ error[E0106]: missing lifetime specifier\n   --> $DIR/lifetime-elision-return-type-requires-explicit-lifetime.rs:2:11\n    |\n LL | fn f() -> &isize {\n-   |           ^ help: consider giving it a 'static lifetime: `&'static`\n+   |           ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f() -> &'static isize {\n+   |           ^^^^^^^^\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/lifetime-elision-return-type-requires-explicit-lifetime.rs:7:33\n@@ -34,25 +38,37 @@ error[E0106]: missing lifetime specifier\n   --> $DIR/lifetime-elision-return-type-requires-explicit-lifetime.rs:21:20\n    |\n LL | fn i(_x: isize) -> &isize {\n-   |                    ^ help: consider giving it an explicit bounded or 'static lifetime: `&'static`\n+   |                    ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn i(_x: isize) -> &'static isize {\n+   |                    ^^^^^^^^\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/lifetime-elision-return-type-requires-explicit-lifetime.rs:34:24\n    |\n LL | fn j(_x: StaticStr) -> &isize {\n-   |                        ^ help: consider giving it an explicit bounded or 'static lifetime: `&'static`\n+   |                        ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn j(_x: StaticStr) -> &'static isize {\n+   |                        ^^^^^^^^\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/lifetime-elision-return-type-requires-explicit-lifetime.rs:40:49\n    |\n LL | fn k<'a, T: WithLifetime<'a>>(_x: T::Output) -> &isize {\n-   |                                                 ^ help: consider giving it an explicit bounded or 'static lifetime: `&'static`\n+   |                                                 ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+help: consider using the `'a` lifetime\n+   |\n+LL | fn k<'a, T: WithLifetime<'a>>(_x: T::Output) -> &'a isize {\n+   |                                                 ^^^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "254eaf51a646b8e7a396a9354f11b0d0edb1ea86", "filename": "src/test/ui/specialization/defaultimpl/validation.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fvalidation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fvalidation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fvalidation.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -25,13 +25,13 @@ LL | default impl !Send for Z {}\n    | default because of this\n \n error[E0750]: negative impls cannot be default impls\n-  --> $DIR/validation.rs:10:14\n+  --> $DIR/validation.rs:10:1\n    |\n LL | default impl !Send for Z {}\n    | ^^^^^^^      ^\n \n error[E0750]: negative impls cannot be default impls\n-  --> $DIR/validation.rs:14:14\n+  --> $DIR/validation.rs:14:1\n    |\n LL | default impl !Tr for S {}\n    | ^^^^^^^      ^"}, {"sha": "b09c1879d701599092a3fa1e5e1d96817a317f85", "filename": "src/test/ui/suggestions/missing-lifetime-specifier.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -0,0 +1,65 @@\n+#![allow(bare_trait_objects)]\n+use std::collections::HashMap;\n+use std::cell::RefCell;\n+\n+pub union Foo<'t, 'k> {\n+    i: &'t i64,\n+    f: &'k f64,\n+}\n+trait Bar<'t, 'k> {}\n+\n+pub union Qux<'t, 'k, I> {\n+    i: &'t I,\n+    f: &'k I,\n+}\n+trait Tar<'t, 'k, I> {}\n+\n+thread_local! {\n+    static a: RefCell<HashMap<i32, Vec<Vec<Foo>>>> = RefCell::new(HashMap::new());\n+    //~^ ERROR missing lifetime specifier\n+    //~| ERROR missing lifetime specifier\n+}\n+thread_local! {\n+    static b: RefCell<HashMap<i32, Vec<Vec<&Bar>>>> = RefCell::new(HashMap::new());\n+    //~^ ERROR missing lifetime specifier\n+    //~| ERROR missing lifetime specifier\n+    //~| ERROR missing lifetime specifier\n+    //~| ERROR missing lifetime specifier\n+    //~| ERROR the lifetime bound for this object type cannot be deduced from context\n+    //~| ERROR the lifetime bound for this object type cannot be deduced from context\n+}\n+thread_local! {\n+    static c: RefCell<HashMap<i32, Vec<Vec<Qux<i32>>>>> = RefCell::new(HashMap::new());\n+    //~^ ERROR missing lifetime specifier\n+    //~| ERROR missing lifetime specifier\n+}\n+thread_local! {\n+    static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n+    //~^ ERROR missing lifetime specifier\n+    //~| ERROR missing lifetime specifier\n+    //~| ERROR missing lifetime specifier\n+    //~| ERROR missing lifetime specifier\n+    //~| ERROR the lifetime bound for this object type cannot be deduced from context\n+    //~| ERROR the lifetime bound for this object type cannot be deduced from context\n+}\n+\n+thread_local! {\n+    static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, i32>>>>> = RefCell::new(HashMap::new());\n+    //~^ ERROR wrong number of lifetime arguments: expected 2, found 1\n+    //~| ERROR wrong number of lifetime arguments: expected 2, found 1\n+    //~| ERROR wrong number of lifetime arguments: expected 2, found 1\n+    //~| ERROR wrong number of lifetime arguments: expected 2, found 1\n+}\n+thread_local! {\n+    static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+    //~^ ERROR the lifetime bound for this object type cannot be deduced from context\n+    //~| ERROR the lifetime bound for this object type cannot be deduced from context\n+    //~| ERROR wrong number of lifetime arguments: expected 2, found 1\n+    //~| ERROR wrong number of lifetime arguments: expected 2, found 1\n+    //~| ERROR wrong number of lifetime arguments: expected 2, found 1\n+    //~| ERROR wrong number of lifetime arguments: expected 2, found 1\n+    //~| ERROR missing lifetime specifier\n+    //~| ERROR missing lifetime specifier\n+}\n+\n+fn main() {}"}, {"sha": "f5ff54cc916cb364748c68c77919e3dd39d5bfa0", "filename": "src/test/ui/suggestions/missing-lifetime-specifier.stderr", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -0,0 +1,256 @@\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/missing-lifetime-specifier.rs:18:44\n+   |\n+LL |     static a: RefCell<HashMap<i32, Vec<Vec<Foo>>>> = RefCell::new(HashMap::new());\n+   |                                            ^^^ expected 2 lifetime parameters\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     static a: RefCell<HashMap<i32, Vec<Vec<Foo<'static, 'static>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/missing-lifetime-specifier.rs:18:44\n+   |\n+LL |     static a: RefCell<HashMap<i32, Vec<Vec<Foo>>>> = RefCell::new(HashMap::new());\n+   |                                            ^^^ expected 2 lifetime parameters\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     static a: RefCell<HashMap<i32, Vec<Vec<Foo<'static, 'static>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lifetime-specifier.rs:23:44\n+   |\n+LL |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar>>>> = RefCell::new(HashMap::new());\n+   |                                            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     static b: RefCell<HashMap<i32, Vec<Vec<&'static Bar>>>> = RefCell::new(HashMap::new());\n+   |                                            ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/missing-lifetime-specifier.rs:23:45\n+   |\n+LL |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar>>>> = RefCell::new(HashMap::new());\n+   |                                             ^^^ expected 2 lifetime parameters\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar<'static, 'static>>>>> = RefCell::new(HashMap::new());\n+   |                                             ^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lifetime-specifier.rs:23:44\n+   |\n+LL |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar>>>> = RefCell::new(HashMap::new());\n+   |                                            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     static b: RefCell<HashMap<i32, Vec<Vec<&'static Bar>>>> = RefCell::new(HashMap::new());\n+   |                                            ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/missing-lifetime-specifier.rs:23:45\n+   |\n+LL |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar>>>> = RefCell::new(HashMap::new());\n+   |                                             ^^^ expected 2 lifetime parameters\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar<'static, 'static>>>>> = RefCell::new(HashMap::new());\n+   |                                             ^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/missing-lifetime-specifier.rs:32:48\n+   |\n+LL |     static c: RefCell<HashMap<i32, Vec<Vec<Qux<i32>>>>> = RefCell::new(HashMap::new());\n+   |                                                ^ expected 2 lifetime parameters\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     static c: RefCell<HashMap<i32, Vec<Vec<Qux<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                                ^^^^^^^^^^^^^^^^^\n+\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/missing-lifetime-specifier.rs:32:48\n+   |\n+LL |     static c: RefCell<HashMap<i32, Vec<Vec<Qux<i32>>>>> = RefCell::new(HashMap::new());\n+   |                                                ^ expected 2 lifetime parameters\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     static c: RefCell<HashMap<i32, Vec<Vec<Qux<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                                ^^^^^^^^^^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lifetime-specifier.rs:37:44\n+   |\n+LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     static d: RefCell<HashMap<i32, Vec<Vec<&'static Tar<i32>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/missing-lifetime-specifier.rs:37:49\n+   |\n+LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n+   |                                                 ^ expected 2 lifetime parameters\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                                 ^^^^^^^^^^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lifetime-specifier.rs:37:44\n+   |\n+LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     static d: RefCell<HashMap<i32, Vec<Vec<&'static Tar<i32>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/missing-lifetime-specifier.rs:37:49\n+   |\n+LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n+   |                                                 ^ expected 2 lifetime parameters\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                                 ^^^^^^^^^^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lifetime-specifier.rs:54:44\n+   |\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&'static Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lifetime-specifier.rs:54:44\n+   |\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&'static Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^^^^^^^^\n+\n+error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n+  --> $DIR/missing-lifetime-specifier.rs:23:45\n+   |\n+LL |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar>>>> = RefCell::new(HashMap::new());\n+   |                                             ^^^\n+\n+error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n+  --> $DIR/missing-lifetime-specifier.rs:23:45\n+   |\n+LL |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar>>>> = RefCell::new(HashMap::new());\n+   |                                             ^^^\n+\n+error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n+  --> $DIR/missing-lifetime-specifier.rs:37:45\n+   |\n+LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n+   |                                             ^^^^^^^^\n+\n+error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n+  --> $DIR/missing-lifetime-specifier.rs:37:45\n+   |\n+LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n+   |                                             ^^^^^^^^\n+\n+error[E0107]: wrong number of lifetime arguments: expected 2, found 1\n+  --> $DIR/missing-lifetime-specifier.rs:47:44\n+   |\n+LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^^^^^^^^^^^^^^^^^ expected 2 lifetime arguments\n+\n+error[E0107]: wrong number of lifetime arguments: expected 2, found 1\n+  --> $DIR/missing-lifetime-specifier.rs:47:44\n+   |\n+LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^^^^^^^^^^^^^^^^^ expected 2 lifetime arguments\n+\n+error[E0107]: wrong number of lifetime arguments: expected 2, found 1\n+  --> $DIR/missing-lifetime-specifier.rs:47:44\n+   |\n+LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^^^^^^^^^^^^^^^^^ expected 2 lifetime arguments\n+\n+error[E0107]: wrong number of lifetime arguments: expected 2, found 1\n+  --> $DIR/missing-lifetime-specifier.rs:47:44\n+   |\n+LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^^^^^^^^^^^^^^^^^ expected 2 lifetime arguments\n+\n+error[E0107]: wrong number of lifetime arguments: expected 2, found 1\n+  --> $DIR/missing-lifetime-specifier.rs:54:45\n+   |\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                             ^^^^^^^^^^^^^^^^^ expected 2 lifetime arguments\n+\n+error[E0107]: wrong number of lifetime arguments: expected 2, found 1\n+  --> $DIR/missing-lifetime-specifier.rs:54:45\n+   |\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                             ^^^^^^^^^^^^^^^^^ expected 2 lifetime arguments\n+\n+error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n+  --> $DIR/missing-lifetime-specifier.rs:54:45\n+   |\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                             ^^^^^^^^^^^^^^^^^\n+\n+error[E0107]: wrong number of lifetime arguments: expected 2, found 1\n+  --> $DIR/missing-lifetime-specifier.rs:54:45\n+   |\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                             ^^^^^^^^^^^^^^^^^ expected 2 lifetime arguments\n+\n+error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n+  --> $DIR/missing-lifetime-specifier.rs:54:45\n+   |\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                             ^^^^^^^^^^^^^^^^^\n+\n+error[E0107]: wrong number of lifetime arguments: expected 2, found 1\n+  --> $DIR/missing-lifetime-specifier.rs:54:45\n+   |\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                             ^^^^^^^^^^^^^^^^^ expected 2 lifetime arguments\n+\n+error: aborting due to 28 previous errors\n+\n+Some errors have detailed explanations: E0106, E0107.\n+For more information about an error, try `rustc --explain E0106`."}, {"sha": "2a237d61f50fe4d56fe6043468a62cdd9e52c5bd", "filename": "src/test/ui/suggestions/return-without-lifetime.stderr", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fsuggestions%2Freturn-without-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Fsuggestions%2Freturn-without-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-without-lifetime.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -2,23 +2,36 @@ error[E0106]: missing lifetime specifier\n   --> $DIR/return-without-lifetime.rs:2:16\n    |\n LL | struct Foo<'a>(&usize);\n-   |                ^ help: consider using the named lifetime: `&'a`\n+   |                ^ expected named lifetime parameter\n+   |\n+help: consider using the `'a` lifetime\n+   |\n+LL | struct Foo<'a>(&'a usize);\n+   |                ^^^\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/return-without-lifetime.rs:5:34\n    |\n LL | fn func1<'a>(_arg: &'a Thing) -> &() { unimplemented!() }\n-   |                    ---------     ^ help: consider using the named lifetime: `&'a`\n+   |                    ---------     ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but the signature does not say which one of `_arg`'s 2 lifetimes it is borrowed from\n+help: consider using the `'a` lifetime\n+   |\n+LL | fn func1<'a>(_arg: &'a Thing) -> &'a () { unimplemented!() }\n+   |                                  ^^^\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/return-without-lifetime.rs:7:35\n    |\n LL | fn func2<'a>(_arg: &Thing<'a>) -> &() { unimplemented!() }\n-   |                    ----------     ^ help: consider using the named lifetime: `&'a`\n+   |                    ----------     ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but the signature does not say which one of `_arg`'s 2 lifetimes it is borrowed from\n+help: consider using the `'a` lifetime\n+   |\n+LL | fn func2<'a>(_arg: &Thing<'a>) -> &'a () { unimplemented!() }\n+   |                                   ^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "a70bbe6b948d1ce1ac5079523e7fff352e619fb1", "filename": "src/test/ui/traits/negative-impls/negative-default-impls.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Fnegative-default-impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Fnegative-default-impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Fnegative-default-impls.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -1,5 +1,5 @@\n error[E0750]: negative impls cannot be default impls\n-  --> $DIR/negative-default-impls.rs:8:14\n+  --> $DIR/negative-default-impls.rs:8:1\n    |\n LL | default impl !MyTrait for u32 {}\n    | ^^^^^^^      ^"}, {"sha": "b824d160d716006d2a969d4b40072f2f567a5e3f", "filename": "src/test/ui/unboxed-closures/unboxed-closure-feature-gate.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-feature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-feature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-feature-gate.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -2,7 +2,7 @@ error[E0658]: parenthetical notation is only stable when used with `Fn`-family t\n   --> $DIR/unboxed-closure-feature-gate.rs:13:20\n    |\n LL |     let x: Box<dyn Foo(isize)>;\n-   |                    ^^^\n+   |                    ^^^^^^^^^^\n    |\n    = note: see issue #29625 <https://github.com/rust-lang/rust/issues/29625> for more information\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable"}, {"sha": "9da36906d55420cd9175e234a0652ecba91761ae", "filename": "src/test/ui/unboxed-closures/unboxed-closure-sugar-not-used-on-fn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-not-used-on-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-not-used-on-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-not-used-on-fn.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -2,7 +2,7 @@ error[E0658]: the precise format of `Fn`-family traits' type parameters is subje\n   --> $DIR/unboxed-closure-sugar-not-used-on-fn.rs:3:17\n    |\n LL | fn bar1(x: &dyn Fn<(), Output=()>) {\n-   |                 ^^ help: use parenthetical notation instead: `Fn() -> ()`\n+   |                 ^^^^^^^^^^^^^^^^^ help: use parenthetical notation instead: `Fn() -> ()`\n    |\n    = note: see issue #29625 <https://github.com/rust-lang/rust/issues/29625> for more information\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n@@ -11,7 +11,7 @@ error[E0658]: the precise format of `Fn`-family traits' type parameters is subje\n   --> $DIR/unboxed-closure-sugar-not-used-on-fn.rs:7:28\n    |\n LL | fn bar2<T>(x: &T) where T: Fn<()> {\n-   |                            ^^ help: use parenthetical notation instead: `Fn() -> ()`\n+   |                            ^^^^^^ help: use parenthetical notation instead: `Fn() -> ()`\n    |\n    = note: see issue #29625 <https://github.com/rust-lang/rust/issues/29625> for more information\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable"}, {"sha": "e9d51983a7a483f077daec9897419acad1e03a15", "filename": "src/test/ui/unboxed-closures/unboxed-closure-sugar-region.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-region.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -2,7 +2,7 @@ error[E0107]: wrong number of lifetime arguments: expected 1, found 0\n   --> $DIR/unboxed-closure-sugar-region.rs:30:51\n    |\n LL | fn test2(x: &dyn Foo<(isize,),Output=()>, y: &dyn Foo(isize)) {\n-   |                                                   ^^^ expected 1 lifetime argument\n+   |                                                   ^^^^^^^^^^ expected 1 lifetime argument\n \n error: aborting due to previous error\n "}, {"sha": "f42ac38d370d57e2b73ca6e66ed65746f5e501fe", "filename": "src/test/ui/unboxed-closures/unboxed-closure-sugar-wrong-number-number-type-parameters-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -2,7 +2,7 @@ error[E0107]: wrong number of type arguments: expected 3, found 1\n   --> $DIR/unboxed-closure-sugar-wrong-number-number-type-parameters-3.rs:5:16\n    |\n LL | fn foo(_: &dyn Three())\n-   |                ^^^^^ expected 3 type arguments\n+   |                ^^^^^^^ expected 3 type arguments\n \n error[E0220]: associated type `Output` not found for `Three<(), [type error], [type error]>`\n   --> $DIR/unboxed-closure-sugar-wrong-number-number-type-parameters-3.rs:5:16"}, {"sha": "594cdd245b3ec9875d9e44c2f7e370974b8cc27e", "filename": "src/test/ui/underscore-lifetime/underscore-lifetime-binders.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -14,15 +14,24 @@ error[E0106]: missing lifetime specifier\n   --> $DIR/underscore-lifetime-binders.rs:2:17\n    |\n LL | struct Baz<'a>(&'_ &'a u8);\n-   |                 ^^ help: consider using the named lifetime: `'a`\n+   |                 ^^ expected named lifetime parameter\n+   |\n+help: consider using the `'a` lifetime\n+   |\n+LL | struct Baz<'a>(&'a &'a u8);\n+   |                 ^^\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/underscore-lifetime-binders.rs:10:33\n    |\n LL | fn meh() -> Box<dyn for<'_> Meh<'_>>\n-   |                                 ^^ help: consider giving it a 'static lifetime: `'static`\n+   |                                 ^^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn meh() -> Box<dyn for<'_> Meh<'static>>\n+   |                                 ^^^^^^^\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/underscore-lifetime-binders.rs:16:35"}, {"sha": "9310b3d7ede004bacaf0e4b47768c5fd07a90a82", "filename": "src/test/ui/unspecified-self-in-trait-ref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Funspecified-self-in-trait-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftest%2Fui%2Funspecified-self-in-trait-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funspecified-self-in-trait-ref.stderr?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -31,7 +31,7 @@ LL | | }\n    | |_- type parameter `A` must be specified for this\n ...\n LL |       let e = Bar::<usize>::lol();\n-   |               ^^^ missing reference to `A`\n+   |               ^^^^^^^^^^^^^^^^^ missing reference to `A`\n    |\n    = note: because of the default `Self` reference, type parameters must be specified on object types\n "}, {"sha": "3a8a5491255a0dce0d093c82747f4c6c6487362c", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -831,12 +831,28 @@ fn extract_gdb_version(full_version_line: &str) -> Option<u32> {\n     // GDB versions look like this: \"major.minor.patch?.yyyymmdd?\", with both\n     // of the ? sections being optional\n \n-    // We will parse up to 3 digits for minor and patch, ignoring the date\n-    // We limit major to 1 digit, otherwise, on openSUSE, we parse the openSUSE version\n+    // We will parse up to 3 digits for each component, ignoring the date\n+\n+    // We skip text in parentheses.  This avoids accidentally parsing\n+    // the openSUSE version, which looks like:\n+    //  GNU gdb (GDB; openSUSE Leap 15.0) 8.1\n+    // This particular form is documented in the GNU coding standards:\n+    // https://www.gnu.org/prep/standards/html_node/_002d_002dversion.html#g_t_002d_002dversion\n \n     // don't start parsing in the middle of a number\n     let mut prev_was_digit = false;\n+    let mut in_parens = false;\n     for (pos, c) in full_version_line.char_indices() {\n+        if in_parens {\n+            if c == ')' {\n+                in_parens = false;\n+            }\n+            continue;\n+        } else if c == '(' {\n+            in_parens = true;\n+            continue;\n+        }\n+\n         if prev_was_digit || !c.is_digit(10) {\n             prev_was_digit = c.is_digit(10);\n             continue;\n@@ -876,7 +892,7 @@ fn extract_gdb_version(full_version_line: &str) -> Option<u32> {\n             None => (line, None),\n         };\n \n-        if major.len() != 1 || minor.is_empty() {\n+        if minor.is_empty() {\n             continue;\n         }\n "}, {"sha": "31c151d29e916c75bc2607870bfa354ac5ecc0c3", "filename": "src/tools/compiletest/src/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftools%2Fcompiletest%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061256835886be38fcb2255d585ec4e1292b77d0/src%2Ftools%2Fcompiletest%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Ftests.rs?ref=061256835886be38fcb2255d585ec4e1292b77d0", "patch": "@@ -7,9 +7,9 @@ fn test_extract_gdb_version() {\n     )*}}}\n \n     test! {\n-        7000001: \"GNU gdb (GDB) CentOS (7.0.1-45.el5.centos)\",\n+        7000001: \"GNU gdb (GDB) CentOS 7.0.1-45.el5.centos\",\n \n-        7002000: \"GNU gdb (GDB) Red Hat Enterprise Linux (7.2-90.el6)\",\n+        7002000: \"GNU gdb (GDB) Red Hat Enterprise Linux 7.2-90.el6\",\n \n         7004000: \"GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04\",\n         7004001: \"GNU gdb (GDB) 7.4.1-debian\","}]}