{"sha": "64963d6cbaea86e0d2a58f507e57a76da7512e3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0OTYzZDZjYmFlYTg2ZTBkMmE1OGY1MDdlNTdhNzZkYTc1MTJlM2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-21T17:43:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-21T17:43:17Z"}, "message": "auto merge of #6611 : huonw/rust/syntax-ext-no-dup, r=jbclements\n\nFixes https://github.com/mozilla/rust/issues/6578 by merging the 3 different ways to build an AST into a single `AstBuilder` trait, creating a more uniform and briefer interface.\r\n\r\nAlso, converts the `ext_ctxt` trait-object to be a plain struct, as well as renaming it to `ExtCtxt`.\r\n\r\nSeems to make expansion slightly faster for the normal case (e.g. `libcore` and `libstd`), but slower for `librustc` (slightly) and `libsyntax` (0.3s -> 0.8s! I'm investigating this, but I'd prefer this patch to land relatively quickly.).\r\n\r\n`git blame` suggests maybe @graydon or @erickt are familiar with this area of the code. r?", "tree": {"sha": "96dfdb86aaa32e4131710cb71507ddd3b9aa752f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96dfdb86aaa32e4131710cb71507ddd3b9aa752f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64963d6cbaea86e0d2a58f507e57a76da7512e3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64963d6cbaea86e0d2a58f507e57a76da7512e3e", "html_url": "https://github.com/rust-lang/rust/commit/64963d6cbaea86e0d2a58f507e57a76da7512e3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64963d6cbaea86e0d2a58f507e57a76da7512e3e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "808aada1fb95133f9e9e78be70ad805c0fee4b9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/808aada1fb95133f9e9e78be70ad805c0fee4b9c", "html_url": "https://github.com/rust-lang/rust/commit/808aada1fb95133f9e9e78be70ad805c0fee4b9c"}, {"sha": "a59bec43e34715880f471db7d7c9d57939649d92", "url": "https://api.github.com/repos/rust-lang/rust/commits/a59bec43e34715880f471db7d7c9d57939649d92", "html_url": "https://github.com/rust-lang/rust/commit/a59bec43e34715880f471db7d7c9d57939649d92"}], "stats": {"total": 3917, "additions": 1667, "deletions": 2250}, "files": [{"sha": "a0ff8cb5e4d248c627bf94cd4e03ae723b1e1167", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -17,7 +17,7 @@ use syntax::ast_util::*;\n use syntax::attr;\n use syntax::codemap::{dummy_sp, span, ExpandedFrom, CallInfo, NameAndSpan};\n use syntax::codemap;\n-use syntax::ext::base::{mk_ctxt, ext_ctxt};\n+use syntax::ext::base::ExtCtxt;\n use syntax::fold;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n@@ -36,7 +36,7 @@ struct TestCtxt {\n     sess: session::Session,\n     crate: @ast::crate,\n     path: ~[ast::ident],\n-    ext_cx: @ext_ctxt,\n+    ext_cx: @ExtCtxt,\n     testfns: ~[Test]\n }\n \n@@ -64,7 +64,7 @@ fn generate_test_harness(sess: session::Session,\n     let cx: @mut TestCtxt = @mut TestCtxt {\n         sess: sess,\n         crate: crate,\n-        ext_cx: mk_ctxt(sess.parse_sess, copy sess.opts.cfg),\n+        ext_cx: ExtCtxt::new(sess.parse_sess, copy sess.opts.cfg),\n         path: ~[],\n         testfns: ~[]\n     };"}, {"sha": "f18396f95be42921b7144b3f46a9d718d523da01", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -19,7 +19,7 @@ use std::semver;\n use std::term;\n use syntax::ast_util::*;\n use syntax::codemap::{dummy_sp, spanned, dummy_spanned};\n-use syntax::ext::base::{mk_ctxt, ext_ctxt};\n+use syntax::ext::base::ExtCtxt;\n use syntax::{ast, attr, codemap, diagnostic, fold};\n use syntax::ast::{meta_name_value, meta_list};\n use syntax::attr::{mk_attr};\n@@ -178,7 +178,7 @@ struct ListenerFn {\n struct ReadyCtx {\n     sess: session::Session,\n     crate: @ast::crate,\n-    ext_cx: @ext_ctxt,\n+    ext_cx: @ExtCtxt,\n     path: ~[ast::ident],\n     fns: ~[ListenerFn]\n }\n@@ -247,7 +247,7 @@ pub fn ready_crate(sess: session::Session,\n     let ctx = @mut ReadyCtx {\n         sess: sess,\n         crate: crate,\n-        ext_cx: mk_ctxt(sess.parse_sess, copy sess.opts.cfg),\n+        ext_cx: ExtCtxt::new(sess.parse_sess, copy sess.opts.cfg),\n         path: ~[],\n         fns: ~[]\n     };"}, {"sha": "162eced11242b4da251e2fdf2528148884ace31f", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -37,7 +37,7 @@ fn next_state(s: State) -> Option<State> {\n     }\n }\n \n-pub fn expand_asm(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_asm(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n                -> base::MacResult {\n     let p = parse::new_parser_from_tts(cx.parse_sess(),\n                                        cx.cfg(),"}, {"sha": "64d2644b38310d3ddc95fda94cb8b26c3410eb3a", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -15,7 +15,7 @@ use codemap::span;\n use ext::base::*;\n \n pub fn expand_auto_encode(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     _mitem: @ast::meta_item,\n     in_items: ~[@ast::item]\n@@ -25,7 +25,7 @@ pub fn expand_auto_encode(\n }\n \n pub fn expand_auto_decode(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     _mitem: @ast::meta_item,\n     in_items: ~[@ast::item]"}, {"sha": "9b71fb9647ce107374a4a1adfe2a81644020b190", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 94, "deletions": 119, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -33,7 +33,7 @@ pub struct MacroDef {\n     ext: SyntaxExtension\n }\n \n-pub type ItemDecorator = @fn(@ext_ctxt,\n+pub type ItemDecorator = @fn(@ExtCtxt,\n                              span,\n                              @ast::meta_item,\n                              ~[@ast::item])\n@@ -44,7 +44,7 @@ pub struct SyntaxExpanderTT {\n     span: Option<span>\n }\n \n-pub type SyntaxExpanderTTFun = @fn(@ext_ctxt,\n+pub type SyntaxExpanderTTFun = @fn(@ExtCtxt,\n                                    span,\n                                    &[ast::token_tree])\n                                 -> MacResult;\n@@ -54,7 +54,7 @@ pub struct SyntaxExpanderTTItem {\n     span: Option<span>\n }\n \n-pub type SyntaxExpanderTTItemFun = @fn(@ext_ctxt,\n+pub type SyntaxExpanderTTItemFun = @fn(@ExtCtxt,\n                                        span,\n                                        ast::ident,\n                                        ~[ast::token_tree])\n@@ -202,134 +202,109 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n // One of these is made during expansion and incrementally updated as we go;\n // when a macro expansion occurs, the resulting nodes have the backtrace()\n // -> expn_info of their expansion context stored into their span.\n-pub trait ext_ctxt {\n-    fn codemap(&self) -> @CodeMap;\n-    fn parse_sess(&self) -> @mut parse::ParseSess;\n-    fn cfg(&self) -> ast::crate_cfg;\n-    fn call_site(&self) -> span;\n-    fn print_backtrace(&self);\n-    fn backtrace(&self) -> Option<@ExpnInfo>;\n-    fn mod_push(&self, mod_name: ast::ident);\n-    fn mod_pop(&self);\n-    fn mod_path(&self) -> ~[ast::ident];\n-    fn bt_push(&self, ei: codemap::ExpnInfo);\n-    fn bt_pop(&self);\n-    fn span_fatal(&self, sp: span, msg: &str) -> !;\n-    fn span_err(&self, sp: span, msg: &str);\n-    fn span_warn(&self, sp: span, msg: &str);\n-    fn span_unimpl(&self, sp: span, msg: &str) -> !;\n-    fn span_bug(&self, sp: span, msg: &str) -> !;\n-    fn bug(&self, msg: &str) -> !;\n-    fn next_id(&self) -> ast::node_id;\n-    fn trace_macros(&self) -> bool;\n-    fn set_trace_macros(&self, x: bool);\n-    /* for unhygienic identifier transformation */\n-    fn str_of(&self, id: ast::ident) -> ~str;\n-    fn ident_of(&self, st: &str) -> ast::ident;\n+pub struct ExtCtxt {\n+    parse_sess: @mut parse::ParseSess,\n+    cfg: ast::crate_cfg,\n+    backtrace: @mut Option<@ExpnInfo>,\n+\n+    // These two @mut's should really not be here,\n+    // but the self types for CtxtRepr are all wrong\n+    // and there are bugs in the code for object\n+    // types that make this hard to get right at the\n+    // moment. - nmatsakis\n+    mod_path: @mut ~[ast::ident],\n+    trace_mac: @mut bool\n }\n \n-pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n-            -> @ext_ctxt {\n-    struct CtxtRepr {\n-        parse_sess: @mut parse::ParseSess,\n-        cfg: ast::crate_cfg,\n-        backtrace: @mut Option<@ExpnInfo>,\n-\n-        // These two @mut's should really not be here,\n-        // but the self types for CtxtRepr are all wrong\n-        // and there are bugs in the code for object\n-        // types that make this hard to get right at the\n-        // moment. - nmatsakis\n-        mod_path: @mut ~[ast::ident],\n-        trace_mac: @mut bool\n-    }\n-    impl ext_ctxt for CtxtRepr {\n-        fn codemap(&self) -> @CodeMap { self.parse_sess.cm }\n-        fn parse_sess(&self) -> @mut parse::ParseSess { self.parse_sess }\n-        fn cfg(&self) -> ast::crate_cfg { copy self.cfg }\n-        fn call_site(&self) -> span {\n-            match *self.backtrace {\n-                Some(@ExpandedFrom(CallInfo {call_site: cs, _})) => cs,\n-                None => self.bug(\"missing top span\")\n-            }\n+pub impl ExtCtxt {\n+    fn new(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg) -> @ExtCtxt {\n+        @ExtCtxt {\n+            parse_sess: parse_sess,\n+            cfg: cfg,\n+            backtrace: @mut None,\n+            mod_path: @mut ~[],\n+            trace_mac: @mut false\n+        }\n+    }\n+\n+    fn codemap(&self) -> @CodeMap { self.parse_sess.cm }\n+    fn parse_sess(&self) -> @mut parse::ParseSess { self.parse_sess }\n+    fn cfg(&self) -> ast::crate_cfg { copy self.cfg }\n+    fn call_site(&self) -> span {\n+        match *self.backtrace {\n+            Some(@ExpandedFrom(CallInfo {call_site: cs, _})) => cs,\n+            None => self.bug(\"missing top span\")\n         }\n-        fn print_backtrace(&self) { }\n-        fn backtrace(&self) -> Option<@ExpnInfo> { *self.backtrace }\n-        fn mod_push(&self, i: ast::ident) { self.mod_path.push(i); }\n-        fn mod_pop(&self) { self.mod_path.pop(); }\n-        fn mod_path(&self) -> ~[ast::ident] { copy *self.mod_path }\n-        fn bt_push(&self, ei: codemap::ExpnInfo) {\n-            match ei {\n-              ExpandedFrom(CallInfo {call_site: cs, callee: ref callee}) => {\n+    }\n+    fn print_backtrace(&self) { }\n+    fn backtrace(&self) -> Option<@ExpnInfo> { *self.backtrace }\n+    fn mod_push(&self, i: ast::ident) { self.mod_path.push(i); }\n+    fn mod_pop(&self) { self.mod_path.pop(); }\n+    fn mod_path(&self) -> ~[ast::ident] { copy *self.mod_path }\n+    fn bt_push(&self, ei: codemap::ExpnInfo) {\n+        match ei {\n+            ExpandedFrom(CallInfo {call_site: cs, callee: ref callee}) => {\n                 *self.backtrace =\n                     Some(@ExpandedFrom(CallInfo {\n                         call_site: span {lo: cs.lo, hi: cs.hi,\n                                          expn_info: *self.backtrace},\n                         callee: copy *callee}));\n-              }\n             }\n         }\n-        fn bt_pop(&self) {\n-            match *self.backtrace {\n-              Some(@ExpandedFrom(CallInfo {\n-                  call_site: span {expn_info: prev, _}, _\n-              })) => {\n+    }\n+    fn bt_pop(&self) {\n+        match *self.backtrace {\n+            Some(@ExpandedFrom(\n+                CallInfo {\n+                    call_site: span {expn_info: prev, _}, _\n+                })) => {\n                 *self.backtrace = prev\n-              }\n-              _ => self.bug(\"tried to pop without a push\")\n             }\n+            _ => self.bug(\"tried to pop without a push\")\n         }\n-        fn span_fatal(&self, sp: span, msg: &str) -> ! {\n-            self.print_backtrace();\n-            self.parse_sess.span_diagnostic.span_fatal(sp, msg);\n-        }\n-        fn span_err(&self, sp: span, msg: &str) {\n-            self.print_backtrace();\n-            self.parse_sess.span_diagnostic.span_err(sp, msg);\n-        }\n-        fn span_warn(&self, sp: span, msg: &str) {\n-            self.print_backtrace();\n-            self.parse_sess.span_diagnostic.span_warn(sp, msg);\n-        }\n-        fn span_unimpl(&self, sp: span, msg: &str) -> ! {\n-            self.print_backtrace();\n-            self.parse_sess.span_diagnostic.span_unimpl(sp, msg);\n-        }\n-        fn span_bug(&self, sp: span, msg: &str) -> ! {\n-            self.print_backtrace();\n-            self.parse_sess.span_diagnostic.span_bug(sp, msg);\n-        }\n-        fn bug(&self, msg: &str) -> ! {\n-            self.print_backtrace();\n-            self.parse_sess.span_diagnostic.handler().bug(msg);\n-        }\n-        fn next_id(&self) -> ast::node_id {\n-            return parse::next_node_id(self.parse_sess);\n-        }\n-        fn trace_macros(&self) -> bool {\n-            *self.trace_mac\n-        }\n-        fn set_trace_macros(&self, x: bool) {\n-            *self.trace_mac = x\n-        }\n-        fn str_of(&self, id: ast::ident) -> ~str {\n-            copy *self.parse_sess.interner.get(id)\n-        }\n-        fn ident_of(&self, st: &str) -> ast::ident {\n-            self.parse_sess.interner.intern(st)\n-        }\n     }\n-    let imp: @CtxtRepr = @CtxtRepr {\n-        parse_sess: parse_sess,\n-        cfg: cfg,\n-        backtrace: @mut None,\n-        mod_path: @mut ~[],\n-        trace_mac: @mut false\n-    };\n-    ((imp) as @ext_ctxt)\n+    fn span_fatal(&self, sp: span, msg: &str) -> ! {\n+        self.print_backtrace();\n+        self.parse_sess.span_diagnostic.span_fatal(sp, msg);\n+    }\n+    fn span_err(&self, sp: span, msg: &str) {\n+        self.print_backtrace();\n+        self.parse_sess.span_diagnostic.span_err(sp, msg);\n+    }\n+    fn span_warn(&self, sp: span, msg: &str) {\n+        self.print_backtrace();\n+        self.parse_sess.span_diagnostic.span_warn(sp, msg);\n+    }\n+    fn span_unimpl(&self, sp: span, msg: &str) -> ! {\n+        self.print_backtrace();\n+        self.parse_sess.span_diagnostic.span_unimpl(sp, msg);\n+    }\n+    fn span_bug(&self, sp: span, msg: &str) -> ! {\n+        self.print_backtrace();\n+        self.parse_sess.span_diagnostic.span_bug(sp, msg);\n+    }\n+    fn bug(&self, msg: &str) -> ! {\n+        self.print_backtrace();\n+        self.parse_sess.span_diagnostic.handler().bug(msg);\n+    }\n+    fn next_id(&self) -> ast::node_id {\n+        parse::next_node_id(self.parse_sess)\n+    }\n+    fn trace_macros(&self) -> bool {\n+        *self.trace_mac\n+    }\n+    fn set_trace_macros(&self, x: bool) {\n+        *self.trace_mac = x\n+    }\n+    fn str_of(&self, id: ast::ident) -> ~str {\n+        copy *self.parse_sess.interner.get(id)\n+    }\n+    fn ident_of(&self, st: &str) -> ast::ident {\n+        self.parse_sess.interner.intern(st)\n+    }\n }\n \n-pub fn expr_to_str(cx: @ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {\n+pub fn expr_to_str(cx: @ExtCtxt, expr: @ast::expr, err_msg: ~str) -> ~str {\n     match expr.node {\n       ast::expr_lit(l) => match l.node {\n         ast::lit_str(s) => copy *s,\n@@ -339,7 +314,7 @@ pub fn expr_to_str(cx: @ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {\n     }\n }\n \n-pub fn expr_to_ident(cx: @ext_ctxt,\n+pub fn expr_to_ident(cx: @ExtCtxt,\n                      expr: @ast::expr,\n                      err_msg: &str) -> ast::ident {\n     match expr.node {\n@@ -353,14 +328,14 @@ pub fn expr_to_ident(cx: @ext_ctxt,\n     }\n }\n \n-pub fn check_zero_tts(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree],\n+pub fn check_zero_tts(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree],\n                       name: &str) {\n     if tts.len() != 0 {\n         cx.span_fatal(sp, fmt!(\"%s takes no arguments\", name));\n     }\n }\n \n-pub fn get_single_str_from_tts(cx: @ext_ctxt,\n+pub fn get_single_str_from_tts(cx: @ExtCtxt,\n                                sp: span,\n                                tts: &[ast::token_tree],\n                                name: &str) -> ~str {\n@@ -375,7 +350,7 @@ pub fn get_single_str_from_tts(cx: @ext_ctxt,\n     }\n }\n \n-pub fn get_exprs_from_tts(cx: @ext_ctxt, tts: &[ast::token_tree])\n+pub fn get_exprs_from_tts(cx: @ExtCtxt, tts: &[ast::token_tree])\n                        -> ~[@ast::expr] {\n     let p = parse::new_parser_from_tts(cx.parse_sess(),\n                                        cx.cfg(),"}, {"sha": "01a504101b914ce11c70f1464bf9bbafcd2aa95f", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 740, "deletions": 722, "changes": 1462, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -8,615 +8,405 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use abi::AbiSet;\n+use ast::ident;\n use ast;\n-use codemap;\n-use codemap::span;\n+use ast_util;\n+use codemap::{span, respan, dummy_sp};\n use fold;\n-use ext::base::ext_ctxt;\n-use ext::build;\n-\n+use ext::base::ExtCtxt;\n+use ext::quote::rt::*;\n+use opt_vec;\n use opt_vec::OptVec;\n \n pub struct Field {\n     ident: ast::ident,\n     ex: @ast::expr\n }\n \n-pub fn mk_expr(cx: @ext_ctxt,\n-               sp: codemap::span,\n-               expr: ast::expr_)\n-            -> @ast::expr {\n-    @ast::expr {\n-        id: cx.next_id(),\n-        callee_id: cx.next_id(),\n-        node: expr,\n-        span: sp,\n-    }\n+// Transitional reexports so qquote can find the paths it is looking for\n+mod syntax {\n+    pub use ext;\n+    pub use parse;\n }\n \n-pub fn mk_lit(cx: @ext_ctxt, sp: span, lit: ast::lit_) -> @ast::expr {\n-    let sp_lit = @codemap::spanned { node: lit, span: sp };\n-    mk_expr(cx, sp, ast::expr_lit(sp_lit))\n-}\n-pub fn mk_int(cx: @ext_ctxt, sp: span, i: int) -> @ast::expr {\n-    let lit = ast::lit_int(i as i64, ast::ty_i);\n-    return mk_lit(cx, sp, lit);\n-}\n-pub fn mk_uint(cx: @ext_ctxt, sp: span, u: uint) -> @ast::expr {\n-    let lit = ast::lit_uint(u as u64, ast::ty_u);\n-    return mk_lit(cx, sp, lit);\n-}\n-pub fn mk_u8(cx: @ext_ctxt, sp: span, u: u8) -> @ast::expr {\n-    let lit = ast::lit_uint(u as u64, ast::ty_u8);\n-    return mk_lit(cx, sp, lit);\n-}\n-pub fn mk_binary(cx: @ext_ctxt, sp: span, op: ast::binop,\n-                 lhs: @ast::expr, rhs: @ast::expr) -> @ast::expr {\n-    cx.next_id(); // see ast_util::op_expr_callee_id\n-    mk_expr(cx, sp, ast::expr_binary(op, lhs, rhs))\n-}\n+pub trait AstBuilder {\n+    // paths\n+    fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n+    fn path_ident(&self, span: span, id: ast::ident) -> @ast::Path;\n+    fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n+    fn path_all(&self, sp: span,\n+                global: bool,\n+                idents: ~[ast::ident],\n+                rp: Option<@ast::Lifetime>,\n+                types: ~[@ast::Ty])\n+        -> @ast::Path;\n+\n+    // types\n+    fn ty_mt(&self, ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt;\n+\n+    fn ty(&self, span: span, ty: ast::ty_) -> @ast::Ty;\n+    fn ty_path(&self, @ast::Path) -> @ast::Ty;\n+    fn ty_ident(&self, span: span, idents: ast::ident) -> @ast::Ty;\n+\n+    fn ty_rptr(&self, span: span,\n+               ty: @ast::Ty,\n+               lifetime: Option<@ast::Lifetime>,\n+               mutbl: ast::mutability)\n+        -> @ast::Ty;\n+    fn ty_uniq(&self, span: span, ty: @ast::Ty) -> @ast::Ty;\n+    fn ty_box(&self, span: span, ty: @ast::Ty, mutbl: ast::mutability) -> @ast::Ty;\n+\n+    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty;\n+    fn ty_infer(&self, sp: span) -> @ast::Ty;\n+    fn ty_nil(&self) -> @ast::Ty;\n+\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n+    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n+    fn ty_field_imm(&self, span: span, name: ident, ty: @ast::Ty) -> ast::ty_field;\n+    fn strip_bounds(&self, bounds: &Generics) -> Generics;\n+\n+    fn typaram(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>) -> ast::TyParam;\n+\n+    fn trait_ref(&self, path: @ast::Path) -> @ast::trait_ref;\n+    fn typarambound(&self, path: @ast::Path) -> ast::TyParamBound;\n+    fn lifetime(&self, span: span, ident: ast::ident) -> ast::Lifetime;\n+\n+    // statements\n+    fn stmt_expr(&self, expr: @ast::expr) -> @ast::stmt;\n+    fn stmt_let(&self, sp: span, mutbl: bool, ident: ast::ident, ex: @ast::expr) -> @ast::stmt;\n+\n+    // blocks\n+    fn blk(&self, span: span, stmts: ~[@ast::stmt], expr: Option<@ast::expr>) -> ast::blk;\n+    fn blk_expr(&self, expr: @ast::expr) -> ast::blk;\n+    fn blk_all(&self, span: span,\n+               view_items: ~[@ast::view_item],\n+               stmts: ~[@ast::stmt],\n+               expr: Option<@ast::expr>) -> ast::blk;\n+\n+    // expressions\n+    fn expr(&self, span: span, node: ast::expr_) -> @ast::expr;\n+    fn expr_path(&self, path: @ast::Path) -> @ast::expr;\n+    fn expr_ident(&self, span: span, id: ast::ident) -> @ast::expr;\n \n-pub fn mk_deref(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n-    mk_unary(cx, sp, ast::deref, e)\n-}\n-pub fn mk_unary(cx: @ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n-             -> @ast::expr {\n-    cx.next_id(); // see ast_util::op_expr_callee_id\n-    mk_expr(cx, sp, ast::expr_unary(op, e))\n-}\n-pub fn mk_raw_path(sp: span, idents: ~[ast::ident]) -> @ast::Path {\n-    mk_raw_path_(sp, idents, None, ~[])\n-}\n-pub fn mk_raw_path_(sp: span,\n-                    idents: ~[ast::ident],\n-                    rp: Option<@ast::Lifetime>,\n-                    types: ~[@ast::Ty])\n-                 -> @ast::Path {\n-    @ast::Path { span: sp,\n-                 global: false,\n-                 idents: idents,\n-                 rp: rp,\n-                 types: types }\n-}\n-pub fn mk_raw_path_global(sp: span, idents: ~[ast::ident]) -> @ast::Path {\n-    mk_raw_path_global_(sp, idents, None, ~[])\n-}\n-pub fn mk_raw_path_global_(sp: span,\n-                           idents: ~[ast::ident],\n-                           rp: Option<@ast::Lifetime>,\n-                           types: ~[@ast::Ty]) -> @ast::Path {\n-    @ast::Path { span: sp,\n-                 global: true,\n-                 idents: idents,\n-                 rp: rp,\n-                 types: types }\n-}\n-pub fn mk_path_raw(cx: @ext_ctxt, sp: span, path: @ast::Path)-> @ast::expr {\n-    mk_expr(cx, sp, ast::expr_path(path))\n-}\n-pub fn mk_path(cx: @ext_ctxt, sp: span, idents: ~[ast::ident])\n-            -> @ast::expr {\n-    mk_path_raw(cx, sp, mk_raw_path(sp, idents))\n-}\n-pub fn mk_path_global(cx: @ext_ctxt, sp: span, idents: ~[ast::ident])\n-                   -> @ast::expr {\n-    mk_path_raw(cx, sp, mk_raw_path_global(sp, idents))\n-}\n-pub fn mk_access_(cx: @ext_ctxt, sp: span, p: @ast::expr, m: ast::ident)\n-               -> @ast::expr {\n-    mk_expr(cx, sp, ast::expr_field(p, m, ~[]))\n-}\n-pub fn mk_access(cx: @ext_ctxt, sp: span, p: ~[ast::ident], m: ast::ident)\n-              -> @ast::expr {\n-    let pathexpr = mk_path(cx, sp, p);\n-    return mk_access_(cx, sp, pathexpr, m);\n-}\n-pub fn mk_addr_of(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n-    return mk_expr(cx, sp, ast::expr_addr_of(ast::m_imm, e));\n-}\n-pub fn mk_mut_addr_of(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n-    return mk_expr(cx, sp, ast::expr_addr_of(ast::m_mutbl, e));\n-}\n-pub fn mk_method_call(cx: @ext_ctxt,\n-                      sp: span,\n-                      rcvr_expr: @ast::expr,\n-                      method_ident: ast::ident,\n-                      args: ~[@ast::expr]) -> @ast::expr {\n-    mk_expr(cx, sp, ast::expr_method_call(rcvr_expr, method_ident, ~[], args, ast::NoSugar))\n-}\n-pub fn mk_call_(cx: @ext_ctxt, sp: span, fn_expr: @ast::expr,\n-                args: ~[@ast::expr]) -> @ast::expr {\n-    mk_expr(cx, sp, ast::expr_call(fn_expr, args, ast::NoSugar))\n-}\n-pub fn mk_call(cx: @ext_ctxt, sp: span, fn_path: ~[ast::ident],\n-               args: ~[@ast::expr]) -> @ast::expr {\n-    let pathexpr = mk_path(cx, sp, fn_path);\n-    return mk_call_(cx, sp, pathexpr, args);\n-}\n-pub fn mk_call_global(cx: @ext_ctxt, sp: span, fn_path: ~[ast::ident],\n-                      args: ~[@ast::expr]) -> @ast::expr {\n-    let pathexpr = mk_path_global(cx, sp, fn_path);\n-    return mk_call_(cx, sp, pathexpr, args);\n-}\n-// e = expr, t = type\n-pub fn mk_base_vec_e(cx: @ext_ctxt, sp: span, exprs: ~[@ast::expr])\n-                  -> @ast::expr {\n-    let vecexpr = ast::expr_vec(exprs, ast::m_imm);\n-    mk_expr(cx, sp, vecexpr)\n-}\n-pub fn mk_vstore_e(cx: @ext_ctxt, sp: span, expr: @ast::expr,\n-                   vst: ast::expr_vstore) ->\n-   @ast::expr {\n-    mk_expr(cx, sp, ast::expr_vstore(expr, vst))\n-}\n-pub fn mk_uniq_vec_e(cx: @ext_ctxt, sp: span, exprs: ~[@ast::expr])\n-                  -> @ast::expr {\n-    mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs), ast::expr_vstore_uniq)\n-}\n-pub fn mk_slice_vec_e(cx: @ext_ctxt, sp: span, exprs: ~[@ast::expr])\n-                   -> @ast::expr {\n-    mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs),\n-                ast::expr_vstore_slice)\n-}\n-pub fn mk_base_str(cx: @ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n-    let lit = ast::lit_str(@s);\n-    return mk_lit(cx, sp, lit);\n-}\n-pub fn mk_uniq_str(cx: @ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n-    mk_vstore_e(cx, sp, mk_base_str(cx, sp, s), ast::expr_vstore_uniq)\n+    fn expr_self(&self, span: span) -> @ast::expr;\n+    fn expr_binary(&self, sp: span, op: ast::binop,\n+                   lhs: @ast::expr, rhs: @ast::expr) -> @ast::expr;\n+    fn expr_deref(&self, sp: span, e: @ast::expr) -> @ast::expr;\n+    fn expr_unary(&self, sp: span, op: ast::unop, e: @ast::expr) -> @ast::expr;\n+\n+    fn expr_copy(&self, sp: span, e: @ast::expr) -> @ast::expr;\n+    fn expr_managed(&self, sp: span, e: @ast::expr) -> @ast::expr;\n+    fn expr_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr;\n+    fn expr_mut_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr;\n+    fn expr_field_access(&self, span: span, expr: @ast::expr, ident: ast::ident) -> @ast::expr;\n+    fn expr_call(&self, span: span, expr: @ast::expr, args: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_call_ident(&self, span: span, id: ast::ident, args: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_call_global(&self, sp: span, fn_path: ~[ast::ident],\n+                        args: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_method_call(&self, span: span,\n+                        expr: @ast::expr, ident: ast::ident,\n+                        args: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_blk(&self, b: ast::blk) -> @ast::expr;\n+\n+    fn field_imm(&self, span: span, name: ident, e: @ast::expr) -> ast::field;\n+    fn expr_struct(&self, span: span, path: @ast::Path, fields: ~[ast::field]) -> @ast::expr;\n+    fn expr_struct_ident(&self, span: span, id: ast::ident, fields: ~[ast::field]) -> @ast::expr;\n+\n+    fn expr_lit(&self, sp: span, lit: ast::lit_) -> @ast::expr;\n+\n+    fn expr_uint(&self, span: span, i: uint) -> @ast::expr;\n+    fn expr_int(&self, sp: span, i: int) -> @ast::expr;\n+    fn expr_u8(&self, sp: span, u: u8) -> @ast::expr;\n+    fn expr_bool(&self, sp: span, value: bool) -> @ast::expr;\n+\n+    fn expr_vstore(&self, sp: span, expr: @ast::expr, vst: ast::expr_vstore) -> @ast::expr;\n+    fn expr_vec(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_vec_uniq(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_vec_slice(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_str(&self, sp: span, s: ~str) -> @ast::expr;\n+    fn expr_str_uniq(&self, sp: span, s: ~str) -> @ast::expr;\n+\n+    fn expr_unreachable(&self, span: span) -> @ast::expr;\n+\n+    fn pat(&self, span: span, pat: ast::pat_) -> @ast::pat;\n+    fn pat_wild(&self, span: span) -> @ast::pat;\n+    fn pat_lit(&self, span: span, expr: @ast::expr) -> @ast::pat;\n+    fn pat_ident(&self, span: span, ident: ast::ident) -> @ast::pat;\n+\n+    fn pat_ident_binding_mode(&self,\n+                              span: span,\n+                              ident: ast::ident,\n+                              bm: ast::binding_mode) -> @ast::pat;\n+    fn pat_enum(&self, span: span, path: @ast::Path, subpats: ~[@ast::pat]) -> @ast::pat;\n+    fn pat_struct(&self, span: span,\n+                  path: @ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat;\n+\n+    fn arm(&self, span: span, pats: ~[@ast::pat], expr: @ast::expr) -> ast::arm;\n+    fn arm_unreachable(&self, span: span) -> ast::arm;\n+\n+    fn expr_match(&self, span: span, arg: @ast::expr, arms: ~[ast::arm]) -> @ast::expr;\n+    fn expr_if(&self, span: span,\n+               cond: @ast::expr, then: @ast::expr, els: Option<@ast::expr>) -> @ast::expr;\n+\n+    fn lambda_fn_decl(&self, span: span, fn_decl: ast::fn_decl, blk: ast::blk) -> @ast::expr;\n+\n+    fn lambda(&self, span: span, ids: ~[ast::ident], blk: ast::blk) -> @ast::expr;\n+    fn lambda0(&self, span: span, blk: ast::blk) -> @ast::expr;\n+    fn lambda1(&self, span: span, blk: ast::blk, ident: ast::ident) -> @ast::expr;\n+\n+    fn lambda_expr(&self, span: span, ids: ~[ast::ident], blk: @ast::expr) -> @ast::expr;\n+    fn lambda_expr_0(&self, span: span, expr: @ast::expr) -> @ast::expr;\n+    fn lambda_expr_1(&self, span: span, expr: @ast::expr, ident: ast::ident) -> @ast::expr;\n+\n+    fn lambda_stmts(&self, span: span, ids: ~[ast::ident], blk: ~[@ast::stmt]) -> @ast::expr;\n+    fn lambda_stmts_0(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr;\n+    fn lambda_stmts_1(&self, span: span, stmts: ~[@ast::stmt], ident: ast::ident) -> @ast::expr;\n+\n+    // items\n+    fn item(&self, span: span,\n+            name: ident, attrs: ~[ast::attribute], node: ast::item_) -> @ast::item;\n+\n+    fn arg(&self, span: span, name: ident, ty: @ast::Ty) -> ast::arg;\n+    // XXX unused self\n+    fn fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n+\n+    fn item_fn_poly(&self,\n+                    span: span,\n+                    name: ident,\n+                    inputs: ~[ast::arg],\n+                    output: @ast::Ty,\n+                    generics: Generics,\n+                    body: ast::blk) -> @ast::item;\n+    fn item_fn(&self,\n+               span: span,\n+               name: ident,\n+               inputs: ~[ast::arg],\n+               output: @ast::Ty,\n+               body: ast::blk) -> @ast::item;\n+\n+    fn variant(&self, span: span, name: ident, tys: ~[@ast::Ty]) -> ast::variant;\n+    fn item_enum_poly(&self,\n+                      span: span,\n+                      name: ident,\n+                      enum_definition: ast::enum_def,\n+                      generics: Generics) -> @ast::item;\n+    fn item_enum(&self, span: span, name: ident, enum_def: ast::enum_def) -> @ast::item;\n+\n+    fn item_struct_poly(&self,\n+                        span: span,\n+                        name: ident,\n+                        struct_def: ast::struct_def,\n+                        generics: Generics) -> @ast::item;\n+    fn item_struct(&self, span: span, name: ident, struct_def: ast::struct_def) -> @ast::item;\n+\n+    fn item_mod(&self, span: span,\n+                name: ident, attrs: ~[ast::attribute],\n+                vi: ~[@ast::view_item], items: ~[@ast::item]) -> @ast::item;\n+\n+    fn item_ty_poly(&self,\n+                    span: span,\n+                    name: ident,\n+                    ty: @ast::Ty,\n+                    generics: Generics) -> @ast::item;\n+    fn item_ty(&self, span: span, name: ident, ty: @ast::Ty) -> @ast::item;\n+\n+    fn attribute(&self, sp: span, mi: @ast::meta_item) -> ast::attribute;\n+\n+    fn meta_word(&self, sp: span, w: ~str) -> @ast::meta_item;\n+    fn meta_list(&self, sp: span, name: ~str, mis: ~[@ast::meta_item]) -> @ast::meta_item;\n+    fn meta_name_value(&self, sp: span, name: ~str, value: ast::lit_) -> @ast::meta_item;\n+\n+    fn view_use(&self, sp: span,\n+                vis: ast::visibility, vp: ~[@ast::view_path]) -> @ast::view_item;\n+    fn view_use_list(&self, sp: span, vis: ast::visibility,\n+                     path: ~[ast::ident], imports: &[ast::ident]) -> @ast::view_item;\n+    fn view_use_glob(&self, sp: span,\n+                     vis: ast::visibility, path: ~[ast::ident]) -> @ast::view_item;\n }\n-pub fn mk_field(sp: span, f: &Field) -> ast::field {\n-    codemap::spanned {\n-        node: ast::field_ { mutbl: ast::m_imm, ident: f.ident, expr: f.ex },\n-        span: sp,\n+\n+impl AstBuilder for @ExtCtxt {\n+    fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n+        self.path_all(span, false, strs, None, ~[])\n     }\n-}\n-pub fn mk_fields(sp: span, fields: ~[Field]) -> ~[ast::field] {\n-    fields.map(|f| mk_field(sp, f))\n-}\n-pub fn mk_struct_e(cx: @ext_ctxt,\n-                   sp: span,\n-                   ctor_path: ~[ast::ident],\n-                   fields: ~[Field])\n-                -> @ast::expr {\n-    mk_expr(cx, sp,\n-            ast::expr_struct(mk_raw_path(sp, ctor_path),\n-                             mk_fields(sp, fields),\n-                                    option::None::<@ast::expr>))\n-}\n-pub fn mk_global_struct_e(cx: @ext_ctxt,\n-                          sp: span,\n-                          ctor_path: ~[ast::ident],\n-                          fields: ~[Field])\n-                       -> @ast::expr {\n-    mk_expr(cx, sp,\n-            ast::expr_struct(mk_raw_path_global(sp, ctor_path),\n-                             mk_fields(sp, fields),\n-                                    option::None::<@ast::expr>))\n-}\n-pub fn mk_glob_use(cx: @ext_ctxt,\n-                   sp: span,\n-                   vis: ast::visibility,\n-                   path: ~[ast::ident]) -> @ast::view_item {\n-    let glob = @codemap::spanned {\n-        node: ast::view_path_glob(mk_raw_path(sp, path), cx.next_id()),\n-        span: sp,\n-    };\n-    @ast::view_item { node: ast::view_item_use(~[glob]),\n-                      attrs: ~[],\n-                      vis: vis,\n-                      span: sp }\n-}\n-pub fn mk_local(cx: @ext_ctxt, sp: span, mutbl: bool,\n-                ident: ast::ident, ex: @ast::expr) -> @ast::stmt {\n-\n-    let pat = @ast::pat {\n-        id: cx.next_id(),\n-        node: ast::pat_ident(\n-            ast::bind_by_copy,\n-            mk_raw_path(sp, ~[ident]),\n-            None),\n-        span: sp,\n-    };\n-    let ty = @ast::Ty { id: cx.next_id(), node: ast::ty_infer, span: sp };\n-    let local = @codemap::spanned {\n-        node: ast::local_ {\n-            is_mutbl: mutbl,\n-            ty: ty,\n-            pat: pat,\n-            init: Some(ex),\n-            id: cx.next_id(),\n-        },\n-        span: sp,\n-    };\n-    let decl = codemap::spanned {node: ast::decl_local(~[local]), span: sp};\n-    @codemap::spanned { node: ast::stmt_decl(@decl, cx.next_id()), span: sp }\n-}\n-pub fn mk_block(cx: @ext_ctxt, span: span,\n-                view_items: ~[@ast::view_item],\n-                stmts: ~[@ast::stmt],\n-                expr: Option<@ast::expr>) -> @ast::expr {\n-    let blk = codemap::spanned {\n-        node: ast::blk_ {\n-             view_items: view_items,\n-             stmts: stmts,\n-             expr: expr,\n-             id: cx.next_id(),\n-             rules: ast::default_blk,\n-        },\n-        span: span,\n-    };\n-    mk_expr(cx, span, ast::expr_block(blk))\n-}\n-pub fn mk_block_(cx: @ext_ctxt,\n-                 span: span,\n-                 stmts: ~[@ast::stmt])\n-              -> ast::blk {\n-    codemap::spanned {\n-        node: ast::blk_ {\n-            view_items: ~[],\n-            stmts: stmts,\n-            expr: None,\n-            id: cx.next_id(),\n-            rules: ast::default_blk,\n-        },\n-        span: span,\n+    fn path_ident(&self, span: span, id: ast::ident) -> @ast::Path {\n+        self.path(span, ~[id])\n     }\n-}\n-pub fn mk_simple_block(cx: @ext_ctxt,\n-                       span: span,\n-                       expr: @ast::expr)\n-                    -> ast::blk {\n-    codemap::spanned {\n-        node: ast::blk_ {\n-            view_items: ~[],\n-            stmts: ~[],\n-            expr: Some(expr),\n-            id: cx.next_id(),\n-            rules: ast::default_blk,\n-        },\n-        span: span,\n+    fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n+        self.path_all(span, true, strs, None, ~[])\n+    }\n+    fn path_all(&self, sp: span,\n+                global: bool,\n+                idents: ~[ast::ident],\n+                rp: Option<@ast::Lifetime>,\n+                types: ~[@ast::Ty])\n+        -> @ast::Path {\n+        @ast::Path {\n+            span: sp,\n+            global: global,\n+            idents: idents,\n+            rp: rp,\n+            types: types\n+        }\n     }\n-}\n-pub fn mk_lambda_(cx: @ext_ctxt,\n-                 span: span,\n-                 fn_decl: ast::fn_decl,\n-                 blk: ast::blk)\n-              -> @ast::expr {\n-    mk_expr(cx, span, ast::expr_fn_block(fn_decl, blk))\n-}\n-pub fn mk_lambda(cx: @ext_ctxt,\n-                 span: span,\n-                 fn_decl: ast::fn_decl,\n-                 expr: @ast::expr)\n-              -> @ast::expr {\n-    let blk = mk_simple_block(cx, span, expr);\n-    mk_lambda_(cx, span, fn_decl, blk)\n-}\n-pub fn mk_lambda_stmts(cx: @ext_ctxt,\n-                       span: span,\n-                       fn_decl: ast::fn_decl,\n-                       stmts: ~[@ast::stmt])\n-                    -> @ast::expr {\n-    let blk = mk_block(cx, span, ~[], stmts, None);\n-    mk_lambda(cx, span, fn_decl, blk)\n-}\n-pub fn mk_lambda_no_args(cx: @ext_ctxt,\n-                         span: span,\n-                         expr: @ast::expr)\n-                      -> @ast::expr {\n-    let fn_decl = mk_fn_decl(~[], mk_ty_infer(cx, span));\n-    mk_lambda(cx, span, fn_decl, expr)\n-}\n-pub fn mk_copy(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n-    mk_expr(cx, sp, ast::expr_copy(e))\n-}\n-pub fn mk_managed(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n-    mk_expr(cx, sp, ast::expr_unary(ast::box(ast::m_imm), e))\n-}\n-pub fn mk_pat(cx: @ext_ctxt, span: span, pat: ast::pat_) -> @ast::pat {\n-    @ast::pat { id: cx.next_id(), node: pat, span: span }\n-}\n-pub fn mk_pat_wild(cx: @ext_ctxt, span: span) -> @ast::pat {\n-    mk_pat(cx, span, ast::pat_wild)\n-}\n-pub fn mk_pat_lit(cx: @ext_ctxt,\n-                  span: span,\n-                  expr: @ast::expr) -> @ast::pat {\n-    mk_pat(cx, span, ast::pat_lit(expr))\n-}\n-pub fn mk_pat_ident(cx: @ext_ctxt,\n-                    span: span,\n-                    ident: ast::ident) -> @ast::pat {\n-    mk_pat_ident_with_binding_mode(cx, span, ident, ast::bind_by_copy)\n-}\n \n-pub fn mk_pat_ident_with_binding_mode(cx: @ext_ctxt,\n-                                      span: span,\n-                                      ident: ast::ident,\n-                                      bm: ast::binding_mode) -> @ast::pat {\n-    let path = mk_raw_path(span, ~[ ident ]);\n-    let pat = ast::pat_ident(bm, path, None);\n-    mk_pat(cx, span, pat)\n-}\n-pub fn mk_pat_enum(cx: @ext_ctxt,\n-                   span: span,\n-                   path: @ast::Path,\n-                   subpats: ~[@ast::pat])\n-                -> @ast::pat {\n-    let pat = ast::pat_enum(path, Some(subpats));\n-    mk_pat(cx, span, pat)\n-}\n-pub fn mk_pat_struct(cx: @ext_ctxt,\n-                     span: span,\n-                     path: @ast::Path,\n-                     field_pats: ~[ast::field_pat])\n-                  -> @ast::pat {\n-    let pat = ast::pat_struct(path, field_pats, false);\n-    mk_pat(cx, span, pat)\n-}\n-pub fn mk_bool(cx: @ext_ctxt, span: span, value: bool) -> @ast::expr {\n-    let lit_expr = ast::expr_lit(@codemap::spanned {\n-        node: ast::lit_bool(value),\n-        span: span });\n-    build::mk_expr(cx, span, lit_expr)\n-}\n-pub fn mk_stmt(cx: @ext_ctxt, span: span, expr: @ast::expr) -> @ast::stmt {\n-    let stmt_ = ast::stmt_semi(expr, cx.next_id());\n-    @codemap::spanned { node: stmt_, span: span }\n-}\n+    fn ty_mt(&self, ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt {\n+        ast::mt {\n+            ty: ty,\n+            mutbl: mutbl\n+        }\n+    }\n \n-pub fn mk_ty_mt(ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt {\n-    ast::mt {\n-        ty: ty,\n-        mutbl: mutbl\n+    fn ty(&self, span: span, ty: ast::ty_) -> @ast::Ty {\n+        @ast::Ty {\n+            id: self.next_id(),\n+            span: span,\n+            node: ty\n+        }\n     }\n-}\n \n-pub fn mk_ty(cx: @ext_ctxt,\n-             span: span,\n-             ty: ast::ty_) -> @ast::Ty {\n-    @ast::Ty {\n-        id: cx.next_id(),\n-        span: span,\n-        node: ty\n+    fn ty_path(&self, path: @ast::Path) -> @ast::Ty {\n+        self.ty(path.span,\n+                ast::ty_path(path, self.next_id()))\n     }\n-}\n \n-pub fn mk_ty_path(cx: @ext_ctxt,\n-                  span: span,\n-                  idents: ~[ ast::ident ])\n-               -> @ast::Ty {\n-    let ty = build::mk_raw_path(span, idents);\n-    mk_ty_path_path(cx, span, ty)\n-}\n+    fn ty_ident(&self, span: span, ident: ast::ident)\n+        -> @ast::Ty {\n+        self.ty_path(self.path_ident(span, ident))\n+    }\n \n-pub fn mk_ty_path_global(cx: @ext_ctxt,\n-                         span: span,\n-                         idents: ~[ ast::ident ])\n-                      -> @ast::Ty {\n-    let ty = build::mk_raw_path_global(span, idents);\n-    mk_ty_path_path(cx, span, ty)\n-}\n+    fn ty_rptr(&self,\n+               span: span,\n+               ty: @ast::Ty,\n+               lifetime: Option<@ast::Lifetime>,\n+               mutbl: ast::mutability)\n+        -> @ast::Ty {\n+        self.ty(span,\n+                ast::ty_rptr(lifetime, self.ty_mt(ty, mutbl)))\n+    }\n+    fn ty_uniq(&self, span: span, ty: @ast::Ty) -> @ast::Ty {\n+        self.ty(span, ast::ty_uniq(self.ty_mt(ty, ast::m_imm)))\n+    }\n+    fn ty_box(&self, span: span,\n+                 ty: @ast::Ty, mutbl: ast::mutability) -> @ast::Ty {\n+        self.ty(span, ast::ty_box(self.ty_mt(ty, mutbl)))\n+    }\n \n-pub fn mk_ty_path_path(cx: @ext_ctxt,\n-                       span: span,\n-                       path: @ast::Path)\n-                      -> @ast::Ty {\n-    let ty = ast::ty_path(path, cx.next_id());\n-    mk_ty(cx, span, ty)\n-}\n+    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty {\n+        self.ty_path(\n+            self.path_all(dummy_sp(),\n+                          true,\n+                          ~[\n+                              self.ident_of(\"core\"),\n+                              self.ident_of(\"option\"),\n+                              self.ident_of(\"Option\")\n+                          ],\n+                          None,\n+                          ~[ ty ]))\n+    }\n \n-pub fn mk_ty_rptr(cx: @ext_ctxt,\n-                  span: span,\n-                  ty: @ast::Ty,\n-                  lifetime: Option<@ast::Lifetime>,\n-                  mutbl: ast::mutability)\n-               -> @ast::Ty {\n-    mk_ty(cx, span,\n-          ast::ty_rptr(lifetime, mk_ty_mt(ty, mutbl)))\n-}\n-pub fn mk_ty_uniq(cx: @ext_ctxt, span: span, ty: @ast::Ty) -> @ast::Ty {\n-    mk_ty(cx, span, ast::ty_uniq(mk_ty_mt(ty, ast::m_imm)))\n-}\n-pub fn mk_ty_box(cx: @ext_ctxt, span: span,\n-                 ty: @ast::Ty, mutbl: ast::mutability) -> @ast::Ty {\n-    mk_ty(cx, span, ast::ty_box(mk_ty_mt(ty, mutbl)))\n-}\n+    fn ty_field_imm(&self, span: span, name: ident, ty: @ast::Ty) -> ast::ty_field {\n+        respan(span,\n+               ast::ty_field_ {\n+                   ident: name,\n+                   mt: ast::mt { ty: ty, mutbl: ast::m_imm },\n+               })\n+    }\n \n+    fn ty_infer(&self, span: span) -> @ast::Ty {\n+        self.ty(span, ast::ty_infer)\n+    }\n \n+    fn ty_nil(&self) -> @ast::Ty {\n+        @ast::Ty {\n+            id: self.next_id(),\n+            node: ast::ty_nil,\n+            span: dummy_sp(),\n+        }\n+    }\n \n-pub fn mk_ty_infer(cx: @ext_ctxt, span: span) -> @ast::Ty {\n-    mk_ty(cx, span, ast::ty_infer)\n-}\n-pub fn mk_trait_ref_global(cx: @ext_ctxt,\n-                           span: span,\n-                           idents: ~[ ast::ident ])\n-    -> @ast::trait_ref\n-{\n-    mk_trait_ref_(cx, build::mk_raw_path_global(span, idents))\n-}\n-pub fn mk_trait_ref_(cx: @ext_ctxt, path: @ast::Path) -> @ast::trait_ref {\n-    @ast::trait_ref {\n-        path: path,\n-        ref_id: cx.next_id()\n+    fn typaram(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>) -> ast::TyParam {\n+        ast::TyParam { ident: id, id: self.next_id(), bounds: bounds }\n     }\n-}\n-pub fn mk_simple_ty_path(cx: @ext_ctxt,\n-                         span: span,\n-                         ident: ast::ident)\n-                      -> @ast::Ty {\n-    mk_ty_path(cx, span, ~[ ident ])\n-}\n-pub fn mk_arg(cx: @ext_ctxt,\n-              span: span,\n-              ident: ast::ident,\n-              ty: @ast::Ty)\n-           -> ast::arg {\n-    let arg_pat = mk_pat_ident(cx, span, ident);\n-    ast::arg {\n-        is_mutbl: false,\n-        ty: ty,\n-        pat: arg_pat,\n-        id: cx.next_id()\n+\n+    // these are strange, and probably shouldn't be used outside of\n+    // pipes. Specifically, the global version possible generates\n+    // incorrect code.\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n+        opt_vec::take_vec(\n+            ty_params.map(|p| self.ty_ident(dummy_sp(), p.ident)))\n     }\n-}\n-pub fn mk_fn_decl(inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n-    ast::fn_decl { inputs: inputs, output: output, cf: ast::return_val }\n-}\n-pub fn mk_trait_ty_param_bound_global(cx: @ext_ctxt,\n-                                      span: span,\n-                                      idents: ~[ast::ident])\n-                                   -> ast::TyParamBound {\n-    ast::TraitTyParamBound(mk_trait_ref_global(cx, span, idents))\n-}\n-pub fn mk_trait_ty_param_bound_(cx: @ext_ctxt,\n-                                path: @ast::Path) -> ast::TyParamBound {\n-    ast::TraitTyParamBound(mk_trait_ref_(cx, path))\n-}\n-pub fn mk_ty_param(cx: @ext_ctxt,\n-                   ident: ast::ident,\n-                   bounds: @OptVec<ast::TyParamBound>)\n-                -> ast::TyParam {\n-    ast::TyParam { ident: ident, id: cx.next_id(), bounds: bounds }\n-}\n-pub fn mk_lifetime(cx: @ext_ctxt,\n-                   span: span,\n-                   ident: ast::ident)\n-                -> ast::Lifetime {\n-    ast::Lifetime { id: cx.next_id(), span: span, ident: ident }\n-}\n-pub fn mk_arm(cx: @ext_ctxt,\n-              span: span,\n-              pats: ~[@ast::pat],\n-              expr: @ast::expr)\n-           -> ast::arm {\n-    ast::arm {\n-        pats: pats,\n-        guard: None,\n-        body: mk_simple_block(cx, span, expr)\n+\n+    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n+        opt_vec::take_vec(\n+            ty_params.map(|p| self.ty_path(\n+                self.path_global(dummy_sp(), ~[p.ident]))))\n     }\n-}\n-pub fn mk_unreachable(cx: @ext_ctxt, span: span) -> @ast::expr {\n-    let loc = cx.codemap().lookup_char_pos(span.lo);\n-    mk_call_global(\n-        cx,\n-        span,\n-        ~[\n-            cx.ident_of(\"core\"),\n-            cx.ident_of(\"sys\"),\n-            cx.ident_of(\"FailWithCause\"),\n-            cx.ident_of(\"fail_with\"),\n-        ],\n-        ~[\n-            mk_base_str(cx, span, ~\"internal error: entered unreachable code\"),\n-            mk_base_str(cx, span, copy loc.file.name),\n-            mk_uint(cx, span, loc.line),\n-        ]\n-    )\n-}\n-pub fn mk_unreachable_arm(cx: @ext_ctxt, span: span) -> ast::arm {\n-    mk_arm(cx, span, ~[mk_pat_wild(cx, span)], mk_unreachable(cx, span))\n-}\n \n-pub fn make_self(cx: @ext_ctxt, span: span) -> @ast::expr {\n-    build::mk_expr(cx, span, ast::expr_self)\n-}\n+    fn strip_bounds(&self, generics: &Generics) -> Generics {\n+        let no_bounds = @opt_vec::Empty;\n+        let new_params = do generics.ty_params.map |ty_param| {\n+            ast::TyParam { bounds: no_bounds, ..copy *ty_param }\n+        };\n+        Generics {\n+            ty_params: new_params,\n+            .. copy *generics\n+        }\n+    }\n \n-//\n-// Duplication functions\n-//\n-// These functions just duplicate AST nodes.\n-//\n+    fn trait_ref(&self, path: @ast::Path) -> @ast::trait_ref {\n+        @ast::trait_ref {\n+            path: path,\n+            ref_id: self.next_id()\n+        }\n+    }\n \n-pub fn duplicate_expr(cx: @ext_ctxt, expr: @ast::expr) -> @ast::expr {\n-    let folder = fold::default_ast_fold();\n-    let folder = @fold::AstFoldFns {\n-        new_id: |_| cx.next_id(),\n-        ..*folder\n-    };\n-    let folder = fold::make_fold(folder);\n-    folder.fold_expr(expr)\n-}\n+    fn typarambound(&self, path: @ast::Path) -> ast::TyParamBound {\n+        ast::TraitTyParamBound(self.trait_ref(path))\n+    }\n \n+    fn lifetime(&self, span: span, ident: ast::ident) -> ast::Lifetime {\n+        ast::Lifetime { id: self.next_id(), span: span, ident: ident }\n+    }\n \n+    fn stmt_expr(&self, expr: @ast::expr) -> @ast::stmt {\n+        @respan(expr.span, ast::stmt_semi(expr, self.next_id()))\n+    }\n \n-// Transitional reexports so qquote can find the paths it is looking for\n-mod syntax {\n-    pub use ext;\n-    pub use parse;\n-}\n+    fn stmt_let(&self, sp: span, mutbl: bool, ident: ast::ident, ex: @ast::expr) -> @ast::stmt {\n+        let pat = self.pat_ident(sp, ident);\n+        let local = @respan(sp,\n+                            ast::local_ {\n+                                is_mutbl: mutbl,\n+                                ty: self.ty_infer(sp),\n+                                pat: pat,\n+                                init: Some(ex),\n+                                id: self.next_id(),\n+                            });\n+        let decl = respan(sp, ast::decl_local(~[local]));\n+        @respan(sp, ast::stmt_decl(@decl, self.next_id()))\n+    }\n \n-trait ExtCtxtMethods {\n-    fn bind_path(&self,\n-                 span: span,\n-                 ident: ast::ident,\n-                 path: @ast::Path,\n-                 bounds: @OptVec<ast::TyParamBound>)\n-                 -> ast::TyParam;\n-    fn expr(&self, span: span, node: ast::expr_) -> @ast::expr;\n-    fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n-    fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n-    fn path_tps(&self, span: span, strs: ~[ast::ident], tps: ~[@ast::Ty])\n-                -> @ast::Path;\n-    fn path_tps_global(&self,\n-                       span: span,\n-                       strs: ~[ast::ident],\n-                       tps: ~[@ast::Ty])\n-                       -> @ast::Path;\n-    fn ty_path(&self, span: span, strs: ~[ast::ident], tps: ~[@ast::Ty])\n-               -> @ast::Ty;\n-    fn binder_pat(&self, span: span, nm: ast::ident) -> @ast::pat;\n-    fn stmt(&self, expr: @ast::expr) -> @ast::stmt;\n-    fn lit_str(&self, span: span, s: @~str) -> @ast::expr;\n-    fn lit_uint(&self, span: span, i: uint) -> @ast::expr;\n-    fn lambda0(&self, blk: ast::blk) -> @ast::expr;\n-    fn lambda1(&self, blk: ast::blk, ident: ast::ident) -> @ast::expr;\n-    fn blk(&self, span: span, stmts: ~[@ast::stmt]) -> ast::blk;\n-    fn expr_blk(&self, expr: @ast::expr) -> ast::blk;\n-    fn expr_path(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n-    fn expr_path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n-    fn expr_var(&self, span: span, var: &str) -> @ast::expr;\n-    fn expr_self(&self, span: span) -> @ast::expr;\n-    fn expr_field(&self, span: span, expr: @ast::expr, ident: ast::ident)\n-                  -> @ast::expr;\n-    fn expr_call(&self, span: span, expr: @ast::expr, args: ~[@ast::expr])\n-                 -> @ast::expr;\n-    fn expr_method_call(&self,\n-                        span: span,\n-                        expr: @ast::expr,\n-                        ident: ast::ident,\n-                        args: ~[@ast::expr])\n-                        -> @ast::expr;\n-    fn lambda_expr_0(&self, expr: @ast::expr) -> @ast::expr;\n-    fn lambda_expr_1(&self, expr: @ast::expr, ident: ast::ident)\n-                    -> @ast::expr;\n-    fn lambda_stmts_0(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr;\n-    fn lambda_stmts_1(&self,\n-                      span: span,\n-                      stmts: ~[@ast::stmt],\n-                      ident: ast::ident)\n-                      -> @ast::expr;\n-}\n+    fn blk(&self, span: span, stmts: ~[@ast::stmt], expr: Option<@expr>) -> ast::blk {\n+        self.blk_all(span, ~[], stmts, expr)\n+    }\n \n-impl ExtCtxtMethods for @ext_ctxt {\n-    fn bind_path(\n-        &self,\n-        _span: span,\n-        ident: ast::ident,\n-        path: @ast::Path,\n-        bounds: @OptVec<ast::TyParamBound>\n-    ) -> ast::TyParam {\n-        let bound = ast::TraitTyParamBound(@ast::trait_ref {\n-            ref_id: self.next_id(),\n-            path: path\n-        });\n-\n-        ast::TyParam {\n-            ident: ident,\n-            id: self.next_id(),\n-            bounds: @bounds.prepend(bound)\n-        }\n+    fn blk_expr(&self, expr: @ast::expr) -> ast::blk {\n+        self.blk_all(expr.span, ~[], ~[], Some(expr))\n+    }\n+    fn blk_all(&self,\n+               span: span,\n+               view_items: ~[@ast::view_item],\n+               stmts: ~[@ast::stmt],\n+               expr: Option<@ast::expr>) -> ast::blk {\n+        respan(span,\n+               ast::blk_ {\n+                   view_items: view_items,\n+                   stmts: stmts,\n+                   expr: expr,\n+                   id: self.next_id(),\n+                   rules: ast::default_blk,\n+               })\n     }\n \n     fn expr(&self, span: span, node: ast::expr_) -> @ast::expr {\n@@ -628,212 +418,440 @@ impl ExtCtxtMethods for @ext_ctxt {\n         }\n     }\n \n-    fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n-        @ast::Path {\n-            span: span,\n-            global: false,\n-            idents: strs,\n-            rp: None,\n-            types: ~[]\n-        }\n+    fn expr_path(&self, path: @ast::Path) -> @ast::expr {\n+        self.expr(path.span, ast::expr_path(path))\n     }\n \n-    fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n-        @ast::Path {\n-            span: span,\n-            global: true,\n-            idents: strs,\n-            rp: None,\n-            types: ~[]\n-        }\n+    fn expr_ident(&self, span: span, id: ast::ident) -> @ast::expr {\n+        self.expr_path(self.path_ident(span, id))\n+    }\n+    fn expr_self(&self, span: span) -> @ast::expr {\n+        self.expr(span, ast::expr_self)\n     }\n \n-    fn path_tps(\n-        &self,\n-        span: span,\n-        strs: ~[ast::ident],\n-        tps: ~[@ast::Ty]\n-    ) -> @ast::Path {\n-        @ast::Path {\n-            span: span,\n-            global: false,\n-            idents: strs,\n-            rp: None,\n-            types: tps\n-        }\n+    fn expr_binary(&self, sp: span, op: ast::binop,\n+                   lhs: @ast::expr, rhs: @ast::expr) -> @ast::expr {\n+        self.next_id(); // see ast_util::op_expr_callee_id\n+        self.expr(sp, ast::expr_binary(op, lhs, rhs))\n     }\n \n-    fn path_tps_global(\n-        &self,\n-        span: span,\n-        strs: ~[ast::ident],\n-        tps: ~[@ast::Ty]\n-    ) -> @ast::Path {\n-        @ast::Path {\n-            span: span,\n-            global: true,\n-            idents: strs,\n-            rp: None,\n-            types: tps\n-        }\n+    fn expr_deref(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+        self.expr_unary(sp, ast::deref, e)\n+    }\n+    fn expr_unary(&self, sp: span, op: ast::unop, e: @ast::expr)\n+        -> @ast::expr {\n+        self.next_id(); // see ast_util::op_expr_callee_id\n+        self.expr(sp, ast::expr_unary(op, e))\n     }\n \n-    fn ty_path(\n-        &self,\n-        span: span,\n-        strs: ~[ast::ident],\n-        tps: ~[@ast::Ty]\n-    ) -> @ast::Ty {\n-        @ast::Ty {\n-            id: self.next_id(),\n-            node: ast::ty_path(\n-                self.path_tps(span, strs, tps),\n-                self.next_id()),\n-            span: span,\n-        }\n+    fn expr_copy(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+        self.expr(sp, ast::expr_copy(e))\n+    }\n+    fn expr_managed(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+        self.expr_unary(sp, ast::box(ast::m_imm), e)\n     }\n \n-    fn binder_pat(&self, span: span, nm: ast::ident) -> @ast::pat {\n-        @ast::pat {\n-            id: self.next_id(),\n-            node: ast::pat_ident(\n-                ast::bind_by_ref(ast::m_imm),\n-                self.path(span, ~[nm]),\n-                None),\n-            span: span,\n-        }\n+    fn expr_field_access(&self, sp: span, expr: @ast::expr, ident: ast::ident) -> @ast::expr {\n+        self.expr(sp, ast::expr_field(expr, ident, ~[]))\n+    }\n+    fn expr_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+        self.expr(sp, ast::expr_addr_of(ast::m_imm, e))\n+    }\n+    fn expr_mut_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+        self.expr(sp, ast::expr_addr_of(ast::m_mutbl, e))\n+    }\n+\n+    fn expr_call(&self, span: span, expr: @ast::expr, args: ~[@ast::expr]) -> @ast::expr {\n+        self.expr(span, ast::expr_call(expr, args, ast::NoSugar))\n+    }\n+    fn expr_call_ident(&self, span: span, id: ast::ident, args: ~[@ast::expr]) -> @ast::expr {\n+        self.expr(span,\n+                  ast::expr_call(self.expr_ident(span, id), args, ast::NoSugar))\n+    }\n+    fn expr_call_global(&self, sp: span, fn_path: ~[ast::ident],\n+                      args: ~[@ast::expr]) -> @ast::expr {\n+        let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n+        self.expr_call(sp, pathexpr, args)\n+    }\n+    fn expr_method_call(&self, span: span,\n+                        expr: @ast::expr,\n+                        ident: ast::ident,\n+                        args: ~[@ast::expr]) -> @ast::expr {\n+        self.expr(span,\n+                  ast::expr_method_call(expr, ident, ~[], args, ast::NoSugar))\n+    }\n+    fn expr_blk(&self, b: ast::blk) -> @ast::expr {\n+        self.expr(b.span, ast::expr_block(b))\n+    }\n+    fn field_imm(&self, span: span, name: ident, e: @ast::expr) -> ast::field {\n+        respan(span, ast::field_ { mutbl: ast::m_imm, ident: name, expr: e })\n+    }\n+    fn expr_struct(&self, span: span, path: @ast::Path, fields: ~[ast::field]) -> @ast::expr {\n+        self.expr(span, ast::expr_struct(path, fields, None))\n+    }\n+    fn expr_struct_ident(&self, span: span,\n+                         id: ast::ident, fields: ~[ast::field]) -> @ast::expr {\n+        self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n \n-    fn stmt(&self, expr: @ast::expr) -> @ast::stmt {\n-        @codemap::spanned { node: ast::stmt_semi(expr, self.next_id()),\n-                       span: expr.span }\n+    fn expr_lit(&self, sp: span, lit: ast::lit_) -> @ast::expr {\n+        self.expr(sp, ast::expr_lit(@respan(sp, lit)))\n+    }\n+    fn expr_uint(&self, span: span, i: uint) -> @ast::expr {\n+        self.expr_lit(span, ast::lit_uint(i as u64, ast::ty_u))\n+    }\n+    fn expr_int(&self, sp: span, i: int) -> @ast::expr {\n+        self.expr_lit(sp, ast::lit_int(i as i64, ast::ty_i))\n+    }\n+    fn expr_u8(&self, sp: span, u: u8) -> @ast::expr {\n+        self.expr_lit(sp, ast::lit_uint(u as u64, ast::ty_u8))\n+    }\n+    fn expr_bool(&self, sp: span, value: bool) -> @ast::expr {\n+        self.expr_lit(sp, ast::lit_bool(value))\n     }\n \n-    fn lit_str(&self, span: span, s: @~str) -> @ast::expr {\n-        self.expr(\n-            span,\n-            ast::expr_vstore(\n-                self.expr(\n-                    span,\n-                    ast::expr_lit(\n-                        @codemap::spanned { node: ast::lit_str(s),\n-                                        span: span})),\n-                ast::expr_vstore_uniq))\n+    fn expr_vstore(&self, sp: span, expr: @ast::expr, vst: ast::expr_vstore) -> @ast::expr {\n+        self.expr(sp, ast::expr_vstore(expr, vst))\n+    }\n+    fn expr_vec(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr {\n+        self.expr(sp, ast::expr_vec(exprs, ast::m_imm))\n     }\n+    fn expr_vec_uniq(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr {\n+        self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::expr_vstore_uniq)\n+    }\n+    fn expr_vec_slice(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr {\n+        self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::expr_vstore_slice)\n+    }\n+    fn expr_str(&self, sp: span, s: ~str) -> @ast::expr {\n+        self.expr_lit(sp, ast::lit_str(@s))\n+    }\n+    fn expr_str_uniq(&self, sp: span, s: ~str) -> @ast::expr {\n+        self.expr_vstore(sp, self.expr_str(sp, s), ast::expr_vstore_uniq)\n+    }\n+\n \n-    fn lit_uint(&self, span: span, i: uint) -> @ast::expr {\n-        self.expr(\n+    fn expr_unreachable(&self, span: span) -> @ast::expr {\n+        let loc = self.codemap().lookup_char_pos(span.lo);\n+        self.expr_call_global(\n             span,\n-            ast::expr_lit(\n-                @codemap::spanned { node: ast::lit_uint(i as u64, ast::ty_u),\n-                                span: span}))\n+            ~[\n+                self.ident_of(\"core\"),\n+                self.ident_of(\"sys\"),\n+                self.ident_of(\"FailWithCause\"),\n+                self.ident_of(\"fail_with\"),\n+            ],\n+            ~[\n+                self.expr_str(span, ~\"internal error: entered unreachable code\"),\n+                self.expr_str(span, copy loc.file.name),\n+                self.expr_uint(span, loc.line),\n+            ])\n     }\n \n-    fn lambda0(&self, blk: ast::blk) -> @ast::expr {\n+\n+    fn pat(&self, span: span, pat: ast::pat_) -> @ast::pat {\n+        @ast::pat { id: self.next_id(), node: pat, span: span }\n+    }\n+    fn pat_wild(&self, span: span) -> @ast::pat {\n+        self.pat(span, ast::pat_wild)\n+    }\n+    fn pat_lit(&self, span: span, expr: @ast::expr) -> @ast::pat {\n+        self.pat(span, ast::pat_lit(expr))\n+    }\n+    fn pat_ident(&self, span: span, ident: ast::ident) -> @ast::pat {\n+        self.pat_ident_binding_mode(span, ident, ast::bind_by_copy)\n+    }\n+\n+    fn pat_ident_binding_mode(&self,\n+                              span: span,\n+                              ident: ast::ident,\n+                              bm: ast::binding_mode) -> @ast::pat {\n+        let path = self.path_ident(span, ident);\n+        let pat = ast::pat_ident(bm, path, None);\n+        self.pat(span, pat)\n+    }\n+    fn pat_enum(&self, span: span, path: @ast::Path, subpats: ~[@ast::pat]) -> @ast::pat {\n+        let pat = ast::pat_enum(path, Some(subpats));\n+        self.pat(span, pat)\n+    }\n+    fn pat_struct(&self, span: span,\n+                  path: @ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat {\n+        let pat = ast::pat_struct(path, field_pats, false);\n+        self.pat(span, pat)\n+    }\n+\n+    fn arm(&self, _span: span, pats: ~[@ast::pat], expr: @ast::expr) -> ast::arm {\n+        ast::arm {\n+            pats: pats,\n+            guard: None,\n+            body: self.blk_expr(expr)\n+        }\n+    }\n+\n+    fn arm_unreachable(&self, span: span) -> ast::arm {\n+        self.arm(span, ~[self.pat_wild(span)], self.expr_unreachable(span))\n+    }\n+\n+    fn expr_match(&self, span: span, arg: @ast::expr, arms: ~[ast::arm]) -> @expr {\n+        self.expr(span, ast::expr_match(arg, arms))\n+    }\n+\n+    fn expr_if(&self, span: span,\n+               cond: @ast::expr, then: @ast::expr, els: Option<@ast::expr>) -> @ast::expr {\n+        let els = els.map(|x| self.expr_blk(self.blk_expr(*x)));\n+        self.expr(span, ast::expr_if(cond, self.blk_expr(then), els))\n+    }\n+\n+    fn lambda_fn_decl(&self, span: span, fn_decl: ast::fn_decl, blk: ast::blk) -> @ast::expr {\n+        self.expr(span, ast::expr_fn_block(fn_decl, blk))\n+    }\n+    fn lambda(&self, span: span, ids: ~[ast::ident], blk: ast::blk) -> @ast::expr {\n+        let fn_decl = self.fn_decl(\n+            ids.map(|id| self.arg(span, *id, self.ty_infer(span))),\n+            self.ty_infer(span));\n+\n+        self.expr(span, ast::expr_fn_block(fn_decl, blk))\n+    }\n+    fn lambda0(&self, _span: span, blk: ast::blk) -> @ast::expr {\n         let ext_cx = *self;\n         let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n-        quote_expr!( || $blk_e )\n+        quote_expr!(|| $blk_e )\n     }\n \n-    fn lambda1(&self, blk: ast::blk, ident: ast::ident) -> @ast::expr {\n+    fn lambda1(&self, _span: span, blk: ast::blk, ident: ast::ident) -> @ast::expr {\n         let ext_cx = *self;\n         let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n-        quote_expr!( |$ident| $blk_e )\n-    }\n-\n-    fn blk(&self, span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n-        codemap::spanned {\n-            node: ast::blk_ {\n-                view_items: ~[],\n-                stmts: stmts,\n-                expr: None,\n-                id: self.next_id(),\n-                rules: ast::default_blk,\n-            },\n-            span: span,\n+        quote_expr!(|$ident| $blk_e )\n+    }\n+\n+    fn lambda_expr(&self, span: span, ids: ~[ast::ident], expr: @ast::expr) -> @ast::expr {\n+        self.lambda(span, ids, self.blk_expr(expr))\n+    }\n+    fn lambda_expr_0(&self, span: span, expr: @ast::expr) -> @ast::expr {\n+        self.lambda0(span, self.blk_expr(expr))\n+    }\n+    fn lambda_expr_1(&self, span: span, expr: @ast::expr, ident: ast::ident) -> @ast::expr {\n+        self.lambda1(span, self.blk_expr(expr), ident)\n+    }\n+\n+    fn lambda_stmts(&self, span: span, ids: ~[ast::ident], stmts: ~[@ast::stmt]) -> @ast::expr {\n+        self.lambda(span, ids, self.blk(span, stmts, None))\n+    }\n+    fn lambda_stmts_0(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n+        self.lambda0(span, self.blk(span, stmts, None))\n+    }\n+    fn lambda_stmts_1(&self, span: span, stmts: ~[@ast::stmt], ident: ast::ident) -> @ast::expr {\n+        self.lambda1(span, self.blk(span, stmts, None), ident)\n+    }\n+\n+    fn arg(&self, span: span, ident: ast::ident, ty: @ast::Ty) -> ast::arg {\n+        let arg_pat = self.pat_ident(span, ident);\n+        ast::arg {\n+            is_mutbl: false,\n+            ty: ty,\n+            pat: arg_pat,\n+            id: self.next_id()\n         }\n     }\n \n-    fn expr_blk(&self, expr: @ast::expr) -> ast::blk {\n-        codemap::spanned {\n-            node: ast::blk_ {\n-                view_items: ~[],\n-                stmts: ~[],\n-                expr: Some(expr),\n-                id: self.next_id(),\n-                rules: ast::default_blk,\n-            },\n-            span: expr.span,\n+    // XXX unused self\n+    fn fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n+        ast::fn_decl {\n+            inputs: inputs,\n+            output: output,\n+            cf: ast::return_val,\n         }\n     }\n \n-    fn expr_path(&self, span: span, strs: ~[ast::ident]) -> @ast::expr {\n-        self.expr(span, ast::expr_path(self.path(span, strs)))\n+    fn item(&self, span: span,\n+            name: ident, attrs: ~[ast::attribute], node: ast::item_) -> @ast::item {\n+        // XXX: Would be nice if our generated code didn't violate\n+        // Rust coding conventions\n+        @ast::item { ident: name,\n+                    attrs: attrs,\n+                    id: self.next_id(),\n+                    node: node,\n+                    vis: ast::public,\n+                    span: span }\n     }\n \n-    fn expr_path_global(\n-        &self,\n-        span: span,\n-        strs: ~[ast::ident]\n-    ) -> @ast::expr {\n-        self.expr(span, ast::expr_path(self.path_global(span, strs)))\n+    fn item_fn_poly(&self,\n+                    span: span,\n+                    name: ident,\n+                    inputs: ~[ast::arg],\n+                    output: @ast::Ty,\n+                    generics: Generics,\n+                    body: ast::blk) -> @ast::item {\n+        self.item(span,\n+                  name,\n+                  ~[],\n+                  ast::item_fn(self.fn_decl(inputs, output),\n+                               ast::impure_fn,\n+                               AbiSet::Rust(),\n+                               generics,\n+                               body))\n+    }\n+\n+    fn item_fn(&self,\n+               span: span,\n+               name: ident,\n+               inputs: ~[ast::arg],\n+               output: @ast::Ty,\n+               body: ast::blk\n+              ) -> @ast::item {\n+        self.item_fn_poly(\n+            span,\n+            name,\n+            inputs,\n+            output,\n+            ast_util::empty_generics(),\n+            body)\n     }\n \n-    fn expr_var(&self, span: span, var: &str) -> @ast::expr {\n-        self.expr_path(span, ~[self.ident_of(var)])\n+    fn variant(&self, span: span, name: ident, tys: ~[@ast::Ty]) -> ast::variant {\n+        let args = do tys.map |ty| {\n+            ast::variant_arg { ty: *ty, id: self.next_id() }\n+        };\n+\n+        respan(span,\n+               ast::variant_ {\n+                   name: name,\n+                   attrs: ~[],\n+                   kind: ast::tuple_variant_kind(args),\n+                   id: self.next_id(),\n+                   disr_expr: None,\n+                   vis: ast::public\n+               })\n     }\n \n-    fn expr_self(&self, span: span) -> @ast::expr {\n-        self.expr(span, ast::expr_self)\n+    fn item_enum_poly(&self, span: span, name: ident,\n+                      enum_definition: ast::enum_def,\n+                      generics: Generics) -> @ast::item {\n+        self.item(span, name, ~[], ast::item_enum(enum_definition, generics))\n     }\n \n-    fn expr_field(\n-        &self,\n-        span: span,\n-        expr: @ast::expr,\n-        ident: ast::ident\n-    ) -> @ast::expr {\n-        self.expr(span, ast::expr_field(expr, ident, ~[]))\n+    fn item_enum(&self, span: span, name: ident,\n+                 enum_definition: ast::enum_def) -> @ast::item {\n+        self.item_enum_poly(span, name, enum_definition,\n+                            ast_util::empty_generics())\n     }\n \n-    fn expr_call(\n+    fn item_struct(\n         &self,\n         span: span,\n-        expr: @ast::expr,\n-        args: ~[@ast::expr]\n-    ) -> @ast::expr {\n-        self.expr(span, ast::expr_call(expr, args, ast::NoSugar))\n+        name: ident,\n+        struct_def: ast::struct_def\n+    ) -> @ast::item {\n+        self.item_struct_poly(\n+            span,\n+            name,\n+            struct_def,\n+            ast_util::empty_generics()\n+        )\n     }\n \n-    fn expr_method_call(\n+    fn item_struct_poly(\n         &self,\n         span: span,\n-        expr: @ast::expr,\n-        ident: ast::ident,\n-        args: ~[@ast::expr]\n-    ) -> @ast::expr {\n-        self.expr(span,\n-                  ast::expr_method_call(expr, ident, ~[], args, ast::NoSugar))\n+        name: ident,\n+        struct_def: ast::struct_def,\n+        generics: Generics\n+    ) -> @ast::item {\n+        self.item(span, name, ~[], ast::item_struct(@struct_def, generics))\n+    }\n+\n+    fn item_mod(&self, span: span, name: ident,\n+                attrs: ~[ast::attribute],\n+                vi: ~[@ast::view_item],\n+                items: ~[@ast::item]) -> @ast::item {\n+        self.item(\n+            span,\n+            name,\n+            attrs,\n+            ast::item_mod(ast::_mod {\n+                view_items: vi,\n+                items: items,\n+            })\n+        )\n     }\n \n-    fn lambda_expr_0(&self, expr: @ast::expr) -> @ast::expr {\n-        self.lambda0(self.expr_blk(expr))\n+    fn item_ty_poly(&self, span: span, name: ident, ty: @ast::Ty,\n+                    generics: Generics) -> @ast::item {\n+        self.item(span, name, ~[], ast::item_ty(ty, generics))\n     }\n \n-    fn lambda_expr_1(&self, expr: @ast::expr, ident: ast::ident)\n-                    -> @ast::expr {\n-        self.lambda1(self.expr_blk(expr), ident)\n+    fn item_ty(&self, span: span, name: ident, ty: @ast::Ty) -> @ast::item {\n+        self.item_ty_poly(span, name, ty, ast_util::empty_generics())\n     }\n \n-    fn lambda_stmts_0(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n-        self.lambda0(self.blk(span, stmts))\n+    fn attribute(&self, sp: span, mi: @ast::meta_item) -> ast::attribute {\n+        respan(sp,\n+               ast::attribute_ {\n+                   style: ast::attr_outer,\n+                   value: mi,\n+                   is_sugared_doc: false\n+               })\n     }\n \n-    fn lambda_stmts_1(&self,\n-                      span: span,\n-                      stmts: ~[@ast::stmt],\n-                      ident: ast::ident)\n-                      -> @ast::expr {\n-        self.lambda1(self.blk(span, stmts), ident)\n+    fn meta_word(&self, sp: span, w: ~str) -> @ast::meta_item {\n+        @respan(sp, ast::meta_word(@w))\n+    }\n+    fn meta_list(&self, sp: span, name: ~str, mis: ~[@ast::meta_item]) -> @ast::meta_item {\n+        @respan(sp, ast::meta_list(@name, mis))\n+    }\n+    fn meta_name_value(&self, sp: span, name: ~str, value: ast::lit_) -> @ast::meta_item {\n+        @respan(sp, ast::meta_name_value(@name, respan(sp, value)))\n+    }\n+\n+    fn view_use(&self, sp: span,\n+                vis: ast::visibility, vp: ~[@ast::view_path]) -> @ast::view_item {\n+        @ast::view_item {\n+            node: ast::view_item_use(vp),\n+            attrs: ~[],\n+            vis: vis,\n+            span: sp\n+        }\n+    }\n+\n+    fn view_use_list(&self, sp: span, vis: ast::visibility,\n+                     path: ~[ast::ident], imports: &[ast::ident]) -> @ast::view_item {\n+        let imports = do imports.map |id| {\n+            respan(sp, ast::path_list_ident_ { name: *id, id: self.next_id() })\n+        };\n+\n+        self.view_use(sp, vis,\n+                      ~[@respan(sp,\n+                                ast::view_path_list(self.path(sp, path),\n+                                                    imports,\n+                                                    self.next_id()))])\n+    }\n+\n+    fn view_use_glob(&self, sp: span,\n+                     vis: ast::visibility, path: ~[ast::ident]) -> @ast::view_item {\n+        self.view_use(sp, vis,\n+                      ~[@respan(sp,\n+                                ast::view_path_glob(self.path(sp, path), self.next_id()))])\n+    }\n+}\n+\n+\n+pub trait Duplicate {\n+    //\n+    // Duplication functions\n+    //\n+    // These functions just duplicate AST nodes.\n+    //\n+\n+    fn duplicate(&self, cx: @ExtCtxt) -> Self;\n+}\n+\n+impl Duplicate for @ast::expr {\n+    fn duplicate(&self, cx: @ExtCtxt) -> @ast::expr {\n+        let folder = fold::default_ast_fold();\n+        let folder = @fold::AstFoldFns {\n+            new_id: |_| cx.next_id(),\n+            ..*folder\n+        };\n+        let folder = fold::make_fold(folder);\n+        folder.fold_expr(*self)\n     }\n }"}, {"sha": "a046395b6f5c8009047cb7b85eac291d2ee09ece", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -14,9 +14,9 @@ use ast;\n use codemap::span;\n use ext::base::*;\n use ext::base;\n-use ext::build::{mk_u8, mk_slice_vec_e};\n+use ext::build::AstBuilder;\n \n-pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree]) -> base::MacResult {\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> base::MacResult {\n     // Gather all argument expressions\n     let exprs = get_exprs_from_tts(cx, tts);\n     let mut bytes = ~[];\n@@ -28,7 +28,7 @@ pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree]) -> ba\n                 // string literal, push each byte to vector expression\n                 ast::lit_str(s) => {\n                     for s.each |byte| {\n-                        bytes.push(mk_u8(cx, sp, byte));\n+                        bytes.push(cx.expr_u8(sp, byte));\n                     }\n                 }\n \n@@ -37,7 +37,7 @@ pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree]) -> ba\n                     if v > 0xFF {\n                         cx.span_err(sp, \"Too large u8 literal in bytes!\")\n                     } else {\n-                        bytes.push(mk_u8(cx, sp, v as u8));\n+                        bytes.push(cx.expr_u8(sp, v as u8));\n                     }\n                 }\n \n@@ -48,14 +48,14 @@ pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree]) -> ba\n                     } else if v < 0 {\n                         cx.span_err(sp, \"Negative integer literal in bytes!\")\n                     } else {\n-                        bytes.push(mk_u8(cx, sp, v as u8));\n+                        bytes.push(cx.expr_u8(sp, v as u8));\n                     }\n                 }\n \n                 // char literal, push to vector expression\n                 ast::lit_int(v, ast::ty_char) => {\n                     if (v as char).is_ascii() {\n-                        bytes.push(mk_u8(cx, sp, v as u8));\n+                        bytes.push(cx.expr_u8(sp, v as u8));\n                     } else {\n                         cx.span_err(sp, \"Non-ascii char literal in bytes!\")\n                     }\n@@ -68,6 +68,6 @@ pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree]) -> ba\n         }\n     }\n \n-    let e = mk_slice_vec_e(cx, sp, bytes);\n+    let e = cx.expr_vec_slice(sp, bytes);\n     MRExpr(e)\n }"}, {"sha": "e6600e198fa6d6ce8fb84c61088375a004e2155b", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -14,7 +14,7 @@ use ext::base::*;\n use ext::base;\n use parse::token;\n \n-pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let mut res_str = ~\"\";\n     for tts.eachi |i, e| {"}, {"sha": "007826a84165d4232a35c756574a9fbf838e9db8", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -10,23 +10,23 @@\n \n use ast::{meta_item, item, expr};\n use codemap::span;\n-use ext::base::ext_ctxt;\n-use ext::build;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n \n-pub fn expand_deriving_clone(cx: @ext_ctxt,\n+pub fn expand_deriving_clone(cx: @ExtCtxt,\n                              span: span,\n                              mitem: @meta_item,\n                              in_items: ~[@item])\n                           -> ~[@item] {\n     let trait_def = TraitDef {\n-        path: Path::new(~[~\"core\", ~\"clone\", ~\"Clone\"]),\n+        path: Path::new(~[\"core\", \"clone\", \"Clone\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n         methods: ~[\n             MethodDef {\n-                name: ~\"clone\",\n+                name: \"clone\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n                 args: ~[],\n@@ -42,18 +42,18 @@ pub fn expand_deriving_clone(cx: @ext_ctxt,\n                             &trait_def)\n }\n \n-pub fn expand_deriving_deep_clone(cx: @ext_ctxt,\n+pub fn expand_deriving_deep_clone(cx: @ExtCtxt,\n                                  span: span,\n                                  mitem: @meta_item,\n                                  in_items: ~[@item])\n     -> ~[@item] {\n     let trait_def = TraitDef {\n-        path: Path::new(~[~\"core\", ~\"clone\", ~\"DeepClone\"]),\n+        path: Path::new(~[\"core\", \"clone\", \"DeepClone\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n         methods: ~[\n             MethodDef {\n-                name: ~\"deep_clone\",\n+                name: \"deep_clone\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n                 args: ~[],\n@@ -73,21 +73,21 @@ pub fn expand_deriving_deep_clone(cx: @ext_ctxt,\n \n fn cs_clone(\n     name: &str,\n-    cx: @ext_ctxt, span: span,\n+    cx: @ExtCtxt, span: span,\n     substr: &Substructure) -> @expr {\n     let clone_ident = substr.method_ident;\n     let ctor_ident;\n     let all_fields;\n     let subcall = |field|\n-        build::mk_method_call(cx, span, field, clone_ident, ~[]);\n+        cx.expr_method_call(span, field, clone_ident, ~[]);\n \n     match *substr.fields {\n         Struct(ref af) => {\n-            ctor_ident = ~[ substr.type_ident ];\n+            ctor_ident = substr.type_ident;\n             all_fields = af;\n         }\n         EnumMatching(_, variant, ref af) => {\n-            ctor_ident = ~[ variant.node.name ];\n+            ctor_ident = variant.node.name;\n             all_fields = af;\n         },\n         EnumNonMatching(*) => cx.span_bug(span,\n@@ -102,7 +102,7 @@ fn cs_clone(\n         [(None, _, _), .. _] => {\n             // enum-like\n             let subcalls = all_fields.map(|&(_, self_f, _)| subcall(self_f));\n-            build::mk_call(cx, span, ctor_ident, subcalls)\n+            cx.expr_call_ident(span, ctor_ident, subcalls)\n         },\n         _ => {\n             // struct-like\n@@ -113,16 +113,14 @@ fn cs_clone(\n                                         fmt!(\"unnamed field in normal struct in `deriving(%s)`\",\n                                              name))\n                 };\n-                build::Field { ident: ident, ex: subcall(self_f) }\n+                cx.field_imm(span, ident, subcall(self_f))\n             };\n \n             if fields.is_empty() {\n                 // no fields, so construct like `None`\n-                build::mk_path(cx, span, ctor_ident)\n+                cx.expr_ident(span, ctor_ident)\n             } else {\n-                build::mk_struct_e(cx, span,\n-                                   ctor_ident,\n-                                   fields)\n+                cx.expr_struct_ident(span, ctor_ident, fields)\n             }\n         }\n     }"}, {"sha": "11c0a597cebab1169c3104d0fd4e7c3d6f3c041e", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -10,22 +10,22 @@\n \n use ast::{meta_item, item, expr};\n use codemap::span;\n-use ext::base::ext_ctxt;\n-use ext::build;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_eq(cx: @ext_ctxt,\n+pub fn expand_deriving_eq(cx: @ExtCtxt,\n                           span: span,\n                           mitem: @meta_item,\n                           in_items: ~[@item]) -> ~[@item] {\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n-    fn cs_eq(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n-        cs_and(|cx, span, _, _| build::mk_bool(cx, span, false),\n+    fn cs_eq(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n+        cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n                                  cx, span, substr)\n     }\n-    fn cs_ne(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n-        cs_or(|cx, span, _, _| build::mk_bool(cx, span, true),\n+    fn cs_ne(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n+        cs_or(|cx, span, _, _| cx.expr_bool(span, true),\n               cx, span, substr)\n     }\n \n@@ -36,20 +36,20 @@ pub fn expand_deriving_eq(cx: @ext_ctxt,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n                 args: ~[borrowed_self()],\n-                ret_ty: Literal(Path::new(~[~\"bool\"])),\n+                ret_ty: Literal(Path::new(~[\"bool\"])),\n                 const_nonmatching: true,\n                 combine_substructure: $f\n             },\n         }\n     );\n \n     let trait_def = TraitDef {\n-        path: Path::new(~[~\"core\", ~\"cmp\", ~\"Eq\"]),\n+        path: Path::new(~[\"core\", \"cmp\", \"Eq\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n         methods: ~[\n-            md!(~\"eq\", cs_eq),\n-            md!(~\"ne\", cs_ne)\n+            md!(\"eq\", cs_eq),\n+            md!(\"ne\", cs_ne)\n         ]\n     };\n "}, {"sha": "9438e1b0f858d2f1a489d00d3f8da41b4539c583", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n \n-use ast::{meta_item, item, expr_if, expr};\n+use ast::{meta_item, item, expr};\n use codemap::span;\n-use ext::base::ext_ctxt;\n-use ext::build;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_ord(cx: @ext_ctxt,\n+pub fn expand_deriving_ord(cx: @ExtCtxt,\n                            span: span,\n                            mitem: @meta_item,\n                            in_items: ~[@item]) -> ~[@item] {\n@@ -26,7 +26,7 @@ pub fn expand_deriving_ord(cx: @ext_ctxt,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n                 args: ~[borrowed_self()],\n-                ret_ty: Literal(Path::new(~[~\"bool\"])),\n+                ret_ty: Literal(Path::new(~[\"bool\"])),\n                 const_nonmatching: false,\n                 combine_substructure: |cx, span, substr|\n                     cs_ord($less, $equal, cx, span, substr)\n@@ -37,15 +37,15 @@ pub fn expand_deriving_ord(cx: @ext_ctxt,\n \n \n     let trait_def = TraitDef {\n-        path: Path::new(~[~\"core\", ~\"cmp\", ~\"Ord\"]),\n+        path: Path::new(~[\"core\", \"cmp\", \"Ord\"]),\n         // XXX: Ord doesn't imply Eq yet\n-        additional_bounds: ~[Literal(Path::new(~[~\"core\", ~\"cmp\", ~\"Eq\"]))],\n+        additional_bounds: ~[Literal(Path::new(~[\"core\", \"cmp\", \"Eq\"]))],\n         generics: LifetimeBounds::empty(),\n         methods: ~[\n-            md!(~\"lt\", true,  false),\n-            md!(~\"le\", true,  true),\n-            md!(~\"gt\", false, false),\n-            md!(~\"ge\", false, true)\n+            md!(\"lt\", true,  false),\n+            md!(\"le\", true,  true),\n+            md!(\"gt\", false, false),\n+            md!(\"ge\", false, true)\n         ]\n     };\n \n@@ -55,17 +55,14 @@ pub fn expand_deriving_ord(cx: @ext_ctxt,\n \n /// `less`: is this `lt` or `le`? `equal`: is this `le` or `ge`?\n fn cs_ord(less: bool, equal: bool,\n-          cx: @ext_ctxt, span: span,\n+          cx: @ExtCtxt, span: span,\n           substr: &Substructure) -> @expr {\n     let binop = if less {\n         cx.ident_of(\"lt\")\n     } else {\n         cx.ident_of(\"gt\")\n     };\n-    let false_blk_expr = build::mk_block(cx, span,\n-                                         ~[], ~[],\n-                                         Some(build::mk_bool(cx, span, false)));\n-    let base = build::mk_bool(cx, span, equal);\n+    let base = cx.expr_bool(span, equal);\n \n     cs_fold(\n         false, // need foldr,\n@@ -98,19 +95,15 @@ fn cs_ord(less: bool, equal: bool,\n                 cx.span_bug(span, \"Not exactly 2 arguments in `deriving(Ord)`\");\n             }\n \n-            let cmp = build::mk_method_call(cx, span,\n-                                            self_f, cx.ident_of(\"eq\"), other_fs.to_owned());\n-            let subexpr = build::mk_simple_block(cx, span, subexpr);\n-            let elseif = expr_if(cmp, subexpr, Some(false_blk_expr));\n-            let elseif = build::mk_expr(cx, span, elseif);\n+            let cmp = cx.expr_method_call(span,\n+                                          self_f, cx.ident_of(\"eq\"), other_fs.to_owned());\n+            let elseif = cx.expr_if(span, cmp,\n+                                    subexpr, Some(cx.expr_bool(span, false)));\n \n-            let cmp = build::mk_method_call(cx, span,\n-                                            self_f, binop, other_fs.to_owned());\n-            let true_blk = build::mk_simple_block(cx, span,\n-                                                  build::mk_bool(cx, span, true));\n-            let if_ = expr_if(cmp, true_blk, Some(elseif));\n-\n-            build::mk_expr(cx, span, if_)\n+            let cmp = cx.expr_method_call(span,\n+                                          self_f, binop, other_fs.to_owned());\n+            cx.expr_if(span, cmp,\n+                        cx.expr_bool(span, true), Some(elseif))\n         },\n         base,\n         |cx, span, args, _| {\n@@ -119,7 +112,7 @@ fn cs_ord(less: bool, equal: bool,\n             match args {\n                 [(self_var, _, _),\n                  (other_var, _, _)] =>\n-                    build::mk_bool(cx, span,\n+                    cx.expr_bool(span,\n                                    if less {\n                                        self_var < other_var\n                                    } else {"}, {"sha": "f1e952eb5f63c98c76bc2ab048d0b748447ec47c", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -11,31 +11,31 @@\n \n use ast::{meta_item, item, expr};\n use codemap::span;\n-use ext::base::ext_ctxt;\n-use ext::build;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_totaleq(cx: @ext_ctxt,\n+pub fn expand_deriving_totaleq(cx: @ExtCtxt,\n                           span: span,\n                           mitem: @meta_item,\n                           in_items: ~[@item]) -> ~[@item] {\n \n-    fn cs_equals(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n-        cs_and(|cx, span, _, _| build::mk_bool(cx, span, false),\n+    fn cs_equals(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n+        cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n                cx, span, substr)\n     }\n \n     let trait_def = TraitDef {\n-        path: Path::new(~[~\"core\", ~\"cmp\", ~\"TotalEq\"]),\n+        path: Path::new(~[\"core\", \"cmp\", \"TotalEq\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n         methods: ~[\n             MethodDef {\n-                name: ~\"equals\",\n+                name: \"equals\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n                 args: ~[borrowed_self()],\n-                ret_ty: Literal(Path::new(~[~\"bool\"])),\n+                ret_ty: Literal(Path::new(~[\"bool\"])),\n                 const_nonmatching: true,\n                 combine_substructure: cs_equals\n             }"}, {"sha": "e26f4a34304cb19fba162b89c312a963e1459575", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -10,26 +10,26 @@\n \n use ast::{meta_item, item, expr};\n use codemap::span;\n-use ext::base::ext_ctxt;\n-use ext::build;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use core::cmp::{Ordering, Equal, Less, Greater};\n \n-pub fn expand_deriving_totalord(cx: @ext_ctxt,\n+pub fn expand_deriving_totalord(cx: @ExtCtxt,\n                                 span: span,\n                                 mitem: @meta_item,\n                                 in_items: ~[@item]) -> ~[@item] {\n     let trait_def = TraitDef {\n-        path: Path::new(~[~\"core\", ~\"cmp\", ~\"TotalOrd\"]),\n+        path: Path::new(~[\"core\", \"cmp\", \"TotalOrd\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n         methods: ~[\n             MethodDef {\n-                name: ~\"cmp\",\n+                name: \"cmp\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n                 args: ~[borrowed_self()],\n-                ret_ty: Literal(Path::new(~[~\"core\", ~\"cmp\", ~\"Ordering\"])),\n+                ret_ty: Literal(Path::new(~[\"core\", \"cmp\", \"Ordering\"])),\n                 const_nonmatching: false,\n                 combine_substructure: cs_cmp\n             }\n@@ -41,30 +41,31 @@ pub fn expand_deriving_totalord(cx: @ext_ctxt,\n }\n \n \n-pub fn ordering_const(cx: @ext_ctxt, span: span, cnst: Ordering) -> @expr {\n+pub fn ordering_const(cx: @ExtCtxt, span: span, cnst: Ordering) -> @expr {\n     let cnst = match cnst {\n         Less => \"Less\",\n         Equal => \"Equal\",\n         Greater => \"Greater\"\n     };\n-    build::mk_path_global(cx, span,\n-                          ~[cx.ident_of(\"core\"),\n-                            cx.ident_of(\"cmp\"),\n-                            cx.ident_of(cnst)])\n+    cx.expr_path(\n+        cx.path_global(span,\n+                       ~[cx.ident_of(\"core\"),\n+                         cx.ident_of(\"cmp\"),\n+                         cx.ident_of(cnst)]))\n }\n \n-pub fn cs_cmp(cx: @ext_ctxt, span: span,\n+pub fn cs_cmp(cx: @ExtCtxt, span: span,\n               substr: &Substructure) -> @expr {\n \n     cs_same_method_fold(\n         // foldr (possibly) nests the matches in lexical_ordering better\n         false,\n         |cx, span, old, new| {\n-            build::mk_call_global(cx, span,\n-                                  ~[cx.ident_of(\"core\"),\n-                                    cx.ident_of(\"cmp\"),\n-                                    cx.ident_of(\"lexical_ordering\")],\n-                                  ~[old, new])\n+            cx.expr_call_global(span,\n+                                ~[cx.ident_of(\"core\"),\n+                                  cx.ident_of(\"cmp\"),\n+                                  cx.ident_of(\"lexical_ordering\")],\n+                                ~[old, new])\n         },\n         ordering_const(cx, span, Equal),\n         |cx, span, list, _| {"}, {"sha": "a8c84e8e361e566804098584a3e7c43d90beb51c", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 87, "deletions": 165, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -15,15 +15,15 @@ encodable.rs for more.\n \n use ast;\n use ast::*;\n-use ext::base::ext_ctxt;\n-use ext::build;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n use ext::deriving::*;\n use codemap::{span, spanned};\n use ast_util;\n use opt_vec;\n \n pub fn expand_deriving_decodable(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     _mitem: @meta_item,\n     in_items: ~[@item]\n@@ -38,42 +38,39 @@ pub fn expand_deriving_decodable(\n }\n \n fn create_derived_decodable_impl(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     type_ident: ident,\n     generics: &Generics,\n     method: @method\n ) -> @item {\n-    let decoder_ty_param = build::mk_ty_param(\n-        cx,\n+    let decoder_ty_param = cx.typaram(\n         cx.ident_of(\"__D\"),\n         @opt_vec::with(\n-            build::mk_trait_ty_param_bound_global(\n-                cx,\n-                span,\n-                ~[\n-                    cx.ident_of(\"std\"),\n-                    cx.ident_of(\"serialize\"),\n-                    cx.ident_of(\"Decoder\"),\n-                ]\n-            )\n-        )\n-    );\n+            cx.typarambound(\n+                cx.path_global(\n+                    span,\n+                    ~[\n+                        cx.ident_of(\"std\"),\n+                        cx.ident_of(\"serialize\"),\n+                        cx.ident_of(\"Decoder\"),\n+                    ]))));\n \n     // All the type parameters need to bound to the trait.\n     let generic_ty_params = opt_vec::with(decoder_ty_param);\n \n     let methods = [method];\n-    let trait_path = build::mk_raw_path_global_(\n+    let trait_path = cx.path_all(\n         span,\n+        true,\n         ~[\n             cx.ident_of(\"std\"),\n             cx.ident_of(\"serialize\"),\n             cx.ident_of(\"Decodable\")\n         ],\n         None,\n         ~[\n-            build::mk_simple_ty_path(cx, span, cx.ident_of(\"__D\"))\n+            cx.ty_ident(span, cx.ident_of(\"__D\"))\n         ]\n     );\n     create_derived_impl(\n@@ -91,22 +88,21 @@ fn create_derived_decodable_impl(\n // Creates a method from the given set of statements conforming to the\n // signature of the `decodable` method.\n fn create_decode_method(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     type_ident: ast::ident,\n     generics: &Generics,\n     expr: @ast::expr\n ) -> @method {\n     // Create the `e` parameter.\n-    let d_arg_type = build::mk_ty_rptr(\n-        cx,\n+    let d_arg_type = cx.ty_rptr(\n         span,\n-        build::mk_simple_ty_path(cx, span, cx.ident_of(\"__D\")),\n+        cx.ty_ident(span, cx.ident_of(\"__D\")),\n         None,\n         ast::m_mutbl\n     );\n     let d_ident = cx.ident_of(\"__d\");\n-    let d_arg = build::mk_arg(cx, span, d_ident, d_arg_type);\n+    let d_arg = cx.arg(span, d_ident, d_arg_type);\n \n     // Create the type of the return value.\n     let output_type = create_self_type_with_params(\n@@ -118,10 +114,10 @@ fn create_decode_method(\n \n     // Create the function declaration.\n     let inputs = ~[d_arg];\n-    let fn_decl = build::mk_fn_decl(inputs, output_type);\n+    let fn_decl = cx.fn_decl(inputs, output_type);\n \n     // Create the body block.\n-    let body_block = build::mk_simple_block(cx, span, expr);\n+    let body_block = cx.blk_expr(expr);\n \n     // Create the method.\n     let explicit_self = spanned { node: sty_static, span: span };\n@@ -142,31 +138,31 @@ fn create_decode_method(\n }\n \n fn call_substructure_decode_method(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span\n ) -> @ast::expr {\n     // Call the substructure method.\n-    build::mk_call_(\n-        cx,\n+    cx.expr_call(\n         span,\n-        build::mk_path_global(\n-            cx,\n-            span,\n-            ~[\n-                cx.ident_of(\"std\"),\n-                cx.ident_of(\"serialize\"),\n-                cx.ident_of(\"Decodable\"),\n-                cx.ident_of(\"decode\"),\n-            ]\n+        cx.expr_path(\n+            cx.path_global(\n+                span,\n+                ~[\n+                    cx.ident_of(\"std\"),\n+                    cx.ident_of(\"serialize\"),\n+                    cx.ident_of(\"Decodable\"),\n+                    cx.ident_of(\"decode\"),\n+                ]\n+            )\n         ),\n         ~[\n-            build::mk_path(cx, span, ~[cx.ident_of(\"__d\")])\n+            cx.expr_ident(span, cx.ident_of(\"__d\"))\n         ]\n     )\n }\n \n fn expand_deriving_decodable_struct_def(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     struct_def: &struct_def,\n     type_ident: ident,\n@@ -192,7 +188,7 @@ fn expand_deriving_decodable_struct_def(\n }\n \n fn expand_deriving_decodable_enum_def(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     enum_definition: &enum_def,\n     type_ident: ident,\n@@ -218,63 +214,54 @@ fn expand_deriving_decodable_enum_def(\n }\n \n fn create_read_struct_field(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     idx: uint,\n     ident: ident\n-) -> build::Field {\n+) -> ast::field {\n     // Call the substructure method.\n     let decode_expr = call_substructure_decode_method(cx, span);\n \n-    let d_arg = build::mk_arg(cx,\n-                              span,\n-                              cx.ident_of(\"__d\"),\n-                              build::mk_ty_infer(cx, span));\n+    let d_id = cx.ident_of(\"__d\");\n \n-    let call_expr = build::mk_method_call(\n-        cx,\n+    let call_expr = cx.expr_method_call(\n         span,\n-        build::mk_path(cx, span, ~[cx.ident_of(\"__d\")]),\n+        cx.expr_ident(span, d_id),\n         cx.ident_of(\"read_struct_field\"),\n         ~[\n-            build::mk_base_str(cx, span, cx.str_of(ident)),\n-            build::mk_uint(cx, span, idx),\n-            build::mk_lambda(cx,\n-                             span,\n-                             build::mk_fn_decl(~[d_arg],\n-                                               build::mk_ty_infer(cx, span)),\n-                             decode_expr),\n+            cx.expr_str(span, cx.str_of(ident)),\n+            cx.expr_uint(span, idx),\n+            cx.lambda_expr_1(span, decode_expr, d_id)\n         ]\n     );\n \n-    build::Field { ident: ident, ex: call_expr }\n+    cx.field_imm(span, ident, call_expr)\n }\n \n fn create_read_struct_arg(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     idx: uint,\n     ident: ident\n-) -> build::Field {\n+) -> ast::field {\n     // Call the substructure method.\n     let decode_expr = call_substructure_decode_method(cx, span);\n \n-    let call_expr = build::mk_method_call(\n-        cx,\n+    let call_expr = cx.expr_method_call(\n         span,\n-        build::mk_path(cx, span, ~[cx.ident_of(\"__d\")]),\n+        cx.expr_ident(span, cx.ident_of(\"__d\")),\n         cx.ident_of(\"read_struct_arg\"),\n         ~[\n-            build::mk_uint(cx, span, idx),\n-            build::mk_lambda_no_args(cx, span, decode_expr),\n+            cx.expr_uint(span, idx),\n+            cx.lambda_expr_0(span, decode_expr),\n         ]\n     );\n \n-    build::Field { ident: ident, ex: call_expr }\n+    cx.field_imm(span, ident, call_expr)\n }\n \n fn expand_deriving_decodable_struct_method(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     struct_def: &struct_def,\n     type_ident: ident,\n@@ -298,34 +285,19 @@ fn expand_deriving_decodable_struct_method(\n         i += 1;\n     }\n \n-    let d_arg = build::mk_arg(cx,\n-                              span,\n-                              cx.ident_of(\"__d\"),\n-                              build::mk_ty_infer(cx, span));\n+    let d_id = cx.ident_of(\"__d\");\n \n-    let read_struct_expr = build::mk_method_call(\n-        cx,\n+    let read_struct_expr = cx.expr_method_call(\n         span,\n-        build::mk_path(\n-            cx,\n-            span,\n-            ~[cx.ident_of(\"__d\")]\n-        ),\n+        cx.expr_ident(span, d_id),\n         cx.ident_of(\"read_struct\"),\n         ~[\n-            build::mk_base_str(cx, span, cx.str_of(type_ident)),\n-            build::mk_uint(cx, span, fields.len()),\n-            build::mk_lambda(\n-                cx,\n+            cx.expr_str(span, cx.str_of(type_ident)),\n+            cx.expr_uint(span, fields.len()),\n+            cx.lambda_expr_1(\n                 span,\n-                build::mk_fn_decl(~[d_arg], build::mk_ty_infer(cx, span)),\n-                build::mk_struct_e(\n-                    cx,\n-                    span,\n-                    ~[type_ident],\n-                    fields\n-                )\n-            ),\n+                cx.expr_struct_ident(span, type_ident, fields),\n+                d_id)\n         ]\n     );\n \n@@ -334,20 +306,20 @@ fn expand_deriving_decodable_struct_method(\n }\n \n fn create_read_variant_arg(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     idx: uint,\n     variant: &ast::variant\n ) -> ast::arm {\n     // Create the matching pattern.\n-    let pat = build::mk_pat_lit(cx, span, build::mk_uint(cx, span, idx));\n+    let pat = cx.pat_lit(span, cx.expr_uint(span, idx));\n \n     // Feed each argument in this variant to the decode function\n     // as well.\n     let variant_arg_len = variant_arg_count(cx, span, variant);\n \n     let expr = if variant_arg_len == 0 {\n-        build::mk_path(cx, span, ~[variant.node.name])\n+        cx.expr_ident(span, variant.node.name)\n     } else {\n         // Feed the discriminant to the decode function.\n         let mut args = ~[];\n@@ -356,53 +328,38 @@ fn create_read_variant_arg(\n             // Call the substructure method.\n             let expr = call_substructure_decode_method(cx, span);\n \n-            let d_arg = build::mk_arg(cx,\n-                                      span,\n-                                      cx.ident_of(\"__d\"),\n-                                      build::mk_ty_infer(cx, span));\n-            let t_infer = build::mk_ty_infer(cx, span);\n+            let d_id = cx.ident_of(\"__d\");\n \n-            let call_expr = build::mk_method_call(\n-                cx,\n+            let call_expr = cx.expr_method_call(\n                 span,\n-                build::mk_path(cx, span, ~[cx.ident_of(\"__d\")]),\n+                cx.expr_ident(span, d_id),\n                 cx.ident_of(\"read_enum_variant_arg\"),\n                 ~[\n-                    build::mk_uint(cx, span, j),\n-                    build::mk_lambda(cx,\n-                                     span,\n-                                     build::mk_fn_decl(~[d_arg], t_infer),\n-                                     expr),\n+                    cx.expr_uint(span, j),\n+                    cx.lambda_expr_1(span, expr, d_id),\n                 ]\n             );\n \n             args.push(call_expr);\n         }\n \n-        build::mk_call(\n-            cx,\n-            span,\n-            ~[variant.node.name],\n-            args\n-        )\n+        cx.expr_call_ident(span, variant.node.name, args)\n     };\n \n     // Create the arm.\n-    build::mk_arm(cx, span, ~[pat], expr)\n+    cx.arm(span, ~[pat], expr)\n }\n \n fn create_read_enum_variant(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     enum_definition: &enum_def\n ) -> @expr {\n     // Create a vector that contains all the variant names.\n-    let expr_arm_names = build::mk_base_vec_e(\n-        cx,\n+    let expr_arm_names = cx.expr_vec(\n         span,\n         do enum_definition.variants.map |variant| {\n-            build::mk_base_str(\n-                cx,\n+            cx.expr_str(\n                 span,\n                 cx.str_of(variant.node.name)\n             )\n@@ -415,51 +372,24 @@ fn create_read_enum_variant(\n     };\n \n     // Add the impossible case arm.\n-    arms.push(build::mk_unreachable_arm(cx, span));\n+    arms.push(cx.arm_unreachable(span));\n \n     // Create the read_enum_variant expression.\n-    build::mk_method_call(\n-        cx,\n+    cx.expr_method_call(\n         span,\n-        build::mk_path(cx, span, ~[cx.ident_of(\"__d\")]),\n+        cx.expr_ident(span, cx.ident_of(\"__d\")),\n         cx.ident_of(\"read_enum_variant\"),\n         ~[\n             expr_arm_names,\n-            build::mk_lambda(\n-                cx,\n-                span,\n-                build::mk_fn_decl(\n-                    ~[\n-                        build::mk_arg(\n-                            cx,\n-                            span,\n-                            cx.ident_of(\"__d\"),\n-                            build::mk_ty_infer(cx, span)\n-                        ),\n-                        build::mk_arg(\n-                            cx,\n-                            span,\n-                            cx.ident_of(\"__i\"),\n-                            build::mk_ty_infer(cx, span)\n-                        )\n-                    ],\n-                    build::mk_ty_infer(cx, span)\n-                ),\n-                build::mk_expr(\n-                    cx,\n-                    span,\n-                    ast::expr_match(\n-                        build::mk_path(cx, span, ~[cx.ident_of(\"__i\")]),\n-                        arms\n-                    )\n-                )\n-            )\n+            cx.lambda_expr(span,\n+                           ~[cx.ident_of(\"__d\"), cx.ident_of(\"__i\")],\n+                           cx.expr_match(span, cx.expr_ident(span, cx.ident_of(\"__i\")), arms))\n         ]\n     )\n }\n \n fn expand_deriving_decodable_enum_method(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     enum_definition: &enum_def,\n     type_ident: ast::ident,\n@@ -471,24 +401,16 @@ fn expand_deriving_decodable_enum_method(\n         enum_definition\n     );\n \n-    let d_arg = build::mk_arg(cx,\n-                              span,\n-                              cx.ident_of(\"__d\"),\n-                              build::mk_ty_infer(cx, span));\n+    let d_id = cx.ident_of(\"__d\");\n \n     // Create the read_enum expression\n-    let read_enum_expr = build::mk_method_call(\n-        cx,\n+    let read_enum_expr = cx.expr_method_call(\n         span,\n-        build::mk_path(cx, span, ~[cx.ident_of(\"__d\")]),\n+        cx.expr_ident(span, d_id),\n         cx.ident_of(\"read_enum\"),\n         ~[\n-            build::mk_base_str(cx, span, cx.str_of(type_ident)),\n-            build::mk_lambda(cx,\n-                             span,\n-                             build::mk_fn_decl(~[d_arg],\n-                                               build::mk_ty_infer(cx, span)),\n-                             read_enum_variant_expr),\n+            cx.expr_str(span, cx.str_of(type_ident)),\n+            cx.lambda_expr_1(span, read_enum_variant_expr, d_id)\n         ]\n     );\n "}, {"sha": "72a1745f902beefcd79e38e00fc6f83b65c9f705", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 68, "deletions": 132, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -78,15 +78,15 @@ would yield functions like:\n \n use ast;\n use ast::*;\n-use ext::base::ext_ctxt;\n-use ext::build;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n use ext::deriving::*;\n use codemap::{span, spanned};\n use ast_util;\n use opt_vec;\n \n pub fn expand_deriving_encodable(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     _mitem: @meta_item,\n     in_items: ~[@item]\n@@ -101,42 +101,39 @@ pub fn expand_deriving_encodable(\n }\n \n fn create_derived_encodable_impl(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     type_ident: ident,\n     generics: &Generics,\n     method: @method\n ) -> @item {\n-    let encoder_ty_param = build::mk_ty_param(\n-        cx,\n+    let encoder_ty_param = cx.typaram(\n         cx.ident_of(\"__E\"),\n         @opt_vec::with(\n-            build::mk_trait_ty_param_bound_global(\n-                cx,\n-                span,\n-                ~[\n-                    cx.ident_of(\"std\"),\n-                    cx.ident_of(\"serialize\"),\n-                    cx.ident_of(\"Encoder\"),\n-                ]\n-            )\n-        )\n-    );\n+            cx.typarambound(\n+                cx.path_global(\n+                    span,\n+                    ~[\n+                        cx.ident_of(\"std\"),\n+                        cx.ident_of(\"serialize\"),\n+                        cx.ident_of(\"Encoder\"),\n+                    ]))));\n \n     // All the type parameters need to bound to the trait.\n     let generic_ty_params = opt_vec::with(encoder_ty_param);\n \n     let methods = [method];\n-    let trait_path = build::mk_raw_path_global_(\n+    let trait_path = cx.path_all(\n         span,\n+        true,\n         ~[\n             cx.ident_of(\"std\"),\n             cx.ident_of(\"serialize\"),\n             cx.ident_of(\"Encodable\")\n         ],\n         None,\n         ~[\n-            build::mk_simple_ty_path(cx, span, cx.ident_of(\"__E\"))\n+            cx.ty_ident(span, cx.ident_of(\"__E\"))\n         ]\n     );\n     create_derived_impl(\n@@ -154,29 +151,28 @@ fn create_derived_encodable_impl(\n // Creates a method from the given set of statements conforming to the\n // signature of the `encodable` method.\n fn create_encode_method(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     statements: ~[@stmt]\n ) -> @method {\n     // Create the `e` parameter.\n-    let e_arg_type = build::mk_ty_rptr(\n-        cx,\n+    let e_arg_type = cx.ty_rptr(\n         span,\n-        build::mk_simple_ty_path(cx, span, cx.ident_of(\"__E\")),\n+        cx.ty_ident(span, cx.ident_of(\"__E\")),\n         None,\n         ast::m_mutbl\n     );\n-    let e_arg = build::mk_arg(cx, span, cx.ident_of(\"__e\"), e_arg_type);\n+    let e_arg = cx.arg(span, cx.ident_of(\"__e\"), e_arg_type);\n \n     // Create the type of the return value.\n-    let output_type = @ast::Ty { id: cx.next_id(), node: ty_nil, span: span };\n+    let output_type = cx.ty_nil();\n \n     // Create the function declaration.\n     let inputs = ~[e_arg];\n-    let fn_decl = build::mk_fn_decl(inputs, output_type);\n+    let fn_decl = cx.fn_decl(inputs, output_type);\n \n     // Create the body block.\n-    let body_block = build::mk_block_(cx, span, statements);\n+    let body_block = cx.blk(span, statements, None);\n \n     // Create the method.\n     let explicit_self = spanned { node: sty_region(None, m_imm), span: span };\n@@ -197,18 +193,17 @@ fn create_encode_method(\n }\n \n fn call_substructure_encode_method(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     self_field: @expr\n ) -> @ast::expr {\n     // Gather up the parameters we want to chain along.\n     let e_ident = cx.ident_of(\"__e\");\n-    let e_expr = build::mk_path(cx, span, ~[e_ident]);\n+    let e_expr = cx.expr_ident(span, e_ident);\n \n     // Call the substructure method.\n     let encode_ident = cx.ident_of(\"encode\");\n-    build::mk_method_call(\n-        cx,\n+    cx.expr_method_call(\n         span,\n         self_field,\n         encode_ident,\n@@ -217,7 +212,7 @@ fn call_substructure_encode_method(\n }\n \n fn expand_deriving_encodable_struct_def(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     struct_def: &struct_def,\n     type_ident: ident,\n@@ -242,7 +237,7 @@ fn expand_deriving_encodable_struct_def(\n }\n \n fn expand_deriving_encodable_enum_def(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     enum_definition: &enum_def,\n     type_ident: ident,\n@@ -267,7 +262,7 @@ fn expand_deriving_encodable_enum_def(\n }\n \n fn expand_deriving_encodable_struct_method(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     type_ident: ident,\n     struct_def: &struct_def\n@@ -279,10 +274,9 @@ fn expand_deriving_encodable_struct_method(\n         match struct_field.node.kind {\n             named_field(ident, _) => {\n                 // Create the accessor for this field.\n-                let self_field = build::mk_access_(cx,\n-                                                   span,\n-                                                   build::make_self(cx, span),\n-                                                   ident);\n+                let self_field = cx.expr_field_access(span,\n+                                                      cx.expr_self(span),\n+                                                      ident);\n \n                 // Call the substructure method.\n                 let encode_expr = call_substructure_encode_method(\n@@ -292,31 +286,19 @@ fn expand_deriving_encodable_struct_method(\n                 );\n \n                 let e_ident = cx.ident_of(\"__e\");\n-                let e_arg = build::mk_arg(cx,\n-                                          span,\n-                                          e_ident,\n-                                          build::mk_ty_infer(cx, span));\n \n-                let blk_expr = build::mk_lambda(\n-                    cx,\n+                let call_expr = cx.expr_method_call(\n                     span,\n-                    build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n-                    encode_expr\n-                );\n-\n-                let call_expr = build::mk_method_call(\n-                    cx,\n-                    span,\n-                    build::mk_path(cx, span, ~[cx.ident_of(\"__e\")]),\n+                    cx.expr_ident(span, e_ident),\n                     cx.ident_of(\"emit_struct_field\"),\n                     ~[\n-                        build::mk_base_str(cx, span, cx.str_of(ident)),\n-                        build::mk_uint(cx, span, idx),\n-                        blk_expr\n+                        cx.expr_str(span, cx.str_of(ident)),\n+                        cx.expr_uint(span, idx),\n+                        cx.lambda_expr_1(span, encode_expr, e_ident)\n                     ]\n                 );\n \n-                statements.push(build::mk_stmt(cx, span, call_expr));\n+                statements.push(cx.stmt_expr(call_expr));\n             }\n             unnamed_field => {\n                 cx.span_unimpl(\n@@ -328,40 +310,26 @@ fn expand_deriving_encodable_struct_method(\n         idx += 1;\n     }\n \n-    let e_arg = build::mk_arg(cx,\n-                              span,\n-                              cx.ident_of(\"__e\"),\n-                              build::mk_ty_infer(cx, span));\n-\n-    let emit_struct_stmt = build::mk_method_call(\n-        cx,\n+    let e_id = cx.ident_of(\"__e\");\n+    let emit_struct_stmt = cx.expr_method_call(\n         span,\n-        build::mk_path(\n-            cx,\n-            span,\n-            ~[cx.ident_of(\"__e\")]\n-        ),\n+        cx.expr_ident(span, e_id),\n         cx.ident_of(\"emit_struct\"),\n         ~[\n-            build::mk_base_str(cx, span, cx.str_of(type_ident)),\n-            build::mk_uint(cx, span, statements.len()),\n-            build::mk_lambda_stmts(\n-                cx,\n-                span,\n-                build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n-                statements\n-            ),\n+            cx.expr_str(span, cx.str_of(type_ident)),\n+            cx.expr_uint(span, statements.len()),\n+            cx.lambda_stmts_1(span, statements, e_id),\n         ]\n     );\n \n-    let statements = ~[build::mk_stmt(cx, span, emit_struct_stmt)];\n+    let statements = ~[cx.stmt_expr(emit_struct_stmt)];\n \n     // Create the method itself.\n     return create_encode_method(cx, span, statements);\n }\n \n fn expand_deriving_encodable_enum_method(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     type_ident: ast::ident,\n     enum_definition: &enum_def\n@@ -382,91 +350,59 @@ fn expand_deriving_encodable_enum_method(\n             let expr = call_substructure_encode_method(cx, span, field);\n \n             let e_ident = cx.ident_of(\"__e\");\n-            let e_arg = build::mk_arg(cx,\n-                                      span,\n-                                      e_ident,\n-                                      build::mk_ty_infer(cx, span));\n-\n-            let blk_expr = build::mk_lambda(\n-                cx,\n-                span,\n-                build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n-                expr\n-            );\n-\n-            let call_expr = build::mk_method_call(\n-                cx,\n+            let call_expr = cx.expr_method_call(\n                 span,\n-                build::mk_path(cx, span, ~[cx.ident_of(\"__e\")]),\n+                cx.expr_ident(span, e_ident),\n                 cx.ident_of(\"emit_enum_variant_arg\"),\n                 ~[\n-                    build::mk_uint(cx, span, j),\n-                    blk_expr,\n+                    cx.expr_uint(span, j),\n+                    cx.lambda_expr_1(span, expr, e_ident),\n                 ]\n             );\n \n-            stmts.push(build::mk_stmt(cx, span, call_expr));\n+            stmts.push(cx.stmt_expr(call_expr));\n         }\n \n         // Create the pattern body.\n-        let e_arg = build::mk_arg(cx,\n-                                  span,\n-                                  cx.ident_of(\"__e\"),\n-                                  build::mk_ty_infer(cx, span));\n-        let call_expr = build::mk_method_call(\n-            cx,\n+        let e_id = cx.ident_of(\"__e\");\n+\n+        let call_expr = cx.expr_method_call(\n             span,\n-            build::mk_path(cx, span, ~[cx.ident_of(\"__e\")]),\n+            cx.expr_ident(span, e_id),\n             cx.ident_of(\"emit_enum_variant\"),\n             ~[\n-                build::mk_base_str(cx, span, cx.str_of(variant.node.name)),\n-                build::mk_uint(cx, span, i),\n-                build::mk_uint(cx, span, variant_arg_len),\n-                build::mk_lambda_stmts(\n-                    cx,\n-                    span,\n-                    build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n-                    stmts\n-                )\n+                cx.expr_str(span, cx.str_of(variant.node.name)),\n+                cx.expr_uint(span, i),\n+                cx.expr_uint(span, variant_arg_len),\n+                cx.lambda_stmts_1(span, stmts, e_id)\n             ]\n         );\n \n-        let match_body_block = build::mk_simple_block(cx, span, call_expr);\n+        //let match_body_block = cx.blk_expr(call_expr);\n \n         // Create the arm.\n-        ast::arm {\n-            pats: ~[pat],\n-            guard: None,\n-            body: match_body_block,\n-        }\n+        cx.arm(span, ~[pat], call_expr) //match_body_block)\n     };\n \n     let e_ident = cx.ident_of(\"__e\");\n-    let e_arg = build::mk_arg(cx,\n-                              span,\n-                              e_ident,\n-                              build::mk_ty_infer(cx, span));\n \n     // Create the method body.\n-    let lambda_expr = build::mk_lambda(\n-        cx,\n+    let lambda_expr = cx.lambda_expr_1(\n         span,\n-        build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n-        expand_enum_or_struct_match(cx, span, arms)\n-    );\n+        expand_enum_or_struct_match(cx, span, arms),\n+        e_ident);\n \n-    let call_expr = build::mk_method_call(\n-        cx,\n+    let call_expr = cx.expr_method_call(\n         span,\n-        build::mk_path(cx, span, ~[cx.ident_of(\"__e\")]),\n+        cx.expr_ident(span, e_ident),\n         cx.ident_of(\"emit_enum\"),\n         ~[\n-            build::mk_base_str(cx, span, cx.str_of(type_ident)),\n+            cx.expr_str(span, cx.str_of(type_ident)),\n             lambda_expr,\n         ]\n     );\n \n-    let stmt = build::mk_stmt(cx, span, call_expr);\n+    let stmt = cx.stmt_expr(call_expr);\n \n     // Create the method.\n     create_encode_method(cx, span, ~[stmt])"}, {"sha": "b61c78721fee94efe44e27ee2f7edd17af10e537", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 58, "deletions": 64, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -165,16 +165,16 @@ StaticEnum(<ast::enum_def of C>, ~[(<ident of C0>, Left(1)),\n use ast;\n use ast::{enum_def, expr, ident, Generics, struct_def};\n \n-use ext::base::ext_ctxt;\n-use ext::build;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n use ext::deriving::*;\n use codemap::{span,respan};\n use opt_vec;\n \n pub use self::ty::*;\n mod ty;\n \n-pub fn expand_deriving_generic(cx: @ext_ctxt,\n+pub fn expand_deriving_generic(cx: @ExtCtxt,\n                                span: span,\n                                _mitem: @ast::meta_item,\n                                in_items: ~[@ast::item],\n@@ -195,34 +195,34 @@ pub fn expand_deriving_generic(cx: @ext_ctxt,\n \n pub struct TraitDef<'self> {\n     /// Path of the trait, including any type parameters\n-    path: Path,\n+    path: Path<'self>,\n     /// Additional bounds required of any type parameters of the type,\n     /// other than the current trait\n-    additional_bounds: ~[Ty],\n+    additional_bounds: ~[Ty<'self>],\n \n     /// Any extra lifetimes and/or bounds, e.g. `D: std::serialize::Decoder`\n-    generics: LifetimeBounds,\n+    generics: LifetimeBounds<'self>,\n \n     methods: ~[MethodDef<'self>]\n }\n \n \n pub struct MethodDef<'self> {\n     /// name of the method\n-    name: ~str,\n+    name: &'self str,\n     /// List of generics, e.g. `R: core::rand::Rng`\n-    generics: LifetimeBounds,\n+    generics: LifetimeBounds<'self>,\n \n     /// Whether there is a self argument (outer Option) i.e. whether\n     /// this is a static function, and whether it is a pointer (inner\n     /// Option)\n-    explicit_self: Option<Option<PtrTy>>,\n+    explicit_self: Option<Option<PtrTy<'self>>>,\n \n     /// Arguments other than the self argument\n-    args: ~[Ty],\n+    args: ~[Ty<'self>],\n \n     /// Return type\n-    ret_ty: Ty,\n+    ret_ty: Ty<'self>,\n \n     /// if the value of the nonmatching enums is independent of the\n     /// actual enum variants, i.e. can use _ => .. match.\n@@ -281,22 +281,22 @@ Combine the values of all the fields together. The last argument is\n all the fields of all the structures, see above for details.\n */\n pub type CombineSubstructureFunc<'self> =\n-    &'self fn(@ext_ctxt, span, &Substructure) -> @expr;\n+    &'self fn(@ExtCtxt, span, &Substructure) -> @expr;\n \n /**\n Deal with non-matching enum variants, the arguments are a list\n representing each variant: (variant index, ast::variant instance,\n [variant fields]), and a list of the nonself args of the type\n */\n pub type EnumNonMatchFunc<'self> =\n-    &'self fn(@ext_ctxt, span,\n+    &'self fn(@ExtCtxt, span,\n               &[(uint, ast::variant,\n                  ~[(Option<ident>, @expr)])],\n               &[@expr]) -> @expr;\n \n \n impl<'self> TraitDef<'self> {\n-    fn create_derived_impl(&self, cx: @ext_ctxt, span: span,\n+    fn create_derived_impl(&self, cx: @ExtCtxt, span: span,\n                            type_ident: ident, generics: &Generics,\n                            methods: ~[@ast::method]) -> @ast::item {\n         let trait_path = self.path.to_path(cx, span, type_ident, generics);\n@@ -315,7 +315,7 @@ impl<'self> TraitDef<'self> {\n                             additional_bounds)\n     }\n \n-    fn expand_struct_def(&self, cx: @ext_ctxt,\n+    fn expand_struct_def(&self, cx: @ExtCtxt,\n                          span: span,\n                          struct_def: &struct_def,\n                          type_ident: ident,\n@@ -347,7 +347,7 @@ impl<'self> TraitDef<'self> {\n     }\n \n     fn expand_enum_def(&self,\n-                       cx: @ext_ctxt, span: span,\n+                       cx: @ExtCtxt, span: span,\n                        enum_def: &enum_def,\n                        type_ident: ident,\n                        generics: &Generics) -> @ast::item {\n@@ -380,7 +380,7 @@ impl<'self> TraitDef<'self> {\n \n impl<'self> MethodDef<'self> {\n     fn call_substructure_method(&self,\n-                                cx: @ext_ctxt,\n+                                cx: @ExtCtxt,\n                                 span: span,\n                                 type_ident: ident,\n                                 self_args: &[@expr],\n@@ -398,7 +398,7 @@ impl<'self> MethodDef<'self> {\n                                     &substructure)\n     }\n \n-    fn get_ret_ty(&self, cx: @ext_ctxt, span: span,\n+    fn get_ret_ty(&self, cx: @ExtCtxt, span: span,\n                      generics: &Generics, type_ident: ident) -> @ast::Ty {\n         self.ret_ty.to_ty(cx, span, type_ident, generics)\n     }\n@@ -407,7 +407,7 @@ impl<'self> MethodDef<'self> {\n         self.explicit_self.is_none()\n     }\n \n-    fn split_self_nonself_args(&self, cx: @ext_ctxt, span: span,\n+    fn split_self_nonself_args(&self, cx: @ExtCtxt, span: span,\n                              type_ident: ident, generics: &Generics)\n         -> (ast::explicit_self, ~[@expr], ~[@expr], ~[(ident, @ast::Ty)]) {\n \n@@ -431,7 +431,7 @@ impl<'self> MethodDef<'self> {\n             let ident = cx.ident_of(fmt!(\"__arg_%u\", i));\n             arg_tys.push((ident, ast_ty));\n \n-            let arg_expr = build::mk_path(cx, span, ~[ident]);\n+            let arg_expr = cx.expr_ident(span, ident);\n \n             match *ty {\n                 // for static methods, just treat any Self\n@@ -440,7 +440,7 @@ impl<'self> MethodDef<'self> {\n                     self_args.push(arg_expr);\n                 }\n                 Ptr(~Self, _) if nonstatic => {\n-                    self_args.push(build::mk_deref(cx, span, arg_expr))\n+                    self_args.push(cx.expr_deref(span, arg_expr))\n                 }\n                 _ => {\n                     nonself_args.push(arg_expr);\n@@ -451,7 +451,7 @@ impl<'self> MethodDef<'self> {\n         (ast_explicit_self, self_args, nonself_args, arg_tys)\n     }\n \n-    fn create_method(&self, cx: @ext_ctxt, span: span,\n+    fn create_method(&self, cx: @ExtCtxt, span: span,\n                      type_ident: ident,\n                      generics: &Generics,\n                      explicit_self: ast::explicit_self,\n@@ -461,14 +461,14 @@ impl<'self> MethodDef<'self> {\n         let fn_generics = self.generics.to_generics(cx, span, type_ident, generics);\n \n         let args = do arg_types.map |&(id, ty)| {\n-            build::mk_arg(cx, span, id, ty)\n+            cx.arg(span, id, ty)\n         };\n \n         let ret_type = self.get_ret_ty(cx, span, generics, type_ident);\n \n         let method_ident = cx.ident_of(self.name);\n-        let fn_decl = build::mk_fn_decl(args, ret_type);\n-        let body_block = build::mk_simple_block(cx, span, body);\n+        let fn_decl = cx.fn_decl(args, ret_type);\n+        let body_block = cx.blk_expr(body);\n \n \n         // Create the method.\n@@ -509,7 +509,7 @@ impl<'self> MethodDef<'self> {\n     ~~~\n     */\n     fn expand_struct_method_body(&self,\n-                                 cx: @ext_ctxt,\n+                                 cx: @ExtCtxt,\n                                  span: span,\n                                  struct_def: &struct_def,\n                                  type_ident: ident,\n@@ -555,19 +555,14 @@ impl<'self> MethodDef<'self> {\n         // structs. This is actually right-to-left, but it shoudn't\n         // matter.\n         for vec::each2(self_args, patterns) |&arg_expr, &pat| {\n-            let match_arm = ast::arm {\n-                pats: ~[ pat ],\n-                guard: None,\n-                body: build::mk_simple_block(cx, span, body)\n-            };\n-\n-            body = build::mk_expr(cx, span, ast::expr_match(arg_expr, ~[match_arm]))\n+            body = cx.expr_match(span, arg_expr,\n+                                 ~[ cx.arm(span, ~[pat], body) ])\n         }\n         body\n     }\n \n     fn expand_static_struct_method_body(&self,\n-                                        cx: @ext_ctxt,\n+                                        cx: @ExtCtxt,\n                                         span: span,\n                                         struct_def: &struct_def,\n                                         type_ident: ident,\n@@ -609,7 +604,7 @@ impl<'self> MethodDef<'self> {\n     ~~~\n     */\n     fn expand_enum_method_body(&self,\n-                               cx: @ext_ctxt,\n+                               cx: @ExtCtxt,\n                                span: span,\n                                enum_def: &enum_def,\n                                type_ident: ident,\n@@ -645,7 +640,7 @@ impl<'self> MethodDef<'self> {\n     the first call).\n     */\n     fn build_enum_match(&self,\n-                        cx: @ext_ctxt, span: span,\n+                        cx: @ExtCtxt, span: span,\n                         enum_def: &enum_def,\n                         type_ident: ident,\n                         self_args: &[@expr],\n@@ -690,7 +685,7 @@ impl<'self> MethodDef<'self> {\n                     }\n                     let field_tuples =\n                         do vec::map_zip(*self_vec,\n-                                     enum_matching_fields) |&(id, self_f), &other| {\n+                                        enum_matching_fields) |&(id, self_f), &other| {\n                         (id, self_f, other)\n                     };\n                     substructure = EnumMatching(variant_index, variant, field_tuples);\n@@ -738,16 +733,16 @@ impl<'self> MethodDef<'self> {\n                                                      matches_so_far,\n                                                      match_count + 1);\n                 matches_so_far.pop();\n-                arms.push(build::mk_arm(cx, span, ~[ pattern ], arm_expr));\n+                arms.push(cx.arm(span, ~[ pattern ], arm_expr));\n \n                 if enum_def.variants.len() > 1 {\n                     let e = &EnumNonMatching(&[]);\n                     let wild_expr = self.call_substructure_method(cx, span, type_ident,\n                                                                   self_args, nonself_args,\n                                                                   e);\n-                    let wild_arm = build::mk_arm(cx, span,\n-                                                 ~[ build::mk_pat_wild(cx, span) ],\n-                                                 wild_expr);\n+                    let wild_arm = cx.arm(span,\n+                                          ~[ cx.pat_wild(span) ],\n+                                          wild_expr);\n                     arms.push(wild_arm);\n                 }\n             } else {\n@@ -774,19 +769,18 @@ impl<'self> MethodDef<'self> {\n                                                          match_count + 1);\n                     matches_so_far.pop();\n \n-                    let arm = build::mk_arm(cx, span, ~[ pattern ], arm_expr);\n+                    let arm = cx.arm(span, ~[ pattern ], arm_expr);\n                     arms.push(arm);\n                 }\n             }\n \n             // match foo { arm, arm, arm, ... }\n-            build::mk_expr(cx, span,\n-                           ast::expr_match(self_args[match_count], arms))\n+            cx.expr_match(span, self_args[match_count], arms)\n         }\n     }\n \n     fn expand_static_enum_method_body(&self,\n-                               cx: @ext_ctxt,\n+                               cx: @ExtCtxt,\n                                span: span,\n                                enum_def: &enum_def,\n                                type_ident: ident,\n@@ -810,7 +804,7 @@ impl<'self> MethodDef<'self> {\n     }\n }\n \n-fn summarise_struct(cx: @ext_ctxt, span: span,\n+fn summarise_struct(cx: @ExtCtxt, span: span,\n                     struct_def: &struct_def) -> Either<uint, ~[ident]> {\n     let mut named_idents = ~[];\n     let mut unnamed_count = 0;\n@@ -840,12 +834,12 @@ Fold the fields. `use_foldl` controls whether this is done\n left-to-right (`true`) or right-to-left (`false`).\n */\n pub fn cs_fold(use_foldl: bool,\n-               f: &fn(@ext_ctxt, span,\n+               f: &fn(@ExtCtxt, span,\n                       old: @expr,\n                       self_f: @expr, other_fs: &[@expr]) -> @expr,\n                base: @expr,\n                enum_nonmatch_f: EnumNonMatchFunc,\n-               cx: @ext_ctxt, span: span,\n+               cx: @ExtCtxt, span: span,\n                substructure: &Substructure) -> @expr {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n@@ -879,18 +873,18 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n ~~~\n */\n #[inline(always)]\n-pub fn cs_same_method(f: &fn(@ext_ctxt, span, ~[@expr]) -> @expr,\n+pub fn cs_same_method(f: &fn(@ExtCtxt, span, ~[@expr]) -> @expr,\n                       enum_nonmatch_f: EnumNonMatchFunc,\n-                      cx: @ext_ctxt, span: span,\n+                      cx: @ExtCtxt, span: span,\n                       substructure: &Substructure) -> @expr {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n             let called = do all_fields.map |&(_, self_field, other_fields)| {\n-                build::mk_method_call(cx, span,\n-                                      self_field,\n-                                      substructure.method_ident,\n-                                      other_fields)\n+                cx.expr_method_call(span,\n+                                    self_field,\n+                                    substructure.method_ident,\n+                                    other_fields)\n             };\n \n             f(cx, span, called)\n@@ -911,10 +905,10 @@ fields. `use_foldl` controls whether this is done left-to-right\n */\n #[inline(always)]\n pub fn cs_same_method_fold(use_foldl: bool,\n-                           f: &fn(@ext_ctxt, span, @expr, @expr) -> @expr,\n+                           f: &fn(@ExtCtxt, span, @expr, @expr) -> @expr,\n                            base: @expr,\n                            enum_nonmatch_f: EnumNonMatchFunc,\n-                           cx: @ext_ctxt, span: span,\n+                           cx: @ExtCtxt, span: span,\n                            substructure: &Substructure) -> @expr {\n     cs_same_method(\n         |cx, span, vals| {\n@@ -940,14 +934,14 @@ on all the fields.\n #[inline(always)]\n pub fn cs_binop(binop: ast::binop, base: @expr,\n                 enum_nonmatch_f: EnumNonMatchFunc,\n-                cx: @ext_ctxt, span: span,\n+                cx: @ExtCtxt, span: span,\n                 substructure: &Substructure) -> @expr {\n     cs_same_method_fold(\n         true, // foldl is good enough\n         |cx, span, old, new| {\n-            build::mk_binary(cx, span,\n-                             binop,\n-                             old, new)\n+            cx.expr_binary(span,\n+                           binop,\n+                           old, new)\n \n         },\n         base,\n@@ -958,18 +952,18 @@ pub fn cs_binop(binop: ast::binop, base: @expr,\n /// cs_binop with binop == or\n #[inline(always)]\n pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n-             cx: @ext_ctxt, span: span,\n+             cx: @ExtCtxt, span: span,\n              substructure: &Substructure) -> @expr {\n-    cs_binop(ast::or, build::mk_bool(cx, span, false),\n+    cs_binop(ast::or, cx.expr_bool(span, false),\n              enum_nonmatch_f,\n              cx, span, substructure)\n }\n /// cs_binop with binop == and\n #[inline(always)]\n pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,\n-              cx: @ext_ctxt, span: span,\n+              cx: @ExtCtxt, span: span,\n               substructure: &Substructure) -> @expr {\n-    cs_binop(ast::and, build::mk_bool(cx, span, true),\n+    cs_binop(ast::and, cx.expr_bool(span, true),\n              enum_nonmatch_f,\n              cx, span, substructure)\n }"}, {"sha": "ae321c3e40956f14ed78802f41890c22575b7edc", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -10,28 +10,28 @@\n \n use ast::{meta_item, item, expr, and};\n use codemap::span;\n-use ext::base::ext_ctxt;\n-use ext::build;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_iter_bytes(cx: @ext_ctxt,\n+pub fn expand_deriving_iter_bytes(cx: @ExtCtxt,\n                                   span: span,\n                                   mitem: @meta_item,\n                                   in_items: ~[@item]) -> ~[@item] {\n     let trait_def = TraitDef {\n-        path: Path::new(~[~\"core\", ~\"to_bytes\", ~\"IterBytes\"]),\n+        path: Path::new(~[\"core\", \"to_bytes\", \"IterBytes\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n         methods: ~[\n             MethodDef {\n-                name: ~\"iter_bytes\",\n+                name: \"iter_bytes\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n                 args: ~[\n-                    Literal(Path::new(~[~\"bool\"])),\n-                    Literal(Path::new(~[~\"core\", ~\"to_bytes\", ~\"Cb\"]))\n+                    Literal(Path::new(~[\"bool\"])),\n+                    Literal(Path::new(~[\"core\", \"to_bytes\", \"Cb\"]))\n                 ],\n-                ret_ty: Literal(Path::new(~[~\"bool\"])),\n+                ret_ty: Literal(Path::new(~[\"bool\"])),\n                 const_nonmatching: false,\n                 combine_substructure: iter_bytes_substructure\n             }\n@@ -41,14 +41,14 @@ pub fn expand_deriving_iter_bytes(cx: @ext_ctxt,\n     expand_deriving_generic(cx, span, mitem, in_items, &trait_def)\n }\n \n-fn iter_bytes_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n+fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n     let lsb0_f = match substr.nonself_args {\n         [l, f] => ~[l, f],\n         _ => cx.span_bug(span, \"Incorrect number of arguments in `deriving(IterBytes)`\")\n     };\n     let iter_bytes_ident = substr.method_ident;\n     let call_iterbytes = |thing_expr| {\n-        build::mk_method_call(cx, span,\n+        cx.expr_method_call(span,\n                               thing_expr, iter_bytes_ident,\n                               copy lsb0_f)\n     };\n@@ -63,7 +63,7 @@ fn iter_bytes_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) ->\n             // iteration function.\n             let discriminant = match variant.node.disr_expr {\n                 Some(copy d)=> d,\n-                None => build::mk_uint(cx, span, index)\n+                None => cx.expr_uint(span, index)\n             };\n \n             exprs.push(call_iterbytes(discriminant));\n@@ -82,6 +82,6 @@ fn iter_bytes_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) ->\n     }\n \n     do vec::foldl(exprs[0], exprs.slice(1, exprs.len())) |prev, me| {\n-        build::mk_binary(cx, span, and, prev, *me)\n+        cx.expr_binary(span, and, prev, *me)\n     }\n }"}, {"sha": "7da66f88ca9082fc983485cd8b8a6170d45d7f27", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 54, "deletions": 78, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -20,9 +20,9 @@ library.\n \n use ast;\n use ast::{Ty, enum_def, expr, ident, item, Generics, meta_item, struct_def};\n-use ext::base::ext_ctxt;\n-use ext::build;\n-use codemap::{span, respan};\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n+use codemap::span;\n use parse::token::special_idents::clownshoes_extensions;\n use opt_vec;\n \n@@ -45,20 +45,20 @@ pub mod totalord;\n \n pub mod generic;\n \n-pub type ExpandDerivingStructDefFn<'self> = &'self fn(@ext_ctxt,\n+pub type ExpandDerivingStructDefFn<'self> = &'self fn(@ExtCtxt,\n                                                        span,\n                                                        x: &struct_def,\n                                                        ident,\n                                                        y: &Generics)\n                                                  -> @item;\n-pub type ExpandDerivingEnumDefFn<'self> = &'self fn(@ext_ctxt,\n+pub type ExpandDerivingEnumDefFn<'self> = &'self fn(@ExtCtxt,\n                                                     span,\n                                                     x: &enum_def,\n                                                     ident,\n                                                     y: &Generics)\n                                                  -> @item;\n \n-pub fn expand_meta_deriving(cx: @ext_ctxt,\n+pub fn expand_meta_deriving(cx: @ExtCtxt,\n                             _span: span,\n                             mitem: @meta_item,\n                             in_items: ~[@item])\n@@ -113,7 +113,7 @@ pub fn expand_meta_deriving(cx: @ext_ctxt,\n     }\n }\n \n-pub fn expand_deriving(cx: @ext_ctxt,\n+pub fn expand_deriving(cx: @ExtCtxt,\n                    span: span,\n                    in_items: ~[@item],\n                    expand_deriving_struct_def: ExpandDerivingStructDefFn,\n@@ -143,38 +143,15 @@ pub fn expand_deriving(cx: @ext_ctxt,\n     result\n }\n \n-fn create_impl_item(cx: @ext_ctxt, span: span, item: ast::item_) -> @item {\n-    let doc_attr = respan(span,\n-                          ast::lit_str(@~\"Automatically derived.\"));\n-    let doc_attr = respan(span, ast::meta_name_value(@~\"doc\", doc_attr));\n-    let doc_attr = ast::attribute_ {\n-        style: ast::attr_outer,\n-        value: @doc_attr,\n-        is_sugared_doc: false\n-    };\n-    let doc_attr = respan(span, doc_attr);\n-\n-    @ast::item {\n-        ident: clownshoes_extensions,\n-        attrs: ~[doc_attr],\n-        id: cx.next_id(),\n-        node: item,\n-        vis: ast::public,\n-        span: span,\n-    }\n-}\n-\n-pub fn create_self_type_with_params(cx: @ext_ctxt,\n-                                span: span,\n-                                type_ident: ident,\n-                                generics: &Generics)\n-                             -> @Ty {\n+pub fn create_self_type_with_params(cx: @ExtCtxt,\n+                                    span: span,\n+                                    type_ident: ident,\n+                                    generics: &Generics)\n+    -> @Ty {\n     // Create the type parameters on the `self` path.\n     let mut self_ty_params = ~[];\n     for generics.ty_params.each |ty_param| {\n-        let self_ty_param = build::mk_simple_ty_path(cx,\n-                                                     span,\n-                                                     ty_param.ident);\n+        let self_ty_param = cx.ty_ident(span, ty_param.ident);\n         self_ty_params.push(self_ty_param);\n     }\n \n@@ -186,14 +163,10 @@ pub fn create_self_type_with_params(cx: @ext_ctxt,\n \n \n     // Create the type of `self`.\n-    let self_type = build::mk_raw_path_(span,\n-                                        ~[ type_ident ],\n-                                        lifetime,\n-                                        self_ty_params);\n-    build::mk_ty_path_path(cx, span, self_type)\n+    cx.ty_path(cx.path_all(span, false, ~[ type_ident ], lifetime, self_ty_params))\n }\n \n-pub fn create_derived_impl(cx: @ext_ctxt,\n+pub fn create_derived_impl(cx: @ExtCtxt,\n                            span: span,\n                            type_ident: ident,\n                            generics: &Generics,\n@@ -222,40 +195,45 @@ pub fn create_derived_impl(cx: @ext_ctxt,\n     for generics.ty_params.each |ty_param| {\n         // extra restrictions on the generics parameters to the type being derived upon\n         let mut bounds = do bounds_paths.map |&bound_path| {\n-            build::mk_trait_ty_param_bound_(cx, bound_path)\n+            cx.typarambound(bound_path)\n         };\n \n-        let this_trait_bound =\n-            build::mk_trait_ty_param_bound_(cx, trait_path);\n+        let this_trait_bound = cx.typarambound(trait_path);\n         bounds.push(this_trait_bound);\n \n-        impl_generics.ty_params.push(build::mk_ty_param(cx, ty_param.ident, @bounds));\n+        impl_generics.ty_params.push(cx.typaram(ty_param.ident, @bounds));\n     }\n \n     // Create the reference to the trait.\n-    let trait_ref = build::mk_trait_ref_(cx, trait_path);\n+    let trait_ref = cx.trait_ref(trait_path);\n \n     // Create the type of `self`.\n     let self_type = create_self_type_with_params(cx,\n                                                  span,\n                                                  type_ident,\n                                                  generics);\n \n-    // Create the impl item.\n-    let impl_item = ast::item_impl(impl_generics,\n-                              Some(trait_ref),\n-                              self_type,\n-                              methods.map(|x| *x));\n-    return create_impl_item(cx, span, impl_item);\n+    let doc_attr = cx.attribute(\n+        span,\n+        cx.meta_name_value(span,\n+                           ~\"doc\", ast::lit_str(@~\"Automatically derived.\")));\n+    cx.item(\n+        span,\n+        clownshoes_extensions,\n+        ~[doc_attr],\n+        ast::item_impl(impl_generics,\n+                       Some(trait_ref),\n+                       self_type,\n+                       methods.map(|x| *x)))\n }\n \n-pub fn create_subpatterns(cx: @ext_ctxt,\n+pub fn create_subpatterns(cx: @ExtCtxt,\n                           span: span,\n                           field_paths: ~[@ast::Path],\n                           mutbl: ast::mutability)\n                    -> ~[@ast::pat] {\n     do field_paths.map |&path| {\n-        build::mk_pat(cx, span,\n+        cx.pat(span,\n                       ast::pat_ident(ast::bind_by_ref(mutbl), path, None))\n     }\n }\n@@ -265,7 +243,7 @@ enum StructType {\n     Unknown, Record, Tuple\n }\n \n-pub fn create_struct_pattern(cx: @ext_ctxt,\n+pub fn create_struct_pattern(cx: @ExtCtxt,\n                              span: span,\n                              struct_ident: ident,\n                              struct_def: &struct_def,\n@@ -274,12 +252,12 @@ pub fn create_struct_pattern(cx: @ext_ctxt,\n     -> (@ast::pat, ~[(Option<ident>, @expr)]) {\n     if struct_def.fields.is_empty() {\n         return (\n-            build::mk_pat_ident_with_binding_mode(\n-                cx, span, struct_ident, ast::bind_infer),\n+            cx.pat_ident_binding_mode(\n+                span, struct_ident, ast::bind_infer),\n             ~[]);\n     }\n \n-    let matching_path = build::mk_raw_path(span, ~[ struct_ident ]);\n+    let matching_path = cx.path(span, ~[ struct_ident ]);\n \n     let mut paths = ~[], ident_expr = ~[];\n \n@@ -301,10 +279,10 @@ pub fn create_struct_pattern(cx: @ext_ctxt,\n                 cx.span_bug(span, \"A struct with named and unnamed fields in `deriving`\");\n             }\n         };\n-        let path = build::mk_raw_path(span,\n-                                      ~[ cx.ident_of(fmt!(\"%s_%u\", prefix, i)) ]);\n+        let path = cx.path_ident(span,\n+                                 cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n         paths.push(path);\n-        ident_expr.push((opt_id, build::mk_path_raw(cx, span, path)));\n+        ident_expr.push((opt_id, cx.expr_path(path)));\n     }\n \n     let subpats = create_subpatterns(cx, span, paths, mutbl);\n@@ -318,15 +296,15 @@ pub fn create_struct_pattern(cx: @ext_ctxt,\n                 push(ast::field_pat { ident: id.get(), pat: pat })\n             }\n         };\n-        build::mk_pat_struct(cx, span, matching_path, field_pats)\n+        cx.pat_struct(span, matching_path, field_pats)\n     } else {\n-        build::mk_pat_enum(cx, span, matching_path, subpats)\n+        cx.pat_enum(span, matching_path, subpats)\n     };\n \n     (pattern, ident_expr)\n }\n \n-pub fn create_enum_variant_pattern(cx: @ext_ctxt,\n+pub fn create_enum_variant_pattern(cx: @ExtCtxt,\n                                    span: span,\n                                    variant: &ast::variant,\n                                    prefix: &str,\n@@ -337,24 +315,24 @@ pub fn create_enum_variant_pattern(cx: @ext_ctxt,\n     match variant.node.kind {\n         ast::tuple_variant_kind(ref variant_args) => {\n             if variant_args.is_empty() {\n-                return (build::mk_pat_ident_with_binding_mode(\n-                    cx, span, variant_ident, ast::bind_infer), ~[]);\n+                return (cx.pat_ident_binding_mode(\n+                    span, variant_ident, ast::bind_infer), ~[]);\n             }\n \n-            let matching_path = build::mk_raw_path(span, ~[ variant_ident ]);\n+            let matching_path = cx.path_ident(span, variant_ident);\n \n             let mut paths = ~[], ident_expr = ~[];\n             for uint::range(0, variant_args.len()) |i| {\n-                let path = build::mk_raw_path(span,\n-                                              ~[ cx.ident_of(fmt!(\"%s_%u\", prefix, i)) ]);\n+                let path = cx.path_ident(span,\n+                                         cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n \n                 paths.push(path);\n-                ident_expr.push((None, build::mk_path_raw(cx, span, path)));\n+                ident_expr.push((None, cx.expr_path(path)));\n             }\n \n             let subpats = create_subpatterns(cx, span, paths, mutbl);\n \n-            (build::mk_pat_enum(cx, span, matching_path, subpats),\n+            (cx.pat_enum(span, matching_path, subpats),\n              ident_expr)\n         }\n         ast::struct_variant_kind(struct_def) => {\n@@ -366,19 +344,17 @@ pub fn create_enum_variant_pattern(cx: @ext_ctxt,\n     }\n }\n \n-pub fn variant_arg_count(_cx: @ext_ctxt, _span: span, variant: &ast::variant) -> uint {\n+pub fn variant_arg_count(_cx: @ExtCtxt, _span: span, variant: &ast::variant) -> uint {\n     match variant.node.kind {\n         ast::tuple_variant_kind(ref args) => args.len(),\n         ast::struct_variant_kind(ref struct_def) => struct_def.fields.len(),\n     }\n }\n \n-pub fn expand_enum_or_struct_match(cx: @ext_ctxt,\n+pub fn expand_enum_or_struct_match(cx: @ExtCtxt,\n                                span: span,\n                                arms: ~[ ast::arm ])\n                             -> @expr {\n-    let self_expr = build::make_self(cx, span);\n-    let self_expr = build::mk_unary(cx, span, ast::deref, self_expr);\n-    let self_match_expr = ast::expr_match(self_expr, arms);\n-    build::mk_expr(cx, span, self_match_expr)\n+    let self_expr = cx.expr_deref(span, cx.expr_self(span));\n+    cx.expr_match(span, self_expr, arms)\n }"}, {"sha": "16f754727b0789610d94d4523d948d5356cb7d64", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 33, "deletions": 40, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -11,30 +11,30 @@\n use ast;\n use ast::{meta_item, item, expr, ident};\n use codemap::span;\n-use ext::base::ext_ctxt;\n-use ext::build;\n+use ext::base::ExtCtxt;\n+use ext::build::{AstBuilder, Duplicate};\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_rand(cx: @ext_ctxt,\n+pub fn expand_deriving_rand(cx: @ExtCtxt,\n                             span: span,\n                             mitem: @meta_item,\n                             in_items: ~[@item])\n     -> ~[@item] {\n     let trait_def = TraitDef {\n-        path: Path::new(~[~\"core\", ~\"rand\", ~\"Rand\"]),\n+        path: Path::new(~[\"core\", \"rand\", \"Rand\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n         methods: ~[\n             MethodDef {\n-                name: ~\"rand\",\n+                name: \"rand\",\n                 generics: LifetimeBounds {\n                     lifetimes: ~[],\n-                    bounds: ~[(~\"R\",\n-                               ~[ Path::new(~[~\"core\", ~\"rand\", ~\"Rng\"]) ])]\n+                    bounds: ~[(\"R\",\n+                               ~[ Path::new(~[\"core\", \"rand\", \"Rng\"]) ])]\n                 },\n                 explicit_self: None,\n                 args: ~[\n-                    Ptr(~Literal(Path::new_local(~\"R\")),\n+                    Ptr(~Literal(Path::new_local(\"R\")),\n                         Borrowed(None, ast::m_mutbl))\n                 ],\n                 ret_ty: Self,\n@@ -47,7 +47,7 @@ pub fn expand_deriving_rand(cx: @ext_ctxt,\n     expand_deriving_generic(cx, span, mitem, in_items, &trait_def)\n }\n \n-fn rand_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n+fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n     let rng = match substr.nonself_args {\n         [rng] => ~[ rng ],\n         _ => cx.bug(\"Incorrect number of arguments to `rand` in `deriving(Rand)`\")\n@@ -59,10 +59,9 @@ fn rand_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr\n         cx.ident_of(\"rand\")\n     ];\n     let rand_call = || {\n-        build::mk_call_global(cx,\n-                              span,\n-                              copy rand_ident,\n-                              ~[ build::duplicate_expr(cx, rng[0]) ])\n+        cx.expr_call_global(span,\n+                            copy rand_ident,\n+                            ~[ rng[0].duplicate(cx) ])\n     };\n \n     return match *substr.fields {\n@@ -74,67 +73,61 @@ fn rand_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr\n                 cx.span_fatal(span, \"`Rand` cannot be derived for enums with no variants\");\n             }\n \n-            let variant_count = build::mk_uint(cx, span, variants.len());\n+            let variant_count = cx.expr_uint(span, variants.len());\n \n             // need to specify the uint-ness of the random number\n-            let u32_ty = build::mk_ty_path(cx, span, ~[cx.ident_of(\"uint\")]);\n-            let r_ty = build::mk_ty_path(cx, span, ~[cx.ident_of(\"R\")]);\n-            let rand_name = build::mk_raw_path_(span, copy rand_ident, None, ~[ u32_ty, r_ty ]);\n-            let rand_name = build::mk_path_raw(cx, span, rand_name);\n+            let u32_ty = cx.ty_ident(span, cx.ident_of(\"uint\"));\n+            let r_ty = cx.ty_ident(span, cx.ident_of(\"R\"));\n+            let rand_name = cx.path_all(span, false, copy rand_ident, None, ~[ u32_ty, r_ty ]);\n+            let rand_name = cx.expr_path(rand_name);\n \n-            let rv_call = build::mk_call_(cx,\n-                                          span,\n-                                          rand_name,\n-                                          ~[ build::duplicate_expr(cx, rng[0]) ]);\n+            let rv_call = cx.expr_call(span,\n+                                       rand_name,\n+                                       ~[ rng[0].duplicate(cx) ]);\n \n             // rand() % variants.len()\n-            let rand_variant = build::mk_binary(cx, span, ast::rem,\n+            let rand_variant = cx.expr_binary(span, ast::rem,\n                                                 rv_call, variant_count);\n \n             let mut arms = do variants.mapi |i, id_sum| {\n-                let i_expr = build::mk_uint(cx, span, i);\n-                let pat = build::mk_pat_lit(cx, span, i_expr);\n+                let i_expr = cx.expr_uint(span, i);\n+                let pat = cx.pat_lit(span, i_expr);\n \n                 match *id_sum {\n                     (ident, ref summary) => {\n-                        build::mk_arm(cx, span,\n-                                      ~[ pat ],\n-                                      rand_thing(cx, span, ident, summary, rand_call))\n+                        cx.arm(span,\n+                               ~[ pat ],\n+                               rand_thing(cx, span, ident, summary, rand_call))\n                     }\n                 }\n             };\n \n             // _ => {} at the end. Should never occur\n-            arms.push(build::mk_unreachable_arm(cx, span));\n+            arms.push(cx.arm_unreachable(span));\n \n-            build::mk_expr(cx, span,\n-                           ast::expr_match(rand_variant, arms))\n+            cx.expr_match(span, rand_variant, arms)\n         }\n         _ => cx.bug(\"Non-static method in `deriving(Rand)`\")\n     };\n \n-    fn rand_thing(cx: @ext_ctxt, span: span,\n+    fn rand_thing(cx: @ExtCtxt, span: span,\n                   ctor_ident: ident,\n                   summary: &Either<uint, ~[ident]>,\n                   rand_call: &fn() -> @expr) -> @expr {\n-        let ctor_ident = ~[ ctor_ident ];\n         match *summary {\n             Left(copy count) => {\n                 if count == 0 {\n-                    build::mk_path(cx, span, ctor_ident)\n+                    cx.expr_ident(span, ctor_ident)\n                 } else {\n                     let exprs = vec::from_fn(count, |_| rand_call());\n-                    build::mk_call(cx, span, ctor_ident, exprs)\n+                    cx.expr_call_ident(span, ctor_ident, exprs)\n                 }\n             }\n             Right(ref fields) => {\n                 let rand_fields = do fields.map |ident| {\n-                    build::Field {\n-                        ident: *ident,\n-                        ex: rand_call()\n-                    }\n+                    cx.field_imm(span, *ident, rand_call())\n                 };\n-                build::mk_struct_e(cx, span, ctor_ident, rand_fields)\n+                cx.expr_struct_ident(span, ctor_ident, rand_fields)\n             }\n         }\n     }"}, {"sha": "89b469575e54bf255b4296ac0fa95e82273153cd", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -10,26 +10,26 @@\n \n use ast::{meta_item, item, expr};\n use codemap::span;\n-use ext::base::ext_ctxt;\n-use ext::build;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_to_str(cx: @ext_ctxt,\n+pub fn expand_deriving_to_str(cx: @ExtCtxt,\n                               span: span,\n                               mitem: @meta_item,\n                               in_items: ~[@item])\n     -> ~[@item] {\n     let trait_def = TraitDef {\n-        path: Path::new(~[~\"core\", ~\"to_str\", ~\"ToStr\"]),\n+        path: Path::new(~[\"core\", \"to_str\", \"ToStr\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n         methods: ~[\n             MethodDef {\n-                name: ~\"to_str\",\n+                name: \"to_str\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n                 args: ~[],\n-                ret_ty: Ptr(~Literal(Path::new_local(~\"str\")), Owned),\n+                ret_ty: Ptr(~Literal(Path::new_local(\"str\")), Owned),\n                 const_nonmatching: false,\n                 combine_substructure: to_str_substructure\n             }\n@@ -39,15 +39,15 @@ pub fn expand_deriving_to_str(cx: @ext_ctxt,\n     expand_deriving_generic(cx, span, mitem, in_items, &trait_def)\n }\n \n-fn to_str_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n+fn to_str_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n     match substr.self_args {\n         [self_obj] => {\n-            let self_addr = build::mk_addr_of(cx, span, self_obj);\n-            build::mk_call_global(cx, span,\n-                                  ~[cx.ident_of(\"core\"),\n-                                    cx.ident_of(\"sys\"),\n-                                    cx.ident_of(\"log_str\")],\n-                                  ~[self_addr])\n+            let self_addr = cx.expr_addr_of(span, self_obj);\n+            cx.expr_call_global(span,\n+                                ~[cx.ident_of(\"core\"),\n+                                  cx.ident_of(\"sys\"),\n+                                  cx.ident_of(\"log_str\")],\n+                                ~[self_addr])\n         }\n         _ => cx.span_bug(span, \"Invalid number of arguments in `deriving(ToStr)`\")\n     }"}, {"sha": "99bc2d87b3095b4ce08493fee9befabaf10bdd43", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 62, "deletions": 65, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -15,37 +15,36 @@ explicit `Self` type to use when specifying impls to be derived.\n \n use ast;\n use ast::{expr,Generics,ident};\n-use ext::base::ext_ctxt;\n-use ext::build;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n use codemap::{span,respan};\n use opt_vec;\n \n /// The types of pointers\n-#[deriving(Eq)]\n-pub enum PtrTy {\n+pub enum PtrTy<'self> {\n     Owned, // ~\n     Managed(ast::mutability), // @[mut]\n-    Borrowed(Option<~str>, ast::mutability), // &['lifetime] [mut]\n+    Borrowed(Option<&'self str>, ast::mutability), // &['lifetime] [mut]\n }\n \n /// A path, e.g. `::core::option::Option::<int>` (global). Has support\n /// for type parameters and a lifetime.\n-#[deriving(Eq)]\n-pub struct Path {\n-    path: ~[~str],\n-    lifetime: Option<~str>,\n-    params: ~[~Ty],\n+pub struct Path<'self> {\n+    path: ~[&'self str],\n+    lifetime: Option<&'self str>,\n+    params: ~[~Ty<'self>],\n     global: bool\n }\n \n-pub impl Path {\n-    fn new(path: ~[~str]) -> Path {\n+pub impl<'self> Path<'self> {\n+    fn new<'r>(path: ~[&'r str]) -> Path<'r> {\n         Path::new_(path, None, ~[], true)\n     }\n-    fn new_local(path: ~str) -> Path {\n+    fn new_local<'r>(path: &'r str) -> Path<'r> {\n         Path::new_(~[ path ], None, ~[], false)\n     }\n-    fn new_(path: ~[~str], lifetime: Option<~str>, params: ~[~Ty], global: bool) -> Path {\n+    fn new_<'r>(path: ~[&'r str], lifetime: Option<&'r str>, params: ~[~Ty<'r>], global: bool)\n+        -> Path<'r> {\n         Path {\n             path: path,\n             lifetime: lifetime,\n@@ -54,87 +53,81 @@ pub impl Path {\n         }\n     }\n \n-    fn to_ty(&self, cx: @ext_ctxt, span: span,\n+    fn to_ty(&self, cx: @ExtCtxt, span: span,\n              self_ty: ident, self_generics: &Generics) -> @ast::Ty {\n-                build::mk_ty_path_path(cx, span,\n-                                       self.to_path(cx, span,\n-                                                    self_ty, self_generics))\n+        cx.ty_path(self.to_path(cx, span,\n+                                self_ty, self_generics))\n     }\n-    fn to_path(&self, cx: @ext_ctxt, span: span,\n+    fn to_path(&self, cx: @ExtCtxt, span: span,\n                self_ty: ident, self_generics: &Generics) -> @ast::Path {\n         let idents = self.path.map(|s| cx.ident_of(*s) );\n         let lt = mk_lifetime(cx, span, &self.lifetime);\n         let tys = self.params.map(|t| t.to_ty(cx, span, self_ty, self_generics));\n \n-        if self.global {\n-            build::mk_raw_path_global_(span, idents, lt, tys)\n-        } else {\n-            build::mk_raw_path_(span, idents, lt, tys)\n-        }\n+        cx.path_all(span, self.global, idents, lt, tys)\n     }\n }\n \n /// A type. Supports pointers (except for *), Self, and literals\n-#[deriving(Eq)]\n-pub enum Ty {\n+pub enum Ty<'self> {\n     Self,\n     // &/~/@ Ty\n-    Ptr(~Ty, PtrTy),\n+    Ptr(~Ty<'self>, PtrTy<'self>),\n     // mod::mod::Type<[lifetime], [Params...]>, including a plain type\n     // parameter, and things like `int`\n-    Literal(Path),\n+    Literal(Path<'self>),\n     // includes nil\n-    Tuple(~[Ty])\n+    Tuple(~[Ty<'self>])\n }\n \n-pub fn borrowed_ptrty() -> PtrTy {\n+pub fn borrowed_ptrty<'r>() -> PtrTy<'r> {\n     Borrowed(None, ast::m_imm)\n }\n-pub fn borrowed(ty: ~Ty) -> Ty {\n+pub fn borrowed<'r>(ty: ~Ty<'r>) -> Ty<'r> {\n     Ptr(ty, borrowed_ptrty())\n }\n \n-pub fn borrowed_explicit_self() -> Option<Option<PtrTy>> {\n+pub fn borrowed_explicit_self<'r>() -> Option<Option<PtrTy<'r>>> {\n     Some(Some(borrowed_ptrty()))\n }\n \n-pub fn borrowed_self() -> Ty {\n+pub fn borrowed_self<'r>() -> Ty<'r> {\n     borrowed(~Self)\n }\n \n-pub fn nil_ty() -> Ty {\n+pub fn nil_ty() -> Ty<'static> {\n     Tuple(~[])\n }\n \n-fn mk_lifetime(cx: @ext_ctxt, span: span, lt: &Option<~str>) -> Option<@ast::Lifetime> {\n+fn mk_lifetime(cx: @ExtCtxt, span: span, lt: &Option<&str>) -> Option<@ast::Lifetime> {\n     match *lt {\n-        Some(ref s) => Some(@build::mk_lifetime(cx, span, cx.ident_of(*s))),\n+        Some(ref s) => Some(@cx.lifetime(span, cx.ident_of(*s))),\n         None => None\n     }\n }\n \n-pub impl Ty {\n-    fn to_ty(&self, cx: @ext_ctxt, span: span,\n+pub impl<'self> Ty<'self> {\n+    fn to_ty(&self, cx: @ExtCtxt, span: span,\n              self_ty: ident, self_generics: &Generics) -> @ast::Ty {\n         match *self {\n             Ptr(ref ty, ref ptr) => {\n                 let raw_ty = ty.to_ty(cx, span, self_ty, self_generics);\n                 match *ptr {\n                     Owned => {\n-                        build::mk_ty_uniq(cx, span, raw_ty)\n+                        cx.ty_uniq(span, raw_ty)\n                     }\n                     Managed(mutbl) => {\n-                        build::mk_ty_box(cx, span, raw_ty, mutbl)\n+                        cx.ty_box(span, raw_ty, mutbl)\n                     }\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = mk_lifetime(cx, span, lt);\n-                        build::mk_ty_rptr(cx, span, raw_ty, lt, mutbl)\n+                        cx.ty_rptr(span, raw_ty, lt, mutbl)\n                     }\n                 }\n             }\n             Literal(ref p) => { p.to_ty(cx, span, self_ty, self_generics) }\n             Self  => {\n-                build::mk_ty_path_path(cx, span, self.to_path(cx, span, self_ty, self_generics))\n+                cx.ty_path(self.to_path(cx, span, self_ty, self_generics))\n             }\n             Tuple(ref fields) => {\n                 let ty = if fields.is_empty() {\n@@ -143,26 +136,26 @@ pub impl Ty {\n                     ast::ty_tup(fields.map(|f| f.to_ty(cx, span, self_ty, self_generics)))\n                 };\n \n-                build::mk_ty(cx, span, ty)\n+                cx.ty(span, ty)\n             }\n         }\n     }\n \n-    fn to_path(&self, cx: @ext_ctxt, span: span,\n+    fn to_path(&self, cx: @ExtCtxt, span: span,\n                self_ty: ident, self_generics: &Generics) -> @ast::Path {\n         match *self {\n             Self => {\n                 let self_params = do self_generics.ty_params.map |ty_param| {\n-                    build::mk_ty_path(cx, span, ~[ ty_param.ident ])\n+                    cx.ty_ident(span, ty_param.ident)\n                 };\n                 let lifetime = if self_generics.lifetimes.is_empty() {\n                     None\n                 } else {\n                     Some(@*self_generics.lifetimes.get(0))\n                 };\n \n-                build::mk_raw_path_(span, ~[self_ty], lifetime,\n-                                    opt_vec::take_vec(self_params))\n+                cx.path_all(span, false, ~[self_ty], lifetime,\n+                            opt_vec::take_vec(self_params))\n             }\n             Literal(ref p) => {\n                 p.to_path(cx, span, self_ty, self_generics)\n@@ -174,14 +167,14 @@ pub impl Ty {\n }\n \n \n-fn mk_ty_param(cx: @ext_ctxt, span: span, name: ~str, bounds: ~[Path],\n+fn mk_ty_param(cx: @ExtCtxt, span: span, name: &str, bounds: &[Path],\n                self_ident: ident, self_generics: &Generics) -> ast::TyParam {\n     let bounds = opt_vec::from(\n         do bounds.map |b| {\n             let path = b.to_path(cx, span, self_ident, self_generics);\n-            build::mk_trait_ty_param_bound_(cx, path)\n+            cx.typarambound(path)\n         });\n-    build::mk_ty_param(cx, cx.ident_of(name), @bounds)\n+    cx.typaram(cx.ident_of(name), @bounds)\n }\n \n fn mk_generics(lifetimes: ~[ast::Lifetime],  ty_params: ~[ast::TyParam]) -> Generics {\n@@ -192,33 +185,37 @@ fn mk_generics(lifetimes: ~[ast::Lifetime],  ty_params: ~[ast::TyParam]) -> Gene\n }\n \n /// Lifetimes and bounds on type parameters\n-pub struct LifetimeBounds {\n-    lifetimes: ~[~str],\n-    bounds: ~[(~str, ~[Path])]\n+pub struct LifetimeBounds<'self> {\n+    lifetimes: ~[&'self str],\n+    bounds: ~[(&'self str, ~[Path<'self>])]\n }\n \n-pub impl LifetimeBounds {\n-    fn empty() -> LifetimeBounds {\n+pub impl<'self> LifetimeBounds<'self> {\n+    fn empty() -> LifetimeBounds<'static> {\n         LifetimeBounds {\n             lifetimes: ~[], bounds: ~[]\n         }\n     }\n-    fn to_generics(&self, cx: @ext_ctxt, span: span,\n+    fn to_generics(&self, cx: @ExtCtxt, span: span,\n                    self_ty: ident, self_generics: &Generics) -> Generics {\n-        let lifetimes = do self.lifetimes.map |&lt| {\n-            build::mk_lifetime(cx, span, cx.ident_of(lt))\n+        let lifetimes = do self.lifetimes.map |lt| {\n+            cx.lifetime(span, cx.ident_of(*lt))\n         };\n-        let ty_params = do self.bounds.map |&(name, bounds)| {\n-            mk_ty_param(cx, span, name, bounds, self_ty, self_generics)\n+        let ty_params = do self.bounds.map |t| {\n+            match t {\n+                &(ref name, ref bounds) => {\n+                    mk_ty_param(cx, span, *name, *bounds, self_ty, self_generics)\n+                }\n+            }\n         };\n         mk_generics(lifetimes, ty_params)\n     }\n }\n \n \n-pub fn get_explicit_self(cx: @ext_ctxt, span: span, self_ptr: &Option<PtrTy>)\n+pub fn get_explicit_self(cx: @ExtCtxt, span: span, self_ptr: &Option<PtrTy>)\n     -> (@expr, ast::explicit_self) {\n-    let self_path = build::make_self(cx, span);\n+    let self_path = cx.expr_self(span);\n     match *self_ptr {\n         None => {\n             (self_path, respan(span, ast::sty_value))\n@@ -230,12 +227,12 @@ pub fn get_explicit_self(cx: @ext_ctxt, span: span, self_ptr: &Option<PtrTy>)\n                     Owned => ast::sty_uniq(ast::m_imm),\n                     Managed(mutbl) => ast::sty_box(mutbl),\n                     Borrowed(ref lt, mutbl) => {\n-                        let lt = lt.map(|s| @build::mk_lifetime(cx, span,\n-                                                                cx.ident_of(*s)));\n+                        let lt = lt.map(|s| @cx.lifetime(span,\n+                                                         cx.ident_of(*s)));\n                         ast::sty_region(lt, mutbl)\n                     }\n                 });\n-            let self_expr = build::mk_deref(cx, span, self_path);\n+            let self_expr = cx.expr_deref(span, self_path);\n             (self_expr, self_ty)\n         }\n     }"}, {"sha": "32fbc9139998ee32bb8ed5748311cb3e0ed1d270", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -18,9 +18,9 @@ use ast;\n use codemap::span;\n use ext::base::*;\n use ext::base;\n-use ext::build::mk_base_str;\n+use ext::build::AstBuilder;\n \n-pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n \n     let var = get_single_str_from_tts(cx, sp, tts, \"env!\");\n@@ -29,8 +29,8 @@ pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     // Option<str> rather than just an maybe-empty string.\n \n     let e = match os::getenv(var) {\n-      None => mk_base_str(cx, sp, ~\"\"),\n-      Some(ref s) => mk_base_str(cx, sp, copy *s)\n+      None => cx.expr_str(sp, ~\"\"),\n+      Some(ref s) => cx.expr_str(sp, copy *s)\n     };\n     MRExpr(e)\n }"}, {"sha": "b993162cfa3dd3ca05e0ca69de9f52804ccffd68", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -23,7 +23,7 @@ use parse;\n use parse::{parse_item_from_source_str};\n \n pub fn expand_expr(extsbox: @mut SyntaxEnv,\n-                   cx: @ext_ctxt,\n+                   cx: @ExtCtxt,\n                    e: &expr_,\n                    s: span,\n                    fld: @ast_fold,\n@@ -109,7 +109,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n // NB: there is some redundancy between this and expand_item, below, and\n // they might benefit from some amount of semantic and language-UI merger.\n pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n-                        cx: @ext_ctxt,\n+                        cx: @ExtCtxt,\n                         module_: &ast::_mod,\n                         fld: @ast_fold,\n                         orig: @fn(&ast::_mod, @ast_fold) -> ast::_mod)\n@@ -161,7 +161,7 @@ macro_rules! with_exts_frame (\n \n // When we enter a module, record it, for the sake of `module!`\n pub fn expand_item(extsbox: @mut SyntaxEnv,\n-                   cx: @ext_ctxt,\n+                   cx: @ExtCtxt,\n                    it: @ast::item,\n                    fld: @ast_fold,\n                    orig: @fn(@ast::item, @ast_fold) -> Option<@ast::item>)\n@@ -227,7 +227,7 @@ macro_rules! without_macro_scoping(\n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n-                       cx: @ext_ctxt, it: @ast::item,\n+                       cx: @ExtCtxt, it: @ast::item,\n                        fld: @ast_fold)\n                     -> Option<@ast::item> {\n     let (pth, tts) = match it.node {\n@@ -294,7 +294,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n \n // expand a stmt\n pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n-                   cx: @ext_ctxt,\n+                   cx: @ExtCtxt,\n                    s: &stmt_,\n                    sp: span,\n                    fld: @ast_fold,\n@@ -360,7 +360,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n \n \n pub fn expand_block(extsbox: @mut SyntaxEnv,\n-                    cx: @ext_ctxt,\n+                    cx: @ExtCtxt,\n                     blk: &blk_,\n                     sp: span,\n                     fld: @ast_fold,\n@@ -381,7 +381,7 @@ pub fn expand_block(extsbox: @mut SyntaxEnv,\n     }\n }\n \n-pub fn new_span(cx: @ext_ctxt, sp: span) -> span {\n+pub fn new_span(cx: @ExtCtxt, sp: span) -> span {\n     /* this discards information in the case of macro-defining macros */\n     return span {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n }\n@@ -590,7 +590,7 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n     // every method/element of AstFoldFns in fold.rs.\n     let extsbox = @mut syntax_expander_table();\n     let afp = default_ast_fold();\n-    let cx: @ext_ctxt = mk_ctxt(parse_sess, copy cfg);\n+    let cx = ExtCtxt::new(parse_sess, copy cfg);\n     let f_pre = @AstFoldFns {\n         fold_expr: |expr,span,recur|\n             expand_expr(extsbox, cx, expr, span, recur, afp.fold_expr),"}, {"sha": "55d3d4ee8349dfc820f062a60d8660ca902f2fde", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 40, "deletions": 51, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -18,12 +18,11 @@ use ast;\n use codemap::span;\n use ext::base::*;\n use ext::base;\n-use ext::build;\n-use ext::build::*;\n+use ext::build::AstBuilder;\n \n use core::unstable::extfmt::ct::*;\n \n-pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let args = get_exprs_from_tts(cx, tts);\n     if args.len() == 0 {\n@@ -34,7 +33,7 @@ pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n                     ~\"first argument to fmt! must be a string literal.\");\n     let fmtspan = args[0].span;\n     debug!(\"Format string: %s\", fmt);\n-    fn parse_fmt_err_(cx: @ext_ctxt, sp: span, msg: &str) -> ! {\n+    fn parse_fmt_err_(cx: @ExtCtxt, sp: span, msg: &str) -> ! {\n         cx.span_fatal(sp, msg);\n     }\n     let parse_fmt_err: @fn(&str) -> ! = |s| parse_fmt_err_(cx, fmtspan, s);\n@@ -46,23 +45,23 @@ pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n // probably be factored out in common with other code that builds\n // expressions.  Also: Cleanup the naming of these functions.\n // Note: Moved many of the common ones to build.rs --kevina\n-fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n+fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                   pieces: ~[Piece], args: ~[@ast::expr])\n    -> @ast::expr {\n-    fn make_path_vec(cx: @ext_ctxt, ident: &str) -> ~[ast::ident] {\n+    fn make_path_vec(cx: @ExtCtxt, ident: &str) -> ~[ast::ident] {\n         let intr = cx.parse_sess().interner;\n         return ~[intr.intern(\"unstable\"), intr.intern(\"extfmt\"),\n                  intr.intern(\"rt\"), intr.intern(ident)];\n     }\n-    fn make_rt_path_expr(cx: @ext_ctxt, sp: span, nm: &str) -> @ast::expr {\n+    fn make_rt_path_expr(cx: @ExtCtxt, sp: span, nm: &str) -> @ast::expr {\n         let path = make_path_vec(cx, nm);\n-        return mk_path_global(cx, sp, path);\n+        cx.expr_path(cx.path_global(sp, path))\n     }\n     // Produces an AST expression that represents a RT::conv record,\n     // which tells the RT::conv* functions how to perform the conversion\n \n-    fn make_rt_conv_expr(cx: @ext_ctxt, sp: span, cnv: &Conv) -> @ast::expr {\n-        fn make_flags(cx: @ext_ctxt, sp: span, flags: &[Flag]) -> @ast::expr {\n+    fn make_rt_conv_expr(cx: @ExtCtxt, sp: span, cnv: &Conv) -> @ast::expr {\n+        fn make_flags(cx: @ExtCtxt, sp: span, flags: &[Flag]) -> @ast::expr {\n             let mut tmp_expr = make_rt_path_expr(cx, sp, \"flag_none\");\n             for flags.each |f| {\n                 let fstr = match *f {\n@@ -72,26 +71,26 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n                   FlagSignAlways => \"flag_sign_always\",\n                   FlagAlternate => \"flag_alternate\"\n                 };\n-                tmp_expr = mk_binary(cx, sp, ast::bitor, tmp_expr,\n-                                     make_rt_path_expr(cx, sp, fstr));\n+                tmp_expr = cx.expr_binary(sp, ast::bitor, tmp_expr,\n+                                          make_rt_path_expr(cx, sp, fstr));\n             }\n             return tmp_expr;\n         }\n-        fn make_count(cx: @ext_ctxt, sp: span, cnt: Count) -> @ast::expr {\n+        fn make_count(cx: @ExtCtxt, sp: span, cnt: Count) -> @ast::expr {\n             match cnt {\n               CountImplied => {\n                 return make_rt_path_expr(cx, sp, \"CountImplied\");\n               }\n               CountIs(c) => {\n-                let count_lit = mk_uint(cx, sp, c as uint);\n+                let count_lit = cx.expr_uint(sp, c as uint);\n                 let count_is_path = make_path_vec(cx, \"CountIs\");\n                 let count_is_args = ~[count_lit];\n-                return mk_call_global(cx, sp, count_is_path, count_is_args);\n+                return cx.expr_call_global(sp, count_is_path, count_is_args);\n               }\n               _ => cx.span_unimpl(sp, \"unimplemented fmt! conversion\")\n             }\n         }\n-        fn make_ty(cx: @ext_ctxt, sp: span, t: Ty) -> @ast::expr {\n+        fn make_ty(cx: @ExtCtxt, sp: span, t: Ty) -> @ast::expr {\n             let rt_type = match t {\n               TyHex(c) => match c {\n                 CaseUpper =>  \"TyHexUpper\",\n@@ -103,27 +102,18 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n             };\n             return make_rt_path_expr(cx, sp, rt_type);\n         }\n-        fn make_conv_struct(cx: @ext_ctxt, sp: span, flags_expr: @ast::expr,\n+        fn make_conv_struct(cx: @ExtCtxt, sp: span, flags_expr: @ast::expr,\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n             let intr = cx.parse_sess().interner;\n-            mk_global_struct_e(\n-                cx,\n+            cx.expr_struct(\n                 sp,\n-                make_path_vec(cx, \"Conv\"),\n+                cx.path_global(sp, make_path_vec(cx, \"Conv\")),\n                 ~[\n-                    build::Field {\n-                        ident: intr.intern(\"flags\"), ex: flags_expr\n-                    },\n-                    build::Field {\n-                        ident: intr.intern(\"width\"), ex: width_expr\n-                    },\n-                    build::Field {\n-                        ident: intr.intern(\"precision\"), ex: precision_expr\n-                    },\n-                    build::Field {\n-                        ident: intr.intern(\"ty\"), ex: ty_expr\n-                    },\n+                    cx.field_imm(sp, intr.intern(\"flags\"), flags_expr),\n+                    cx.field_imm(sp, intr.intern(\"width\"), width_expr),\n+                    cx.field_imm(sp, intr.intern(\"precision\"), precision_expr),\n+                    cx.field_imm(sp, intr.intern(\"ty\"), ty_expr)\n                 ]\n             )\n         }\n@@ -134,16 +124,16 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n         make_conv_struct(cx, sp, rt_conv_flags, rt_conv_width,\n                          rt_conv_precision, rt_conv_ty)\n     }\n-    fn make_conv_call(cx: @ext_ctxt, sp: span, conv_type: &str, cnv: &Conv,\n+    fn make_conv_call(cx: @ExtCtxt, sp: span, conv_type: &str, cnv: &Conv,\n                       arg: @ast::expr, buf: @ast::expr) -> @ast::expr {\n         let fname = ~\"conv_\" + conv_type;\n         let path = make_path_vec(cx, fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n         let args = ~[cnv_expr, arg, buf];\n-        return mk_call_global(cx, arg.span, path, args);\n+        cx.expr_call_global(arg.span, path, args)\n     }\n \n-    fn make_new_conv(cx: @ext_ctxt, sp: span, cnv: &Conv,\n+    fn make_new_conv(cx: @ExtCtxt, sp: span, cnv: &Conv,\n                      arg: @ast::expr, buf: @ast::expr) -> @ast::expr {\n         fn is_signed_type(cnv: &Conv) -> bool {\n             match cnv.ty {\n@@ -198,10 +188,10 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n             TyChar => (\"char\", arg),\n             TyBits | TyOctal | TyHex(_) | TyInt(Unsigned) => (\"uint\", arg),\n             TyFloat => (\"float\", arg),\n-            TyPoly => (\"poly\", mk_addr_of(cx, sp, arg))\n+            TyPoly => (\"poly\", cx.expr_addr_of(sp, arg))\n         };\n         return make_conv_call(cx, arg.span, name, cnv, actual_arg,\n-                              mk_mut_addr_of(cx, arg.span, buf));\n+                              cx.expr_mut_addr_of(arg.span, buf));\n     }\n     fn log_conv(c: &Conv) {\n         debug!(\"Building conversion:\");\n@@ -259,7 +249,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n \n     /* 'ident' is the local buffer building up the result of fmt! */\n     let ident = cx.parse_sess().interner.intern(\"__fmtbuf\");\n-    let buf = || mk_path(cx, fmt_sp, ~[ident]);\n+    let buf = || cx.expr_ident(fmt_sp, ident);\n     let str_ident = cx.parse_sess().interner.intern(\"str\");\n     let push_ident = cx.parse_sess().interner.intern(\"push_str\");\n     let mut stms = ~[];\n@@ -276,14 +266,14 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n                    buffer with it directly. If it's actually the only piece,\n                    then there's no need for it to be mutable */\n                 if i == 0 {\n-                    stms.push(mk_local(cx, fmt_sp, npieces > 1, ident, mk_uniq_str(cx, fmt_sp, s)));\n+                    stms.push(cx.stmt_let(fmt_sp, npieces > 1,\n+                                          ident, cx.expr_str_uniq(fmt_sp, s)));\n                 } else {\n-                    let args = ~[mk_mut_addr_of(cx, fmt_sp, buf()), mk_base_str(cx, fmt_sp, s)];\n-                    let call = mk_call_global(cx,\n-                                              fmt_sp,\n-                                              ~[str_ident, push_ident],\n-                                              args);\n-                    stms.push(mk_stmt(cx, fmt_sp, call));\n+                    let args = ~[cx.expr_mut_addr_of(fmt_sp, buf()), cx.expr_str(fmt_sp, s)];\n+                    let call = cx.expr_call_global(fmt_sp,\n+                                                   ~[str_ident, push_ident],\n+                                                   args);\n+                    stms.push(cx.stmt_expr(call));\n                 }\n             }\n \n@@ -300,12 +290,11 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n                 /* If the first portion is a conversion, then the local buffer\n                    must be initialized as an empty string */\n                 if i == 0 {\n-                    stms.push(mk_local(cx, fmt_sp, true, ident,\n-                                       mk_uniq_str(cx, fmt_sp, ~\"\")));\n+                    stms.push(cx.stmt_let(fmt_sp, true, ident,\n+                                          cx.expr_str_uniq(fmt_sp, ~\"\")));\n                 }\n-                stms.push(mk_stmt(cx, fmt_sp,\n-                                  make_new_conv(cx, fmt_sp, conv,\n-                                                args[n], buf())));\n+                stms.push(cx.stmt_expr(make_new_conv(cx, fmt_sp, conv,\n+                                                     args[n], buf())));\n             }\n         }\n     }\n@@ -317,5 +306,5 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n                            nargs, expected_nargs));\n     }\n \n-    return mk_block(cx, fmt_sp, ~[], stms, Some(buf()));\n+    cx.expr_blk(cx.blk(fmt_sp, stms, Some(buf())))\n }"}, {"sha": "a3f6fb8e97d219836697a198663e6ff3d42793b9", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -14,7 +14,7 @@ use ext::base::*;\n use ext::base;\n use print;\n \n-pub fn expand_syntax_ext(cx: @ext_ctxt,\n+pub fn expand_syntax_ext(cx: @ExtCtxt,\n                          sp: codemap::span,\n                          tt: &[ast::token_tree])\n                       -> base::MacResult {"}, {"sha": "1f2e3f06a731009f6de2682d8a51161593e0e617", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 2, "deletions": 382, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -13,16 +13,10 @@\n // To start with, it will be use dummy spans, but it might someday do\n // something smarter.\n \n-use abi::AbiSet;\n use ast::ident;\n use ast;\n-use ast_util;\n-use codemap::{span, respan, dummy_sp, spanned};\n-use codemap;\n-use ext::base::ext_ctxt;\n-use ext::quote::rt::*;\n-use opt_vec;\n-use opt_vec::OptVec;\n+use codemap::span;\n+// use ext::quote::rt::*;\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n@@ -66,377 +60,3 @@ impl append_types for @ast::Path {\n         }\n     }\n }\n-\n-pub trait ext_ctxt_ast_builder {\n-    fn ty_param(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>)\n-        -> ast::TyParam;\n-    fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg;\n-    fn expr_block(&self, e: @ast::expr) -> ast::blk;\n-    fn fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n-    fn item(&self, name: ident, span: span, node: ast::item_) -> @ast::item;\n-    fn item_fn_poly(&self,\n-                    ame: ident,\n-                    inputs: ~[ast::arg],\n-                    output: @ast::Ty,\n-                    generics: Generics,\n-                    body: ast::blk) -> @ast::item;\n-    fn item_fn(&self,\n-               name: ident,\n-               inputs: ~[ast::arg],\n-               output: @ast::Ty,\n-               body: ast::blk) -> @ast::item;\n-    fn item_enum_poly(&self,\n-                      name: ident,\n-                      span: span,\n-                      enum_definition: ast::enum_def,\n-                      generics: Generics) -> @ast::item;\n-    fn item_enum(&self,\n-                 name: ident,\n-                 span: span,\n-                 enum_definition: ast::enum_def) -> @ast::item;\n-    fn item_struct_poly(&self,\n-                        name: ident,\n-                        span: span,\n-                        struct_def: ast::struct_def,\n-                        generics: Generics) -> @ast::item;\n-    fn item_struct(&self,\n-                   name: ident,\n-                   span: span,\n-                   struct_def: ast::struct_def) -> @ast::item;\n-    fn struct_expr(&self,\n-                   path: @ast::Path,\n-                   fields: ~[ast::field]) -> @ast::expr;\n-    fn variant(&self,\n-               name: ident,\n-               span: span,\n-               tys: ~[@ast::Ty]) -> ast::variant;\n-    fn item_mod(&self,\n-                name: ident,\n-                span: span,\n-                items: ~[@ast::item]) -> @ast::item;\n-    fn ty_path_ast_builder(&self, path: @ast::Path) -> @ast::Ty;\n-    fn item_ty_poly(&self,\n-                    name: ident,\n-                    span: span,\n-                    ty: @ast::Ty,\n-                    generics: Generics) -> @ast::item;\n-    fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item;\n-    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n-    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n-    fn ty_field_imm(&self, name: ident, ty: @ast::Ty) -> ast::ty_field;\n-    fn field_imm(&self, name: ident, e: @ast::expr) -> ast::field;\n-    fn block(&self, stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk;\n-    fn stmt_let(&self, ident: ident, e: @ast::expr) -> @ast::stmt;\n-    fn stmt_expr(&self, e: @ast::expr) -> @ast::stmt;\n-    fn block_expr(&self, b: ast::blk) -> @ast::expr;\n-    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty;\n-    fn ty_infer(&self) -> @ast::Ty;\n-    fn ty_nil_ast_builder(&self) -> @ast::Ty;\n-    fn strip_bounds(&self, bounds: &Generics) -> Generics;\n-}\n-\n-impl ext_ctxt_ast_builder for @ext_ctxt {\n-    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty {\n-        self.ty_path_ast_builder(path_global(~[\n-            self.ident_of(\"core\"),\n-            self.ident_of(\"option\"),\n-            self.ident_of(\"Option\")\n-        ], dummy_sp()).add_ty(ty))\n-    }\n-\n-    fn block_expr(&self, b: ast::blk) -> @ast::expr {\n-        @expr {\n-            id: self.next_id(),\n-            callee_id: self.next_id(),\n-            node: ast::expr_block(b),\n-            span: dummy_sp(),\n-        }\n-    }\n-\n-    fn stmt_expr(&self, e: @ast::expr) -> @ast::stmt {\n-        @spanned { node: ast::stmt_expr(e, self.next_id()),\n-                   span: dummy_sp()}\n-    }\n-\n-    fn stmt_let(&self, ident: ident, e: @ast::expr) -> @ast::stmt {\n-        let ext_cx = *self;\n-        quote_stmt!( let $ident = $e; )\n-    }\n-\n-    fn field_imm(&self, name: ident, e: @ast::expr) -> ast::field {\n-        spanned {\n-            node: ast::field_ { mutbl: ast::m_imm, ident: name, expr: e },\n-            span: dummy_sp(),\n-        }\n-    }\n-\n-    fn ty_field_imm(&self, name: ident, ty: @ast::Ty) -> ast::ty_field {\n-        spanned {\n-            node: ast::ty_field_ {\n-                ident: name,\n-                mt: ast::mt { ty: ty, mutbl: ast::m_imm },\n-            },\n-            span: dummy_sp(),\n-        }\n-    }\n-\n-    fn ty_infer(&self) -> @ast::Ty {\n-        @ast::Ty {\n-            id: self.next_id(),\n-            node: ast::ty_infer,\n-            span: dummy_sp(),\n-        }\n-    }\n-\n-    fn ty_param(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>)\n-        -> ast::TyParam\n-    {\n-        ast::TyParam { ident: id, id: self.next_id(), bounds: bounds }\n-    }\n-\n-    fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg {\n-        ast::arg {\n-            is_mutbl: false,\n-            ty: ty,\n-            pat: @ast::pat {\n-                id: self.next_id(),\n-                node: ast::pat_ident(\n-                    ast::bind_by_copy,\n-                    ast_util::ident_to_path(dummy_sp(), name),\n-                    None),\n-                span: dummy_sp(),\n-            },\n-            id: self.next_id(),\n-        }\n-    }\n-\n-    fn block(&self, stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk {\n-        let blk = ast::blk_ {\n-            view_items: ~[],\n-            stmts: stmts,\n-            expr: Some(e),\n-            id: self.next_id(),\n-            rules: ast::default_blk,\n-        };\n-\n-        spanned { node: blk, span: dummy_sp() }\n-    }\n-\n-    fn expr_block(&self, e: @ast::expr) -> ast::blk {\n-        self.block(~[], e)\n-    }\n-\n-    fn fn_decl(&self, inputs: ~[ast::arg],\n-               output: @ast::Ty) -> ast::fn_decl {\n-        ast::fn_decl {\n-            inputs: inputs,\n-            output: output,\n-            cf: ast::return_val,\n-        }\n-    }\n-\n-    fn item(&self, name: ident, span: span,\n-            node: ast::item_) -> @ast::item {\n-\n-        // XXX: Would be nice if our generated code didn't violate\n-        // Rust coding conventions\n-        let non_camel_case_attribute = respan(dummy_sp(), ast::attribute_ {\n-            style: ast::attr_outer,\n-            value: @respan(dummy_sp(),\n-                          ast::meta_list(@~\"allow\", ~[\n-                              @respan(dummy_sp(),\n-                                      ast::meta_word(\n-                                         @~\"non_camel_case_types\"))\n-                          ])),\n-            is_sugared_doc: false\n-        });\n-\n-        @ast::item { ident: name,\n-                     attrs: ~[non_camel_case_attribute],\n-                     id: self.next_id(),\n-                     node: node,\n-                     vis: ast::public,\n-                     span: span }\n-    }\n-\n-    fn item_fn_poly(&self, name: ident,\n-                    inputs: ~[ast::arg],\n-                    output: @ast::Ty,\n-                    generics: Generics,\n-                    body: ast::blk) -> @ast::item {\n-        self.item(name,\n-                  dummy_sp(),\n-                  ast::item_fn(self.fn_decl(inputs, output),\n-                               ast::impure_fn,\n-                               AbiSet::Rust(),\n-                               generics,\n-                               body))\n-    }\n-\n-    fn item_fn(&self,\n-               name: ident,\n-               inputs: ~[ast::arg],\n-               output: @ast::Ty,\n-               body: ast::blk\n-    ) -> @ast::item {\n-        self.item_fn_poly(\n-            name,\n-            inputs,\n-            output,\n-            ast_util::empty_generics(),\n-            body\n-        )\n-    }\n-\n-    fn item_enum_poly(&self, name: ident, span: span,\n-                      enum_definition: ast::enum_def,\n-                      generics: Generics) -> @ast::item {\n-        self.item(name, span, ast::item_enum(enum_definition, generics))\n-    }\n-\n-    fn item_enum(&self, name: ident, span: span,\n-                 enum_definition: ast::enum_def) -> @ast::item {\n-        self.item_enum_poly(name, span, enum_definition,\n-                            ast_util::empty_generics())\n-    }\n-\n-    fn item_struct(\n-        &self, name: ident,\n-        span: span,\n-        struct_def: ast::struct_def\n-    ) -> @ast::item {\n-        self.item_struct_poly(\n-            name,\n-            span,\n-            struct_def,\n-            ast_util::empty_generics()\n-        )\n-    }\n-\n-    fn item_struct_poly(\n-        &self,\n-        name: ident,\n-        span: span,\n-        struct_def: ast::struct_def,\n-        generics: Generics\n-    ) -> @ast::item {\n-        self.item(name, span, ast::item_struct(@struct_def, generics))\n-    }\n-\n-    fn struct_expr(&self, path: @ast::Path,\n-                   fields: ~[ast::field]) -> @ast::expr {\n-        @ast::expr {\n-            id: self.next_id(),\n-            callee_id: self.next_id(),\n-            node: ast::expr_struct(path, fields, None),\n-            span: dummy_sp()\n-        }\n-    }\n-\n-    fn variant(&self, name: ident, span: span,\n-               tys: ~[@ast::Ty]) -> ast::variant {\n-        let args = do tys.map |ty| {\n-            ast::variant_arg { ty: *ty, id: self.next_id() }\n-        };\n-\n-        spanned {\n-            node: ast::variant_ {\n-                name: name,\n-                attrs: ~[],\n-                kind: ast::tuple_variant_kind(args),\n-                id: self.next_id(),\n-                disr_expr: None,\n-                vis: ast::public\n-            },\n-            span: span,\n-        }\n-    }\n-\n-    fn item_mod(&self, name: ident, span: span,\n-                items: ~[@ast::item]) -> @ast::item {\n-\n-        // XXX: Total hack: import `core::kinds::Owned` to work around a\n-        // parser bug whereby `fn f<T:::kinds::Owned>` doesn't parse.\n-        let vi = ast::view_item_use(~[\n-            @codemap::spanned {\n-                node: ast::view_path_simple(\n-                    self.ident_of(\"Owned\"),\n-                    path(\n-                        ~[\n-                            self.ident_of(\"core\"),\n-                            self.ident_of(\"kinds\"),\n-                            self.ident_of(\"Owned\")\n-                        ],\n-                        codemap::dummy_sp()\n-                    ),\n-                    self.next_id()\n-                ),\n-                span: codemap::dummy_sp()\n-            }\n-        ]);\n-        let vi = @ast::view_item {\n-            node: vi,\n-            attrs: ~[],\n-            vis: ast::private,\n-            span: codemap::dummy_sp()\n-        };\n-\n-        self.item(\n-            name,\n-            span,\n-            ast::item_mod(ast::_mod {\n-                view_items: ~[vi],\n-                items: items,\n-            })\n-        )\n-    }\n-\n-    fn ty_path_ast_builder(&self, path: @ast::Path) -> @ast::Ty {\n-        @ast::Ty {\n-            id: self.next_id(),\n-            node: ast::ty_path(path, self.next_id()),\n-            span: path.span,\n-        }\n-    }\n-\n-    fn ty_nil_ast_builder(&self) -> @ast::Ty {\n-        @ast::Ty {\n-            id: self.next_id(),\n-            node: ast::ty_nil,\n-            span: dummy_sp(),\n-        }\n-    }\n-\n-    fn strip_bounds(&self, generics: &Generics) -> Generics {\n-        let no_bounds = @opt_vec::Empty;\n-        let new_params = do generics.ty_params.map |ty_param| {\n-            ast::TyParam { bounds: no_bounds, ..copy *ty_param }\n-        };\n-        Generics {\n-            ty_params: new_params,\n-            .. copy *generics\n-        }\n-    }\n-\n-    fn item_ty_poly(&self, name: ident, span: span, ty: @ast::Ty,\n-                    generics: Generics) -> @ast::item {\n-        self.item(name, span, ast::item_ty(ty, generics))\n-    }\n-\n-    fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item {\n-        self.item_ty_poly(name, span, ty, ast_util::empty_generics())\n-    }\n-\n-    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n-        opt_vec::take_vec(\n-            ty_params.map(|p| self.ty_path_ast_builder(\n-                path(~[p.ident], dummy_sp()))))\n-    }\n-\n-    fn ty_vars_global(&self,\n-                      ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n-        opt_vec::take_vec(\n-            ty_params.map(|p| self.ty_path_ast_builder(\n-                path(~[p.ident], dummy_sp()))))\n-    }\n-}"}, {"sha": "c0b7f5bbb84263f6e0faa2e6dd44ca5c4132a8be", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -31,11 +31,11 @@ that.\n \n use ast;\n use codemap::span;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::pipes::proto::{state, protocol, next_state};\n use ext::pipes::proto;\n \n-impl proto::visitor<(), (), ()> for @ext_ctxt {\n+impl proto::visitor<(), (), ()> for @ExtCtxt {\n     fn visit_proto(&self, _proto: protocol, _states: &[()]) { }\n \n     fn visit_state(&self, state: state, _m: &[()]) {"}, {"sha": "8d45e47d54ef75c207340d1f819e0a666188a7d5", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -37,12 +37,12 @@ updating the states using rule (2) until there are no changes.\n \n */\n \n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::pipes::proto::{protocol_};\n \n use std::bitv::Bitv;\n \n-pub fn analyze(proto: @mut protocol_, _cx: @ext_ctxt) {\n+pub fn analyze(proto: @mut protocol_, _cx: @ExtCtxt) {\n     debug!(\"initializing colive analysis\");\n     let num_states = proto.num_states();\n     let mut colive = do (copy proto.states).map_to_vec |state| {"}, {"sha": "46de21d1c0b2e7069d26f0a8751c535aafda6a83", "filename": "src/libsyntax/ext/pipes/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -46,7 +46,7 @@ FIXME (#3072) - This is still incomplete.\n use ast;\n use codemap::span;\n use ext::base;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::pipes::parse_proto::proto_parser;\n use ext::pipes::pipec::gen_init;\n use ext::pipes::proto::visit;\n@@ -63,7 +63,7 @@ pub mod check;\n pub mod liveness;\n \n \n-pub fn expand_proto(cx: @ext_ctxt, _sp: span, id: ast::ident,\n+pub fn expand_proto(cx: @ExtCtxt, _sp: span, id: ast::ident,\n                     tt: ~[ast::token_tree]) -> base::MacResult {\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();"}, {"sha": "0482dffe6d44c59c308a95b5231eccb0fd264825", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 93, "deletions": 75, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -12,36 +12,37 @@\n \n use ast;\n use codemap::{dummy_sp, spanned};\n-use ext::base::ext_ctxt;\n-use ext::pipes::ast_builder::{append_types, ext_ctxt_ast_builder, path};\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n+use ext::pipes::ast_builder::{append_types, path};\n use ext::pipes::ast_builder::{path_global};\n use ext::pipes::proto::*;\n use ext::quote::rt::*;\n use opt_vec;\n use opt_vec::OptVec;\n \n pub trait gen_send {\n-    fn gen_send(&mut self, cx: @ext_ctxt, try: bool) -> @ast::item;\n-    fn to_ty(&mut self, cx: @ext_ctxt) -> @ast::Ty;\n+    fn gen_send(&mut self, cx: @ExtCtxt, try: bool) -> @ast::item;\n+    fn to_ty(&mut self, cx: @ExtCtxt) -> @ast::Ty;\n }\n \n pub trait to_type_decls {\n-    fn to_type_decls(&self, cx: @ext_ctxt) -> ~[@ast::item];\n-    fn to_endpoint_decls(&self, cx: @ext_ctxt,\n+    fn to_type_decls(&self, cx: @ExtCtxt) -> ~[@ast::item];\n+    fn to_endpoint_decls(&self, cx: @ExtCtxt,\n                          dir: direction) -> ~[@ast::item];\n }\n \n pub trait gen_init {\n-    fn gen_init(&self, cx: @ext_ctxt) -> @ast::item;\n-    fn compile(&self, cx: @ext_ctxt) -> @ast::item;\n-    fn buffer_ty_path(&self, cx: @ext_ctxt) -> @ast::Ty;\n-    fn gen_buffer_type(&self, cx: @ext_ctxt) -> @ast::item;\n-    fn gen_buffer_init(&self, ext_cx: @ext_ctxt) -> @ast::expr;\n-    fn gen_init_bounded(&self, ext_cx: @ext_ctxt) -> @ast::expr;\n+    fn gen_init(&self, cx: @ExtCtxt) -> @ast::item;\n+    fn compile(&self, cx: @ExtCtxt) -> @ast::item;\n+    fn buffer_ty_path(&self, cx: @ExtCtxt) -> @ast::Ty;\n+    fn gen_buffer_type(&self, cx: @ExtCtxt) -> @ast::item;\n+    fn gen_buffer_init(&self, ext_cx: @ExtCtxt) -> @ast::expr;\n+    fn gen_init_bounded(&self, ext_cx: @ExtCtxt) -> @ast::expr;\n }\n \n impl gen_send for message {\n-    fn gen_send(&mut self, cx: @ext_ctxt, try: bool) -> @ast::item {\n+    fn gen_send(&mut self, cx: @ExtCtxt, try: bool) -> @ast::item {\n         debug!(\"pipec: gen_send\");\n         let name = self.name();\n \n@@ -52,14 +53,13 @@ impl gen_send for message {\n             assert!(next_state.tys.len() ==\n                 next.generics.ty_params.len());\n             let arg_names = tys.mapi(|i, _ty| cx.ident_of(~\"x_\"+i.to_str()));\n-            let args_ast = vec::map_zip(arg_names, *tys, |n, t| cx.arg(*n, *t));\n+            let args_ast = vec::map_zip(arg_names, *tys, |n, t| cx.arg(span, *n, *t));\n \n-            let pipe_ty = cx.ty_path_ast_builder(\n+            let pipe_ty = cx.ty_path(\n                 path(~[this.data_name()], span)\n-                .add_tys(cx.ty_vars_global(&this.generics.ty_params)));\n+                .add_tys(cx.ty_vars(&this.generics.ty_params)));\n             let args_ast = vec::append(\n-                ~[cx.arg(cx.ident_of(\"pipe\"),\n-                              pipe_ty)],\n+                ~[cx.arg(span, cx.ident_of(\"pipe\"), pipe_ty)],\n                 args_ast);\n \n             let mut body = ~\"{\\n\";\n@@ -111,35 +111,37 @@ impl gen_send for message {\n \n             let body = cx.parse_expr(body);\n \n-            let mut rty = cx.ty_path_ast_builder(path(~[next.data_name()],\n-                                                      span)\n-                                               .add_tys(copy next_state.tys));\n+            let mut rty = cx.ty_path(path(~[next.data_name()],\n+                                          span)\n+                                     .add_tys(copy next_state.tys));\n             if try {\n                 rty = cx.ty_option(rty);\n             }\n \n             let name = cx.ident_of(if try { ~\"try_\" + name } else { name } );\n \n-            cx.item_fn_poly(name,\n+            cx.item_fn_poly(dummy_sp(),\n+                            name,\n                             args_ast,\n                             rty,\n                             self.get_generics(),\n-                            cx.expr_block(body))\n+                            cx.blk_expr(body))\n           }\n \n             message(ref _id, span, ref tys, this, None) => {\n                 debug!(\"pipec: no next state\");\n                 let arg_names = tys.mapi(|i, _ty| (~\"x_\" + i.to_str()));\n \n                 let args_ast = do vec::map_zip(arg_names, *tys) |n, t| {\n-                    cx.arg(cx.ident_of(*n), *t)\n+                    cx.arg(span, cx.ident_of(*n), *t)\n                 };\n \n                 let args_ast = vec::append(\n-                    ~[cx.arg(cx.ident_of(\"pipe\"),\n-                             cx.ty_path_ast_builder(\n+                    ~[cx.arg(span,\n+                             cx.ident_of(\"pipe\"),\n+                             cx.ty_path(\n                                  path(~[this.data_name()], span)\n-                                 .add_tys(cx.ty_vars_global(\n+                                 .add_tys(cx.ty_vars(\n                                      &this.generics.ty_params))))],\n                     args_ast);\n \n@@ -171,27 +173,28 @@ impl gen_send for message {\n \n                 let name = if try { ~\"try_\" + name } else { name };\n \n-                cx.item_fn_poly(cx.ident_of(name),\n+                cx.item_fn_poly(dummy_sp(),\n+                                cx.ident_of(name),\n                                 args_ast,\n                                 if try {\n-                                    cx.ty_option(cx.ty_nil_ast_builder())\n+                                    cx.ty_option(cx.ty_nil())\n                                 } else {\n-                                    cx.ty_nil_ast_builder()\n+                                    cx.ty_nil()\n                                 },\n                                 self.get_generics(),\n-                                cx.expr_block(body))\n+                                cx.blk_expr(body))\n             }\n           }\n         }\n \n-    fn to_ty(&mut self, cx: @ext_ctxt) -> @ast::Ty {\n-        cx.ty_path_ast_builder(path(~[cx.ident_of(self.name())], self.span())\n-          .add_tys(cx.ty_vars_global(&self.get_generics().ty_params)))\n+    fn to_ty(&mut self, cx: @ExtCtxt) -> @ast::Ty {\n+        cx.ty_path(path(~[cx.ident_of(self.name())], self.span())\n+          .add_tys(cx.ty_vars(&self.get_generics().ty_params)))\n     }\n }\n \n impl to_type_decls for state {\n-    fn to_type_decls(&self, cx: @ext_ctxt) -> ~[@ast::item] {\n+    fn to_type_decls(&self, cx: @ExtCtxt) -> ~[@ast::item] {\n         debug!(\"pipec: to_type_decls\");\n         // This compiles into two different type declarations. Say the\n         // state is called ping. This will generate both `ping` and\n@@ -217,30 +220,30 @@ impl to_type_decls for state {\n                 };\n \n                 vec::append_one(tys,\n-                                cx.ty_path_ast_builder(\n+                                cx.ty_path(\n                                     path(~[cx.ident_of(dir),\n                                            cx.ident_of(next_name)], span)\n                                     .add_tys(copy next_state.tys)))\n               }\n               None => tys\n             };\n \n-            let v = cx.variant(cx.ident_of(name), span, tys);\n+            let v = cx.variant(span, cx.ident_of(name), tys);\n \n             items_msg.push(v);\n         }\n \n         ~[\n             cx.item_enum_poly(\n-                name,\n                 self.span,\n+                name,\n                 ast::enum_def { variants: items_msg },\n                 cx.strip_bounds(&self.generics)\n             )\n         ]\n     }\n \n-    fn to_endpoint_decls(&self, cx: @ext_ctxt,\n+    fn to_endpoint_decls(&self, cx: @ExtCtxt,\n                          dir: direction) -> ~[@ast::item] {\n         debug!(\"pipec: to_endpoint_decls\");\n         let dir = match dir {\n@@ -262,33 +265,33 @@ impl to_type_decls for state {\n         if !self.proto.is_bounded() {\n             items.push(\n                 cx.item_ty_poly(\n-                    self.data_name(),\n                     self.span,\n-                    cx.ty_path_ast_builder(\n+                    self.data_name(),\n+                    cx.ty_path(\n                         path_global(~[cx.ident_of(\"core\"),\n                                       cx.ident_of(\"pipes\"),\n                                       cx.ident_of(dir.to_str() + \"Packet\")],\n                              dummy_sp())\n-                        .add_ty(cx.ty_path_ast_builder(\n+                        .add_ty(cx.ty_path(\n                             path(~[cx.ident_of(\"super\"),\n                                    self.data_name()],\n                                  dummy_sp())\n-                            .add_tys(cx.ty_vars_global(\n+                            .add_tys(cx.ty_vars(\n                                 &self.generics.ty_params))))),\n                     cx.strip_bounds(&self.generics)));\n         }\n         else {\n             items.push(\n                 cx.item_ty_poly(\n-                    self.data_name(),\n                     self.span,\n-                    cx.ty_path_ast_builder(\n+                    self.data_name(),\n+                    cx.ty_path(\n                         path_global(~[cx.ident_of(\"core\"),\n                                       cx.ident_of(\"pipes\"),\n                                       cx.ident_of(dir.to_str()\n                                                   + \"PacketBuffered\")],\n                              dummy_sp())\n-                        .add_tys(~[cx.ty_path_ast_builder(\n+                        .add_tys(~[cx.ty_path(\n                             path(~[cx.ident_of(\"super\"),\n                                    self.data_name()],\n                                         dummy_sp())\n@@ -302,7 +305,7 @@ impl to_type_decls for state {\n }\n \n impl gen_init for protocol {\n-    fn gen_init(&self, cx: @ext_ctxt) -> @ast::item {\n+    fn gen_init(&self, cx: @ExtCtxt) -> @ast::item {\n         let ext_cx = cx;\n \n         debug!(\"gen_init\");\n@@ -340,35 +343,39 @@ impl gen_init for protocol {\n                            body.to_source(cx)))\n     }\n \n-    fn gen_buffer_init(&self, ext_cx: @ext_ctxt) -> @ast::expr {\n-        ext_cx.struct_expr(path(~[ext_cx.ident_of(\"__Buffer\")],\n-                                dummy_sp()),\n-                      self.states.map_to_vec(|s| {\n-            let fty = s.to_ty(ext_cx);\n-            ext_cx.field_imm(ext_cx.ident_of(s.name),\n-                             quote_expr!(\n-                                 ::core::pipes::mk_packet::<$fty>()\n-                             ))\n-        }))\n+    fn gen_buffer_init(&self, ext_cx: @ExtCtxt) -> @ast::expr {\n+        ext_cx.expr_struct(\n+            dummy_sp(),\n+            path(~[ext_cx.ident_of(\"__Buffer\")],\n+                 dummy_sp()),\n+            self.states.map_to_vec(|s| {\n+                let fty = s.to_ty(ext_cx);\n+                ext_cx.field_imm(dummy_sp(),\n+                                 ext_cx.ident_of(s.name),\n+                                 quote_expr!(\n+                                     ::core::pipes::mk_packet::<$fty>()\n+                                 ))\n+            }))\n     }\n \n-    fn gen_init_bounded(&self, ext_cx: @ext_ctxt) -> @ast::expr {\n+    fn gen_init_bounded(&self, ext_cx: @ExtCtxt) -> @ast::expr {\n         debug!(\"gen_init_bounded\");\n         let buffer_fields = self.gen_buffer_init(ext_cx);\n         let buffer = quote_expr!(~::core::pipes::Buffer {\n             header: ::core::pipes::BufferHeader(),\n             data: $buffer_fields,\n         });\n \n-        let entangle_body = ext_cx.block_expr(\n-            ext_cx.block(\n+        let entangle_body = ext_cx.expr_blk(\n+            ext_cx.blk(\n+                dummy_sp(),\n                 self.states.map_to_vec(\n                     |s| ext_cx.parse_stmt(\n                         fmt!(\"data.%s.set_buffer(buffer)\",\n                              s.name))),\n-                ext_cx.parse_expr(fmt!(\n+                Some(ext_cx.parse_expr(fmt!(\n                     \"::core::ptr::to_mut_unsafe_ptr(&mut (data.%s))\",\n-                    self.states[0].name))));\n+                    self.states[0].name)))));\n \n         quote_expr!({\n             let buffer = $buffer;\n@@ -378,7 +385,7 @@ impl gen_init for protocol {\n         })\n     }\n \n-    fn buffer_ty_path(&self, cx: @ext_ctxt) -> @ast::Ty {\n+    fn buffer_ty_path(&self, cx: @ExtCtxt) -> @ast::Ty {\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n         for (copy self.states).each |s| {\n             for s.generics.ty_params.each |tp| {\n@@ -389,13 +396,13 @@ impl gen_init for protocol {\n             }\n         }\n \n-        cx.ty_path_ast_builder(path(~[cx.ident_of(\"super\"),\n-                                      cx.ident_of(\"__Buffer\")],\n-                                    copy self.span)\n-                               .add_tys(cx.ty_vars_global(&params)))\n+        cx.ty_path(path(~[cx.ident_of(\"super\"),\n+                          cx.ident_of(\"__Buffer\")],\n+                        copy self.span)\n+                   .add_tys(cx.ty_vars_global(&params)))\n     }\n \n-    fn gen_buffer_type(&self, cx: @ext_ctxt) -> @ast::item {\n+    fn gen_buffer_type(&self, cx: @ExtCtxt) -> @ast::item {\n         let ext_cx = cx;\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n         let fields = do (copy self.states).map_to_vec |s| {\n@@ -427,16 +434,16 @@ impl gen_init for protocol {\n         };\n \n         cx.item_struct_poly(\n-            cx.ident_of(\"__Buffer\"),\n             dummy_sp(),\n+            cx.ident_of(\"__Buffer\"),\n             ast::struct_def {\n                 fields: fields,\n                 ctor_id: None\n             },\n             cx.strip_bounds(&generics))\n     }\n \n-    fn compile(&self, cx: @ext_ctxt) -> @ast::item {\n+    fn compile(&self, cx: @ExtCtxt) -> @ast::item {\n         let mut items = ~[self.gen_init(cx)];\n         let mut client_states = ~[];\n         let mut server_states = ~[];\n@@ -452,13 +459,24 @@ impl gen_init for protocol {\n             items.push(self.gen_buffer_type(cx))\n         }\n \n-        items.push(cx.item_mod(cx.ident_of(\"client\"),\n-                               copy self.span,\n+        items.push(cx.item_mod(copy self.span,\n+                               cx.ident_of(\"client\"),\n+                               ~[], ~[],\n                                client_states));\n-        items.push(cx.item_mod(cx.ident_of(\"server\"),\n-                               copy self.span,\n+        items.push(cx.item_mod(copy self.span,\n+                               cx.ident_of(\"server\"),\n+                               ~[], ~[],\n                                server_states));\n \n-        cx.item_mod(cx.ident_of(copy self.name), copy self.span, items)\n+        // XXX: Would be nice if our generated code didn't violate\n+        // Rust coding conventions\n+        let allows = cx.attribute(\n+            copy self.span,\n+            cx.meta_list(copy self.span,\n+                         ~\"allow\",\n+                         ~[cx.meta_word(copy self.span, ~\"non_camel_case_types\"),\n+                           cx.meta_word(copy self.span, ~\"unused_mut\")]));\n+        cx.item_mod(copy self.span, cx.ident_of(copy self.name),\n+                    ~[allows], ~[], items)\n     }\n }"}, {"sha": "4471c5bb9b855b91aaef8bd99f67fcf67f40fa4d", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -10,8 +10,9 @@\n \n use ast;\n use codemap::span;\n-use ext::base::ext_ctxt;\n-use ext::pipes::ast_builder::{append_types, ext_ctxt_ast_builder, path};\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n+use ext::pipes::ast_builder::{append_types, path};\n \n #[deriving(Eq)]\n pub enum direction { send, recv }\n@@ -92,8 +93,8 @@ pub impl state_ {\n     }\n \n     /// Returns the type that is used for the messages.\n-    fn to_ty(&self, cx: @ext_ctxt) -> @ast::Ty {\n-        cx.ty_path_ast_builder\n+    fn to_ty(&self, cx: @ExtCtxt) -> @ast::Ty {\n+        cx.ty_path\n             (path(~[cx.ident_of(self.name)],self.span).add_tys(\n                 cx.ty_vars(&self.generics.ty_params)))\n     }"}, {"sha": "1c57d500c221ab36018cd37669ecff9e753417f2", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 169, "deletions": 183, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -10,9 +10,9 @@\n \n use ast;\n use codemap::{BytePos, Pos, span};\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::base;\n-use ext::build;\n+use ext::build::AstBuilder;\n use parse::token::*;\n use parse::token;\n use parse;\n@@ -30,7 +30,7 @@ use parse;\n \n pub mod rt {\n     use ast;\n-    use ext::base::ext_ctxt;\n+    use ext::base::ExtCtxt;\n     use parse;\n     use print::pprust;\n \n@@ -44,11 +44,11 @@ pub mod rt {\n     use print::pprust::{item_to_str, ty_to_str};\n \n     pub trait ToTokens {\n-        pub fn to_tokens(&self, _cx: @ext_ctxt) -> ~[token_tree];\n+        pub fn to_tokens(&self, _cx: @ExtCtxt) -> ~[token_tree];\n     }\n \n     impl ToTokens for ~[token_tree] {\n-        pub fn to_tokens(&self, _cx: @ext_ctxt) -> ~[token_tree] {\n+        pub fn to_tokens(&self, _cx: @ExtCtxt) -> ~[token_tree] {\n             copy *self\n         }\n     }\n@@ -57,10 +57,10 @@ pub mod rt {\n \n     trait ToSource : ToTokens {\n         // Takes a thing and generates a string containing rust code for it.\n-        pub fn to_source(cx: @ext_ctxt) -> ~str;\n+        pub fn to_source(cx: @ExtCtxt) -> ~str;\n \n         // If you can make source, you can definitely make tokens.\n-        pub fn to_tokens(cx: @ext_ctxt) -> ~[token_tree] {\n+        pub fn to_tokens(cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n@@ -69,130 +69,130 @@ pub mod rt {\n \n     pub trait ToSource {\n         // Takes a thing and generates a string containing rust code for it.\n-        pub fn to_source(&self, cx: @ext_ctxt) -> ~str;\n+        pub fn to_source(&self, cx: @ExtCtxt) -> ~str;\n     }\n \n     impl ToSource for ast::ident {\n-        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n             copy *cx.parse_sess().interner.get(*self)\n         }\n     }\n \n     impl ToSource for @ast::item {\n-        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n             item_to_str(*self, cx.parse_sess().interner)\n         }\n     }\n \n     impl<'self> ToSource for &'self [@ast::item] {\n-        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n             str::connect(self.map(|i| i.to_source(cx)), \"\\n\\n\")\n         }\n     }\n \n     impl ToSource for @ast::Ty {\n-        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n             ty_to_str(*self, cx.parse_sess().interner)\n         }\n     }\n \n     impl<'self> ToSource for &'self [@ast::Ty] {\n-        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n             str::connect(self.map(|i| i.to_source(cx)), \", \")\n         }\n     }\n \n     impl ToSource for Generics {\n-        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n             pprust::generics_to_str(self, cx.parse_sess().interner)\n         }\n     }\n \n     impl ToSource for @ast::expr {\n-        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n             pprust::expr_to_str(*self, cx.parse_sess().interner)\n         }\n     }\n \n     impl ToSource for ast::blk {\n-        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n             pprust::block_to_str(self, cx.parse_sess().interner)\n         }\n     }\n \n     impl<'self> ToSource for &'self str {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_str(@str::to_owned(*self)));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for int {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for i8 {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i8));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for i16 {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i16));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n \n     impl ToSource for i32 {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i32));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for i64 {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i64));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for uint {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for u8 {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u8));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for u16 {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u16));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for u32 {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u32));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for u64 {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u64));\n             pprust::lit_to_str(@lit)\n         }\n@@ -201,115 +201,115 @@ pub mod rt {\n     // Alas ... we write these out instead. All redundant.\n \n     impl ToTokens for ast::ident {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for @ast::item {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl<'self> ToTokens for &'self [@ast::item] {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for @ast::Ty {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl<'self> ToTokens for &'self [@ast::Ty] {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for Generics {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for @ast::expr {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for ast::blk {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl<'self> ToTokens for &'self str {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for int {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for i8 {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for i16 {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for i32 {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for i64 {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for uint {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for u8 {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for u16 {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for u32 {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for u64 {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n@@ -321,7 +321,7 @@ pub mod rt {\n         fn parse_tts(&self, s: ~str) -> ~[ast::token_tree];\n     }\n \n-    impl ExtParseUtils for @ext_ctxt {\n+    impl ExtParseUtils for ExtCtxt {\n \n         fn parse_item(&self, s: ~str) -> @ast::item {\n             let res = parse::parse_item_from_source_str(\n@@ -367,74 +367,74 @@ pub mod rt {\n \n }\n \n-pub fn expand_quote_tokens(cx: @ext_ctxt,\n+pub fn expand_quote_tokens(cx: @ExtCtxt,\n                            sp: span,\n                            tts: &[ast::token_tree]) -> base::MacResult {\n     base::MRExpr(expand_tts(cx, sp, tts))\n }\n \n-pub fn expand_quote_expr(cx: @ext_ctxt,\n+pub fn expand_quote_expr(cx: @ExtCtxt,\n                          sp: span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_expr\", ~[], tts))\n }\n \n-pub fn expand_quote_item(cx: @ext_ctxt,\n+pub fn expand_quote_item(cx: @ExtCtxt,\n                          sp: span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n-    let e_attrs = build::mk_uniq_vec_e(cx, sp, ~[]);\n+    let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_item\",\n                                     ~[e_attrs], tts))\n }\n \n-pub fn expand_quote_pat(cx: @ext_ctxt,\n+pub fn expand_quote_pat(cx: @ExtCtxt,\n                         sp: span,\n                         tts: &[ast::token_tree]) -> base::MacResult {\n-    let e_refutable = build::mk_lit(cx, sp, ast::lit_bool(true));\n+    let e_refutable = cx.expr_lit(sp, ast::lit_bool(true));\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_pat\",\n                                     ~[e_refutable], tts))\n }\n \n-pub fn expand_quote_ty(cx: @ext_ctxt,\n+pub fn expand_quote_ty(cx: @ExtCtxt,\n                        sp: span,\n                        tts: &[ast::token_tree]) -> base::MacResult {\n-    let e_param_colons = build::mk_lit(cx, sp, ast::lit_bool(false));\n+    let e_param_colons = cx.expr_lit(sp, ast::lit_bool(false));\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_ty\",\n                                     ~[e_param_colons], tts))\n }\n \n-pub fn expand_quote_stmt(cx: @ext_ctxt,\n+pub fn expand_quote_stmt(cx: @ExtCtxt,\n                          sp: span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n-    let e_attrs = build::mk_uniq_vec_e(cx, sp, ~[]);\n+    let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_stmt\",\n                                     ~[e_attrs], tts))\n }\n \n-fn ids_ext(cx: @ext_ctxt, strs: ~[~str]) -> ~[ast::ident] {\n+fn ids_ext(cx: @ExtCtxt, strs: ~[~str]) -> ~[ast::ident] {\n     strs.map(|str| cx.parse_sess().interner.intern(*str))\n }\n \n-fn id_ext(cx: @ext_ctxt, str: &str) -> ast::ident {\n+fn id_ext(cx: @ExtCtxt, str: &str) -> ast::ident {\n     cx.parse_sess().interner.intern(str)\n }\n \n // Lift an ident to the expr that evaluates to that ident.\n-fn mk_ident(cx: @ext_ctxt, sp: span, ident: ast::ident) -> @ast::expr {\n-    let e_str = build::mk_base_str(cx, sp, cx.str_of(ident));\n-    build::mk_method_call(cx, sp,\n-                          build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n-                          id_ext(cx, \"ident_of\"),\n-                          ~[e_str])\n+fn mk_ident(cx: @ExtCtxt, sp: span, ident: ast::ident) -> @ast::expr {\n+    let e_str = cx.expr_str(sp, cx.str_of(ident));\n+    cx.expr_method_call(sp,\n+                        cx.expr_ident(sp, id_ext(cx, \"ext_cx\")),\n+                        id_ext(cx, \"ident_of\"),\n+                        ~[e_str])\n }\n \n-fn mk_bytepos(cx: @ext_ctxt, sp: span, bpos: BytePos) -> @ast::expr {\n-    let path = ids_ext(cx, ~[~\"BytePos\"]);\n-    let arg = build::mk_uint(cx, sp, bpos.to_uint());\n-    build::mk_call(cx, sp, path, ~[arg])\n+fn mk_bytepos(cx: @ExtCtxt, sp: span, bpos: BytePos) -> @ast::expr {\n+    let path = id_ext(cx, \"BytePos\");\n+    let arg = cx.expr_uint(sp, bpos.to_uint());\n+    cx.expr_call_ident(sp, path, ~[arg])\n }\n \n-fn mk_binop(cx: @ext_ctxt, sp: span, bop: token::binop) -> @ast::expr {\n+fn mk_binop(cx: @ExtCtxt, sp: span, bop: token::binop) -> @ast::expr {\n     let name = match bop {\n         PLUS => \"PLUS\",\n         MINUS => \"MINUS\",\n@@ -447,22 +447,21 @@ fn mk_binop(cx: @ext_ctxt, sp: span, bop: token::binop) -> @ast::expr {\n         SHL => \"SHL\",\n         SHR => \"SHR\"\n     };\n-    build::mk_path(cx, sp,\n-                   ids_ext(cx, ~[name.to_owned()]))\n+    cx.expr_ident(sp, id_ext(cx, name))\n }\n \n-fn mk_token(cx: @ext_ctxt, sp: span, tok: &token::Token) -> @ast::expr {\n+fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n \n     match *tok {\n         BINOP(binop) => {\n-            return build::mk_call(cx, sp,\n-                                  ids_ext(cx, ~[~\"BINOP\"]),\n-                                  ~[mk_binop(cx, sp, binop)]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"BINOP\"),\n+                                      ~[mk_binop(cx, sp, binop)]);\n         }\n         BINOPEQ(binop) => {\n-            return build::mk_call(cx, sp,\n-                                  ids_ext(cx, ~[~\"BINOPEQ\"]),\n-                                  ~[mk_binop(cx, sp, binop)]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"BINOPEQ\"),\n+                                      ~[mk_binop(cx, sp, binop)]);\n         }\n \n         LIT_INT(i, ity) => {\n@@ -474,15 +473,13 @@ fn mk_token(cx: @ext_ctxt, sp: span, tok: &token::Token) -> @ast::expr {\n                 ast::ty_i32 => ~\"ty_i32\",\n                 ast::ty_i64 => ~\"ty_i64\"\n             };\n-            let e_ity =\n-                build::mk_path(cx, sp,\n-                               ids_ext(cx, ~[s_ity]));\n+            let e_ity = cx.expr_ident(sp, id_ext(cx, s_ity));\n \n-            let e_i64 = build::mk_lit(cx, sp, ast::lit_int(i, ast::ty_i64));\n+            let e_i64 = cx.expr_lit(sp, ast::lit_int(i, ast::ty_i64));\n \n-            return build::mk_call(cx, sp,\n-                                  ids_ext(cx, ~[~\"LIT_INT\"]),\n-                                  ~[e_i64, e_ity]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"LIT_INT\"),\n+                                      ~[e_i64, e_ity]);\n         }\n \n         LIT_UINT(u, uty) => {\n@@ -493,24 +490,21 @@ fn mk_token(cx: @ext_ctxt, sp: span, tok: &token::Token) -> @ast::expr {\n                 ast::ty_u32 => ~\"ty_u32\",\n                 ast::ty_u64 => ~\"ty_u64\"\n             };\n-            let e_uty =\n-                build::mk_path(cx, sp,\n-                               ids_ext(cx, ~[s_uty]));\n+            let e_uty = cx.expr_ident(sp, id_ext(cx, s_uty));\n \n-            let e_u64 = build::mk_lit(cx, sp, ast::lit_uint(u, ast::ty_u64));\n+            let e_u64 = cx.expr_lit(sp, ast::lit_uint(u, ast::ty_u64));\n \n-            return build::mk_call(cx, sp,\n-                                  ids_ext(cx, ~[~\"LIT_UINT\"]),\n-                                  ~[e_u64, e_uty]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"LIT_UINT\"),\n+                                      ~[e_u64, e_uty]);\n         }\n \n         LIT_INT_UNSUFFIXED(i) => {\n-            let e_i64 = build::mk_lit(cx, sp,\n-                                      ast::lit_int(i, ast::ty_i64));\n+            let e_i64 = cx.expr_lit(sp, ast::lit_int(i, ast::ty_i64));\n \n-            return build::mk_call(cx, sp,\n-                                  ids_ext(cx, ~[~\"LIT_INT_UNSUFFIXED\"]),\n-                                  ~[e_i64]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"LIT_INT_UNSUFFIXED\"),\n+                                      ~[e_i64]);\n         }\n \n         LIT_FLOAT(fident, fty) => {\n@@ -519,40 +513,38 @@ fn mk_token(cx: @ext_ctxt, sp: span, tok: &token::Token) -> @ast::expr {\n                 ast::ty_f32 => ~\"ty_f32\",\n                 ast::ty_f64 => ~\"ty_f64\"\n             };\n-            let e_fty =\n-                build::mk_path(cx, sp,\n-                               ids_ext(cx, ~[s_fty]));\n+            let e_fty = cx.expr_ident(sp, id_ext(cx, s_fty));\n \n             let e_fident = mk_ident(cx, sp, fident);\n \n-            return build::mk_call(cx, sp,\n-                                  ids_ext(cx, ~[~\"LIT_FLOAT\"]),\n-                                  ~[e_fident, e_fty]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"LIT_FLOAT\"),\n+                                      ~[e_fident, e_fty]);\n         }\n \n         LIT_STR(ident) => {\n-            return build::mk_call(cx, sp,\n-                                  ids_ext(cx, ~[~\"LIT_STR\"]),\n-                                  ~[mk_ident(cx, sp, ident)]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"LIT_STR\"),\n+                                      ~[mk_ident(cx, sp, ident)]);\n         }\n \n         IDENT(ident, b) => {\n-            return build::mk_call(cx, sp,\n-                                  ids_ext(cx, ~[~\"IDENT\"]),\n-                                  ~[mk_ident(cx, sp, ident),\n-                                    build::mk_lit(cx, sp, ast::lit_bool(b))]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"IDENT\"),\n+                                      ~[mk_ident(cx, sp, ident),\n+                                        cx.expr_bool(sp, b)]);\n         }\n \n         LIFETIME(ident) => {\n-            return build::mk_call(cx, sp,\n-                                  ids_ext(cx, ~[~\"LIFETIME\"]),\n-                                  ~[mk_ident(cx, sp, ident)]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"LIFETIME\"),\n+                                      ~[mk_ident(cx, sp, ident)]);\n         }\n \n         DOC_COMMENT(ident) => {\n-            return build::mk_call(cx, sp,\n-                                  ids_ext(cx, ~[~\"DOC_COMMENT\"]),\n-                                  ~[mk_ident(cx, sp, ident)]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"DOC_COMMENT\"),\n+                                      ~[mk_ident(cx, sp, ident)]);\n         }\n \n         INTERPOLATED(_) => fail!(\"quote! with interpolated token\"),\n@@ -595,30 +587,26 @@ fn mk_token(cx: @ext_ctxt, sp: span, tok: &token::Token) -> @ast::expr {\n         EOF => \"EOF\",\n         _ => fail!()\n     };\n-    build::mk_path(cx, sp,\n-                   ids_ext(cx, ~[name.to_owned()]))\n+    cx.expr_ident(sp, id_ext(cx, name))\n }\n \n \n-fn mk_tt(cx: @ext_ctxt, sp: span, tt: &ast::token_tree)\n+fn mk_tt(cx: @ExtCtxt, sp: span, tt: &ast::token_tree)\n     -> ~[@ast::stmt] {\n \n     match *tt {\n \n         ast::tt_tok(sp, ref tok) => {\n-            let e_sp = build::mk_path(cx, sp,\n-                                      ids_ext(cx, ~[~\"sp\"]));\n-            let e_tok =\n-                build::mk_call(cx, sp,\n-                               ids_ext(cx, ~[~\"tt_tok\"]),\n-                               ~[e_sp, mk_token(cx, sp, tok)]);\n+            let e_sp = cx.expr_ident(sp, id_ext(cx, \"sp\"));\n+            let e_tok = cx.expr_call_ident(sp,\n+                                           id_ext(cx, \"tt_tok\"),\n+                                           ~[e_sp, mk_token(cx, sp, tok)]);\n             let e_push =\n-                build::mk_method_call(cx, sp,\n-                                      build::mk_path(cx, sp, ids_ext(cx, ~[~\"tt\"])),\n-                                      id_ext(cx, \"push\"),\n-                                      ~[e_tok]);\n-            ~[build::mk_stmt(cx, sp, e_push)]\n-\n+                cx.expr_method_call(sp,\n+                                    cx.expr_ident(sp, id_ext(cx, \"tt\")),\n+                                    id_ext(cx, \"push\"),\n+                                    ~[e_tok]);\n+            ~[cx.stmt_expr(e_push)]\n         }\n \n         ast::tt_delim(ref tts) => mk_tts(cx, sp, *tts),\n@@ -629,24 +617,23 @@ fn mk_tt(cx: @ext_ctxt, sp: span, tt: &ast::token_tree)\n             // tt.push_all_move($ident.to_tokens(ext_cx))\n \n             let e_to_toks =\n-                build::mk_method_call(cx, sp,\n-                                      build::mk_path(cx, sp, ~[ident]),\n-                                      id_ext(cx, \"to_tokens\"),\n-                                      ~[build::mk_path(cx, sp,\n-                                                       ids_ext(cx, ~[~\"ext_cx\"]))]);\n+                cx.expr_method_call(sp,\n+                                    cx.expr_ident(sp, ident),\n+                                    id_ext(cx, \"to_tokens\"),\n+                                    ~[cx.expr_ident(sp, id_ext(cx, \"ext_cx\"))]);\n \n             let e_push =\n-                build::mk_method_call(cx, sp,\n-                                      build::mk_path(cx, sp, ids_ext(cx, ~[~\"tt\"])),\n-                                      id_ext(cx, \"push_all_move\"),\n-                                      ~[e_to_toks]);\n+                cx.expr_method_call(sp,\n+                                    cx.expr_ident(sp, id_ext(cx, \"tt\")),\n+                                    id_ext(cx, \"push_all_move\"),\n+                                    ~[e_to_toks]);\n \n-            ~[build::mk_stmt(cx, sp, e_push)]\n+            ~[cx.stmt_expr(e_push)]\n         }\n     }\n }\n \n-fn mk_tts(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+fn mk_tts(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> ~[@ast::stmt] {\n     let mut ss = ~[];\n     for tts.each |tt| {\n@@ -655,7 +642,7 @@ fn mk_tts(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     ss\n }\n \n-fn expand_tts(cx: @ext_ctxt,\n+fn expand_tts(cx: @ExtCtxt,\n               sp: span,\n               tts: &[ast::token_tree]) -> @ast::expr {\n \n@@ -677,11 +664,11 @@ fn expand_tts(cx: @ext_ctxt,\n     // We want to emit a block expression that does a sequence of 'use's to\n     // import the runtime module, followed by a tt-building expression.\n \n-    let uses = ~[ build::mk_glob_use(cx, sp, ast::public,\n-                                     ids_ext(cx, ~[~\"syntax\",\n-                                                   ~\"ext\",\n-                                                   ~\"quote\",\n-                                                   ~\"rt\"])) ];\n+    let uses = ~[ cx.view_use_glob(sp, ast::public,\n+                                   ids_ext(cx, ~[~\"syntax\",\n+                                                 ~\"ext\",\n+                                                 ~\"quote\",\n+                                                 ~\"rt\"])) ];\n \n     // We also bind a single value, sp, to ext_cx.call_site()\n     //\n@@ -709,54 +696,53 @@ fn expand_tts(cx: @ext_ctxt,\n     // of quotes, for example) but at this point it seems not likely to be\n     // worth the hassle.\n \n-    let e_sp = build::mk_method_call(cx, sp,\n-                                     build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n-                                     id_ext(cx, \"call_site\"),\n-                                     ~[]);\n+    let e_sp = cx.expr_method_call(sp,\n+                                   cx.expr_ident(sp, id_ext(cx, \"ext_cx\")),\n+                                   id_ext(cx, \"call_site\"),\n+                                   ~[]);\n \n-    let stmt_let_sp = build::mk_local(cx, sp, false,\n-                                      id_ext(cx, \"sp\"),\n-                                      e_sp);\n+    let stmt_let_sp = cx.stmt_let(sp, false,\n+                                  id_ext(cx, \"sp\"),\n+                                  e_sp);\n \n-    let stmt_let_tt = build::mk_local(cx, sp, true,\n-                                      id_ext(cx, \"tt\"),\n-                                      build::mk_uniq_vec_e(cx, sp, ~[]));\n+    let stmt_let_tt = cx.stmt_let(sp, true,\n+                                  id_ext(cx, \"tt\"),\n+                                  cx.expr_vec_uniq(sp, ~[]));\n \n-    build::mk_block(cx, sp, uses,\n-                    ~[stmt_let_sp,\n-                      stmt_let_tt] + mk_tts(cx, sp, tts),\n-                    Some(build::mk_path(cx, sp,\n-                                        ids_ext(cx, ~[~\"tt\"]))))\n+    cx.expr_blk(\n+        cx.blk_all(sp, uses,\n+                   ~[stmt_let_sp,\n+                     stmt_let_tt] + mk_tts(cx, sp, tts),\n+                   Some(cx.expr_ident(sp, id_ext(cx, \"tt\")))))\n }\n \n-fn expand_parse_call(cx: @ext_ctxt,\n+fn expand_parse_call(cx: @ExtCtxt,\n                      sp: span,\n                      parse_method: &str,\n                      arg_exprs: ~[@ast::expr],\n                      tts: &[ast::token_tree]) -> @ast::expr {\n     let tts_expr = expand_tts(cx, sp, tts);\n \n-    let cfg_call = || build::mk_method_call(\n-        cx, sp, build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n+    let cfg_call = || cx.expr_method_call(\n+        sp, cx.expr_ident(sp, id_ext(cx, \"ext_cx\")),\n         id_ext(cx, \"cfg\"), ~[]);\n \n-    let parse_sess_call = || build::mk_method_call(\n-        cx, sp, build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n+    let parse_sess_call = || cx.expr_method_call(\n+        sp, cx.expr_ident(sp, id_ext(cx, \"ext_cx\")),\n         id_ext(cx, \"parse_sess\"), ~[]);\n \n     let new_parser_call =\n-        build::mk_call_global(cx, sp,\n-                              ids_ext(cx, ~[~\"syntax\",\n-                                            ~\"ext\",\n-                                            ~\"quote\",\n-                                            ~\"rt\",\n-                                            ~\"new_parser_from_tts\"]),\n-                              ~[parse_sess_call(),\n-                                cfg_call(),\n-                                tts_expr]);\n-\n-    build::mk_method_call(cx, sp,\n-                          new_parser_call,\n-                          id_ext(cx, parse_method),\n-                          arg_exprs)\n+        cx.expr_call_global(sp,\n+                            ids_ext(cx, ~[~\"syntax\",\n+                                          ~\"ext\",\n+                                          ~\"quote\",\n+                                          ~\"rt\",\n+                                          ~\"new_parser_from_tts\"]),\n+                            ~[parse_sess_call(),\n+                              cfg_call(),\n+                              tts_expr]);\n+\n+    cx.expr_method_call(sp, new_parser_call,\n+                        id_ext(cx, parse_method),\n+                        arg_exprs)\n }"}, {"sha": "30e6b7cfc65c90b560b8dae364418bc2ba3f1752", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -14,7 +14,7 @@ use codemap::{FileMap, Loc, Pos, ExpandedFrom, span};\n use codemap::{CallInfo, NameAndSpan};\n use ext::base::*;\n use ext::base;\n-use ext::build::{mk_base_vec_e, mk_uint, mk_u8, mk_base_str};\n+use ext::build::AstBuilder;\n use parse;\n use print::pprust;\n \n@@ -23,57 +23,57 @@ use print::pprust;\n // a given file into the current one.\n \n /* line!(): expands to the current line number */\n-pub fn expand_line(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_line(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n     let topmost = topmost_expn_info(cx.backtrace().get());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n \n-    base::MRExpr(mk_uint(cx, topmost.call_site, loc.line))\n+    base::MRExpr(cx.expr_uint(topmost.call_site, loc.line))\n }\n \n /* col!(): expands to the current column number */\n-pub fn expand_col(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_col(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"col!\");\n \n     let topmost = topmost_expn_info(cx.backtrace().get());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n-    base::MRExpr(mk_uint(cx, topmost.call_site, loc.col.to_uint()))\n+    base::MRExpr(cx.expr_uint(topmost.call_site, loc.col.to_uint()))\n }\n \n /* file!(): expands to the current filename */\n /* The filemap (`loc.file`) contains a bunch more information we could spit\n  * out if we wanted. */\n-pub fn expand_file(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_file(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n     let topmost = topmost_expn_info(cx.backtrace().get());\n     let Loc { file: @FileMap { name: filename, _ }, _ } =\n         cx.codemap().lookup_char_pos(topmost.call_site.lo);\n-    base::MRExpr(mk_base_str(cx, topmost.call_site, filename))\n+    base::MRExpr(cx.expr_str(topmost.call_site, filename))\n }\n \n-pub fn expand_stringify(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_stringify(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let s = pprust::tts_to_str(tts, cx.parse_sess().interner);\n-    base::MRExpr(mk_base_str(cx, sp, s))\n+    base::MRExpr(cx.expr_str(sp, s))\n }\n \n-pub fn expand_mod(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_mod(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n-    base::MRExpr(mk_base_str(cx, sp,\n+    base::MRExpr(cx.expr_str(sp,\n                               str::connect(cx.mod_path().map(\n                                   |x| cx.str_of(*x)), \"::\")))\n }\n \n // include! : parse the given file as an expr\n // This is generally a bad idea because it's going to behave\n // unhygienically.\n-pub fn expand_include(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_include(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n     let p = parse::new_sub_parser_from_file(\n@@ -83,7 +83,7 @@ pub fn expand_include(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n }\n \n // include_str! : read the given file, insert it as a literal string expr\n-pub fn expand_include_str(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_include_str(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n     let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path(file)));\n@@ -94,18 +94,18 @@ pub fn expand_include_str(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n       }\n     }\n \n-    base::MRExpr(mk_base_str(cx, sp, result::unwrap(res)))\n+    base::MRExpr(cx.expr_str(sp, result::unwrap(res)))\n }\n \n-pub fn expand_include_bin(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_include_bin(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n     match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {\n       result::Ok(src) => {\n         let u8_exprs = vec::map(src, |char| {\n-            mk_u8(cx, sp, *char)\n+            cx.expr_u8(sp, *char)\n         });\n-        base::MRExpr(mk_base_vec_e(cx, sp, u8_exprs))\n+        base::MRExpr(cx.expr_vec(sp, u8_exprs))\n       }\n       result::Err(ref e) => {\n         cx.parse_sess().span_diagnostic.handler().fatal((*e))\n@@ -141,7 +141,7 @@ fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n \n // resolve a file-system path to an absolute file-system path (if it\n // isn't already)\n-fn res_rel_file(cx: @ext_ctxt, sp: codemap::span, arg: &Path) -> Path {\n+fn res_rel_file(cx: @ExtCtxt, sp: codemap::span, arg: &Path) -> Path {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !arg.is_absolute {\n         let cu = Path(cx.codemap().span_to_filename(sp));"}, {"sha": "25607a8bfa76fad419dff07c7be50e3a3d4b8441", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -10,12 +10,12 @@\n \n use ast;\n use codemap::span;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::base;\n use parse::lexer::{new_tt_reader, reader};\n use parse::parser::Parser;\n \n-pub fn expand_trace_macros(cx: @ext_ctxt,\n+pub fn expand_trace_macros(cx: @ExtCtxt,\n                            sp: span,\n                            tt: &[ast::token_tree])\n                         -> base::MacResult {"}, {"sha": "3814243efc4c6e058285300ec0cd317d2d45c433", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -13,7 +13,7 @@ use ast::{ident, matcher_, matcher, match_tok, match_nonterminal, match_seq};\n use ast::{tt_delim};\n use ast;\n use codemap::{span, spanned, dummy_sp};\n-use ext::base::{ext_ctxt, MacResult, MRAny, MRDef, MacroDef, NormalTT};\n+use ext::base::{ExtCtxt, MacResult, MRAny, MRDef, MacroDef, NormalTT};\n use ext::base;\n use ext::tt::macro_parser::{error};\n use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n@@ -26,7 +26,7 @@ use print;\n \n use core::io;\n \n-pub fn add_new_extension(cx: @ext_ctxt,\n+pub fn add_new_extension(cx: @ExtCtxt,\n                          sp: span,\n                          name: ident,\n                          arg: ~[ast::token_tree])\n@@ -73,7 +73,7 @@ pub fn add_new_extension(cx: @ext_ctxt,\n     };\n \n     // Given `lhses` and `rhses`, this is the new macro we create\n-    fn generic_extension(cx: @ext_ctxt, sp: span, name: ident,\n+    fn generic_extension(cx: @ExtCtxt, sp: span, name: ident,\n                          arg: &[ast::token_tree],\n                          lhses: &[@named_match], rhses: &[@named_match])\n     -> MacResult {\n@@ -145,7 +145,7 @@ pub fn add_new_extension(cx: @ext_ctxt,\n         cx.span_fatal(best_fail_spot, best_fail_msg);\n     }\n \n-    let exp: @fn(@ext_ctxt, span, &[ast::token_tree]) -> MacResult =\n+    let exp: @fn(@ExtCtxt, span, &[ast::token_tree]) -> MacResult =\n         |cx, sp, arg| generic_extension(cx, sp, name, arg, *lhses, *rhses);\n \n     return MRDef(MacroDef{"}, {"sha": "0cd416afc8316874fbd1f31aebdaa477fe088308", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64963d6cbaea86e0d2a58f507e57a76da7512e3e/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=64963d6cbaea86e0d2a58f507e57a76da7512e3e", "patch": "@@ -12,9 +12,9 @@\n \n extern mod syntax;\n \n-use syntax::ext::base::ext_ctxt;\n+use syntax::ext::base::ExtCtxt;\n \n-fn syntax_extension(ext_cx: @ext_ctxt) {\n+fn syntax_extension(ext_cx: @ExtCtxt) {\n     let e_toks : ~[syntax::ast::token_tree] = quote_tokens!(1 + 2);\n     let p_toks : ~[syntax::ast::token_tree] = quote_tokens!((x, 1 .. 4, *));\n "}]}