{"sha": "ca0c8395a00dcb57549fa1a8a407185b4a2a54c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMGM4Mzk1YTAwZGNiNTc1NDlmYTFhOGE0MDcxODViNGEyYTU0YzA=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2016-12-03T20:39:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-12-03T20:39:51Z"}, "message": "Rollup merge of #38028 - Mark-Simulacrum:polish, r=nikomatsakis\n\nRefactor one_bound_for_assoc_type to take an Iterator instead of Vec\n\nI doubt the performance implications will be serious, but it will avoid allocating one-element Vecs for the successful case (and avoid allocating vecs at all for any case, too).\n\n`--stage 2` tests passed locally.", "tree": {"sha": "3d6fbed1a780265325f1bdac4dc9d7068d559074", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d6fbed1a780265325f1bdac4dc9d7068d559074"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca0c8395a00dcb57549fa1a8a407185b4a2a54c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca0c8395a00dcb57549fa1a8a407185b4a2a54c0", "html_url": "https://github.com/rust-lang/rust/commit/ca0c8395a00dcb57549fa1a8a407185b4a2a54c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca0c8395a00dcb57549fa1a8a407185b4a2a54c0/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "468ca2c56a446dce31638b6bc23f3c91aa680714", "url": "https://api.github.com/repos/rust-lang/rust/commits/468ca2c56a446dce31638b6bc23f3c91aa680714", "html_url": "https://github.com/rust-lang/rust/commit/468ca2c56a446dce31638b6bc23f3c91aa680714"}, {"sha": "d21861dd89e2df8c567c97756d9cc18e39a5283f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d21861dd89e2df8c567c97756d9cc18e39a5283f", "html_url": "https://github.com/rust-lang/rust/commit/d21861dd89e2df8c567c97756d9cc18e39a5283f"}], "stats": {"total": 66, "additions": 33, "deletions": 33}, "files": [{"sha": "b5531b8bb9ec97e627f74645c0f0674e89489bca", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ca0c8395a00dcb57549fa1a8a407185b4a2a54c0/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0c8395a00dcb57549fa1a8a407185b4a2a54c0/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ca0c8395a00dcb57549fa1a8a407185b4a2a54c0", "patch": "@@ -884,10 +884,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // those that do.\n         self.ensure_super_predicates(binding.span, trait_ref.def_id())?;\n \n-        let candidates: Vec<ty::PolyTraitRef> =\n+        let candidates =\n             traits::supertraits(tcx, trait_ref.clone())\n-            .filter(|r| self.trait_defines_associated_type_named(r.def_id(), binding.item_name))\n-            .collect();\n+            .filter(|r| self.trait_defines_associated_type_named(r.def_id(), binding.item_name));\n \n         let candidate = self.one_bound_for_assoc_type(candidates,\n                                                       &trait_ref.to_string(),\n@@ -1191,10 +1190,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // Check that there is exactly one way to find an associated type with the\n         // correct name.\n-        let suitable_bounds: Vec<_> =\n+        let suitable_bounds =\n             traits::transitive_bounds(tcx, &bounds)\n-            .filter(|b| self.trait_defines_associated_type_named(b.def_id(), assoc_name))\n-            .collect();\n+            .filter(|b| self.trait_defines_associated_type_named(b.def_id(), assoc_name));\n \n         self.one_bound_for_assoc_type(suitable_bounds,\n                                       &ty_param_name.as_str(),\n@@ -1205,54 +1203,57 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     // Checks that bounds contains exactly one element and reports appropriate\n     // errors otherwise.\n-    fn one_bound_for_assoc_type(&self,\n-                                bounds: Vec<ty::PolyTraitRef<'tcx>>,\n+    fn one_bound_for_assoc_type<I>(&self,\n+                                mut bounds: I,\n                                 ty_param_name: &str,\n                                 assoc_name: &str,\n                                 span: Span)\n         -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n+        where I: Iterator<Item=ty::PolyTraitRef<'tcx>>\n     {\n-        if bounds.is_empty() {\n-            struct_span_err!(self.tcx().sess, span, E0220,\n-                      \"associated type `{}` not found for `{}`\",\n-                      assoc_name,\n-                      ty_param_name)\n-              .span_label(span, &format!(\"associated type `{}` not found\", assoc_name))\n-              .emit();\n-            return Err(ErrorReported);\n-        }\n-\n-        if bounds.len() > 1 {\n-            let spans = bounds.iter().map(|b| {\n-                self.tcx().associated_items(b.def_id()).find(|item| {\n-                    item.kind == ty::AssociatedKind::Type && item.name == assoc_name\n-                })\n-                .and_then(|item| self.tcx().map.span_if_local(item.def_id))\n-            });\n+        let bound = match bounds.next() {\n+            Some(bound) => bound,\n+            None => {\n+                struct_span_err!(self.tcx().sess, span, E0220,\n+                          \"associated type `{}` not found for `{}`\",\n+                          assoc_name,\n+                          ty_param_name)\n+                  .span_label(span, &format!(\"associated type `{}` not found\", assoc_name))\n+                  .emit();\n+                return Err(ErrorReported);\n+            }\n+        };\n \n+        if let Some(bound2) = bounds.next() {\n+            let bounds = iter::once(bound).chain(iter::once(bound2)).chain(bounds);\n             let mut err = struct_span_err!(\n                 self.tcx().sess, span, E0221,\n                 \"ambiguous associated type `{}` in bounds of `{}`\",\n                 assoc_name,\n                 ty_param_name);\n             err.span_label(span, &format!(\"ambiguous associated type `{}`\", assoc_name));\n \n-            for span_and_bound in spans.zip(&bounds) {\n-                if let Some(span) = span_and_bound.0 {\n+            for bound in bounds {\n+                let bound_span = self.tcx().associated_items(bound.def_id()).find(|item| {\n+                    item.kind == ty::AssociatedKind::Type && item.name == assoc_name\n+                })\n+                .and_then(|item| self.tcx().map.span_if_local(item.def_id));\n+\n+                if let Some(span) = bound_span {\n                     err.span_label(span, &format!(\"ambiguous `{}` from `{}`\",\n                                                   assoc_name,\n-                                                  span_and_bound.1));\n+                                                  bound));\n                 } else {\n                     span_note!(&mut err, span,\n                                \"associated type `{}` could derive from `{}`\",\n                                ty_param_name,\n-                               span_and_bound.1);\n+                               bound);\n                 }\n             }\n             err.emit();\n         }\n \n-        Ok(bounds[0].clone())\n+        return Ok(bound);\n     }\n \n     // Create a type from a path to an associated type.\n@@ -1293,11 +1294,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     return (tcx.types.err, Def::Err);\n                 }\n \n-                let candidates: Vec<ty::PolyTraitRef> =\n+                let candidates =\n                     traits::supertraits(tcx, ty::Binder(trait_ref))\n                     .filter(|r| self.trait_defines_associated_type_named(r.def_id(),\n-                                                                         assoc_name))\n-                    .collect();\n+                                                                         assoc_name));\n \n                 match self.one_bound_for_assoc_type(candidates,\n                                                     \"Self\","}]}