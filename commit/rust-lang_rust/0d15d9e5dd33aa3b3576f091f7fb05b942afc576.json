{"sha": "0d15d9e5dd33aa3b3576f091f7fb05b942afc576", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMTVkOWU1ZGQzM2FhM2IzNTc2ZjA5MWY3ZmIwNWI5NDJhZmM1NzY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-08-24T12:51:02Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-08-24T12:51:02Z"}, "message": "Rustup to rustc 1.30.0-nightly (63d66494a 2018-08-23)", "tree": {"sha": "459edb97fb73d2e8bb1a4f4a3694c05658e07e58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/459edb97fb73d2e8bb1a4f4a3694c05658e07e58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d15d9e5dd33aa3b3576f091f7fb05b942afc576", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d15d9e5dd33aa3b3576f091f7fb05b942afc576", "html_url": "https://github.com/rust-lang/rust/commit/0d15d9e5dd33aa3b3576f091f7fb05b942afc576", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d15d9e5dd33aa3b3576f091f7fb05b942afc576/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e8d03e477314ca7cbb41281832befe83b0bd53a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e8d03e477314ca7cbb41281832befe83b0bd53a", "html_url": "https://github.com/rust-lang/rust/commit/8e8d03e477314ca7cbb41281832befe83b0bd53a"}], "stats": {"total": 143, "additions": 71, "deletions": 72}, "files": [{"sha": "b5967e734190223c0de2e185e0812ccd8fbb9a69", "filename": "src/abi.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0d15d9e5dd33aa3b3576f091f7fb05b942afc576/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d15d9e5dd33aa3b3576f091f7fb05b942afc576/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=0d15d9e5dd33aa3b3576f091f7fb05b942afc576", "patch": "@@ -57,7 +57,7 @@ pub fn cton_sig_from_fn_ty<'a, 'tcx: 'a>(\n         Abi::RustCall => {\n             assert_eq!(sig.inputs().len(), 2);\n             let extra_args = match sig.inputs().last().unwrap().sty {\n-                ty::TyTuple(ref tupled_arguments) => tupled_arguments,\n+                ty::Tuple(ref tupled_arguments) => tupled_arguments,\n                 _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n             };\n             let mut inputs: Vec<Ty> = vec![sig.inputs()[0]];\n@@ -104,10 +104,10 @@ pub fn cton_sig_from_fn_ty<'a, 'tcx: 'a>(\n \n fn ty_fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> ty::FnSig<'tcx> {\n     let sig = match ty.sty {\n-        ty::TyFnDef(..) |\n+        ty::FnDef(..) |\n         // Shims currently have type TyFnPtr. Not sure this should remain.\n-        ty::TyFnPtr(_) => ty.fn_sig(tcx),\n-        ty::TyClosure(def_id, substs) => {\n+        ty::FnPtr(_) => ty.fn_sig(tcx),\n+        ty::Closure(def_id, substs) => {\n             let sig = substs.closure_sig(def_id, tcx);\n \n             let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n@@ -119,7 +119,7 @@ fn ty_fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> ty::FnSig<'\n                 sig.abi\n             ))\n         }\n-        ty::TyGenerator(def_id, substs, _) => {\n+        ty::Generator(def_id, substs, _) => {\n             let sig = substs.poly_sig(def_id, tcx);\n \n             let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n@@ -213,7 +213,7 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n                 )\n             }).unzip();\n         let return_layout = self.layout_of(return_ty);\n-        let return_ty = if let TypeVariants::TyTuple(tup) = return_ty.sty {\n+        let return_ty = if let ty::Tuple(tup) = return_ty.sty {\n             if !tup.is_empty() {\n                 bug!(\"easy_call( (...) -> <non empty tuple> ) is not allowed\");\n             }\n@@ -278,7 +278,7 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n                 // individual function arguments.\n \n                 let tupled_arg_tys = match arg_ty.sty {\n-                    ty::TyTuple(ref tys) => tys,\n+                    ty::Tuple(ref tys) => tys,\n                     _ => bug!(\"spread argument isn't a tuple?! but {:?}\", arg_ty),\n                 };\n \n@@ -431,7 +431,7 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n         let mut args = Vec::new();\n         args.push(self_arg);\n         match pack_arg.layout().ty.sty {\n-            ty::TyTuple(ref tupled_arguments) => {\n+            ty::Tuple(ref tupled_arguments) => {\n                 for (i, _) in tupled_arguments.iter().enumerate() {\n                     args.push(pack_arg.value_field(fx, mir::Field::new(i)));\n                 }\n@@ -476,7 +476,7 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n         })).collect::<Vec<_>>();\n \n     let call_inst = match fn_ty.sty {\n-        TypeVariants::TyFnDef(def_id, substs) => {\n+        ty::FnDef(def_id, substs) => {\n             let func_ref = fx.get_function_ref(\n                 Instance::resolve(fx.tcx, ParamEnv::reveal_all(), def_id, substs).unwrap(),\n             );\n@@ -528,7 +528,7 @@ fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n     args: &[CValue<'tcx>],\n     destination: Option<(CPlace<'tcx>, BasicBlock)>,\n ) -> bool {\n-    if let TypeVariants::TyFnDef(def_id, substs) = fn_ty.sty {\n+    if let ty::FnDef(def_id, substs) = fn_ty.sty {\n         if sig.abi == Abi::RustIntrinsic {\n             let intrinsic = fx.tcx.item_name(def_id).as_str();\n             let intrinsic = &intrinsic[..];\n@@ -621,15 +621,15 @@ fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                         _ => unimplemented!(\"intrinsic {}\", intrinsic),\n                     };\n                     let res = match ret.layout().ty.sty {\n-                        TypeVariants::TyUint(_) => crate::base::trans_int_binop(\n+                        ty::Uint(_) => crate::base::trans_int_binop(\n                             fx,\n                             bin_op,\n                             args[0],\n                             args[1],\n                             ret.layout().ty,\n                             false,\n                         ),\n-                        TypeVariants::TyInt(_) => crate::base::trans_int_binop(\n+                        ty::Int(_) => crate::base::trans_int_binop(\n                             fx,\n                             bin_op,\n                             args[0],\n@@ -651,15 +651,15 @@ fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                         _ => unimplemented!(\"intrinsic {}\", intrinsic),\n                     };\n                     let res = match args[0].layout().ty.sty {\n-                        TypeVariants::TyUint(_) => crate::base::trans_checked_int_binop(\n+                        ty::Uint(_) => crate::base::trans_checked_int_binop(\n                             fx,\n                             bin_op,\n                             args[0],\n                             args[1],\n                             ret.layout().ty,\n                             false,\n                         ),\n-                        TypeVariants::TyInt(_) => crate::base::trans_checked_int_binop(\n+                        ty::Int(_) => crate::base::trans_checked_int_binop(\n                             fx,\n                             bin_op,\n                             args[0],\n@@ -681,15 +681,15 @@ fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                         _ => unimplemented!(\"intrinsic {}\", intrinsic),\n                     };\n                     let res = match args[0].layout().ty.sty {\n-                        TypeVariants::TyUint(_) => crate::base::trans_int_binop(\n+                        ty::Uint(_) => crate::base::trans_int_binop(\n                             fx,\n                             bin_op,\n                             args[0],\n                             args[1],\n                             ret.layout().ty,\n                             false,\n                         ),\n-                        TypeVariants::TyInt(_) => crate::base::trans_int_binop(\n+                        ty::Int(_) => crate::base::trans_int_binop(\n                             fx,\n                             bin_op,\n                             args[0],"}, {"sha": "e0a9ce610b6318909e7b9f5bb310482da5df6c2f", "filename": "src/base.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0d15d9e5dd33aa3b3576f091f7fb05b942afc576/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d15d9e5dd33aa3b3576f091f7fb05b942afc576/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=0d15d9e5dd33aa3b3576f091f7fb05b942afc576", "patch": "@@ -317,22 +317,22 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                     let rhs = trans_operand(fx, rhs);\n \n                     let res = match ty.sty {\n-                        TypeVariants::TyBool => {\n+                        ty::Bool => {\n                             trans_bool_binop(fx, *bin_op, lhs, rhs, lval.layout().ty)\n                         }\n-                        TypeVariants::TyUint(_) => {\n+                        ty::Uint(_) => {\n                             trans_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty, false)\n                         }\n-                        TypeVariants::TyInt(_) => {\n+                        ty::Int(_) => {\n                             trans_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty, true)\n                         }\n-                        TypeVariants::TyFloat(_) => {\n+                        ty::Float(_) => {\n                             trans_float_binop(fx, *bin_op, lhs, rhs, lval.layout().ty)\n                         }\n-                        TypeVariants::TyChar => {\n+                        ty::Char => {\n                             trans_char_binop(fx, *bin_op, lhs, rhs, lval.layout().ty)\n                         }\n-                        TypeVariants::TyRawPtr(..) => {\n+                        ty::RawPtr(..) => {\n                             trans_ptr_binop(fx, *bin_op, lhs, rhs, lval.layout().ty)\n                         }\n                         _ => unimplemented!(\"binop {:?} for {:?}\", bin_op, ty),\n@@ -345,10 +345,10 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                     let rhs = trans_operand(fx, rhs);\n \n                     let res = match ty.sty {\n-                        TypeVariants::TyUint(_) => {\n+                        ty::Uint(_) => {\n                             trans_checked_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty, false)\n                         }\n-                        TypeVariants::TyInt(_) => {\n+                        ty::Int(_) => {\n                             trans_checked_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty, true)\n                         }\n                         _ => unimplemented!(\"checked binop {:?} for {:?}\", bin_op, ty),\n@@ -362,12 +362,12 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                     let res = match un_op {\n                         UnOp::Not => fx.bcx.ins().bnot(val),\n                         UnOp::Neg => match ty.sty {\n-                            TypeVariants::TyInt(_) => {\n+                            ty::Int(_) => {\n                                 let clif_ty = fx.cton_type(ty).unwrap();\n                                 let zero = fx.bcx.ins().iconst(clif_ty, 0);\n                                 fx.bcx.ins().isub(zero, val)\n                             }\n-                            TypeVariants::TyFloat(_) => fx.bcx.ins().fneg(val),\n+                            ty::Float(_) => fx.bcx.ins().fneg(val),\n                             _ => unimplemented!(\"un op Neg for {:?}\", ty),\n                         },\n                     };\n@@ -387,27 +387,27 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                     let operand = trans_operand(fx, operand);\n                     let from_ty = operand.layout().ty;\n                     match (&from_ty.sty, &to_ty.sty) {\n-                        (TypeVariants::TyRef(..), TypeVariants::TyRef(..))\n-                        | (TypeVariants::TyRef(..), TypeVariants::TyRawPtr(..))\n-                        | (TypeVariants::TyRawPtr(..), TypeVariants::TyRef(..))\n-                        | (TypeVariants::TyRawPtr(..), TypeVariants::TyRawPtr(..)) => {\n+                        (ty::Ref(..), ty::Ref(..))\n+                        | (ty::Ref(..), ty::RawPtr(..))\n+                        | (ty::RawPtr(..), ty::Ref(..))\n+                        | (ty::RawPtr(..), ty::RawPtr(..)) => {\n                             lval.write_cvalue(fx, operand.unchecked_cast_to(dest_layout));\n                         }\n-                        (TypeVariants::TyRawPtr(..), TypeVariants::TyUint(_))\n-                        | (TypeVariants::TyFnPtr(..), TypeVariants::TyUint(_))\n+                        (ty::RawPtr(..), ty::Uint(_))\n+                        | (ty::FnPtr(..), ty::Uint(_))\n                             if to_ty.sty == fx.tcx.types.usize.sty =>\n                         {\n                             lval.write_cvalue(fx, operand.unchecked_cast_to(dest_layout));\n                         }\n-                        (TypeVariants::TyUint(_), TypeVariants::TyRawPtr(..))\n+                        (ty::Uint(_), ty::RawPtr(..))\n                             if from_ty.sty == fx.tcx.types.usize.sty =>\n                         {\n                             lval.write_cvalue(fx, operand.unchecked_cast_to(dest_layout));\n                         }\n-                        (TypeVariants::TyChar, TypeVariants::TyUint(_))\n-                        | (TypeVariants::TyUint(_), TypeVariants::TyChar)\n-                        | (TypeVariants::TyUint(_), TypeVariants::TyInt(_))\n-                        | (TypeVariants::TyUint(_), TypeVariants::TyUint(_)) => {\n+                        (ty::Char, ty::Uint(_))\n+                        | (ty::Uint(_), ty::Char)\n+                        | (ty::Uint(_), ty::Int(_))\n+                        | (ty::Uint(_), ty::Uint(_)) => {\n                             let from = operand.load_value(fx);\n                             let res = crate::common::cton_intcast(\n                                 fx,\n@@ -417,8 +417,8 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                             );\n                             lval.write_cvalue(fx, CValue::ByVal(res, dest_layout));\n                         }\n-                        (TypeVariants::TyInt(_), TypeVariants::TyInt(_))\n-                        | (TypeVariants::TyInt(_), TypeVariants::TyUint(_)) => {\n+                        (ty::Int(_), ty::Int(_))\n+                        | (ty::Int(_), ty::Uint(_)) => {\n                             let from = operand.load_value(fx);\n                             let res = crate::common::cton_intcast(\n                                 fx,\n@@ -428,7 +428,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                             );\n                             lval.write_cvalue(fx, CValue::ByVal(res, dest_layout));\n                         }\n-                        (TypeVariants::TyFloat(from_flt), TypeVariants::TyFloat(to_flt)) => {\n+                        (ty::Float(from_flt), ty::Float(to_flt)) => {\n                             let from = operand.load_value(fx);\n                             let res = match (from_flt, to_flt) {\n                                 (FloatTy::F32, FloatTy::F64) => {\n@@ -441,20 +441,20 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                             };\n                             lval.write_cvalue(fx, CValue::ByVal(res, dest_layout));\n                         }\n-                        (TypeVariants::TyInt(_), TypeVariants::TyFloat(_)) => {\n+                        (ty::Int(_), ty::Float(_)) => {\n                             let from = operand.load_value(fx);\n                             let f_type = fx.cton_type(to_ty).unwrap();\n                             let res = fx.bcx.ins().fcvt_from_sint(f_type, from);\n                             lval.write_cvalue(fx, CValue::ByVal(res, dest_layout));\n                         }\n-                        (TypeVariants::TyUint(_), TypeVariants::TyFloat(_)) => {\n+                        (ty::Uint(_), ty::Float(_)) => {\n                             let from = operand.load_value(fx);\n                             let f_type = fx.cton_type(to_ty).unwrap();\n                             let res = fx.bcx.ins().fcvt_from_uint(f_type, from);\n                             lval.write_cvalue(fx, CValue::ByVal(res, dest_layout));\n                         }\n-                        (TypeVariants::TyBool, TypeVariants::TyUint(_))\n-                        | (TypeVariants::TyBool, TypeVariants::TyInt(_)) => {\n+                        (ty::Bool, ty::Uint(_))\n+                        | (ty::Bool, ty::Int(_)) => {\n                             let to_ty = fx.cton_type(to_ty).unwrap();\n                             let from = operand.load_value(fx);\n                             let res = if to_ty != types::I8 {\n@@ -744,7 +744,7 @@ pub fn trans_checked_int_binop<'a, 'tcx: 'a>(\n         );\n     }\n     let res_ty = match out_ty.sty {\n-        TypeVariants::TyTuple(tys) => tys[0],\n+        ty::Tuple(tys) => tys[0],\n         _ => bug!(\n             \"Checked int binop requires tuple as output, but got {:?}\",\n             out_ty\n@@ -798,8 +798,8 @@ fn trans_float_binop<'a, 'tcx: 'a>(\n             assert_eq!(lhs.layout().ty, ty);\n             assert_eq!(rhs.layout().ty, ty);\n             match ty.sty {\n-                TypeVariants::TyFloat(FloatTy::F32) => fx.easy_call(\"fmodf\", &[lhs, rhs], ty),\n-                TypeVariants::TyFloat(FloatTy::F64) => fx.easy_call(\"fmod\", &[lhs, rhs], ty),\n+                ty::Float(FloatTy::F32) => fx.easy_call(\"fmodf\", &[lhs, rhs], ty),\n+                ty::Float(FloatTy::F64) => fx.easy_call(\"fmod\", &[lhs, rhs], ty),\n                 _ => bug!(),\n             }\n         });\n@@ -863,7 +863,7 @@ fn trans_ptr_binop<'a, 'tcx: 'a>(\n     ty: Ty<'tcx>,\n ) -> CValue<'tcx> {\n     match lhs.layout().ty.sty {\n-        TypeVariants::TyRawPtr(TypeAndMut { ty, mutbl: _ }) => {\n+        ty::RawPtr(TypeAndMut { ty, mutbl: _ }) => {\n             if !ty.is_sized(fx.tcx.at(DUMMY_SP), ParamEnv::reveal_all()) {\n                 unimpl!(\"Unsized values are not yet implemented\");\n             }"}, {"sha": "7a8cc53b8d5acdb611657a18909d0e3cd60d71b0", "filename": "src/common.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0d15d9e5dd33aa3b3576f091f7fb05b942afc576/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d15d9e5dd33aa3b3576f091f7fb05b942afc576/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=0d15d9e5dd33aa3b3576f091f7fb05b942afc576", "patch": "@@ -24,37 +24,37 @@ pub fn cton_type_from_ty<'a, 'tcx: 'a>(\n     ty: Ty<'tcx>,\n ) -> Option<types::Type> {\n     Some(match ty.sty {\n-        TypeVariants::TyBool => types::I8,\n-        TypeVariants::TyUint(size) => match size {\n+        ty::Bool => types::I8,\n+        ty::Uint(size) => match size {\n             UintTy::U8 => types::I8,\n             UintTy::U16 => types::I16,\n             UintTy::U32 => types::I32,\n             UintTy::U64 => types::I64,\n             UintTy::U128 => unimpl!(\"u128\"),\n             UintTy::Usize => pointer_ty(tcx),\n         },\n-        TypeVariants::TyInt(size) => match size {\n+        ty::Int(size) => match size {\n             IntTy::I8 => types::I8,\n             IntTy::I16 => types::I16,\n             IntTy::I32 => types::I32,\n             IntTy::I64 => types::I64,\n             IntTy::I128 => unimpl!(\"i128\"),\n             IntTy::Isize => pointer_ty(tcx),\n         },\n-        TypeVariants::TyChar => types::I32,\n-        TypeVariants::TyFloat(size) => match size {\n+        ty::Char => types::I32,\n+        ty::Float(size) => match size {\n             FloatTy::F32 => types::F32,\n             FloatTy::F64 => types::F64,\n         },\n-        TypeVariants::TyFnPtr(_) => pointer_ty(tcx),\n-        TypeVariants::TyRawPtr(TypeAndMut { ty, mutbl: _ }) | TypeVariants::TyRef(_, ty, _) => {\n+        ty::FnPtr(_) => pointer_ty(tcx),\n+        ty::RawPtr(TypeAndMut { ty, mutbl: _ }) | ty::Ref(_, ty, _) => {\n             if ty.is_sized(tcx.at(DUMMY_SP), ParamEnv::reveal_all()) {\n                 pointer_ty(tcx)\n             } else {\n                 return None;\n             }\n         }\n-        TypeVariants::TyParam(_) => bug!(\"{:?}: {:?}\", ty, ty.sty),\n+        ty::Param(_) => bug!(\"{:?}: {:?}\", ty, ty.sty),\n         _ => return None,\n     })\n }\n@@ -279,7 +279,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n \n     pub fn write_cvalue(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>, from: CValue<'tcx>) {\n         match (&self.layout().ty.sty, &from.layout().ty.sty) {\n-            (TypeVariants::TyRef(_, t, dest_mut), TypeVariants::TyRef(_, u, src_mut))\n+            (ty::Ref(_, t, dest_mut), ty::Ref(_, u, src_mut))\n                 if (if *dest_mut != ::rustc::hir::Mutability::MutImmutable && src_mut != dest_mut {\n                     false\n                 } else if t != u {\n@@ -369,15 +369,15 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n         let addr = self.expect_addr();\n         let layout = self.layout();\n         match layout.ty.sty {\n-            TypeVariants::TyArray(elem_ty, _) => {\n+            ty::Array(elem_ty, _) => {\n                 let elem_layout = fx.layout_of(elem_ty);\n                 let offset = fx\n                     .bcx\n                     .ins()\n                     .imul_imm(index, elem_layout.size.bytes() as i64);\n                 CPlace::Addr(fx.bcx.ins().iadd(addr, offset), elem_layout)\n             }\n-            TypeVariants::TySlice(_elem_ty) => unimplemented!(\"place_index(TySlice)\"),\n+            ty::Slice(_elem_ty) => unimplemented!(\"place_index(TySlice)\"),\n             _ => bug!(\"place_index({:?})\", layout.ty),\n         }\n     }"}, {"sha": "f7bfdaf2d55d1ab602c20e2e592193d6f5e99553", "filename": "src/constant.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0d15d9e5dd33aa3b3576f091f7fb05b942afc576/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d15d9e5dd33aa3b3576f091f7fb05b942afc576/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=0d15d9e5dd33aa3b3576f091f7fb05b942afc576", "patch": "@@ -93,19 +93,19 @@ fn trans_const_value<'a, 'tcx: 'a>(\n     let ty = fx.monomorphize(&const_.ty);\n     let layout = fx.layout_of(ty);\n     match ty.sty {\n-        TypeVariants::TyBool => {\n-            let bits = const_.val.to_bits(layout.size).unwrap();\n+        ty::Bool => {\n+            let bits = const_.val.try_to_bits(layout.size).unwrap();\n             CValue::const_val(fx, ty, bits as u64 as i64)\n         }\n-        TypeVariants::TyUint(_) => {\n-            let bits = const_.val.to_bits(layout.size).unwrap();\n+        ty::Uint(_) => {\n+            let bits = const_.val.try_to_bits(layout.size).unwrap();\n             CValue::const_val(fx, ty, bits as u64 as i64)\n         }\n-        TypeVariants::TyInt(_) => {\n-            let bits = const_.val.to_bits(layout.size).unwrap();\n+        ty::Int(_) => {\n+            let bits = const_.val.try_to_bits(layout.size).unwrap();\n             CValue::const_val(fx, ty, bits as i128 as i64)\n         }\n-        TypeVariants::TyFnDef(def_id, substs) => {\n+        ty::FnDef(def_id, substs) => {\n             let func_ref = fx.get_function_ref(\n                 Instance::resolve(fx.tcx, ParamEnv::reveal_all(), def_id, substs).unwrap(),\n             );\n@@ -120,7 +120,7 @@ fn trans_const_place<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     const_: &'tcx Const<'tcx>,\n ) -> CPlace<'tcx> {\n-    let alloc = fx.tcx.const_value_to_allocation(const_);\n+    let alloc = fx.tcx.const_to_allocation(const_);\n     //println!(\"const value: {:?} allocation: {:?}\", value, alloc);\n     let alloc_id = fx.tcx.alloc_map.lock().allocate(alloc);\n     fx.constants.todo.insert(TodoItem::Alloc(alloc_id));"}, {"sha": "3b98d03367076fbbd0161db020e37b8b9c7fea16", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d15d9e5dd33aa3b3576f091f7fb05b942afc576/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d15d9e5dd33aa3b3576f091f7fb05b942afc576/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=0d15d9e5dd33aa3b3576f091f7fb05b942afc576", "patch": "@@ -31,7 +31,7 @@ use rustc::middle::cstore::MetadataLoader;\n use rustc::session::{config::OutputFilenames, CompileIncomplete};\n use rustc::ty::query::Providers;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n-use rustc_codegen_utils::link::{build_link_meta, out_filename};\n+use rustc_codegen_utils::link::out_filename;\n use rustc_data_structures::svh::Svh;\n use syntax::symbol::Symbol;\n \n@@ -66,7 +66,7 @@ mod prelude {\n     pub use rustc::ty::layout::{self, LayoutOf, Size, TyLayout};\n     pub use rustc::ty::{\n         self, subst::Substs, FnSig, Instance, InstanceDef, ParamEnv, PolyFnSig, Ty, TyCtxt,\n-        TypeAndMut, TypeFoldable, TypeVariants,\n+        TypeAndMut, TypeFoldable,\n     };\n     pub use rustc_data_structures::{\n         fx::{FxHashMap, FxHashSet},\n@@ -75,7 +75,7 @@ mod prelude {\n     };\n     pub use rustc_mir::monomorphize::{collector, MonoItem};\n     pub use syntax::ast::{FloatTy, IntTy, UintTy};\n-    pub use syntax::codemap::DUMMY_SP;\n+    pub use syntax::source_map::DUMMY_SP;\n \n     pub use cranelift::codegen::ir::{\n         condcodes::IntCC, function::Function, ExternalName, FuncRef, Inst, StackSlot,\n@@ -209,8 +209,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n \n         tcx.sess.abort_if_errors();\n \n-        let link_meta = build_link_meta(tcx.crate_hash(LOCAL_CRATE));\n-        let metadata = tcx.encode_metadata(&link_meta);\n+        let metadata = tcx.encode_metadata();\n \n         let mut flags_builder = settings::builder();\n         flags_builder.enable(\"is_pic\").unwrap();"}]}