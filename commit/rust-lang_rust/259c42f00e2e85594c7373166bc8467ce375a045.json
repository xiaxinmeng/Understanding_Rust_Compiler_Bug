{"sha": "259c42f00e2e85594c7373166bc8467ce375a045", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1OWM0MmYwMGUyZTg1NTk0YzczNzMxNjZiYzg0NjdjZTM3NWEwNDU=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-13T20:43:53Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-13T21:33:37Z"}, "message": "Add macros for known names and paths", "tree": {"sha": "e3c3c855a4bcb7ba425f9d788a9a383a529557c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3c3c855a4bcb7ba425f9d788a9a383a529557c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/259c42f00e2e85594c7373166bc8467ce375a045", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/259c42f00e2e85594c7373166bc8467ce375a045", "html_url": "https://github.com/rust-lang/rust/commit/259c42f00e2e85594c7373166bc8467ce375a045", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/259c42f00e2e85594c7373166bc8467ce375a045/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "169fe4932f84f396965a4814c44e31061673937c", "url": "https://api.github.com/repos/rust-lang/rust/commits/169fe4932f84f396965a4814c44e31061673937c", "html_url": "https://github.com/rust-lang/rust/commit/169fe4932f84f396965a4814c44e31061673937c"}], "stats": {"total": 365, "additions": 192, "deletions": 173}, "files": [{"sha": "d1153fa628bf5f9e0fe5e59a9768537fb2e0b286", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=259c42f00e2e85594c7373166bc8467ce375a045", "patch": "@@ -17,7 +17,7 @@ use hir_def::{\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n-    name::{self, AsName},\n+    name::{AsName, N},\n     MacroDefId,\n };\n use hir_ty::{\n@@ -723,7 +723,7 @@ impl Local {\n     }\n \n     pub fn is_self(self, db: &impl HirDatabase) -> bool {\n-        self.name(db) == Some(name::SELF_PARAM)\n+        self.name(db) == Some(N![self])\n     }\n \n     pub fn is_mut(self, db: &impl HirDatabase) -> bool {"}, {"sha": "6c760166fd56c4bcdaae13498e017c749ee8ef5f", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=259c42f00e2e85594c7373166bc8467ce375a045", "patch": "@@ -2,7 +2,7 @@\n //! representation.\n \n use either::Either;\n-use hir_expand::name::{self, AsName, Name};\n+use hir_expand::name::{AsName, Name, N};\n use ra_arena::Arena;\n use ra_syntax::{\n     ast::{\n@@ -68,7 +68,7 @@ where\n                 let ptr = AstPtr::new(&self_param);\n                 let param_pat = self.alloc_pat(\n                     Pat::Bind {\n-                        name: name::SELF_PARAM,\n+                        name: N![self],\n                         mode: BindingAnnotation::Unannotated,\n                         subpat: None,\n                     },"}, {"sha": "757123f824b9923a23065cbcc2c786c41a4899c6", "filename": "crates/ra_hir_def/src/builtin_type.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs?ref=259c42f00e2e85594c7373166bc8467ce375a045", "patch": "@@ -5,7 +5,7 @@\n \n use std::fmt;\n \n-use hir_expand::name::{self, Name};\n+use hir_expand::name::{Name, N};\n \n #[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n pub enum Signedness {\n@@ -52,26 +52,26 @@ pub enum BuiltinType {\n impl BuiltinType {\n     #[rustfmt::skip]\n     pub const ALL: &'static [(Name, BuiltinType)] = &[\n-        (name::CHAR, BuiltinType::Char),\n-        (name::BOOL, BuiltinType::Bool),\n-        (name::STR,  BuiltinType::Str ),\n-\n-        (name::ISIZE, BuiltinType::Int(BuiltinInt::ISIZE)),\n-        (name::I8,    BuiltinType::Int(BuiltinInt::I8)),\n-        (name::I16,   BuiltinType::Int(BuiltinInt::I16)),\n-        (name::I32,   BuiltinType::Int(BuiltinInt::I32)),\n-        (name::I64,   BuiltinType::Int(BuiltinInt::I64)),\n-        (name::I128,  BuiltinType::Int(BuiltinInt::I128)),\n-\n-        (name::USIZE, BuiltinType::Int(BuiltinInt::USIZE)),\n-        (name::U8,    BuiltinType::Int(BuiltinInt::U8)),\n-        (name::U16,   BuiltinType::Int(BuiltinInt::U16)),\n-        (name::U32,   BuiltinType::Int(BuiltinInt::U32)),\n-        (name::U64,   BuiltinType::Int(BuiltinInt::U64)),\n-        (name::U128,  BuiltinType::Int(BuiltinInt::U128)),\n-\n-        (name::F32, BuiltinType::Float(BuiltinFloat::F32)),\n-        (name::F64, BuiltinType::Float(BuiltinFloat::F64)),\n+        (N![char], BuiltinType::Char),\n+        (N![bool], BuiltinType::Bool),\n+        (N![str],  BuiltinType::Str),\n+\n+        (N![isize], BuiltinType::Int(BuiltinInt::ISIZE)),\n+        (N![i8],    BuiltinType::Int(BuiltinInt::I8)),\n+        (N![i16],   BuiltinType::Int(BuiltinInt::I16)),\n+        (N![i32],   BuiltinType::Int(BuiltinInt::I32)),\n+        (N![i64],   BuiltinType::Int(BuiltinInt::I64)),\n+        (N![i128],  BuiltinType::Int(BuiltinInt::I128)),\n+\n+        (N![usize], BuiltinType::Int(BuiltinInt::USIZE)),\n+        (N![u8],    BuiltinType::Int(BuiltinInt::U8)),\n+        (N![u16],   BuiltinType::Int(BuiltinInt::U16)),\n+        (N![u32],   BuiltinType::Int(BuiltinInt::U32)),\n+        (N![u64],   BuiltinType::Int(BuiltinInt::U64)),\n+        (N![u128],  BuiltinType::Int(BuiltinInt::U128)),\n+\n+        (N![f32], BuiltinType::Float(BuiltinFloat::F32)),\n+        (N![f64], BuiltinType::Float(BuiltinFloat::F64)),\n     ];\n }\n "}, {"sha": "afeac0ec27c01b4d7d88f8b3593dfb1f6725bdb6", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=259c42f00e2e85594c7373166bc8467ce375a045", "patch": "@@ -3,7 +3,7 @@\n use std::sync::Arc;\n \n use hir_expand::{\n-    name::{self, AsName, Name},\n+    name::{AsName, Name, N},\n     AstId,\n };\n use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n@@ -37,7 +37,7 @@ impl FunctionData {\n                 let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n                     TypeRef::from_ast(type_ref)\n                 } else {\n-                    let self_type = TypeRef::Path(name::SELF_TYPE.into());\n+                    let self_type = TypeRef::Path(N![Self].into());\n                     match self_param.kind() {\n                         ast::SelfParamKind::Owned => self_type,\n                         ast::SelfParamKind::Ref => {"}, {"sha": "2b13748f3622a207824609b5082ffcb234e4c32c", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=259c42f00e2e85594c7373166bc8467ce375a045", "patch": "@@ -6,7 +6,7 @@ use std::sync::Arc;\n \n use either::Either;\n use hir_expand::{\n-    name::{self, AsName, Name},\n+    name::{AsName, Name, N},\n     InFile,\n };\n use ra_arena::{map::ArenaMap, Arena};\n@@ -90,11 +90,11 @@ impl GenericParams {\n \n                 // traits get the Self type as an implicit first type parameter\n                 let self_param_id =\n-                    generics.types.alloc(TypeParamData { name: name::SELF_TYPE, default: None });\n+                    generics.types.alloc(TypeParamData { name: N![Self], default: None });\n                 sm.insert(self_param_id, Either::Left(src.value.clone()));\n                 // add super traits as bounds on Self\n                 // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n-                let self_param = TypeRef::Path(name::SELF_TYPE.into());\n+                let self_param = TypeRef::Path(N![Self].into());\n                 generics.fill_bounds(&src.value, self_param);\n \n                 generics.fill(&mut sm, &src.value);"}, {"sha": "e81bac914b8868fd69a9b7648b096aeb95838233", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=259c42f00e2e85594c7373166bc8467ce375a045", "patch": "@@ -6,7 +6,7 @@\n use hir_expand::{\n     builtin_derive::find_builtin_derive,\n     builtin_macro::find_builtin_macro,\n-    name::{self, AsName, Name},\n+    name::{AsName, Name, N},\n     HirFileId, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n use ra_cfg::CfgOptions;\n@@ -918,7 +918,7 @@ where\n }\n \n fn is_macro_rules(path: &Path) -> bool {\n-    path.as_ident() == Some(&name::MACRO_RULES)\n+    path.as_ident() == Some(&N![macro_rules])\n }\n \n #[cfg(test)]"}, {"sha": "36ad27867873c881f4b74f743e91e99ae171b31d", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=259c42f00e2e85594c7373166bc8467ce375a045", "patch": "@@ -6,7 +6,7 @@ use std::{iter, sync::Arc};\n use either::Either;\n use hir_expand::{\n     hygiene::Hygiene,\n-    name::{self, AsName, Name},\n+    name::{AsName, Name, N},\n };\n use ra_db::CrateId;\n use ra_syntax::{\n@@ -276,7 +276,7 @@ impl GenericArgs {\n         }\n         if let Some(ret_type) = ret_type {\n             let type_ref = TypeRef::from_ast_opt(ret_type.type_ref());\n-            bindings.push((name::OUTPUT_TYPE, type_ref))\n+            bindings.push((N![Output], type_ref))\n         }\n         if args.is_empty() && bindings.is_empty() {\n             None\n@@ -297,68 +297,63 @@ impl From<Name> for Path {\n }\n \n pub mod known {\n-    use hir_expand::name;\n+    use hir_expand::name::N;\n \n     use super::{Path, PathKind};\n \n+    macro_rules! P {\n+        ($start:ident $(:: $seg:ident)*) => { Path::from_simple_segments(PathKind::Abs, vec![N![$start], $(N![$seg],)*]) };\n+    }\n+\n     pub fn std_iter_into_iterator() -> Path {\n-        Path::from_simple_segments(\n-            PathKind::Abs,\n-            vec![name::STD, name::ITER, name::INTO_ITERATOR_TYPE],\n-        )\n+        P![std::iter::IntoIterator]\n     }\n \n     pub fn std_ops_try() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::TRY_TYPE])\n+        P![std::ops::Try]\n     }\n \n     pub fn std_ops_range() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::RANGE_TYPE])\n+        P![std::ops::Range]\n     }\n \n     pub fn std_ops_range_from() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::RANGE_FROM_TYPE])\n+        P![std::ops::RangeFrom]\n     }\n \n     pub fn std_ops_range_full() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::RANGE_FULL_TYPE])\n+        P![std::ops::RangeFull]\n     }\n \n     pub fn std_ops_range_inclusive() -> Path {\n-        Path::from_simple_segments(\n-            PathKind::Abs,\n-            vec![name::STD, name::OPS, name::RANGE_INCLUSIVE_TYPE],\n-        )\n+        P![std::ops::RangeInclusive]\n     }\n \n     pub fn std_ops_range_to() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::RANGE_TO_TYPE])\n+        P![std::ops::RangeTo]\n     }\n \n     pub fn std_ops_range_to_inclusive() -> Path {\n-        Path::from_simple_segments(\n-            PathKind::Abs,\n-            vec![name::STD, name::OPS, name::RANGE_TO_INCLUSIVE_TYPE],\n-        )\n+        P![std::ops::RangeToInclusive]\n     }\n \n     pub fn std_ops_neg() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::NEG_TYPE])\n+        P![std::ops::Neg]\n     }\n \n     pub fn std_ops_not() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::NOT_TYPE])\n+        P![std::ops::Not]\n     }\n \n     pub fn std_result_result() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::RESULT, name::RESULT_TYPE])\n+        P![std::result::Result]\n     }\n \n     pub fn std_future_future() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::FUTURE, name::FUTURE_TYPE])\n+        P![std::future::Future]\n     }\n \n     pub fn std_boxed_box() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::BOXED, name::BOX_TYPE])\n+        P![std::boxed::Box]\n     }\n }"}, {"sha": "0fb529527901f2aaa986c5b35760ac6883881051", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=259c42f00e2e85594c7373166bc8467ce375a045", "patch": "@@ -2,7 +2,7 @@\n use std::sync::Arc;\n \n use hir_expand::{\n-    name::{self, Name},\n+    name::{Name, N},\n     MacroDefId,\n };\n use ra_db::CrateId;\n@@ -163,13 +163,13 @@ impl Resolver {\n                     }\n                 }\n                 Scope::ImplBlockScope(impl_) => {\n-                    if first_name == &name::SELF_TYPE {\n+                    if first_name == &N![Self] {\n                         let idx = if path.segments.len() == 1 { None } else { Some(1) };\n                         return Some((TypeNs::SelfType(*impl_), idx));\n                     }\n                 }\n                 Scope::AdtScope(adt) => {\n-                    if first_name == &name::SELF_TYPE {\n+                    if first_name == &N![Self] {\n                         let idx = if path.segments.len() == 1 { None } else { Some(1) };\n                         return Some((TypeNs::AdtSelfType(*adt), idx));\n                     }\n@@ -223,7 +223,7 @@ impl Resolver {\n             return None;\n         }\n         let n_segments = path.segments.len();\n-        let tmp = name::SELF_PARAM;\n+        let tmp = N![self];\n         let first_name = if path.is_self() { &tmp } else { &path.segments.first()?.name };\n         let skip_to_mod = path.kind != PathKind::Plain && !path.is_self();\n         for scope in self.scopes.iter().rev() {\n@@ -259,13 +259,13 @@ impl Resolver {\n                 Scope::GenericParams { .. } => continue,\n \n                 Scope::ImplBlockScope(impl_) if n_segments > 1 => {\n-                    if first_name == &name::SELF_TYPE {\n+                    if first_name == &N![Self] {\n                         let ty = TypeNs::SelfType(*impl_);\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n                 Scope::AdtScope(adt) if n_segments > 1 => {\n-                    if first_name == &name::SELF_TYPE {\n+                    if first_name == &N![Self] {\n                         let ty = TypeNs::AdtSelfType(*adt);\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n@@ -439,10 +439,10 @@ impl Scope {\n                 }\n             }\n             Scope::ImplBlockScope(i) => {\n-                f(name::SELF_TYPE, ScopeDef::ImplSelfType((*i).into()));\n+                f(N![Self], ScopeDef::ImplSelfType((*i).into()));\n             }\n             Scope::AdtScope(i) => {\n-                f(name::SELF_TYPE, ScopeDef::AdtSelfType((*i).into()));\n+                f(N![Self], ScopeDef::AdtSelfType((*i).into()));\n             }\n             Scope::ExprScope(scope) => {\n                 scope.expr_scopes.entries(scope.scope_id).iter().for_each(|e| {"}, {"sha": "d7f8ada786e4c605ba31de96dfc794ac87578ded", "filename": "crates/ra_hir_expand/src/builtin_derive.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs?ref=259c42f00e2e85594c7373166bc8467ce375a045", "patch": "@@ -12,10 +12,10 @@ use crate::db::AstDatabase;\n use crate::{name, quote, MacroCallId, MacroDefId, MacroDefKind};\n \n macro_rules! register_builtin {\n-    ( $(($name:ident, $kind: ident) => $expand:ident),* ) => {\n+    ( $($trait:ident => $expand:ident),* ) => {\n         #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n         pub enum BuiltinDeriveExpander {\n-            $($kind),*\n+            $($trait),*\n         }\n \n         impl BuiltinDeriveExpander {\n@@ -26,15 +26,15 @@ macro_rules! register_builtin {\n                 tt: &tt::Subtree,\n             ) -> Result<tt::Subtree, mbe::ExpandError> {\n                 let expander = match *self {\n-                    $( BuiltinDeriveExpander::$kind => $expand, )*\n+                    $( BuiltinDeriveExpander::$trait => $expand, )*\n                 };\n                 expander(db, id, tt)\n             }\n         }\n \n         pub fn find_builtin_derive(ident: &name::Name) -> Option<MacroDefId> {\n             let kind = match ident {\n-                 $( id if id == &name::$name => BuiltinDeriveExpander::$kind, )*\n+                $( id if id == &name::N![$trait] => BuiltinDeriveExpander::$trait, )*\n                  _ => return None,\n             };\n \n@@ -44,15 +44,15 @@ macro_rules! register_builtin {\n }\n \n register_builtin! {\n-    (COPY_TRAIT, Copy) => copy_expand,\n-    (CLONE_TRAIT, Clone) => clone_expand,\n-    (DEFAULT_TRAIT, Default) => default_expand,\n-    (DEBUG_TRAIT, Debug) => debug_expand,\n-    (HASH_TRAIT, Hash) => hash_expand,\n-    (ORD_TRAIT, Ord) => ord_expand,\n-    (PARTIAL_ORD_TRAIT, PartialOrd) => partial_ord_expand,\n-    (EQ_TRAIT, Eq) => eq_expand,\n-    (PARTIAL_EQ_TRAIT, PartialEq) => partial_eq_expand\n+    Copy => copy_expand,\n+    Clone => clone_expand,\n+    Default => default_expand,\n+    Debug => debug_expand,\n+    Hash => hash_expand,\n+    Ord => ord_expand,\n+    PartialOrd => partial_ord_expand,\n+    Eq => eq_expand,\n+    PartialEq => partial_eq_expand\n }\n \n struct BasicAdtInfo {"}, {"sha": "e5046ad4cbf49a0d2361516993434ab195c81714", "filename": "crates/ra_hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=259c42f00e2e85594c7373166bc8467ce375a045", "patch": "@@ -34,7 +34,7 @@ macro_rules! register_builtin {\n             ast_id: AstId<ast::MacroCall>,\n         ) -> Option<MacroDefId> {\n             let kind = match ident {\n-                 $( id if id == &name::$name => BuiltinFnLikeExpander::$kind, )*\n+                 $( id if id == &name::N![$name] => BuiltinFnLikeExpander::$kind, )*\n                  _ => return None,\n             };\n \n@@ -44,15 +44,15 @@ macro_rules! register_builtin {\n }\n \n register_builtin! {\n-    (COLUMN_MACRO, Column) => column_expand,\n-    (COMPILE_ERROR_MACRO, CompileError) => compile_error_expand,\n-    (FILE_MACRO, File) => file_expand,\n-    (LINE_MACRO, Line) => line_expand,\n-    (STRINGIFY_MACRO, Stringify) => stringify_expand,\n-    (FORMAT_ARGS_MACRO, FormatArgs) => format_args_expand,\n+    (column, Column) => column_expand,\n+    (compile_error, CompileError) => compile_error_expand,\n+    (file, File) => file_expand,\n+    (line, Line) => line_expand,\n+    (stringify, Stringify) => stringify_expand,\n+    (format_args, FormatArgs) => format_args_expand,\n     // format_args_nl only differs in that it adds a newline in the end,\n     // so we use the same stub expansion for now\n-    (FORMAT_ARGS_NL_MACRO, FormatArgsNl) => format_args_expand\n+    (format_args_nl, FormatArgsNl) => format_args_expand\n }\n \n fn to_line_number(db: &dyn AstDatabase, file: HirFileId, pos: TextUnit) -> usize {"}, {"sha": "8b3141d75cc6350b51deb9dca50ad6a7eb64bfc7", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 96, "deletions": 70, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=259c42f00e2e85594c7373166bc8467ce375a045", "patch": "@@ -104,73 +104,99 @@ impl AsName for ra_db::Dependency {\n     }\n }\n \n-// Primitives\n-pub const ISIZE: Name = Name::new_inline_ascii(b\"isize\");\n-pub const I8: Name = Name::new_inline_ascii(b\"i8\");\n-pub const I16: Name = Name::new_inline_ascii(b\"i16\");\n-pub const I32: Name = Name::new_inline_ascii(b\"i32\");\n-pub const I64: Name = Name::new_inline_ascii(b\"i64\");\n-pub const I128: Name = Name::new_inline_ascii(b\"i128\");\n-pub const USIZE: Name = Name::new_inline_ascii(b\"usize\");\n-pub const U8: Name = Name::new_inline_ascii(b\"u8\");\n-pub const U16: Name = Name::new_inline_ascii(b\"u16\");\n-pub const U32: Name = Name::new_inline_ascii(b\"u32\");\n-pub const U64: Name = Name::new_inline_ascii(b\"u64\");\n-pub const U128: Name = Name::new_inline_ascii(b\"u128\");\n-pub const F32: Name = Name::new_inline_ascii(b\"f32\");\n-pub const F64: Name = Name::new_inline_ascii(b\"f64\");\n-pub const BOOL: Name = Name::new_inline_ascii(b\"bool\");\n-pub const CHAR: Name = Name::new_inline_ascii(b\"char\");\n-pub const STR: Name = Name::new_inline_ascii(b\"str\");\n-\n-// Special names\n-pub const SELF_PARAM: Name = Name::new_inline_ascii(b\"self\");\n-pub const SELF_TYPE: Name = Name::new_inline_ascii(b\"Self\");\n-pub const MACRO_RULES: Name = Name::new_inline_ascii(b\"macro_rules\");\n-\n-// Components of known path (value or mod name)\n-pub const STD: Name = Name::new_inline_ascii(b\"std\");\n-pub const ITER: Name = Name::new_inline_ascii(b\"iter\");\n-pub const OPS: Name = Name::new_inline_ascii(b\"ops\");\n-pub const FUTURE: Name = Name::new_inline_ascii(b\"future\");\n-pub const RESULT: Name = Name::new_inline_ascii(b\"result\");\n-pub const BOXED: Name = Name::new_inline_ascii(b\"boxed\");\n-\n-// Components of known path (type name)\n-pub const INTO_ITERATOR_TYPE: Name = Name::new_inline_ascii(b\"IntoIterator\");\n-pub const ITEM_TYPE: Name = Name::new_inline_ascii(b\"Item\");\n-pub const TRY_TYPE: Name = Name::new_inline_ascii(b\"Try\");\n-pub const OK_TYPE: Name = Name::new_inline_ascii(b\"Ok\");\n-pub const FUTURE_TYPE: Name = Name::new_inline_ascii(b\"Future\");\n-pub const RESULT_TYPE: Name = Name::new_inline_ascii(b\"Result\");\n-pub const OUTPUT_TYPE: Name = Name::new_inline_ascii(b\"Output\");\n-pub const TARGET_TYPE: Name = Name::new_inline_ascii(b\"Target\");\n-pub const BOX_TYPE: Name = Name::new_inline_ascii(b\"Box\");\n-pub const RANGE_FROM_TYPE: Name = Name::new_inline_ascii(b\"RangeFrom\");\n-pub const RANGE_FULL_TYPE: Name = Name::new_inline_ascii(b\"RangeFull\");\n-pub const RANGE_INCLUSIVE_TYPE: Name = Name::new_inline_ascii(b\"RangeInclusive\");\n-pub const RANGE_TO_INCLUSIVE_TYPE: Name = Name::new_inline_ascii(b\"RangeToInclusive\");\n-pub const RANGE_TO_TYPE: Name = Name::new_inline_ascii(b\"RangeTo\");\n-pub const RANGE_TYPE: Name = Name::new_inline_ascii(b\"Range\");\n-pub const NEG_TYPE: Name = Name::new_inline_ascii(b\"Neg\");\n-pub const NOT_TYPE: Name = Name::new_inline_ascii(b\"Not\");\n-\n-// Builtin Macros\n-pub const FILE_MACRO: Name = Name::new_inline_ascii(b\"file\");\n-pub const COLUMN_MACRO: Name = Name::new_inline_ascii(b\"column\");\n-pub const COMPILE_ERROR_MACRO: Name = Name::new_inline_ascii(b\"compile_error\");\n-pub const LINE_MACRO: Name = Name::new_inline_ascii(b\"line\");\n-pub const STRINGIFY_MACRO: Name = Name::new_inline_ascii(b\"stringify\");\n-pub const FORMAT_ARGS_MACRO: Name = Name::new_inline_ascii(b\"format_args\");\n-pub const FORMAT_ARGS_NL_MACRO: Name = Name::new_inline_ascii(b\"format_args_nl\");\n-\n-// Builtin derives\n-pub const COPY_TRAIT: Name = Name::new_inline_ascii(b\"Copy\");\n-pub const CLONE_TRAIT: Name = Name::new_inline_ascii(b\"Clone\");\n-pub const DEFAULT_TRAIT: Name = Name::new_inline_ascii(b\"Default\");\n-pub const DEBUG_TRAIT: Name = Name::new_inline_ascii(b\"Debug\");\n-pub const HASH_TRAIT: Name = Name::new_inline_ascii(b\"Hash\");\n-pub const ORD_TRAIT: Name = Name::new_inline_ascii(b\"Ord\");\n-pub const PARTIAL_ORD_TRAIT: Name = Name::new_inline_ascii(b\"PartialOrd\");\n-pub const EQ_TRAIT: Name = Name::new_inline_ascii(b\"Eq\");\n-pub const PARTIAL_EQ_TRAIT: Name = Name::new_inline_ascii(b\"PartialEq\");\n+pub mod known {\n+    macro_rules! known_names {\n+        ($($ident:ident),* $(,)?) => {\n+            $(\n+                #[allow(bad_style)]\n+                pub const $ident: super::Name =\n+                    super::Name::new_inline_ascii(stringify!($ident).as_bytes());\n+            )*\n+        };\n+    }\n+\n+    known_names!(\n+        // Primitives\n+        isize,\n+        i8,\n+        i16,\n+        i32,\n+        i64,\n+        i128,\n+        usize,\n+        u8,\n+        u16,\n+        u32,\n+        u64,\n+        u128,\n+        f32,\n+        f64,\n+        bool,\n+        char,\n+        str,\n+        // Special names\n+        macro_rules,\n+        // Components of known path (value or mod name)\n+        std,\n+        iter,\n+        ops,\n+        future,\n+        result,\n+        boxed,\n+        // Components of known path (type name)\n+        IntoIterator,\n+        Item,\n+        Try,\n+        Ok,\n+        Future,\n+        Result,\n+        Output,\n+        Target,\n+        Box,\n+        RangeFrom,\n+        RangeFull,\n+        RangeInclusive,\n+        RangeToInclusive,\n+        RangeTo,\n+        Range,\n+        Neg,\n+        Not,\n+        // Builtin macros\n+        file,\n+        column,\n+        compile_error,\n+        line,\n+        stringify,\n+        format_args,\n+        format_args_nl,\n+        // Builtin derives\n+        Copy,\n+        Clone,\n+        Default,\n+        Debug,\n+        Hash,\n+        Ord,\n+        PartialOrd,\n+        Eq,\n+        PartialEq,\n+    );\n+\n+    // self/Self cannot be used as an identifier\n+    pub const SELF_PARAM: super::Name = super::Name::new_inline_ascii(b\"self\");\n+    pub const SELF_TYPE: super::Name = super::Name::new_inline_ascii(b\"Self\");\n+\n+    #[macro_export]\n+    macro_rules! N {\n+        (self) => {\n+            $crate::name::known::SELF_PARAM\n+        };\n+        (Self) => {\n+            $crate::name::known::SELF_TYPE\n+        };\n+        ($ident:ident) => {\n+            $crate::name::known::$ident\n+        };\n+    }\n+}\n+\n+pub use crate::N;"}, {"sha": "04822d56e5fcdfd42061a5e16a815a341c659bfc", "filename": "crates/ra_hir_ty/src/autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs?ref=259c42f00e2e85594c7373166bc8467ce375a045", "patch": "@@ -6,7 +6,7 @@\n use std::iter::successors;\n \n use hir_def::lang_item::LangItemTarget;\n-use hir_expand::name;\n+use hir_expand::name::N;\n use log::{info, warn};\n use ra_db::CrateId;\n \n@@ -52,7 +52,7 @@ fn deref_by_trait(\n         LangItemTarget::TraitId(it) => it,\n         _ => return None,\n     };\n-    let target = db.trait_data(deref_trait).associated_type_by_name(&name::TARGET_TYPE)?;\n+    let target = db.trait_data(deref_trait).associated_type_by_name(&N![Target])?;\n \n     let generic_params = generics(db, target.into());\n     if generic_params.len() != 1 {"}, {"sha": "bb366bb8b4268b0edfc2519b7c21b9794639fbc7", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=259c42f00e2e85594c7373166bc8467ce375a045", "patch": "@@ -29,7 +29,7 @@ use hir_def::{\n     type_ref::{Mutability, TypeRef},\n     AdtId, AssocItemId, DefWithBodyId, FunctionId, StructFieldId, TypeAliasId, VariantId,\n };\n-use hir_expand::{diagnostics::DiagnosticSink, name};\n+use hir_expand::{diagnostics::DiagnosticSink, name::N};\n use ra_arena::map::ArenaMap;\n use ra_prof::profile;\n \n@@ -424,31 +424,31 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn resolve_into_iter_item(&self) -> Option<TypeAliasId> {\n         let path = known::std_iter_into_iterator();\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name::ITEM_TYPE)\n+        self.db.trait_data(trait_).associated_type_by_name(&N![Item])\n     }\n \n     fn resolve_ops_try_ok(&self) -> Option<TypeAliasId> {\n         let path = known::std_ops_try();\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name::OK_TYPE)\n+        self.db.trait_data(trait_).associated_type_by_name(&N![Ok])\n     }\n \n     fn resolve_ops_neg_output(&self) -> Option<TypeAliasId> {\n         let path = known::std_ops_neg();\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name::OUTPUT_TYPE)\n+        self.db.trait_data(trait_).associated_type_by_name(&N![Output])\n     }\n \n     fn resolve_ops_not_output(&self) -> Option<TypeAliasId> {\n         let path = known::std_ops_not();\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name::OUTPUT_TYPE)\n+        self.db.trait_data(trait_).associated_type_by_name(&N![Output])\n     }\n \n     fn resolve_future_future_output(&self) -> Option<TypeAliasId> {\n         let path = known::std_future_future();\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name::OUTPUT_TYPE)\n+        self.db.trait_data(trait_).associated_type_by_name(&N![Output])\n     }\n \n     fn resolve_boxed_box(&self) -> Option<AdtId> {"}, {"sha": "a6f5c6ec3c2a0d92991c72a55d64383847070bca", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=259c42f00e2e85594c7373166bc8467ce375a045", "patch": "@@ -10,7 +10,7 @@ use hir_def::{\n     resolver::resolver_for_expr,\n     AdtId, ContainerId, Lookup, StructFieldId,\n };\n-use hir_expand::name::{self, Name};\n+use hir_expand::name::{Name, N};\n use ra_syntax::ast::RangeOp;\n \n use crate::{\n@@ -631,7 +631,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         // Parent arguments are unknown, except for the receiver type\n         if let Some(parent_generics) = def_generics.as_ref().map(|p| p.iter_parent()) {\n             for (_id, param) in parent_generics {\n-                if param.name == name::SELF_TYPE {\n+                if param.name == N![Self] {\n                     substs.push(receiver_ty.clone());\n                 } else {\n                     substs.push(Ty::Unknown);"}, {"sha": "27c475a3c46a54b93f6d646df0e8f0b0bb1ff3a5", "filename": "crates/ra_hir_ty/src/traits/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs?ref=259c42f00e2e85594c7373166bc8467ce375a045", "patch": "@@ -1,7 +1,7 @@\n //! This module provides the built-in trait implementations, e.g. to make\n //! closures implement `Fn`.\n use hir_def::{expr::Expr, lang_item::LangItemTarget, TraitId, TypeAliasId};\n-use hir_expand::name;\n+use hir_expand::name::N;\n use ra_db::CrateId;\n \n use super::{AssocTyValue, Impl};\n@@ -79,7 +79,7 @@ fn closure_fn_trait_impl_datum(\n     // and don't want to return a valid value only to find out later that FnOnce\n     // is broken\n     let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n-    let _output = db.trait_data(fn_once_trait).associated_type_by_name(&name::OUTPUT_TYPE)?;\n+    let _output = db.trait_data(fn_once_trait).associated_type_by_name(&N![Output])?;\n \n     let num_args: u16 = match &db.body(data.def.into())[data.expr] {\n         Expr::Lambda { args, .. } => args.len() as u16,\n@@ -137,7 +137,7 @@ fn closure_fn_trait_output_assoc_ty_value(\n \n     let output_ty_id = db\n         .trait_data(fn_once_trait)\n-        .associated_type_by_name(&name::OUTPUT_TYPE)\n+        .associated_type_by_name(&N![Output])\n         .expect(\"assoc ty value should not exist\");\n \n     BuiltinImplAssocTyValueData {"}, {"sha": "fabf45b5397551288a7f80b45b74f1e32391ab19", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/259c42f00e2e85594c7373166bc8467ce375a045/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=259c42f00e2e85594c7373166bc8467ce375a045", "patch": "@@ -10,10 +10,8 @@ use hir_def::{\n     type_ref::TypeRef,\n     ContainerId, GenericDefId, Lookup, TraitId, TypeAliasId, TypeParamId, VariantId,\n };\n-use hir_expand::name::{self, Name};\n+use hir_expand::name::{Name, N};\n \n-// FIXME: this is wrong, b/c it can't express `trait T: PartialEq<()>`.\n-// We should return a `TraitREf` here.\n fn direct_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n     let resolver = trait_.resolver(db);\n     // returning the iterator directly doesn't easily work because of\n@@ -24,7 +22,7 @@ fn direct_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n         .where_predicates\n         .iter()\n         .filter_map(|pred| match &pred.type_ref {\n-            TypeRef::Path(p) if p.as_ident() == Some(&name::SELF_TYPE) => pred.bound.as_path(),\n+            TypeRef::Path(p) if p.as_ident() == Some(&N![Self]) => pred.bound.as_path(),\n             _ => None,\n         })\n         .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path) {"}]}