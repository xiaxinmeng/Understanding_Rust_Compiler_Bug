{"sha": "c71970eea2954b40b2b9f195507bc56d2507c5ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MTk3MGVlYTI5NTRiNDBiMmI5ZjE5NTUwN2JjNTZkMjUwN2M1YWM=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-02-28T21:53:12Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-04-03T12:46:09Z"}, "message": "Extract attribute handling code into a module\n\nThis commit causes no change in trans semantics, it just moves some functions around and\ndeduplicates them.", "tree": {"sha": "aafe5de211547a76aa4b9aa95f5e441e25655b8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aafe5de211547a76aa4b9aa95f5e441e25655b8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c71970eea2954b40b2b9f195507bc56d2507c5ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c71970eea2954b40b2b9f195507bc56d2507c5ac", "html_url": "https://github.com/rust-lang/rust/commit/c71970eea2954b40b2b9f195507bc56d2507c5ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c71970eea2954b40b2b9f195507bc56d2507c5ac/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d36c4db96d117f4a45d3a7a0d3ba68fe8b6ee993", "url": "https://api.github.com/repos/rust-lang/rust/commits/d36c4db96d117f4a45d3a7a0d3ba68fe8b6ee993", "html_url": "https://github.com/rust-lang/rust/commit/d36c4db96d117f4a45d3a7a0d3ba68fe8b6ee993"}], "stats": {"total": 303, "additions": 172, "deletions": 131}, "files": [{"sha": "3eaa354c5e6dad06129ae3e6d195e6cfb844c161", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c71970eea2954b40b2b9f195507bc56d2507c5ac/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71970eea2954b40b2b9f195507bc56d2507c5ac/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=c71970eea2954b40b2b9f195507bc56d2507c5ac", "patch": "@@ -157,7 +157,7 @@ bitflags! {\n #[derive(Copy, Clone)]\n pub enum OtherAttribute {\n     // The following are not really exposed in\n-    // the LLVM c api so instead to add these\n+    // the LLVM C api so instead to add these\n     // we call a wrapper function in RustWrapper\n     // that uses the C++ api.\n     SanitizeAddressAttribute = 1 << 32,\n@@ -958,6 +958,7 @@ extern {\n     pub fn LLVMAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n     pub fn LLVMRemoveFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n     pub fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_ulonglong;\n+    pub fn LLVMRemoveFunctionAttr(Fn: ValueRef, val: c_ulonglong);\n \n     /* Operations on parameters */\n     pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;"}, {"sha": "76034420e4b9793bfb63cbb23a9d5e3c64ee89b7", "filename": "src/librustc_trans/trans/attributes.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/c71970eea2954b40b2b9f195507bc56d2507c5ac/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71970eea2954b40b2b9f195507bc56d2507c5ac/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=c71970eea2954b40b2b9f195507bc56d2507c5ac", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//! Set and unset common attributes on LLVM values.\n+\n+use llvm::{self, ValueRef, AttrHelper};\n+use syntax::ast;\n+use syntax::attr::InlineAttr;\n+pub use syntax::attr::InlineAttr::*;\n+use trans::context::CrateContext;\n+\n+use libc::{c_uint, c_ulonglong};\n+\n+/// Mark LLVM function to use split stack.\n+#[inline]\n+pub fn split_stack(val: ValueRef, set: bool) {\n+    unsafe {\n+        let attr = \"split-stack\\0\".as_ptr() as *const _;\n+        if set {\n+            llvm::LLVMAddFunctionAttrString(val, llvm::FunctionIndex as c_uint, attr);\n+        } else {\n+            llvm::LLVMRemoveFunctionAttrString(val, llvm::FunctionIndex as c_uint, attr);\n+        }\n+    }\n+}\n+\n+/// Mark LLVM function to use provided inline heuristic.\n+#[inline]\n+pub fn inline(val: ValueRef, inline: InlineAttr) {\n+    match inline {\n+        InlineHint   => llvm::SetFunctionAttribute(val, llvm::InlineHintAttribute),\n+        InlineAlways => llvm::SetFunctionAttribute(val, llvm::AlwaysInlineAttribute),\n+        InlineNever  => llvm::SetFunctionAttribute(val, llvm::NoInlineAttribute),\n+        InlineNone   => {\n+            let attr = llvm::InlineHintAttribute |\n+                       llvm::AlwaysInlineAttribute |\n+                       llvm::NoInlineAttribute;\n+            unsafe {\n+                llvm::LLVMRemoveFunctionAttr(val, attr.bits() as c_ulonglong)\n+            }\n+        },\n+    };\n+}\n+\n+/// Tell LLVM to emit or not emit the information necessary to unwind the stack for the function.\n+#[inline]\n+pub fn emit_uwtable(val: ValueRef, emit: bool) {\n+    if emit {\n+        llvm::SetFunctionAttribute(val, llvm::UWTableAttribute);\n+    } else {\n+        unsafe {\n+            llvm::LLVMRemoveFunctionAttr(val, llvm::UWTableAttribute.bits() as c_ulonglong);\n+        }\n+    }\n+}\n+\n+/// Tell LLVM whether the function can or cannot unwind.\n+#[inline]\n+#[allow(dead_code)] // possibly useful function\n+pub fn unwind(val: ValueRef, can_unwind: bool) {\n+    if can_unwind {\n+        unsafe {\n+            llvm::LLVMRemoveFunctionAttr(val, llvm::NoUnwindAttribute.bits() as c_ulonglong);\n+        }\n+    } else {\n+        llvm::SetFunctionAttribute(val, llvm::NoUnwindAttribute);\n+    }\n+}\n+\n+/// Tell LLVM whether it should optimise function for size.\n+#[inline]\n+#[allow(dead_code)] // possibly useful function\n+pub fn set_optimize_for_size(val: ValueRef, optimize: bool) {\n+    if optimize {\n+        llvm::SetFunctionAttribute(val, llvm::OptimizeForSizeAttribute);\n+    } else {\n+        unsafe {\n+            llvm::LLVMRemoveFunctionAttr(val, llvm::OptimizeForSizeAttribute.bits() as c_ulonglong);\n+        }\n+    }\n+}\n+\n+/// Composite function which sets LLVM attributes for function depending on its AST (#[attribute])\n+/// attributes.\n+pub fn convert_fn_attrs_to_llvm(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRef) {\n+    use syntax::attr::*;\n+    inline(llfn, find_inline_attr(Some(ccx.sess().diagnostic()), attrs));\n+\n+    for attr in attrs {\n+        if attr.check_name(\"no_stack_check\") {\n+            split_stack(llfn, false);\n+        } else if attr.check_name(\"cold\") {\n+            unsafe {\n+                llvm::LLVMAddFunctionAttribute(llfn,\n+                                               llvm::FunctionIndex as c_uint,\n+                                               llvm::ColdAttribute as u64)\n+            }\n+        } else if attr.check_name(\"allocator\") {\n+            llvm::NoAliasAttribute.apply_llfn(llvm::ReturnIndex as c_uint, llfn);\n+        }\n+    }\n+}"}, {"sha": "25750b6ec0e14171d03c9982b120ae6b500f7d9d", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 27, "deletions": 98, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c71970eea2954b40b2b9f195507bc56d2507c5ac/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71970eea2954b40b2b9f195507bc56d2507c5ac/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=c71970eea2954b40b2b9f195507bc56d2507c5ac", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -7,21 +7,20 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-\n-// trans.rs: Translate the completed AST to the LLVM IR.\n-//\n-// Some functions here, such as trans_block and trans_expr, return a value --\n-// the result of the translation to LLVM -- while others, such as trans_fn,\n-// trans_impl, and trans_item, are called only for the side effect of adding a\n-// particular definition to the LLVM IR output we're producing.\n-//\n-// Hopefully useful general knowledge about trans:\n-//\n-//   * There's no way to find out the Ty type of a ValueRef.  Doing so\n-//     would be \"trying to get the eggs out of an omelette\" (credit:\n-//     pcwalton).  You can, instead, find out its TypeRef by calling val_ty,\n-//     but one TypeRef corresponds to many `Ty`s; for instance, tup(int, int,\n-//     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n+//! Translate the completed AST to the LLVM IR.\n+//!\n+//! Some functions here, such as trans_block and trans_expr, return a value --\n+//! the result of the translation to LLVM -- while others, such as trans_fn,\n+//! trans_impl, and trans_item, are called only for the side effect of adding a\n+//! particular definition to the LLVM IR output we're producing.\n+//!\n+//! Hopefully useful general knowledge about trans:\n+//!\n+//!   * There's no way to find out the Ty type of a ValueRef.  Doing so\n+//!     would be \"trying to get the eggs out of an omelette\" (credit:\n+//!     pcwalton).  You can, instead, find out its TypeRef by calling val_ty,\n+//!     but one TypeRef corresponds to many `Ty`s; for instance, tup(int, int,\n+//!     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n \n #![allow(non_camel_case_types)]\n \n@@ -33,7 +32,7 @@ use super::ModuleTranslation;\n use back::link::mangle_exported_name;\n use back::{link, abi};\n use lint;\n-use llvm::{AttrHelper, BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n+use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n use llvm;\n use metadata::{csearch, encoder, loader};\n use middle::astencode;\n@@ -46,6 +45,7 @@ use session::config::{self, NoDebugInfo};\n use session::Session;\n use trans::_match;\n use trans::adt;\n+use trans::attributes;\n use trans::build::*;\n use trans::builder::{Builder, noname};\n use trans::callee;\n@@ -204,7 +204,7 @@ pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n     llvm::SetUnnamedAddr(llfn, true);\n \n     if ccx.is_split_stack_supported() && !ccx.sess().opts.cg.no_stack_check {\n-        set_split_stack(llfn);\n+        attributes::split_stack(llfn, true);\n     }\n \n     llfn\n@@ -245,7 +245,7 @@ fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n     let f = decl_rust_fn(ccx, fn_ty, name);\n \n     let attrs = csearch::get_item_attrs(&ccx.sess().cstore, did);\n-    set_llvm_fn_attrs(ccx, &attrs[..], f);\n+    attributes::convert_fn_attrs_to_llvm(ccx, &attrs[..], f);\n \n     ccx.externs().borrow_mut().insert(name.to_string(), f);\n     f\n@@ -390,77 +390,6 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n \n-#[allow(dead_code)] // useful\n-pub fn set_optimize_for_size(f: ValueRef) {\n-    llvm::SetFunctionAttribute(f, llvm::OptimizeForSizeAttribute)\n-}\n-\n-pub fn set_no_inline(f: ValueRef) {\n-    llvm::SetFunctionAttribute(f, llvm::NoInlineAttribute)\n-}\n-\n-#[allow(dead_code)] // useful\n-pub fn set_no_unwind(f: ValueRef) {\n-    llvm::SetFunctionAttribute(f, llvm::NoUnwindAttribute)\n-}\n-\n-// Tell LLVM to emit the information necessary to unwind the stack for the\n-// function f.\n-pub fn set_uwtable(f: ValueRef) {\n-    llvm::SetFunctionAttribute(f, llvm::UWTableAttribute)\n-}\n-\n-pub fn set_inline_hint(f: ValueRef) {\n-    llvm::SetFunctionAttribute(f, llvm::InlineHintAttribute)\n-}\n-\n-pub fn set_llvm_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRef) {\n-    use syntax::attr::{find_inline_attr, InlineAttr};\n-    // Set the inline hint if there is one\n-    match find_inline_attr(Some(ccx.sess().diagnostic()), attrs) {\n-        InlineAttr::Hint   => set_inline_hint(llfn),\n-        InlineAttr::Always => set_always_inline(llfn),\n-        InlineAttr::Never  => set_no_inline(llfn),\n-        InlineAttr::None   => { /* fallthrough */ }\n-    }\n-\n-    for attr in attrs {\n-        let mut used = true;\n-        match &attr.name()[..] {\n-            \"no_stack_check\" => unset_split_stack(llfn),\n-            \"cold\" => unsafe {\n-                llvm::LLVMAddFunctionAttribute(llfn,\n-                                               llvm::FunctionIndex as c_uint,\n-                                               llvm::ColdAttribute as uint64_t)\n-            },\n-            \"allocator\" => {\n-                llvm::NoAliasAttribute.apply_llfn(llvm::ReturnIndex as c_uint, llfn);\n-            }\n-            _ => used = false,\n-        }\n-        if used {\n-            attr::mark_used(attr);\n-        }\n-    }\n-}\n-\n-pub fn set_always_inline(f: ValueRef) {\n-    llvm::SetFunctionAttribute(f, llvm::AlwaysInlineAttribute)\n-}\n-\n-pub fn set_split_stack(f: ValueRef) {\n-    unsafe {\n-        llvm::LLVMAddFunctionAttrString(f, llvm::FunctionIndex as c_uint,\n-                                        \"split-stack\\0\".as_ptr() as *const _);\n-    }\n-}\n-\n-pub fn unset_split_stack(f: ValueRef) {\n-    unsafe {\n-        llvm::LLVMRemoveFunctionAttrString(f, llvm::FunctionIndex as c_uint,\n-                                           \"split-stack\\0\".as_ptr() as *const _);\n-    }\n-}\n \n // Double-check that we never ask LLVM to declare the same symbol twice. It\n // silently mangles such symbols, breaking our linkage model.\n@@ -898,7 +827,7 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 _ => {\n                     let llfn = foreign::register_foreign_item_fn(ccx, fn_ty.abi, t, &name[..]);\n                     let attrs = csearch::get_item_attrs(&ccx.sess().cstore, did);\n-                    set_llvm_fn_attrs(ccx, &attrs, llfn);\n+                    attributes::convert_fn_attrs_to_llvm(ccx, &attrs, llfn);\n                     llfn\n                 }\n             }\n@@ -1708,7 +1637,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n     let _icx = push_ctxt(\"trans_closure\");\n-    set_uwtable(llfndecl);\n+    attributes::emit_uwtable(llfndecl, true);\n \n     debug!(\"trans_closure(..., param_substs={})\",\n            param_substs.repr(ccx.tcx()));\n@@ -2312,7 +2241,7 @@ fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: String, node_id: ast::N\n     // eh_personality functions need to be externally linkable.\n     let def = ast_util::local_def(node_id);\n     if ccx.tcx().lang_items.stack_exhausted() == Some(def) {\n-        unset_split_stack(llfn);\n+        attributes::split_stack(llfn, false);\n         llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n     }\n     if ccx.tcx().lang_items.eh_personality() == Some(def) {\n@@ -2733,7 +2662,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                                                    sym,\n                                                                    i.id)\n                     };\n-                    set_llvm_fn_attrs(ccx, &i.attrs, llfn);\n+                    attributes::convert_fn_attrs_to_llvm(ccx, &i.attrs, llfn);\n                     llfn\n                 }\n \n@@ -2794,7 +2723,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     let ty = ty::node_id_to_type(ccx.tcx(), ni.id);\n                     let name = foreign::link_name(&*ni);\n                     let llfn = foreign::register_foreign_item_fn(ccx, abi, ty, &name);\n-                    set_llvm_fn_attrs(ccx, &ni.attrs, llfn);\n+                    attributes::convert_fn_attrs_to_llvm(ccx, &ni.attrs, llfn);\n                     llfn\n                 }\n                 ast::ForeignItemStatic(..) => {\n@@ -2826,7 +2755,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                 }\n                 _ => ccx.sess().bug(\"NodeVariant, shouldn't happen\")\n             };\n-            set_inline_hint(llfn);\n+            attributes::inline(llfn, attributes::InlineHint);\n             llfn\n         }\n \n@@ -2848,7 +2777,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                     &struct_item.attrs);\n             let llfn = register_fn(ccx, struct_item.span,\n                                    sym, ctor_id, ty);\n-            set_inline_hint(llfn);\n+            attributes::inline(llfn, attributes::InlineHint);\n             llfn\n         }\n \n@@ -2883,7 +2812,7 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n         } else {\n             foreign::register_rust_fn_with_foreign_abi(ccx, span, sym, id)\n         };\n-        set_llvm_fn_attrs(ccx, &attrs, llfn);\n+        attributes::convert_fn_attrs_to_llvm(ccx, &attrs, llfn);\n         return llfn;\n     } else {\n         ccx.sess().span_bug(span, \"expected bare rust function\");"}, {"sha": "e83ac8a5e0c9c56a78ccb2a14509112c1bd60691", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c71970eea2954b40b2b9f195507bc56d2507c5ac/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71970eea2954b40b2b9f195507bc56d2507c5ac/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=c71970eea2954b40b2b9f195507bc56d2507c5ac", "patch": "@@ -13,6 +13,7 @@ use back::link::{self, mangle_internal_name_by_path_and_seq};\n use llvm::{ValueRef, get_param};\n use middle::mem_categorization::Typer;\n use trans::adt;\n+use trans::attributes;\n use trans::base::*;\n use trans::build::*;\n use trans::callee::{self, ArgVals, Callee, TraitItem, MethodData};\n@@ -164,7 +165,7 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n     let llfn = decl_internal_rust_fn(ccx, function_type, &symbol[..]);\n \n     // set an inline hint for all closures\n-    set_inline_hint(llfn);\n+    attributes::inline(llfn, attributes::InlineHint);\n \n     debug!(\"get_or_create_declaration_if_closure(): inserting new \\\n             closure {:?} (type {})\","}, {"sha": "ce80c72b8478533dd63a1b187bbd00ab6eec1324", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c71970eea2954b40b2b9f195507bc56d2507c5ac/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71970eea2954b40b2b9f195507bc56d2507c5ac/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=c71970eea2954b40b2b9f195507bc56d2507c5ac", "patch": "@@ -13,6 +13,7 @@ use back::link;\n use llvm::{ValueRef, CallConv, get_param};\n use llvm;\n use middle::weak_lang_items;\n+use trans::attributes;\n use trans::base::{llvm_linkage_by_name, push_ctxt};\n use trans::base;\n use trans::build::*;\n@@ -612,7 +613,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                id, t.repr(tcx));\n \n         let llfn = base::decl_internal_rust_fn(ccx, t, &ps[..]);\n-        base::set_llvm_fn_attrs(ccx, attrs, llfn);\n+        attributes::convert_fn_attrs_to_llvm(ccx, attrs, llfn);\n         base::trans_fn(ccx, decl, body, llfn, param_substs, id, &[]);\n         llfn\n     }"}, {"sha": "0face6860dce533e9250e558c397f6de6b6f7812", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c71970eea2954b40b2b9f195507bc56d2507c5ac/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71970eea2954b40b2b9f195507bc56d2507c5ac/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=c71970eea2954b40b2b9f195507bc56d2507c5ac", "patch": "@@ -19,43 +19,44 @@ pub use self::common::gensym_name;\n #[macro_use]\n mod macros;\n \n-mod inline;\n-mod monomorphize;\n-mod controlflow;\n-mod glue;\n-mod datum;\n-mod callee;\n-mod expr;\n-mod common;\n-mod context;\n-mod consts;\n-mod type_of;\n+mod adt;\n+mod asm;\n+mod attributes;\n+mod base;\n+mod basic_block;\n mod build;\n mod builder;\n-mod base;\n-mod _match;\n-mod closure;\n-mod tvec;\n-mod meth;\n mod cabi;\n-mod cabi_x86;\n-mod cabi_x86_64;\n-mod cabi_x86_win64;\n-mod cabi_arm;\n mod cabi_aarch64;\n+mod cabi_arm;\n mod cabi_mips;\n mod cabi_powerpc;\n+mod cabi_x86;\n+mod cabi_x86_64;\n+mod cabi_x86_win64;\n+mod callee;\n+mod cleanup;\n+mod closure;\n+mod common;\n+mod consts;\n+mod context;\n+mod controlflow;\n+mod datum;\n+mod debuginfo;\n+mod expr;\n mod foreign;\n+mod glue;\n+mod inline;\n mod intrinsic;\n-mod debuginfo;\n+mod llrepr;\n mod machine;\n-mod adt;\n-mod asm;\n+mod _match;\n+mod meth;\n+mod monomorphize;\n+mod tvec;\n mod type_;\n+mod type_of;\n mod value;\n-mod basic_block;\n-mod llrepr;\n-mod cleanup;\n \n #[derive(Copy, Clone)]\n pub struct ModuleTranslation {"}, {"sha": "fc08b1a107944cb8fd466522de4e9ec2127f6ce9", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c71970eea2954b40b2b9f195507bc56d2507c5ac/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71970eea2954b40b2b9f195507bc56d2507c5ac/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=c71970eea2954b40b2b9f195507bc56d2507c5ac", "patch": "@@ -17,7 +17,7 @@ use middle::subst;\n use middle::subst::{Subst, Substs};\n use middle::traits;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n-use trans::base::{set_llvm_fn_attrs, set_inline_hint};\n+use trans::attributes;\n use trans::base::{trans_enum_variant, push_ctxt, get_item_val};\n use trans::base::{trans_fn, decl_internal_rust_fn};\n use trans::base;\n@@ -151,7 +151,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     };\n     let setup_lldecl = |lldecl, attrs: &[ast::Attribute]| {\n         base::update_linkage(ccx, lldecl, None, base::OriginalTranslation);\n-        set_llvm_fn_attrs(ccx, attrs, lldecl);\n+        attributes::convert_fn_attrs_to_llvm(ccx, attrs, lldecl);\n \n         let is_first = !ccx.available_monomorphizations().borrow().contains(&s);\n         if is_first {\n@@ -200,7 +200,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let tvs = ty::enum_variants(ccx.tcx(), local_def(parent));\n             let this_tv = tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n             let d = mk_lldecl(abi::Rust);\n-            set_inline_hint(d);\n+            attributes::inline(d, attributes::InlineHint);\n             match v.node.kind {\n                 ast::TupleVariantKind(ref args) => {\n                     trans_enum_variant(ccx,\n@@ -259,7 +259,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         ast_map::NodeStructCtor(struct_def) => {\n             let d = mk_lldecl(abi::Rust);\n-            set_inline_hint(d);\n+            attributes::inline(d, attributes::InlineHint);\n             base::trans_tuple_struct(ccx,\n                                      &struct_def.fields,\n                                      struct_def.ctor_id.expect(\"ast-mapped tuple struct \\"}]}