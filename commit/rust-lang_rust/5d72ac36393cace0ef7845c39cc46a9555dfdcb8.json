{"sha": "5d72ac36393cace0ef7845c39cc46a9555dfdcb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNzJhYzM2MzkzY2FjZTBlZjc4NDVjMzljYzQ2YTk1NTVkZmRjYjg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-29T15:58:44Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-29T15:58:44Z"}, "message": "libsyntax: introduce 'fn is_keyword_ahead(dist, keywords)'.", "tree": {"sha": "cd2c7cd44056d73fbde9e9a73941e8299670293e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd2c7cd44056d73fbde9e9a73941e8299670293e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d72ac36393cace0ef7845c39cc46a9555dfdcb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d72ac36393cace0ef7845c39cc46a9555dfdcb8", "html_url": "https://github.com/rust-lang/rust/commit/5d72ac36393cace0ef7845c39cc46a9555dfdcb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d72ac36393cace0ef7845c39cc46a9555dfdcb8/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "html_url": "https://github.com/rust-lang/rust/commit/4b9d80325a65b0375eea526409a0f3aaf1cbc23c"}], "stats": {"total": 73, "additions": 38, "deletions": 35}, "files": [{"sha": "746e9cad4962ca4057e9214ef433aedaedade7f2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5d72ac36393cace0ef7845c39cc46a9555dfdcb8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d72ac36393cace0ef7845c39cc46a9555dfdcb8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5d72ac36393cace0ef7845c39cc46a9555dfdcb8", "patch": "@@ -1087,6 +1087,11 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Returns whether any of the given keywords are `dist` tokens ahead of the current one.\n+    fn is_keyword_ahead(&self, dist: usize, kws: &[Symbol]) -> bool {\n+        self.look_ahead(dist, |t| kws.iter().any(|&kw| t.is_keyword(kw)))\n+    }\n+\n     /// Is the current token one of the keywords that signals a bare function type?\n     fn token_is_bare_fn_keyword(&mut self) -> bool {\n         self.check_keyword(kw::Fn) ||\n@@ -4270,7 +4275,7 @@ impl<'a> Parser<'a> {\n         self.token.is_keyword(kw::Async) &&\n         (\n             ( // `async move {`\n-                self.look_ahead(1, |t| t.is_keyword(kw::Move)) &&\n+                self.is_keyword_ahead(1, &[kw::Move]) &&\n                 self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))\n             ) || ( // `async {`\n                 self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace))\n@@ -4280,12 +4285,12 @@ impl<'a> Parser<'a> {\n \n     fn is_async_fn(&self) -> bool {\n         self.token.is_keyword(kw::Async) &&\n-            self.look_ahead(1, |t| t.is_keyword(kw::Fn))\n+            self.is_keyword_ahead(1, &[kw::Fn])\n     }\n \n     fn is_do_catch_block(&self) -> bool {\n         self.token.is_keyword(kw::Do) &&\n-        self.look_ahead(1, |t| t.is_keyword(kw::Catch)) &&\n+        self.is_keyword_ahead(1, &[kw::Catch]) &&\n         self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace)) &&\n         !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n     }\n@@ -4309,17 +4314,17 @@ impl<'a> Parser<'a> {\n \n     fn is_existential_type_decl(&self) -> bool {\n         self.token.is_keyword(kw::Existential) &&\n-        self.look_ahead(1, |t| t.is_keyword(kw::Type))\n+        self.is_keyword_ahead(1, &[kw::Type])\n     }\n \n     fn is_auto_trait_item(&self) -> bool {\n         // auto trait\n-        (self.token.is_keyword(kw::Auto)\n-            && self.look_ahead(1, |t| t.is_keyword(kw::Trait)))\n+        (self.token.is_keyword(kw::Auto) &&\n+            self.is_keyword_ahead(1, &[kw::Trait]))\n         || // unsafe auto trait\n         (self.token.is_keyword(kw::Unsafe) &&\n-         self.look_ahead(1, |t| t.is_keyword(kw::Auto)) &&\n-         self.look_ahead(2, |t| t.is_keyword(kw::Trait)))\n+         self.is_keyword_ahead(1, &[kw::Auto]) &&\n+         self.is_keyword_ahead(2, &[kw::Trait]))\n     }\n \n     fn eat_macro_def(&mut self, attrs: &[Attribute], vis: &Visibility, lo: Span)\n@@ -5486,7 +5491,7 @@ impl<'a> Parser<'a> {\n                 (if isolated_self(self, 1) {\n                     self.bump();\n                     SelfKind::Region(None, Mutability::Immutable)\n-                } else if self.look_ahead(1, |t| t.is_keyword(kw::Mut)) &&\n+                } else if self.is_keyword_ahead(1, &[kw::Mut]) &&\n                           isolated_self(self, 2) {\n                     self.bump();\n                     self.bump();\n@@ -5497,7 +5502,7 @@ impl<'a> Parser<'a> {\n                     let lt = self.expect_lifetime();\n                     SelfKind::Region(Some(lt), Mutability::Immutable)\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n-                          self.look_ahead(2, |t| t.is_keyword(kw::Mut)) &&\n+                          self.is_keyword_ahead(2, &[kw::Mut]) &&\n                           isolated_self(self, 3) {\n                     self.bump();\n                     let lt = self.expect_lifetime();\n@@ -5676,8 +5681,7 @@ impl<'a> Parser<'a> {\n     /// (returns `false` for things like `const fn`, etc.).\n     fn is_const_item(&self) -> bool {\n         self.token.is_keyword(kw::Const) &&\n-            !self.look_ahead(1, |t| t.is_keyword(kw::Fn)) &&\n-            !self.look_ahead(1, |t| t.is_keyword(kw::Unsafe))\n+            !self.is_keyword_ahead(1, &[kw::Fn, kw::Unsafe])\n     }\n \n     /// Parses all the \"front matter\" for a `fn` declaration, up to\n@@ -5955,7 +5959,7 @@ impl<'a> Parser<'a> {\n              self.look_ahead(1, |t| t.is_lifetime() || t.is_ident()) &&\n                 self.look_ahead(2, |t| t == &token::Gt || t == &token::Comma ||\n                                        t == &token::Colon || t == &token::Eq) ||\n-             self.look_ahead(1, |t| t.is_keyword(kw::Const)))\n+            self.is_keyword_ahead(1, &[kw::Const]))\n     }\n \n     fn parse_impl_body(&mut self) -> PResult<'a, (Vec<ImplItem>, Vec<Attribute>)> {\n@@ -6316,7 +6320,7 @@ impl<'a> Parser<'a> {\n             // `()` or a tuple might be allowed. For example, `struct Struct(pub (), pub (usize));`.\n             // Because of this, we only `bump` the `(` if we're assured it is appropriate to do so\n             // by the following tokens.\n-            if self.look_ahead(1, |t| t.is_keyword(kw::Crate)) &&\n+            if self.is_keyword_ahead(1, &[kw::Crate]) &&\n                 self.look_ahead(2, |t| t != &token::ModSep) // account for `pub(crate::foo)`\n             {\n                 // `pub(crate)`\n@@ -6328,7 +6332,7 @@ impl<'a> Parser<'a> {\n                     VisibilityKind::Crate(CrateSugar::PubCrate),\n                 );\n                 return Ok(vis)\n-            } else if self.look_ahead(1, |t| t.is_keyword(kw::In)) {\n+            } else if self.is_keyword_ahead(1, &[kw::In]) {\n                 // `pub(in path)`\n                 self.bump(); // `(`\n                 self.bump(); // `in`\n@@ -6340,8 +6344,7 @@ impl<'a> Parser<'a> {\n                 });\n                 return Ok(vis)\n             } else if self.look_ahead(2, |t| t == &token::CloseDelim(token::Paren)) &&\n-                      self.look_ahead(1, |t| t.is_keyword(kw::Super) ||\n-                                             t.is_keyword(kw::SelfLower))\n+                      self.is_keyword_ahead(1, &[kw::Super, kw::SelfLower])\n             {\n                 // `pub(self)` or `pub(super)`\n                 self.bump(); // `(`\n@@ -6380,13 +6383,16 @@ impl<'a> Parser<'a> {\n     fn parse_defaultness(&mut self) -> Defaultness {\n         // `pub` is included for better error messages\n         if self.check_keyword(kw::Default) &&\n-           self.look_ahead(1, |t| t.is_keyword(kw::Impl) ||\n-                                  t.is_keyword(kw::Const) ||\n-                                  t.is_keyword(kw::Fn) ||\n-                                  t.is_keyword(kw::Unsafe) ||\n-                                  t.is_keyword(kw::Extern) ||\n-                                  t.is_keyword(kw::Type) ||\n-                                  t.is_keyword(kw::Pub)) {\n+            self.is_keyword_ahead(1, &[\n+                kw::Impl,\n+                kw::Const,\n+                kw::Fn,\n+                kw::Unsafe,\n+                kw::Extern,\n+                kw::Type,\n+                kw::Pub,\n+            ])\n+        {\n             self.bump(); // `default`\n             Defaultness::Default\n         } else {\n@@ -6880,7 +6886,7 @@ impl<'a> Parser<'a> {\n         //     Ident [\"<\"...\">\"] [\"where\" ...] (\"=\" | \":\") Ty \";\"\n         if self.check_keyword(kw::Type) ||\n            self.check_keyword(kw::Existential) &&\n-                self.look_ahead(1, |t| t.is_keyword(kw::Type)) {\n+                self.is_keyword_ahead(1, &[kw::Type]) {\n             let existential = self.eat_keyword(kw::Existential);\n             assert!(self.eat_keyword(kw::Type));\n             Some(self.parse_existential_or_alias(existential))\n@@ -7157,7 +7163,7 @@ impl<'a> Parser<'a> {\n             let const_span = self.prev_span;\n             if self.check_keyword(kw::Fn)\n                 || (self.check_keyword(kw::Unsafe)\n-                    && self.look_ahead(1, |t| t.is_keyword(kw::Fn))) {\n+                    && self.is_keyword_ahead(1, &[kw::Fn])) {\n                 // CONST FUNCTION ITEM\n                 let unsafety = self.parse_unsafety();\n                 self.bump();\n@@ -7202,10 +7208,10 @@ impl<'a> Parser<'a> {\n         // `unsafe async fn` or `async fn`\n         if (\n             self.check_keyword(kw::Unsafe) &&\n-            self.look_ahead(1, |t| t.is_keyword(kw::Async))\n+            self.is_keyword_ahead(1, &[kw::Async])\n         ) || (\n             self.check_keyword(kw::Async) &&\n-            self.look_ahead(1, |t| t.is_keyword(kw::Fn))\n+            self.is_keyword_ahead(1, &[kw::Fn])\n         )\n         {\n             // ASYNC FUNCTION ITEM\n@@ -7239,8 +7245,7 @@ impl<'a> Parser<'a> {\n             return Ok(Some(item));\n         }\n         if self.check_keyword(kw::Unsafe) &&\n-            (self.look_ahead(1, |t| t.is_keyword(kw::Trait)) ||\n-            self.look_ahead(1, |t| t.is_keyword(kw::Auto)))\n+            self.is_keyword_ahead(1, &[kw::Trait, kw::Auto])\n         {\n             // UNSAFE TRAIT ITEM\n             self.bump(); // `unsafe`\n@@ -7263,11 +7268,9 @@ impl<'a> Parser<'a> {\n         }\n         if self.check_keyword(kw::Impl) ||\n            self.check_keyword(kw::Unsafe) &&\n-                self.look_ahead(1, |t| t.is_keyword(kw::Impl)) ||\n-           self.check_keyword(kw::Default) &&\n-                self.look_ahead(1, |t| t.is_keyword(kw::Impl)) ||\n+                self.is_keyword_ahead(1, &[kw::Impl]) ||\n            self.check_keyword(kw::Default) &&\n-                self.look_ahead(1, |t| t.is_keyword(kw::Unsafe)) {\n+                self.is_keyword_ahead(1, &[kw::Impl, kw::Unsafe]) {\n             // IMPL ITEM\n             let defaultness = self.parse_defaultness();\n             let unsafety = self.parse_unsafety();\n@@ -7360,7 +7363,7 @@ impl<'a> Parser<'a> {\n         }\n         if self.check_keyword(kw::Trait)\n             || (self.check_keyword(kw::Auto)\n-                && self.look_ahead(1, |t| t.is_keyword(kw::Trait)))\n+                && self.is_keyword_ahead(1, &[kw::Trait]))\n         {\n             let is_auto = if self.eat_keyword(kw::Trait) {\n                 IsAuto::No"}]}