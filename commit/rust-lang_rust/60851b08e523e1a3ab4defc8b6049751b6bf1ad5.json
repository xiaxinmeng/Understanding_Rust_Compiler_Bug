{"sha": "60851b08e523e1a3ab4defc8b6049751b6bf1ad5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwODUxYjA4ZTUyM2UxYTNhYjRkZWZjOGI2MDQ5NzUxYjZiZjFhZDU=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-10-14T23:11:30Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-10-15T19:53:08Z"}, "message": "Optimize `BitSet` iteration.\n\nThis commit removes an `Option` check in `BitIter::next()`, avoids\ncalling `trailing_zeros()` when it's not necessary, and avoids the need\nfor `enumerate()`. This gives a tiny (0.2%) instruction count win on a\ncouple of benchmarks.\n\nThe commit also adds some comments, which is good because this iteration\ncode is moderately complex.", "tree": {"sha": "5257d399c52f50a9de0d9f04844d3748f2e540ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5257d399c52f50a9de0d9f04844d3748f2e540ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60851b08e523e1a3ab4defc8b6049751b6bf1ad5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60851b08e523e1a3ab4defc8b6049751b6bf1ad5", "html_url": "https://github.com/rust-lang/rust/commit/60851b08e523e1a3ab4defc8b6049751b6bf1ad5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60851b08e523e1a3ab4defc8b6049751b6bf1ad5/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2918a7d5a9e65721a31598b50e975ae0882feac3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2918a7d5a9e65721a31598b50e975ae0882feac3", "html_url": "https://github.com/rust-lang/rust/commit/2918a7d5a9e65721a31598b50e975ae0882feac3"}], "stats": {"total": 44, "additions": 31, "deletions": 13}, "files": [{"sha": "d8c6e4c33e2faaad6b57a25ebe60846d32ed32f3", "filename": "src/librustc_index/bit_set.rs", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/60851b08e523e1a3ab4defc8b6049751b6bf1ad5/src%2Flibrustc_index%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60851b08e523e1a3ab4defc8b6049751b6bf1ad5/src%2Flibrustc_index%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fbit_set.rs?ref=60851b08e523e1a3ab4defc8b6049751b6bf1ad5", "patch": "@@ -287,17 +287,32 @@ impl<T: Idx> ToString for BitSet<T> {\n }\n \n pub struct BitIter<'a, T: Idx> {\n-    cur: Option<(Word, usize)>,\n-    iter: iter::Enumerate<slice::Iter<'a, Word>>,\n+    /// A copy of the current word, but with any already-visited bits cleared.\n+    /// (This lets us use `trailing_zeros()` to find the next set bit.) When it\n+    /// is reduced to 0, we move onto the next word.\n+    word: Word,\n+\n+    /// The offset (measured in bits) of the current word.\n+    offset: usize,\n+\n+    /// Underlying iterator over the words.\n+    iter: slice::Iter<'a, Word>,\n+\n     marker: PhantomData<T>\n }\n \n impl<'a, T: Idx> BitIter<'a, T> {\n     #[inline]\n     fn new(words: &'a [Word]) -> BitIter<'a, T> {\n+        // We initialize `word` and `offset` to degenerate values. On the first\n+        // call to `next()` we will fall through to getting the first word from\n+        // `iter`, which sets `word` to the first word (if there is one) and\n+        // `offset` to 0. Doing it this way saves us from having to maintain\n+        // additional state about whether we have started.\n         BitIter {\n-            cur: None,\n-            iter: words.iter().enumerate(),\n+            word: 0,\n+            offset: std::usize::MAX - (WORD_BITS - 1),\n+            iter: words.iter(),\n             marker: PhantomData,\n         }\n     }\n@@ -307,17 +322,20 @@ impl<'a, T: Idx> Iterator for BitIter<'a, T> {\n     type Item = T;\n     fn next(&mut self) -> Option<T> {\n         loop {\n-            if let Some((ref mut word, offset)) = self.cur {\n-                let bit_pos = word.trailing_zeros() as usize;\n-                if bit_pos != WORD_BITS {\n-                    let bit = 1 << bit_pos;\n-                    *word ^= bit;\n-                    return Some(T::new(bit_pos + offset))\n-                }\n+            if self.word != 0 {\n+                // Get the position of the next set bit in the current word,\n+                // then clear the bit.\n+                let bit_pos = self.word.trailing_zeros() as usize;\n+                let bit = 1 << bit_pos;\n+                self.word ^= bit;\n+                return Some(T::new(bit_pos + self.offset))\n             }\n \n-            let (i, word) = self.iter.next()?;\n-            self.cur = Some((*word, WORD_BITS * i));\n+            // Move onto the next word. `wrapping_add()` is needed to handle\n+            // the degenerate initial value given to `offset` in `new()`.\n+            let word = self.iter.next()?;\n+            self.word = *word;\n+            self.offset = self.offset.wrapping_add(WORD_BITS);\n         }\n     }\n }"}]}