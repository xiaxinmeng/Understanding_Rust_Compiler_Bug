{"sha": "20f55c193dea0a893c869dd7a9cf3e2298635221", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwZjU1YzE5M2RlYTBhODkzYzg2OWRkN2E5Y2YzZTIyOTg2MzUyMjE=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-07-27T23:25:08Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-07-28T22:08:19Z"}, "message": "Refactor MIR coverage instrumentation\n\nLays a better foundation for injecting more counters in each function.", "tree": {"sha": "5ad78ef2acb3bcec40463564052c11662421b194", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ad78ef2acb3bcec40463564052c11662421b194"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20f55c193dea0a893c869dd7a9cf3e2298635221", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20f55c193dea0a893c869dd7a9cf3e2298635221", "html_url": "https://github.com/rust-lang/rust/commit/20f55c193dea0a893c869dd7a9cf3e2298635221", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20f55c193dea0a893c869dd7a9cf3e2298635221/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12ddd6073abecb7a515a43bee37408596e322345", "url": "https://api.github.com/repos/rust-lang/rust/commits/12ddd6073abecb7a515a43bee37408596e322345", "html_url": "https://github.com/rust-lang/rust/commit/12ddd6073abecb7a515a43bee37408596e322345"}], "stats": {"total": 271, "additions": 151, "deletions": 120}, "files": [{"sha": "f68d25ee76c44e1e6001d9e7ad2694a64dcebb42", "filename": "src/librustc_codegen_llvm/coverageinfo/mapgen.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20f55c193dea0a893c869dd7a9cf3e2298635221/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20f55c193dea0a893c869dd7a9cf3e2298635221/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs?ref=20f55c193dea0a893c869dd7a9cf3e2298635221", "patch": "@@ -24,7 +24,7 @@ use std::ffi::CString;\n /// replicated for Rust's Coverage Map.\n pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n     let function_coverage_map = cx.coverage_context().take_function_coverage_map();\n-    if function_coverage_map.len() == 0 {\n+    if function_coverage_map.is_empty() {\n         // This module has no functions with coverage instrumentation\n         return;\n     }\n@@ -81,7 +81,7 @@ struct CoverageMapGenerator {\n \n impl CoverageMapGenerator {\n     fn new() -> Self {\n-        Self { filenames: Vec::new(), filename_to_index: FxHashMap::<CString, u32>::default() }\n+        Self { filenames: Vec::new(), filename_to_index: FxHashMap::default() }\n     }\n \n     /// Using the `expressions` and `counter_regions` collected for the current function, generate\n@@ -95,7 +95,7 @@ impl CoverageMapGenerator {\n         coverage_mappings_buffer: &RustString,\n     ) {\n         let mut counter_regions = counter_regions.collect::<Vec<_>>();\n-        if counter_regions.len() == 0 {\n+        if counter_regions.is_empty() {\n             return;\n         }\n \n@@ -109,7 +109,7 @@ impl CoverageMapGenerator {\n         // `file_id` (indexing files referenced by the current function), and construct the\n         // function-specific `virtual_file_mapping` from `file_id` to its index in the module's\n         // `filenames` array.\n-        counter_regions.sort_by_key(|(_counter, region)| *region);\n+        counter_regions.sort_unstable_by_key(|(_counter, region)| *region);\n         for (counter, region) in counter_regions {\n             let (file_path, start_line, start_col, end_line, end_col) = region.file_start_and_end();\n             let same_file = current_file_path.as_ref().map_or(false, |p| p == file_path);"}, {"sha": "f515f50e350ba3628f4139c7f1700643bc2835c6", "filename": "src/librustc_codegen_llvm/coverageinfo/mod.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/20f55c193dea0a893c869dd7a9cf3e2298635221/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20f55c193dea0a893c869dd7a9cf3e2298635221/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs?ref=20f55c193dea0a893c869dd7a9cf3e2298635221", "patch": "@@ -110,36 +110,37 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n-/// Aligns to C++ struct llvm::coverage::Counter::CounterKind.\n-/// The order of discrimiators is important.\n+/// Aligns with [llvm::coverage::CounterMappingRegion::RegionKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L205-L221)\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n enum RegionKind {\n     /// A CodeRegion associates some code with a counter\n-    CodeRegion,\n+    CodeRegion = 0,\n \n     /// An ExpansionRegion represents a file expansion region that associates\n     /// a source range with the expansion of a virtual source file, such as\n     /// for a macro instantiation or #include file.\n-    ExpansionRegion,\n+    ExpansionRegion = 1,\n \n     /// A SkippedRegion represents a source range with code that was skipped\n     /// by a preprocessor or similar means.\n-    SkippedRegion,\n+    SkippedRegion = 2,\n \n     /// A GapRegion is like a CodeRegion, but its count is only set as the\n     /// line execution count when its the only region in the line.\n-    GapRegion,\n+    GapRegion = 3,\n }\n \n /// This struct provides LLVM's representation of a \"CoverageMappingRegion\", encoded into the\n-/// coverage map in accordance with LLVM's \"Coverage Mapping Format\". The struct composes fields\n-/// representing the `Counter` type and value(s) (injected counter ID, or expression type and\n-/// operands), the source file (an indirect index into a \"filenames array\", encoded separately),\n-/// and source location (start and end positions of the represented code region).\n+/// coverage map, in accordance with the\n+/// [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n+/// The struct composes fields representing the `Counter` type and value(s) (injected counter ID,\n+/// or expression type and operands), the source file (an indirect index into a \"filenames array\",\n+/// encoded separately), and source location (start and end positions of the represented code\n+/// region).\n ///\n-/// Aligns to C++ struct llvm::coverage::CounterMappingRegion.\n-/// The order of fields is important.\n+/// Aligns with [llvm::coverage::CounterMappingRegion](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L223-L226)\n+/// Important: The Rust struct layout (order and types of fields) must match its C++ counterpart.\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct CounterMappingRegion {"}, {"sha": "c72ee57ad6ff9aafb297c031d6a97fdf27f85990", "filename": "src/librustc_codegen_ssa/coverageinfo/map.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/20f55c193dea0a893c869dd7a9cf3e2298635221/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20f55c193dea0a893c869dd7a9cf3e2298635221/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs?ref=20f55c193dea0a893c869dd7a9cf3e2298635221", "patch": "@@ -7,26 +7,28 @@ use std::cmp::{Ord, Ordering};\n use std::fmt;\n use std::path::PathBuf;\n \n-/// Aligns to C++ struct llvm::coverage::Counter::CounterKind.\n-/// The order of discriminators is important.\n+/// Aligns with [llvm::coverage::Counter::CounterKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L91)\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n enum CounterKind {\n-    Zero,\n-    CounterValueReference,\n-    Expression,\n+    Zero = 0,\n+    CounterValueReference = 1,\n+    Expression = 2,\n }\n \n-/// Aligns to C++ struct llvm::coverage::Counter. Note that `id` has\n-/// different interpretations, depending on the `kind`:\n+/// A reference to an instance of an abstract \"counter\" that will yield a value in a coverage\n+/// report. Note that `id` has different interpretations, depending on the `kind`:\n ///   * For `CounterKind::Zero`, `id` is assumed to be `0`\n ///   * For `CounterKind::CounterValueReference`,  `id` matches the `counter_id` of the injected\n ///     instrumentation counter (the `index` argument to the LLVM intrinsic `instrprof.increment()`)\n-///   * For `CounterKind::Expression`, `id` is the index into the array of counter expressions.\n-/// The order of fields is important.\n+///   * For `CounterKind::Expression`, `id` is the index into the coverage map's array of counter\n+///     expressions.\n+/// Aligns with [llvm::coverage::Counter](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L98-L99)\n+/// Important: The Rust struct layout (order and types of fields) must match its C++ counterpart.\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct Counter {\n+    // Important: The layout (order and types of fields) must match its C++ counterpart.\n     kind: CounterKind,\n     id: u32,\n }\n@@ -45,21 +47,19 @@ impl Counter {\n     }\n }\n \n-/// Aligns to C++ struct llvm::coverage::CounterExpression::ExprKind.\n-/// The order of discriminators is important.\n+/// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L146)\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub enum ExprKind {\n-    Subtract,\n-    Add,\n+    Subtract = 0,\n+    Add = 1,\n }\n \n-/// Aligns to C++ struct llvm::coverage::CounterExpression.\n-/// The order of fields is important.\n+/// Aligns with [llvm::coverage::CounterExpression](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L147-L148)\n+/// Important: The Rust struct layout (order and types of fields) must match its C++ counterpart.\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct CounterExpression {\n-    // Note the field order is important.\n     kind: ExprKind,\n     lhs: Counter,\n     rhs: Counter,"}, {"sha": "fe63a67fdbb34cd1041ce89ce95584d5a37a9c2f", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "modified", "additions": 105, "deletions": 79, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/20f55c193dea0a893c869dd7a9cf3e2298635221/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20f55c193dea0a893c869dd7a9cf3e2298635221/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=20f55c193dea0a893c869dd7a9cf3e2298635221", "patch": "@@ -7,10 +7,9 @@ use rustc_middle::hir;\n use rustc_middle::ich::StableHashingContext;\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::interpret::Scalar;\n-use rustc_middle::mir::CoverageInfo;\n use rustc_middle::mir::{\n-    self, traversal, BasicBlock, BasicBlockData, Operand, Place, SourceInfo, StatementKind,\n-    Terminator, TerminatorKind, START_BLOCK,\n+    self, traversal, BasicBlock, BasicBlockData, CoverageInfo, Operand, Place, SourceInfo,\n+    SourceScope, StatementKind, Terminator, TerminatorKind,\n };\n use rustc_middle::ty;\n use rustc_middle::ty::query::Providers;\n@@ -41,14 +40,14 @@ fn coverageinfo_from_mir<'tcx>(tcx: TyCtxt<'tcx>, mir_def_id: DefId) -> Coverage\n         tcx.require_lang_item(lang_items::CoverageCounterSubtractFnLangItem, None);\n \n     // The `num_counters` argument to `llvm.instrprof.increment` is the number of injected\n-    // counters, with each counter having an index from `0..num_counters-1`. MIR optimization\n+    // counters, with each counter having a counter ID from `0..num_counters-1`. MIR optimization\n     // may split and duplicate some BasicBlock sequences. Simply counting the calls may not\n-    // not work; but computing the num_counters by adding `1` to the highest index (for a given\n+    // work; but computing the num_counters by adding `1` to the highest counter_id (for a given\n     // instrumented function) is valid.\n     //\n     // `num_expressions` is the number of counter expressions added to the MIR body. Both\n     // `num_counters` and `num_expressions` are used to initialize new vectors, during backend\n-    // code generate, to lookup counters and expressions by their simple u32 indexes.\n+    // code generate, to lookup counters and expressions by simple u32 indexes.\n     let mut num_counters: u32 = 0;\n     let mut num_expressions: u32 = 0;\n     for terminator in\n@@ -57,27 +56,26 @@ fn coverageinfo_from_mir<'tcx>(tcx: TyCtxt<'tcx>, mir_def_id: DefId) -> Coverage\n         if let TerminatorKind::Call { func: Operand::Constant(func), args, .. } = &terminator.kind {\n             match func.literal.ty.kind {\n                 FnDef(id, _) if id == count_code_region_fn => {\n-                    let index_arg =\n+                    let counter_id_arg =\n                         args.get(count_code_region_args::COUNTER_ID).expect(\"arg found\");\n-                    let counter_index = mir::Operand::scalar_from_const(index_arg)\n+                    let counter_id = mir::Operand::scalar_from_const(counter_id_arg)\n                         .to_u32()\n-                        .expect(\"index arg is u32\");\n-                    num_counters = std::cmp::max(num_counters, counter_index + 1);\n+                        .expect(\"counter_id arg is u32\");\n+                    num_counters = std::cmp::max(num_counters, counter_id + 1);\n                 }\n                 FnDef(id, _)\n                     if id == coverage_counter_add_fn || id == coverage_counter_subtract_fn =>\n                 {\n-                    let index_arg = args\n+                    let expression_id_arg = args\n                         .get(coverage_counter_expression_args::EXPRESSION_ID)\n                         .expect(\"arg found\");\n-                    let translated_index = mir::Operand::scalar_from_const(index_arg)\n+                    let id_descending_from_max = mir::Operand::scalar_from_const(expression_id_arg)\n                         .to_u32()\n-                        .expect(\"index arg is u32\");\n-                    // Counter expressions start with \"translated indexes\", descending from\n-                    // `u32::MAX`, so the range of expression indexes is disjoint from the range of\n-                    // counter indexes. This way, both counters and expressions can be operands in\n-                    // other expressions.\n-                    let expression_index = u32::MAX - translated_index;\n+                        .expect(\"expression_id arg is u32\");\n+                    // Counter expressions are initially assigned IDs descending from `u32::MAX`, so\n+                    // the range of expression IDs is disjoint from the range of counter IDs. This\n+                    // way, both counters and expressions can be operands in other expressions.\n+                    let expression_index = u32::MAX - id_descending_from_max;\n                     num_expressions = std::cmp::max(num_expressions, expression_index + 1);\n                 }\n                 _ => {}\n@@ -97,12 +95,10 @@ fn call_terminators(data: &'tcx BasicBlockData<'tcx>) -> Option<&'tcx Terminator\n \n impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, mir_body: &mut mir::Body<'tcx>) {\n-        if tcx.sess.opts.debugging_opts.instrument_coverage {\n-            // If the InstrumentCoverage pass is called on promoted MIRs, skip them.\n-            // See: https://github.com/rust-lang/rust/pull/73011#discussion_r438317601\n-            if src.promoted.is_none() {\n-                Instrumentor::new(tcx, src, mir_body).inject_counters();\n-            }\n+        // If the InstrumentCoverage pass is called on promoted MIRs, skip them.\n+        // See: https://github.com/rust-lang/rust/pull/73011#discussion_r438317601\n+        if src.promoted.is_none() {\n+            Instrumentor::new(tcx, src, mir_body).inject_counters();\n         }\n     }\n }\n@@ -113,6 +109,12 @@ enum Op {\n     Subtract,\n }\n \n+struct InjectedCall<'tcx> {\n+    func: Operand<'tcx>,\n+    args: Vec<Operand<'tcx>>,\n+    inject_at: Span,\n+}\n+\n struct Instrumentor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     mir_def_id: DefId,\n@@ -147,11 +149,8 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n     }\n \n     /// Expression IDs start from u32::MAX and go down because a CounterExpression can reference\n-    /// (add or subtract counts) of both Counter regions and CounterExpression regions. The indexes\n-    /// of each type of region must be contiguous, but also must be unique across both sets.\n-    /// The expression IDs are eventually translated into region indexes (starting after the last\n-    /// counter index, for the given function), during backend code generation, by the helper method\n-    /// `rustc_codegen_ssa::coverageinfo::map::FunctionCoverage::translate_expressions()`.\n+    /// (add or subtract counts) of both Counter regions and CounterExpression regions. The counter\n+    /// expression operand IDs must be unique across both types.\n     fn next_expression(&mut self) -> u32 {\n         assert!(self.num_counters < u32::MAX - self.num_expressions);\n         let next = u32::MAX - self.num_expressions;\n@@ -171,17 +170,25 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n     }\n \n     fn inject_counters(&mut self) {\n+        let mir_body = &self.mir_body;\n         let body_span = self.hir_body.value.span;\n-        debug!(\n-            \"instrumenting {:?}, span: {}\",\n-            self.mir_def_id,\n-            self.tcx.sess.source_map().span_to_string(body_span)\n-        );\n+        debug!(\"instrumenting {:?}, span: {:?}\", self.mir_def_id, body_span);\n \n         // FIXME(richkadel): As a first step, counters are only injected at the top of each\n         // function. The complete solution will inject counters at each conditional code branch.\n-        let next_block = START_BLOCK;\n-        self.inject_counter(body_span, next_block);\n+        let _ignore = mir_body;\n+        let id = self.next_counter();\n+        let function_source_hash = self.function_source_hash();\n+        let code_region = body_span;\n+        let scope = rustc_middle::mir::OUTERMOST_SOURCE_SCOPE;\n+        let is_cleanup = false;\n+        let next_block = rustc_middle::mir::START_BLOCK;\n+        self.inject_call(\n+            self.make_counter(id, function_source_hash, code_region),\n+            scope,\n+            is_cleanup,\n+            next_block,\n+        );\n \n         // FIXME(richkadel): The next step to implement source based coverage analysis will be\n         // instrumenting branches within functions, and some regions will be counted by \"counter\n@@ -190,57 +197,68 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         let fake_use = false;\n         if fake_use {\n             let add = false;\n-            if add {\n-                self.inject_counter_expression(body_span, next_block, 1, Op::Add, 2);\n-            } else {\n-                self.inject_counter_expression(body_span, next_block, 1, Op::Subtract, 2);\n-            }\n+            let lhs = 1;\n+            let op = if add { Op::Add } else { Op::Subtract };\n+            let rhs = 2;\n+\n+            let code_region = body_span;\n+            let scope = rustc_middle::mir::OUTERMOST_SOURCE_SCOPE;\n+            let is_cleanup = false;\n+            let next_block = rustc_middle::mir::START_BLOCK;\n+\n+            let id = self.next_expression();\n+            self.inject_call(\n+                self.make_expression(id, code_region, lhs, op, rhs),\n+                scope,\n+                is_cleanup,\n+                next_block,\n+            );\n         }\n     }\n \n-    fn inject_counter(&mut self, code_region: Span, next_block: BasicBlock) -> u32 {\n-        let counter_id = self.next_counter();\n-        let function_source_hash = self.function_source_hash();\n-        let injection_point = code_region.shrink_to_lo();\n+    fn make_counter(\n+        &self,\n+        id: u32,\n+        function_source_hash: u64,\n+        code_region: Span,\n+    ) -> InjectedCall<'tcx> {\n+        let inject_at = code_region.shrink_to_lo();\n \n-        let count_code_region_fn = function_handle(\n+        let func = function_handle(\n             self.tcx,\n             self.tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None),\n-            injection_point,\n+            inject_at,\n         );\n \n         let mut args = Vec::new();\n \n         use count_code_region_args::*;\n         debug_assert_eq!(FUNCTION_SOURCE_HASH, args.len());\n-        args.push(self.const_u64(function_source_hash, injection_point));\n+        args.push(self.const_u64(function_source_hash, inject_at));\n \n         debug_assert_eq!(COUNTER_ID, args.len());\n-        args.push(self.const_u32(counter_id, injection_point));\n+        args.push(self.const_u32(id, inject_at));\n \n         debug_assert_eq!(START_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.lo().to_u32(), injection_point));\n+        args.push(self.const_u32(code_region.lo().to_u32(), inject_at));\n \n         debug_assert_eq!(END_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.hi().to_u32(), injection_point));\n-\n-        self.inject_call(count_code_region_fn, args, injection_point, next_block);\n+        args.push(self.const_u32(code_region.hi().to_u32(), inject_at));\n \n-        counter_id\n+        InjectedCall { func, args, inject_at }\n     }\n \n-    fn inject_counter_expression(\n-        &mut self,\n+    fn make_expression(\n+        &self,\n+        id: u32,\n         code_region: Span,\n-        next_block: BasicBlock,\n         lhs: u32,\n         op: Op,\n         rhs: u32,\n-    ) -> u32 {\n-        let expression_id = self.next_expression();\n-        let injection_point = code_region.shrink_to_lo();\n+    ) -> InjectedCall<'tcx> {\n+        let inject_at = code_region.shrink_to_lo();\n \n-        let count_code_region_fn = function_handle(\n+        let func = function_handle(\n             self.tcx,\n             self.tcx.require_lang_item(\n                 match op {\n@@ -249,43 +267,51 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n                 },\n                 None,\n             ),\n-            injection_point,\n+            inject_at,\n         );\n \n         let mut args = Vec::new();\n \n         use coverage_counter_expression_args::*;\n         debug_assert_eq!(EXPRESSION_ID, args.len());\n-        args.push(self.const_u32(expression_id, injection_point));\n+        args.push(self.const_u32(id, inject_at));\n \n         debug_assert_eq!(LEFT_ID, args.len());\n-        args.push(self.const_u32(lhs, injection_point));\n+        args.push(self.const_u32(lhs, inject_at));\n \n         debug_assert_eq!(RIGHT_ID, args.len());\n-        args.push(self.const_u32(rhs, injection_point));\n+        args.push(self.const_u32(rhs, inject_at));\n \n         debug_assert_eq!(START_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.lo().to_u32(), injection_point));\n+        args.push(self.const_u32(code_region.lo().to_u32(), inject_at));\n \n         debug_assert_eq!(END_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.hi().to_u32(), injection_point));\n+        args.push(self.const_u32(code_region.hi().to_u32(), inject_at));\n \n-        self.inject_call(count_code_region_fn, args, injection_point, next_block);\n-\n-        expression_id\n+        InjectedCall { func, args, inject_at }\n     }\n \n     fn inject_call(\n         &mut self,\n-        func: Operand<'tcx>,\n-        args: Vec<Operand<'tcx>>,\n-        fn_span: Span,\n+        call: InjectedCall<'tcx>,\n+        scope: SourceScope,\n+        is_cleanup: bool,\n         next_block: BasicBlock,\n     ) {\n+        let InjectedCall { func, args, inject_at } = call;\n+        debug!(\n+            \"  injecting {}call to {:?}({:?}) at: {:?}, scope: {:?}\",\n+            if is_cleanup { \"cleanup \" } else { \"\" },\n+            func,\n+            args,\n+            inject_at,\n+            scope,\n+        );\n+\n         let mut patch = MirPatch::new(self.mir_body);\n \n-        let temp = patch.new_temp(self.tcx.mk_unit(), fn_span);\n-        let new_block = patch.new_block(placeholder_block(fn_span));\n+        let temp = patch.new_temp(self.tcx.mk_unit(), inject_at);\n+        let new_block = patch.new_block(placeholder_block(inject_at, scope, is_cleanup));\n         patch.patch_terminator(\n             new_block,\n             TerminatorKind::Call {\n@@ -295,7 +321,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n                 destination: Some((Place::from(temp), new_block)),\n                 cleanup: None,\n                 from_hir_call: false,\n-                fn_span,\n+                fn_span: inject_at,\n             },\n         );\n \n@@ -325,15 +351,15 @@ fn function_handle<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, span: Span) -> Ope\n     Operand::function_handle(tcx, fn_def_id, substs, span)\n }\n \n-fn placeholder_block(span: Span) -> BasicBlockData<'tcx> {\n+fn placeholder_block(span: Span, scope: SourceScope, is_cleanup: bool) -> BasicBlockData<'tcx> {\n     BasicBlockData {\n         statements: vec![],\n         terminator: Some(Terminator {\n-            source_info: SourceInfo::outermost(span),\n+            source_info: SourceInfo { span, scope },\n             // this gets overwritten by the counter Call\n             kind: TerminatorKind::Unreachable,\n         }),\n-        is_cleanup: false,\n+        is_cleanup,\n     }\n }\n "}, {"sha": "26b4a6968971d9efc5eb5604f3fd93513203842a", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/20f55c193dea0a893c869dd7a9cf3e2298635221/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20f55c193dea0a893c869dd7a9cf3e2298635221/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=20f55c193dea0a893c869dd7a9cf3e2298635221", "patch": "@@ -332,21 +332,25 @@ fn mir_validated(\n     body.required_consts = required_consts;\n \n     let promote_pass = promote_consts::PromoteTemps::default();\n+    let promote: &[&dyn MirPass<'tcx>] = &[\n+        // What we need to run borrowck etc.\n+        &promote_pass,\n+        &simplify::SimplifyCfg::new(\"qualify-consts\"),\n+    ];\n+\n+    let opt_coverage: &[&dyn MirPass<'tcx>] = if tcx.sess.opts.debugging_opts.instrument_coverage {\n+        &[&instrument_coverage::InstrumentCoverage]\n+    } else {\n+        &[]\n+    };\n+\n     run_passes(\n         tcx,\n         &mut body,\n         InstanceDef::Item(def.to_global()),\n         None,\n         MirPhase::Validated,\n-        &[&[\n-            // What we need to run borrowck etc.\n-            &promote_pass,\n-            &simplify::SimplifyCfg::new(\"qualify-consts\"),\n-            // If the `instrument-coverage` option is enabled, analyze the CFG, identify each\n-            // conditional branch, construct a coverage map to be passed to LLVM, and inject\n-            // counters where needed.\n-            &instrument_coverage::InstrumentCoverage,\n-        ]],\n+        &[promote, opt_coverage],\n     );\n \n     let promoted = promote_pass.promoted_fragments.into_inner();"}]}