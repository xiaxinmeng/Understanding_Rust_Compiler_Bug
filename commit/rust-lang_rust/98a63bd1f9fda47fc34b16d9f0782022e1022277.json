{"sha": "98a63bd1f9fda47fc34b16d9f0782022e1022277", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4YTYzYmQxZjlmZGE0N2ZjMzRiMTZkOWYwNzgyMDIyZTEwMjIyNzc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-02T01:08:46Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-02T01:09:02Z"}, "message": "Add code to fail on non-exhaustive alt matching. Fix all cases this picked up in rustc.", "tree": {"sha": "25796c068e3219553a6b7e984d512523ddd754cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25796c068e3219553a6b7e984d512523ddd754cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98a63bd1f9fda47fc34b16d9f0782022e1022277", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98a63bd1f9fda47fc34b16d9f0782022e1022277", "html_url": "https://github.com/rust-lang/rust/commit/98a63bd1f9fda47fc34b16d9f0782022e1022277", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98a63bd1f9fda47fc34b16d9f0782022e1022277/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd600bad4666758088ec69a355a0dbd86bb11c22", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd600bad4666758088ec69a355a0dbd86bb11c22", "html_url": "https://github.com/rust-lang/rust/commit/fd600bad4666758088ec69a355a0dbd86bb11c22"}], "stats": {"total": 103, "additions": 89, "deletions": 14}, "files": [{"sha": "34f4d81db04b891afd05c406648d1a9debbf8110", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/98a63bd1f9fda47fc34b16d9f0782022e1022277/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/98a63bd1f9fda47fc34b16d9f0782022e1022277/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=98a63bd1f9fda47fc34b16d9f0782022e1022277", "patch": "@@ -4895,7 +4895,14 @@ let trans_visitor\n           last_jump\n     in\n     let last_jumps = Array.map trans_arm at.Ast.alt_tag_arms in\n-      Array.iter patch last_jumps\n+      if not (arr_exists\n+                (fun _ arm -> (fst arm.node) = Ast.PAT_wild)\n+                at.Ast.alt_tag_arms)\n+      then\n+        trans_cond_fail \"non-exhaustive match failure\"\n+          (Array.to_list last_jumps)\n+      else\n+        Array.iter patch last_jumps\n \n   (* If we're about to drop a channel, synthesize an upcall_flush_chan.\n    * TODO: This should rather appear in a chan dtor when chans become"}, {"sha": "f8d3bf0727c3ecc9b261329db357a1de7724ef6b", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/98a63bd1f9fda47fc34b16d9f0782022e1022277/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a63bd1f9fda47fc34b16d9f0782022e1022277/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=98a63bd1f9fda47fc34b16d9f0782022e1022277", "patch": "@@ -388,6 +388,7 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n                                        es.node, ast.ann_none);\n                     hi = es.span;\n                 }\n+                case (_) { /* fall through */ }\n             }\n         }\n \n@@ -401,6 +402,7 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n                     ret @spanned(lo, hi,\n                                  ast.expr_lit(lit, ast.ann_none));\n                 }\n+                case (_) { /* fall through */ }\n             }\n             auto e = parse_expr(p);\n             hi = p.get_span();\n@@ -590,6 +592,7 @@ impure fn parse_binops(parser p,\n                         more = true;\n                     }\n                 }\n+                case (_) { /* fall through */ }\n             }\n         }\n     }\n@@ -711,6 +714,7 @@ impure fn parse_assign_expr(parser p) -> @ast.expr {\n             ret @spanned(lo, rhs.span,\n                          ast.expr_assign(lhs, rhs, ast.ann_none));\n         }\n+        case (_) { /* fall through */ }\n     }\n     ret lhs;\n }\n@@ -733,6 +737,7 @@ impure fn parse_if_expr(parser p) -> @ast.expr {\n             els = some(eblk);\n             hi = eblk.span;\n         }\n+        case (_) { /* fall through */ }\n     }\n     ret @spanned(lo, hi, ast.expr_if(cond, thn, els, ast.ann_none));\n }\n@@ -1039,6 +1044,7 @@ fn index_block(vec[@ast.stmt] stmts, option.t[@ast.expr] expr) -> ast.block_ {\n                     }\n                 }\n             }\n+            case (_) { /* fall through */ }\n         }\n     }\n     ret rec(stmts=stmts, expr=expr, index=index);\n@@ -1211,7 +1217,6 @@ impure fn parse_mod_items(parser p, token.token term) -> ast._mod {\n \n             case (ast.item_tag(?id, ?variants, _, _)) {\n                 index.insert(id, ast.mie_item(u));\n-            \n                 let uint variant_idx = 0u;\n                 for (ast.variant v in variants) {\n                     index.insert(v.name, ast.mie_tag_variant(u, variant_idx));"}, {"sha": "203b8fdaf03a18a0a4b6b253278b89e03b9d8de0", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98a63bd1f9fda47fc34b16d9f0782022e1022277/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a63bd1f9fda47fc34b16d9f0782022e1022277/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=98a63bd1f9fda47fc34b16d9f0782022e1022277", "patch": "@@ -86,6 +86,10 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &span sp,\n          @ast.lit, ann a) -> @expr)               fold_expr_lit,\n \n+     (fn(&ENV e, &span sp,\n+         @ast.expr e, @ast.ty ty,\n+         ann a) -> @expr)                         fold_expr_cast,\n+\n      (fn(&ENV e, &span sp,\n          @expr cond, &block thn,\n          &option.t[block] els,\n@@ -296,11 +300,13 @@ fn fold_decl[ENV](&ENV env, ast_fold[ENV] fld, @decl d) -> @decl {\n                 case (some[@ast.ty](?t)) {\n                     ty_ = some[@ast.ty](fold_ty(env, fld, t));\n                 }\n+                case (_) { /* fall through */  }\n             }\n             alt (local.init) {\n                 case (some[@ast.expr](?e)) {\n                     init_ = some[@ast.expr](fold_expr(env, fld, e));\n                 }\n+                case (_) { /* fall through */  }\n             }\n             let @ast.local local_ = @rec(ty=ty_, init=init_ with *local);\n             ret fld.fold_decl_local(env_, d.span, local_);\n@@ -405,6 +411,12 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n             ret fld.fold_expr_lit(env_, e.span, lit, t);\n         }\n \n+        case (ast.expr_cast(?e, ?t, ?at)) {\n+            auto ee = fold_expr(env_, fld, e);\n+            auto tt = fold_ty(env, fld, t);\n+            ret fld.fold_expr_cast(env_, e.span, ee, tt, at);\n+        }\n+\n         case (ast.expr_if(?cnd, ?thn, ?els, ?t)) {\n             auto ccnd = fold_expr(env_, fld, cnd);\n             auto tthn = fold_block(env_, fld, thn);\n@@ -413,6 +425,7 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n                 case (some[block](?b)) {\n                     eels = some(fold_block(env_, fld, b));\n                 }\n+                case (_) { /* fall through */  }\n             }\n             ret fld.fold_expr_if(env_, e.span, ccnd, tthn, eels, t);\n         }\n@@ -492,6 +505,7 @@ fn fold_stmt[ENV](&ENV env, ast_fold[ENV] fld, &@stmt s) -> @stmt {\n                 case (some[@expr](?e)) {\n                     oee = some(fold_expr(env_, fld, e));\n                 }\n+                case (_) { /* fall through */  }\n             }\n             ret fld.fold_stmt_ret(env_, s.span, oee);\n         }\n@@ -737,6 +751,11 @@ fn identity_fold_expr_lit[ENV](&ENV env, &span sp, @ast.lit lit,\n     ret @respan(sp, ast.expr_lit(lit, a));\n }\n \n+fn identity_fold_expr_cast[ENV](&ENV env, &span sp, @ast.expr e,\n+                                @ast.ty t, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_cast(e, t, a));\n+}\n+\n fn identity_fold_expr_if[ENV](&ENV env, &span sp,\n                               @expr cond, &block thn,\n                               &option.t[block] els, ann a) -> @expr {\n@@ -956,6 +975,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_expr_binary = bind identity_fold_expr_binary[ENV](_,_,_,_,_,_),\n          fold_expr_unary  = bind identity_fold_expr_unary[ENV](_,_,_,_,_),\n          fold_expr_lit    = bind identity_fold_expr_lit[ENV](_,_,_,_),\n+         fold_expr_cast   = bind identity_fold_expr_cast[ENV](_,_,_,_,_),\n          fold_expr_if     = bind identity_fold_expr_if[ENV](_,_,_,_,_,_),\n          fold_expr_while  = bind identity_fold_expr_while[ENV](_,_,_,_,_),\n          fold_expr_do_while"}, {"sha": "498596d60006bf7126bb9411fbde7bede4b83b4b", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98a63bd1f9fda47fc34b16d9f0782022e1022277/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a63bd1f9fda47fc34b16d9f0782022e1022277/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=98a63bd1f9fda47fc34b16d9f0782022e1022277", "patch": "@@ -113,6 +113,7 @@ fn lookup_name(&env e, ast.ident i) -> option.t[def] {\n                     case (some[uint](?ix)) {\n                         ret found_decl_stmt(b.node.stmts.(ix));\n                     }\n+                    case (_) { /* fall through */  }\n                 }\n             }\n         }"}, {"sha": "89055578d5558c29e8acbf5c1ed4aefabf741e7e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/98a63bd1f9fda47fc34b16d9f0782022e1022277/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a63bd1f9fda47fc34b16d9f0782022e1022277/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=98a63bd1f9fda47fc34b16d9f0782022e1022277", "patch": "@@ -295,6 +295,7 @@ fn type_of_inner(@crate_ctxt cx, @typeck.ty t) -> TypeRef {\n                     case (ast.alias) {\n                         t = T_ptr(t);\n                     }\n+                    case (_) { /* fall through */  }\n                 }\n                 atys += t;\n             }\n@@ -506,6 +507,17 @@ fn iter_structural_ty(@block_ctxt cx,\n                 i += 1;\n             }\n         }\n+        case (typeck.ty_rec(?fields)) {\n+            let int i = 0;\n+            for (typeck.field fld in fields) {\n+                auto llfld = r.bcx.build.GEP(v, vec(C_int(0), C_int(i)));\n+                r = f(r.bcx, llfld, fld.ty);\n+                i += 1;\n+            }\n+        }\n+        case (_) {\n+            cx.fcx.ccx.sess.unimpl(\"type in iter_structural_ty\");\n+        }\n         // FIXME: handle records and tags when we support them.\n     }\n     ret r;\n@@ -560,6 +572,7 @@ fn iter_sequence(@block_ctxt cx,\n             auto et = typeck.plain_ty(typeck.ty_machine(common.ty_u8));\n             ret iter_sequence_body(cx, v, et, f, false);\n         }\n+        case (_) { fail; }\n     }\n     cx.fcx.ccx.sess.bug(\"bad type in trans.iter_sequence\");\n     fail;\n@@ -765,6 +778,7 @@ fn target_type(@crate_ctxt cx, @typeck.ty t) -> @typeck.ty {\n             auto tm = typeck.ty_machine(cx.sess.get_targ_cfg().uint_type);\n             ret @rec(struct=tm with *t);\n         }\n+        case (_) { /* fall through */ }\n     }\n     ret t;\n }\n@@ -813,8 +827,10 @@ impure fn trans_unary(@block_ctxt cx, ast.unop op,\n                                             C_int(abi.box_rc_field_refcnt)));\n             ret res(sub.bcx, cx.build.Store(C_int(1), rc));\n         }\n+        case (_) {\n+            cx.fcx.ccx.sess.unimpl(\"expr variant in trans_unary\");\n+        }\n     }\n-    cx.fcx.ccx.sess.unimpl(\"expr variant in trans_unary\");\n     fail;\n }\n \n@@ -859,6 +875,8 @@ impure fn trans_binary(@block_ctxt cx, ast.binop op,\n             ret join_results(cx, T_bool(),\n                              vec(lhs_true_res, rhs_res));\n         }\n+\n+        case (_) { /* fall through */ }\n     }\n \n     // Remaining cases are eager:\n@@ -958,8 +976,11 @@ impure fn trans_binary(@block_ctxt cx, ast.binop op,\n             sub.val = cx.build.ICmp(lib.llvm.LLVMIntSGT, lhs.val, sub.val);\n             ret sub;\n         }\n+\n+        case (_) {\n+            cx.fcx.ccx.sess.unimpl(\"operator in trans_binary\");\n+        }\n     }\n-    cx.fcx.ccx.sess.unimpl(\"expr variant in trans_binary\");\n     fail;\n }\n \n@@ -994,6 +1015,8 @@ fn join_results(@block_ctxt parent_cx,\n             // onward.\n             ret live.(0);\n         }\n+\n+        case (_) { /* fall through */ }\n     }\n \n     // We have >1 incoming edges. Make a join block and br+phi them into it.\n@@ -1020,6 +1043,7 @@ impure fn trans_if(@block_ctxt cx, @ast.expr cond,\n         case (some[ast.block](?eblk)) {\n             else_res = trans_block(else_cx, eblk);\n         }\n+        case (_) { /* fall through */ }\n     }\n \n     cond_res.bcx.build.CondBr(cond_res.val,\n@@ -1119,8 +1143,8 @@ fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n             auto v = r.bcx.build.GEP(r.val, vec(C_int(0), C_int(ix as int)));\n             ret tup(res(r.bcx, v), lv._1);\n         }\n+        case (_) { cx.fcx.ccx.sess.unimpl(\"field variant in trans_field\"); }\n     }\n-    cx.fcx.ccx.sess.unimpl(\"field variant in trans_field\");\n     fail;\n }\n \n@@ -1132,8 +1156,8 @@ fn trans_lval(@block_ctxt cx, @ast.expr e) -> tup(result, bool) {\n         case (ast.expr_field(?base, ?ident, ?ann)) {\n             ret trans_field(cx, e.span, base, ident, ann);\n         }\n+        case (_) { cx.fcx.ccx.sess.unimpl(\"expr variant in trans_lval\"); }\n     }\n-    cx.fcx.ccx.sess.unimpl(\"expr variant in trans_lval\");\n     fail;\n }\n \n@@ -1366,6 +1390,7 @@ impure fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n         case (some[@ast.expr](?x)) {\n             r = trans_expr(cx, x);\n         }\n+        case (_) { /* fall through */  }\n     }\n \n     // Run all cleanups and back out.\n@@ -1388,6 +1413,7 @@ impure fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n             r.val = r.bcx.build.Ret(r.val);\n             ret r;\n         }\n+        case (_) { /* fall through */  }\n     }\n \n     // FIXME: until LLVM has a unit type, we are moving around\n@@ -1426,6 +1452,7 @@ impure fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n                             copy_ty(sub.bcx, true, llptr, sub.val,\n                                     typeck.expr_ty(e));\n                         }\n+                        case (_) { /* fall through */  }\n                     }\n                 }\n             }\n@@ -1496,8 +1523,10 @@ iter block_locals(&ast.block b) -> @ast.local {\n                     case (ast.decl_local(?local)) {\n                         put local;\n                     }\n+                    case (_) { /* fall through */ }\n                 }\n             }\n+            case (_) { /* fall through */ }\n         }\n     }\n }\n@@ -1626,6 +1655,7 @@ impure fn trans_item(@crate_ctxt cx, &ast.item item) {\n             auto sub_cx = @rec(path=cx.path + \".\" + name with *cx);\n             trans_mod(sub_cx, m);\n         }\n+        case (_) { /* fall through */ }\n     }\n }\n \n@@ -1650,6 +1680,7 @@ fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n         case (ast.item_mod(?name, ?m, ?mid)) {\n             cx.items.insert(mid, i);\n         }\n+        case (_) { /* fall through */ }\n     }\n     ret cx;\n }"}, {"sha": "79f57be2ae1f0c5ffa1f4eadde0f2898b9f121f0", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/98a63bd1f9fda47fc34b16d9f0782022e1022277/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a63bd1f9fda47fc34b16d9f0782022e1022277/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=98a63bd1f9fda47fc34b16d9f0782022e1022277", "patch": "@@ -537,38 +537,43 @@ fn mode_is_alias(ast.mode m) -> bool {\n         case (ast.val) { ret false; }\n         case (ast.alias) { ret true; }\n     }\n+    fail;\n }\n \n fn type_is_nil(@ty t) -> bool {\n     alt (t.struct) {\n         case (ty_nil) { ret true; }\n+        case (_) { ret false; }\n     }\n-    ret false;\n+    fail;\n }\n \n fn type_is_structural(@ty t) -> bool {\n     alt (t.struct) {\n         // FIXME: cover tag when we support it.\n         case (ty_tup(_)) { ret true; }\n         case (ty_rec(_)) { ret true; }\n+        case (_) { ret false; }\n     }\n-    ret false;\n+    fail;\n }\n \n fn type_is_binding(@ty t) -> bool {\n     alt (t.struct) {\n         // FIXME: cover obj when we support it.\n         case (ty_fn(_,_)) { ret true; }\n+        case (_) { ret false; }\n     }\n-    ret false;\n+    fail;\n }\n \n fn type_is_boxed(@ty t) -> bool {\n     alt (t.struct) {\n         case (ty_str) { ret true; }\n         case (ty_vec(_)) { ret true; }\n+        case (_) { ret false; }\n     }\n-    ret false;\n+    fail;\n }\n \n fn type_is_scalar(@ty t) -> bool {\n@@ -578,8 +583,9 @@ fn type_is_scalar(@ty t) -> bool {\n         case (ty_uint) { ret true; }\n         case (ty_machine(_)) { ret true; }\n         case (ty_char) { ret true; }\n+        case (_) { ret false; }\n     }\n-    ret false;\n+    fail;\n }\n \n fn type_is_fp(@ty t) -> bool {\n@@ -588,10 +594,12 @@ fn type_is_fp(@ty t) -> bool {\n             alt (tm) {\n                 case (common.ty_f32) { ret true; }\n                 case (common.ty_f64) { ret true; }\n+                case (_) { ret false; }\n             }\n         }\n+        case (_) { ret false; }\n     }\n-    ret false;\n+    fail;\n }\n \n fn type_is_signed(@ty t) -> bool {\n@@ -603,10 +611,12 @@ fn type_is_signed(@ty t) -> bool {\n                 case (common.ty_i16) { ret true; }\n                 case (common.ty_i32) { ret true; }\n                 case (common.ty_i64) { ret true; }\n+                case (_) { ret false; }\n             }\n         }\n+        case (_) { ret false; }\n     }\n-    ret false;\n+    fail;\n }\n \n fn plain_ty(&sty st) -> @ty {\n@@ -662,7 +672,6 @@ fn expr_ty(@ast.expr expr) -> @ty {\n         case (ast.expr_index(_, _, ?ann))     { ret ann_to_type(ann); }\n         case (ast.expr_name(_, _, ?ann))      { ret ann_to_type(ann); }\n     }\n-\n     fail;\n }\n \n@@ -1198,6 +1207,7 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (ast.ne) { t = plain_ty(ty_bool); }\n                 case (ast.ge) { t = plain_ty(ty_bool); }\n                 case (ast.gt) { t = plain_ty(ty_bool); }\n+                case (_) { /* fall through */ }\n             }\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_binary(binop, lhs_1, rhs_1,\n@@ -1506,6 +1516,7 @@ fn check_stmt(&fn_ctxt fcx, &@ast.stmt stmt)\n                             auto expr_1 = demand_expr(fcx, lty, expr_0);\n                             init = some[@ast.expr](expr_1);\n                         }\n+                        case (_) { /* fall through */  }\n                     }\n \n                     auto local_1 = @rec(init = init with *local);"}]}