{"sha": "47c6c8e2f3393fc2094bd6ab0f6f8ad426f32d29", "node_id": "C_kwDOAAsO6NoAKDQ3YzZjOGUyZjMzOTNmYzIwOTRiZDZhYjBmNmY4YWQ0MjZmMzJkMjk", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-12-24T08:57:50Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-12-27T09:21:01Z"}, "message": "Extract multi-character punct handling into a method", "tree": {"sha": "ce5111181cb4b944c7b90c28ce71b5778278dd93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce5111181cb4b944c7b90c28ce71b5778278dd93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47c6c8e2f3393fc2094bd6ab0f6f8ad426f32d29", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmOquV8ACgkQ4laYqTBY\nYXHHoA//bMcwn9lGtviGtHIdVcrrDGI9lGyWhxGOTtbKnlfkk/J6qJQhUtMkxSO9\n+O7kprutYAgD8sulY1Va8gxiqVjflY/0D4vIXV3dt87vbqaOPiVmb1EweaRUZKqe\n63U7oXj87IpVKmn6FE4f/pIURaXnJtdXzFsdtW3Dji023KfBJtVMb04sPL1g9HnD\nb1QWEE/fVn3arXksS06gjvZlKgSBEcZynXAbC5G6//mAz2TYvJCOTPFYdo1fjXky\nioeJ3yATszGhlRvBjz5T6AMgtz1ENdMvFbsrAktpJ3nGiTjgXFC3fzario5gbLPT\nir4ia9FhQr/i4zZr4saSUDfdejOOvToStrJkl8uSXq8Yhdz9pthv1N99+GRQ7gKs\nc9I1rCaWxQAjgy8Eahk3uLLiMiVUGGSqAE+N+H5sMkwl2a7i5x6sQnpehsUAqJb7\nPHXLq9b5THnVJK3ZkGTHXUYtrPVsQfn1loZHplrwlxhC3RpcF1XzzRC9x2OpIHk5\nVYygNheZweHahVf9AljceBCEfsvj5EkmuIo4c9s2AOua+U/hm1Qv4jUWoUjvVcB3\nXEF6PmPs8kZU0c1gCYQh9ZQx6gGSgA3W3pqqdf19VZIOHsLvLJivb1n7PTwRLAGi\ntVI9hQjTcCPIW2n8Y2sXomosvMlYzvEiixi+niCLn+YTcCf9nWI=\n=MtdX\n-----END PGP SIGNATURE-----", "payload": "tree ce5111181cb4b944c7b90c28ce71b5778278dd93\nparent 2872e0558982360d499bdba79cf1a3ed06f1ae82\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1671872270 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1672132861 +0900\n\nExtract multi-character punct handling into a method\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47c6c8e2f3393fc2094bd6ab0f6f8ad426f32d29", "html_url": "https://github.com/rust-lang/rust/commit/47c6c8e2f3393fc2094bd6ab0f6f8ad426f32d29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47c6c8e2f3393fc2094bd6ab0f6f8ad426f32d29/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2872e0558982360d499bdba79cf1a3ed06f1ae82", "url": "https://api.github.com/repos/rust-lang/rust/commits/2872e0558982360d499bdba79cf1a3ed06f1ae82", "html_url": "https://github.com/rust-lang/rust/commit/2872e0558982360d499bdba79cf1a3ed06f1ae82"}], "stats": {"total": 96, "additions": 53, "deletions": 43}, "files": [{"sha": "d7a745860cc3322d55a86c63c77dbbd169a9044e", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 11, "deletions": 42, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/47c6c8e2f3393fc2094bd6ab0f6f8ad426f32d29/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c6c8e2f3393fc2094bd6ab0f6f8ad426f32d29/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=47c6c8e2f3393fc2094bd6ab0f6f8ad426f32d29", "patch": "@@ -837,7 +837,7 @@ impl<'a> TtIter<'a> {\n                 },\n                 Err(_) => false,\n             },\n-            Separator::Puncts(lhss) if idx < lhss.len() => match fork.expect_punct() {\n+            Separator::Puncts(lhss) if idx < lhss.len() => match fork.expect_single_punct() {\n                 Ok(rhs) => rhs.char == lhss[idx].char,\n                 Err(_) => false,\n             },\n@@ -850,52 +850,21 @@ impl<'a> TtIter<'a> {\n     }\n \n     fn expect_tt(&mut self) -> Result<tt::TokenTree, ()> {\n-        match self.peek_n(0) {\n-            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) if punct.char == '\\'' => {\n-                return self.expect_lifetime();\n-            }\n-            _ => (),\n-        }\n-\n-        let tt = self.next().ok_or(())?.clone();\n-        let punct = match tt {\n-            tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) if punct.spacing == tt::Spacing::Joint => {\n-                punct\n-            }\n-            _ => return Ok(tt),\n-        };\n-\n-        let (second, third) = match (self.peek_n(0), self.peek_n(1)) {\n-            (\n-                Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p2))),\n-                Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p3))),\n-            ) if p2.spacing == tt::Spacing::Joint => (p2.char, Some(p3.char)),\n-            (Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p2))), _) => (p2.char, None),\n-            _ => return Ok(tt),\n-        };\n-\n-        match (punct.char, second, third) {\n-            ('.', '.', Some('.' | '=')) | ('<', '<', Some('=')) | ('>', '>', Some('=')) => {\n-                let tt2 = self.next().unwrap().clone();\n-                let tt3 = self.next().unwrap().clone();\n-                Ok(tt::Subtree { delimiter: None, token_trees: vec![tt, tt2, tt3] }.into())\n-            }\n-            ('-' | '!' | '*' | '/' | '&' | '%' | '^' | '+' | '<' | '=' | '>' | '|', '=', _)\n-            | ('-' | '=' | '>', '>', _)\n-            | (':', ':', _)\n-            | ('.', '.', _)\n-            | ('&', '&', _)\n-            | ('<', '<', _)\n-            | ('|', '|', _) => {\n-                let tt2 = self.next().unwrap().clone();\n-                Ok(tt::Subtree { delimiter: None, token_trees: vec![tt, tt2] }.into())\n+        if let Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) = self.peek_n(0) {\n+            if punct.char == '\\'' {\n+                self.expect_lifetime()\n+            } else {\n+                let puncts = self.expect_glued_punct()?;\n+                let token_trees = puncts.into_iter().map(|p| tt::Leaf::Punct(p).into()).collect();\n+                Ok(tt::TokenTree::Subtree(tt::Subtree { delimiter: None, token_trees }))\n             }\n-            _ => Ok(tt),\n+        } else {\n+            self.next().ok_or(()).cloned()\n         }\n     }\n \n     fn expect_lifetime(&mut self) -> Result<tt::TokenTree, ()> {\n-        let punct = self.expect_punct()?;\n+        let punct = self.expect_single_punct()?;\n         if punct.char != '\\'' {\n             return Err(());\n         }"}, {"sha": "a08eb2f5543d10e0e310bd78b98285376f8ee96a", "filename": "crates/mbe/src/tt_iter.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/47c6c8e2f3393fc2094bd6ab0f6f8ad426f32d29/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c6c8e2f3393fc2094bd6ab0f6f8ad426f32d29/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftt_iter.rs?ref=47c6c8e2f3393fc2094bd6ab0f6f8ad426f32d29", "patch": "@@ -1,6 +1,7 @@\n //! A \"Parser\" structure for token trees. We use this when parsing a declarative\n //! macro definition into a list of patterns and templates.\n \n+use smallvec::{smallvec, SmallVec};\n use syntax::SyntaxKind;\n use tt::buffer::TokenBuffer;\n \n@@ -80,13 +81,53 @@ impl<'a> TtIter<'a> {\n         }\n     }\n \n-    pub(crate) fn expect_punct(&mut self) -> Result<&'a tt::Punct, ()> {\n+    pub(crate) fn expect_single_punct(&mut self) -> Result<&'a tt::Punct, ()> {\n         match self.expect_leaf()? {\n             tt::Leaf::Punct(it) => Ok(it),\n             _ => Err(()),\n         }\n     }\n \n+    pub(crate) fn expect_glued_punct(&mut self) -> Result<SmallVec<[tt::Punct; 3]>, ()> {\n+        let tt::TokenTree::Leaf(tt::Leaf::Punct(first)) = self.next().ok_or(())?.clone() else {\n+            return Err(());\n+        };\n+\n+        if first.spacing == tt::Spacing::Alone {\n+            return Ok(smallvec![first]);\n+        }\n+\n+        let (second, third) = match (self.peek_n(0), self.peek_n(1)) {\n+            (\n+                Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p2))),\n+                Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p3))),\n+            ) if p2.spacing == tt::Spacing::Joint => (p2, Some(p3)),\n+            (Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p2))), _) => (p2, None),\n+            _ => return Ok(smallvec![first]),\n+        };\n+\n+        match (first.char, second.char, third.map(|it| it.char)) {\n+            ('.', '.', Some('.' | '=')) | ('<', '<', Some('=')) | ('>', '>', Some('=')) => {\n+                let puncts = smallvec![first, second.clone(), third.unwrap().clone()];\n+                let _ = self.next().unwrap();\n+                let _ = self.next().unwrap();\n+                Ok(puncts)\n+            }\n+            ('-' | '!' | '*' | '/' | '&' | '%' | '^' | '+' | '<' | '=' | '>' | '|', '=', _)\n+            | ('-' | '=' | '>', '>', _)\n+            | (':', ':', _)\n+            | ('.', '.', _)\n+            | ('&', '&', _)\n+            | ('<', '<', _)\n+            | ('|', '|', _) => {\n+                let puncts = smallvec![first, second.clone()];\n+                let _ = self.next().unwrap();\n+                Ok(puncts)\n+            }\n+            _ => Ok(smallvec![first]),\n+        }\n+    }\n+\n     pub(crate) fn expect_fragment(\n         &mut self,\n         entry_point: parser::PrefixEntryPoint,"}]}