{"sha": "c7312fe4ff85ada30103cea58db25d83e0bec4b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MzEyZmU0ZmY4NWFkYTMwMTAzY2VhNThkYjI1ZDgzZTBiZWM0YjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-28T20:22:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-28T20:22:42Z"}, "message": "Auto merge of #63090 - Centril:rollup-xnjwm2h, r=Centril\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #61856 (Lint attributes on function arguments)\n - #62360 (Document that ManuallyDrop::drop should not called more than once)\n - #62392 (Update minifier-rs version)\n - #62871 (Explicit error message for async recursion.)\n - #62995 (Avoid ICE when suggestion span is at Eof)\n - #63053 (SystemTime docs: recommend Instant for elapsed time)\n - #63081 (tidy: Cleanup the directory whitelist)\n - #63088 (Remove anonymous_parameters from unrelated test)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "c45aed285c4e04591ea7d6e8bc6c90b3461671a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c45aed285c4e04591ea7d6e8bc6c90b3461671a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7312fe4ff85ada30103cea58db25d83e0bec4b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7312fe4ff85ada30103cea58db25d83e0bec4b0", "html_url": "https://github.com/rust-lang/rust/commit/c7312fe4ff85ada30103cea58db25d83e0bec4b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7312fe4ff85ada30103cea58db25d83e0bec4b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4560cb830fce63fcffdc4558f4281aaac6a3a1ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/4560cb830fce63fcffdc4558f4281aaac6a3a1ba", "html_url": "https://github.com/rust-lang/rust/commit/4560cb830fce63fcffdc4558f4281aaac6a3a1ba"}, {"sha": "29c377882f545e24b9cc6e1198ee4f72c20d5449", "url": "https://api.github.com/repos/rust-lang/rust/commits/29c377882f545e24b9cc6e1198ee4f72c20d5449", "html_url": "https://github.com/rust-lang/rust/commit/29c377882f545e24b9cc6e1198ee4f72c20d5449"}], "stats": {"total": 1142, "additions": 794, "deletions": 348}, "files": [{"sha": "c08d7444d14eae91f12218f5930c78d51828baef", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -1700,7 +1700,7 @@ dependencies = [\n \n [[package]]\n name = \"minifier\"\n-version = \"0.0.30\"\n+version = \"0.0.33\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"macro-utils 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3195,7 +3195,7 @@ dependencies = [\n name = \"rustdoc\"\n version = \"0.0.0\"\n dependencies = [\n- \"minifier 0.0.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"minifier 0.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -4442,7 +4442,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum memoffset 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ce6075db033bbbb7ee5a0bbd3a3186bbae616f57fb001c485c7ff77955f8177f\"\n \"checksum mime 0.3.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3e27ca21f40a310bd06d9031785f4801710d566c184a6e15bad4f1d9b65f9425\"\n \"checksum mime_guess 2.0.0-alpha.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"30de2e4613efcba1ec63d8133f344076952090c122992a903359be5a4f99c3ed\"\n-\"checksum minifier 0.0.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4c909e78edf61f3aa0dd2086da168cdf304329044bbf248768ca3d20253ec8c0\"\n+\"checksum minifier 0.0.33 (registry+https://github.com/rust-lang/crates.io-index)\" = \"70bf0db2475f5e627787da77ca52fe33c294063f49f4134b8bc662eedb5e7332\"\n \"checksum miniz-sys 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0300eafb20369952951699b68243ab4334f4b10a88f411c221d444b36c40e649\"\n \"checksum miniz_oxide 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5ad30a47319c16cde58d0314f5d98202a80c9083b5f61178457403dfb14e509c\"\n \"checksum miniz_oxide_c_api 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"28edaef377517fd9fe3e085c37d892ce7acd1fbeab9239c5a36eec352d8a8b7e\""}, {"sha": "bb353993236289b2ae4d131d9d4352fb34b0b8b4", "filename": "src/libcore/mem/manually_drop.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmanually_drop.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -119,6 +119,8 @@ impl<T: ?Sized> ManuallyDrop<T> {\n     /// This function runs the destructor of the contained value and thus the wrapped value\n     /// now represents uninitialized data. It is up to the user of this method to ensure the\n     /// uninitialized data is not actually used.\n+    /// In particular, this function can only be called called at most once\n+    /// for a given instance of `ManuallyDrop<T>`.\n     ///\n     /// [`ManuallyDrop::into_inner`]: #method.into_inner\n     #[stable(feature = \"manually_drop\", since = \"1.20.0\")]"}, {"sha": "3781d7df1764c7a49ff0cbc96a677ac9866d1a61", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -210,6 +210,10 @@ pub trait Visitor<'v> : Sized {\n         }\n     }\n \n+    fn visit_arg(&mut self, arg: &'v Arg) {\n+        walk_arg(self, arg)\n+    }\n+\n     /// Visits the top-level item and (optionally) nested items / impl items. See\n     /// `visit_nested_item` for details.\n     fn visit_item(&mut self, i: &'v Item) {\n@@ -396,10 +400,7 @@ pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod, mod_hir_id\n }\n \n pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body) {\n-    for argument in &body.arguments {\n-        visitor.visit_id(argument.hir_id);\n-        visitor.visit_pat(&argument.pat);\n-    }\n+    walk_list!(visitor, visit_arg, &body.arguments);\n     visitor.visit_expr(&body.value);\n }\n \n@@ -452,6 +453,12 @@ pub fn walk_trait_ref<'v, V>(visitor: &mut V, trait_ref: &'v TraitRef)\n     visitor.visit_path(&trait_ref.path, trait_ref.hir_ref_id)\n }\n \n+pub fn walk_arg<'v, V: Visitor<'v>>(visitor: &mut V, arg: &'v Arg) {\n+    visitor.visit_id(arg.hir_id);\n+    visitor.visit_pat(&arg.pat);\n+    walk_list!(visitor, visit_attribute, &arg.attrs);\n+}\n+\n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_ident(item.ident);"}, {"sha": "4ddd7818bb1aa8f2f7fa33192c1f9fdd37c753b4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -2461,8 +2461,10 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_arg(&mut self, arg: &Arg) -> hir::Arg {\n         hir::Arg {\n+            attrs: self.lower_attrs(&arg.attrs),\n             hir_id: self.lower_node_id(arg.id),\n             pat: self.lower_pat(&arg.pat),\n+            span: arg.span,\n         }\n     }\n \n@@ -3279,19 +3281,29 @@ impl<'a> LoweringContext<'a> {\n                 //\n                 // If this is the simple case, this argument will end up being the same as the\n                 // original argument, but with a different pattern id.\n+                let mut stmt_attrs = ThinVec::new();\n+                stmt_attrs.extend(argument.attrs.iter().cloned());\n                 let (new_argument_pat, new_argument_id) = this.pat_ident(desugared_span, ident);\n                 let new_argument = hir::Arg {\n+                    attrs: argument.attrs,\n                     hir_id: argument.hir_id,\n                     pat: new_argument_pat,\n+                    span: argument.span,\n                 };\n \n+\n                 if is_simple_argument {\n                     // If this is the simple case, then we only insert one statement that is\n                     // `let <pat> = <pat>;`. We re-use the original argument's pattern so that\n                     // `HirId`s are densely assigned.\n                     let expr = this.expr_ident(desugared_span, ident, new_argument_id);\n                     let stmt = this.stmt_let_pat(\n-                        desugared_span, Some(P(expr)), argument.pat, hir::LocalSource::AsyncFn);\n+                        stmt_attrs,\n+                        desugared_span,\n+                        Some(P(expr)),\n+                        argument.pat,\n+                        hir::LocalSource::AsyncFn\n+                    );\n                     statements.push(stmt);\n                 } else {\n                     // If this is not the simple case, then we construct two statements:\n@@ -3313,14 +3325,23 @@ impl<'a> LoweringContext<'a> {\n                         desugared_span, ident, hir::BindingAnnotation::Mutable);\n                     let move_expr = this.expr_ident(desugared_span, ident, new_argument_id);\n                     let move_stmt = this.stmt_let_pat(\n-                        desugared_span, Some(P(move_expr)), move_pat, hir::LocalSource::AsyncFn);\n+                        ThinVec::new(),\n+                        desugared_span,\n+                        Some(P(move_expr)),\n+                        move_pat,\n+                        hir::LocalSource::AsyncFn\n+                    );\n \n                     // Construct the `let <pat> = __argN;` statement. We re-use the original\n                     // argument's pattern so that `HirId`s are densely assigned.\n                     let pattern_expr = this.expr_ident(desugared_span, ident, move_id);\n                     let pattern_stmt = this.stmt_let_pat(\n-                        desugared_span, Some(P(pattern_expr)), argument.pat,\n-                        hir::LocalSource::AsyncFn);\n+                        stmt_attrs,\n+                        desugared_span,\n+                        Some(P(pattern_expr)),\n+                        argument.pat,\n+                        hir::LocalSource::AsyncFn\n+                    );\n \n                     statements.push(move_stmt);\n                     statements.push(pattern_stmt);\n@@ -5030,6 +5051,7 @@ impl<'a> LoweringContext<'a> {\n \n                 // `let mut __next`\n                 let next_let = self.stmt_let_pat(\n+                    ThinVec::new(),\n                     desugared_span,\n                     None,\n                     next_pat,\n@@ -5039,6 +5061,7 @@ impl<'a> LoweringContext<'a> {\n                 // `let <pat> = __next`\n                 let pat = self.lower_pat(pat);\n                 let pat_let = self.stmt_let_pat(\n+                    ThinVec::new(),\n                     head_sp,\n                     Some(next_expr),\n                     pat,\n@@ -5533,19 +5556,20 @@ impl<'a> LoweringContext<'a> {\n \n     fn stmt_let_pat(\n         &mut self,\n+        attrs: ThinVec<Attribute>,\n         span: Span,\n         init: Option<P<hir::Expr>>,\n         pat: P<hir::Pat>,\n         source: hir::LocalSource,\n     ) -> hir::Stmt {\n         let local = hir::Local {\n-            pat,\n-            ty: None,\n-            init,\n+            attrs,\n             hir_id: self.next_id(),\n-            span,\n+            init,\n+            pat,\n             source,\n-            attrs: ThinVec::new()\n+            span,\n+            ty: None,\n         };\n         self.stmt(span, hir::StmtKind::Local(P(local)))\n     }\n@@ -5959,6 +5983,7 @@ impl<'a> LoweringContext<'a> {\n             hir::BindingAnnotation::Mutable,\n         );\n         let pinned_let = self.stmt_let_pat(\n+            ThinVec::new(),\n             span,\n             Some(expr),\n             pinned_pat,"}, {"sha": "b6807f7d3bbd2e60b1db88e12a220ddad70066d6", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -363,6 +363,14 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.currently_in_body = prev_in_body;\n     }\n \n+    fn visit_arg(&mut self, arg: &'hir Arg) {\n+        let node = Node::Arg(arg);\n+        self.insert(arg.pat.span, arg.hir_id, node);\n+        self.with_parent(arg.hir_id, |this| {\n+            intravisit::walk_arg(this, arg);\n+        });\n+    }\n+\n     fn visit_item(&mut self, i: &'hir Item) {\n         debug!(\"visit_item: {:?}\", i);\n         debug_assert_eq!(i.hir_id.owner,"}, {"sha": "5a28d9e7b7db6ce2a7da4544d9229ac9165dd436", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -360,6 +360,7 @@ impl<'hir> Map<'hir> {\n             Node::Pat(_) |\n             Node::Binding(_) |\n             Node::Local(_) |\n+            Node::Arg(_) |\n             Node::Arm(_) |\n             Node::Lifetime(_) |\n             Node::Visibility(_) |\n@@ -932,6 +933,7 @@ impl<'hir> Map<'hir> {\n     pub fn attrs(&self, id: HirId) -> &'hir [ast::Attribute] {\n         self.read(id); // reveals attributes on the node\n         let attrs = match self.find_entry(id).map(|entry| entry.node) {\n+            Some(Node::Arg(a)) => Some(&a.attrs[..]),\n             Some(Node::Local(l)) => Some(&l.attrs[..]),\n             Some(Node::Item(i)) => Some(&i.attrs[..]),\n             Some(Node::ForeignItem(fi)) => Some(&fi.attrs[..]),\n@@ -995,6 +997,7 @@ impl<'hir> Map<'hir> {\n     pub fn span(&self, hir_id: HirId) -> Span {\n         self.read(hir_id); // reveals span from node\n         match self.find_entry(hir_id).map(|entry| entry.node) {\n+            Some(Node::Arg(arg)) => arg.span,\n             Some(Node::Item(item)) => item.span,\n             Some(Node::ForeignItem(foreign_item)) => foreign_item.span,\n             Some(Node::TraitItem(trait_method)) => trait_method.span,\n@@ -1197,6 +1200,7 @@ impl<'hir> print::PpAnn for Map<'hir> {\n impl<'a> print::State<'a> {\n     pub fn print_node(&mut self, node: Node<'_>) {\n         match node {\n+            Node::Arg(a)          => self.print_arg(&a),\n             Node::Item(a)         => self.print_item(&a),\n             Node::ForeignItem(a)  => self.print_foreign_item(&a),\n             Node::TraitItem(a)    => self.print_trait_item(a),\n@@ -1338,6 +1342,9 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n         Some(Node::Pat(_)) => {\n             format!(\"pat {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n+        Some(Node::Arg(_)) => {\n+            format!(\"arg {}{}\", map.hir_to_pretty_string(id), id_str)\n+        }\n         Some(Node::Arm(_)) => {\n             format!(\"arm {}{}\", map.hir_to_pretty_string(id), id_str)\n         }"}, {"sha": "f9a4944780195784ee7cb5fe547ffdfd60092d5f", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -2010,8 +2010,10 @@ pub struct InlineAsm {\n /// Represents an argument in a function header.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Arg {\n-    pub pat: P<Pat>,\n+    pub attrs: HirVec<Attribute>,\n     pub hir_id: HirId,\n+    pub pat: P<Pat>,\n+    pub span: Span,\n }\n \n /// Represents the header (not the body) of a function declaration.\n@@ -2701,6 +2703,7 @@ impl CodegenFnAttrs {\n \n #[derive(Copy, Clone, Debug)]\n pub enum Node<'hir> {\n+    Arg(&'hir Arg),\n     Item(&'hir Item),\n     ForeignItem(&'hir ForeignItem),\n     TraitItem(&'hir TraitItem),"}, {"sha": "9c32831cf88e8f797053915d88db89957501ac31", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -1767,6 +1767,11 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n+    pub fn print_arg(&mut self, arg: &hir::Arg) {\n+        self.print_outer_attributes(&arg.attrs);\n+        self.print_pat(&arg.pat);\n+    }\n+\n     pub fn print_arm(&mut self, arm: &hir::Arm) {\n         // I have no idea why this check is necessary, but here it\n         // is :("}, {"sha": "de812410e8bd83260f66925bcabbe285fbc0ee7d", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -966,6 +966,13 @@ for LateContextAndPass<'a, 'tcx, T> {\n         self.context.tables = old_tables;\n     }\n \n+    fn visit_arg(&mut self, arg: &'tcx hir::Arg) {\n+        self.with_lint_attrs(arg.hir_id, &arg.attrs, |cx| {\n+            lint_callback!(cx, check_arg, arg);\n+            hir_visit::walk_arg(cx, arg);\n+        });\n+    }\n+\n     fn visit_body(&mut self, body: &'tcx hir::Body) {\n         lint_callback!(self, check_body, body);\n         hir_visit::walk_body(self, body);\n@@ -1156,6 +1163,13 @@ for LateContextAndPass<'a, 'tcx, T> {\n }\n \n impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T> {\n+    fn visit_arg(&mut self, arg: &'a ast::Arg) {\n+        self.with_lint_attrs(arg.id, &arg.attrs, |cx| {\n+            run_early_pass!(cx, check_arg, arg);\n+            ast_visit::walk_arg(cx, arg);\n+        });\n+    }\n+\n     fn visit_item(&mut self, it: &'a ast::Item) {\n         self.with_lint_attrs(it.id, &it.attrs, |cx| {\n             run_early_pass!(cx, check_item, it);"}, {"sha": "8ddf4603490a199366f352fd22a39335ddd34bb5", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -206,6 +206,7 @@ macro_rules! declare_lint_pass {\n macro_rules! late_lint_methods {\n     ($macro:path, $args:tt, [$hir:tt]) => (\n         $macro!($args, [$hir], [\n+            fn check_arg(a: &$hir hir::Arg);\n             fn check_body(a: &$hir hir::Body);\n             fn check_body_post(a: &$hir hir::Body);\n             fn check_name(a: Span, b: ast::Name);\n@@ -358,6 +359,7 @@ macro_rules! declare_combined_late_lint_pass {\n macro_rules! early_lint_methods {\n     ($macro:path, $args:tt) => (\n         $macro!($args, [\n+            fn check_arg(a: &ast::Arg);\n             fn check_ident(a: ast::Ident);\n             fn check_crate(a: &ast::Crate);\n             fn check_crate_post(a: &ast::Crate);\n@@ -495,8 +497,6 @@ pub type EarlyLintPassObject = Box<dyn EarlyLintPass + sync::Send + sync::Sync +\n pub type LateLintPassObject = Box<dyn for<'a, 'tcx> LateLintPass<'a, 'tcx> + sync::Send\n                                                                            + sync::Sync + 'static>;\n \n-\n-\n /// Identifies a lint known to the compiler.\n #[derive(Clone, Copy, Debug)]\n pub struct LintId {\n@@ -812,6 +812,12 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'tcx> {\n         intravisit::NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n+    fn visit_arg(&mut self, arg: &'tcx hir::Arg) {\n+        self.with_lint_attrs(arg.hir_id, &arg.attrs, |builder| {\n+            intravisit::walk_arg(builder, arg);\n+        });\n+    }\n+\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n         self.with_lint_attrs(it.hir_id, &it.attrs, |builder| {\n             intravisit::walk_item(builder, it);"}, {"sha": "ea9c5283aee7dd5c5c8718d86680667624dc52a1", "filename": "src/librustc_data_structures/owning_ref/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -10,7 +10,7 @@ This allows moving and dropping of a `OwningRef` without needing to recreate the\n This can sometimes be useful because Rust borrowing rules normally prevent\n moving a type that has been moved from. For example, this kind of code gets rejected:\n \n-```rust,ignore\n+```compile_fail,E0515\n fn return_owned_and_referenced<'a>() -> (Vec<u8>, &'a [u8]) {\n     let v = vec![1, 2, 3, 4];\n     let s = &v[1..3];\n@@ -43,7 +43,8 @@ and preventing mutable access to root containers, which in practice requires hea\n as provided by `Box<T>`, `Rc<T>`, etc.\n \n Also provided are typedefs for common owner type combinations,\n-which allow for less verbose type signatures. For example, `BoxRef<T>` instead of `OwningRef<Box<T>, T>`.\n+which allow for less verbose type signatures.\n+For example, `BoxRef<T>` instead of `OwningRef<Box<T>, T>`.\n \n The crate also provides the more advanced `OwningHandle` type,\n which allows more freedom in bundling a dependent handle object\n@@ -498,7 +499,8 @@ impl<O, T: ?Sized> OwningRef<O, T> {\n         }\n     }\n \n-    /// Erases the concrete base type of the owner with a trait object which implements `Send` and `Sync`.\n+    /// Erases the concrete base type of the owner with a trait object\n+    /// which implements `Send` and `Sync`.\n     ///\n     /// This allows mixing of owned references with different owner base types.\n     pub fn erase_send_sync_owner<'a>(self) -> OwningRef<O::Erased, T>\n@@ -510,7 +512,7 @@ impl<O, T: ?Sized> OwningRef<O, T> {\n         }\n     }\n \n-    // TODO: wrap_owner\n+    // UNIMPLEMENTED: wrap_owner\n \n     // FIXME: Naming convention?\n     /// A getter for the underlying owner.\n@@ -756,7 +758,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n         }\n     }\n \n-    // TODO: wrap_owner\n+    // UNIMPLEMENTED: wrap_owner\n \n     // FIXME: Naming convention?\n     /// A getter for the underlying owner."}, {"sha": "5bff5e035b5298594711d832c2e6d5fe905570bc", "filename": "src/librustc_data_structures/owning_ref/tests.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_data_structures%2Fowning_ref%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_data_structures%2Fowning_ref%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fowning_ref%2Ftests.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -274,7 +274,9 @@ mod owning_handle {\n         use std::cell::RefCell;\n         let cell = Rc::new(RefCell::new(2));\n         let cell_ref = RcRef::new(cell);\n-        let mut handle = OwningHandle::new_with_fn(cell_ref, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n+        let mut handle = OwningHandle::new_with_fn(cell_ref, |x| {\n+            unsafe { x.as_ref() }.unwrap().borrow_mut()\n+        });\n         assert_eq!(*handle, 2);\n         *handle = 3;\n         assert_eq!(*handle, 3);\n@@ -319,8 +321,12 @@ mod owning_handle {\n         let result = {\n             let complex = Rc::new(RefCell::new(Arc::new(RwLock::new(\"someString\"))));\n             let curr = RcRef::new(complex);\n-            let curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n-            let mut curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().try_write().unwrap());\n+            let curr = OwningHandle::new_with_fn(curr, |x| {\n+                unsafe { x.as_ref() }.unwrap().borrow_mut()\n+            });\n+            let mut curr = OwningHandle::new_with_fn(curr, |x| {\n+                unsafe { x.as_ref() }.unwrap().try_write().unwrap()\n+            });\n             assert_eq!(*curr, \"someString\");\n             *curr = \"someOtherString\";\n             curr\n@@ -353,8 +359,12 @@ mod owning_handle {\n         let result = {\n             let complex = Rc::new(RefCell::new(Arc::new(RwLock::new(\"someString\"))));\n             let curr = RcRef::new(complex);\n-            let curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n-            let mut curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().try_write().unwrap());\n+            let curr = OwningHandle::new_with_fn(curr, |x| {\n+                unsafe { x.as_ref() }.unwrap().borrow_mut()\n+            });\n+            let mut curr = OwningHandle::new_with_fn(curr, |x| {\n+                unsafe { x.as_ref() }.unwrap().try_write().unwrap()\n+            });\n             assert_eq!(*curr, \"someString\");\n             *curr = \"someOtherString\";\n             curr"}, {"sha": "3b6a6a824c86d3d5099d90cada304aa658e5d297", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -223,7 +223,8 @@ impl CodeSuggestion {\n                         }\n                     }\n                     if let Some(cur_line) = fm.get_line(cur_lo.line - 1) {\n-                        buf.push_str(&cur_line[..cur_lo.col.to_usize()]);\n+                        let end = std::cmp::min(cur_line.len(), cur_lo.col.to_usize());\n+                        buf.push_str(&cur_line[..end]);\n                     }\n                 }\n                 buf.push_str(&part.snippet);"}, {"sha": "4e970aee42cf47ca9b077d50791941005c19fdf7", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -121,7 +121,7 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n                             self_arg = None;\n                         }\n \n-                        ArgInfo(fn_sig.inputs()[index], opt_ty_info, Some(&*arg.pat), self_arg)\n+                        ArgInfo(fn_sig.inputs()[index], opt_ty_info, Some(&arg), self_arg)\n                     });\n \n             let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n@@ -511,7 +511,7 @@ fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: DefId, abi: Abi) -> bool {\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-struct ArgInfo<'tcx>(Ty<'tcx>, Option<Span>, Option<&'tcx hir::Pat>, Option<ImplicitSelfKind>);\n+struct ArgInfo<'tcx>(Ty<'tcx>, Option<Span>, Option<&'tcx hir::Arg>, Option<ImplicitSelfKind>);\n \n fn construct_fn<'a, 'tcx, A>(\n     hir: Cx<'a, 'tcx>,\n@@ -782,13 +782,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                      -> BlockAnd<()>\n     {\n         // Allocate locals for the function arguments\n-        for &ArgInfo(ty, _, pattern, _) in arguments.iter() {\n+        for &ArgInfo(ty, _, arg_opt, _) in arguments.iter() {\n             // If this is a simple binding pattern, give the local a name for\n             // debuginfo and so that error reporting knows that this is a user\n             // variable. For any other pattern the pattern introduces new\n             // variables which will be named instead.\n-            let (name, span) = if let Some(pat) = pattern {\n-                (pat.simple_ident().map(|ident| ident.name), pat.span)\n+            let (name, span) = if let Some(arg) = arg_opt {\n+                (arg.pat.simple_ident().map(|ident| ident.name), arg.pat.span)\n             } else {\n                 (None, self.fn_span)\n             };\n@@ -813,18 +813,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // Function arguments always get the first Local indices after the return place\n             let local = Local::new(index + 1);\n             let place = Place::from(local);\n-            let &ArgInfo(ty, opt_ty_info, pattern, ref self_binding) = arg_info;\n+            let &ArgInfo(ty, opt_ty_info, arg_opt, ref self_binding) = arg_info;\n \n             // Make sure we drop (parts of) the argument even when not matched on.\n             self.schedule_drop(\n-                pattern.as_ref().map_or(ast_body.span, |pat| pat.span),\n+                arg_opt.as_ref().map_or(ast_body.span, |arg| arg.pat.span),\n                 argument_scope, local, ty, DropKind::Value,\n             );\n \n-            if let Some(pattern) = pattern {\n-                let pattern = self.hir.pattern_from_hir(pattern);\n+            if let Some(arg) = arg_opt {\n+                let pattern = self.hir.pattern_from_hir(&arg.pat);\n+                let original_source_scope = self.source_scope;\n                 let span = pattern.span;\n-\n+                self.set_correct_source_scope_for_arg(arg.hir_id, original_source_scope, span);\n                 match *pattern.kind {\n                     // Don't introduce extra copies for simple bindings\n                     PatternKind::Binding {\n@@ -835,6 +836,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         ..\n                     } => {\n                         self.local_decls[local].mutability = mutability;\n+                        self.local_decls[local].source_info.scope = self.source_scope;\n                         self.local_decls[local].is_user_variable =\n                             if let Some(kind) = self_binding {\n                                 Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(*kind)))\n@@ -860,6 +862,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         unpack!(block = self.place_into_pattern(block, pattern, &place, false));\n                     }\n                 }\n+                self.source_scope = original_source_scope;\n             }\n         }\n \n@@ -872,6 +875,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.into(&Place::RETURN_PLACE, block, body)\n     }\n \n+    fn set_correct_source_scope_for_arg(\n+        &mut self,\n+        arg_hir_id: hir::HirId,\n+        original_source_scope: SourceScope,\n+        pattern_span: Span\n+    ) {\n+        let tcx = self.hir.tcx();\n+        let current_root = tcx.maybe_lint_level_root_bounded(\n+            arg_hir_id,\n+            self.hir.root_lint_level\n+        );\n+        let parent_root = tcx.maybe_lint_level_root_bounded(\n+            self.source_scope_local_data[original_source_scope].lint_root,\n+            self.hir.root_lint_level,\n+        );\n+        if current_root != parent_root {\n+            self.source_scope = self.new_source_scope(\n+                pattern_span,\n+                LintLevel::Explicit(current_root),\n+                None\n+            );\n+        }\n+    }\n+\n     fn get_unit_temp(&mut self) -> Place<'tcx> {\n         match self.unit_temp {\n             Some(ref tmp) => tmp.clone(),"}, {"sha": "8fba3256ec429585697557c7334eeef38ea3effc", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -94,6 +94,11 @@ impl<'k> StatCollector<'k> {\n }\n \n impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n+    fn visit_arg(&mut self, arg: &'v hir::Arg) {\n+        self.record(\"Arg\", Id::Node(arg.hir_id), arg);\n+        hir_visit::walk_arg(self, arg)\n+    }\n+\n     fn nested_visit_map<'this>(&'this mut self) -> hir_visit::NestedVisitorMap<'this, 'v> {\n         panic!(\"visit_nested_xxx must be manually implemented in this visitor\")\n     }"}, {"sha": "e4dda20c822bf26f8d996768d5ced26ac7da2501", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -555,21 +555,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         let tcx = self.tcx;\n         if let PatKind::Binding(..) = inner.node {\n-            let parent_id = tcx.hir().get_parent_node(pat.hir_id);\n-            let parent = tcx.hir().get(parent_id);\n-            debug!(\"inner {:?} pat {:?} parent {:?}\", inner, pat, parent);\n-            match parent {\n-                hir::Node::Item(hir::Item { node: hir::ItemKind::Fn(..), .. }) |\n-                hir::Node::ForeignItem(hir::ForeignItem {\n-                    node: hir::ForeignItemKind::Fn(..), ..\n-                }) |\n-                hir::Node::TraitItem(hir::TraitItem { node: hir::TraitItemKind::Method(..), .. }) |\n-                hir::Node::ImplItem(hir::ImplItem { node: hir::ImplItemKind::Method(..), .. }) => {\n-                    // this pat is likely an argument\n+            let binding_parent_id = tcx.hir().get_parent_node(pat.hir_id);\n+            let binding_parent = tcx.hir().get(binding_parent_id);\n+            debug!(\"inner {:?} pat {:?} parent {:?}\", inner, pat, binding_parent);\n+            match binding_parent {\n+                hir::Node::Arg(hir::Arg { span, .. }) => {\n                     if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) {\n-                        // FIXME: turn into structured suggestion, will need a span that also\n-                        // includes the the arg's type.\n-                        err.help(&format!(\"did you mean `{}: &{}`?\", snippet, expected));\n+                        err.span_suggestion(\n+                            *span,\n+                            &format!(\"did you mean `{}`\", snippet),\n+                            format!(\" &{}\", expected),\n+                            Applicability::MachineApplicable,\n+                        );\n                     }\n                 }\n                 hir::Node::Arm(_) |"}, {"sha": "3229d49841e79794a1fabf310162ff1e6bca31a3", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 49, "deletions": 33, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -235,40 +235,56 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &hir::Expr,\n     ) -> Option<(Span, &'static str, String)> {\n-        if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.node {\n-            if let hir::def::Res::Local(id) = path.res {\n-                let parent = self.tcx.hir().get_parent_node(id);\n-                if let Some(Node::Expr(hir::Expr {\n-                    hir_id,\n-                    node: hir::ExprKind::Closure(_, decl, ..),\n-                    ..\n-                })) = self.tcx.hir().find(parent) {\n-                    let parent = self.tcx.hir().get_parent_node(*hir_id);\n-                    if let (Some(Node::Expr(hir::Expr {\n-                        node: hir::ExprKind::MethodCall(path, span, expr),\n-                        ..\n-                    })), 1) = (self.tcx.hir().find(parent), decl.inputs.len()) {\n-                        let self_ty = self.tables.borrow().node_type(expr[0].hir_id);\n-                        let self_ty = format!(\"{:?}\", self_ty);\n-                        let name = path.ident.as_str();\n-                        let is_as_ref_able = (\n-                            self_ty.starts_with(\"&std::option::Option\") ||\n-                            self_ty.starts_with(\"&std::result::Result\") ||\n-                            self_ty.starts_with(\"std::option::Option\") ||\n-                            self_ty.starts_with(\"std::result::Result\")\n-                        ) && (name == \"map\" || name == \"and_then\");\n-                        match (is_as_ref_able, self.sess().source_map().span_to_snippet(*span)) {\n-                            (true, Ok(src)) => {\n-                                return Some((*span, \"consider using `as_ref` instead\",\n-                                             format!(\"as_ref().{}\", src)));\n-                            },\n-                            _ => ()\n-                        }\n-                    }\n-                }\n-            }\n+        let path = match expr.node {\n+            hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => path,\n+            _ => return None\n+        };\n+\n+        let local_id = match path.res {\n+            hir::def::Res::Local(id) => id,\n+            _ => return None\n+        };\n+\n+        let local_parent = self.tcx.hir().get_parent_node(local_id);\n+        let arg_hir_id = match self.tcx.hir().find(local_parent) {\n+            Some(Node::Arg(hir::Arg { hir_id, .. })) => hir_id,\n+            _ => return None\n+        };\n+\n+        let arg_parent = self.tcx.hir().get_parent_node(*arg_hir_id);\n+        let (expr_hir_id, closure_fn_decl) = match self.tcx.hir().find(arg_parent) {\n+            Some(Node::Expr(\n+                hir::Expr { hir_id, node: hir::ExprKind::Closure(_, decl, ..), .. }\n+            )) => (hir_id, decl),\n+            _ => return None\n+        };\n+\n+        let expr_parent = self.tcx.hir().get_parent_node(*expr_hir_id);\n+        let hir = self.tcx.hir().find(expr_parent);\n+        let closure_params_len = closure_fn_decl.inputs.len();\n+        let (method_path, method_span, method_expr) = match (hir, closure_params_len) {\n+            (Some(Node::Expr(\n+                hir::Expr { node: hir::ExprKind::MethodCall(path, span, expr), .. }\n+            )), 1) => (path, span, expr),\n+            _ => return None\n+        };\n+\n+        let self_ty = self.tables.borrow().node_type(method_expr[0].hir_id);\n+        let self_ty = format!(\"{:?}\", self_ty);\n+        let name = method_path.ident.as_str();\n+        let is_as_ref_able = (\n+            self_ty.starts_with(\"&std::option::Option\") ||\n+            self_ty.starts_with(\"&std::result::Result\") ||\n+            self_ty.starts_with(\"std::option::Option\") ||\n+            self_ty.starts_with(\"std::result::Result\")\n+        ) && (name == \"map\" || name == \"and_then\");\n+        match (is_as_ref_able, self.sess().source_map().span_to_snippet(*method_span)) {\n+            (true, Ok(src)) => {\n+                let suggestion = format!(\"as_ref().{}\", src);\n+                Some((*method_span, \"consider using `as_ref` instead\", suggestion))\n+            },\n+            _ => None\n         }\n-        None\n     }\n \n     crate fn is_hir_id_from_struct_pattern_shorthand_field("}, {"sha": "1b4dbfe4be6df1a8608ed85e4a78a95b043d7fb6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -1325,19 +1325,35 @@ fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n     check_packed(tcx, span, def_id);\n }\n \n-fn check_opaque<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, substs: SubstsRef<'tcx>, span: Span) {\n+fn check_opaque<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    substs: SubstsRef<'tcx>,\n+    span: Span,\n+    origin: &hir::ExistTyOrigin\n+) {\n     if let Err(partially_expanded_type) = tcx.try_expand_impl_trait_type(def_id, substs) {\n-        let mut err = struct_span_err!(\n-            tcx.sess, span, E0720,\n-            \"opaque type expands to a recursive type\",\n-        );\n-        err.span_label(span, \"expands to a recursive type\");\n-        if let ty::Opaque(..) = partially_expanded_type.sty {\n-            err.note(\"type resolves to itself\");\n+        if let hir::ExistTyOrigin::AsyncFn = origin {\n+            struct_span_err!(\n+                tcx.sess, span, E0733,\n+                \"recursion in an `async fn` requires boxing\",\n+            )\n+            .span_label(span, \"an `async fn` cannot invoke itself directly\")\n+            .note(\"a recursive `async fn` must be rewritten to return a boxed future.\")\n+            .emit();\n         } else {\n-            err.note(&format!(\"expanded type is `{}`\", partially_expanded_type));\n+            let mut err = struct_span_err!(\n+                tcx.sess, span, E0720,\n+                \"opaque type expands to a recursive type\",\n+            );\n+            err.span_label(span, \"expands to a recursive type\");\n+            if let ty::Opaque(..) = partially_expanded_type.sty {\n+                err.note(\"type resolves to itself\");\n+            } else {\n+                err.note(&format!(\"expanded type is `{}`\", partially_expanded_type));\n+            }\n+            err.emit();\n         }\n-        err.emit();\n     }\n }\n \n@@ -1387,11 +1403,11 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item) {\n         hir::ItemKind::Union(..) => {\n             check_union(tcx, it.hir_id, it.span);\n         }\n-        hir::ItemKind::Existential(..) => {\n+        hir::ItemKind::Existential(hir::ExistTy{origin, ..}) => {\n             let def_id = tcx.hir().local_def_id(it.hir_id);\n \n             let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-            check_opaque(tcx, def_id, substs, it.span);\n+            check_opaque(tcx, def_id, substs, it.span, &origin);\n         }\n         hir::ItemKind::Ty(..) => {\n             let def_id = tcx.hir().local_def_id(it.hir_id);"}, {"sha": "90118a9f191d9d2cc1e5bb897591fefbcb4761f3", "filename": "src/librustc_typeck/error_codes.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -4763,7 +4763,53 @@ assert_eq!(1, discriminant(&Enum::Struct{a: 7, b: 11}));\n ```\n \"##,\n \n+E0733: r##\"\n+Recursion in an `async fn` requires boxing. For example, this will not compile:\n+\n+```edition2018,compile_fail,E0733\n+#![feature(async_await)]\n+async fn foo(n: usize) {\n+    if n > 0 {\n+        foo(n - 1).await;\n+    }\n+}\n+```\n+\n+To achieve async recursion, the `async fn` needs to be desugared\n+such that the `Future` is explicit in the return type:\n+\n+```edition2018,compile_fail,E0720\n+# #![feature(async_await)]\n+use std::future::Future;\n+fn foo_desugered(n: usize) -> impl Future<Output = ()> {\n+    async move {\n+        if n > 0 {\n+            foo_desugered(n - 1).await;\n+        }\n+    }\n+}\n+```\n+\n+Finally, the future is wrapped in a pinned box:\n+\n+```edition2018\n+# #![feature(async_await)]\n+use std::future::Future;\n+use std::pin::Pin;\n+fn foo_recursive(n: usize) -> Pin<Box<dyn Future<Output = ()>>> {\n+    Box::pin(async move {\n+        if n > 0 {\n+            foo_recursive(n - 1).await;\n+        }\n+    })\n }\n+```\n+\n+The `Box<...>` ensures that the result is of known size,\n+and the pin is required to keep it in the same place in memory.\n+\"##,\n+\n+}  // (end of detailed error messages)\n \n register_diagnostics! {\n //  E0035, merged into E0087/E0089"}, {"sha": "334dc74c6c8f74a63ef34623dcb335bf5faed09e", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n \n [dependencies]\n pulldown-cmark = { version = \"0.5.3\", default-features = false }\n-minifier = \"0.0.30\"\n+minifier = \"0.0.33\"\n rayon = { version = \"0.2.0\", package = \"rustc-rayon\" }\n tempfile = \"3\"\n parking_lot = \"0.7\""}, {"sha": "87c6a0b4235787db414670e6d984b3c6e3d000c3", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -1322,13 +1322,13 @@ fn write_minify_replacer<W: Write>(\n                  {\n                     let tokens: Tokens<'_> = simple_minify(contents)\n                         .into_iter()\n-                        .filter(|f| {\n+                        .filter(|(f, next)| {\n                             // We keep backlines.\n-                            minifier::js::clean_token_except(f, &|c: &Token<'_>| {\n+                            minifier::js::clean_token_except(f, next, &|c: &Token<'_>| {\n                                 c.get_char() != Some(ReservedChar::Backline)\n                             })\n                         })\n-                        .map(|f| {\n+                        .map(|(f, _)| {\n                             minifier::js::replace_token_with(f, &|t: &Token<'_>| {\n                                 match *t {\n                                     Token::Keyword(Keyword::Null) => Some(Token::Other(\"N\")),\n@@ -1363,7 +1363,7 @@ fn write_minify_replacer<W: Write>(\n                             // shouldn't be aggregated.\n                             |tokens, pos| {\n                                 pos < 2 ||\n-                                !tokens[pos - 1].is_char(ReservedChar::OpenBracket) ||\n+                                !tokens[pos - 1].eq_char(ReservedChar::OpenBracket) ||\n                                 tokens[pos - 2].get_other() != Some(\"searchIndex\")\n                             }\n                         )"}, {"sha": "98371b9ba3d7e5b52624e368a8d032b44bae20bb", "filename": "src/libstd/time.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -396,6 +396,7 @@ impl SystemTime {\n     /// This function may fail because measurements taken earlier are not\n     /// guaranteed to always be before later measurements (due to anomalies such\n     /// as the system clock being adjusted either forwards or backwards).\n+    /// [`Instant`] can be used to measure elapsed time without this risk of failure.\n     ///\n     /// If successful, [`Ok`]`(`[`Duration`]`)` is returned where the duration represents\n     /// the amount of time elapsed from the specified measurement to this one.\n@@ -406,6 +407,7 @@ impl SystemTime {\n     /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n     /// [`Duration`]: ../../std/time/struct.Duration.html\n     /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n+    /// [`Instant`]: ../../std/time/struct.Instant.html\n     ///\n     /// # Examples\n     ///\n@@ -414,7 +416,7 @@ impl SystemTime {\n     ///\n     /// let sys_time = SystemTime::now();\n     /// let difference = sys_time.duration_since(sys_time)\n-    ///                          .expect(\"SystemTime::duration_since failed\");\n+    ///                          .expect(\"Clock may have gone backwards\");\n     /// println!(\"{:?}\", difference);\n     /// ```\n     #[stable(feature = \"time2\", since = \"1.8.0\")]\n@@ -423,20 +425,24 @@ impl SystemTime {\n         self.0.sub_time(&earlier.0).map_err(SystemTimeError)\n     }\n \n-    /// Returns the amount of time elapsed since this system time was created.\n+    /// Returns the difference between the clock time when this\n+    /// system time was created, and the current clock time.\n     ///\n     /// This function may fail as the underlying system clock is susceptible to\n     /// drift and updates (e.g., the system clock could go backwards), so this\n     /// function may not always succeed. If successful, [`Ok`]`(`[`Duration`]`)` is\n     /// returned where the duration represents the amount of time elapsed from\n     /// this time measurement to the current time.\n     ///\n+    /// To measure elapsed time reliably, use [`Instant`] instead.\n+    ///\n     /// Returns an [`Err`] if `self` is later than the current system time, and\n     /// the error contains how far from the current system time `self` is.\n     ///\n     /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n     /// [`Duration`]: ../../std/time/struct.Duration.html\n     /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n+    /// [`Instant`]: ../../std/time/struct.Instant.html\n     ///\n     /// # Examples\n     ///"}, {"sha": "58a1c4aee9ad90e53542d530cb3dd52f37f6c89e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -1796,6 +1796,7 @@ pub struct Arg {\n     pub ty: P<Ty>,\n     pub pat: P<Pat>,\n     pub id: NodeId,\n+    pub span: Span,\n }\n \n /// Alternative representation for `Arg`s describing `self` parameter of methods.\n@@ -1854,6 +1855,7 @@ impl Arg {\n                 node: PatKind::Ident(BindingMode::ByValue(mutbl), eself_ident, None),\n                 span,\n             }),\n+            span,\n             ty,\n             id: DUMMY_NODE_ID,\n         };"}, {"sha": "b30fefe5b9676382d6a25f91ab7babdf2d5f61bf", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -966,6 +966,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             attrs: ThinVec::default(),\n             id: ast::DUMMY_NODE_ID,\n             pat: arg_pat,\n+            span,\n             ty,\n         }\n     }"}, {"sha": "43b6bea69d9ed5522decbdf2d10c1332fb44e83c", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -558,10 +558,11 @@ pub fn noop_visit_meta_item<T: MutVisitor>(mi: &mut MetaItem, vis: &mut T) {\n     vis.visit_span(span);\n }\n \n-pub fn noop_visit_arg<T: MutVisitor>(Arg { attrs, id, pat, ty }: &mut Arg, vis: &mut T) {\n+pub fn noop_visit_arg<T: MutVisitor>(Arg { attrs, id, pat, span, ty }: &mut Arg, vis: &mut T) {\n     vis.visit_id(id);\n     visit_thin_attrs(attrs, vis);\n     vis.visit_pat(pat);\n+    vis.visit_span(span);\n     vis.visit_ty(ty);\n }\n "}, {"sha": "39cb5042fbc115a99932d11d19bcf1a2f83093bf", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -30,7 +30,7 @@ crate fn dummy_arg(ident: Ident) -> Arg {\n         span: ident.span,\n         id: ast::DUMMY_NODE_ID\n     };\n-    Arg { attrs: ThinVec::default(), id: ast::DUMMY_NODE_ID, pat, ty: P(ty) }\n+    Arg { attrs: ThinVec::default(), id: ast::DUMMY_NODE_ID, pat, span: ident.span, ty: P(ty) }\n }\n \n pub enum Error {"}, {"sha": "6cb965bf817d170892e56254d973553e1ff4c440", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -1515,6 +1515,7 @@ impl<'a> Parser<'a> {\n     where\n         F: Fn(&token::Token) -> bool\n     {\n+        let lo = self.token.span;\n         let attrs = self.parse_arg_attributes()?;\n         if let Some(mut arg) = self.parse_self_arg()? {\n             arg.attrs = attrs.into();\n@@ -1578,11 +1579,14 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        Ok(Arg { attrs: attrs.into(), id: ast::DUMMY_NODE_ID, pat, ty })\n+        let span = lo.to(self.token.span);\n+\n+        Ok(Arg { attrs: attrs.into(), id: ast::DUMMY_NODE_ID, pat, span, ty })\n     }\n \n     /// Parses an argument in a lambda header (e.g., `|arg, arg|`).\n     fn parse_fn_block_arg(&mut self) -> PResult<'a, Arg> {\n+        let lo = self.token.span;\n         let attrs = self.parse_arg_attributes()?;\n         let pat = self.parse_pat(Some(\"argument name\"))?;\n         let t = if self.eat(&token::Colon) {\n@@ -1594,10 +1598,12 @@ impl<'a> Parser<'a> {\n                 span: self.prev_span,\n             })\n         };\n+        let span = lo.to(self.token.span);\n         Ok(Arg {\n             attrs: attrs.into(),\n             ty: t,\n             pat,\n+            span,\n             id: ast::DUMMY_NODE_ID\n         })\n     }"}, {"sha": "50be8c68f7f8c62e6f2641ee95714d7f67993375", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -66,6 +66,7 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_local(&mut self, l: &'ast Local) { walk_local(self, l) }\n     fn visit_block(&mut self, b: &'ast Block) { walk_block(self, b) }\n     fn visit_stmt(&mut self, s: &'ast Stmt) { walk_stmt(self, s) }\n+    fn visit_arg(&mut self, arg: &'ast Arg) { walk_arg(self, arg) }\n     fn visit_arm(&mut self, a: &'ast Arm) { walk_arm(self, a) }\n     fn visit_pat(&mut self, p: &'ast Pat) { walk_pat(self, p) }\n     fn visit_anon_const(&mut self, c: &'ast AnonConst) { walk_anon_const(self, c) }\n@@ -547,12 +548,10 @@ pub fn walk_fn_ret_ty<'a, V: Visitor<'a>>(visitor: &mut V, ret_ty: &'a FunctionR\n }\n \n pub fn walk_fn_decl<'a, V: Visitor<'a>>(visitor: &mut V, function_declaration: &'a FnDecl) {\n-    for argument in &function_declaration.inputs {\n-        walk_list!(visitor, visit_attribute, argument.attrs.iter());\n-        visitor.visit_pat(&argument.pat);\n-        visitor.visit_ty(&argument.ty);\n+    for arg in &function_declaration.inputs {\n+        visitor.visit_arg(arg);\n     }\n-    visitor.visit_fn_ret_ty(&function_declaration.output)\n+    visitor.visit_fn_ret_ty(&function_declaration.output);\n }\n \n pub fn walk_fn<'a, V>(visitor: &mut V, kind: FnKind<'a>, declaration: &'a FnDecl, _span: Span)\n@@ -822,6 +821,12 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n     visitor.visit_expr_post(expression)\n }\n \n+pub fn walk_arg<'a, V: Visitor<'a>>(visitor: &mut V, arg: &'a Arg) {\n+    walk_list!(visitor, visit_attribute, arg.attrs.iter());\n+    visitor.visit_pat(&arg.pat);\n+    visitor.visit_ty(&arg.ty);\n+}\n+\n pub fn walk_arm<'a, V: Visitor<'a>>(visitor: &mut V, arm: &'a Arm) {\n     walk_list!(visitor, visit_pat, &arm.pats);\n     if let Some(ref e) = &arm.guard {"}, {"sha": "64f6eccd5479a963e34a526eca568e2712b6a4e9", "filename": "src/test/ui/async-await/recursive-async-impl-trait-type.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.stderr?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -1,11 +1,11 @@\n-error[E0720]: opaque type expands to a recursive type\n+error[E0733]: recursion in an `async fn` requires boxing\n   --> $DIR/recursive-async-impl-trait-type.rs:7:40\n    |\n LL | async fn recursive_async_function() -> () {\n-   |                                        ^^ expands to a recursive type\n+   |                                        ^^ an `async fn` cannot invoke itself directly\n    |\n-   = note: expanded type is `std::future::GenFuture<[static generator@$DIR/recursive-async-impl-trait-type.rs:7:43: 9:2 {impl std::future::Future, ()}]>`\n+   = note: a recursive `async fn` must be rewritten to return a boxed future.\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0720`.\n+For more information about this error, try `rustc --explain E0733`."}, {"sha": "141f363694ab62201e97d67042781b734f0c0f2e", "filename": "src/test/ui/error-codes/e0119/auxiliary/issue-23563-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fauxiliary%2Fissue-23563-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fauxiliary%2Fissue-23563-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fauxiliary%2Fissue-23563-a.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -9,7 +9,7 @@ pub trait LolInto<T>: Sized {\n }\n \n pub trait LolFrom<T> {\n-    fn from(T) -> Self;\n+    fn from(_: T) -> Self;\n }\n \n impl<'a, T: ?Sized, U> LolInto<U> for &'a T where T: LolTo<U> {"}, {"sha": "2957f9311105108ee41e7e029e7ede7b4d582292", "filename": "src/test/ui/lint/lint-unused-mut-variables.rs", "status": "modified", "additions": 61, "deletions": 3, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -1,12 +1,70 @@\n+// edition:2018\n+\n // Exercise the unused_mut attribute in some positive and negative cases\n \n-#![allow(unused_assignments)]\n-#![allow(unused_variables)]\n-#![allow(dead_code)]\n #![deny(unused_mut)]\n+#![feature(async_await, async_closure, param_attrs)]\n+\n+async fn baz_async(\n+    mut a: i32,\n+    //~^ ERROR: variable does not need to be mutable\n+    #[allow(unused_mut)] mut b: i32,\n+) {}\n+fn baz(\n+    mut a: i32,\n+    //~^ ERROR: variable does not need to be mutable\n+    #[allow(unused_mut)] mut b: i32,\n+    #[allow(unused_mut)] (mut c, d): (i32, i32)\n+) {}\n+\n+struct RefStruct {}\n+impl RefStruct {\n+    async fn baz_async(\n+        mut a: i32,\n+        //~^ ERROR: variable does not need to be mutable\n+        #[allow(unused_mut)] mut b: i32,\n+    ) {}\n+    fn baz(\n+        &self,\n+        mut a: i32,\n+        //~^ ERROR: variable does not need to be mutable\n+        #[allow(unused_mut)] mut b: i32,\n+        #[allow(unused_mut)] (mut c, d): (i32, i32)\n+    ) {}\n+}\n \n+trait RefTrait {\n+    fn baz(\n+        &self,\n+        mut a: i32,\n+        //~^ ERROR: variable does not need to be mutable\n+        #[allow(unused_mut)] mut b: i32,\n+        #[allow(unused_mut)] (mut c, d): (i32, i32)\n+    ) {}\n+}\n+impl RefTrait for () {\n+    fn baz(\n+        &self,\n+        mut a: i32,\n+        //~^ ERROR: variable does not need to be mutable\n+        #[allow(unused_mut)] mut b: i32,\n+        #[allow(unused_mut)] (mut c, d): (i32, i32)\n+    ) {}\n+}\n \n fn main() {\n+    let _ = async move |\n+        mut a: i32,\n+        //~^ ERROR: variable does not need to be mutable\n+        #[allow(unused_mut)] mut b: i32,\n+    | {};\n+    let _ = |\n+        mut a: i32,\n+        //~^ ERROR: variable does not need to be mutable\n+        #[allow(unused_mut)] mut b: i32,\n+        #[allow(unused_mut)] (mut c, d): (i32, i32)\n+    | {};\n+\n     // negative cases\n     let mut a = 3; //~ ERROR: variable does not need to be mutable\n "}, {"sha": "92c2b68652dc278c77fc8287a17e9c14e42848ae", "filename": "src/test/ui/lint/lint-unused-mut-variables.stderr", "status": "modified", "additions": 88, "deletions": 24, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -1,150 +1,214 @@\n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:46:14\n+  --> $DIR/lint-unused-mut-variables.rs:9:5\n    |\n-LL |     let x = |mut y: isize| 10;\n-   |              ----^\n-   |              |\n-   |              help: remove this `mut`\n+LL |     mut a: i32,\n+   |     ----^\n+   |     |\n+   |     help: remove this `mut`\n    |\n note: lint level defined here\n-  --> $DIR/lint-unused-mut-variables.rs:6:9\n+  --> $DIR/lint-unused-mut-variables.rs:5:9\n    |\n LL | #![deny(unused_mut)]\n    |         ^^^^^^^^^^\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:11:9\n+  --> $DIR/lint-unused-mut-variables.rs:14:5\n+   |\n+LL |     mut a: i32,\n+   |     ----^\n+   |     |\n+   |     help: remove this `mut`\n+\n+error: variable does not need to be mutable\n+  --> $DIR/lint-unused-mut-variables.rs:23:9\n+   |\n+LL |         mut a: i32,\n+   |         ----^\n+   |         |\n+   |         help: remove this `mut`\n+\n+error: variable does not need to be mutable\n+  --> $DIR/lint-unused-mut-variables.rs:29:9\n+   |\n+LL |         mut a: i32,\n+   |         ----^\n+   |         |\n+   |         help: remove this `mut`\n+\n+error: variable does not need to be mutable\n+  --> $DIR/lint-unused-mut-variables.rs:39:9\n+   |\n+LL |         mut a: i32,\n+   |         ----^\n+   |         |\n+   |         help: remove this `mut`\n+\n+error: variable does not need to be mutable\n+  --> $DIR/lint-unused-mut-variables.rs:48:9\n+   |\n+LL |         mut a: i32,\n+   |         ----^\n+   |         |\n+   |         help: remove this `mut`\n+\n+error: variable does not need to be mutable\n+  --> $DIR/lint-unused-mut-variables.rs:57:9\n+   |\n+LL |         mut a: i32,\n+   |         ----^\n+   |         |\n+   |         help: remove this `mut`\n+\n+error: variable does not need to be mutable\n+  --> $DIR/lint-unused-mut-variables.rs:62:9\n+   |\n+LL |         mut a: i32,\n+   |         ----^\n+   |         |\n+   |         help: remove this `mut`\n+\n+error: variable does not need to be mutable\n+  --> $DIR/lint-unused-mut-variables.rs:104:14\n+   |\n+LL |     let x = |mut y: isize| 10;\n+   |              ----^\n+   |              |\n+   |              help: remove this `mut`\n+\n+error: variable does not need to be mutable\n+  --> $DIR/lint-unused-mut-variables.rs:69:9\n    |\n LL |     let mut a = 3;\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:13:9\n+  --> $DIR/lint-unused-mut-variables.rs:71:9\n    |\n LL |     let mut a = 2;\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:15:9\n+  --> $DIR/lint-unused-mut-variables.rs:73:9\n    |\n LL |     let mut b = 3;\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:17:9\n+  --> $DIR/lint-unused-mut-variables.rs:75:9\n    |\n LL |     let mut a = vec![3];\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:19:10\n+  --> $DIR/lint-unused-mut-variables.rs:77:10\n    |\n LL |     let (mut a, b) = (1, 2);\n    |          ----^\n    |          |\n    |          help: remove this `mut`\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:21:9\n+  --> $DIR/lint-unused-mut-variables.rs:79:9\n    |\n LL |     let mut a;\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:25:9\n+  --> $DIR/lint-unused-mut-variables.rs:83:9\n    |\n LL |     let mut b;\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:34:9\n+  --> $DIR/lint-unused-mut-variables.rs:92:9\n    |\n LL |         mut x => {}\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:38:8\n+  --> $DIR/lint-unused-mut-variables.rs:96:8\n    |\n LL |       (mut x, 1) |\n    |        ----^\n    |        |\n    |        help: remove this `mut`\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:51:9\n+  --> $DIR/lint-unused-mut-variables.rs:109:9\n    |\n LL |     let mut a = &mut 5;\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:56:9\n+  --> $DIR/lint-unused-mut-variables.rs:114:9\n    |\n LL |     let mut b = (&mut a,);\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:59:9\n+  --> $DIR/lint-unused-mut-variables.rs:117:9\n    |\n LL |     let mut x = &mut 1;\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:71:9\n+  --> $DIR/lint-unused-mut-variables.rs:129:9\n    |\n LL |     let mut v : &mut Vec<()> = &mut vec![];\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:48:13\n+  --> $DIR/lint-unused-mut-variables.rs:106:13\n    |\n LL |     fn what(mut foo: isize) {}\n    |             ----^^^\n    |             |\n    |             help: remove this `mut`\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:66:20\n+  --> $DIR/lint-unused-mut-variables.rs:124:20\n    |\n LL |     fn mut_ref_arg(mut arg : &mut [u8]) -> &mut [u8] {\n    |                    ----^^^\n    |                    |\n    |                    help: remove this `mut`\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:138:9\n+  --> $DIR/lint-unused-mut-variables.rs:196:9\n    |\n LL |     let mut b = vec![2];\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n    |\n note: lint level defined here\n-  --> $DIR/lint-unused-mut-variables.rs:134:8\n+  --> $DIR/lint-unused-mut-variables.rs:192:8\n    |\n LL | #[deny(unused_mut)]\n    |        ^^^^^^^^^^\n \n-error: aborting due to 17 previous errors\n+error: aborting due to 25 previous errors\n "}, {"sha": "a1660d235112333703517cdcbacacbd9083d2d12", "filename": "src/test/ui/lint/lint-unused-variables.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Flint%2Flint-unused-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Flint%2Flint-unused-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-variables.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -0,0 +1,64 @@\n+// compile-flags: --cfg something\n+// edition:2018\n+\n+#![feature(async_await, async_closure, param_attrs)]\n+#![deny(unused_variables)]\n+\n+async fn foo_async(\n+    a: i32,\n+    //~^ ERROR unused variable: `a`\n+    #[allow(unused_variables)] b: i32,\n+) {}\n+fn foo(\n+    #[allow(unused_variables)] a: i32,\n+    b: i32,\n+    //~^ ERROR unused variable: `b`\n+) {}\n+\n+struct RefStruct {}\n+impl RefStruct {\n+    async fn bar_async(\n+        &self,\n+        a: i32,\n+        //~^ ERROR unused variable: `a`\n+        #[allow(unused_variables)] b: i32,\n+    ) {}\n+    fn bar(\n+        &self,\n+        #[allow(unused_variables)] a: i32,\n+        b: i32,\n+        //~^ ERROR unused variable: `b`\n+    ) {}\n+}\n+trait RefTrait {\n+    fn bar(\n+        &self,\n+        #[allow(unused_variables)] a: i32,\n+        b: i32,\n+        //~^ ERROR unused variable: `b`\n+    ) {}\n+}\n+impl RefTrait for RefStruct {\n+    fn bar(\n+        &self,\n+        #[allow(unused_variables)] a: i32,\n+        b: i32,\n+        //~^ ERROR unused variable: `b`\n+    ) {}\n+}\n+\n+fn main() {\n+    let _: fn(_, _) = foo;\n+    let a = async move |\n+        a: i32,\n+        //~^ ERROR unused variable: `a`\n+        #[allow(unused_variables)] b: i32,\n+    | {};\n+    let b = |\n+        #[allow(unused_variables)] a: i32,\n+        b: i32,\n+        //~^ ERROR unused variable: `b`\n+    | {};\n+    let _ = a(1, 2);\n+    let _ = b(1, 2);\n+}"}, {"sha": "7ed5669e33c2444adfcf99a423551ad26d50ef18", "filename": "src/test/ui/lint/lint-unused-variables.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Flint%2Flint-unused-variables.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Flint%2Flint-unused-variables.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-variables.stderr?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -0,0 +1,56 @@\n+error: unused variable: `a`\n+  --> $DIR/lint-unused-variables.rs:8:5\n+   |\n+LL |     a: i32,\n+   |     ^ help: consider prefixing with an underscore: `_a`\n+   |\n+note: lint level defined here\n+  --> $DIR/lint-unused-variables.rs:5:9\n+   |\n+LL | #![deny(unused_variables)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: unused variable: `b`\n+  --> $DIR/lint-unused-variables.rs:14:5\n+   |\n+LL |     b: i32,\n+   |     ^ help: consider prefixing with an underscore: `_b`\n+\n+error: unused variable: `a`\n+  --> $DIR/lint-unused-variables.rs:53:9\n+   |\n+LL |         a: i32,\n+   |         ^ help: consider prefixing with an underscore: `_a`\n+\n+error: unused variable: `b`\n+  --> $DIR/lint-unused-variables.rs:59:9\n+   |\n+LL |         b: i32,\n+   |         ^ help: consider prefixing with an underscore: `_b`\n+\n+error: unused variable: `b`\n+  --> $DIR/lint-unused-variables.rs:37:9\n+   |\n+LL |         b: i32,\n+   |         ^ help: consider prefixing with an underscore: `_b`\n+\n+error: unused variable: `a`\n+  --> $DIR/lint-unused-variables.rs:22:9\n+   |\n+LL |         a: i32,\n+   |         ^ help: consider prefixing with an underscore: `_a`\n+\n+error: unused variable: `b`\n+  --> $DIR/lint-unused-variables.rs:29:9\n+   |\n+LL |         b: i32,\n+   |         ^ help: consider prefixing with an underscore: `_b`\n+\n+error: unused variable: `b`\n+  --> $DIR/lint-unused-variables.rs:45:9\n+   |\n+LL |         b: i32,\n+   |         ^ help: consider prefixing with an underscore: `_b`\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "79a0807c3372155efc11f5c55d3bb2862c4d1442", "filename": "src/test/ui/mismatched_types/issue-38371.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.stderr?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -2,11 +2,13 @@ error[E0308]: mismatched types\n   --> $DIR/issue-38371.rs:4:8\n    |\n LL | fn foo(&foo: Foo) {\n-   |        ^^^^ expected struct `Foo`, found reference\n+   |        ^^^^------\n+   |        |\n+   |        expected struct `Foo`, found reference\n+   |        help: did you mean `foo`: `&Foo`\n    |\n    = note: expected type `Foo`\n               found type `&_`\n-   = help: did you mean `foo: &Foo`?\n \n error[E0308]: mismatched types\n   --> $DIR/issue-38371.rs:18:9"}, {"sha": "18bc51e7ba7cdf4713668d9c01e64559f319b274", "filename": "src/test/ui/parser/issue-62973.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Fparser%2Fissue-62973.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Fparser%2Fissue-62973.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-62973.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -0,0 +1,8 @@\n+// ignore-tidy-trailing-newlines\n+// error-pattern: aborting due to 6 previous errors\n+\n+fn main() {}\n+\n+fn p() { match s { v, E { [) {) }\n+\n+"}, {"sha": "141076bf6b6388c5ceab1184dc0cd50a7dc4b8d3", "filename": "src/test/ui/parser/issue-62973.stderr", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Fparser%2Fissue-62973.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Fparser%2Fissue-62973.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-62973.stderr?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -0,0 +1,61 @@\n+error: this file contains an un-closed delimiter\n+  --> $DIR/issue-62973.rs:8:2\n+   |\n+LL | fn p() { match s { v, E { [) {) }\n+   |        -         - un-closed delimiter\n+   |        |\n+   |        un-closed delimiter\n+LL | \n+LL | \n+   |  ^\n+\n+error: expected one of `,` or `}`, found `{`\n+  --> $DIR/issue-62973.rs:6:25\n+   |\n+LL | fn p() { match s { v, E { [) {) }\n+   |                -        ^ expected one of `,` or `}` here\n+   |                |\n+   |                while parsing this struct\n+\n+error: struct literals are not allowed here\n+  --> $DIR/issue-62973.rs:6:16\n+   |\n+LL |   fn p() { match s { v, E { [) {) }\n+   |  ________________^\n+LL | |\n+LL | |\n+   | |_^\n+help: surround the struct literal with parentheses\n+   |\n+LL | fn p() { match (s { v, E { [) {) }\n+LL | \n+LL | )\n+   |\n+\n+error: expected one of `.`, `?`, `{`, or an operator, found `}`\n+  --> $DIR/issue-62973.rs:8:1\n+   |\n+LL | fn p() { match s { v, E { [) {) }\n+   |          ----- while parsing this match expression\n+LL | \n+LL | \n+   | ^ expected one of `.`, `?`, `{`, or an operator here\n+\n+error: incorrect close delimiter: `)`\n+  --> $DIR/issue-62973.rs:6:28\n+   |\n+LL | fn p() { match s { v, E { [) {) }\n+   |                           -^ incorrect close delimiter\n+   |                           |\n+   |                           un-closed delimiter\n+\n+error: incorrect close delimiter: `)`\n+  --> $DIR/issue-62973.rs:6:31\n+   |\n+LL | fn p() { match s { v, E { [) {) }\n+   |                              -^ incorrect close delimiter\n+   |                              |\n+   |                              un-closed delimiter\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "5eeda66173ded56be7b3355b58c54938f12b4ae1", "filename": "src/test/ui/rfc-2565-param-attrs/param-attrs-allowed.rs", "status": "modified", "additions": 28, "deletions": 151, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-allowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-allowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-allowed.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -1,189 +1,66 @@\n+// check-pass\n // compile-flags: --cfg something\n-// build-pass (FIXME(62277): could be check-pass?)\n \n+#![deny(unused_mut)]\n #![feature(param_attrs)]\n \n extern \"C\" {\n     fn ffi(\n-        #[allow(C)] a: i32,\n+        #[allow(unused_mut)] a: i32,\n         #[cfg(something)] b: i32,\n         #[cfg_attr(something, cfg(nothing))] c: i32,\n-        #[deny(C)] d: i32,\n-        #[forbid(C)] #[warn(C)] ...\n+        #[deny(unused_mut)] d: i32,\n+        #[forbid(unused_mut)] #[warn(unused_mut)] ...\n     );\n }\n \n type FnType = fn(\n-    #[allow(C)] a: i32,\n+    #[allow(unused_mut)] a: i32,\n     #[cfg(something)] b: i32,\n     #[cfg_attr(something, cfg(nothing))] c: i32,\n-    #[deny(C)] d: i32,\n-    #[forbid(C)] #[warn(C)] e: i32\n+    #[deny(unused_mut)] d: i32,\n+    #[forbid(unused_mut)] #[warn(unused_mut)] e: i32\n );\n \n pub fn foo(\n-    #[allow(C)] a: i32,\n+    #[allow(unused_mut)] a: i32,\n     #[cfg(something)] b: i32,\n     #[cfg_attr(something, cfg(nothing))] c: i32,\n-    #[deny(C)] d: i32,\n-    #[forbid(C)] #[warn(C)] e: i32\n+    #[deny(unused_mut)] d: i32,\n+    #[forbid(unused_mut)] #[warn(unused_mut)] _e: i32\n ) {}\n \n-// self, &self and &mut self\n+// self\n \n struct SelfStruct {}\n impl SelfStruct {\n     fn foo(\n-        #[allow(C)] self,\n+        #[allow(unused_mut)] self,\n         #[cfg(something)] a: i32,\n         #[cfg_attr(something, cfg(nothing))]\n-        #[deny(C)] b: i32,\n+        #[deny(unused_mut)] b: i32,\n     ) {}\n }\n \n struct RefStruct {}\n impl RefStruct {\n     fn foo(\n-        #[allow(C)] &self,\n+        #[allow(unused_mut)] &self,\n         #[cfg(something)] a: i32,\n         #[cfg_attr(something, cfg(nothing))]\n-        #[deny(C)] b: i32,\n+        #[deny(unused_mut)] b: i32,\n     ) {}\n }\n trait RefTrait {\n     fn foo(\n-        #[forbid(C)] &self,\n-        #[warn(C)] a: i32\n+        #[forbid(unused_mut)] &self,\n+        #[warn(unused_mut)] a: i32\n     ) {}\n }\n impl RefTrait for RefStruct {\n     fn foo(\n-        #[forbid(C)] &self,\n-        #[warn(C)] a: i32\n-    ) {}\n-}\n-\n-struct MutStruct {}\n-impl MutStruct {\n-    fn foo(\n-        #[allow(C)] &mut self,\n-        #[cfg(something)] a: i32,\n-        #[cfg_attr(something, cfg(nothing))]\n-        #[deny(C)] b: i32,\n-    ) {}\n-}\n-trait MutTrait {\n-    fn foo(\n-        #[forbid(C)] &mut self,\n-        #[warn(C)] a: i32\n-    ) {}\n-}\n-impl MutTrait for MutStruct {\n-    fn foo(\n-        #[forbid(C)] &mut self,\n-        #[warn(C)] a: i32\n-    ) {}\n-}\n-\n-// self: Self, self: &Self and self: &mut Self\n-\n-struct NamedSelfSelfStruct {}\n-impl NamedSelfSelfStruct {\n-    fn foo(\n-        #[allow(C)] self: Self,\n-        #[cfg(something)] a: i32,\n-        #[cfg_attr(something, cfg(nothing))]\n-        #[deny(C)] b: i32,\n-    ) {}\n-}\n-\n-struct NamedSelfRefStruct {}\n-impl NamedSelfRefStruct {\n-    fn foo(\n-        #[allow(C)] self: &Self,\n-        #[cfg(something)] a: i32,\n-        #[cfg_attr(something, cfg(nothing))]\n-        #[deny(C)] b: i32,\n-    ) {}\n-}\n-trait NamedSelfRefTrait {\n-    fn foo(\n-        #[forbid(C)] self: &Self,\n-        #[warn(C)] a: i32\n-    ) {}\n-}\n-impl NamedSelfRefTrait for NamedSelfRefStruct {\n-    fn foo(\n-        #[forbid(C)] self: &Self,\n-        #[warn(C)] a: i32\n-    ) {}\n-}\n-\n-struct NamedSelfMutStruct {}\n-impl NamedSelfMutStruct {\n-    fn foo(\n-        #[allow(C)] self: &mut Self,\n-        #[cfg(something)] a: i32,\n-        #[cfg_attr(something, cfg(nothing))]\n-        #[deny(C)] b: i32,\n-    ) {}\n-}\n-trait NamedSelfMutTrait {\n-    fn foo(\n-        #[forbid(C)] self: &mut Self,\n-        #[warn(C)] a: i32\n-    ) {}\n-}\n-impl NamedSelfMutTrait for NamedSelfMutStruct {\n-    fn foo(\n-        #[forbid(C)] self: &mut Self,\n-        #[warn(C)] a: i32\n-    ) {}\n-}\n-\n-// &'a self and &'a mut self\n-\n-struct NamedLifetimeRefStruct {}\n-impl NamedLifetimeRefStruct {\n-    fn foo<'a>(\n-        #[allow(C)] self: &'a Self,\n-        #[cfg(something)] a: i32,\n-        #[cfg_attr(something, cfg(nothing))]\n-        #[deny(C)] b: i32,\n-    ) {}\n-}\n-trait NamedLifetimeRefTrait {\n-    fn foo<'a>(\n-        #[forbid(C)] &'a self,\n-        #[warn(C)] a: i32\n-    ) {}\n-}\n-impl NamedLifetimeRefTrait for NamedLifetimeRefStruct {\n-    fn foo<'a>(\n-        #[forbid(C)] &'a self,\n-        #[warn(C)] a: i32\n-    ) {}\n-}\n-\n-struct NamedLifetimeMutStruct {}\n-impl NamedLifetimeMutStruct {\n-    fn foo<'a>(\n-        #[allow(C)] self: &'a mut Self,\n-        #[cfg(something)] a: i32,\n-        #[cfg_attr(something, cfg(nothing))]\n-        #[deny(C)] b: i32,\n-    ) {}\n-}\n-trait NamedLifetimeMutTrait {\n-    fn foo<'a>(\n-        #[forbid(C)] &'a mut self,\n-        #[warn(C)] a: i32\n-    ) {}\n-}\n-impl NamedLifetimeMutTrait for NamedLifetimeMutStruct {\n-    fn foo<'a>(\n-        #[forbid(C)] &'a mut self,\n-        #[warn(C)] a: i32\n+        #[forbid(unused_mut)] &self,\n+        #[warn(unused_mut)] a: i32\n     ) {}\n }\n \n@@ -192,22 +69,22 @@ impl NamedLifetimeMutTrait for NamedLifetimeMutStruct {\n struct BoxSelfStruct {}\n impl BoxSelfStruct {\n     fn foo(\n-        #[allow(C)] self: Box<Self>,\n+        #[allow(unused_mut)] self: Box<Self>,\n         #[cfg(something)] a: i32,\n         #[cfg_attr(something, cfg(nothing))]\n-        #[deny(C)] b: i32,\n+        #[deny(unused_mut)] b: i32,\n     ) {}\n }\n trait BoxSelfTrait {\n     fn foo(\n-        #[forbid(C)] self: Box<Self>,\n-        #[warn(C)] a: i32\n+        #[forbid(unused_mut)] self: Box<Self>,\n+        #[warn(unused_mut)] a: i32\n     ) {}\n }\n impl BoxSelfTrait for BoxSelfStruct {\n     fn foo(\n-        #[forbid(C)] self: Box<Self>,\n-        #[warn(C)] a: i32\n+        #[forbid(unused_mut)] self: Box<Self>,\n+        #[warn(unused_mut)] a: i32\n     ) {}\n }\n \n@@ -216,10 +93,10 @@ fn main() {\n     let _: fn(_, _, _, _) = foo;\n     let _: FnType = |_, _, _, _| {};\n     let c = |\n-        #[allow(C)] a: u32,\n+        #[allow(unused_mut)] a: u32,\n         #[cfg(something)] b: i32,\n         #[cfg_attr(something, cfg(nothing))]\n-        #[deny(C)] c: i32,\n+        #[deny(unused_mut)] c: i32,\n     | {};\n     let _ = c(1, 2);\n }"}, {"sha": "069332ffa255f836216a873ab883659a0fbfb66f", "filename": "src/test/ui/rfc-2565-param-attrs/param-attrs-cfg.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-cfg.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -1,6 +1,7 @@\n // compile-flags: --cfg something\n+// edition:2018\n \n-#![feature(param_attrs)]\n+#![feature(async_await, async_closure, param_attrs)]\n #![deny(unused_variables)]\n \n extern \"C\" {\n@@ -19,24 +20,35 @@ type FnType = fn(\n     #[cfg_attr(something, cfg(nothing))] d: i32,\n );\n \n+async fn foo_async(\n+    #[cfg(something)] a: i32,\n+    //~^ ERROR unused variable: `a`\n+    #[cfg(nothing)] b: i32,\n+) {}\n fn foo(\n     #[cfg(nothing)] a: i32,\n     #[cfg(something)] b: i32,\n-    //~^ ERROR unused variable: `b` [unused_variables]\n+    //~^ ERROR unused variable: `b`\n     #[cfg_attr(nothing, cfg(nothing))] c: i32,\n-    //~^ ERROR unused variable: `c` [unused_variables]\n+    //~^ ERROR unused variable: `c`\n     #[cfg_attr(something, cfg(nothing))] d: i32,\n ) {}\n \n struct RefStruct {}\n impl RefStruct {\n+    async fn bar_async(\n+        &self,\n+        #[cfg(something)] a: i32,\n+        //~^ ERROR unused variable: `a`\n+        #[cfg(nothing)] b: i32,\n+    ) {}\n     fn bar(\n         &self,\n         #[cfg(nothing)] a: i32,\n         #[cfg(something)] b: i32,\n-        //~^ ERROR unused variable: `b` [unused_variables]\n+        //~^ ERROR unused variable: `b`\n         #[cfg_attr(nothing, cfg(nothing))] c: i32,\n-        //~^ ERROR unused variable: `c` [unused_variables]\n+        //~^ ERROR unused variable: `c`\n         #[cfg_attr(something, cfg(nothing))] d: i32,\n     ) {}\n }\n@@ -45,9 +57,9 @@ trait RefTrait {\n         &self,\n         #[cfg(nothing)] a: i32,\n         #[cfg(something)] b: i32,\n-        //~^ ERROR unused variable: `b` [unused_variables]\n+        //~^ ERROR unused variable: `b`\n         #[cfg_attr(nothing, cfg(nothing))] c: i32,\n-        //~^ ERROR unused variable: `c` [unused_variables]\n+        //~^ ERROR unused variable: `c`\n         #[cfg_attr(something, cfg(nothing))] d: i32,\n     ) {}\n }\n@@ -56,9 +68,9 @@ impl RefTrait for RefStruct {\n         &self,\n         #[cfg(nothing)] a: i32,\n         #[cfg(something)] b: i32,\n-        //~^ ERROR unused variable: `b` [unused_variables]\n+        //~^ ERROR unused variable: `b`\n         #[cfg_attr(nothing, cfg(nothing))] c: i32,\n-        //~^ ERROR unused variable: `c` [unused_variables]\n+        //~^ ERROR unused variable: `c`\n         #[cfg_attr(something, cfg(nothing))] d: i32,\n     ) {}\n }\n@@ -67,13 +79,19 @@ fn main() {\n     let _: unsafe extern \"C\" fn(_, ...) = ffi;\n     let _: fn(_, _) = foo;\n     let _: FnType = |_, _| {};\n+    let a = async move |\n+        #[cfg(something)] a: i32,\n+        //~^ ERROR unused variable: `a`\n+        #[cfg(nothing)] b: i32,\n+    | {};\n     let c = |\n         #[cfg(nothing)] a: i32,\n         #[cfg(something)] b: i32,\n-        //~^ ERROR unused variable: `b` [unused_variables]\n+        //~^ ERROR unused variable: `b`\n         #[cfg_attr(nothing, cfg(nothing))] c: i32,\n-        //~^ ERROR unused variable: `c` [unused_variables]\n+        //~^ ERROR unused variable: `c`\n         #[cfg_attr(something, cfg(nothing))] d: i32,\n     | {};\n+    let _ = a(1);\n     let _ = c(1, 2);\n }"}, {"sha": "3232e2a0411a270335498e05ce185bd753808c91", "filename": "src/test/ui/rfc-2565-param-attrs/param-attrs-cfg.stderr", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-cfg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-cfg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-cfg.stderr?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -1,68 +1,86 @@\n-error: unused variable: `b`\n+error: unused variable: `a`\n   --> $DIR/param-attrs-cfg.rs:24:23\n    |\n-LL |     #[cfg(something)] b: i32,\n-   |                       ^ help: consider prefixing with an underscore: `_b`\n+LL |     #[cfg(something)] a: i32,\n+   |                       ^ help: consider prefixing with an underscore: `_a`\n    |\n note: lint level defined here\n-  --> $DIR/param-attrs-cfg.rs:4:9\n+  --> $DIR/param-attrs-cfg.rs:5:9\n    |\n LL | #![deny(unused_variables)]\n    |         ^^^^^^^^^^^^^^^^\n \n+error: unused variable: `b`\n+  --> $DIR/param-attrs-cfg.rs:30:23\n+   |\n+LL |     #[cfg(something)] b: i32,\n+   |                       ^ help: consider prefixing with an underscore: `_b`\n+\n error: unused variable: `c`\n-  --> $DIR/param-attrs-cfg.rs:26:40\n+  --> $DIR/param-attrs-cfg.rs:32:40\n    |\n LL |     #[cfg_attr(nothing, cfg(nothing))] c: i32,\n    |                                        ^ help: consider prefixing with an underscore: `_c`\n \n+error: unused variable: `a`\n+  --> $DIR/param-attrs-cfg.rs:83:27\n+   |\n+LL |         #[cfg(something)] a: i32,\n+   |                           ^ help: consider prefixing with an underscore: `_a`\n+\n error: unused variable: `b`\n-  --> $DIR/param-attrs-cfg.rs:72:27\n+  --> $DIR/param-attrs-cfg.rs:89:27\n    |\n LL |         #[cfg(something)] b: i32,\n    |                           ^ help: consider prefixing with an underscore: `_b`\n \n error: unused variable: `c`\n-  --> $DIR/param-attrs-cfg.rs:74:44\n+  --> $DIR/param-attrs-cfg.rs:91:44\n    |\n LL |         #[cfg_attr(nothing, cfg(nothing))] c: i32,\n    |                                            ^ help: consider prefixing with an underscore: `_c`\n \n error: unused variable: `b`\n-  --> $DIR/param-attrs-cfg.rs:47:27\n+  --> $DIR/param-attrs-cfg.rs:59:27\n    |\n LL |         #[cfg(something)] b: i32,\n    |                           ^ help: consider prefixing with an underscore: `_b`\n \n error: unused variable: `c`\n-  --> $DIR/param-attrs-cfg.rs:49:44\n+  --> $DIR/param-attrs-cfg.rs:61:44\n    |\n LL |         #[cfg_attr(nothing, cfg(nothing))] c: i32,\n    |                                            ^ help: consider prefixing with an underscore: `_c`\n \n+error: unused variable: `a`\n+  --> $DIR/param-attrs-cfg.rs:41:27\n+   |\n+LL |         #[cfg(something)] a: i32,\n+   |                           ^ help: consider prefixing with an underscore: `_a`\n+\n error: unused variable: `b`\n-  --> $DIR/param-attrs-cfg.rs:36:27\n+  --> $DIR/param-attrs-cfg.rs:48:27\n    |\n LL |         #[cfg(something)] b: i32,\n    |                           ^ help: consider prefixing with an underscore: `_b`\n \n error: unused variable: `c`\n-  --> $DIR/param-attrs-cfg.rs:38:44\n+  --> $DIR/param-attrs-cfg.rs:50:44\n    |\n LL |         #[cfg_attr(nothing, cfg(nothing))] c: i32,\n    |                                            ^ help: consider prefixing with an underscore: `_c`\n \n error: unused variable: `b`\n-  --> $DIR/param-attrs-cfg.rs:58:27\n+  --> $DIR/param-attrs-cfg.rs:70:27\n    |\n LL |         #[cfg(something)] b: i32,\n    |                           ^ help: consider prefixing with an underscore: `_b`\n \n error: unused variable: `c`\n-  --> $DIR/param-attrs-cfg.rs:60:44\n+  --> $DIR/param-attrs-cfg.rs:72:44\n    |\n LL |         #[cfg_attr(nothing, cfg(nothing))] c: i32,\n    |                                            ^ help: consider prefixing with an underscore: `_c`\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 13 previous errors\n "}, {"sha": "a7f4855915b24f76b70844026cb4580a75c2e13b", "filename": "src/test/ui/rfc-2565-param-attrs/param-attrs-feature-gate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-feature-gate.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -1,12 +1,14 @@\n // gate-test-param_attrs\n \n+#![deny(unused_variables)]\n+\n fn foo(\n     /// Foo\n     //~^ ERROR documentation comments cannot be applied to function parameters\n     //~| NOTE doc comments are not allowed here\n     //~| ERROR attributes on function parameters are unstable\n     //~| NOTE https://github.com/rust-lang/rust/issues/60406\n-    #[allow(C)] a: u8\n+    #[allow(unused_variables)] a: u8\n     //~^ ERROR attributes on function parameters are unstable\n     //~| NOTE https://github.com/rust-lang/rust/issues/60406\n ) {}"}, {"sha": "0bb9d05dca0acad876418cebefe1ba2f40e2fd98", "filename": "src/test/ui/rfc-2565-param-attrs/param-attrs-feature-gate.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-feature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-feature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-feature-gate.stderr?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -1,11 +1,11 @@\n error: documentation comments cannot be applied to function parameters\n-  --> $DIR/param-attrs-feature-gate.rs:4:5\n+  --> $DIR/param-attrs-feature-gate.rs:6:5\n    |\n LL |     /// Foo\n    |     ^^^^^^^ doc comments are not allowed here\n \n error[E0658]: attributes on function parameters are unstable\n-  --> $DIR/param-attrs-feature-gate.rs:4:5\n+  --> $DIR/param-attrs-feature-gate.rs:6:5\n    |\n LL |     /// Foo\n    |     ^^^^^^^\n@@ -14,10 +14,10 @@ LL |     /// Foo\n    = help: add `#![feature(param_attrs)]` to the crate attributes to enable\n \n error[E0658]: attributes on function parameters are unstable\n-  --> $DIR/param-attrs-feature-gate.rs:9:5\n+  --> $DIR/param-attrs-feature-gate.rs:11:5\n    |\n-LL |     #[allow(C)] a: u8\n-   |     ^^^^^^^^^^^\n+LL |     #[allow(unused_variables)] a: u8\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/60406\n    = help: add `#![feature(param_attrs)]` to the crate attributes to enable"}, {"sha": "eca8001a9d2a1be40f45cfe6eccae9b9d4d49779", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -43,31 +43,19 @@ pub mod unstable_book;\n \n fn filter_dirs(path: &Path) -> bool {\n     let skip = [\n-        \"src/llvm\",\n-        \"src/llvm-project\",\n         \"src/llvm-emscripten\",\n-        \"src/libbacktrace\",\n-        \"src/librustc_data_structures/owning_ref\",\n-        \"src/vendor\",\n+        \"src/llvm-project\",\n+        \"src/stdarch\",\n         \"src/tools/cargo\",\n-        \"src/tools/clang\",\n-        \"src/tools/rls\",\n         \"src/tools/clippy\",\n+        \"src/tools/miri\",\n+        \"src/tools/rls\",\n         \"src/tools/rust-installer\",\n         \"src/tools/rustfmt\",\n-        \"src/tools/miri\",\n-        \"src/tools/lld\",\n-        \"src/tools/lldb\",\n-        \"src/target\",\n-        \"src/stdarch\",\n-        \"src/rust-sgx\",\n-        \"target\",\n-        \"vendor\",\n     ];\n     skip.iter().any(|p| path.ends_with(p))\n }\n \n-\n fn walk_many(\n     paths: &[&Path], skip: &mut dyn FnMut(&Path) -> bool, f: &mut dyn FnMut(&DirEntry, &str)\n ) {"}, {"sha": "6a0d530e2362a27b55d5b44f8b54928e25945e68", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -152,6 +152,8 @@ pub fn check(path: &Path, bad: &mut bool) {\n         let mut skip_file_length = contains_ignore_directive(can_contain, &contents, \"filelength\");\n         let mut skip_end_whitespace =\n             contains_ignore_directive(can_contain, &contents, \"end-whitespace\");\n+        let mut skip_trailing_newlines =\n+            contains_ignore_directive(can_contain, &contents, \"trailing-newlines\");\n         let mut skip_copyright = contains_ignore_directive(can_contain, &contents, \"copyright\");\n         let mut leading_new_lines = false;\n         let mut trailing_new_lines = 0;\n@@ -214,10 +216,17 @@ pub fn check(path: &Path, bad: &mut bool) {\n         if leading_new_lines {\n             tidy_error!(bad, \"{}: leading newline\", file.display());\n         }\n+        let mut err = |msg: &str| {\n+            tidy_error!(bad, \"{}: {}\", file.display(), msg);\n+        };\n         match trailing_new_lines {\n-            0 => tidy_error!(bad, \"{}: missing trailing newline\", file.display()),\n+            0 => suppressible_tidy_err!(err, skip_trailing_newlines, \"missing trailing newline\"),\n             1 => {}\n-            n => tidy_error!(bad, \"{}: too many trailing newlines ({})\", file.display(), n),\n+            n => suppressible_tidy_err!(\n+                err,\n+                skip_trailing_newlines,\n+                &format!(\"too many trailing newlines ({})\", n)\n+            ),\n         };\n         if lines > LINES {\n             let mut err = |_| {\n@@ -247,6 +256,9 @@ pub fn check(path: &Path, bad: &mut bool) {\n         if let Directive::Ignore(false) = skip_end_whitespace {\n             tidy_error!(bad, \"{}: ignoring trailing whitespace unnecessarily\", file.display());\n         }\n+        if let Directive::Ignore(false) = skip_trailing_newlines {\n+            tidy_error!(bad, \"{}: ignoring trailing newlines unnecessarily\", file.display());\n+        }\n         if let Directive::Ignore(false) = skip_copyright {\n             tidy_error!(bad, \"{}: ignoring copyright unnecessarily\", file.display());\n         }"}]}