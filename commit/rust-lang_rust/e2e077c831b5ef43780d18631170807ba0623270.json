{"sha": "e2e077c831b5ef43780d18631170807ba0623270", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZTA3N2M4MzFiNWVmNDM3ODBkMTg2MzExNzA4MDdiYTA2MjMyNzA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-22T12:47:30Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-22T14:04:00Z"}, "message": "Remove trivial cast checker\n\nI consider the added complexity not justified at this point, and it\ninteracts badly with the patches for issue #828. Feel free to discuss.", "tree": {"sha": "bf569817966747368a661712e6f62f1567e58b2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf569817966747368a661712e6f62f1567e58b2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2e077c831b5ef43780d18631170807ba0623270", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2e077c831b5ef43780d18631170807ba0623270", "html_url": "https://github.com/rust-lang/rust/commit/e2e077c831b5ef43780d18631170807ba0623270", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2e077c831b5ef43780d18631170807ba0623270/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e31983a02eb5476dbfc84c71af037ddde3492fb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e31983a02eb5476dbfc84c71af037ddde3492fb5", "html_url": "https://github.com/rust-lang/rust/commit/e31983a02eb5476dbfc84c71af037ddde3492fb5"}], "stats": {"total": 230, "additions": 36, "deletions": 194}, "files": [{"sha": "1a34fe631e954912bade5569d03f39443757dbb1", "filename": "src/comp/middle/check_const.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2e077c831b5ef43780d18631170807ba0623270/src%2Fcomp%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e077c831b5ef43780d18631170807ba0623270/src%2Fcomp%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_const.rs?ref=e2e077c831b5ef43780d18631170807ba0623270", "patch": "@@ -43,7 +43,6 @@ fn check_expr(sess: session, e: @expr, &&is_const: bool, v: visit::vt<bool>) {\n                           \"disallowed operator in constant expression\");\n             ret;\n           }\n-          expr_cast(_, _) { }\n           expr_lit(@{node: lit_str(_), _}) {\n             sess.span_err(e.span,\n                           \"string constants are not supported\");"}, {"sha": "cc2259d6e0d01dd0633449f9a6f211ff1ef5529d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e2e077c831b5ef43780d18631170807ba0623270/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e077c831b5ef43780d18631170807ba0623270/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e2e077c831b5ef43780d18631170807ba0623270", "patch": "@@ -3581,12 +3581,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         }\n         else { ret lval_to_dps(bcx, a, dest); }\n       }\n-      ast::expr_cast(val, _) {\n-        alt tcx.cast_map.find(e.id) {\n-          some(ty::triv_cast.) { ret trans_expr(bcx, val, dest); }\n-          _ { ret trans_cast(bcx, val, e.id, dest); }\n-        }\n-      }\n+      ast::expr_cast(val, _) { ret trans_cast(bcx, val, e.id, dest); }\n       ast::expr_anon_obj(anon_obj) {\n         ret trans_anon_obj(bcx, e.span, anon_obj, e.id, dest);\n       }\n@@ -3615,7 +3610,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         // that is_call_expr(ex) -- but we don't support that\n         // yet\n         // FIXME\n-        check (ast_util::is_tail_call_expr(ex));\n+        check (ast_util::is_call_expr(ex));\n         ret trans_be(bcx, ex);\n       }\n       ast::expr_fail(expr) {\n@@ -3952,8 +3947,7 @@ fn trans_ret(bcx: @block_ctxt, e: option::t<@ast::expr>) -> @block_ctxt {\n fn build_return(bcx: @block_ctxt) { Br(bcx, bcx_fcx(bcx).llreturn); }\n \n // fn trans_be(cx: &@block_ctxt, e: &@ast::expr) -> result {\n-fn trans_be(cx: @block_ctxt, e: @ast::expr) :\n-ast_util::is_tail_call_expr(e) ->\n+fn trans_be(cx: @block_ctxt, e: @ast::expr) : ast_util::is_call_expr(e) ->\n    @block_ctxt {\n     // FIXME: Turn this into a real tail call once\n     // calling convention issues are settled\n@@ -4728,16 +4722,6 @@ fn trans_impl(cx: @local_ctxt, name: ast::ident, methods: [@ast::method],\n // that does so later on?\n fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n     alt e.node {\n-      ast::expr_cast(e1, _) {\n-        alt ccx_tcx(cx).cast_map.find(e.id) {\n-          some(ty::triv_cast.) { trans_const_expr(cx, e1) }\n-          _ {\n-              cx.sess.span_err(e.span,\n-                               \"non-trivial cast in constant expression\");\n-              fail;\n-            }\n-        }\n-      }\n       ast::expr_lit(lit) { ret trans_crate_lit(cx, *lit); }\n       ast::expr_binary(b, e1, e2) {\n         let te1 = trans_const_expr(cx, e1);"}, {"sha": "ef6177822e376e22046f37b08d39e3b24aadd1f1", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e2e077c831b5ef43780d18631170807ba0623270/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e077c831b5ef43780d18631170807ba0623270/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=e2e077c831b5ef43780d18631170807ba0623270", "patch": "@@ -31,7 +31,6 @@ export ast_constr_to_constr;\n export bind_params_in_type;\n export block_ty;\n export constr;\n-export cast_type;\n export constr_general;\n export constr_table;\n export count_ty_params;\n@@ -106,8 +105,6 @@ export substitute_type_params;\n export t;\n export tag_variants;\n export tag_variant_with_id;\n-export triv_cast;\n-export triv_eq_ty;\n export ty_param_substs_opt_and_ty;\n export ty_param_kinds_and_ty;\n export ty_native_fn;\n@@ -133,7 +130,6 @@ export ty_param;\n export ty_ptr;\n export ty_rec;\n export ty_tag;\n-export ty_to_machine_ty;\n export ty_tup;\n export ty_type;\n export ty_send_type;\n@@ -214,17 +210,10 @@ type creader_cache = hashmap<{cnum: int, pos: uint, len: uint}, ty::t>;\n type tag_var_cache =\n     @smallintmap::smallintmap<@mutable [variant_info]>;\n \n-tag cast_type {\n-    /* cast may be ignored after substituting primitive with machine types\n-       since expr already has the right type */\n-    triv_cast;\n-}\n-\n type ctxt =\n     @{ts: @type_store,\n       sess: session::session,\n       def_map: resolve::def_map,\n-      cast_map: hashmap<ast::node_id, cast_type>,\n       node_types: node_type_table,\n       items: ast_map::map,\n       freevars: freevars::freevar_map,\n@@ -420,7 +409,6 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n         @{ts: ts,\n           sess: s,\n           def_map: dm,\n-          cast_map: ast_util::new_node_hash(),\n           node_types: ntt,\n           items: amap,\n           freevars: freevars,\n@@ -1423,42 +1411,6 @@ fn eq_raw_ty(&&a: @raw_t, &&b: @raw_t) -> bool {\n // the types are interned.\n fn eq_ty(&&a: t, &&b: t) -> bool { a == b }\n \n-\n-// Convert type to machine type\n-// (i.e. replace uint, int, float with target architecture machine types)\n-//\n-// FIXME somewhat expensive but this should only be called rarely\n-fn ty_to_machine_ty(cx: ctxt, ty: t) -> t {\n-    fn sub_fn(cx: ctxt, uint_ty: t, int_ty: t, float_ty: t, in: t) -> t {\n-        alt struct(cx, in) {\n-          ty_uint(ast::ty_u.) { ret uint_ty; }\n-          ty_int(ast::ty_i.) { ret int_ty; }\n-          ty_float(ast::ty_f.) { ret float_ty; }\n-          _ { ret in; }\n-        }\n-    }\n-\n-    let cfg      = cx.sess.get_targ_cfg();\n-    let uint_ty  = mk_mach_uint(cx, cfg.uint_type);\n-    let int_ty   = mk_mach_int(cx, cfg.int_type);\n-    let float_ty = mk_mach_float(cx, cfg.float_type);\n-    let fold_m   = fm_general(bind sub_fn(cx, uint_ty, int_ty, float_ty, _));\n-\n-    ret fold_ty(cx, fold_m, ty);\n-}\n-\n-// Two types are trivially equal if they are either\n-// equal or if they are equal after substituting all occurences of\n-//  machine independent primitive types by their machine type equivalents\n-// for the current target architecture\n-fn triv_eq_ty(cx: ctxt, &&a: t, &&b: t) -> bool {\n-    let a = alt interner::get(*cx.ts, a).struct\n-        { ty_named(t, _) { t } _ { a } };\n-    let b = alt interner::get(*cx.ts, b).struct\n-        { ty_named(t, _) { t } _ { b } };\n-    a == b || ty_to_machine_ty(cx, a) == ty_to_machine_ty(cx, b)\n-}\n-\n // Type lookups\n fn node_id_to_ty_param_substs_opt_and_ty(cx: ctxt, id: ast::node_id) ->\n    ty_param_substs_opt_and_ty {"}, {"sha": "d37482f0f1e8edb5833b28a73099d4a1d5dd1363", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e2e077c831b5ef43780d18631170807ba0623270/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e077c831b5ef43780d18631170807ba0623270/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=e2e077c831b5ef43780d18631170807ba0623270", "patch": "@@ -1850,21 +1850,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_be(e) {\n         // FIXME: prove instead of assert\n-        assert (ast_util::is_tail_call_expr(e));\n+        assert (ast_util::is_call_expr(e));\n         check_expr_with(fcx, e, fcx.ret_ty);\n-\n-        alt e.node {\n-          ast::expr_cast(_, _) {\n-            alt tcx.cast_map.find(e.id) {\n-              option::some(ty::triv_cast.) { }\n-              _ { tcx.sess.span_err(expr.span,\n-                    \"non-trivial cast of tail-call return value\");\n-                }\n-            }\n-          }\n-          _ { /* regular tail call */ }\n-        }\n-\n         bot = true;\n         write::nil_ty(tcx, id);\n       }\n@@ -2066,19 +2053,19 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       ast::expr_cast(e, t) {\n         bot = check_expr(fcx, e);\n         let t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n-        let t_e = expr_ty(tcx, e);\n+        let t_e = ty::expr_ty(tcx, e);\n \n         if ty::type_is_nil(tcx, t_e) {\n             tcx.sess.span_err(expr.span,\n                               \"cast from nil: \" +\n-                                  ty_to_str(tcx, expr_ty(tcx, e)) + \" as \" +\n+                                  ty_to_str(tcx, t_e) + \" as \" +\n                                   ty_to_str(tcx, t_1));\n         }\n \n         if ty::type_is_nil(tcx, t_1) {\n             tcx.sess.span_err(expr.span,\n                               \"cast to nil: \" +\n-                                  ty_to_str(tcx, expr_ty(tcx, e)) + \" as \" +\n+                                  ty_to_str(tcx, t_e) + \" as \" +\n                                   ty_to_str(tcx, t_1));\n         }\n \n@@ -2087,14 +2074,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n              && type_is_scalar(fcx, expr.span, t_1)) {\n             tcx.sess.span_err(expr.span,\n                               \"non-scalar cast: \" +\n-                                  ty_to_str(tcx, expr_ty(tcx, e)) + \" as \" +\n+                                  ty_to_str(tcx, t_e) + \" as \" +\n                                   ty_to_str(tcx, t_1));\n         }\n-\n-        // mark as triv_cast for later dropping in trans\n-        if ty::triv_eq_ty(tcx, t_1, t_e)\n-            { tcx.cast_map.insert(expr.id, ty::triv_cast); }\n-\n         write::ty_only_fixup(fcx, id, t_1);\n       }\n       ast::expr_vec(args, mut) {"}, {"sha": "f32b4f7aa93021b19550c18c644d483fd7a29de8", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e2e077c831b5ef43780d18631170807ba0623270/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e077c831b5ef43780d18631170807ba0623270/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=e2e077c831b5ef43780d18631170807ba0623270", "patch": "@@ -1,19 +1,10 @@\n-import core::{str, option, int};\n-import std::map;\n import codemap::span;\n import ast::*;\n \n fn respan<copy T>(sp: span, t: T) -> spanned<T> {\n     ret {node: t, span: sp};\n }\n \n-fn new_node_hash<copy V>() -> map::hashmap<node_id, V> {\n-    fn node_id_hash(&&i: node_id) -> uint { ret int::hash(i as int); }\n-    fn node_id_eq(&&a: node_id, &&b: node_id) -> bool\n-        { ret int::eq(a as int, b as int); }\n-    ret map::mk_hashmap(node_id_hash, node_id_eq);\n-}\n-\n /* assuming that we're not in macro expansion */\n fn mk_sp(lo: uint, hi: uint) -> span {\n     ret {lo: lo, hi: hi, expanded_from: codemap::os_none};\n@@ -198,14 +189,6 @@ pure fn is_call_expr(e: @expr) -> bool {\n     alt e.node { expr_call(_, _, _) { true } _ { false } }\n }\n \n-pure fn is_tail_call_expr(e: @expr) -> bool {\n-    alt e.node {\n-      expr_call(_, _, _) { true }\n-      expr_cast(inner_e, _) { is_call_expr(inner_e) }\n-      _ { false }\n-    }\n-}\n-\n fn is_constraint_arg(e: @expr) -> bool {\n     alt e.node {\n       expr_lit(_) { ret true; }"}, {"sha": "cf02c4ea31e399ec058d580ef57157cdf0dcbb72", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2e077c831b5ef43780d18631170807ba0623270/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e077c831b5ef43780d18631170807ba0623270/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=e2e077c831b5ef43780d18631170807ba0623270", "patch": "@@ -958,7 +958,7 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n         let e = parse_expr(p);\n \n         // FIXME: Is this the right place for this check?\n-        if /*check*/ ast_util::is_tail_call_expr(e) {\n+        if /*check*/ast_util::is_call_expr(e) {\n             hi = e.span.hi;\n             ex = ast::expr_be(e);\n         } else { p.fatal(\"Non-call expression in tail call\"); }"}, {"sha": "fdc5dda996d13d3e5123cb9185a7ff983b74592a", "filename": "src/libcore/float.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e2e077c831b5ef43780d18631170807ba0623270/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e077c831b5ef43780d18631170807ba0623270/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=e2e077c831b5ef43780d18631170807ba0623270", "patch": "@@ -482,23 +482,23 @@ Function: acos\n Returns the arccosine of an angle (measured in rad)\n */\n pure fn acos(x: float) -> float\n-    { be m_float::acos(x as m_float) as float }\n+    { ret m_float::acos(x as m_float) as float }\n \n /*\n Function: asin\n \n Returns the arcsine of an angle (measured in rad)\n */\n pure fn asin(x: float) -> float\n-    { be m_float::asin(x as m_float) as float }\n+    { ret m_float::asin(x as m_float) as float }\n \n /*\n Function: atan\n \n Returns the arctangents of an angle (measured in rad)\n */\n pure fn atan(x: float) -> float\n-    { be m_float::atan(x as m_float) as float }\n+    { ret m_float::atan(x as m_float) as float }\n \n \n /*\n@@ -507,23 +507,23 @@ Function: atan2\n Returns the arctangent of an angle (measured in rad)\n */\n pure fn atan2(y: float, x: float) -> float\n-    { be m_float::atan2(y as m_float, x as m_float) as float }\n+    { ret m_float::atan2(y as m_float, x as m_float) as float }\n \n /*\n Function: ceil\n \n Returns the smallest integral value less than or equal to `n`\n */\n pure fn ceil(n: float) -> float\n-    { be m_float::ceil(n as m_float) as float }\n+    { ret m_float::ceil(n as m_float) as float }\n \n /*\n Function: cos\n \n Returns the cosine of an angle `x` (measured in rad)\n */\n pure fn cos(x: float) -> float\n-    { be m_float::cos(x as m_float) as float }\n+    { ret m_float::cos(x as m_float) as float }\n \n /*\n Function: cosh\n@@ -532,7 +532,7 @@ Returns the hyperbolic cosine of `x`\n \n */\n pure fn cosh(x: float) -> float\n-    { be m_float::cosh(x as m_float) as float }\n+    { ret m_float::cosh(x as m_float) as float }\n \n \n /*\n@@ -541,47 +541,47 @@ Function: exp\n Returns `consts::e` to the power of `n*\n */\n pure fn exp(n: float) -> float\n-    { be m_float::exp(n as m_float) as float }\n+    { ret m_float::exp(n as m_float) as float }\n \n /*\n Function: abs\n \n Returns the absolute value of  `n`\n */\n pure fn abs(n: float) -> float\n-    { be m_float::abs(n as m_float) as float }\n+    { ret m_float::abs(n as m_float) as float }\n \n /*\n Function: floor\n \n Returns the largest integral value less than or equal to `n`\n */\n pure fn floor(n: float) -> float\n-    { be m_float::floor(n as m_float) as float }\n+    { ret m_float::floor(n as m_float) as float }\n \n /*\n Function: fmod\n \n Returns the floating-point remainder of `x/y`\n */\n pure fn fmod(x: float, y: float) -> float\n-    { be m_float::fmod(x as m_float, y as m_float) as float }\n+    { ret m_float::fmod(x as m_float, y as m_float) as float }\n \n /*\n Function: ln\n \n Returns the natural logaritm of `n`\n */\n pure fn ln(n: float) -> float\n-    { be m_float::ln(n as m_float) as float }\n+    { ret m_float::ln(n as m_float) as float }\n \n /*\n Function: ldexp\n \n Returns `x` multiplied by 2 to the power of `n`\n */\n pure fn ldexp(n: float, i: int) -> float\n-    { be m_float::ldexp(n as m_float, i as c_int) as float }\n+    { ret m_float::ldexp(n as m_float, i as c_int) as float }\n \n /*\n Function: ln1p\n@@ -590,23 +590,23 @@ Returns the natural logarithm of `1+n` accurately,\n even for very small values of `n`\n */\n pure fn ln1p(n: float) -> float\n-    { be m_float::ln1p(n as m_float) as float }\n+    { ret m_float::ln1p(n as m_float) as float }\n \n /*\n Function: log10\n \n Returns the logarithm to base 10 of `n`\n */\n pure fn log10(n: float) -> float\n-    { be m_float::log10(n as m_float) as float }\n+    { ret m_float::log10(n as m_float) as float }\n \n /*\n Function: log2\n \n Returns the logarithm to base 2 of `n`\n */\n pure fn log2(n: float) -> float\n-    { be m_float::log2(n as m_float) as float }\n+    { ret m_float::log2(n as m_float) as float }\n \n /*\n Function: modf\n@@ -622,7 +622,7 @@ The fractional part of `n`\n */\n #[no(warn_trivial_casts)] // FIXME Implement\n pure fn modf(n: float, &iptr: float) -> float { unsafe {\n-    be m_float::modf(n as m_float, ptr::addr_of(iptr) as *m_float) as float\n+    ret m_float::modf(n as m_float, ptr::addr_of(iptr) as *m_float) as float\n } }\n \n /*\n@@ -640,13 +640,13 @@ Returns:\n The fractional part of `n`\n */\n pure fn frexp(n: float, &exp: c_int) -> float\n-    { be m_float::frexp(n as m_float, exp) as float }\n+    { ret m_float::frexp(n as m_float, exp) as float }\n \n /*\n Function: pow\n */\n pure fn pow(v: float, e: float) -> float\n-    { be m_float::pow(v as m_float, e as m_float) as float }\n+    { ret m_float::pow(v as m_float, e as m_float) as float }\n \n \n /*\n@@ -656,7 +656,7 @@ Returns the integral value nearest to `x` (according to the\n prevailing rounding mode) in floating-point format\n */\n pure fn rint(x: float) -> float\n-    { be m_float::rint(x as m_float) as float }\n+    { ret m_float::rint(x as m_float) as float }\n \n /*\n Function: round\n@@ -666,31 +666,31 @@ Return the integral value nearest to `x` rounding half-way\n cases away from zero, regardless of the current rounding direction.\n */\n pure fn round(x: float) -> float\n-    { be m_float::round(x as m_float) as float }\n+    { ret m_float::round(x as m_float) as float }\n \n /*\n Function: sin\n \n Returns the sine of an angle `x` (measured in rad)\n */\n pure fn sin(x: float) -> float\n-    { be m_float::sin(x as m_float) as float }\n+    { ret m_float::sin(x as m_float) as float }\n \n /*\n Function: sinh\n \n Returns the hyperbolic sine of an angle `x` (measured in rad)\n */\n pure fn sinh(x: float) -> float\n-    { be m_float::sinh(x as m_float) as float }\n+    { ret m_float::sinh(x as m_float) as float }\n \n /*\n Function: sqrt\n \n Returns the square root of `x`\n */\n pure fn sqrt(x: float) -> float\n-    { be m_float::sqrt(x as m_float) as float }\n+    { ret m_float::sqrt(x as m_float) as float }\n \n /*\n Function: tan\n@@ -699,7 +699,7 @@ Returns the tangent of an angle `x` (measured in rad)\n \n */\n pure fn tan(x: float) -> float\n-    { be m_float::tan(x as m_float) as float }\n+    { ret m_float::tan(x as m_float) as float }\n \n /*\n Function: tanh\n@@ -708,7 +708,7 @@ Returns the hyperbolic tangent of an angle `x` (measured in rad)\n \n */\n pure fn tanh(x: float) -> float\n-    { be m_float::tanh(x as m_float) as float }\n+    { ret m_float::tanh(x as m_float) as float }\n \n /*\n Function: trunc\n@@ -717,7 +717,7 @@ Returns the integral value nearest to but no larger in magnitude than `x`\n \n */\n pure fn trunc(x: float) -> float\n-    { be m_float::trunc(x as m_float) as float }\n+    { ret m_float::trunc(x as m_float) as float }\n \n //\n // Local Variables:"}, {"sha": "458013a912c9c4d2787108c7024f78ab75b49627", "filename": "src/test/compile-fail/non-triv-cast-be.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e31983a02eb5476dbfc84c71af037ddde3492fb5/src%2Ftest%2Fcompile-fail%2Fnon-triv-cast-be.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e31983a02eb5476dbfc84c71af037ddde3492fb5/src%2Ftest%2Fcompile-fail%2Fnon-triv-cast-be.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-triv-cast-be.rs?ref=e31983a02eb5476dbfc84c71af037ddde3492fb5", "patch": "@@ -1,17 +0,0 @@\n-// error-pattern: non-trivial cast of tail-call return value\n-import core::mtypes::*;\n-\n-fn foo_float() -> m_float { ret 0.0 as m_float; }\n-fn bar_float() -> bool { be foo_float() as bool; }\n-\n-fn foo_int() -> m_int { ret 0 as m_int; }\n-fn bar_int() -> bool { be foo_int() as bool; }\n-\n-fn foo_uint() -> m_uint { ret 0u as m_uint; }\n-fn bar_uint() -> bool { be foo_uint() as bool; }\n-\n-fn main() {\n-    assert bar_float() == 0.0;\n-    assert bar_int() == 0.0;\n-    assert bar_uint() == 0.0;\n-}\n\\ No newline at end of file"}, {"sha": "0fbb1ad283009e230bd6bae5646a7610e457f092", "filename": "src/test/run-pass/triv-cast-be.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e31983a02eb5476dbfc84c71af037ddde3492fb5/src%2Ftest%2Frun-pass%2Ftriv-cast-be.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e31983a02eb5476dbfc84c71af037ddde3492fb5/src%2Ftest%2Frun-pass%2Ftriv-cast-be.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftriv-cast-be.rs?ref=e31983a02eb5476dbfc84c71af037ddde3492fb5", "patch": "@@ -1,28 +0,0 @@\n-import core::ctypes::*;\n-\n-import core::mtypes::m_float;\n-import core::mtypes::m_int;\n-import core::mtypes::m_uint;\n-\n-fn foo_float() -> m_float { ret 0.0 as m_float; }\n-fn bar_float() -> float { be foo_float() as float; }\n-\n-fn foo_int() -> m_int { ret 0 as m_int; }\n-fn bar_int() -> int { be foo_int() as int; }\n-\n-fn foo_uint() -> m_uint { ret 0u as m_uint; }\n-fn bar_uint() -> uint { be foo_uint() as uint; }\n-\n-fn foo_long() -> long { ret 0 as long; }\n-fn bar_long() -> int { be foo_long() as int; }\n-\n-fn foo_ulong() -> ulong { ret 0u as ulong; }\n-fn bar_ulong() -> uint { be foo_uint() as uint; }\n-\n-fn main() {\n-    assert bar_float() == 0.0;\n-    assert bar_int() == 0;\n-    assert bar_uint() == 0u;\n-    assert bar_long() == 0;\n-    assert bar_ulong() == 0u;\n-}\n\\ No newline at end of file"}, {"sha": "0880fc82c48dbbc26bf5a3aa56c441b674dbec11", "filename": "src/test/run-pass/triv-cast-const.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e31983a02eb5476dbfc84c71af037ddde3492fb5/src%2Ftest%2Frun-pass%2Ftriv-cast-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e31983a02eb5476dbfc84c71af037ddde3492fb5/src%2Ftest%2Frun-pass%2Ftriv-cast-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftriv-cast-const.rs?ref=e31983a02eb5476dbfc84c71af037ddde3492fb5", "patch": "@@ -1,13 +0,0 @@\n-import core::mtypes::m_int;\n-\n-// This will be more interesting once there is support\n-// for consts that refer to other consts, i.e. math_f64::consts::pi as m_float\n-#[cfg(target_arch=\"x86\")]\n-const foo: m_int = 0i32 as m_int;\n-\n-#[cfg(target_arch=\"x86_64\")]\n-const foo: m_int = 0i64 as m_int;\n-\n-fn main() {\n-    assert foo == 0 as m_int;\n-}\n\\ No newline at end of file"}]}