{"sha": "78419779f1bd5f5f51179af7d2c768c8eeab637e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NDE5Nzc5ZjFiZDVmNWY1MTE3OWFmN2QyYzc2OGM4ZWVhYjYzN2U=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-06-20T17:10:45Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-06-20T17:12:06Z"}, "message": "More cleanups, use `check` for `display_source_code` tests", "tree": {"sha": "97f44ee533b79ac0342dd9a173f5b54c954c9812", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97f44ee533b79ac0342dd9a173f5b54c954c9812"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78419779f1bd5f5f51179af7d2c768c8eeab637e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78419779f1bd5f5f51179af7d2c768c8eeab637e", "html_url": "https://github.com/rust-lang/rust/commit/78419779f1bd5f5f51179af7d2c768c8eeab637e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78419779f1bd5f5f51179af7d2c768c8eeab637e/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0219b145ea255e215693d0fc324aa78311a41236", "url": "https://api.github.com/repos/rust-lang/rust/commits/0219b145ea255e215693d0fc324aa78311a41236", "html_url": "https://github.com/rust-lang/rust/commit/0219b145ea255e215693d0fc324aa78311a41236"}], "stats": {"total": 152, "additions": 67, "deletions": 85}, "files": [{"sha": "0651f34ae6cca512f296671d84398e6faae94c6d", "filename": "crates/hir_ty/src/tests.rs", "status": "modified", "additions": 62, "deletions": 80, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/78419779f1bd5f5f51179af7d2c768c8eeab637e/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78419779f1bd5f5f51179af7d2c768c8eeab637e/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests.rs?ref=78419779f1bd5f5f51179af7d2c768c8eeab637e", "patch": "@@ -11,23 +11,21 @@ mod incremental;\n \n use std::{collections::HashMap, env, sync::Arc};\n \n-use base_db::{fixture::WithFixture, FileRange, SourceDatabase, SourceDatabaseExt};\n+use base_db::{fixture::WithFixture, FileRange, SourceDatabaseExt};\n use expect_test::Expect;\n use hir_def::{\n     body::{Body, BodySourceMap, SyntheticSyntax},\n-    child_by_source::ChildBySource,\n     db::DefDatabase,\n+    expr::{ExprId, PatId},\n     item_scope::ItemScope,\n-    keys,\n     nameres::DefMap,\n     src::HasSource,\n-    AssocItemId, DefWithBodyId, LocalModuleId, Lookup, ModuleDefId,\n+    AssocItemId, DefWithBodyId, HasModule, LocalModuleId, Lookup, ModuleDefId,\n };\n use hir_expand::{db::AstDatabase, InFile};\n use once_cell::race::OnceBool;\n use stdx::format_to;\n use syntax::{\n-    algo,\n     ast::{self, AstNode, NameOwner},\n     SyntaxNode,\n };\n@@ -59,45 +57,22 @@ fn setup_tracing() -> Option<tracing::subscriber::DefaultGuard> {\n }\n \n fn check_types(ra_fixture: &str) {\n-    check_impl(ra_fixture, false, true)\n+    check_impl(ra_fixture, false, true, false)\n }\n \n fn check_types_source_code(ra_fixture: &str) {\n-    // TODO\n-    check_types_impl(ra_fixture, true)\n-}\n-\n-fn check_types_impl(ra_fixture: &str, display_source: bool) {\n-    // TODO\n-    let _tracing = setup_tracing();\n-    let db = TestDB::with_files(ra_fixture);\n-    let mut checked_one = false;\n-    for (file_id, annotations) in db.extract_annotations() {\n-        for (range, expected) in annotations {\n-            let ty = type_at_range(&db, FileRange { file_id, range });\n-            let actual = if display_source {\n-                let module = db.module_for_file(file_id);\n-                ty.display_source_code(&db, module).unwrap()\n-            } else {\n-                ty.display_test(&db).to_string()\n-            };\n-            assert_eq!(expected, actual);\n-            checked_one = true;\n-        }\n-    }\n-\n-    assert!(checked_one, \"no `//^` annotations found\");\n+    check_impl(ra_fixture, false, true, true)\n }\n \n fn check_no_mismatches(ra_fixture: &str) {\n-    check_impl(ra_fixture, true, false)\n+    check_impl(ra_fixture, true, false, false)\n }\n \n fn check(ra_fixture: &str) {\n-    check_impl(ra_fixture, false, false)\n+    check_impl(ra_fixture, false, false, false)\n }\n \n-fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool) {\n+fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_source: bool) {\n     let _tracing = setup_tracing();\n     let (db, files) = TestDB::with_many_files(ra_fixture);\n \n@@ -151,50 +126,41 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool) {\n         let inference_result = db.infer(def);\n \n         for (pat, ty) in inference_result.type_of_pat.iter() {\n-            let node = match body_source_map.pat_syntax(pat) {\n-                Ok(sp) => {\n-                    let root = db.parse_or_expand(sp.file_id).unwrap();\n-                    sp.map(|ptr| {\n-                        ptr.either(\n-                            |it| it.to_node(&root).syntax().clone(),\n-                            |it| it.to_node(&root).syntax().clone(),\n-                        )\n-                    })\n-                }\n-                Err(SyntheticSyntax) => continue,\n+            let node = match pat_node(&body_source_map, pat, &db) {\n+                Some(value) => value,\n+                None => continue,\n             };\n             let range = node.as_ref().original_file_range(&db);\n-            if let Some(annotation) = types.remove(&range) {\n-                assert_eq!(ty.display_test(&db).to_string(), annotation);\n+            if let Some(expected) = types.remove(&range) {\n+                let actual = if display_source {\n+                    ty.display_source_code(&db, def.module(&db)).unwrap()\n+                } else {\n+                    ty.display_test(&db).to_string()\n+                };\n+                assert_eq!(actual, expected);\n             }\n         }\n \n         for (expr, ty) in inference_result.type_of_expr.iter() {\n-            let node = match body_source_map.expr_syntax(expr) {\n-                Ok(sp) => {\n-                    let root = db.parse_or_expand(sp.file_id).unwrap();\n-                    sp.map(|ptr| ptr.to_node(&root).syntax().clone())\n-                }\n-                Err(SyntheticSyntax) => continue,\n+            let node = match expr_node(&body_source_map, expr, &db) {\n+                Some(value) => value,\n+                None => continue,\n             };\n             let range = node.as_ref().original_file_range(&db);\n-            if let Some(annotation) = types.remove(&range) {\n-                assert_eq!(ty.display_test(&db).to_string(), annotation);\n+            if let Some(expected) = types.remove(&range) {\n+                let actual = if display_source {\n+                    ty.display_source_code(&db, def.module(&db)).unwrap()\n+                } else {\n+                    ty.display_test(&db).to_string()\n+                };\n+                assert_eq!(actual, expected);\n             }\n         }\n \n         for (pat, mismatch) in inference_result.pat_type_mismatches() {\n-            let node = match body_source_map.pat_syntax(pat) {\n-                Ok(sp) => {\n-                    let root = db.parse_or_expand(sp.file_id).unwrap();\n-                    sp.map(|ptr| {\n-                        ptr.either(\n-                            |it| it.to_node(&root).syntax().clone(),\n-                            |it| it.to_node(&root).syntax().clone(),\n-                        )\n-                    })\n-                }\n-                Err(SyntheticSyntax) => continue,\n+            let node = match pat_node(&body_source_map, pat, &db) {\n+                Some(value) => value,\n+                None => continue,\n             };\n             let range = node.as_ref().original_file_range(&db);\n             let actual = format!(\n@@ -249,21 +215,37 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool) {\n     assert!(buf.is_empty(), \"{}\", buf);\n }\n \n-fn type_at_range(db: &TestDB, pos: FileRange) -> Ty {\n-    let file = db.parse(pos.file_id).ok().unwrap();\n-    let expr = algo::find_node_at_range::<ast::Expr>(file.syntax(), pos.range).unwrap();\n-    let fn_def = expr.syntax().ancestors().find_map(ast::Fn::cast).unwrap();\n-    let module = db.module_for_file(pos.file_id);\n-    let func = *module.child_by_source(db)[keys::FUNCTION]\n-        .get(&InFile::new(pos.file_id.into(), fn_def))\n-        .unwrap();\n-\n-    let (_body, source_map) = db.body_with_source_map(func.into());\n-    if let Some(expr_id) = source_map.node_expr(InFile::new(pos.file_id.into(), &expr)) {\n-        let infer = db.infer(func.into());\n-        return infer[expr_id].clone();\n-    }\n-    panic!(\"Can't find expression\")\n+fn expr_node(\n+    body_source_map: &BodySourceMap,\n+    expr: ExprId,\n+    db: &TestDB,\n+) -> Option<InFile<SyntaxNode>> {\n+    Some(match body_source_map.expr_syntax(expr) {\n+        Ok(sp) => {\n+            let root = db.parse_or_expand(sp.file_id).unwrap();\n+            sp.map(|ptr| ptr.to_node(&root).syntax().clone())\n+        }\n+        Err(SyntheticSyntax) => return None,\n+    })\n+}\n+\n+fn pat_node(\n+    body_source_map: &BodySourceMap,\n+    pat: PatId,\n+    db: &TestDB,\n+) -> Option<InFile<SyntaxNode>> {\n+    Some(match body_source_map.pat_syntax(pat) {\n+        Ok(sp) => {\n+            let root = db.parse_or_expand(sp.file_id).unwrap();\n+            sp.map(|ptr| {\n+                ptr.either(\n+                    |it| it.to_node(&root).syntax().clone(),\n+                    |it| it.to_node(&root).syntax().clone(),\n+                )\n+            })\n+        }\n+        Err(SyntheticSyntax) => return None,\n+    })\n }\n \n fn infer(ra_fixture: &str) -> String {"}, {"sha": "058cd02d7a7aa2f218e77b18bc87b2f7a8077b25", "filename": "crates/hir_ty/src/tests/display_source_code.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78419779f1bd5f5f51179af7d2c768c8eeab637e/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78419779f1bd5f5f51179af7d2c768c8eeab637e/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=78419779f1bd5f5f51179af7d2c768c8eeab637e", "patch": "@@ -10,8 +10,8 @@ mod foo {\n \n fn bar() {\n     let foo: foo::Foo = foo::Foo;\n-    foo\n-}  //^ foo::Foo\n+    foo;\n+} //^^^ foo::Foo\n \n \"#,\n     );\n@@ -25,7 +25,7 @@ struct Foo<T = u8> { t: T }\n fn main() {\n     let foo = Foo { t: 5u8 };\n     foo;\n-}  //^ Foo\n+} //^^^ Foo\n \"#,\n     );\n \n@@ -35,7 +35,7 @@ struct Foo<K, T = u8> { k: K, t: T }\n fn main() {\n     let foo = Foo { k: 400, t: 5u8 };\n     foo;\n-}   //^ Foo<i32>\n+} //^^^ Foo<i32>\n \"#,\n     );\n }\n@@ -50,7 +50,7 @@ fn foo() -> *const (impl Unpin + Sized) { loop {} }\n fn main() {\n     let foo = foo();\n     foo;\n-}   //^ *const (impl Unpin + Sized)\n+} //^^^ *const (impl Unpin + Sized)\n \"#,\n     );\n }"}]}