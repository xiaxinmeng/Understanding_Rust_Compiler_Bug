{"sha": "4c11822aebd9e9c3bbe798f14fa10ec6db3f3937", "node_id": "C_kwDOAAsO6NoAKDRjMTE4MjJhZWJkOWU5YzNiYmU3OThmMTRmYTEwZWM2ZGIzZjM5Mzc", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-04-15T18:53:50Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-04-17T19:16:54Z"}, "message": "rustdoc: restructure type search engine to pick-and-use IDs\n\nThis change makes it so, instead of mixing string distance with\ntype unification, function signature search works by\nmapping names to IDs at the start, reporting to the user any\ncases where it had to make corrections, and then matches with\nIDs when going through the items.\n\nThis only changes function searches. Name searches are left alone,\nand corrections are only done when there's a single item in the\nsearch query.", "tree": {"sha": "ce89e933ebd8fb99605784ddf0c97e8f3a22e20d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce89e933ebd8fb99605784ddf0c97e8f3a22e20d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c11822aebd9e9c3bbe798f14fa10ec6db3f3937", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c11822aebd9e9c3bbe798f14fa10ec6db3f3937", "html_url": "https://github.com/rust-lang/rust/commit/4c11822aebd9e9c3bbe798f14fa10ec6db3f3937", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c11822aebd9e9c3bbe798f14fa10ec6db3f3937/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a7132d4f8dfb2ed6f9267b3bac5391a992d0775", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a7132d4f8dfb2ed6f9267b3bac5391a992d0775", "html_url": "https://github.com/rust-lang/rust/commit/1a7132d4f8dfb2ed6f9267b3bac5391a992d0775"}], "stats": {"total": 558, "additions": 354, "deletions": 204}, "files": [{"sha": "a7d5f497756b58fda25ac01e058235f661f55408", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c11822aebd9e9c3bbe798f14fa10ec6db3f3937/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/4c11822aebd9e9c3bbe798f14fa10ec6db3f3937/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=4c11822aebd9e9c3bbe798f14fa10ec6db3f3937", "patch": "@@ -1259,6 +1259,10 @@ a.tooltip:hover::after {\n \tbackground-color: var(--search-error-code-background-color);\n }\n \n+.search-corrections {\n+\tfont-weight: normal;\n+}\n+\n #src-sidebar-toggle {\n \tposition: sticky;\n \ttop: 0;"}, {"sha": "8b931f74e600a074b68621ba5291355236497839", "filename": "src/librustdoc/html/static/js/externs.js", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c11822aebd9e9c3bbe798f14fa10ec6db3f3937/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js", "raw_url": "https://github.com/rust-lang/rust/raw/4c11822aebd9e9c3bbe798f14fa10ec6db3f3937/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js?ref=4c11822aebd9e9c3bbe798f14fa10ec6db3f3937", "patch": "@@ -9,6 +9,7 @@ function initSearch(searchIndex){}\n /**\n  * @typedef {{\n  *     name: string,\n+ *     id: integer,\n  *     fullPath: Array<string>,\n  *     pathWithoutLast: Array<string>,\n  *     pathLast: string,\n@@ -36,6 +37,8 @@ let ParserState;\n  *     args: Array<QueryElement>,\n  *     returned: Array<QueryElement>,\n  *     foundElems: number,\n+ *     literalSearch: boolean,\n+ *     corrections: Array<{from: string, to: integer}>,\n  * }}\n  */\n let ParsedQuery;\n@@ -139,7 +142,7 @@ let FunctionSearchType;\n \n /**\n  * @typedef {{\n- *     name: (null|string),\n+ *     id: (null|number),\n  *     ty: (null|number),\n  *     generics: Array<FunctionType>,\n  * }}"}, {"sha": "2d0a3f0192bd09e0e99117bfa15c548340256224", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 219, "deletions": 195, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/4c11822aebd9e9c3bbe798f14fa10ec6db3f3937/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/4c11822aebd9e9c3bbe798f14fa10ec6db3f3937/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=4c11822aebd9e9c3bbe798f14fa10ec6db3f3937", "patch": "@@ -58,6 +58,7 @@ function printTab(nb) {\n         }\n         iter += 1;\n     });\n+    const isTypeSearch = (nb > 0 || iter === 1);\n     iter = 0;\n     onEachLazy(document.getElementById(\"results\").childNodes, elem => {\n         if (nb === iter) {\n@@ -70,6 +71,13 @@ function printTab(nb) {\n     });\n     if (foundCurrentTab && foundCurrentResultSet) {\n         searchState.currentTab = nb;\n+        // Corrections only kick in on type-based searches.\n+        const correctionsElem = document.getElementsByClassName(\"search-corrections\");\n+        if (isTypeSearch) {\n+            removeClass(correctionsElem[0], \"hidden\");\n+        } else {\n+            addClass(correctionsElem[0], \"hidden\");\n+        }\n     } else if (nb !== 0) {\n         printTab(0);\n     }\n@@ -191,6 +199,13 @@ function initSearch(rawSearchIndex) {\n      */\n     let searchIndex;\n     let currentResults;\n+    /**\n+     * Map from normalized type names to integers. Used to make type search\n+     * more efficient.\n+     *\n+     * @type {Map<string, integer>}\n+     */\n+    let typeNameIdMap;\n     const ALIASES = new Map();\n \n     function isWhitespace(c) {\n@@ -358,6 +373,7 @@ function initSearch(rawSearchIndex) {\n         parserState.typeFilter = null;\n         return {\n             name: name,\n+            id: -1,\n             fullPath: pathSegments,\n             pathWithoutLast: pathSegments.slice(0, pathSegments.length - 1),\n             pathLast: pathSegments[pathSegments.length - 1],\n@@ -718,6 +734,7 @@ function initSearch(rawSearchIndex) {\n             foundElems: 0,\n             literalSearch: false,\n             error: null,\n+            correction: null,\n         };\n     }\n \n@@ -1091,48 +1108,50 @@ function initSearch(rawSearchIndex) {\n          *\n          * @param {Row} row                 - The object to check.\n          * @param {QueryElement} elem       - The element from the parsed query.\n-         * @param {integer} defaultDistance - This is the value to return in case there are no\n-         *                                    generics.\n          *\n-         * @return {integer}           - Returns the best match (if any) or `maxEditDistance + 1`.\n+         * @return {boolean}           - Returns true if a match, false otherwise.\n          */\n-        function checkGenerics(row, elem, defaultDistance, maxEditDistance) {\n-            if (row.generics.length === 0) {\n-                return elem.generics.length === 0 ? defaultDistance : maxEditDistance + 1;\n-            } else if (row.generics.length > 0 && row.generics[0].name === null) {\n-                return checkGenerics(row.generics[0], elem, defaultDistance, maxEditDistance);\n-            }\n-            // The names match, but we need to be sure that all generics kinda\n-            // match as well.\n+        function checkGenerics(row, elem) {\n+            if (row.generics.length === 0 || elem.generics.length === 0) {\n+                return false;\n+            }\n+            // This function is called if the names match, but we need to make\n+            // sure that all generics match as well.\n+            //\n+            // This search engine implements order-agnostic unification. There\n+            // should be no missing duplicates (generics have \"bag semantics\"),\n+            // and the row is allowed to have extras.\n             if (elem.generics.length > 0 && row.generics.length >= elem.generics.length) {\n                 const elems = new Map();\n-                for (const entry of row.generics) {\n-                    if (entry.name === \"\") {\n+                const addEntryToElems = function addEntryToElems(entry) {\n+                    if (entry.id === -1) {\n                         // Pure generic, needs to check into it.\n-                        if (checkGenerics(entry, elem, maxEditDistance + 1, maxEditDistance)\n-                            !== 0) {\n-                            return maxEditDistance + 1;\n+                        for (const inner_entry of entry.generics) {\n+                            addEntryToElems(inner_entry);\n                         }\n-                        continue;\n+                        return;\n                     }\n                     let currentEntryElems;\n-                    if (elems.has(entry.name)) {\n-                        currentEntryElems = elems.get(entry.name);\n+                    if (elems.has(entry.id)) {\n+                        currentEntryElems = elems.get(entry.id);\n                     } else {\n                         currentEntryElems = [];\n-                        elems.set(entry.name, currentEntryElems);\n+                        elems.set(entry.id, currentEntryElems);\n                     }\n                     currentEntryElems.push(entry);\n+                };\n+                for (const entry of row.generics) {\n+                    addEntryToElems(entry);\n                 }\n                 // We need to find the type that matches the most to remove it in order\n                 // to move forward.\n                 const handleGeneric = generic => {\n-                    if (!elems.has(generic.name)) {\n+                    if (!elems.has(generic.id)) {\n                         return false;\n                     }\n-                    const matchElems = elems.get(generic.name);\n+                    const matchElems = elems.get(generic.id);\n                     const matchIdx = matchElems.findIndex(tmp_elem => {\n-                        if (checkGenerics(tmp_elem, generic, 0, maxEditDistance) !== 0) {\n+                        if (generic.generics.length > 0 && !checkGenerics(tmp_elem, generic)) {\n                             return false;\n                         }\n                         return typePassesFilter(generic.typeFilter, tmp_elem.ty);\n@@ -1142,7 +1161,7 @@ function initSearch(rawSearchIndex) {\n                     }\n                     matchElems.splice(matchIdx, 1);\n                     if (matchElems.length === 0) {\n-                        elems.delete(generic.name);\n+                        elems.delete(generic.id);\n                     }\n                     return true;\n                 };\n@@ -1152,17 +1171,17 @@ function initSearch(rawSearchIndex) {\n                 // own type.\n                 for (const generic of elem.generics) {\n                     if (generic.typeFilter !== -1 && !handleGeneric(generic)) {\n-                        return maxEditDistance + 1;\n+                        return false;\n                     }\n                 }\n                 for (const generic of elem.generics) {\n                     if (generic.typeFilter === -1 && !handleGeneric(generic)) {\n-                        return maxEditDistance + 1;\n+                        return false;\n                     }\n                 }\n-                return 0;\n+                return true;\n             }\n-            return maxEditDistance + 1;\n+            return false;\n         }\n \n         /**\n@@ -1172,17 +1191,15 @@ function initSearch(rawSearchIndex) {\n           * @param {Row} row\n           * @param {QueryElement} elem    - The element from the parsed query.\n           *\n-          * @return {integer} - Returns an edit distance to the best match.\n+          * @return {boolean} - Returns true if found, false otherwise.\n           */\n-        function checkIfInGenerics(row, elem, maxEditDistance) {\n-            let dist = maxEditDistance + 1;\n+        function checkIfInGenerics(row, elem) {\n             for (const entry of row.generics) {\n-                dist = Math.min(checkType(entry, elem, true, maxEditDistance), dist);\n-                if (dist === 0) {\n-                    break;\n+                if (checkType(entry, elem)) {\n+                    return true;\n                 }\n             }\n-            return dist;\n+            return false;\n         }\n \n         /**\n@@ -1191,162 +1208,82 @@ function initSearch(rawSearchIndex) {\n           *\n           * @param {Row} row\n           * @param {QueryElement} elem      - The element from the parsed query.\n-          * @param {boolean} literalSearch\n           *\n-          * @return {integer} - Returns an edit distance to the best match. If there is\n-          *                     no match, returns `maxEditDistance + 1`.\n+          * @return {boolean} - Returns true if the type matches, false otherwise.\n           */\n-        function checkType(row, elem, literalSearch, maxEditDistance) {\n-            if (row.name === null) {\n+        function checkType(row, elem) {\n+            if (row.id === -1) {\n                 // This is a pure \"generic\" search, no need to run other checks.\n-                if (row.generics.length > 0) {\n-                    return checkIfInGenerics(row, elem, maxEditDistance);\n-                }\n-                return maxEditDistance + 1;\n+                return row.generics.length > 0 ? checkIfInGenerics(row, elem) : false;\n             }\n \n-            let dist;\n-            if (typePassesFilter(elem.typeFilter, row.ty)) {\n-                dist = editDistance(row.name, elem.name, maxEditDistance);\n-            } else {\n-                dist = maxEditDistance + 1;\n-            }\n-            if (literalSearch) {\n-                if (dist !== 0) {\n-                    // The name didn't match, let's try to check if the generics do.\n-                    if (elem.generics.length === 0) {\n-                        const checkGeneric = row.generics.length > 0;\n-                        if (checkGeneric && row.generics\n-                            .findIndex(tmp_elem => tmp_elem.name === elem.name &&\n-                                typePassesFilter(elem.typeFilter, tmp_elem.ty)) !== -1) {\n-                            return 0;\n-                        }\n-                    }\n-                    return maxEditDistance + 1;\n-                } else if (elem.generics.length > 0) {\n-                    return checkGenerics(row, elem, maxEditDistance + 1, maxEditDistance);\n-                }\n-                return 0;\n-            } else if (row.generics.length > 0) {\n-                if (elem.generics.length === 0) {\n-                    if (dist === 0) {\n-                        return 0;\n-                    }\n-                    // The name didn't match so we now check if the type we're looking for is inside\n-                    // the generics!\n-                    dist = Math.min(dist, checkIfInGenerics(row, elem, maxEditDistance));\n-                    return dist;\n-                } else if (dist > maxEditDistance) {\n-                    // So our item's name doesn't match at all and has generics.\n-                    //\n-                    // Maybe it's present in a sub generic? For example \"f<A<B<C>>>()\", if we're\n-                    // looking for \"B<C>\", we'll need to go down.\n-                    return checkIfInGenerics(row, elem, maxEditDistance);\n-                } else {\n-                    // At this point, the name kinda match and we have generics to check, so\n-                    // let's go!\n-                    const tmp_dist = checkGenerics(row, elem, dist, maxEditDistance);\n-                    if (tmp_dist > maxEditDistance) {\n-                        return maxEditDistance + 1;\n-                    }\n-                    // We compute the median value of both checks and return it.\n-                    return (tmp_dist + dist) / 2;\n+            if (row.id === elem.id && typePassesFilter(elem.typeFilter, row.ty)) {\n+                if (elem.generics.length > 0) {\n+                    return checkGenerics(row, elem);\n                 }\n-            } else if (elem.generics.length > 0) {\n-                // In this case, we were expecting generics but there isn't so we simply reject this\n-                // one.\n-                return maxEditDistance + 1;\n+                return true;\n+            }\n+\n+            // If the current item does not match, try [unboxing] the generic.\n+            // [unboxing]:\n+            //   https://ndmitchell.com/downloads/slides-hoogle_fast_type_searching-09_aug_2008.pdf\n+            if (checkIfInGenerics(row, elem)) {\n+                return true;\n             }\n-            // No generics on our query or on the target type so we can return without doing\n-            // anything else.\n-            return dist;\n+\n+            return false;\n         }\n \n         /**\n          * This function checks if the object (`row`) has an argument with the given type (`elem`).\n          *\n          * @param {Row} row\n          * @param {QueryElement} elem    - The element from the parsed query.\n-         * @param {integer} maxEditDistance\n          * @param {Array<integer>} skipPositions - Do not return one of these positions.\n          *\n-         * @return {dist: integer, position: integer} - Returns an edit distance to the best match.\n-         *                                              If there is no match, returns\n-         *                                              `maxEditDistance + 1` and position: -1.\n+         * @return {integer} - Returns the position of the match, or -1 if none.\n          */\n-        function findArg(row, elem, maxEditDistance, skipPositions) {\n-            let dist = maxEditDistance + 1;\n-            let position = -1;\n-\n+        function findArg(row, elem, skipPositions) {\n             if (row && row.type && row.type.inputs && row.type.inputs.length > 0) {\n                 let i = 0;\n                 for (const input of row.type.inputs) {\n                     if (skipPositions.indexOf(i) !== -1) {\n                         i += 1;\n                         continue;\n                     }\n-                    const typeDist = checkType(\n-                        input,\n-                        elem,\n-                        parsedQuery.literalSearch,\n-                        maxEditDistance\n-                    );\n-                    if (typeDist === 0) {\n-                        return {dist: 0, position: i};\n-                    }\n-                    if (typeDist < dist) {\n-                        dist = typeDist;\n-                        position = i;\n+                    if (checkType(input, elem)) {\n+                        return i;\n                     }\n                     i += 1;\n                 }\n             }\n-            dist = parsedQuery.literalSearch ? maxEditDistance + 1 : dist;\n-            return {dist, position};\n+            return -1;\n         }\n \n         /**\n          * This function checks if the object (`row`) returns the given type (`elem`).\n          *\n          * @param {Row} row\n          * @param {QueryElement} elem   - The element from the parsed query.\n-         * @param {integer} maxEditDistance\n          * @param {Array<integer>} skipPositions - Do not return one of these positions.\n          *\n-         * @return {dist: integer, position: integer} - Returns an edit distance to the best match.\n-         *                                              If there is no match, returns\n-         *                                              `maxEditDistance + 1` and position: -1.\n+         * @return {integer} - Returns the position of the matching item, or -1 if none.\n          */\n-        function checkReturned(row, elem, maxEditDistance, skipPositions) {\n-            let dist = maxEditDistance + 1;\n-            let position = -1;\n-\n+        function checkReturned(row, elem, skipPositions) {\n             if (row && row.type && row.type.output.length > 0) {\n-                const ret = row.type.output;\n                 let i = 0;\n-                for (const ret_ty of ret) {\n+                for (const ret_ty of row.type.output) {\n                     if (skipPositions.indexOf(i) !== -1) {\n                         i += 1;\n                         continue;\n                     }\n-                    const typeDist = checkType(\n-                        ret_ty,\n-                        elem,\n-                        parsedQuery.literalSearch,\n-                        maxEditDistance\n-                    );\n-                    if (typeDist === 0) {\n-                        return {dist: 0, position: i};\n-                    }\n-                    if (typeDist < dist) {\n-                        dist = typeDist;\n-                        position = i;\n+                    if (checkType(ret_ty, elem)) {\n+                        return i;\n                     }\n                     i += 1;\n                 }\n             }\n-            dist = parsedQuery.literalSearch ? maxEditDistance + 1 : dist;\n-            return {dist, position};\n+            return -1;\n         }\n \n         function checkPath(contains, ty, maxEditDistance) {\n@@ -1543,17 +1480,20 @@ function initSearch(rawSearchIndex) {\n             if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n                 return;\n             }\n-            let dist, index = -1, path_dist = 0;\n+            let index = -1, path_dist = 0;\n             const fullId = row.id;\n             const searchWord = searchWords[pos];\n \n-            const in_args = findArg(row, elem, maxEditDistance, []);\n-            const returned = checkReturned(row, elem, maxEditDistance, []);\n-\n-            // path_dist is 0 because no parent path information is currently stored\n-            // in the search index\n-            addIntoResults(results_in_args, fullId, pos, -1, in_args.dist, 0, maxEditDistance);\n-            addIntoResults(results_returned, fullId, pos, -1, returned.dist, 0, maxEditDistance);\n+            const in_args = findArg(row, elem, []);\n+            if (in_args !== -1) {\n+                // path_dist is 0 because no parent path information is currently stored\n+                // in the search index\n+                addIntoResults(results_in_args, fullId, pos, -1, 0, 0, maxEditDistance);\n+            }\n+            const returned = checkReturned(row, elem, []);\n+            if (returned !== -1) {\n+                addIntoResults(results_returned, fullId, pos, -1, 0, 0, maxEditDistance);\n+            }\n \n             if (!typePassesFilter(elem.typeFilter, row.ty)) {\n                 return;\n@@ -1574,16 +1514,6 @@ function initSearch(rawSearchIndex) {\n                 index = row_index;\n             }\n \n-            // No need to check anything else if it's a \"pure\" generics search.\n-            if (elem.name.length === 0) {\n-                if (row.type !== null) {\n-                    dist = checkGenerics(row.type, elem, maxEditDistance + 1, maxEditDistance);\n-                    // path_dist is 0 because we know it's empty\n-                    addIntoResults(results_others, fullId, pos, index, dist, 0, maxEditDistance);\n-                }\n-                return;\n-            }\n-\n             if (elem.fullPath.length > 1) {\n                 path_dist = checkPath(elem.pathWithoutLast, row, maxEditDistance);\n                 if (path_dist > maxEditDistance) {\n@@ -1598,7 +1528,7 @@ function initSearch(rawSearchIndex) {\n                 return;\n             }\n \n-            dist = editDistance(searchWord, elem.pathLast, maxEditDistance);\n+            const dist = editDistance(searchWord, elem.pathLast, maxEditDistance);\n \n             if (index === -1 && dist + path_dist > maxEditDistance) {\n                 return;\n@@ -1616,28 +1546,22 @@ function initSearch(rawSearchIndex) {\n          * @param {integer} pos      - Position in the `searchIndex`.\n          * @param {Object} results\n          */\n-        function handleArgs(row, pos, results, maxEditDistance) {\n+        function handleArgs(row, pos, results) {\n             if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n                 return;\n             }\n \n-            let totalDist = 0;\n-            let nbDist = 0;\n-\n             // If the result is too \"bad\", we return false and it ends this search.\n             function checkArgs(elems, callback) {\n                 const skipPositions = [];\n                 for (const elem of elems) {\n                     // There is more than one parameter to the query so all checks should be \"exact\"\n-                    const { dist, position } = callback(\n+                    const position = callback(\n                         row,\n                         elem,\n-                        maxEditDistance,\n                         skipPositions\n                     );\n-                    if (dist <= 1) {\n-                        nbDist += 1;\n-                        totalDist += dist;\n+                    if (position !== -1) {\n                         skipPositions.push(position);\n                     } else {\n                         return false;\n@@ -1652,11 +1576,7 @@ function initSearch(rawSearchIndex) {\n                 return;\n             }\n \n-            if (nbDist === 0) {\n-                return;\n-            }\n-            const dist = Math.round(totalDist / nbDist);\n-            addIntoResults(results, row.id, pos, 0, dist, 0, maxEditDistance);\n+            addIntoResults(results, row.id, pos, 0, 0, 0, Number.MAX_VALUE);\n         }\n \n         function innerRunQuery() {\n@@ -1671,6 +1591,50 @@ function initSearch(rawSearchIndex) {\n             }\n             const maxEditDistance = Math.floor(queryLen / 3);\n \n+            /**\n+             * Convert names to ids in parsed query elements.\n+             * This is not used for the \"In Names\" tab, but is used for the\n+             * \"In Params\", \"In Returns\", and \"In Function Signature\" tabs.\n+             *\n+             * If there is no matching item, but a close-enough match, this\n+             * function also that correction.\n+             *\n+             * See `buildTypeMapIndex` for more information.\n+             *\n+             * @param {QueryElement} elem\n+             */\n+            function convertNameToId(elem) {\n+                if (typeNameIdMap.has(elem.name)) {\n+                    elem.id = typeNameIdMap.get(elem.name);\n+                } else if (!parsedQuery.literalSearch) {\n+                    let match = -1;\n+                    let matchDist = maxEditDistance + 1;\n+                    let matchName = \"\";\n+                    for (const [name, id] of typeNameIdMap) {\n+                        const dist = editDistance(name, elem.name, maxEditDistance);\n+                        if (dist <= matchDist && dist <= maxEditDistance) {\n+                            match = id;\n+                            matchDist = dist;\n+                            matchName = name;\n+                        }\n+                    }\n+                    if (match !== -1) {\n+                        parsedQuery.correction = matchName;\n+                    }\n+                    elem.id = match;\n+                }\n+                for (const elem2 of elem.generics) {\n+                    convertNameToId(elem2);\n+                }\n+            }\n+\n+            for (const elem of parsedQuery.elems) {\n+                convertNameToId(elem);\n+            }\n+            for (const elem of parsedQuery.returned) {\n+                convertNameToId(elem);\n+            }\n+\n             if (parsedQuery.foundElems === 1) {\n                 if (parsedQuery.elems.length === 1) {\n                     elem = parsedQuery.elems[0];\n@@ -1695,22 +1659,23 @@ function initSearch(rawSearchIndex) {\n                         in_returned = checkReturned(\n                             row,\n                             elem,\n-                            maxEditDistance,\n                             []\n                         );\n-                        addIntoResults(\n-                            results_others,\n-                            row.id,\n-                            i,\n-                            -1,\n-                            in_returned.dist,\n-                            maxEditDistance\n-                        );\n+                        if (in_returned !== -1) {\n+                            addIntoResults(\n+                                results_others,\n+                                row.id,\n+                                i,\n+                                -1,\n+                                0,\n+                                Number.MAX_VALUE\n+                            );\n+                        }\n                     }\n                 }\n             } else if (parsedQuery.foundElems > 0) {\n                 for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n-                    handleArgs(searchIndex[i], i, results_others, maxEditDistance);\n+                    handleArgs(searchIndex[i], i, results_others);\n                 }\n             }\n         }\n@@ -2030,6 +1995,11 @@ function initSearch(rawSearchIndex) {\n             currentTab = 0;\n         }\n \n+        if (results.query.correction !== null) {\n+            output += \"<h3 class=\\\"search-corrections\\\">Showing results for \" +\n+                `\"${results.query.correction}\".</h3>`;\n+        }\n+\n         const resultsElem = document.createElement(\"div\");\n         resultsElem.id = \"results\";\n         resultsElem.appendChild(ret_others[0]);\n@@ -2108,6 +2078,34 @@ function initSearch(rawSearchIndex) {\n             filterCrates);\n     }\n \n+    /**\n+     * Add an item to the type Name->ID map, or, if one already exists, use it.\n+     * Returns the number. If name is \"\" or null, return -1 (pure generic).\n+     *\n+     * This is effectively string interning, so that function matching can be\n+     * done more quickly. Two types with the same name but different item kinds\n+     * get the same ID.\n+     *\n+     * @param {Map<string, integer>} typeNameIdMap\n+     * @param {string} name\n+     *\n+     * @returns {integer}\n+     */\n+    function buildTypeMapIndex(typeNameIdMap, name) {\n+\n+        if (name === \"\" || name === null) {\n+            return -1;\n+        }\n+\n+        if (typeNameIdMap.has(name)) {\n+            return typeNameIdMap.get(name);\n+        } else {\n+            const id = typeNameIdMap.size;\n+            typeNameIdMap.set(name, id);\n+            return id;\n+        }\n+    }\n+\n     /**\n      * Convert a list of RawFunctionType / ID to object-based FunctionType.\n      *\n@@ -2126,7 +2124,7 @@ function initSearch(rawSearchIndex) {\n      *\n      * @return {Array<FunctionSearchType>}\n      */\n-    function buildItemSearchTypeAll(types, lowercasePaths) {\n+    function buildItemSearchTypeAll(types, lowercasePaths, typeNameIdMap) {\n         const PATH_INDEX_DATA = 0;\n         const GENERICS_DATA = 1;\n         return types.map(type => {\n@@ -2136,11 +2134,17 @@ function initSearch(rawSearchIndex) {\n                 generics = [];\n             } else {\n                 pathIndex = type[PATH_INDEX_DATA];\n-                generics = buildItemSearchTypeAll(type[GENERICS_DATA], lowercasePaths);\n+                generics = buildItemSearchTypeAll(\n+                    type[GENERICS_DATA],\n+                    lowercasePaths,\n+                    typeNameIdMap\n+                );\n             }\n             return {\n                 // `0` is used as a sentinel because it's fewer bytes than `null`\n-                name: pathIndex === 0 ? null : lowercasePaths[pathIndex - 1].name,\n+                id: pathIndex === 0\n+                    ? -1\n+                    : buildTypeMapIndex(typeNameIdMap, lowercasePaths[pathIndex - 1].name),\n                 ty: pathIndex === 0 ? null : lowercasePaths[pathIndex - 1].ty,\n                 generics: generics,\n             };\n@@ -2159,10 +2163,11 @@ function initSearch(rawSearchIndex) {\n      *\n      * @param {RawFunctionSearchType} functionSearchType\n      * @param {Array<{name: string, ty: number}>} lowercasePaths\n+     * @param {Map<string, integer>}\n      *\n      * @return {null|FunctionSearchType}\n      */\n-    function buildFunctionSearchType(functionSearchType, lowercasePaths) {\n+    function buildFunctionSearchType(functionSearchType, lowercasePaths, typeNameIdMap) {\n         const INPUTS_DATA = 0;\n         const OUTPUT_DATA = 1;\n         // `0` is used as a sentinel because it's fewer bytes than `null`\n@@ -2173,23 +2178,35 @@ function initSearch(rawSearchIndex) {\n         if (typeof functionSearchType[INPUTS_DATA] === \"number\") {\n             const pathIndex = functionSearchType[INPUTS_DATA];\n             inputs = [{\n-                name: pathIndex === 0 ? null : lowercasePaths[pathIndex - 1].name,\n+                id: pathIndex === 0\n+                    ? -1\n+                    : buildTypeMapIndex(typeNameIdMap, lowercasePaths[pathIndex - 1].name),\n                 ty: pathIndex === 0 ? null : lowercasePaths[pathIndex - 1].ty,\n                 generics: [],\n             }];\n         } else {\n-            inputs = buildItemSearchTypeAll(functionSearchType[INPUTS_DATA], lowercasePaths);\n+            inputs = buildItemSearchTypeAll(\n+                functionSearchType[INPUTS_DATA],\n+                lowercasePaths,\n+                typeNameIdMap\n+            );\n         }\n         if (functionSearchType.length > 1) {\n             if (typeof functionSearchType[OUTPUT_DATA] === \"number\") {\n                 const pathIndex = functionSearchType[OUTPUT_DATA];\n                 output = [{\n-                    name: pathIndex === 0 ? null : lowercasePaths[pathIndex - 1].name,\n+                    id: pathIndex === 0\n+                        ? -1\n+                        : buildTypeMapIndex(typeNameIdMap, lowercasePaths[pathIndex - 1].name),\n                     ty: pathIndex === 0 ? null : lowercasePaths[pathIndex - 1].ty,\n                     generics: [],\n                 }];\n             } else {\n-                output = buildItemSearchTypeAll(functionSearchType[OUTPUT_DATA], lowercasePaths);\n+                output = buildItemSearchTypeAll(\n+                    functionSearchType[OUTPUT_DATA],\n+                    lowercasePaths,\n+                    typeNameIdMap\n+                );\n             }\n         } else {\n             output = [];\n@@ -2202,9 +2219,12 @@ function initSearch(rawSearchIndex) {\n     function buildIndex(rawSearchIndex) {\n         searchIndex = [];\n         /**\n+         * List of normalized search words (ASCII lowercased, and undescores removed).\n+         *\n          * @type {Array<string>}\n          */\n         const searchWords = [];\n+        typeNameIdMap = new Map();\n         const charA = \"A\".charCodeAt(0);\n         let currentIndex = 0;\n         let id = 0;\n@@ -2337,7 +2357,11 @@ function initSearch(rawSearchIndex) {\n                     path: itemPaths.has(i) ? itemPaths.get(i) : lastPath,\n                     desc: itemDescs[i],\n                     parent: itemParentIdxs[i] > 0 ? paths[itemParentIdxs[i] - 1] : undefined,\n-                    type: buildFunctionSearchType(itemFunctionSearchTypes[i], lowercasePaths),\n+                    type: buildFunctionSearchType(\n+                        itemFunctionSearchTypes[i],\n+                        lowercasePaths,\n+                        typeNameIdMap\n+                    ),\n                     id: id,\n                     normalizedName: word.indexOf(\"_\") === -1 ? word : word.replace(/_/g, \"\"),\n                     deprecated: deprecatedItems.has(i),"}, {"sha": "270704ebffde61aa858ec1a61c29fd7f5db5697d", "filename": "src/tools/rustdoc-js/tester.js", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4c11822aebd9e9c3bbe798f14fa10ec6db3f3937/src%2Ftools%2Frustdoc-js%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/4c11822aebd9e9c3bbe798f14fa10ec6db3f3937/src%2Ftools%2Frustdoc-js%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-js%2Ftester.js?ref=4c11822aebd9e9c3bbe798f14fa10ec6db3f3937", "patch": "@@ -226,6 +226,24 @@ function runSearch(query, expected, doSearch, loadedFile, queryName) {\n     return error_text;\n }\n \n+function runCorrections(query, corrections, getCorrections, loadedFile) {\n+    const qc = getCorrections(query, loadedFile.FILTER_CRATE);\n+    const error_text = [];\n+\n+    if (corrections === null) {\n+        if (qc !== null) {\n+            error_text.push(`==> expected = null, found = ${qc}`);\n+        }\n+        return error_text;\n+    }\n+\n+    if (qc !== corrections.toLowerCase()) {\n+        error_text.push(`==> expected = ${corrections}, found = ${qc}`);\n+    }\n+\n+    return error_text;\n+}\n+\n function checkResult(error_text, loadedFile, displaySuccess) {\n     if (error_text.length === 0 && loadedFile.should_fail === true) {\n         console.log(\"FAILED\");\n@@ -272,9 +290,10 @@ function runCheck(loadedFile, key, callback) {\n     return 0;\n }\n \n-function runChecks(testFile, doSearch, parseQuery) {\n+function runChecks(testFile, doSearch, parseQuery, getCorrections) {\n     let checkExpected = false;\n     let checkParsed = false;\n+    let checkCorrections = false;\n     let testFileContent = readFile(testFile) + \"exports.QUERY = QUERY;\";\n \n     if (testFileContent.indexOf(\"FILTER_CRATE\") !== -1) {\n@@ -291,9 +310,13 @@ function runChecks(testFile, doSearch, parseQuery) {\n         testFileContent += \"exports.PARSED = PARSED;\";\n         checkParsed = true;\n     }\n-    if (!checkParsed && !checkExpected) {\n+    if (testFileContent.indexOf(\"\\nconst CORRECTIONS\") !== -1) {\n+        testFileContent += \"exports.CORRECTIONS = CORRECTIONS;\";\n+        checkCorrections = true;\n+    }\n+    if (!checkParsed && !checkExpected && !checkCorrections) {\n         console.log(\"FAILED\");\n-        console.log(\"==> At least `PARSED` or `EXPECTED` is needed!\");\n+        console.log(\"==> At least `PARSED`, `EXPECTED`, or `CORRECTIONS` is needed!\");\n         return 1;\n     }\n \n@@ -310,6 +333,11 @@ function runChecks(testFile, doSearch, parseQuery) {\n             return runParser(query, expected, parseQuery, text);\n         });\n     }\n+    if (checkCorrections) {\n+        res += runCheck(loadedFile, \"CORRECTIONS\", (query, expected) => {\n+            return runCorrections(query, expected, getCorrections, loadedFile);\n+        });\n+    }\n     return res;\n }\n \n@@ -318,9 +346,10 @@ function runChecks(testFile, doSearch, parseQuery) {\n  *\n  * @param {string} doc_folder      - Path to a folder generated by running rustdoc\n  * @param {string} resource_suffix - Version number between filename and .js, e.g. \"1.59.0\"\n- * @returns {Object}               - Object containing two keys: `doSearch`, which runs a search\n- *   with the loaded index and returns a table of results; and `parseQuery`, which is the\n- *   `parseQuery` function exported from the search module.\n+ * @returns {Object}               - Object containing keys: `doSearch`, which runs a search\n+ *   with the loaded index and returns a table of results; `parseQuery`, which is the\n+ *   `parseQuery` function exported from the search module; and `getCorrections`, which runs\n+ *   a search but returns type name corrections instead of results.\n  */\n function loadSearchJS(doc_folder, resource_suffix) {\n     const searchIndexJs = path.join(doc_folder, \"search-index\" + resource_suffix + \".js\");\n@@ -336,6 +365,12 @@ function loadSearchJS(doc_folder, resource_suffix) {\n             return searchModule.execQuery(searchModule.parseQuery(queryStr), searchWords,\n                 filterCrate, currentCrate);\n         },\n+        getCorrections: function(queryStr, filterCrate, currentCrate) {\n+            const parsedQuery = searchModule.parseQuery(queryStr);\n+            searchModule.execQuery(parsedQuery, searchWords,\n+                filterCrate, currentCrate);\n+            return parsedQuery.correction;\n+        },\n         parseQuery: searchModule.parseQuery,\n     };\n }\n@@ -417,11 +452,14 @@ function main(argv) {\n     const doSearch = function(queryStr, filterCrate) {\n         return parseAndSearch.doSearch(queryStr, filterCrate, opts[\"crate_name\"]);\n     };\n+    const getCorrections = function(queryStr, filterCrate) {\n+        return parseAndSearch.getCorrections(queryStr, filterCrate, opts[\"crate_name\"]);\n+    };\n \n     if (opts[\"test_file\"].length !== 0) {\n         opts[\"test_file\"].forEach(file => {\n             process.stdout.write(`Testing ${file} ... `);\n-            errors += runChecks(file, doSearch, parseAndSearch.parseQuery);\n+            errors += runChecks(file, doSearch, parseAndSearch.parseQuery, getCorrections);\n         });\n     } else if (opts[\"test_folder\"].length !== 0) {\n         fs.readdirSync(opts[\"test_folder\"]).forEach(file => {\n@@ -430,7 +468,7 @@ function main(argv) {\n             }\n             process.stdout.write(`Testing ${file} ... `);\n             errors += runChecks(path.join(opts[\"test_folder\"], file), doSearch,\n-                    parseAndSearch.parseQuery);\n+                    parseAndSearch.parseQuery, getCorrections);\n         });\n     }\n     return errors > 0 ? 1 : 0;"}, {"sha": "832aa15305468c1d0d1b75245f6eddf0ebae9d1f", "filename": "tests/rustdoc-gui/search-corrections.goml", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4c11822aebd9e9c3bbe798f14fa10ec6db3f3937/tests%2Frustdoc-gui%2Fsearch-corrections.goml", "raw_url": "https://github.com/rust-lang/rust/raw/4c11822aebd9e9c3bbe798f14fa10ec6db3f3937/tests%2Frustdoc-gui%2Fsearch-corrections.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsearch-corrections.goml?ref=4c11822aebd9e9c3bbe798f14fa10ec6db3f3937", "patch": "@@ -0,0 +1,54 @@\n+// Checks that the search tab result tell the user about corrections\n+// First, try a search-by-name\n+go-to: \"file://\" + |DOC_PATH| + \"/test_docs/index.html\"\n+// Intentionally wrong spelling of \"NotableStructWithLongName\"\n+write: (\".search-input\", \"NotableStructWithLongNamr\")\n+// To be SURE that the search will be run.\n+press-key: 'Enter'\n+// Waiting for the search results to appear...\n+wait-for: \"#search-tabs\"\n+\n+// Corrections aren't shown on the \"In Names\" tab.\n+assert: \"#search-tabs button.selected:first-child\"\n+assert-css: (\".search-corrections\", {\n+    \"display\": \"none\"\n+})\n+\n+// Corrections do get shown on the \"In Parameters\" tab.\n+click: \"#search-tabs button:nth-child(2)\"\n+assert: \"#search-tabs button.selected:nth-child(2)\"\n+assert-css: (\".search-corrections\", {\n+    \"display\": \"block\"\n+})\n+assert-text: (\n+    \".search-corrections\",\n+    \"Showing results for \\\"notablestructwithlongname\\\".\"\n+)\n+\n+// Corrections do get shown on the \"In Return Type\" tab.\n+click: \"#search-tabs button:nth-child(3)\"\n+assert: \"#search-tabs button.selected:nth-child(3)\"\n+assert-css: (\".search-corrections\", {\n+    \"display\": \"block\"\n+})\n+assert-text: (\n+    \".search-corrections\",\n+    \"Showing results for \\\"notablestructwithlongname\\\".\"\n+)\n+\n+// Now, explicit return values\n+go-to: \"file://\" + |DOC_PATH| + \"/test_docs/index.html\"\n+// Intentionally wrong spelling of \"NotableStructWithLongName\"\n+write: (\".search-input\", \"-> NotableStructWithLongNamr\")\n+// To be SURE that the search will be run.\n+press-key: 'Enter'\n+// Waiting for the search results to appear...\n+wait-for: \"#search-tabs\"\n+\n+assert-css: (\".search-corrections\", {\n+    \"display\": \"block\"\n+})\n+assert-text: (\n+    \".search-corrections\",\n+    \"Showing results for \\\"notablestructwithlongname\\\".\"\n+)"}, {"sha": "0e84751603ed678700865f542cae255690b55162", "filename": "tests/rustdoc-js/generics-trait.js", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4c11822aebd9e9c3bbe798f14fa10ec6db3f3937/tests%2Frustdoc-js%2Fgenerics-trait.js", "raw_url": "https://github.com/rust-lang/rust/raw/4c11822aebd9e9c3bbe798f14fa10ec6db3f3937/tests%2Frustdoc-js%2Fgenerics-trait.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fgenerics-trait.js?ref=4c11822aebd9e9c3bbe798f14fa10ec6db3f3937", "patch": "@@ -1,9 +1,21 @@\n+// exact-check\n+\n const QUERY = [\n     'Result<SomeTrait>',\n+    'Result<SomeTraiz>',\n+    'OtherThingxxxxxxxx',\n+    'OtherThingxxxxxxxy',\n+];\n+\n+const CORRECTIONS = [\n+    null,\n+    null,\n+    null,\n     'OtherThingxxxxxxxx',\n ];\n \n const EXPECTED = [\n+    // Result<SomeTrait>\n     {\n         'in_args': [\n             { 'path': 'generics_trait', 'name': 'beta' },\n@@ -12,6 +24,21 @@ const EXPECTED = [\n             { 'path': 'generics_trait', 'name': 'bet' },\n         ],\n     },\n+    // Result<SomeTraiz>\n+    {\n+        'in_args': [],\n+        'returned': [],\n+    },\n+    // OtherThingxxxxxxxx\n+    {\n+        'in_args': [\n+            { 'path': 'generics_trait', 'name': 'alpha' },\n+        ],\n+        'returned': [\n+            { 'path': 'generics_trait', 'name': 'alef' },\n+        ],\n+    },\n+    // OtherThingxxxxxxxy\n     {\n         'in_args': [\n             { 'path': 'generics_trait', 'name': 'alpha' },"}]}