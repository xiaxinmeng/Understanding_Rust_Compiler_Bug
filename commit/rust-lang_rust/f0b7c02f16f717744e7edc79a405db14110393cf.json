{"sha": "f0b7c02f16f717744e7edc79a405db14110393cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwYjdjMDJmMTZmNzE3NzQ0ZTdlZGM3OWE0MDVkYjE0MTEwMzkzY2Y=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-07T00:32:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-07T00:32:56Z"}, "message": "Merge #7892\n\n7892: Fix TokenStream::from_str for input consisting of a single group with delimiter r=edwin0cheng a=kevinmehall\n\nTokenStream holds a `tt::Subtree` but assumes its `delimiter` is always `None`. In particular, the iterator implementation iterates over the inner `token_trees` and ignores the `delimiter`.\r\n\r\nHowever, `TokenStream::from_str` violated this assumption when the input consists of a single group by producing a Subtree with an outer delimiter, which was ignored as seen by a procedural macro.\r\n\r\n`tt::Subtree` is just `pub delimiter: Option<Delimiter>, pub token_trees: Vec<TokenTree>`, so a Subtree that is statically guaranteed not to have a delimiter is just `Vec<TokenTree>`.\r\n\r\nFixes #7810\r\nFixes #7875\n\nCo-authored-by: Kevin Mehall <km@kevinmehall.net>", "tree": {"sha": "c0aaf8373aa42ce3b4037fad2f42efba07680f53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0aaf8373aa42ce3b4037fad2f42efba07680f53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0b7c02f16f717744e7edc79a405db14110393cf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgRB84CRBK7hj4Ov3rIwAAdHIIAAuAHIGCJ9qCtAvhuaSsDzvi\n2qiRBE0zuiCK7e8gSHn6+Y8o9tt5oWhmIJVfCgt8+MWWqqhm/oAGAkxf3mG6cehq\nJzO/8H+OQPqgL+XSSITevEtWpb7FtnkHtxVvyDD44ySGORRB4uaTZ9+Bo3tS7N5w\n1oOpRcJ9Srcgx59WYWR33Tx7lfCuEnegjTyMbMSemQjWsTYWk1mUZK1xhGx2lRpp\nOHRLMRV++K84Qg4GnYdY1iqjKy6hOcYl1M9E4nFLQwlQPP/JWOnV44pGZsHRHwiC\nIMtqXCwTIB4DGXrARaKgb7w0ZUNKC9nsUIRSEzOpL+8W5UQHBlESUZzh/szcKQ4=\n=71tr\n-----END PGP SIGNATURE-----\n", "payload": "tree c0aaf8373aa42ce3b4037fad2f42efba07680f53\nparent 07a54f7ae451451292e3282f1e7defb4391b766f\nparent aea974939064b0f7b83de371a93ee4190c80e544\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615077176 +0000\ncommitter GitHub <noreply@github.com> 1615077176 +0000\n\nMerge #7892\n\n7892: Fix TokenStream::from_str for input consisting of a single group with delimiter r=edwin0cheng a=kevinmehall\n\nTokenStream holds a `tt::Subtree` but assumes its `delimiter` is always `None`. In particular, the iterator implementation iterates over the inner `token_trees` and ignores the `delimiter`.\r\n\r\nHowever, `TokenStream::from_str` violated this assumption when the input consists of a single group by producing a Subtree with an outer delimiter, which was ignored as seen by a procedural macro.\r\n\r\n`tt::Subtree` is just `pub delimiter: Option<Delimiter>, pub token_trees: Vec<TokenTree>`, so a Subtree that is statically guaranteed not to have a delimiter is just `Vec<TokenTree>`.\r\n\r\nFixes #7810\r\nFixes #7875\n\nCo-authored-by: Kevin Mehall <km@kevinmehall.net>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0b7c02f16f717744e7edc79a405db14110393cf", "html_url": "https://github.com/rust-lang/rust/commit/f0b7c02f16f717744e7edc79a405db14110393cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0b7c02f16f717744e7edc79a405db14110393cf/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07a54f7ae451451292e3282f1e7defb4391b766f", "url": "https://api.github.com/repos/rust-lang/rust/commits/07a54f7ae451451292e3282f1e7defb4391b766f", "html_url": "https://github.com/rust-lang/rust/commit/07a54f7ae451451292e3282f1e7defb4391b766f"}, {"sha": "aea974939064b0f7b83de371a93ee4190c80e544", "url": "https://api.github.com/repos/rust-lang/rust/commits/aea974939064b0f7b83de371a93ee4190c80e544", "html_url": "https://github.com/rust-lang/rust/commit/aea974939064b0f7b83de371a93ee4190c80e544"}], "stats": {"total": 151, "additions": 89, "deletions": 62}, "files": [{"sha": "baf10fea9376166273ef0e6248b07b971cf81dca", "filename": "crates/proc_macro_srv/src/dylib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0b7c02f16f717744e7edc79a405db14110393cf/crates%2Fproc_macro_srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b7c02f16f717744e7edc79a405db14110393cf/crates%2Fproc_macro_srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fdylib.rs?ref=f0b7c02f16f717744e7edc79a405db14110393cf", "patch": "@@ -138,7 +138,7 @@ impl Expander {\n                         parsed_body,\n                         false,\n                     );\n-                    return res.map(|it| it.subtree);\n+                    return res.map(|it| it.into_subtree());\n                 }\n                 bridge::client::ProcMacro::Bang { name, client } if *name == macro_name => {\n                     let res = client.run(\n@@ -147,7 +147,7 @@ impl Expander {\n                         parsed_body,\n                         false,\n                     );\n-                    return res.map(|it| it.subtree);\n+                    return res.map(|it| it.into_subtree());\n                 }\n                 bridge::client::ProcMacro::Attr { name, client } if *name == macro_name => {\n                     let res = client.run(\n@@ -157,7 +157,7 @@ impl Expander {\n                         parsed_body,\n                         false,\n                     );\n-                    return res.map(|it| it.subtree);\n+                    return res.map(|it| it.into_subtree());\n                 }\n                 _ => continue,\n             }"}, {"sha": "b036d4e2016cf5fede32d3278d02cc0013deb98a", "filename": "crates/proc_macro_srv/src/proc_macro/bridge/client.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0b7c02f16f717744e7edc79a405db14110393cf/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b7c02f16f717744e7edc79a405db14110393cf/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclient.rs?ref=f0b7c02f16f717744e7edc79a405db14110393cf", "patch": "@@ -238,7 +238,7 @@ macro_rules! define_client_side {\n         $(impl $name {\n             #[allow(unused)]\n             $(pub(crate) fn $method($($arg: $arg_ty),*) $(-> $ret_ty)* {\n-                panic!(\"hello\");\n+                panic!(\"crates should be linked against the sysroot version of proc_macro, not this one from rust-analyzer\");\n                 // Bridge::with(|bridge| {\n                 //     let mut b = bridge.cached_buffer.take();\n "}, {"sha": "ceefd187d257f2e0c1f156a57a6082801b161125", "filename": "crates/proc_macro_srv/src/rustc_server.rs", "status": "modified", "additions": 84, "deletions": 57, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/f0b7c02f16f717744e7edc79a405db14110393cf/crates%2Fproc_macro_srv%2Fsrc%2Frustc_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b7c02f16f717744e7edc79a405db14110393cf/crates%2Fproc_macro_srv%2Fsrc%2Frustc_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Frustc_server.rs?ref=f0b7c02f16f717744e7edc79a405db14110393cf", "patch": "@@ -25,27 +25,35 @@ type Span = tt::TokenId;\n \n #[derive(Debug, Clone)]\n pub struct TokenStream {\n-    pub subtree: tt::Subtree,\n+    pub token_trees: Vec<TokenTree>,\n }\n \n impl TokenStream {\n     pub fn new() -> Self {\n-        TokenStream { subtree: Default::default() }\n+        TokenStream { token_trees: Default::default() }\n     }\n \n     pub fn with_subtree(subtree: tt::Subtree) -> Self {\n-        TokenStream { subtree }\n+        if subtree.delimiter.is_some() {\n+            TokenStream { token_trees: vec![TokenTree::Subtree(subtree)] }\n+        } else {\n+            TokenStream { token_trees: subtree.token_trees }\n+        }\n+    }\n+\n+    pub fn into_subtree(self) -> tt::Subtree {\n+        tt::Subtree { delimiter: None, token_trees: self.token_trees }\n     }\n \n     pub fn is_empty(&self) -> bool {\n-        self.subtree.token_trees.is_empty()\n+        self.token_trees.is_empty()\n     }\n }\n \n /// Creates a token stream containing a single token tree.\n impl From<TokenTree> for TokenStream {\n     fn from(tree: TokenTree) -> TokenStream {\n-        TokenStream { subtree: tt::Subtree { delimiter: None, token_trees: vec![tree] } }\n+        TokenStream { token_trees: vec![tree] }\n     }\n }\n \n@@ -78,10 +86,10 @@ impl Extend<TokenStream> for TokenStream {\n             for tkn in item {\n                 match tkn {\n                     tt::TokenTree::Subtree(subtree) if subtree.delimiter.is_none() => {\n-                        self.subtree.token_trees.extend(subtree.token_trees);\n+                        self.token_trees.extend(subtree.token_trees);\n                     }\n                     _ => {\n-                        self.subtree.token_trees.push(tkn);\n+                        self.token_trees.push(tkn);\n                     }\n                 }\n             }\n@@ -164,7 +172,7 @@ pub mod token_stream {\n         type IntoIter = super::IntoIter<TokenTree>;\n \n         fn into_iter(self) -> Self::IntoIter {\n-            self.subtree.token_trees.into_iter()\n+            self.token_trees.into_iter()\n         }\n     }\n \n@@ -185,28 +193,22 @@ pub mod token_stream {\n                 mbe::parse_to_token_tree(src).ok_or(\"Failed to parse from mbe\")?;\n \n             let subtree = subtree_replace_token_ids_with_unspecified(subtree);\n-            Ok(TokenStream { subtree })\n+            Ok(TokenStream::with_subtree(subtree))\n         }\n     }\n \n     impl ToString for TokenStream {\n         fn to_string(&self) -> String {\n-            let tt = self.subtree.clone().into();\n-            to_text(&tt)\n-        }\n-    }\n+            return tokentrees_to_text(&self.token_trees[..]);\n \n-    fn to_text(tkn: &tt::TokenTree) -> String {\n-        match tkn {\n-            tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => ident.text.clone().into(),\n-            tt::TokenTree::Leaf(tt::Leaf::Literal(literal)) => literal.text.clone().into(),\n-            tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) => format!(\"{}\", punct.char),\n-            tt::TokenTree::Subtree(subtree) => {\n-                let content = subtree\n-                    .token_trees\n-                    .iter()\n+            fn tokentrees_to_text(tkns: &[tt::TokenTree]) -> String {\n+                tkns.iter()\n                     .fold((String::new(), true), |(last, last_to_joint), tkn| {\n-                        let s = [last, to_text(tkn)].join(if last_to_joint { \"\" } else { \" \" });\n+                        let s = [last, tokentree_to_text(tkn)].join(if last_to_joint {\n+                            \"\"\n+                        } else {\n+                            \" \"\n+                        });\n                         let mut is_joint = false;\n                         if let tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) = tkn {\n                             if punct.spacing == tt::Spacing::Joint {\n@@ -215,15 +217,25 @@ pub mod token_stream {\n                         }\n                         (s, is_joint)\n                     })\n-                    .0;\n-\n-                let (open, close) = match subtree.delimiter.map(|it| it.kind) {\n-                    None => (\"\", \"\"),\n-                    Some(tt::DelimiterKind::Brace) => (\"{\", \"}\"),\n-                    Some(tt::DelimiterKind::Parenthesis) => (\"(\", \")\"),\n-                    Some(tt::DelimiterKind::Bracket) => (\"[\", \"]\"),\n-                };\n-                format!(\"{}{}{}\", open, content, close)\n+                    .0\n+            }\n+\n+            fn tokentree_to_text(tkn: &tt::TokenTree) -> String {\n+                match tkn {\n+                    tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => ident.text.clone().into(),\n+                    tt::TokenTree::Leaf(tt::Leaf::Literal(literal)) => literal.text.clone().into(),\n+                    tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) => format!(\"{}\", punct.char),\n+                    tt::TokenTree::Subtree(subtree) => {\n+                        let content = tokentrees_to_text(&subtree.token_trees);\n+                        let (open, close) = match subtree.delimiter.map(|it| it.kind) {\n+                            None => (\"\", \"\"),\n+                            Some(tt::DelimiterKind::Brace) => (\"{\", \"}\"),\n+                            Some(tt::DelimiterKind::Parenthesis) => (\"(\", \")\"),\n+                            Some(tt::DelimiterKind::Bracket) => (\"[\", \"]\"),\n+                        };\n+                        format!(\"{}{}{}\", open, content, close)\n+                    }\n+                }\n             }\n         }\n     }\n@@ -433,20 +445,15 @@ fn spacing_to_external(spacing: Spacing) -> bridge::Spacing {\n \n impl server::Group for Rustc {\n     fn new(&mut self, delimiter: bridge::Delimiter, stream: Self::TokenStream) -> Self::Group {\n-        Self::Group {\n-            delimiter: delim_to_internal(delimiter),\n-            token_trees: stream.subtree.token_trees,\n-        }\n+        Self::Group { delimiter: delim_to_internal(delimiter), token_trees: stream.token_trees }\n     }\n     fn delimiter(&mut self, group: &Self::Group) -> bridge::Delimiter {\n         delim_to_external(group.delimiter)\n     }\n \n     // NOTE: Return value of do not include delimiter\n     fn stream(&mut self, group: &Self::Group) -> Self::TokenStream {\n-        TokenStream {\n-            subtree: tt::Subtree { delimiter: None, token_trees: group.token_trees.clone() },\n-        }\n+        TokenStream { token_trees: group.token_trees.clone() }\n     }\n \n     fn span(&mut self, group: &Self::Group) -> Self::Span {\n@@ -755,28 +762,48 @@ mod tests {\n     #[test]\n     fn test_rustc_server_to_string() {\n         let s = TokenStream {\n-            subtree: tt::Subtree {\n-                delimiter: None,\n-                token_trees: vec![\n-                    tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n-                        text: \"struct\".into(),\n-                        id: tt::TokenId::unspecified(),\n-                    })),\n-                    tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n-                        text: \"T\".into(),\n+            token_trees: vec![\n+                tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                    text: \"struct\".into(),\n+                    id: tt::TokenId::unspecified(),\n+                })),\n+                tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                    text: \"T\".into(),\n+                    id: tt::TokenId::unspecified(),\n+                })),\n+                tt::TokenTree::Subtree(tt::Subtree {\n+                    delimiter: Some(tt::Delimiter {\n                         id: tt::TokenId::unspecified(),\n-                    })),\n-                    tt::TokenTree::Subtree(tt::Subtree {\n-                        delimiter: Some(tt::Delimiter {\n-                            id: tt::TokenId::unspecified(),\n-                            kind: tt::DelimiterKind::Brace,\n-                        }),\n-                        token_trees: vec![],\n+                        kind: tt::DelimiterKind::Brace,\n                     }),\n-                ],\n-            },\n+                    token_trees: vec![],\n+                }),\n+            ],\n         };\n \n         assert_eq!(s.to_string(), \"struct T {}\");\n     }\n+\n+    #[test]\n+    fn test_rustc_server_from_str() {\n+        use std::str::FromStr;\n+        let subtree_paren_a = tt::TokenTree::Subtree(tt::Subtree {\n+            delimiter: Some(tt::Delimiter {\n+                id: tt::TokenId::unspecified(),\n+                kind: tt::DelimiterKind::Parenthesis,\n+            }),\n+            token_trees: vec![tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                text: \"a\".into(),\n+                id: tt::TokenId::unspecified(),\n+            }))],\n+        });\n+\n+        let t1 = TokenStream::from_str(\"(a)\").unwrap();\n+        assert_eq!(t1.token_trees.len(), 1);\n+        assert_eq!(t1.token_trees[0], subtree_paren_a);\n+\n+        let t2 = TokenStream::from_str(\"(a);\").unwrap();\n+        assert_eq!(t2.token_trees.len(), 2);\n+        assert_eq!(t2.token_trees[0], subtree_paren_a);\n+    }\n }"}, {"sha": "0484c3af449831205254f6cb2d8f4be07493a44c", "filename": "crates/proc_macro_srv/src/tests/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0b7c02f16f717744e7edc79a405db14110393cf/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b7c02f16f717744e7edc79a405db14110393cf/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs?ref=f0b7c02f16f717744e7edc79a405db14110393cf", "patch": "@@ -52,7 +52,7 @@ pub fn assert_expand(\n     let expander = dylib::Expander::new(&path).unwrap();\n     let fixture = parse_string(ra_fixture).unwrap();\n \n-    let res = expander.expand(macro_name, &fixture.subtree, None).unwrap();\n+    let res = expander.expand(macro_name, &fixture.into_subtree(), None).unwrap();\n     assert_eq_text!(&expect.trim(), &format!(\"{:?}\", res));\n }\n "}]}