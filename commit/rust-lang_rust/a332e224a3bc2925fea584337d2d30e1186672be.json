{"sha": "a332e224a3bc2925fea584337d2d30e1186672be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMzJlMjI0YTNiYzI5MjVmZWE1ODQzMzdkMmQzMGUxMTg2NjcyYmU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-01T21:18:56Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-01T22:59:01Z"}, "message": "librustdoc: Unconfigure tests during normal build", "tree": {"sha": "ee502bfc63ef9eddab144e2fca949c44ab486a20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee502bfc63ef9eddab144e2fca949c44ab486a20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a332e224a3bc2925fea584337d2d30e1186672be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a332e224a3bc2925fea584337d2d30e1186672be", "html_url": "https://github.com/rust-lang/rust/commit/a332e224a3bc2925fea584337d2d30e1186672be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a332e224a3bc2925fea584337d2d30e1186672be/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e118eb6c7970385fbcdd688d03975f65d88e642e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e118eb6c7970385fbcdd688d03975f65d88e642e", "html_url": "https://github.com/rust-lang/rust/commit/e118eb6c7970385fbcdd688d03975f65d88e642e"}], "stats": {"total": 1305, "additions": 651, "deletions": 654}, "files": [{"sha": "b9b3e621bb740dc6892258843d85d60624529340", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 3, "deletions": 417, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=a332e224a3bc2925fea584337d2d30e1186672be", "patch": "@@ -16,6 +16,9 @@ use syntax_pos::Span;\n \n use crate::html::escape::Escape;\n \n+#[cfg(test)]\n+mod tests;\n+\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub enum Cfg {\n     /// Accepts all configurations.\n@@ -408,420 +411,3 @@ impl<'a> fmt::Display for Html<'a> {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::Cfg;\n-\n-    use syntax_pos::DUMMY_SP;\n-    use syntax::ast::*;\n-    use syntax::attr;\n-    use syntax::source_map::dummy_spanned;\n-    use syntax::symbol::Symbol;\n-    use syntax::with_default_globals;\n-\n-    fn word_cfg(s: &str) -> Cfg {\n-        Cfg::Cfg(Symbol::intern(s), None)\n-    }\n-\n-    fn name_value_cfg(name: &str, value: &str) -> Cfg {\n-        Cfg::Cfg(Symbol::intern(name), Some(Symbol::intern(value)))\n-    }\n-\n-    fn dummy_meta_item_word(name: &str) -> MetaItem {\n-        MetaItem {\n-            path: Path::from_ident(Ident::from_str(name)),\n-            node: MetaItemKind::Word,\n-            span: DUMMY_SP,\n-        }\n-    }\n-\n-    macro_rules! dummy_meta_item_list {\n-        ($name:ident, [$($list:ident),* $(,)?]) => {\n-            MetaItem {\n-                path: Path::from_ident(Ident::from_str(stringify!($name))),\n-                node: MetaItemKind::List(vec![\n-                    $(\n-                        NestedMetaItem::MetaItem(\n-                            dummy_meta_item_word(stringify!($list)),\n-                        ),\n-                    )*\n-                ]),\n-                span: DUMMY_SP,\n-            }\n-        };\n-\n-        ($name:ident, [$($list:expr),* $(,)?]) => {\n-            MetaItem {\n-                path: Path::from_ident(Ident::from_str(stringify!($name))),\n-                node: MetaItemKind::List(vec![\n-                    $(\n-                        NestedMetaItem::MetaItem($list),\n-                    )*\n-                ]),\n-                span: DUMMY_SP,\n-            }\n-        };\n-    }\n-\n-    #[test]\n-    fn test_cfg_not() {\n-        with_default_globals(|| {\n-            assert_eq!(!Cfg::False, Cfg::True);\n-            assert_eq!(!Cfg::True, Cfg::False);\n-            assert_eq!(!word_cfg(\"test\"), Cfg::Not(Box::new(word_cfg(\"test\"))));\n-            assert_eq!(\n-                !Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n-                Cfg::Not(Box::new(Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")])))\n-            );\n-            assert_eq!(\n-                !Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n-                Cfg::Not(Box::new(Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")])))\n-            );\n-            assert_eq!(!Cfg::Not(Box::new(word_cfg(\"test\"))), word_cfg(\"test\"));\n-        })\n-    }\n-\n-    #[test]\n-    fn test_cfg_and() {\n-        with_default_globals(|| {\n-            let mut x = Cfg::False;\n-            x &= Cfg::True;\n-            assert_eq!(x, Cfg::False);\n-\n-            x = word_cfg(\"test\");\n-            x &= Cfg::False;\n-            assert_eq!(x, Cfg::False);\n-\n-            x = word_cfg(\"test2\");\n-            x &= Cfg::True;\n-            assert_eq!(x, word_cfg(\"test2\"));\n-\n-            x = Cfg::True;\n-            x &= word_cfg(\"test3\");\n-            assert_eq!(x, word_cfg(\"test3\"));\n-\n-            x &= word_cfg(\"test4\");\n-            assert_eq!(x, Cfg::All(vec![word_cfg(\"test3\"), word_cfg(\"test4\")]));\n-\n-            x &= word_cfg(\"test5\");\n-            assert_eq!(x, Cfg::All(vec![word_cfg(\"test3\"), word_cfg(\"test4\"), word_cfg(\"test5\")]));\n-\n-            x &= Cfg::All(vec![word_cfg(\"test6\"), word_cfg(\"test7\")]);\n-            assert_eq!(x, Cfg::All(vec![\n-                word_cfg(\"test3\"),\n-                word_cfg(\"test4\"),\n-                word_cfg(\"test5\"),\n-                word_cfg(\"test6\"),\n-                word_cfg(\"test7\"),\n-            ]));\n-\n-            let mut y = Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]);\n-            y &= x;\n-            assert_eq!(y, Cfg::All(vec![\n-                word_cfg(\"test3\"),\n-                word_cfg(\"test4\"),\n-                word_cfg(\"test5\"),\n-                word_cfg(\"test6\"),\n-                word_cfg(\"test7\"),\n-                Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n-            ]));\n-\n-            assert_eq!(\n-                word_cfg(\"a\") & word_cfg(\"b\") & word_cfg(\"c\"),\n-                Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\"), word_cfg(\"c\")])\n-            );\n-        })\n-    }\n-\n-    #[test]\n-    fn test_cfg_or() {\n-        with_default_globals(|| {\n-            let mut x = Cfg::True;\n-            x |= Cfg::False;\n-            assert_eq!(x, Cfg::True);\n-\n-            x = word_cfg(\"test\");\n-            x |= Cfg::True;\n-            assert_eq!(x, Cfg::True);\n-\n-            x = word_cfg(\"test2\");\n-            x |= Cfg::False;\n-            assert_eq!(x, word_cfg(\"test2\"));\n-\n-            x = Cfg::False;\n-            x |= word_cfg(\"test3\");\n-            assert_eq!(x, word_cfg(\"test3\"));\n-\n-            x |= word_cfg(\"test4\");\n-            assert_eq!(x, Cfg::Any(vec![word_cfg(\"test3\"), word_cfg(\"test4\")]));\n-\n-            x |= word_cfg(\"test5\");\n-            assert_eq!(x, Cfg::Any(vec![word_cfg(\"test3\"), word_cfg(\"test4\"), word_cfg(\"test5\")]));\n-\n-            x |= Cfg::Any(vec![word_cfg(\"test6\"), word_cfg(\"test7\")]);\n-            assert_eq!(x, Cfg::Any(vec![\n-                word_cfg(\"test3\"),\n-                word_cfg(\"test4\"),\n-                word_cfg(\"test5\"),\n-                word_cfg(\"test6\"),\n-                word_cfg(\"test7\"),\n-            ]));\n-\n-            let mut y = Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]);\n-            y |= x;\n-            assert_eq!(y, Cfg::Any(vec![\n-                word_cfg(\"test3\"),\n-                word_cfg(\"test4\"),\n-                word_cfg(\"test5\"),\n-                word_cfg(\"test6\"),\n-                word_cfg(\"test7\"),\n-                Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n-            ]));\n-\n-            assert_eq!(\n-                word_cfg(\"a\") | word_cfg(\"b\") | word_cfg(\"c\"),\n-                Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\"), word_cfg(\"c\")])\n-            );\n-        })\n-    }\n-\n-    #[test]\n-    fn test_parse_ok() {\n-        with_default_globals(|| {\n-            let mi = dummy_meta_item_word(\"all\");\n-            assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"all\")));\n-\n-            let mi = attr::mk_name_value_item_str(\n-                Ident::from_str(\"all\"),\n-                dummy_spanned(Symbol::intern(\"done\"))\n-            );\n-            assert_eq!(Cfg::parse(&mi), Ok(name_value_cfg(\"all\", \"done\")));\n-\n-            let mi = dummy_meta_item_list!(all, [a, b]);\n-            assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\")));\n-\n-            let mi = dummy_meta_item_list!(any, [a, b]);\n-            assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") | word_cfg(\"b\")));\n-\n-            let mi = dummy_meta_item_list!(not, [a]);\n-            assert_eq!(Cfg::parse(&mi), Ok(!word_cfg(\"a\")));\n-\n-            let mi = dummy_meta_item_list!(not, [\n-                dummy_meta_item_list!(any, [\n-                    dummy_meta_item_word(\"a\"),\n-                    dummy_meta_item_list!(all, [b, c]),\n-                ]),\n-            ]);\n-            assert_eq!(Cfg::parse(&mi), Ok(!(word_cfg(\"a\") | (word_cfg(\"b\") & word_cfg(\"c\")))));\n-\n-            let mi = dummy_meta_item_list!(all, [a, b, c]);\n-            assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\") & word_cfg(\"c\")));\n-        })\n-    }\n-\n-    #[test]\n-    fn test_parse_err() {\n-        with_default_globals(|| {\n-            let mi = attr::mk_name_value_item(\n-                DUMMY_SP,\n-                Ident::from_str(\"foo\"),\n-                LitKind::Bool(false),\n-                DUMMY_SP,\n-            );\n-            assert!(Cfg::parse(&mi).is_err());\n-\n-            let mi = dummy_meta_item_list!(not, [a, b]);\n-            assert!(Cfg::parse(&mi).is_err());\n-\n-            let mi = dummy_meta_item_list!(not, []);\n-            assert!(Cfg::parse(&mi).is_err());\n-\n-            let mi = dummy_meta_item_list!(foo, []);\n-            assert!(Cfg::parse(&mi).is_err());\n-\n-            let mi = dummy_meta_item_list!(all, [\n-                dummy_meta_item_list!(foo, []),\n-                dummy_meta_item_word(\"b\"),\n-            ]);\n-            assert!(Cfg::parse(&mi).is_err());\n-\n-            let mi = dummy_meta_item_list!(any, [\n-                dummy_meta_item_word(\"a\"),\n-                dummy_meta_item_list!(foo, []),\n-            ]);\n-            assert!(Cfg::parse(&mi).is_err());\n-\n-            let mi = dummy_meta_item_list!(not, [\n-                dummy_meta_item_list!(foo, []),\n-            ]);\n-            assert!(Cfg::parse(&mi).is_err());\n-        })\n-    }\n-\n-    #[test]\n-    fn test_render_short_html() {\n-        with_default_globals(|| {\n-            assert_eq!(\n-                word_cfg(\"unix\").render_short_html(),\n-                \"Unix\"\n-            );\n-            assert_eq!(\n-                name_value_cfg(\"target_os\", \"macos\").render_short_html(),\n-                \"macOS\"\n-            );\n-            assert_eq!(\n-                name_value_cfg(\"target_pointer_width\", \"16\").render_short_html(),\n-                \"16-bit\"\n-            );\n-            assert_eq!(\n-                name_value_cfg(\"target_endian\", \"little\").render_short_html(),\n-                \"Little-endian\"\n-            );\n-            assert_eq!(\n-                (!word_cfg(\"windows\")).render_short_html(),\n-                \"Non-Windows\"\n-            );\n-            assert_eq!(\n-                (word_cfg(\"unix\") & word_cfg(\"windows\")).render_short_html(),\n-                \"Unix and Windows\"\n-            );\n-            assert_eq!(\n-                (word_cfg(\"unix\") | word_cfg(\"windows\")).render_short_html(),\n-                \"Unix or Windows\"\n-            );\n-            assert_eq!(\n-                (\n-                    word_cfg(\"unix\") & word_cfg(\"windows\") & word_cfg(\"debug_assertions\")\n-                ).render_short_html(),\n-                \"Unix and Windows and debug-assertions enabled\"\n-            );\n-            assert_eq!(\n-                (\n-                    word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\")\n-                ).render_short_html(),\n-                \"Unix or Windows or debug-assertions enabled\"\n-            );\n-            assert_eq!(\n-                (\n-                    !(word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\"))\n-                ).render_short_html(),\n-                \"Neither Unix nor Windows nor debug-assertions enabled\"\n-            );\n-            assert_eq!(\n-                (\n-                    (word_cfg(\"unix\") & name_value_cfg(\"target_arch\", \"x86_64\")) |\n-                    (word_cfg(\"windows\") & name_value_cfg(\"target_pointer_width\", \"64\"))\n-                ).render_short_html(),\n-                \"Unix and x86-64, or Windows and 64-bit\"\n-            );\n-            assert_eq!(\n-                (!(word_cfg(\"unix\") & word_cfg(\"windows\"))).render_short_html(),\n-                \"Not (Unix and Windows)\"\n-            );\n-            assert_eq!(\n-                (\n-                    (word_cfg(\"debug_assertions\") | word_cfg(\"windows\")) & word_cfg(\"unix\")\n-                ).render_short_html(),\n-                \"(Debug-assertions enabled or Windows) and Unix\"\n-            );\n-            assert_eq!(\n-                name_value_cfg(\"target_feature\", \"sse2\").render_short_html(),\n-                \"<code>sse2</code>\"\n-            );\n-            assert_eq!(\n-                (\n-                    name_value_cfg(\"target_arch\", \"x86_64\") &\n-                    name_value_cfg(\"target_feature\", \"sse2\")\n-                ).render_short_html(),\n-                \"x86-64 and <code>sse2</code>\"\n-            );\n-        })\n-    }\n-\n-    #[test]\n-    fn test_render_long_html() {\n-        with_default_globals(|| {\n-            assert_eq!(\n-                word_cfg(\"unix\").render_long_html(),\n-                \"This is supported on <strong>Unix</strong> only.\"\n-            );\n-            assert_eq!(\n-                name_value_cfg(\"target_os\", \"macos\").render_long_html(),\n-                \"This is supported on <strong>macOS</strong> only.\"\n-            );\n-            assert_eq!(\n-                name_value_cfg(\"target_pointer_width\", \"16\").render_long_html(),\n-                \"This is supported on <strong>16-bit</strong> only.\"\n-            );\n-            assert_eq!(\n-                name_value_cfg(\"target_endian\", \"little\").render_long_html(),\n-                \"This is supported on <strong>little-endian</strong> only.\"\n-            );\n-            assert_eq!(\n-                (!word_cfg(\"windows\")).render_long_html(),\n-                \"This is supported on <strong>non-Windows</strong> only.\"\n-            );\n-            assert_eq!(\n-                (word_cfg(\"unix\") & word_cfg(\"windows\")).render_long_html(),\n-                \"This is supported on <strong>Unix and Windows</strong> only.\"\n-            );\n-            assert_eq!(\n-                (word_cfg(\"unix\") | word_cfg(\"windows\")).render_long_html(),\n-                \"This is supported on <strong>Unix or Windows</strong> only.\"\n-            );\n-            assert_eq!(\n-                (\n-                    word_cfg(\"unix\") & word_cfg(\"windows\") & word_cfg(\"debug_assertions\")\n-                ).render_long_html(),\n-                \"This is supported on <strong>Unix and Windows and debug-assertions enabled\\\n-                 </strong> only.\"\n-            );\n-            assert_eq!(\n-                (\n-                    word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\")\n-                ).render_long_html(),\n-                \"This is supported on <strong>Unix or Windows or debug-assertions enabled\\\n-                 </strong> only.\"\n-            );\n-            assert_eq!(\n-                (\n-                    !(word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\"))\n-                ).render_long_html(),\n-                \"This is supported on <strong>neither Unix nor Windows nor debug-assertions \\\n-                    enabled</strong>.\"\n-            );\n-            assert_eq!(\n-                (\n-                    (word_cfg(\"unix\") & name_value_cfg(\"target_arch\", \"x86_64\")) |\n-                    (word_cfg(\"windows\") & name_value_cfg(\"target_pointer_width\", \"64\"))\n-                ).render_long_html(),\n-                \"This is supported on <strong>Unix and x86-64, or Windows and 64-bit</strong> \\\n-                 only.\"\n-            );\n-            assert_eq!(\n-                (!(word_cfg(\"unix\") & word_cfg(\"windows\"))).render_long_html(),\n-                \"This is supported on <strong>not (Unix and Windows)</strong>.\"\n-            );\n-            assert_eq!(\n-                (\n-                    (word_cfg(\"debug_assertions\") | word_cfg(\"windows\")) & word_cfg(\"unix\")\n-                ).render_long_html(),\n-                \"This is supported on <strong>(debug-assertions enabled or Windows) and Unix\\\n-                </strong> only.\"\n-            );\n-            assert_eq!(\n-                name_value_cfg(\"target_feature\", \"sse2\").render_long_html(),\n-                \"This is supported with <strong>target feature <code>sse2</code></strong> only.\"\n-            );\n-            assert_eq!(\n-                (\n-                    name_value_cfg(\"target_arch\", \"x86_64\") &\n-                    name_value_cfg(\"target_feature\", \"sse2\")\n-                ).render_long_html(),\n-                \"This is supported on <strong>x86-64 and target feature \\\n-                <code>sse2</code></strong> only.\"\n-            );\n-        })\n-    }\n-}"}, {"sha": "d0df9f8f7e4101242b2e5ae4faf6ef2d679e047d", "filename": "src/librustdoc/clean/cfg/tests.rs", "status": "added", "additions": 413, "deletions": 0, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs?ref=a332e224a3bc2925fea584337d2d30e1186672be", "patch": "@@ -0,0 +1,413 @@\n+use super::*;\n+\n+use syntax_pos::DUMMY_SP;\n+use syntax::ast::*;\n+use syntax::attr;\n+use syntax::source_map::dummy_spanned;\n+use syntax::symbol::Symbol;\n+use syntax::with_default_globals;\n+\n+fn word_cfg(s: &str) -> Cfg {\n+    Cfg::Cfg(Symbol::intern(s), None)\n+}\n+\n+fn name_value_cfg(name: &str, value: &str) -> Cfg {\n+    Cfg::Cfg(Symbol::intern(name), Some(Symbol::intern(value)))\n+}\n+\n+fn dummy_meta_item_word(name: &str) -> MetaItem {\n+    MetaItem {\n+        path: Path::from_ident(Ident::from_str(name)),\n+        node: MetaItemKind::Word,\n+        span: DUMMY_SP,\n+    }\n+}\n+\n+macro_rules! dummy_meta_item_list {\n+    ($name:ident, [$($list:ident),* $(,)?]) => {\n+        MetaItem {\n+            path: Path::from_ident(Ident::from_str(stringify!($name))),\n+            node: MetaItemKind::List(vec![\n+                $(\n+                    NestedMetaItem::MetaItem(\n+                        dummy_meta_item_word(stringify!($list)),\n+                    ),\n+                )*\n+            ]),\n+            span: DUMMY_SP,\n+        }\n+    };\n+\n+    ($name:ident, [$($list:expr),* $(,)?]) => {\n+        MetaItem {\n+            path: Path::from_ident(Ident::from_str(stringify!($name))),\n+            node: MetaItemKind::List(vec![\n+                $(\n+                    NestedMetaItem::MetaItem($list),\n+                )*\n+            ]),\n+            span: DUMMY_SP,\n+        }\n+    };\n+}\n+\n+#[test]\n+fn test_cfg_not() {\n+    with_default_globals(|| {\n+        assert_eq!(!Cfg::False, Cfg::True);\n+        assert_eq!(!Cfg::True, Cfg::False);\n+        assert_eq!(!word_cfg(\"test\"), Cfg::Not(Box::new(word_cfg(\"test\"))));\n+        assert_eq!(\n+            !Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+            Cfg::Not(Box::new(Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")])))\n+        );\n+        assert_eq!(\n+            !Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+            Cfg::Not(Box::new(Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")])))\n+        );\n+        assert_eq!(!Cfg::Not(Box::new(word_cfg(\"test\"))), word_cfg(\"test\"));\n+    })\n+}\n+\n+#[test]\n+fn test_cfg_and() {\n+    with_default_globals(|| {\n+        let mut x = Cfg::False;\n+        x &= Cfg::True;\n+        assert_eq!(x, Cfg::False);\n+\n+        x = word_cfg(\"test\");\n+        x &= Cfg::False;\n+        assert_eq!(x, Cfg::False);\n+\n+        x = word_cfg(\"test2\");\n+        x &= Cfg::True;\n+        assert_eq!(x, word_cfg(\"test2\"));\n+\n+        x = Cfg::True;\n+        x &= word_cfg(\"test3\");\n+        assert_eq!(x, word_cfg(\"test3\"));\n+\n+        x &= word_cfg(\"test4\");\n+        assert_eq!(x, Cfg::All(vec![word_cfg(\"test3\"), word_cfg(\"test4\")]));\n+\n+        x &= word_cfg(\"test5\");\n+        assert_eq!(x, Cfg::All(vec![word_cfg(\"test3\"), word_cfg(\"test4\"), word_cfg(\"test5\")]));\n+\n+        x &= Cfg::All(vec![word_cfg(\"test6\"), word_cfg(\"test7\")]);\n+        assert_eq!(x, Cfg::All(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+        ]));\n+\n+        let mut y = Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]);\n+        y &= x;\n+        assert_eq!(y, Cfg::All(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+            Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+        ]));\n+\n+        assert_eq!(\n+            word_cfg(\"a\") & word_cfg(\"b\") & word_cfg(\"c\"),\n+            Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\"), word_cfg(\"c\")])\n+        );\n+    })\n+}\n+\n+#[test]\n+fn test_cfg_or() {\n+    with_default_globals(|| {\n+        let mut x = Cfg::True;\n+        x |= Cfg::False;\n+        assert_eq!(x, Cfg::True);\n+\n+        x = word_cfg(\"test\");\n+        x |= Cfg::True;\n+        assert_eq!(x, Cfg::True);\n+\n+        x = word_cfg(\"test2\");\n+        x |= Cfg::False;\n+        assert_eq!(x, word_cfg(\"test2\"));\n+\n+        x = Cfg::False;\n+        x |= word_cfg(\"test3\");\n+        assert_eq!(x, word_cfg(\"test3\"));\n+\n+        x |= word_cfg(\"test4\");\n+        assert_eq!(x, Cfg::Any(vec![word_cfg(\"test3\"), word_cfg(\"test4\")]));\n+\n+        x |= word_cfg(\"test5\");\n+        assert_eq!(x, Cfg::Any(vec![word_cfg(\"test3\"), word_cfg(\"test4\"), word_cfg(\"test5\")]));\n+\n+        x |= Cfg::Any(vec![word_cfg(\"test6\"), word_cfg(\"test7\")]);\n+        assert_eq!(x, Cfg::Any(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+        ]));\n+\n+        let mut y = Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]);\n+        y |= x;\n+        assert_eq!(y, Cfg::Any(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+            Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+        ]));\n+\n+        assert_eq!(\n+            word_cfg(\"a\") | word_cfg(\"b\") | word_cfg(\"c\"),\n+            Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\"), word_cfg(\"c\")])\n+        );\n+    })\n+}\n+\n+#[test]\n+fn test_parse_ok() {\n+    with_default_globals(|| {\n+        let mi = dummy_meta_item_word(\"all\");\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"all\")));\n+\n+        let mi = attr::mk_name_value_item_str(\n+            Ident::from_str(\"all\"),\n+            dummy_spanned(Symbol::intern(\"done\"))\n+        );\n+        assert_eq!(Cfg::parse(&mi), Ok(name_value_cfg(\"all\", \"done\")));\n+\n+        let mi = dummy_meta_item_list!(all, [a, b]);\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\")));\n+\n+        let mi = dummy_meta_item_list!(any, [a, b]);\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") | word_cfg(\"b\")));\n+\n+        let mi = dummy_meta_item_list!(not, [a]);\n+        assert_eq!(Cfg::parse(&mi), Ok(!word_cfg(\"a\")));\n+\n+        let mi = dummy_meta_item_list!(not, [\n+            dummy_meta_item_list!(any, [\n+                dummy_meta_item_word(\"a\"),\n+                dummy_meta_item_list!(all, [b, c]),\n+            ]),\n+        ]);\n+        assert_eq!(Cfg::parse(&mi), Ok(!(word_cfg(\"a\") | (word_cfg(\"b\") & word_cfg(\"c\")))));\n+\n+        let mi = dummy_meta_item_list!(all, [a, b, c]);\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\") & word_cfg(\"c\")));\n+    })\n+}\n+\n+#[test]\n+fn test_parse_err() {\n+    with_default_globals(|| {\n+        let mi = attr::mk_name_value_item(\n+            DUMMY_SP,\n+            Ident::from_str(\"foo\"),\n+            LitKind::Bool(false),\n+            DUMMY_SP,\n+        );\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = dummy_meta_item_list!(not, [a, b]);\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = dummy_meta_item_list!(not, []);\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = dummy_meta_item_list!(foo, []);\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = dummy_meta_item_list!(all, [\n+            dummy_meta_item_list!(foo, []),\n+            dummy_meta_item_word(\"b\"),\n+        ]);\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = dummy_meta_item_list!(any, [\n+            dummy_meta_item_word(\"a\"),\n+            dummy_meta_item_list!(foo, []),\n+        ]);\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = dummy_meta_item_list!(not, [\n+            dummy_meta_item_list!(foo, []),\n+        ]);\n+        assert!(Cfg::parse(&mi).is_err());\n+    })\n+}\n+\n+#[test]\n+fn test_render_short_html() {\n+    with_default_globals(|| {\n+        assert_eq!(\n+            word_cfg(\"unix\").render_short_html(),\n+            \"Unix\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_os\", \"macos\").render_short_html(),\n+            \"macOS\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_pointer_width\", \"16\").render_short_html(),\n+            \"16-bit\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_endian\", \"little\").render_short_html(),\n+            \"Little-endian\"\n+        );\n+        assert_eq!(\n+            (!word_cfg(\"windows\")).render_short_html(),\n+            \"Non-Windows\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") & word_cfg(\"windows\")).render_short_html(),\n+            \"Unix and Windows\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") | word_cfg(\"windows\")).render_short_html(),\n+            \"Unix or Windows\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") & word_cfg(\"windows\") & word_cfg(\"debug_assertions\")\n+            ).render_short_html(),\n+            \"Unix and Windows and debug-assertions enabled\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\")\n+            ).render_short_html(),\n+            \"Unix or Windows or debug-assertions enabled\"\n+        );\n+        assert_eq!(\n+            (\n+                !(word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\"))\n+            ).render_short_html(),\n+            \"Neither Unix nor Windows nor debug-assertions enabled\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"unix\") & name_value_cfg(\"target_arch\", \"x86_64\")) |\n+                (word_cfg(\"windows\") & name_value_cfg(\"target_pointer_width\", \"64\"))\n+            ).render_short_html(),\n+            \"Unix and x86-64, or Windows and 64-bit\"\n+        );\n+        assert_eq!(\n+            (!(word_cfg(\"unix\") & word_cfg(\"windows\"))).render_short_html(),\n+            \"Not (Unix and Windows)\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"debug_assertions\") | word_cfg(\"windows\")) & word_cfg(\"unix\")\n+            ).render_short_html(),\n+            \"(Debug-assertions enabled or Windows) and Unix\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_feature\", \"sse2\").render_short_html(),\n+            \"<code>sse2</code>\"\n+        );\n+        assert_eq!(\n+            (\n+                name_value_cfg(\"target_arch\", \"x86_64\") &\n+                name_value_cfg(\"target_feature\", \"sse2\")\n+            ).render_short_html(),\n+            \"x86-64 and <code>sse2</code>\"\n+        );\n+    })\n+}\n+\n+#[test]\n+fn test_render_long_html() {\n+    with_default_globals(|| {\n+        assert_eq!(\n+            word_cfg(\"unix\").render_long_html(),\n+            \"This is supported on <strong>Unix</strong> only.\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_os\", \"macos\").render_long_html(),\n+            \"This is supported on <strong>macOS</strong> only.\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_pointer_width\", \"16\").render_long_html(),\n+            \"This is supported on <strong>16-bit</strong> only.\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_endian\", \"little\").render_long_html(),\n+            \"This is supported on <strong>little-endian</strong> only.\"\n+        );\n+        assert_eq!(\n+            (!word_cfg(\"windows\")).render_long_html(),\n+            \"This is supported on <strong>non-Windows</strong> only.\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") & word_cfg(\"windows\")).render_long_html(),\n+            \"This is supported on <strong>Unix and Windows</strong> only.\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") | word_cfg(\"windows\")).render_long_html(),\n+            \"This is supported on <strong>Unix or Windows</strong> only.\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") & word_cfg(\"windows\") & word_cfg(\"debug_assertions\")\n+            ).render_long_html(),\n+            \"This is supported on <strong>Unix and Windows and debug-assertions enabled\\\n+                </strong> only.\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\")\n+            ).render_long_html(),\n+            \"This is supported on <strong>Unix or Windows or debug-assertions enabled\\\n+                </strong> only.\"\n+        );\n+        assert_eq!(\n+            (\n+                !(word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\"))\n+            ).render_long_html(),\n+            \"This is supported on <strong>neither Unix nor Windows nor debug-assertions \\\n+                enabled</strong>.\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"unix\") & name_value_cfg(\"target_arch\", \"x86_64\")) |\n+                (word_cfg(\"windows\") & name_value_cfg(\"target_pointer_width\", \"64\"))\n+            ).render_long_html(),\n+            \"This is supported on <strong>Unix and x86-64, or Windows and 64-bit</strong> \\\n+                only.\"\n+        );\n+        assert_eq!(\n+            (!(word_cfg(\"unix\") & word_cfg(\"windows\"))).render_long_html(),\n+            \"This is supported on <strong>not (Unix and Windows)</strong>.\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"debug_assertions\") | word_cfg(\"windows\")) & word_cfg(\"unix\")\n+            ).render_long_html(),\n+            \"This is supported on <strong>(debug-assertions enabled or Windows) and Unix\\\n+            </strong> only.\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_feature\", \"sse2\").render_long_html(),\n+            \"This is supported with <strong>target feature <code>sse2</code></strong> only.\"\n+        );\n+        assert_eq!(\n+            (\n+                name_value_cfg(\"target_arch\", \"x86_64\") &\n+                name_value_cfg(\"target_feature\", \"sse2\")\n+            ).render_long_html(),\n+            \"This is supported on <strong>x86-64 and target feature \\\n+            <code>sse2</code></strong> only.\"\n+        );\n+    })\n+}"}, {"sha": "ef52ce62875c7d15db5dd42e832658047c053bcb", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=a332e224a3bc2925fea584337d2d30e1186672be", "patch": "@@ -39,6 +39,9 @@ use crate::test;\n \n use pulldown_cmark::{html, CowStr, Event, Options, Parser, Tag};\n \n+#[cfg(test)]\n+mod tests;\n+\n fn opts() -> Options {\n     Options::ENABLE_TABLES | Options::ENABLE_FOOTNOTES\n }\n@@ -1032,27 +1035,3 @@ impl IdMap {\n         id\n     }\n }\n-\n-#[cfg(test)]\n-#[test]\n-fn test_unique_id() {\n-    let input = [\"foo\", \"examples\", \"examples\", \"method.into_iter\",\"examples\",\n-                 \"method.into_iter\", \"foo\", \"main\", \"search\", \"methods\",\n-                 \"examples\", \"method.into_iter\", \"assoc_type.Item\", \"assoc_type.Item\"];\n-    let expected = [\"foo\", \"examples\", \"examples-1\", \"method.into_iter\", \"examples-2\",\n-                    \"method.into_iter-1\", \"foo-1\", \"main\", \"search\", \"methods\",\n-                    \"examples-3\", \"method.into_iter-2\", \"assoc_type.Item\", \"assoc_type.Item-1\"];\n-\n-    let map = RefCell::new(IdMap::new());\n-    let test = || {\n-        let mut map = map.borrow_mut();\n-        let actual: Vec<String> = input.iter().map(|s| map.derive(s.to_string())).collect();\n-        assert_eq!(&actual[..], expected);\n-    };\n-    test();\n-    map.borrow_mut().reset();\n-    test();\n-}\n-\n-#[cfg(test)]\n-mod tests;"}, {"sha": "681f363544a615493e94121928c73c0a9520804d", "filename": "src/librustdoc/html/markdown/tests.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs?ref=a332e224a3bc2925fea584337d2d30e1186672be", "patch": "@@ -3,6 +3,26 @@ use super::plain_summary_line;\n use std::cell::RefCell;\n use syntax::edition::{Edition, DEFAULT_EDITION};\n \n+#[test]\n+fn test_unique_id() {\n+    let input = [\"foo\", \"examples\", \"examples\", \"method.into_iter\",\"examples\",\n+                 \"method.into_iter\", \"foo\", \"main\", \"search\", \"methods\",\n+                 \"examples\", \"method.into_iter\", \"assoc_type.Item\", \"assoc_type.Item\"];\n+    let expected = [\"foo\", \"examples\", \"examples-1\", \"method.into_iter\", \"examples-2\",\n+                    \"method.into_iter-1\", \"foo-1\", \"main\", \"search\", \"methods\",\n+                    \"examples-3\", \"method.into_iter-2\", \"assoc_type.Item\", \"assoc_type.Item-1\"];\n+\n+    let map = RefCell::new(IdMap::new());\n+    let test = || {\n+        let mut map = map.borrow_mut();\n+        let actual: Vec<String> = input.iter().map(|s| map.derive(s.to_string())).collect();\n+        assert_eq!(&actual[..], expected);\n+    };\n+    test();\n+    map.borrow_mut().reset();\n+    test();\n+}\n+\n #[test]\n fn test_lang_string_parse() {\n     fn t(s: &str,"}, {"sha": "c7bda534d07d683913fc3c18e5a4fcf0e6fa5f70", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 30, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=a332e224a3bc2925fea584337d2d30e1186672be", "patch": "@@ -75,6 +75,9 @@ use crate::html::{highlight, layout, static_files};\n \n use minifier;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// A pair of name and its optional document.\n pub type NameDoc = (String, Option<String>);\n \n@@ -5238,33 +5241,3 @@ fn get_generics(clean_type: &clean::Type) -> Option<Vec<String>> {\n pub fn cache() -> Arc<Cache> {\n     CACHE_KEY.with(|c| c.borrow().clone())\n }\n-\n-#[cfg(test)]\n-#[test]\n-fn test_name_key() {\n-    assert_eq!(name_key(\"0\"), (\"\", 0, 1));\n-    assert_eq!(name_key(\"123\"), (\"\", 123, 0));\n-    assert_eq!(name_key(\"Fruit\"), (\"Fruit\", 0, 0));\n-    assert_eq!(name_key(\"Fruit0\"), (\"Fruit\", 0, 1));\n-    assert_eq!(name_key(\"Fruit0000\"), (\"Fruit\", 0, 4));\n-    assert_eq!(name_key(\"Fruit01\"), (\"Fruit\", 1, 1));\n-    assert_eq!(name_key(\"Fruit10\"), (\"Fruit\", 10, 0));\n-    assert_eq!(name_key(\"Fruit123\"), (\"Fruit\", 123, 0));\n-}\n-\n-#[cfg(test)]\n-#[test]\n-fn test_name_sorting() {\n-    let names = [\"Apple\",\n-                 \"Banana\",\n-                 \"Fruit\", \"Fruit0\", \"Fruit00\",\n-                 \"Fruit1\", \"Fruit01\",\n-                 \"Fruit2\", \"Fruit02\",\n-                 \"Fruit20\",\n-                 \"Fruit30x\",\n-                 \"Fruit100\",\n-                 \"Pear\"];\n-    let mut sorted = names.to_owned();\n-    sorted.sort_by_key(|&s| name_key(s));\n-    assert_eq!(names, sorted);\n-}"}, {"sha": "1848b575e4d6730f573380a70972aab5ba3bf0a2", "filename": "src/librustdoc/html/render/tests.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs?ref=a332e224a3bc2925fea584337d2d30e1186672be", "patch": "@@ -0,0 +1,29 @@\n+use super::*;\n+\n+#[test]\n+fn test_name_key() {\n+    assert_eq!(name_key(\"0\"), (\"\", 0, 1));\n+    assert_eq!(name_key(\"123\"), (\"\", 123, 0));\n+    assert_eq!(name_key(\"Fruit\"), (\"Fruit\", 0, 0));\n+    assert_eq!(name_key(\"Fruit0\"), (\"Fruit\", 0, 1));\n+    assert_eq!(name_key(\"Fruit0000\"), (\"Fruit\", 0, 4));\n+    assert_eq!(name_key(\"Fruit01\"), (\"Fruit\", 1, 1));\n+    assert_eq!(name_key(\"Fruit10\"), (\"Fruit\", 10, 0));\n+    assert_eq!(name_key(\"Fruit123\"), (\"Fruit\", 123, 0));\n+}\n+\n+#[test]\n+fn test_name_sorting() {\n+    let names = [\"Apple\",\n+                 \"Banana\",\n+                 \"Fruit\", \"Fruit0\", \"Fruit00\",\n+                 \"Fruit1\", \"Fruit01\",\n+                 \"Fruit2\", \"Fruit02\",\n+                 \"Fruit20\",\n+                 \"Fruit30x\",\n+                 \"Fruit100\",\n+                 \"Pear\"];\n+    let mut sorted = names.to_owned();\n+    sorted.sort_by_key(|&s| name_key(s));\n+    assert_eq!(names, sorted);\n+}"}, {"sha": "7ad98242fdc92c285b714c61136f031bb3c144f4", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 3, "deletions": 76, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=a332e224a3bc2925fea584337d2d30e1186672be", "patch": "@@ -7,6 +7,9 @@ use crate::core::DocContext;\n use crate::fold::{self, DocFolder};\n use crate::passes::Pass;\n \n+#[cfg(test)]\n+mod tests;\n+\n pub const UNINDENT_COMMENTS: Pass = Pass {\n     name: \"unindent-comments\",\n     pass: unindent_comments,\n@@ -102,79 +105,3 @@ fn unindent(s: &str) -> String {\n         s.to_string()\n     }\n }\n-\n-#[cfg(test)]\n-mod unindent_tests {\n-    use super::unindent;\n-\n-    #[test]\n-    fn should_unindent() {\n-        let s = \"    line1\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_unindent_multiple_paragraphs() {\n-        let s = \"    line1\\n\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\n\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_leave_multiple_indent_levels() {\n-        // Line 2 is indented another level beyond the\n-        // base indentation and should be preserved\n-        let s = \"    line1\\n\\n        line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\n\\n    line2\");\n-    }\n-\n-    #[test]\n-    fn should_ignore_first_line_indent() {\n-        // The first line of the first paragraph may not be indented as\n-        // far due to the way the doc string was written:\n-        //\n-        // #[doc = \"Start way over here\n-        //          and continue here\"]\n-        let s = \"line1\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n-        let s = \"line1\\n\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\n\\n    line2\");\n-    }\n-\n-    #[test]\n-    fn should_unindent_tabs() {\n-        let s = \"\\tline1\\n\\tline2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_trim_mixed_indentation() {\n-        let s = \"\\t    line1\\n\\t    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-\n-        let s = \"    \\tline1\\n    \\tline2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_not_trim() {\n-        let s = \"\\t    line1  \\n\\t    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1  \\nline2\");\n-\n-        let s = \"    \\tline1  \\n    \\tline2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1  \\nline2\");\n-    }\n-}"}, {"sha": "c39c03e1249c61a760f07d150013d72e4a12148a", "filename": "src/librustdoc/passes/unindent_comments/tests.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Fpasses%2Funindent_comments%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Fpasses%2Funindent_comments%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments%2Ftests.rs?ref=a332e224a3bc2925fea584337d2d30e1186672be", "patch": "@@ -0,0 +1,72 @@\n+use super::*;\n+\n+#[test]\n+fn should_unindent() {\n+    let s = \"    line1\\n    line2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1\\nline2\");\n+}\n+\n+#[test]\n+fn should_unindent_multiple_paragraphs() {\n+    let s = \"    line1\\n\\n    line2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1\\n\\nline2\");\n+}\n+\n+#[test]\n+fn should_leave_multiple_indent_levels() {\n+    // Line 2 is indented another level beyond the\n+    // base indentation and should be preserved\n+    let s = \"    line1\\n\\n        line2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1\\n\\n    line2\");\n+}\n+\n+#[test]\n+fn should_ignore_first_line_indent() {\n+    // The first line of the first paragraph may not be indented as\n+    // far due to the way the doc string was written:\n+    //\n+    // #[doc = \"Start way over here\n+    //          and continue here\"]\n+    let s = \"line1\\n    line2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1\\nline2\");\n+}\n+\n+#[test]\n+fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n+    let s = \"line1\\n\\n    line2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1\\n\\n    line2\");\n+}\n+\n+#[test]\n+fn should_unindent_tabs() {\n+    let s = \"\\tline1\\n\\tline2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1\\nline2\");\n+}\n+\n+#[test]\n+fn should_trim_mixed_indentation() {\n+    let s = \"\\t    line1\\n\\t    line2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1\\nline2\");\n+\n+    let s = \"    \\tline1\\n    \\tline2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1\\nline2\");\n+}\n+\n+#[test]\n+fn should_not_trim() {\n+    let s = \"\\t    line1  \\n\\t    line2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1  \\nline2\");\n+\n+    let s = \"    \\tline1  \\n    \\tline2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1  \\nline2\");\n+}"}, {"sha": "7037a146c50ab23e566f86947b2a84499442e7cf", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 3, "deletions": 106, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=a332e224a3bc2925fea584337d2d30e1186672be", "patch": "@@ -5,6 +5,9 @@ use std::path::Path;\n \n use errors::Handler;\n \n+#[cfg(test)]\n+mod tests;\n+\n macro_rules! try_something {\n     ($e:expr, $diag:expr, $out:expr) => ({\n         match $e {\n@@ -275,109 +278,3 @@ pub fn test_theme_against<P: AsRef<Path>>(\n     get_differences(against, &paths, &mut ret);\n     (true, ret)\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-\n-    #[test]\n-    fn test_comments_in_rules() {\n-        let text = r#\"\n-rule a {}\n-\n-rule b, c\n-// a line comment\n-{}\n-\n-rule d\n-// another line comment\n-e {}\n-\n-rule f/* a multine\n-\n-comment*/{}\n-\n-rule g/* another multine\n-\n-comment*/h\n-\n-i {}\n-\n-rule j/*commeeeeent\n-\n-you like things like \"{}\" in there? :)\n-*/\n-end {}\"#;\n-\n-        let against = r#\"\n-rule a {}\n-\n-rule b, c {}\n-\n-rule d e {}\n-\n-rule f {}\n-\n-rule gh i {}\n-\n-rule j end {}\n-\"#;\n-\n-        let mut ret = Vec::new();\n-        get_differences(&load_css_paths(against.as_bytes()),\n-                        &load_css_paths(text.as_bytes()),\n-                        &mut ret);\n-        assert!(ret.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_text() {\n-        let text = r#\"\n-a\n-/* sdfs\n-*/ b\n-c // sdf\n-d {}\n-\"#;\n-        let paths = load_css_paths(text.as_bytes());\n-        assert!(paths.children.contains(&CssPath::new(\"a b c d\".to_owned())));\n-    }\n-\n-    #[test]\n-    fn test_comparison() {\n-        let x = r#\"\n-a {\n-    b {\n-        c {}\n-    }\n-}\n-\"#;\n-\n-        let y = r#\"\n-a {\n-    b {}\n-}\n-\"#;\n-\n-        let against = load_css_paths(y.as_bytes());\n-        let other = load_css_paths(x.as_bytes());\n-\n-        let mut ret = Vec::new();\n-        get_differences(&against, &other, &mut ret);\n-        assert!(ret.is_empty());\n-        get_differences(&other, &against, &mut ret);\n-        assert_eq!(ret, vec![\"  Missing \\\"c\\\" rule\".to_owned()]);\n-    }\n-\n-    #[test]\n-    fn check_empty_css() {\n-        let events = load_css_events(&[]);\n-        assert_eq!(events.len(), 0);\n-    }\n-\n-    #[test]\n-    fn check_invalid_css() {\n-        let events = load_css_events(b\"*\");\n-        assert_eq!(events.len(), 0);\n-    }\n-}"}, {"sha": "ab0935bc494261d95f6ef5efca3a80d46957b4f0", "filename": "src/librustdoc/theme/tests.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Ftheme%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a332e224a3bc2925fea584337d2d30e1186672be/src%2Flibrustdoc%2Ftheme%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme%2Ftests.rs?ref=a332e224a3bc2925fea584337d2d30e1186672be", "patch": "@@ -0,0 +1,102 @@\n+use super::*;\n+\n+#[test]\n+fn test_comments_in_rules() {\n+    let text = r#\"\n+rule a {}\n+\n+rule b, c\n+// a line comment\n+{}\n+\n+rule d\n+// another line comment\n+e {}\n+\n+rule f/* a multine\n+\n+comment*/{}\n+\n+rule g/* another multine\n+\n+comment*/h\n+\n+i {}\n+\n+rule j/*commeeeeent\n+\n+you like things like \"{}\" in there? :)\n+*/\n+end {}\"#;\n+\n+    let against = r#\"\n+rule a {}\n+\n+rule b, c {}\n+\n+rule d e {}\n+\n+rule f {}\n+\n+rule gh i {}\n+\n+rule j end {}\n+\"#;\n+\n+    let mut ret = Vec::new();\n+    get_differences(&load_css_paths(against.as_bytes()),\n+                    &load_css_paths(text.as_bytes()),\n+                    &mut ret);\n+    assert!(ret.is_empty());\n+}\n+\n+#[test]\n+fn test_text() {\n+    let text = r#\"\n+a\n+/* sdfs\n+*/ b\n+c // sdf\n+d {}\n+\"#;\n+    let paths = load_css_paths(text.as_bytes());\n+    assert!(paths.children.contains(&CssPath::new(\"a b c d\".to_owned())));\n+}\n+\n+#[test]\n+fn test_comparison() {\n+    let x = r#\"\n+a {\n+    b {\n+        c {}\n+    }\n+}\n+\"#;\n+\n+    let y = r#\"\n+a {\n+    b {}\n+}\n+\"#;\n+\n+    let against = load_css_paths(y.as_bytes());\n+    let other = load_css_paths(x.as_bytes());\n+\n+    let mut ret = Vec::new();\n+    get_differences(&against, &other, &mut ret);\n+    assert!(ret.is_empty());\n+    get_differences(&other, &against, &mut ret);\n+    assert_eq!(ret, vec![\"  Missing \\\"c\\\" rule\".to_owned()]);\n+}\n+\n+#[test]\n+fn check_empty_css() {\n+    let events = load_css_events(&[]);\n+    assert_eq!(events.len(), 0);\n+}\n+\n+#[test]\n+fn check_invalid_css() {\n+    let events = load_css_events(b\"*\");\n+    assert_eq!(events.len(), 0);\n+}"}, {"sha": "751b54e000af4d5e95de5a333b40b14c17ed7a9a", "filename": "src/tools/tidy/src/unit_tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a332e224a3bc2925fea584337d2d30e1186672be/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a332e224a3bc2925fea584337d2d30e1186672be/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs?ref=a332e224a3bc2925fea584337d2d30e1186672be", "patch": "@@ -27,7 +27,6 @@ pub fn check(root_path: &Path, bad: &mut bool) {\n     };\n     let fixme = [\n         \"liballoc\",\n-        \"librustdoc\",\n         \"libstd\",\n         \"libsyntax\",\n     ];"}]}