{"sha": "2d3a0a99279093e024c819dda826626a088bcd7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkM2EwYTk5Mjc5MDkzZTAyNGM4MTlkZGE4MjY2MjZhMDg4YmNkN2U=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-07-24T01:52:39Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-08-02T22:57:24Z"}, "message": "Generate self-profiler types with macros", "tree": {"sha": "0e50a37cc36c1ce7d5ef1cef2bee8720c08b6fa1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e50a37cc36c1ce7d5ef1cef2bee8720c08b6fa1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d3a0a99279093e024c819dda826626a088bcd7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d3a0a99279093e024c819dda826626a088bcd7e", "html_url": "https://github.com/rust-lang/rust/commit/2d3a0a99279093e024c819dda826626a088bcd7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d3a0a99279093e024c819dda826626a088bcd7e/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60c2e9a329f3e10fb87927a7af4393ffa9c3aa1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/60c2e9a329f3e10fb87927a7af4393ffa9c3aa1e", "html_url": "https://github.com/rust-lang/rust/commit/60c2e9a329f3e10fb87927a7af4393ffa9c3aa1e"}], "stats": {"total": 221, "additions": 91, "deletions": 130}, "files": [{"sha": "447b75e547f01d903c6fec73fe38aac2933fbb49", "filename": "src/librustc/util/profiling.rs", "status": "modified", "additions": 91, "deletions": 130, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a0a99279093e024c819dda826626a088bcd7e/src%2Flibrustc%2Futil%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a0a99279093e024c819dda826626a088bcd7e/src%2Flibrustc%2Futil%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fprofiling.rs?ref=2d3a0a99279093e024c819dda826626a088bcd7e", "patch": "@@ -14,152 +14,113 @@ use std::fs;\n use std::io::{self, StdoutLock, Write};\n use std::time::Instant;\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum ProfileCategory {\n-    Parsing,\n-    Expansion,\n-    TypeChecking,\n-    BorrowChecking,\n-    Codegen,\n-    Linking,\n-    Other,\n-}\n-\n-struct Categories<T> {\n-    parsing: T,\n-    expansion: T,\n-    type_checking: T,\n-    borrow_checking: T,\n-    codegen: T,\n-    linking: T,\n-    other: T,\n-}\n-\n-impl<T: Default> Categories<T> {\n-    fn new() -> Categories<T> {\n-        Categories {\n-            parsing: T::default(),\n-            expansion: T::default(),\n-            type_checking: T::default(),\n-            borrow_checking: T::default(),\n-            codegen: T::default(),\n-            linking: T::default(),\n-            other: T::default(),\n+macro_rules! define_categories {\n+    ($($name:ident,)*) => {\n+        #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+        pub enum ProfileCategory {\n+            $($name),*\n         }\n-    }\n-}\n \n-impl<T> Categories<T> {\n-    fn get(&self, category: ProfileCategory) -> &T {\n-        match category {\n-            ProfileCategory::Parsing => &self.parsing,\n-            ProfileCategory::Expansion => &self.expansion,\n-            ProfileCategory::TypeChecking => &self.type_checking,\n-            ProfileCategory::BorrowChecking => &self.borrow_checking,\n-            ProfileCategory::Codegen => &self.codegen,\n-            ProfileCategory::Linking => &self.linking,\n-            ProfileCategory::Other => &self.other,\n+        #[allow(bad_style)]\n+        struct Categories<T> {\n+            $($name: T),*\n         }\n-    }\n \n-    fn set(&mut self, category: ProfileCategory, value: T) {\n-        match category {\n-            ProfileCategory::Parsing => self.parsing = value,\n-            ProfileCategory::Expansion => self.expansion = value,\n-            ProfileCategory::TypeChecking => self.type_checking = value,\n-            ProfileCategory::BorrowChecking => self.borrow_checking = value,\n-            ProfileCategory::Codegen => self.codegen = value,\n-            ProfileCategory::Linking => self.linking = value,\n-            ProfileCategory::Other => self.other = value,\n+        impl<T: Default> Categories<T> {\n+            fn new() -> Categories<T> {\n+                Categories {\n+                    $($name: T::default()),*\n+                }\n+            }\n         }\n-    }\n-}\n \n-struct CategoryData {\n-    times: Categories<u64>,\n-    query_counts: Categories<(u64, u64)>,\n-}\n+        impl<T> Categories<T> {\n+            fn get(&self, category: ProfileCategory) -> &T {\n+                match category {\n+                    $(ProfileCategory::$name => &self.$name),*\n+                }\n+            }\n \n-impl CategoryData {\n-    fn new() -> CategoryData {\n-        CategoryData {\n-            times: Categories::new(),\n-            query_counts: Categories::new(),\n+            fn set(&mut self, category: ProfileCategory, value: T) {\n+                match category {\n+                    $(ProfileCategory::$name => self.$name = value),*\n+                }\n+            }\n         }\n-    }\n \n-    fn print(&self, lock: &mut StdoutLock) {\n-        macro_rules! p {\n-            ($name:tt, $rustic_name:ident) => {\n-                let (hits, total) = self.query_counts.$rustic_name;\n-                let (hits, total) = if total > 0 {\n-                    (format!(\"{:.2}\",\n-                     (((hits as f32) / (total as f32)) * 100.0)), total.to_string())\n-                } else {\n-                    (\"\".into(), \"\".into())\n-                };\n-\n-                writeln!(\n-                   lock,\n-                   \"| {0: <16} | {1: <14} | {2: <14} | {3: <8} |\",\n-                   $name,\n-                   self.times.$rustic_name / 1_000_000,\n-                   total,\n-                   hits\n-                ).unwrap();\n-            };\n+        struct CategoryData {\n+            times: Categories<u64>,\n+            query_counts: Categories<(u64, u64)>,\n         }\n \n-        writeln!(lock, \"| Phase            | Time (ms)      | Queries        | Hits (%) |\")\n-            .unwrap();\n-        writeln!(lock, \"| ---------------- | -------------- | -------------- | -------- |\")\n-            .unwrap();\n-\n-        p!(\"Parsing\", parsing);\n-        p!(\"Expansion\", expansion);\n-        p!(\"TypeChecking\", type_checking);\n-        p!(\"BorrowChecking\", borrow_checking);\n-        p!(\"Codegen\", codegen);\n-        p!(\"Linking\", linking);\n-        p!(\"Other\", other);\n-    }\n+        impl CategoryData {\n+            fn new() -> CategoryData {\n+                CategoryData {\n+                    times: Categories::new(),\n+                    query_counts: Categories::new(),\n+                }\n+            }\n \n-    fn json(&self) -> String {\n-        macro_rules! j {\n-            ($category:tt, $rustic_name:ident) => {{\n-                let (hits, total) = self.query_counts.$rustic_name;\n-\n-                format!(\n-                    \"{{ \\\"category\\\": {}, \\\"time_ms\\\": {},\n-                        \\\"query_count\\\": {}, \\\"query_hits\\\": {} }}\",\n-                    stringify!($category),\n-                    self.times.$rustic_name / 1_000_000,\n-                    total,\n-                    format!(\"{:.2}\", (((hits as f32) / (total as f32)) * 100.0))\n-                )\n-            }}\n-        }\n+            fn print(&self, lock: &mut StdoutLock) {\n+                writeln!(lock, \"| Phase            | Time (ms)      | Queries        | Hits (%) |\")\n+                    .unwrap();\n+                writeln!(lock, \"| ---------------- | -------------- | -------------- | -------- |\")\n+                    .unwrap();\n+\n+                $(\n+                    let (hits, total) = self.query_counts.$name;\n+                    let (hits, total) = if total > 0 {\n+                        (format!(\"{:.2}\",\n+                        (((hits as f32) / (total as f32)) * 100.0)), total.to_string())\n+                    } else {\n+                        (\"\".into(), \"\".into())\n+                    };\n+\n+                    writeln!(\n+                        lock,\n+                        \"| {0: <16} | {1: <14} | {2: <14} | {3: <8} |\",\n+                        stringify!($name),\n+                        self.times.$name / 1_000_000,\n+                        total,\n+                        hits\n+                    ).unwrap();\n+                )*\n+            }\n \n-        format!(\"[\n-            {},\n-            {},\n-            {},\n-            {},\n-            {},\n-            {},\n-            {}\n-        ]\",\n-            j!(\"Parsing\", parsing),\n-            j!(\"Expansion\", expansion),\n-            j!(\"TypeChecking\", type_checking),\n-            j!(\"BorrowChecking\", borrow_checking),\n-            j!(\"Codegen\", codegen),\n-            j!(\"Linking\", linking),\n-            j!(\"Other\", other)\n-        )\n+            fn json(&self) -> String {\n+                let mut json = String::from(\"[\");\n+\n+                $(\n+                    let (hits, total) = self.query_counts.$name;\n+\n+                    json.push_str(&format!(\n+                        \"{{ \\\"category\\\": {}, \\\"time_ms\\\": {},\n+                            \\\"query_count\\\": {}, \\\"query_hits\\\": {} }}\",\n+                        stringify!($name),\n+                        self.times.$name / 1_000_000,\n+                        total,\n+                        format!(\"{:.2}\", (((hits as f32) / (total as f32)) * 100.0))\n+                    ));\n+                )*\n+\n+                json.push(']');\n+\n+                json\n+            }\n+        }\n     }\n }\n \n+define_categories! {\n+    Parsing,\n+    Expansion,\n+    TypeChecking,\n+    BorrowChecking,\n+    Codegen,\n+    Linking,\n+    Other,\n+}\n+\n pub struct SelfProfiler {\n     timer_stack: Vec<ProfileCategory>,\n     data: CategoryData,"}]}