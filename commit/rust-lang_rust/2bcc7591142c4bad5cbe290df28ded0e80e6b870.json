{"sha": "2bcc7591142c4bad5cbe290df28ded0e80e6b870", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiY2M3NTkxMTQyYzRiYWQ1Y2JlMjkwZGYyOGRlZDBlODBlNmI4NzA=", "commit": {"author": {"name": "Fabian Wolff", "email": "fabian.wolff@alumni.ethz.ch", "date": "2021-05-21T14:56:45Z"}, "committer": {"name": "Fabian Wolff", "email": "fabian.wolff@alumni.ethz.ch", "date": "2021-05-21T16:30:36Z"}, "message": "Warn about unreachable code following an expression with an uninhabited type", "tree": {"sha": "5a8c8ec64c0b650df4ea4f84777313eea544dfd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a8c8ec64c0b650df4ea4f84777313eea544dfd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bcc7591142c4bad5cbe290df28ded0e80e6b870", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bcc7591142c4bad5cbe290df28ded0e80e6b870", "html_url": "https://github.com/rust-lang/rust/commit/2bcc7591142c4bad5cbe290df28ded0e80e6b870", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bcc7591142c4bad5cbe290df28ded0e80e6b870/comments", "author": {"login": "FabianWolff", "id": 16052130, "node_id": "MDQ6VXNlcjE2MDUyMTMw", "avatar_url": "https://avatars.githubusercontent.com/u/16052130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/FabianWolff", "html_url": "https://github.com/FabianWolff", "followers_url": "https://api.github.com/users/FabianWolff/followers", "following_url": "https://api.github.com/users/FabianWolff/following{/other_user}", "gists_url": "https://api.github.com/users/FabianWolff/gists{/gist_id}", "starred_url": "https://api.github.com/users/FabianWolff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/FabianWolff/subscriptions", "organizations_url": "https://api.github.com/users/FabianWolff/orgs", "repos_url": "https://api.github.com/users/FabianWolff/repos", "events_url": "https://api.github.com/users/FabianWolff/events{/privacy}", "received_events_url": "https://api.github.com/users/FabianWolff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "FabianWolff", "id": 16052130, "node_id": "MDQ6VXNlcjE2MDUyMTMw", "avatar_url": "https://avatars.githubusercontent.com/u/16052130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/FabianWolff", "html_url": "https://github.com/FabianWolff", "followers_url": "https://api.github.com/users/FabianWolff/followers", "following_url": "https://api.github.com/users/FabianWolff/following{/other_user}", "gists_url": "https://api.github.com/users/FabianWolff/gists{/gist_id}", "starred_url": "https://api.github.com/users/FabianWolff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/FabianWolff/subscriptions", "organizations_url": "https://api.github.com/users/FabianWolff/orgs", "repos_url": "https://api.github.com/users/FabianWolff/repos", "events_url": "https://api.github.com/users/FabianWolff/events{/privacy}", "received_events_url": "https://api.github.com/users/FabianWolff/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "237b1ef0b9147eb4d66220c589c39009bd79784f", "url": "https://api.github.com/repos/rust-lang/rust/commits/237b1ef0b9147eb4d66220c589c39009bd79784f", "html_url": "https://github.com/rust-lang/rust/commit/237b1ef0b9147eb4d66220c589c39009bd79784f"}], "stats": {"total": 220, "additions": 200, "deletions": 20}, "files": [{"sha": "80c1bd7a5f5f31a90c1cebc38ddb4b281a9a5e6c", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 91, "deletions": 20, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/2bcc7591142c4bad5cbe290df28ded0e80e6b870/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcc7591142c4bad5cbe290df28ded0e80e6b870/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=2bcc7591142c4bad5cbe290df28ded0e80e6b870", "patch": "@@ -95,7 +95,7 @@ use rustc_hir::{Expr, HirId, HirIdMap, HirIdSet};\n use rustc_index::vec::IndexVec;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, DefIdTree, RootVariableMinCaptureList, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, RootVariableMinCaptureList, Ty, TyCtxt};\n use rustc_session::lint;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n@@ -123,8 +123,8 @@ rustc_index::newtype_index! {\n #[derive(Copy, Clone, PartialEq, Debug)]\n enum LiveNodeKind {\n     UpvarNode(Span),\n-    ExprNode(Span),\n-    VarDefNode(Span),\n+    ExprNode(Span, HirId),\n+    VarDefNode(Span, HirId),\n     ClosureNode,\n     ExitNode,\n }\n@@ -133,8 +133,8 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_>) -> String {\n     let sm = tcx.sess.source_map();\n     match lnk {\n         UpvarNode(s) => format!(\"Upvar node [{}]\", sm.span_to_diagnostic_string(s)),\n-        ExprNode(s) => format!(\"Expr node [{}]\", sm.span_to_diagnostic_string(s)),\n-        VarDefNode(s) => format!(\"Var def node [{}]\", sm.span_to_diagnostic_string(s)),\n+        ExprNode(s, _) => format!(\"Expr node [{}]\", sm.span_to_diagnostic_string(s)),\n+        VarDefNode(s, _) => format!(\"Var def node [{}]\", sm.span_to_diagnostic_string(s)),\n         ClosureNode => \"Closure node\".to_owned(),\n         ExitNode => \"Exit node\".to_owned(),\n     }\n@@ -297,7 +297,7 @@ impl IrMaps<'tcx> {\n         }\n \n         pat.each_binding(|_, hir_id, _, ident| {\n-            self.add_live_node_for_node(hir_id, VarDefNode(ident.span));\n+            self.add_live_node_for_node(hir_id, VarDefNode(ident.span, hir_id));\n             self.add_variable(Local(LocalInfo {\n                 id: hir_id,\n                 name: ident.name,\n@@ -391,14 +391,14 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 debug!(\"expr {}: path that leads to {:?}\", expr.hir_id, path.res);\n                 if let Res::Local(_var_hir_id) = path.res {\n-                    self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+                    self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span, expr.hir_id));\n                 }\n                 intravisit::walk_expr(self, expr);\n             }\n             hir::ExprKind::Closure(..) => {\n                 // Interesting control flow (for loops can contain labeled\n                 // breaks or continues)\n-                self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+                self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span, expr.hir_id));\n \n                 // Make a live_node for each captured variable, with the span\n                 // being the location that the variable is used.  This results\n@@ -426,11 +426,11 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n \n             // live nodes required for interesting control flow:\n             hir::ExprKind::If(..) | hir::ExprKind::Match(..) | hir::ExprKind::Loop(..) => {\n-                self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+                self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span, expr.hir_id));\n                 intravisit::walk_expr(self, expr);\n             }\n             hir::ExprKind::Binary(op, ..) if op.node.is_lazy() => {\n-                self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+                self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span, expr.hir_id));\n                 intravisit::walk_expr(self, expr);\n             }\n \n@@ -978,11 +978,26 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::Call(ref f, ref args) => {\n                 let m = self.ir.tcx.parent_module(expr.hir_id).to_def_id();\n-                let succ = if self.ir.tcx.is_ty_uninhabited_from(\n-                    m,\n-                    self.typeck_results.expr_ty(expr),\n-                    self.param_env,\n-                ) {\n+                let ty = self.typeck_results.expr_ty(expr);\n+                let succ = if self.ir.tcx.is_ty_uninhabited_from(m, ty, self.param_env) {\n+                    if let LiveNodeKind::ExprNode(succ_span, succ_id) = self.ir.lnks[succ] {\n+                        self.warn_about_unreachable(\n+                            expr.span,\n+                            ty,\n+                            succ_span,\n+                            succ_id,\n+                            \"expression\",\n+                        );\n+                    } else if let LiveNodeKind::VarDefNode(succ_span, succ_id) = self.ir.lnks[succ]\n+                    {\n+                        self.warn_about_unreachable(\n+                            expr.span,\n+                            ty,\n+                            succ_span,\n+                            succ_id,\n+                            \"definition\",\n+                        );\n+                    }\n                     self.exit_ln\n                 } else {\n                     succ\n@@ -993,11 +1008,26 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::MethodCall(.., ref args, _) => {\n                 let m = self.ir.tcx.parent_module(expr.hir_id).to_def_id();\n-                let succ = if self.ir.tcx.is_ty_uninhabited_from(\n-                    m,\n-                    self.typeck_results.expr_ty(expr),\n-                    self.param_env,\n-                ) {\n+                let ty = self.typeck_results.expr_ty(expr);\n+                let succ = if self.ir.tcx.is_ty_uninhabited_from(m, ty, self.param_env) {\n+                    if let LiveNodeKind::ExprNode(succ_span, succ_id) = self.ir.lnks[succ] {\n+                        self.warn_about_unreachable(\n+                            expr.span,\n+                            ty,\n+                            succ_span,\n+                            succ_id,\n+                            \"expression\",\n+                        );\n+                    } else if let LiveNodeKind::VarDefNode(succ_span, succ_id) = self.ir.lnks[succ]\n+                    {\n+                        self.warn_about_unreachable(\n+                            expr.span,\n+                            ty,\n+                            succ_span,\n+                            succ_id,\n+                            \"definition\",\n+                        );\n+                    }\n                     self.exit_ln\n                 } else {\n                     succ\n@@ -1274,6 +1304,47 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         ln\n     }\n+\n+    fn warn_about_unreachable(\n+        &mut self,\n+        orig_span: Span,\n+        orig_ty: Ty<'tcx>,\n+        expr_span: Span,\n+        expr_id: HirId,\n+        descr: &str,\n+    ) {\n+        if !orig_ty.is_never() {\n+            // Unreachable code warnings are already emitted during type checking.\n+            // However, during type checking, full type information is being\n+            // calculated but not yet available, so the check for diverging\n+            // expressions due to uninhabited result types is pretty crude and\n+            // only checks whether ty.is_never(). Here, we have full type\n+            // information available and can issue warnings for less obviously\n+            // uninhabited types (e.g. empty enums). The check above is used so\n+            // that we do not emit the same warning twice if the uninhabited type\n+            // is indeed `!`.\n+\n+            self.ir.tcx.struct_span_lint_hir(\n+                lint::builtin::UNREACHABLE_CODE,\n+                expr_id,\n+                expr_span,\n+                |lint| {\n+                    let msg = format!(\"unreachable {}\", descr);\n+                    lint.build(&msg)\n+                        .span_label(expr_span, &msg)\n+                        .span_label(orig_span, \"any code following this expression is unreachable\")\n+                        .span_note(\n+                            orig_span,\n+                            &format!(\n+                                \"this expression has type `{}`, which is uninhabited\",\n+                                orig_ty\n+                            ),\n+                        )\n+                        .emit();\n+                },\n+            );\n+        }\n+    }\n }\n \n // _______________________________________________________________________"}, {"sha": "f0639931c84f3b5e2aa1f45735766c5c27d464fc", "filename": "src/test/ui/lint/dead-code/issue-85071-2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2bcc7591142c4bad5cbe290df28ded0e80e6b870/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcc7591142c4bad5cbe290df28ded0e80e6b870/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071-2.rs?ref=2bcc7591142c4bad5cbe290df28ded0e80e6b870", "patch": "@@ -0,0 +1,22 @@\n+// A slight variation of issue-85071.rs. Here, a method is called instead\n+// of a function, and the warning is about an unreachable definition\n+// instead of an unreachable expression.\n+\n+// check-pass\n+\n+#![warn(unused_variables,unreachable_code)]\n+\n+enum Foo {}\n+\n+struct S;\n+impl S {\n+    fn f(&self) -> Foo {todo!()}\n+}\n+\n+fn main() {\n+    let s = S;\n+    let x = s.f();\n+    //~^ WARNING: unused variable: `x`\n+    let _y = x;\n+    //~^ WARNING: unreachable definition\n+}"}, {"sha": "86fbd1d75e89ff1a5565cd7c89237302dfce967a", "filename": "src/test/ui/lint/dead-code/issue-85071-2.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2bcc7591142c4bad5cbe290df28ded0e80e6b870/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bcc7591142c4bad5cbe290df28ded0e80e6b870/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071-2.stderr?ref=2bcc7591142c4bad5cbe290df28ded0e80e6b870", "patch": "@@ -0,0 +1,34 @@\n+warning: unreachable definition\n+  --> $DIR/issue-85071-2.rs:20:9\n+   |\n+LL |     let x = s.f();\n+   |             ----- any code following this expression is unreachable\n+LL |\n+LL |     let _y = x;\n+   |         ^^ unreachable definition\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-85071-2.rs:7:26\n+   |\n+LL | #![warn(unused_variables,unreachable_code)]\n+   |                          ^^^^^^^^^^^^^^^^\n+note: this expression has type `Foo`, which is uninhabited\n+  --> $DIR/issue-85071-2.rs:18:13\n+   |\n+LL |     let x = s.f();\n+   |             ^^^^^\n+\n+warning: unused variable: `x`\n+  --> $DIR/issue-85071-2.rs:18:9\n+   |\n+LL |     let x = s.f();\n+   |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-85071-2.rs:7:9\n+   |\n+LL | #![warn(unused_variables,unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "d6969321cad4b5e7a1a37e2ee8dfdd787b4cd48b", "filename": "src/test/ui/lint/dead-code/issue-85071.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2bcc7591142c4bad5cbe290df28ded0e80e6b870/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcc7591142c4bad5cbe290df28ded0e80e6b870/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071.rs?ref=2bcc7591142c4bad5cbe290df28ded0e80e6b870", "patch": "@@ -0,0 +1,19 @@\n+// Checks that an unreachable code warning is emitted when an expression is\n+// preceded by an expression with an uninhabited type. Previously, the\n+// variable liveness analysis was \"smarter\" than the reachability analysis\n+// in this regard, which led to confusing \"unused variable\" warnings\n+// without an accompanying explanatory \"unreachable expression\" warning.\n+\n+// check-pass\n+\n+#![warn(unused_variables,unreachable_code)]\n+\n+enum Foo {}\n+fn f() -> Foo {todo!()}\n+\n+fn main() {\n+    let x = f();\n+    //~^ WARNING: unused variable: `x`\n+    let _ = x;\n+    //~^ WARNING: unreachable expression\n+}"}, {"sha": "49555fdaa3595553297ce2b37dd0f234c05837bd", "filename": "src/test/ui/lint/dead-code/issue-85071.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2bcc7591142c4bad5cbe290df28ded0e80e6b870/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bcc7591142c4bad5cbe290df28ded0e80e6b870/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071.stderr?ref=2bcc7591142c4bad5cbe290df28ded0e80e6b870", "patch": "@@ -0,0 +1,34 @@\n+warning: unreachable expression\n+  --> $DIR/issue-85071.rs:17:13\n+   |\n+LL |     let x = f();\n+   |             --- any code following this expression is unreachable\n+LL |\n+LL |     let _ = x;\n+   |             ^ unreachable expression\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-85071.rs:9:26\n+   |\n+LL | #![warn(unused_variables,unreachable_code)]\n+   |                          ^^^^^^^^^^^^^^^^\n+note: this expression has type `Foo`, which is uninhabited\n+  --> $DIR/issue-85071.rs:15:13\n+   |\n+LL |     let x = f();\n+   |             ^^^\n+\n+warning: unused variable: `x`\n+  --> $DIR/issue-85071.rs:15:9\n+   |\n+LL |     let x = f();\n+   |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-85071.rs:9:9\n+   |\n+LL | #![warn(unused_variables,unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+warning: 2 warnings emitted\n+"}]}