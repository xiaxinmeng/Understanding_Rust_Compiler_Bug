{"sha": "4d1076c9f918297c97300a7ecf769dd7e6780be6", "node_id": "C_kwDOAAsO6NoAKDRkMTA3NmM5ZjkxODI5N2M5NzMwMGE3ZWNmNzY5ZGQ3ZTY3ODBiZTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-08T00:57:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-08T00:57:08Z"}, "message": "Auto merge of #94206 - PrestonFrom:significant_drop, r=flip1995\n\nCreate clippy lint against unexpectedly late drop for temporaries in match scrutinee expressions\n\nA new clippy lint for issue 93883 (https://github.com/rust-lang/rust/issues/93883). Relies on a new trait in `marker` (called `SignificantDrop` to enable linting), which is why this PR is for the rust-lang repo and not the clippy repo.\n\nchangelog: new lint [`significant_drop_in_scrutinee`]", "tree": {"sha": "e05ffd8d49aa8ac2c57c39a61a616a1422f0d505", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e05ffd8d49aa8ac2c57c39a61a616a1422f0d505"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d1076c9f918297c97300a7ecf769dd7e6780be6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d1076c9f918297c97300a7ecf769dd7e6780be6", "html_url": "https://github.com/rust-lang/rust/commit/4d1076c9f918297c97300a7ecf769dd7e6780be6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d1076c9f918297c97300a7ecf769dd7e6780be6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e612ce9ce50182fb33a5186fbb39cdd5d4534f1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e612ce9ce50182fb33a5186fbb39cdd5d4534f1f", "html_url": "https://github.com/rust-lang/rust/commit/e612ce9ce50182fb33a5186fbb39cdd5d4534f1f"}, {"sha": "d9e963fba027ee9f5670ce1953df0ebde0e51da4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9e963fba027ee9f5670ce1953df0ebde0e51da4", "html_url": "https://github.com/rust-lang/rust/commit/d9e963fba027ee9f5670ce1953df0ebde0e51da4"}], "stats": {"total": 1204, "additions": 1204, "deletions": 0}, "files": [{"sha": "aacc893ba06468e6f7e2e54e125495c3b1cd4f0b", "filename": "library/std/src/sync/mutex.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d1076c9f918297c97300a7ecf769dd7e6780be6/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1076c9f918297c97300a7ecf769dd7e6780be6/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs?ref=4d1076c9f918297c97300a7ecf769dd7e6780be6", "patch": "@@ -192,6 +192,7 @@ unsafe impl<T: ?Sized + Send> Sync for Mutex<T> {}\n                       points can cause deadlocks, delays, \\\n                       and cause Futures to not implement `Send`\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[clippy::has_significant_drop]\n pub struct MutexGuard<'a, T: ?Sized + 'a> {\n     lock: &'a Mutex<T>,\n     poison: poison::Guard,"}, {"sha": "9ec0903f037ccf9c40ad24264abaee9f076552db", "filename": "library/std/src/sync/rwlock.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1076c9f918297c97300a7ecf769dd7e6780be6/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1076c9f918297c97300a7ecf769dd7e6780be6/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs?ref=4d1076c9f918297c97300a7ecf769dd7e6780be6", "patch": "@@ -99,6 +99,7 @@ unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}\n                       points can cause deadlocks, delays, \\\n                       and cause Futures to not implement `Send`\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[clippy::has_significant_drop]\n pub struct RwLockReadGuard<'a, T: ?Sized + 'a> {\n     lock: &'a RwLock<T>,\n }\n@@ -122,6 +123,7 @@ unsafe impl<T: ?Sized + Sync> Sync for RwLockReadGuard<'_, T> {}\n                       points can cause deadlocks, delays, \\\n                       and cause Future's to not implement `Send`\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[clippy::has_significant_drop]\n pub struct RwLockWriteGuard<'a, T: ?Sized + 'a> {\n     lock: &'a RwLock<T>,\n     poison: poison::Guard,"}, {"sha": "d25ad0ac6fa16806f92561934b9735a2ddb64c5a", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d1076c9f918297c97300a7ecf769dd7e6780be6/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d1076c9f918297c97300a7ecf769dd7e6780be6/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=4d1076c9f918297c97300a7ecf769dd7e6780be6", "patch": "@@ -3696,6 +3696,7 @@ Released 2018-09-13\n [`skip_while_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#skip_while_next\n [`slow_vector_initialization`]: https://rust-lang.github.io/rust-clippy/master/index.html#slow_vector_initialization\n [`stable_sort_primitive`]: https://rust-lang.github.io/rust-clippy/master/index.html#stable_sort_primitive\n+[`significant_drop_in_scrutinee`]: https://rust-lang.github.io/rust-clippy/master/index.html#significant_drop_in_scrutinee\n [`str_to_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#str_to_string\n [`string_add`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_add\n [`string_add_assign`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_add_assign"}, {"sha": "c888a5feda2aeff8aa9a24951c2e66928682d3b5", "filename": "src/tools/clippy/clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d1076c9f918297c97300a7ecf769dd7e6780be6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1076c9f918297c97300a7ecf769dd7e6780be6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs?ref=4d1076c9f918297c97300a7ecf769dd7e6780be6", "patch": "@@ -475,6 +475,7 @@ store.register_lints(&[\n     size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT,\n     slow_vector_initialization::SLOW_VECTOR_INITIALIZATION,\n     stable_sort_primitive::STABLE_SORT_PRIMITIVE,\n+    significant_drop_in_scrutinee::SIGNIFICANT_DROP_IN_SCRUTINEE,\n     strings::STRING_ADD,\n     strings::STRING_ADD_ASSIGN,\n     strings::STRING_FROM_UTF8_AS_BYTES,"}, {"sha": "d43c7e03533c72182092c58336a3509abdb806bf", "filename": "src/tools/clippy/clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d1076c9f918297c97300a7ecf769dd7e6780be6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1076c9f918297c97300a7ecf769dd7e6780be6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=4d1076c9f918297c97300a7ecf769dd7e6780be6", "patch": "@@ -25,6 +25,7 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE),\n     LintId::of(redundant_pub_crate::REDUNDANT_PUB_CRATE),\n     LintId::of(regex::TRIVIAL_REGEX),\n+    LintId::of(significant_drop_in_scrutinee::SIGNIFICANT_DROP_IN_SCRUTINEE),\n     LintId::of(strings::STRING_LIT_AS_BYTES),\n     LintId::of(suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS),\n     LintId::of(trailing_empty_array::TRAILING_EMPTY_ARRAY),"}, {"sha": "09071a255c5e68ef0f94862dbe09afbeae472489", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1076c9f918297c97300a7ecf769dd7e6780be6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1076c9f918297c97300a7ecf769dd7e6780be6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=4d1076c9f918297c97300a7ecf769dd7e6780be6", "patch": "@@ -364,6 +364,7 @@ mod self_named_constructors;\n mod semicolon_if_nothing_returned;\n mod serde_api;\n mod shadow;\n+mod significant_drop_in_scrutinee;\n mod single_char_lifetime_names;\n mod single_component_path_imports;\n mod size_of_in_element_count;\n@@ -874,6 +875,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(manual_bits::ManualBits::new(msrv)));\n     store.register_late_pass(|| Box::new(default_union_representation::DefaultUnionRepresentation));\n     store.register_late_pass(|| Box::new(only_used_in_recursion::OnlyUsedInRecursion));\n+    store.register_late_pass(|| Box::new(significant_drop_in_scrutinee::SignificantDropInScrutinee));\n     store.register_late_pass(|| Box::new(dbg_macro::DbgMacro));\n     let cargo_ignore_publish = conf.cargo_ignore_publish;\n     store.register_late_pass(move || {"}, {"sha": "94ae0c8f5a65909b68f179dba39a051ef40b861a", "filename": "src/tools/clippy/clippy_lints/src/significant_drop_in_scrutinee.rs", "status": "added", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/4d1076c9f918297c97300a7ecf769dd7e6780be6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsignificant_drop_in_scrutinee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1076c9f918297c97300a7ecf769dd7e6780be6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsignificant_drop_in_scrutinee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsignificant_drop_in_scrutinee.rs?ref=4d1076c9f918297c97300a7ecf769dd7e6780be6", "patch": "@@ -0,0 +1,408 @@\n+use crate::FxHashSet;\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::get_attr;\n+use clippy_utils::source::{indent_of, snippet};\n+use rustc_errors::{Applicability, Diagnostic};\n+use rustc_hir::intravisit::{walk_expr, Visitor};\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::{Ty, TypeAndMut};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Check for temporaries returned from function calls in a match scrutinee that have the\n+    /// `clippy::has_significant_drop` attribute.\n+    ///\n+    /// ### Why is this bad?\n+    /// The `clippy::has_significant_drop` attribute can be added to types whose Drop impls have\n+    /// an important side-effect, such as unlocking a mutex, making it important for users to be\n+    /// able to accurately understand their lifetimes. When a temporary is returned in a function\n+    /// call in a match scrutinee, its lifetime lasts until the end of the match block, which may\n+    /// be surprising.\n+    ///\n+    /// For `Mutex`es this can lead to a deadlock. This happens when the match scrutinee uses a\n+    /// function call that returns a `MutexGuard` and then tries to lock again in one of the match\n+    /// arms. In that case the `MutexGuard` in the scrutinee will not be dropped until the end of\n+    /// the match block and thus will not unlock.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::sync::Mutex;\n+    ///\n+    /// # struct State {}\n+    ///\n+    /// # impl State {\n+    /// #     fn foo(&self) -> bool {\n+    /// #         true\n+    /// #     }\n+    ///\n+    /// #     fn bar(&self) {}\n+    /// # }\n+    ///\n+    ///\n+    /// let mutex = Mutex::new(State {});\n+    ///\n+    /// match mutex.lock().unwrap().foo() {\n+    ///     true => {\n+    ///         mutex.lock().unwrap().bar(); // Deadlock!\n+    ///     }\n+    ///     false => {}\n+    /// };\n+    ///\n+    /// println!(\"All done!\");\n+    ///\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::sync::Mutex;\n+    ///\n+    /// # struct State {}\n+    ///\n+    /// # impl State {\n+    /// #     fn foo(&self) -> bool {\n+    /// #         true\n+    /// #     }\n+    ///\n+    /// #     fn bar(&self) {}\n+    /// # }\n+    ///\n+    /// let mutex = Mutex::new(State {});\n+    ///\n+    /// let is_foo = mutex.lock().unwrap().foo();\n+    /// match is_foo {\n+    ///     true => {\n+    ///         mutex.lock().unwrap().bar();\n+    ///     }\n+    ///     false => {}\n+    /// };\n+    ///\n+    /// println!(\"All done!\");\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub SIGNIFICANT_DROP_IN_SCRUTINEE,\n+    nursery,\n+    \"warns when a temporary of a type with a drop with a significant side-effect might have a surprising lifetime\"\n+}\n+\n+declare_lint_pass!(SignificantDropInScrutinee => [SIGNIFICANT_DROP_IN_SCRUTINEE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for SignificantDropInScrutinee {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        if let Some(suggestions) = has_significant_drop_in_scrutinee(cx, expr) {\n+            for found in suggestions {\n+                span_lint_and_then(\n+                    cx,\n+                    SIGNIFICANT_DROP_IN_SCRUTINEE,\n+                    found.found_span,\n+                    \"temporary with significant drop in match scrutinee\",\n+                    |diag| set_diagnostic(diag, cx, expr, found),\n+                )\n+            }\n+        }\n+    }\n+}\n+\n+fn set_diagnostic<'tcx>(diag: &mut Diagnostic, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, found: FoundSigDrop) {\n+    if found.lint_suggestion == LintSuggestion::MoveAndClone {\n+        // If our suggestion is to move and clone, then we want to leave it to the user to\n+        // decide how to address this lint, since it may be that cloning is inappropriate.\n+        // Therefore, we won't to emit a suggestion.\n+        return;\n+    }\n+\n+    let original = snippet(cx, found.found_span, \"..\");\n+    let trailing_indent = \" \".repeat(indent_of(cx, found.found_span).unwrap_or(0));\n+\n+    let replacement = if found.lint_suggestion == LintSuggestion::MoveAndDerefToCopy {\n+        format!(\"let value = *{};\\n{}\", original, trailing_indent)\n+    } else if found.is_unit_return_val {\n+        // If the return value of the expression to be moved is unit, then we don't need to\n+        // capture the result in a temporary -- we can just replace it completely with `()`.\n+        format!(\"{};\\n{}\", original, trailing_indent)\n+    } else {\n+        format!(\"let value = {};\\n{}\", original, trailing_indent)\n+    };\n+\n+    let suggestion_message = if found.lint_suggestion == LintSuggestion::MoveOnly {\n+        \"try moving the temporary above the match\"\n+    } else {\n+        \"try moving the temporary above the match and create a copy\"\n+    };\n+\n+    let scrutinee_replacement = if found.is_unit_return_val {\n+        \"()\".to_owned()\n+    } else {\n+        \"value\".to_owned()\n+    };\n+\n+    diag.multipart_suggestion(\n+        suggestion_message,\n+        vec![\n+            (expr.span.shrink_to_lo(), replacement),\n+            (found.found_span, scrutinee_replacement),\n+        ],\n+        Applicability::MaybeIncorrect,\n+    );\n+}\n+\n+/// If the expression is an ExprKind::Match, check if the scrutinee has a significant drop that may\n+/// have a surprising lifetime.\n+fn has_significant_drop_in_scrutinee<'tcx, 'a>(\n+    cx: &'a LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+) -> Option<Vec<FoundSigDrop>> {\n+    let mut helper = SigDropHelper::new(cx);\n+    match expr.kind {\n+        ExprKind::Match(match_expr, _, _) => helper.find_sig_drop(match_expr),\n+        _ => None,\n+    }\n+}\n+\n+struct SigDropHelper<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    is_chain_end: bool,\n+    seen_types: FxHashSet<Ty<'tcx>>,\n+    has_significant_drop: bool,\n+    current_sig_drop: Option<FoundSigDrop>,\n+    sig_drop_spans: Option<Vec<FoundSigDrop>>,\n+    special_handling_for_binary_op: bool,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+enum LintSuggestion {\n+    MoveOnly,\n+    MoveAndDerefToCopy,\n+    MoveAndClone,\n+}\n+\n+#[derive(Clone, Copy)]\n+struct FoundSigDrop {\n+    found_span: Span,\n+    is_unit_return_val: bool,\n+    lint_suggestion: LintSuggestion,\n+}\n+\n+impl<'a, 'tcx> SigDropHelper<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>) -> SigDropHelper<'a, 'tcx> {\n+        SigDropHelper {\n+            cx,\n+            is_chain_end: true,\n+            seen_types: FxHashSet::default(),\n+            has_significant_drop: false,\n+            current_sig_drop: None,\n+            sig_drop_spans: None,\n+            special_handling_for_binary_op: false,\n+        }\n+    }\n+\n+    fn find_sig_drop(&mut self, match_expr: &'tcx Expr<'_>) -> Option<Vec<FoundSigDrop>> {\n+        self.visit_expr(match_expr);\n+\n+        // If sig drop spans is empty but we found a significant drop, it means that we didn't find\n+        // a type that was trivially copyable as we moved up the chain after finding a significant\n+        // drop, so move the entire scrutinee.\n+        if self.has_significant_drop && self.sig_drop_spans.is_none() {\n+            self.try_setting_current_suggestion(match_expr, true);\n+            self.move_current_suggestion();\n+        }\n+\n+        self.sig_drop_spans.take()\n+    }\n+\n+    /// This will try to set the current suggestion (so it can be moved into the suggestions vec\n+    /// later). If allow_move_and_clone is false, the suggestion *won't* be set -- this gives us\n+    /// an opportunity to look for another type in the chain that will be trivially copyable.\n+    /// However, if we are at the the end of the chain, we want to accept whatever is there. (The\n+    /// suggestion won't actually be output, but the diagnostic message will be output, so the user\n+    /// can determine the best way to handle the lint.)\n+    fn try_setting_current_suggestion(&mut self, expr: &'tcx Expr<'_>, allow_move_and_clone: bool) {\n+        if self.current_sig_drop.is_some() {\n+            return;\n+        }\n+        let ty = self.get_type(expr);\n+        if ty.is_ref() {\n+            // We checked that the type was ref, so builtin_deref will return Some TypeAndMut,\n+            // but let's avoid any chance of an ICE\n+            if let Some(TypeAndMut { ty, .. }) = ty.builtin_deref(true) {\n+                if ty.is_trivially_pure_clone_copy() {\n+                    self.current_sig_drop.replace(FoundSigDrop {\n+                        found_span: expr.span,\n+                        is_unit_return_val: false,\n+                        lint_suggestion: LintSuggestion::MoveAndDerefToCopy,\n+                    });\n+                } else if allow_move_and_clone {\n+                    self.current_sig_drop.replace(FoundSigDrop {\n+                        found_span: expr.span,\n+                        is_unit_return_val: false,\n+                        lint_suggestion: LintSuggestion::MoveAndClone,\n+                    });\n+                }\n+            }\n+        } else if ty.is_trivially_pure_clone_copy() {\n+            self.current_sig_drop.replace(FoundSigDrop {\n+                found_span: expr.span,\n+                is_unit_return_val: false,\n+                lint_suggestion: LintSuggestion::MoveOnly,\n+            });\n+        }\n+    }\n+\n+    fn move_current_suggestion(&mut self) {\n+        if let Some(current) = self.current_sig_drop.take() {\n+            self.sig_drop_spans.get_or_insert_with(Vec::new).push(current);\n+        }\n+    }\n+\n+    fn get_type(&self, ex: &'tcx Expr<'_>) -> Ty<'tcx> {\n+        self.cx.typeck_results().expr_ty(ex)\n+    }\n+\n+    fn has_seen_type(&mut self, ty: Ty<'tcx>) -> bool {\n+        !self.seen_types.insert(ty)\n+    }\n+\n+    fn visit_exprs_for_binary_ops(\n+        &mut self,\n+        left: &'tcx Expr<'_>,\n+        right: &'tcx Expr<'_>,\n+        is_unit_return_val: bool,\n+        span: Span,\n+    ) {\n+        self.special_handling_for_binary_op = true;\n+        self.visit_expr(left);\n+        self.visit_expr(right);\n+\n+        // If either side had a significant drop, suggest moving the entire scrutinee to avoid\n+        // unnecessary copies and to simplify cases where both sides have significant drops.\n+        if self.has_significant_drop {\n+            self.current_sig_drop.replace(FoundSigDrop {\n+                found_span: span,\n+                is_unit_return_val,\n+                lint_suggestion: LintSuggestion::MoveOnly,\n+            });\n+        }\n+\n+        self.special_handling_for_binary_op = false;\n+    }\n+\n+    fn has_sig_drop_attr(&mut self, cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+        if let Some(adt) = ty.ty_adt_def() {\n+            if get_attr(cx.sess(), cx.tcx.get_attrs(adt.did()), \"has_significant_drop\").count() > 0 {\n+                return true;\n+            }\n+        }\n+\n+        match ty.kind() {\n+            rustc_middle::ty::Adt(a, b) => {\n+                for f in a.all_fields() {\n+                    let ty = f.ty(cx.tcx, b);\n+                    if !self.has_seen_type(ty) && self.has_sig_drop_attr(cx, ty) {\n+                        return true;\n+                    }\n+                }\n+\n+                for generic_arg in b.iter() {\n+                    if let GenericArgKind::Type(ty) = generic_arg.unpack() {\n+                        if self.has_sig_drop_attr(cx, ty) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+                false\n+            },\n+            rustc_middle::ty::Array(ty, _) => self.has_sig_drop_attr(cx, *ty),\n+            rustc_middle::ty::RawPtr(TypeAndMut { ty, .. }) => self.has_sig_drop_attr(cx, *ty),\n+            rustc_middle::ty::Ref(_, ty, _) => self.has_sig_drop_attr(cx, *ty),\n+            rustc_middle::ty::Slice(ty) => self.has_sig_drop_attr(cx, *ty),\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for SigDropHelper<'a, 'tcx> {\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'_>) {\n+        if !self.is_chain_end && self.has_sig_drop_attr(self.cx, self.get_type(ex)) {\n+            self.has_significant_drop = true;\n+            return;\n+        }\n+        self.is_chain_end = false;\n+\n+        match ex.kind {\n+            ExprKind::MethodCall(_, [ref expr, ..], _) => {\n+                self.visit_expr(expr)\n+            }\n+            ExprKind::Binary(_, left, right) => {\n+                self.visit_exprs_for_binary_ops(left, right, false, ex.span);\n+            }\n+            ExprKind::Assign(left, right, _) => {\n+                self.visit_exprs_for_binary_ops(left, right, true, ex.span);\n+            }\n+            ExprKind::AssignOp(_, left, right) => {\n+                self.visit_exprs_for_binary_ops(left, right, true, ex.span);\n+            }\n+            ExprKind::Tup(exprs) => {\n+                for expr in exprs {\n+                    self.visit_expr(expr);\n+                    if self.has_significant_drop {\n+                        // We may have not have set current_sig_drop if all the suggestions were\n+                        // MoveAndClone, so add this tuple item's full expression in that case.\n+                        if self.current_sig_drop.is_none() {\n+                            self.try_setting_current_suggestion(expr, true);\n+                        }\n+\n+                        // Now we are guaranteed to have something, so add it to the final vec.\n+                        self.move_current_suggestion();\n+                    }\n+                    // Reset `has_significant_drop` after each tuple expression so we can look for\n+                    // additional cases.\n+                    self.has_significant_drop = false;\n+                }\n+                if self.sig_drop_spans.is_some() {\n+                    self.has_significant_drop = true;\n+                }\n+            }\n+            ExprKind::Box(..) |\n+                ExprKind::Array(..) |\n+                ExprKind::Call(..) |\n+                ExprKind::Unary(..) |\n+                ExprKind::If(..) |\n+                ExprKind::Match(..) |\n+                ExprKind::Field(..) |\n+                ExprKind::Index(..) |\n+                ExprKind::Ret(..) |\n+                ExprKind::Repeat(..) |\n+                ExprKind::Yield(..) |\n+                ExprKind::MethodCall(..) => walk_expr(self, ex),\n+            ExprKind::AddrOf(_, _, _) |\n+                ExprKind::Block(_, _) |\n+                ExprKind::Break(_, _) |\n+                ExprKind::Cast(_, _) |\n+                // Don't want to check the closure itself, only invocation, which is covered by MethodCall\n+                ExprKind::Closure(_, _, _, _, _) |\n+                ExprKind::ConstBlock(_) |\n+                ExprKind::Continue(_) |\n+                ExprKind::DropTemps(_) |\n+                ExprKind::Err |\n+                ExprKind::InlineAsm(_) |\n+                ExprKind::Let(_) |\n+                ExprKind::Lit(_) |\n+                ExprKind::Loop(_, _, _, _) |\n+                ExprKind::Path(_) |\n+                ExprKind::Struct(_, _, _) |\n+                ExprKind::Type(_, _) => {\n+                return;\n+            }\n+        }\n+\n+        // Once a significant temporary has been found, we need to go back up at least 1 level to\n+        // find the span to extract for replacement, so the temporary gets dropped. However, for\n+        // binary ops, we want to move the whole scrutinee so we avoid unnecessary copies and to\n+        // simplify cases where both sides have significant drops.\n+        if self.has_significant_drop && !self.special_handling_for_binary_op {\n+            self.try_setting_current_suggestion(ex, false);\n+        }\n+    }\n+}"}, {"sha": "7f448175e3267c7db0fb9e58ba735a40978efb86", "filename": "src/tools/clippy/clippy_utils/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d1076c9f918297c97300a7ecf769dd7e6780be6/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1076c9f918297c97300a7ecf769dd7e6780be6/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs?ref=4d1076c9f918297c97300a7ecf769dd7e6780be6", "patch": "@@ -22,6 +22,7 @@ pub const BUILTIN_ATTRIBUTES: &[(&str, DeprecationStatus)] = &[\n     (\"cyclomatic_complexity\", DeprecationStatus::Replaced(\"cognitive_complexity\")),\n     (\"dump\",                  DeprecationStatus::None),\n     (\"msrv\",                  DeprecationStatus::None),\n+    (\"has_significant_drop\",  DeprecationStatus::None),\n ];\n \n pub struct LimitStack {"}, {"sha": "c4a3301e72265779fbde2ec6b9b6d3909de4251b", "filename": "src/tools/clippy/tests/ui/significant_drop_in_scrutinee.rs", "status": "added", "additions": 526, "deletions": 0, "changes": 526, "blob_url": "https://github.com/rust-lang/rust/blob/4d1076c9f918297c97300a7ecf769dd7e6780be6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsignificant_drop_in_scrutinee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1076c9f918297c97300a7ecf769dd7e6780be6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsignificant_drop_in_scrutinee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsignificant_drop_in_scrutinee.rs?ref=4d1076c9f918297c97300a7ecf769dd7e6780be6", "patch": "@@ -0,0 +1,526 @@\n+// FIXME: Ideally these suggestions would be fixed via rustfix. Blocked by rust-lang/rust#53934\n+// // run-rustfix\n+\n+#![warn(clippy::significant_drop_in_scrutinee)]\n+#![allow(clippy::single_match)]\n+#![allow(clippy::match_single_binding)]\n+#![allow(unused_assignments)]\n+#![allow(dead_code)]\n+\n+use std::ops::Deref;\n+use std::sync::atomic::{AtomicU64, Ordering};\n+use std::sync::{Mutex, MutexGuard};\n+\n+struct State {}\n+\n+impl State {\n+    fn foo(&self) -> bool {\n+        true\n+    }\n+\n+    fn bar(&self) {}\n+}\n+\n+fn should_not_trigger_lint_with_mutex_guard_outside_match() {\n+    let mutex = Mutex::new(State {});\n+\n+    // Should not trigger lint because the temporary should drop at the `;` on line before the match\n+    let is_foo = mutex.lock().unwrap().foo();\n+    match is_foo {\n+        true => {\n+            mutex.lock().unwrap().bar();\n+        }\n+        false => {}\n+    };\n+}\n+\n+fn should_not_trigger_lint_with_mutex_guard_when_taking_ownership_in_match() {\n+    let mutex = Mutex::new(State {});\n+\n+    // Should not trigger lint because the scrutinee is explicitly returning the MutexGuard,\n+    // so its lifetime should not be surprising.\n+    match mutex.lock() {\n+        Ok(guard) => {\n+            guard.foo();\n+            mutex.lock().unwrap().bar();\n+        }\n+        _ => {}\n+    };\n+}\n+\n+fn should_trigger_lint_with_mutex_guard_in_match_scrutinee() {\n+    let mutex = Mutex::new(State {});\n+\n+    // Should trigger lint because the lifetime of the temporary MutexGuard is surprising because it\n+    // is preserved until the end of the match, but there is no clear indication that this is the\n+    // case.\n+    match mutex.lock().unwrap().foo() {\n+        true => {\n+            mutex.lock().unwrap().bar();\n+        }\n+        false => {}\n+    };\n+}\n+\n+fn should_not_trigger_lint_for_insignificant_drop() {\n+    // Should not trigger lint because there are no temporaries whose drops have a significant\n+    // side effect.\n+    match 1u64.to_string().is_empty() {\n+        true => {\n+            println!(\"It was empty\")\n+        }\n+        false => {\n+            println!(\"It was not empty\")\n+        }\n+    }\n+}\n+\n+struct StateWithMutex {\n+    m: Mutex<u64>,\n+}\n+\n+struct MutexGuardWrapper<'a> {\n+    mg: MutexGuard<'a, u64>,\n+}\n+\n+impl<'a> MutexGuardWrapper<'a> {\n+    fn get_the_value(&self) -> u64 {\n+        *self.mg.deref()\n+    }\n+}\n+\n+struct MutexGuardWrapperWrapper<'a> {\n+    mg: MutexGuardWrapper<'a>,\n+}\n+\n+impl<'a> MutexGuardWrapperWrapper<'a> {\n+    fn get_the_value(&self) -> u64 {\n+        *self.mg.mg.deref()\n+    }\n+}\n+\n+impl StateWithMutex {\n+    fn lock_m(&self) -> MutexGuardWrapper<'_> {\n+        MutexGuardWrapper {\n+            mg: self.m.lock().unwrap(),\n+        }\n+    }\n+\n+    fn lock_m_m(&self) -> MutexGuardWrapperWrapper<'_> {\n+        MutexGuardWrapperWrapper {\n+            mg: MutexGuardWrapper {\n+                mg: self.m.lock().unwrap(),\n+            },\n+        }\n+    }\n+\n+    fn foo(&self) -> bool {\n+        true\n+    }\n+\n+    fn bar(&self) {}\n+}\n+\n+fn should_trigger_lint_with_wrapped_mutex() {\n+    let s = StateWithMutex { m: Mutex::new(1) };\n+\n+    // Should trigger lint because a temporary contains a type with a significant drop and its\n+    // lifetime is not obvious. Additionally, it is not obvious from looking at the scrutinee that\n+    // the temporary contains such a type, making it potentially even more surprising.\n+    match s.lock_m().get_the_value() {\n+        1 => {\n+            println!(\"Got 1. Is it still 1?\");\n+            println!(\"{}\", s.lock_m().get_the_value());\n+        }\n+        2 => {\n+            println!(\"Got 2. Is it still 2?\");\n+            println!(\"{}\", s.lock_m().get_the_value());\n+        }\n+        _ => {}\n+    }\n+    println!(\"All done!\");\n+}\n+\n+fn should_trigger_lint_with_double_wrapped_mutex() {\n+    let s = StateWithMutex { m: Mutex::new(1) };\n+\n+    // Should trigger lint because a temporary contains a type which further contains a type with a\n+    // significant drop and its lifetime is not obvious. Additionally, it is not obvious from\n+    // looking at the scrutinee that the temporary contains such a type, making it potentially even\n+    // more surprising.\n+    match s.lock_m_m().get_the_value() {\n+        1 => {\n+            println!(\"Got 1. Is it still 1?\");\n+            println!(\"{}\", s.lock_m().get_the_value());\n+        }\n+        2 => {\n+            println!(\"Got 2. Is it still 2?\");\n+            println!(\"{}\", s.lock_m().get_the_value());\n+        }\n+        _ => {}\n+    }\n+    println!(\"All done!\");\n+}\n+\n+struct Counter {\n+    i: AtomicU64,\n+}\n+\n+#[clippy::has_significant_drop]\n+struct CounterWrapper<'a> {\n+    counter: &'a Counter,\n+}\n+\n+impl<'a> CounterWrapper<'a> {\n+    fn new(counter: &Counter) -> CounterWrapper {\n+        counter.i.fetch_add(1, Ordering::Relaxed);\n+        CounterWrapper { counter }\n+    }\n+}\n+\n+impl<'a> Drop for CounterWrapper<'a> {\n+    fn drop(&mut self) {\n+        self.counter.i.fetch_sub(1, Ordering::Relaxed);\n+    }\n+}\n+\n+impl Counter {\n+    fn temp_increment(&self) -> Vec<CounterWrapper> {\n+        vec![CounterWrapper::new(self), CounterWrapper::new(self)]\n+    }\n+}\n+\n+fn should_trigger_lint_for_vec() {\n+    let counter = Counter { i: AtomicU64::new(0) };\n+\n+    // Should trigger lint because the temporary in the scrutinee returns a collection of types\n+    // which have significant drops. The types with significant drops are also non-obvious when\n+    // reading the expression in the scrutinee.\n+    match counter.temp_increment().len() {\n+        2 => {\n+            let current_count = counter.i.load(Ordering::Relaxed);\n+            println!(\"Current count {}\", current_count);\n+            assert_eq!(current_count, 0);\n+        }\n+        1 => {}\n+        3 => {}\n+        _ => {}\n+    };\n+}\n+\n+struct StateWithField {\n+    s: String,\n+}\n+\n+// Should trigger lint only on the type in the tuple which is created using a temporary\n+// with a significant drop. Additionally, this test ensures that the format of the tuple\n+// is preserved correctly in the suggestion.\n+fn should_trigger_lint_for_tuple_in_scrutinee() {\n+    let mutex1 = Mutex::new(StateWithField { s: \"one\".to_owned() });\n+\n+    {\n+        match (mutex1.lock().unwrap().s.len(), true) {\n+            (3, _) => {\n+                println!(\"started\");\n+                mutex1.lock().unwrap().s.len();\n+                println!(\"done\");\n+            }\n+            (_, _) => {}\n+        };\n+\n+        match (true, mutex1.lock().unwrap().s.len(), true) {\n+            (_, 3, _) => {\n+                println!(\"started\");\n+                mutex1.lock().unwrap().s.len();\n+                println!(\"done\");\n+            }\n+            (_, _, _) => {}\n+        };\n+\n+        let mutex2 = Mutex::new(StateWithField { s: \"two\".to_owned() });\n+        match (mutex1.lock().unwrap().s.len(), true, mutex2.lock().unwrap().s.len()) {\n+            (3, _, 3) => {\n+                println!(\"started\");\n+                mutex1.lock().unwrap().s.len();\n+                mutex2.lock().unwrap().s.len();\n+                println!(\"done\");\n+            }\n+            (_, _, _) => {}\n+        };\n+\n+        let mutex3 = Mutex::new(StateWithField { s: \"three\".to_owned() });\n+        match mutex3.lock().unwrap().s.as_str() {\n+            \"three\" => {\n+                println!(\"started\");\n+                mutex1.lock().unwrap().s.len();\n+                mutex2.lock().unwrap().s.len();\n+                println!(\"done\");\n+            }\n+            _ => {}\n+        };\n+\n+\n+        match (true, mutex3.lock().unwrap().s.as_str()) {\n+            (_, \"three\") => {\n+                println!(\"started\");\n+                mutex1.lock().unwrap().s.len();\n+                mutex2.lock().unwrap().s.len();\n+                println!(\"done\");\n+            }\n+            (_, _) => {}\n+        };\n+    }\n+}\n+\n+// Should trigger lint when either side of a binary operation creates a temporary with a\n+// significant drop.\n+// To avoid potential unnecessary copies or creating references that would trigger the significant\n+// drop problem, the lint recommends moving the entire binary operation.\n+fn should_trigger_lint_for_accessing_field_in_mutex_in_one_side_of_binary_op() {\n+    let mutex = Mutex::new(StateWithField { s: \"state\".to_owned() });\n+\n+    match mutex.lock().unwrap().s.len() > 1 {\n+        true => {\n+            mutex.lock().unwrap().s.len();\n+        }\n+        false => {}\n+    };\n+\n+    match 1 < mutex.lock().unwrap().s.len() {\n+        true => {\n+            mutex.lock().unwrap().s.len();\n+        }\n+        false => {}\n+    };\n+}\n+\n+// Should trigger lint when both sides of a binary operation creates a temporary with a\n+// significant drop.\n+// To avoid potential unnecessary copies or creating references that would trigger the significant\n+// drop problem, the lint recommends moving the entire binary operation.\n+fn should_trigger_lint_for_accessing_fields_in_mutex_in_both_sides_of_binary_op() {\n+    let mutex1 = Mutex::new(StateWithField { s: \"state\".to_owned() });\n+    let mutex2 = Mutex::new(StateWithField { s: \"statewithfield\".to_owned() });\n+\n+    match mutex1.lock().unwrap().s.len() < mutex2.lock().unwrap().s.len() {\n+        true => {\n+            println!(\"{} < {}\", mutex1.lock().unwrap().s.len(), mutex2.lock().unwrap().s.len());\n+        }\n+        false => {}\n+    };\n+\n+    match mutex1.lock().unwrap().s.len() >= mutex2.lock().unwrap().s.len() {\n+        true => {\n+            println!(\"{} >= {}\", mutex1.lock().unwrap().s.len(), mutex2.lock().unwrap().s.len());\n+        }\n+        false => {}\n+    };\n+}\n+\n+fn should_not_trigger_lint_for_closure_in_scrutinee() {\n+    let mutex1 = Mutex::new(StateWithField { s: \"one\".to_owned() });\n+\n+    let get_mutex_guard = || mutex1.lock().unwrap().s.len();\n+\n+    // Should not trigger lint because the temporary with a significant drop will be dropped\n+    // at the end of the closure, so the MutexGuard will be unlocked and not have a potentially\n+    // surprising lifetime.\n+    match get_mutex_guard() > 1 {\n+        true => {\n+            mutex1.lock().unwrap().s.len();\n+        }\n+        false => {}\n+    };\n+}\n+\n+fn should_trigger_lint_for_return_from_closure_in_scrutinee() {\n+    let mutex1 = Mutex::new(StateWithField { s: \"one\".to_owned() });\n+\n+    let get_mutex_guard = || mutex1.lock().unwrap();\n+\n+    // Should trigger lint because the temporary with a significant drop is returned from the\n+    // closure but not used directly in any match arms, so it has a potentially surprising lifetime.\n+    match get_mutex_guard().s.len() > 1 {\n+        true => {\n+            mutex1.lock().unwrap().s.len();\n+        }\n+        false => {}\n+    };\n+}\n+\n+fn should_trigger_lint_for_return_from_match_in_scrutinee() {\n+    let mutex1 = Mutex::new(StateWithField { s: \"one\".to_owned() });\n+    let mutex2 = Mutex::new(StateWithField { s: \"two\".to_owned() });\n+\n+    let i = 100;\n+\n+    // Should trigger lint because the nested match within the scrutinee returns a temporary with a\n+    // significant drop is but not used directly in any match arms, so it has a potentially\n+    // surprising lifetime.\n+    match match i { 100 => mutex1.lock().unwrap(), _ => mutex2.lock().unwrap() }.s.len() > 1 {\n+        true => {\n+            mutex1.lock().unwrap().s.len();\n+        }\n+        false => {\n+            println!(\"nothing to do here\");\n+        }\n+    };\n+}\n+\n+fn should_trigger_lint_for_return_from_if_in_scrutinee() {\n+    let mutex1 = Mutex::new(StateWithField { s: \"one\".to_owned() });\n+    let mutex2 = Mutex::new(StateWithField { s: \"two\".to_owned() });\n+\n+    let i = 100;\n+\n+    // Should trigger lint because the nested if-expression within the scrutinee returns a temporary\n+    // with a significant drop is but not used directly in any match arms, so it has a potentially\n+    // surprising lifetime.\n+    match if i > 1 { mutex1.lock().unwrap() } else { mutex2.lock().unwrap() }.s.len() > 1 {\n+        true => {\n+            mutex1.lock().unwrap().s.len();\n+        }\n+        false => {}\n+    };\n+}\n+\n+fn should_not_trigger_lint_for_if_in_scrutinee() {\n+    let mutex = Mutex::new(StateWithField { s: \"state\".to_owned() });\n+\n+    let i = 100;\n+\n+    // Should not trigger the lint because the temporary with a significant drop *is* dropped within\n+    // the body of the if-expression nested within the match scrutinee, and therefore does not have\n+    // a potentially surprising lifetime.\n+    match if i > 1 { mutex.lock().unwrap().s.len() > 1 } else { false } {\n+        true => {\n+            mutex.lock().unwrap().s.len();\n+        }\n+        false => {}\n+    };\n+}\n+\n+struct StateWithBoxedMutexGuard {\n+    u: Mutex<u64>,\n+}\n+\n+impl StateWithBoxedMutexGuard {\n+    fn new() -> StateWithBoxedMutexGuard {\n+        StateWithBoxedMutexGuard { u: Mutex::new(42) }\n+    }\n+    fn lock(&self) -> Box<MutexGuard<u64>> {\n+        Box::new(self.u.lock().unwrap())\n+    }\n+}\n+\n+fn should_trigger_lint_for_boxed_mutex_guard() {\n+    let s = StateWithBoxedMutexGuard::new();\n+\n+    // Should trigger lint because a temporary Box holding a type with a significant drop in a match\n+    // scrutinee may have a potentially surprising lifetime.\n+    match s.lock().deref().deref() {\n+        0 | 1 => println!(\"Value was less than 2\"),\n+        _ => println!(\"Value is {}\", s.lock().deref()),\n+    };\n+}\n+\n+struct StateStringWithBoxedMutexGuard {\n+    s: Mutex<String>,\n+}\n+\n+impl StateStringWithBoxedMutexGuard {\n+    fn new() -> StateStringWithBoxedMutexGuard {\n+        StateStringWithBoxedMutexGuard { s: Mutex::new(\"A String\".to_owned()) }\n+    }\n+    fn lock(&self) -> Box<MutexGuard<String>> {\n+        Box::new(self.s.lock().unwrap())\n+    }\n+}\n+\n+fn should_trigger_lint_for_boxed_mutex_guard_holding_string() {\n+    let s = StateStringWithBoxedMutexGuard::new();\n+\n+    let matcher = String::from(\"A String\");\n+\n+    // Should trigger lint because a temporary Box holding a type with a significant drop in a match\n+    // scrutinee may have a potentially surprising lifetime.\n+    match s.lock().deref().deref() {\n+        matcher => println!(\"Value is {}\", s.lock().deref()),\n+        _ => println!(\"Value was not a match\"),\n+    };\n+}\n+\n+\n+struct StateWithIntField {\n+    i: u64,\n+}\n+\n+// Should trigger lint when either side of an assign expression contains a temporary with a\n+// significant drop, because the temporary's lifetime will be extended to the end of the match.\n+// To avoid potential unnecessary copies or creating references that would trigger the significant\n+// drop problem, the lint recommends moving the entire binary operation.\n+fn should_trigger_lint_in_assign_expr() {\n+    let mutex = Mutex::new(StateWithIntField { i: 10 });\n+\n+    let mut i = 100;\n+\n+    match mutex.lock().unwrap().i = i {\n+        _ => {\n+            println!(\"{}\", mutex.lock().unwrap().i);\n+        }\n+    };\n+\n+    match i = mutex.lock().unwrap().i {\n+        _ => {\n+            println!(\"{}\", mutex.lock().unwrap().i);\n+        }\n+    };\n+\n+    match mutex.lock().unwrap().i += 1 {\n+        _ => {\n+            println!(\"{}\", mutex.lock().unwrap().i);\n+        }\n+    };\n+\n+    match i += mutex.lock().unwrap().i {\n+        _ => {\n+            println!(\"{}\", mutex.lock().unwrap().i);\n+        }\n+    };\n+}\n+\n+#[derive(Debug)]\n+enum RecursiveEnum {\n+    Foo(Option<Box<RecursiveEnum>>)\n+}\n+\n+#[derive(Debug)]\n+enum GenericRecursiveEnum<T> {\n+    Foo(T, Option<Box<GenericRecursiveEnum<T>>>)\n+}\n+\n+fn should_not_cause_stack_overflow() {\n+    // Test that when a type recursively contains itself, a stack overflow does not occur when\n+    // checking sub-types for significant drops.\n+    let f = RecursiveEnum::Foo(Some(Box::new(RecursiveEnum::Foo(None))));\n+    match f {\n+        RecursiveEnum::Foo(Some(f)) => {\n+            println!(\"{:?}\", f)\n+        }\n+        RecursiveEnum::Foo(f) => {\n+            println!(\"{:?}\", f)\n+        }\n+    }\n+\n+    let f = GenericRecursiveEnum::Foo(1u64, Some(Box::new(GenericRecursiveEnum::Foo(2u64, None))));\n+    match f {\n+        GenericRecursiveEnum::Foo(i, Some(f)) => {\n+            println!(\"{} {:?}\", i, f)\n+        }\n+        GenericRecursiveEnum::Foo(i, f) => {\n+            println!(\"{} {:?}\", i, f)\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "c442e93f539aea0acdcdf65cce2f08adf97169e3", "filename": "src/tools/clippy/tests/ui/significant_drop_in_scrutinee.stderr", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/4d1076c9f918297c97300a7ecf769dd7e6780be6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsignificant_drop_in_scrutinee.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d1076c9f918297c97300a7ecf769dd7e6780be6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsignificant_drop_in_scrutinee.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsignificant_drop_in_scrutinee.stderr?ref=4d1076c9f918297c97300a7ecf769dd7e6780be6", "patch": "@@ -0,0 +1,261 @@\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:57:11\n+   |\n+LL |     match mutex.lock().unwrap().foo() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::significant-drop-in-scrutinee` implied by `-D warnings`\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = mutex.lock().unwrap().foo();\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:130:11\n+   |\n+LL |     match s.lock_m().get_the_value() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = s.lock_m().get_the_value();\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:151:11\n+   |\n+LL |     match s.lock_m_m().get_the_value() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = s.lock_m_m().get_the_value();\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:199:11\n+   |\n+LL |     match counter.temp_increment().len() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = counter.temp_increment().len();\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:222:16\n+   |\n+LL |         match (mutex1.lock().unwrap().s.len(), true) {\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~         let value = mutex1.lock().unwrap().s.len();\n+LL ~         match (value, true) {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:231:22\n+   |\n+LL |         match (true, mutex1.lock().unwrap().s.len(), true) {\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~         let value = mutex1.lock().unwrap().s.len();\n+LL ~         match (true, value, true) {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:241:16\n+   |\n+LL |         match (mutex1.lock().unwrap().s.len(), true, mutex2.lock().unwrap().s.len()) {\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~         let value = mutex1.lock().unwrap().s.len();\n+LL ~         match (value, true, mutex2.lock().unwrap().s.len()) {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:241:54\n+   |\n+LL |         match (mutex1.lock().unwrap().s.len(), true, mutex2.lock().unwrap().s.len()) {\n+   |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~         let value = mutex2.lock().unwrap().s.len();\n+LL ~         match (mutex1.lock().unwrap().s.len(), true, value) {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:252:15\n+   |\n+LL |         match mutex3.lock().unwrap().s.as_str() {\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:263:22\n+   |\n+LL |         match (true, mutex3.lock().unwrap().s.as_str()) {\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:282:11\n+   |\n+LL |     match mutex.lock().unwrap().s.len() > 1 {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = mutex.lock().unwrap().s.len() > 1;\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:289:11\n+   |\n+LL |     match 1 < mutex.lock().unwrap().s.len() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = 1 < mutex.lock().unwrap().s.len();\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:305:11\n+   |\n+LL |     match mutex1.lock().unwrap().s.len() < mutex2.lock().unwrap().s.len() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = mutex1.lock().unwrap().s.len() < mutex2.lock().unwrap().s.len();\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:312:11\n+   |\n+LL |     match mutex1.lock().unwrap().s.len() >= mutex2.lock().unwrap().s.len() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = mutex1.lock().unwrap().s.len() >= mutex2.lock().unwrap().s.len();\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:343:11\n+   |\n+LL |     match get_mutex_guard().s.len() > 1 {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = get_mutex_guard().s.len() > 1;\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:360:11\n+   |\n+LL |     match match i { 100 => mutex1.lock().unwrap(), _ => mutex2.lock().unwrap() }.s.len() > 1 {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = match i { 100 => mutex1.lock().unwrap(), _ => mutex2.lock().unwrap() }.s.len() > 1;\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:379:11\n+   |\n+LL |     match if i > 1 { mutex1.lock().unwrap() } else { mutex2.lock().unwrap() }.s.len() > 1 {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = if i > 1 { mutex1.lock().unwrap() } else { mutex2.lock().unwrap() }.s.len() > 1;\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:421:11\n+   |\n+LL |     match s.lock().deref().deref() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match and create a copy\n+   |\n+LL ~     let value = *s.lock().deref().deref();\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:447:11\n+   |\n+LL |     match s.lock().deref().deref() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:467:11\n+   |\n+LL |     match mutex.lock().unwrap().i = i {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     mutex.lock().unwrap().i = i;\n+LL ~     match () {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:473:11\n+   |\n+LL |     match i = mutex.lock().unwrap().i {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     i = mutex.lock().unwrap().i;\n+LL ~     match () {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:479:11\n+   |\n+LL |     match mutex.lock().unwrap().i += 1 {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     mutex.lock().unwrap().i += 1;\n+LL ~     match () {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:485:11\n+   |\n+LL |     match i += mutex.lock().unwrap().i {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     i += mutex.lock().unwrap().i;\n+LL ~     match () {\n+   |\n+\n+error: aborting due to 23 previous errors\n+"}]}