{"sha": "70dfe3fa746ac459747da30aca0bac11379088d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwZGZlM2ZhNzQ2YWM0NTk3NDdkYTMwYWNhMGJhYzExMzc5MDg4ZDU=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-08-02T19:28:18Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-08-18T20:14:40Z"}, "message": "move const param structural match checks to wfcheck", "tree": {"sha": "c21c7b76ee67aa31b10f3cca5ea75744d52f9b09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c21c7b76ee67aa31b10f3cca5ea75744d52f9b09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70dfe3fa746ac459747da30aca0bac11379088d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70dfe3fa746ac459747da30aca0bac11379088d5", "html_url": "https://github.com/rust-lang/rust/commit/70dfe3fa746ac459747da30aca0bac11379088d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70dfe3fa746ac459747da30aca0bac11379088d5/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b287b56f97288cc4605329f76e31cb7604474aef", "url": "https://api.github.com/repos/rust-lang/rust/commits/b287b56f97288cc4605329f76e31cb7604474aef", "html_url": "https://github.com/rust-lang/rust/commit/b287b56f97288cc4605329f76e31cb7604474aef"}], "stats": {"total": 556, "additions": 155, "deletions": 401}, "files": [{"sha": "dc4f181ec939b52708f505e2494ba9edae5bb786", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70dfe3fa746ac459747da30aca0bac11379088d5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70dfe3fa746ac459747da30aca0bac11379088d5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=70dfe3fa746ac459747da30aca0bac11379088d5", "patch": "@@ -729,8 +729,8 @@ impl ItemLikeVisitor<'tcx> for CheckItemTypesVisitor<'tcx> {\n }\n \n pub fn check_wf_new(tcx: TyCtxt<'_>) {\n-    let visit = wfcheck::CheckTypeWellFormedVisitor::new(tcx);\n-    tcx.hir().krate().par_visit_all_item_likes(&visit);\n+    let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(tcx);\n+    tcx.hir().krate().visit_all_item_likes(&mut visit.as_deep_visitor());\n }\n \n fn check_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {"}, {"sha": "740f30f5224d0328dddc492c1e0b520aa4d06969", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 111, "deletions": 5, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/70dfe3fa746ac459747da30aca0bac11379088d5/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70dfe3fa746ac459747da30aca0bac11379088d5/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=70dfe3fa746ac459747da30aca0bac11379088d5", "patch": "@@ -6,9 +6,11 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_hir::itemlikevisit::ParItemLikeVisitor;\n+use rustc_hir::intravisit as hir_visit;\n+use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items;\n use rustc_hir::ItemKind;\n+use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n use rustc_middle::ty::{\n@@ -275,6 +277,95 @@ pub fn check_impl_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     check_associated_item(tcx, impl_item.hir_id, impl_item.span, method_sig);\n }\n \n+fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n+    match param.kind {\n+        // We currently only check wf of const params here.\n+        hir::GenericParamKind::Lifetime { .. } | hir::GenericParamKind::Type { .. } => (),\n+\n+        // Const parameters are well formed if their\n+        // type is structural match.\n+        hir::GenericParamKind::Const { ty: hir_ty } => {\n+            let ty = tcx.type_of(tcx.hir().local_def_id(param.hir_id));\n+\n+            let err_ty_str;\n+            let err = if tcx.features().min_const_generics {\n+                match ty.kind {\n+                    ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Error(_) => None,\n+                    ty::FnPtr(_) => Some(\"function pointers\"),\n+                    ty::RawPtr(_) => Some(\"raw pointers\"),\n+                    _ => {\n+                        err_ty_str = format!(\"`{}`\", ty);\n+                        Some(err_ty_str.as_str())\n+                    }\n+                }\n+            } else {\n+                match ty.peel_refs().kind {\n+                    ty::FnPtr(_) => Some(\"function pointers\"),\n+                    ty::RawPtr(_) => Some(\"raw pointers\"),\n+                    _ => None,\n+                }\n+            };\n+            if let Some(unsupported_type) = err {\n+                let mut err = tcx.sess.struct_span_err(\n+                    hir_ty.span,\n+                    &format!(\"using {} as const generic parameters is forbidden\", unsupported_type),\n+                );\n+\n+                if tcx.features().min_const_generics {\n+                    err.note(\"the only supported types are integers, `bool` and `char`\")\n+                        .note(\"more complex types are supported with `#[feature(const_generics)]`\")\n+                        .emit()\n+                } else {\n+                    err.emit();\n+                }\n+            };\n+            if traits::search_for_structural_match_violation(param.hir_id, param.span, tcx, ty)\n+                .is_some()\n+            {\n+                // We use the same error code in both branches, because this is really the same\n+                // issue: we just special-case the message for type parameters to make it\n+                // clearer.\n+                if let ty::Param(_) = ty.peel_refs().kind {\n+                    // Const parameters may not have type parameters as their types,\n+                    // because we cannot be sure that the type parameter derives `PartialEq`\n+                    // and `Eq` (just implementing them is not enough for `structural_match`).\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        hir_ty.span,\n+                        E0741,\n+                        \"`{}` is not guaranteed to `#[derive(PartialEq, Eq)]`, so may not be \\\n+                            used as the type of a const parameter\",\n+                        ty,\n+                    )\n+                    .span_label(\n+                        hir_ty.span,\n+                        format!(\"`{}` may not derive both `PartialEq` and `Eq`\", ty),\n+                    )\n+                    .note(\n+                        \"it is not currently possible to use a type parameter as the type of a \\\n+                            const parameter\",\n+                    )\n+                    .emit();\n+                } else {\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        hir_ty.span,\n+                        E0741,\n+                        \"`{}` must be annotated with `#[derive(PartialEq, Eq)]` to be used as \\\n+                            the type of a const parameter\",\n+                        ty,\n+                    )\n+                    .span_label(\n+                        hir_ty.span,\n+                        format!(\"`{}` doesn't derive both `PartialEq` and `Eq`\", ty),\n+                    )\n+                    .emit();\n+                }\n+            }\n+        }\n+    }\n+}\n+\n fn check_associated_item(\n     tcx: TyCtxt<'_>,\n     item_id: hir::HirId,\n@@ -1292,23 +1383,38 @@ impl CheckTypeWellFormedVisitor<'tcx> {\n     }\n }\n \n-impl ParItemLikeVisitor<'tcx> for CheckTypeWellFormedVisitor<'tcx> {\n-    fn visit_item(&self, i: &'tcx hir::Item<'tcx>) {\n+impl Visitor<'tcx> for CheckTypeWellFormedVisitor<'tcx> {\n+    type Map = hir_map::Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> hir_visit::NestedVisitorMap<Self::Map> {\n+        hir_visit::NestedVisitorMap::OnlyBodies(self.tcx.hir())\n+    }\n+\n+    fn visit_item(&mut self, i: &'tcx hir::Item<'tcx>) {\n         debug!(\"visit_item: {:?}\", i);\n         let def_id = self.tcx.hir().local_def_id(i.hir_id);\n         self.tcx.ensure().check_item_well_formed(def_id);\n+        hir_visit::walk_item(self, i);\n     }\n \n-    fn visit_trait_item(&self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         debug!(\"visit_trait_item: {:?}\", trait_item);\n         let def_id = self.tcx.hir().local_def_id(trait_item.hir_id);\n         self.tcx.ensure().check_trait_item_well_formed(def_id);\n+        hir_visit::walk_trait_item(self, trait_item);\n     }\n \n-    fn visit_impl_item(&self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         debug!(\"visit_impl_item: {:?}\", impl_item);\n         let def_id = self.tcx.hir().local_def_id(impl_item.hir_id);\n         self.tcx.ensure().check_impl_item_well_formed(def_id);\n+        hir_visit::walk_impl_item(self, impl_item);\n+    }\n+\n+    fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam<'tcx>) {\n+        check_param_wf(self.tcx, p);\n+        // No need to walk further here, there is nothing interesting\n+        // inside of generic params we don't already check in `check_param_wf`.\n     }\n }\n "}, {"sha": "70ed92c5614a1ad8e88099ad867cff7309dca6f4", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 2, "deletions": 83, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/70dfe3fa746ac459747da30aca0bac11379088d5/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70dfe3fa746ac459747da30aca0bac11379088d5/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=70dfe3fa746ac459747da30aca0bac11379088d5", "patch": "@@ -12,7 +12,6 @@ use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n use rustc_span::symbol::Ident;\n use rustc_span::{Span, DUMMY_SP};\n-use rustc_trait_selection::traits;\n \n use super::ItemCtxt;\n use super::{bad_placeholder_type, is_suggestable_infer_ty};\n@@ -323,88 +322,8 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         }\n \n         Node::GenericParam(param) => match &param.kind {\n-            GenericParamKind::Type { default: Some(ref ty), .. } => icx.to_ty(ty),\n-            GenericParamKind::Const { ty: ref hir_ty, .. } => {\n-                let ty = icx.to_ty(hir_ty);\n-                let err_ty_str;\n-                let err = if tcx.features().min_const_generics {\n-                    match ty.kind {\n-                        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Error(_) => None,\n-                        ty::FnPtr(_) => Some(\"function pointers\"),\n-                        ty::RawPtr(_) => Some(\"raw pointers\"),\n-                        _ => {\n-                            err_ty_str = format!(\"`{}`\", ty);\n-                            Some(err_ty_str.as_str())\n-                        }\n-                    }\n-                } else {\n-                    match ty.peel_refs().kind {\n-                        ty::FnPtr(_) => Some(\"function pointers\"),\n-                        ty::RawPtr(_) => Some(\"raw pointers\"),\n-                        _ => None,\n-                    }\n-                };\n-                if let Some(unsupported_type) = err {\n-                    let mut err = tcx.sess.struct_span_err(\n-                        hir_ty.span,\n-                        &format!(\n-                            \"using {} as const generic parameters is forbidden\",\n-                            unsupported_type\n-                        ),\n-                    );\n-\n-                    if tcx.features().min_const_generics {\n-                        err.note(\"the only supported types are integers, `bool` and `char`\")\n-                        .note(\"more complex types are supported with `#[feature(const_generics)]`\").emit()\n-                    } else {\n-                        err.emit();\n-                    }\n-                };\n-                if traits::search_for_structural_match_violation(param.hir_id, param.span, tcx, ty)\n-                    .is_some()\n-                {\n-                    // We use the same error code in both branches, because this is really the same\n-                    // issue: we just special-case the message for type parameters to make it\n-                    // clearer.\n-                    if let ty::Param(_) = ty.peel_refs().kind {\n-                        // Const parameters may not have type parameters as their types,\n-                        // because we cannot be sure that the type parameter derives `PartialEq`\n-                        // and `Eq` (just implementing them is not enough for `structural_match`).\n-                        struct_span_err!(\n-                            tcx.sess,\n-                            hir_ty.span,\n-                            E0741,\n-                            \"`{}` is not guaranteed to `#[derive(PartialEq, Eq)]`, so may not be \\\n-                             used as the type of a const parameter\",\n-                            ty,\n-                        )\n-                        .span_label(\n-                            hir_ty.span,\n-                            format!(\"`{}` may not derive both `PartialEq` and `Eq`\", ty),\n-                        )\n-                        .note(\n-                            \"it is not currently possible to use a type parameter as the type of a \\\n-                             const parameter\",\n-                        )\n-                        .emit();\n-                    } else {\n-                        struct_span_err!(\n-                            tcx.sess,\n-                            hir_ty.span,\n-                            E0741,\n-                            \"`{}` must be annotated with `#[derive(PartialEq, Eq)]` to be used as \\\n-                             the type of a const parameter\",\n-                            ty,\n-                        )\n-                        .span_label(\n-                            hir_ty.span,\n-                            format!(\"`{}` doesn't derive both `PartialEq` and `Eq`\", ty),\n-                        )\n-                        .emit();\n-                    }\n-                }\n-                ty\n-            }\n+            GenericParamKind::Type { default: Some(ty), .. }\n+            | GenericParamKind::Const { ty, .. } => icx.to_ty(ty),\n             x => bug!(\"unexpected non-type Node::GenericParam: {:?}\", x),\n         },\n "}, {"sha": "5d068d851c10bcb3965fec486c6abce352b56bb1", "filename": "src/test/ui/const-generics/issues/issue-75047.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/70dfe3fa746ac459747da30aca0bac11379088d5/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-75047.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70dfe3fa746ac459747da30aca0bac11379088d5/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-75047.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-75047.rs?ref=70dfe3fa746ac459747da30aca0bac11379088d5", "patch": "@@ -0,0 +1,15 @@\n+// check-pass\n+#![feature(const_generics)]\n+#![allow(incomplete_features)]\n+\n+struct Bar<T>(T);\n+\n+impl<T> Bar<T> {\n+    const fn value() -> usize {\n+        42\n+    }\n+}\n+\n+struct Foo<const N: [u8; Bar::<u32>::value()]>;\n+\n+fn main() {}"}, {"sha": "a55d43d395c842513f6118a6906d1f9eb5115242", "filename": "src/test/ui/const-generics/nested-type.full.stderr", "status": "modified", "additions": 10, "deletions": 153, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/70dfe3fa746ac459747da30aca0bac11379088d5/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70dfe3fa746ac459747da30aca0bac11379088d5/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.full.stderr?ref=70dfe3fa746ac459747da30aca0bac11379088d5", "patch": "@@ -1,159 +1,16 @@\n-error[E0391]: cycle detected when computing type of `Foo`\n-  --> $DIR/nested-type.rs:7:1\n+error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+  --> $DIR/nested-type.rs:17:5\n    |\n-LL | struct Foo<const N: [u8; {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires computing type of `Foo::N`...\n-  --> $DIR/nested-type.rs:7:18\n-   |\n-LL | struct Foo<const N: [u8; {\n-   |                  ^\n-note: ...which requires const-evaluating + checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires const-evaluating + checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires const-evaluating `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires type-checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires computing the variances of `Foo::{{constant}}#0::Foo`...\n-  --> $DIR/nested-type.rs:11:5\n-   |\n-LL |     struct Foo<const N: usize>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires computing the variances for items in this crate...\n-   = note: ...which again requires computing type of `Foo`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/nested-type.rs:3:1\n-   |\n-LL | / #![cfg_attr(full, feature(const_generics))]\n-LL | | #![cfg_attr(full, allow(incomplete_features))]\n-LL | | #![cfg_attr(min, feature(min_const_generics))]\n-LL | |\n-...  |\n-LL | |\n-LL | | fn main() {}\n-   | |____________^\n+LL |     Foo::<17>::value()\n+   |     ^^^^^^^^^^^^^^^^^^\n \n-error[E0391]: cycle detected when computing type of `Foo`\n-  --> $DIR/nested-type.rs:7:1\n-   |\n-LL | struct Foo<const N: [u8; {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires computing type of `Foo::N`...\n-  --> $DIR/nested-type.rs:7:18\n-   |\n-LL | struct Foo<const N: [u8; {\n-   |                  ^\n-note: ...which requires const-evaluating + checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires const-evaluating + checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires const-evaluating `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires type-checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires computing the variances of `Foo::{{constant}}#0::Foo`...\n-  --> $DIR/nested-type.rs:11:5\n-   |\n-LL |     struct Foo<const N: usize>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires computing the variances for items in this crate...\n-   = note: ...which again requires computing type of `Foo`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/nested-type.rs:3:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/nested-type.rs:17:5\n    |\n-LL | / #![cfg_attr(full, feature(const_generics))]\n-LL | | #![cfg_attr(full, allow(incomplete_features))]\n-LL | | #![cfg_attr(min, feature(min_const_generics))]\n-LL | |\n-...  |\n-LL | |\n-LL | | fn main() {}\n-   | |____________^\n+LL |     Foo::<17>::value()\n+   |     ^^^^^^^^^^^^^^^^^^ calling non-const function `Foo::{{constant}}#0::Foo::<17_usize>::value`\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0391`.\n+Some errors have detailed explanations: E0015, E0080.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "17e2eef7278a0cdca70b815eb1dbe04dae2d6f53", "filename": "src/test/ui/const-generics/nested-type.min.stderr", "status": "modified", "additions": 12, "deletions": 155, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/70dfe3fa746ac459747da30aca0bac11379088d5/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70dfe3fa746ac459747da30aca0bac11379088d5/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.min.stderr?ref=70dfe3fa746ac459747da30aca0bac11379088d5", "patch": "@@ -4,172 +4,29 @@ error: using `[u8; _]` as const generic parameters is forbidden\n LL |   struct Foo<const N: [u8; {\n    |  _____________________^\n LL | |\n-LL | |\n+LL | |     struct Foo<const N: usize>;\n LL | |\n ...  |\n-LL | |     Foo::<17>::value()\n+LL | |\n LL | | }]>;\n    | |__^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n    = note: more complex types are supported with `#[feature(const_generics)]`\n \n-error[E0391]: cycle detected when computing type of `Foo`\n-  --> $DIR/nested-type.rs:7:1\n-   |\n-LL | struct Foo<const N: [u8; {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires computing type of `Foo::N`...\n-  --> $DIR/nested-type.rs:7:18\n-   |\n-LL | struct Foo<const N: [u8; {\n-   |                  ^\n-note: ...which requires const-evaluating + checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires const-evaluating + checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires const-evaluating `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires type-checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires computing the variances of `Foo::{{constant}}#0::Foo`...\n-  --> $DIR/nested-type.rs:11:5\n-   |\n-LL |     struct Foo<const N: usize>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires computing the variances for items in this crate...\n-   = note: ...which again requires computing type of `Foo`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/nested-type.rs:3:1\n+error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+  --> $DIR/nested-type.rs:17:5\n    |\n-LL | / #![cfg_attr(full, feature(const_generics))]\n-LL | | #![cfg_attr(full, allow(incomplete_features))]\n-LL | | #![cfg_attr(min, feature(min_const_generics))]\n-LL | |\n-...  |\n-LL | |\n-LL | | fn main() {}\n-   | |____________^\n+LL |     Foo::<17>::value()\n+   |     ^^^^^^^^^^^^^^^^^^\n \n-error[E0391]: cycle detected when computing type of `Foo`\n-  --> $DIR/nested-type.rs:7:1\n-   |\n-LL | struct Foo<const N: [u8; {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires computing type of `Foo::N`...\n-  --> $DIR/nested-type.rs:7:18\n-   |\n-LL | struct Foo<const N: [u8; {\n-   |                  ^\n-note: ...which requires const-evaluating + checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires const-evaluating + checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires const-evaluating `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/nested-type.rs:17:5\n    |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires type-checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires computing the variances of `Foo::{{constant}}#0::Foo`...\n-  --> $DIR/nested-type.rs:11:5\n-   |\n-LL |     struct Foo<const N: usize>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires computing the variances for items in this crate...\n-   = note: ...which again requires computing type of `Foo`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/nested-type.rs:3:1\n-   |\n-LL | / #![cfg_attr(full, feature(const_generics))]\n-LL | | #![cfg_attr(full, allow(incomplete_features))]\n-LL | | #![cfg_attr(min, feature(min_const_generics))]\n-LL | |\n-...  |\n-LL | |\n-LL | | fn main() {}\n-   | |____________^\n+LL |     Foo::<17>::value()\n+   |     ^^^^^^^^^^^^^^^^^^ calling non-const function `Foo::{{constant}}#0::Foo::<17_usize>::value`\n \n error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0391`.\n+Some errors have detailed explanations: E0015, E0080.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "70d6ac42e9ff2b153c6aeab34d479ccf170c15ba", "filename": "src/test/ui/const-generics/nested-type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70dfe3fa746ac459747da30aca0bac11379088d5/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70dfe3fa746ac459747da30aca0bac11379088d5/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.rs?ref=70dfe3fa746ac459747da30aca0bac11379088d5", "patch": "@@ -5,9 +5,7 @@\n #![cfg_attr(min, feature(min_const_generics))]\n \n struct Foo<const N: [u8; {\n-//~^ ERROR cycle detected\n-//~| ERROR cycle detected\n-//[min]~| ERROR using `[u8; _]` as const generic\n+//[min]~^ ERROR using `[u8; _]` as const generic\n     struct Foo<const N: usize>;\n \n     impl<const N: usize> Foo<N> {\n@@ -17,6 +15,8 @@ struct Foo<const N: [u8; {\n     }\n \n     Foo::<17>::value()\n+    //~^ ERROR calls in constants are limited to constant functions\n+    //~| ERROR evaluation of constant value failed\n }]>;\n \n fn main() {}"}]}