{"sha": "7256c6f93ee0c0773d749d865e8b7041635dd6ed", "node_id": "C_kwDOAAsO6NoAKDcyNTZjNmY5M2VlMGMwNzczZDc0OWQ4NjVlOGI3MDQxNjM1ZGQ2ZWQ", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-04-22T19:49:01Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-05-13T17:42:53Z"}, "message": "rustdoc: Remove `fn resolve_macro`\n\nand otherwise unify resolution in macro namespace and other namespaces", "tree": {"sha": "27d307711ee5e68989622620011b8697c3298182", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27d307711ee5e68989622620011b8697c3298182"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7256c6f93ee0c0773d749d865e8b7041635dd6ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7256c6f93ee0c0773d749d865e8b7041635dd6ed", "html_url": "https://github.com/rust-lang/rust/commit/7256c6f93ee0c0773d749d865e8b7041635dd6ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7256c6f93ee0c0773d749d865e8b7041635dd6ed/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95fb05d4d87e5cbf42d2208b218ba8c10d4c311a", "url": "https://api.github.com/repos/rust-lang/rust/commits/95fb05d4d87e5cbf42d2208b218ba8c10d4c311a", "html_url": "https://github.com/rust-lang/rust/commit/95fb05d4d87e5cbf42d2208b218ba8c10d4c311a"}], "stats": {"total": 162, "additions": 43, "deletions": 119}, "files": [{"sha": "3b2b47b6c79537b056f8b69c0555dc1eedb45332", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 43, "deletions": 119, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/7256c6f93ee0c0773d749d865e8b7041635dd6ed/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7256c6f93ee0c0773d749d865e8b7041635dd6ed/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=7256c6f93ee0c0773d749d865e8b7041635dd6ed", "patch": "@@ -54,12 +54,6 @@ enum ErrorKind<'a> {\n     AnchorFailure(AnchorFailure),\n }\n \n-impl<'a> From<ResolutionFailure<'a>> for ErrorKind<'a> {\n-    fn from(err: ResolutionFailure<'a>) -> Self {\n-        ErrorKind::Resolve(box err)\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, Hash)]\n enum Res {\n     Def(DefKind, DefId),\n@@ -371,7 +365,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         path_str: &'path str,\n         item_id: ItemId,\n         module_id: DefId,\n-    ) -> Result<(Res, Option<ItemFragment>), ErrorKind<'path>> {\n+    ) -> Result<(Res, Option<ItemFragment>), ResolutionFailure<'path>> {\n         let tcx = self.cx.tcx;\n         let no_res = || ResolutionFailure::NotResolved {\n             item_id,\n@@ -445,25 +439,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         })\n     }\n \n-    /// Resolves a string as a macro.\n-    ///\n-    /// FIXME(jynelson): Can this be unified with `resolve()`?\n-    fn resolve_macro(\n-        &self,\n-        path_str: &'a str,\n-        item_id: ItemId,\n-        module_id: DefId,\n-    ) -> Result<Res, ResolutionFailure<'a>> {\n-        self.resolve_path(path_str, MacroNS, item_id, module_id).ok_or_else(|| {\n-            ResolutionFailure::NotResolved {\n-                item_id,\n-                module_id,\n-                partial_res: None,\n-                unresolved: path_str.into(),\n-            }\n-        })\n-    }\n-\n     fn resolve_self_ty(&self, path_str: &str, ns: Namespace, item_id: ItemId) -> Option<Res> {\n         if ns != TypeNS || path_str != \"Self\" {\n             return None;\n@@ -556,12 +531,12 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         module_id: DefId,\n         user_fragment: &Option<String>,\n     ) -> Result<(Res, Option<UrlFragment>), ErrorKind<'path>> {\n-        let (res, rustdoc_fragment) = self.resolve_inner(path_str, ns, item_id, module_id)?;\n+        let (res, rustdoc_fragment) = self\n+            .resolve_inner(path_str, ns, item_id, module_id)\n+            .map_err(|err| ErrorKind::Resolve(box err))?;\n         let chosen_fragment = match (user_fragment, rustdoc_fragment) {\n-            (Some(_), Some(r_frag)) => {\n-                let diag_res = match r_frag {\n-                    ItemFragment(_, did) => Res::Def(self.cx.tcx.def_kind(did), did),\n-                };\n+            (Some(_), Some(ItemFragment(_, did))) => {\n+                let diag_res = Res::Def(self.cx.tcx.def_kind(did), did);\n                 let failure = AnchorFailure::RustdocAnchorConflict(diag_res);\n                 return Err(ErrorKind::AnchorFailure(failure));\n             }\n@@ -578,7 +553,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         ns: Namespace,\n         item_id: ItemId,\n         module_id: DefId,\n-    ) -> Result<(Res, Option<ItemFragment>), ErrorKind<'path>> {\n+    ) -> Result<(Res, Option<ItemFragment>), ResolutionFailure<'path>> {\n         if let Some(res) = self.resolve_path(path_str, ns, item_id, module_id) {\n             match res {\n                 // FIXME(#76467): make this fallthrough to lookup the associated\n@@ -595,6 +570,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 // Not a trait item; just return what we found.\n                 _ => return Ok((res, None)),\n             }\n+        } else if ns == MacroNS {\n+            return Err(ResolutionFailure::NotResolved {\n+                item_id,\n+                module_id,\n+                partial_res: None,\n+                unresolved: path_str.into(),\n+            });\n         }\n \n         // Try looking for methods and associated items.\n@@ -639,8 +621,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         module_id,\n                         partial_res: None,\n                         unresolved: path_root.into(),\n-                    }\n-                    .into())\n+                    })\n                 }\n             })\n     }\n@@ -862,26 +843,15 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         module_id: DefId,\n         extra_fragment: &Option<String>,\n     ) -> Option<Res> {\n-        // resolve() can't be used for macro namespace\n-        let result = match ns {\n-            Namespace::MacroNS => self\n-                .resolve_macro(path_str, item_id, module_id)\n-                .map(|res| (res, None))\n-                .map_err(ErrorKind::from),\n-            Namespace::TypeNS | Namespace::ValueNS => {\n-                self.resolve(path_str, ns, item_id, module_id, extra_fragment)\n-            }\n-        };\n-\n-        let res = match result {\n+        let res = match self.resolve(path_str, ns, item_id, module_id, extra_fragment) {\n             Ok((res, frag)) => {\n                 if let Some(UrlFragment::Item(ItemFragment(_, id))) = frag {\n                     Some(Res::Def(self.cx.tcx.def_kind(id), id))\n                 } else {\n                     Some(res)\n                 }\n             }\n-            Err(ErrorKind::Resolve(box kind)) => kind.full_res(),\n+            Err(ErrorKind::Resolve(kind)) => kind.full_res(),\n             Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(res))) => Some(res),\n             Err(ErrorKind::AnchorFailure(AnchorFailure::MultipleAnchors)) => None,\n         };\n@@ -1481,80 +1451,57 @@ impl LinkCollector<'_, '_> {\n         let extra_fragment = &key.extra_fragment;\n \n         match disambiguator.map(Disambiguator::ns) {\n-            Some(expected_ns @ (ValueNS | TypeNS)) => {\n+            Some(expected_ns) => {\n                 match self.resolve(path_str, expected_ns, item_id, base_node, extra_fragment) {\n                     Ok(res) => Some(res),\n-                    Err(ErrorKind::Resolve(box mut kind)) => {\n+                    Err(ErrorKind::AnchorFailure(msg)) => {\n+                        anchor_failure(self.cx, diag, msg);\n+                        None\n+                    }\n+                    Err(ErrorKind::Resolve(mut err)) => {\n                         // We only looked in one namespace. Try to give a better error if possible.\n-                        if kind.full_res().is_none() {\n-                            let other_ns = if expected_ns == ValueNS { TypeNS } else { ValueNS };\n-                            // FIXME: really it should be `resolution_failure` that does this, not `resolve_with_disambiguator`\n-                            // See https://github.com/rust-lang/rust/pull/76955#discussion_r493953382 for a good approach\n-                            for new_ns in [other_ns, MacroNS] {\n+                        // FIXME: really it should be `resolution_failure` that does this, not `resolve_with_disambiguator`.\n+                        // See https://github.com/rust-lang/rust/pull/76955#discussion_r493953382 for a good approach.\n+                        for other_ns in [TypeNS, ValueNS, MacroNS] {\n+                            if other_ns != expected_ns {\n                                 if let Some(res) = self.check_full_res(\n-                                    new_ns,\n+                                    other_ns,\n                                     path_str,\n                                     item_id,\n                                     base_node,\n                                     extra_fragment,\n                                 ) {\n-                                    kind = ResolutionFailure::WrongNamespace { res, expected_ns };\n+                                    *err = ResolutionFailure::WrongNamespace { res, expected_ns };\n                                     break;\n                                 }\n                             }\n                         }\n-                        resolution_failure(self, diag, path_str, disambiguator, smallvec![kind]);\n+                        resolution_failure(self, diag, path_str, disambiguator, smallvec![*err]);\n                         // This could just be a normal link or a broken link\n                         // we could potentially check if something is\n                         // \"intra-doc-link-like\" and warn in that case.\n                         None\n                     }\n-                    Err(ErrorKind::AnchorFailure(msg)) => {\n-                        anchor_failure(self.cx, diag, msg);\n-                        None\n-                    }\n                 }\n             }\n             None => {\n                 // Try everything!\n-                let candidates = PerNS {\n-                    macro_ns: self\n-                        .resolve_macro(path_str, item_id, base_node)\n-                        .map(|res| (res, extra_fragment.clone().map(UrlFragment::UserWritten))),\n-                    type_ns: match self.resolve(\n-                        path_str,\n-                        TypeNS,\n-                        item_id,\n-                        base_node,\n-                        extra_fragment,\n-                    ) {\n-                        Ok(res) => {\n-                            debug!(\"got res in TypeNS: {:?}\", res);\n-                            Ok(res)\n-                        }\n+                let mut candidate =\n+                    |ns| match self.resolve(path_str, ns, item_id, base_node, extra_fragment) {\n+                        Ok(res) => Some(Ok(res)),\n                         Err(ErrorKind::AnchorFailure(msg)) => {\n-                            anchor_failure(self.cx, diag, msg);\n-                            return None;\n+                            anchor_failure(self.cx, diag.clone(), msg);\n+                            None\n                         }\n-                        Err(ErrorKind::Resolve(box kind)) => Err(kind),\n-                    },\n-                    value_ns: match self.resolve(\n-                        path_str,\n-                        ValueNS,\n-                        item_id,\n-                        base_node,\n-                        extra_fragment,\n-                    ) {\n-                        Ok(res) => Ok(res),\n-                        Err(ErrorKind::AnchorFailure(msg)) => {\n-                            anchor_failure(self.cx, diag, msg);\n-                            return None;\n-                        }\n-                        Err(ErrorKind::Resolve(box kind)) => Err(kind),\n-                    }\n-                    .and_then(|(res, fragment)| {\n-                        // Constructors are picked up in the type namespace.\n+                        Err(ErrorKind::Resolve(err)) => Some(Err(*err)),\n+                    };\n+\n+                let candidates = PerNS {\n+                    macro_ns: candidate(MacroNS)?,\n+                    type_ns: candidate(TypeNS)?,\n+                    value_ns: candidate(ValueNS)?.and_then(|(res, fragment)| {\n                         match res {\n+                            // Constructors are picked up in the type namespace.\n                             Res::Def(DefKind::Ctor(..), _) => {\n                                 Err(ResolutionFailure::WrongNamespace { res, expected_ns: TypeNS })\n                             }\n@@ -1604,29 +1551,6 @@ impl LinkCollector<'_, '_> {\n                     None\n                 }\n             }\n-            Some(MacroNS) => {\n-                match self.resolve_macro(path_str, item_id, base_node) {\n-                    Ok(res) => Some((res, extra_fragment.clone().map(UrlFragment::UserWritten))),\n-                    Err(mut kind) => {\n-                        // `resolve_macro` only looks in the macro namespace. Try to give a better error if possible.\n-                        for ns in [TypeNS, ValueNS] {\n-                            if let Some(res) = self.check_full_res(\n-                                ns,\n-                                path_str,\n-                                item_id,\n-                                base_node,\n-                                extra_fragment,\n-                            ) {\n-                                kind =\n-                                    ResolutionFailure::WrongNamespace { res, expected_ns: MacroNS };\n-                                break;\n-                            }\n-                        }\n-                        resolution_failure(self, diag, path_str, disambiguator, smallvec![kind]);\n-                        None\n-                    }\n-                }\n-            }\n         }\n     }\n }"}]}