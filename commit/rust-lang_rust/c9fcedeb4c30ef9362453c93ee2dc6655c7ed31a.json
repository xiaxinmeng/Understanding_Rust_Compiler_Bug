{"sha": "c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5ZmNlZGViNGMzMGVmOTM2MjQ1M2M5M2VlMmRjNjY1NWM3ZWQzMWE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-02-16T17:20:18Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-02-20T00:50:26Z"}, "message": "rustc_mir: optimize the deaggregator's expansion of statements.", "tree": {"sha": "504e6076949e9b0fe22c13a353863c6099570dea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/504e6076949e9b0fe22c13a353863c6099570dea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a", "html_url": "https://github.com/rust-lang/rust/commit/c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d773d95880b0866ce2bee4ab68ee6fa363235f84", "url": "https://api.github.com/repos/rust-lang/rust/commits/d773d95880b0866ce2bee4ab68ee6fa363235f84", "html_url": "https://github.com/rust-lang/rust/commit/d773d95880b0866ce2bee4ab68ee6fa363235f84"}], "stats": {"total": 161, "additions": 104, "deletions": 57}, "files": [{"sha": "2700ef28d671a09c7c0f813eab266fd073b25ba9", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a", "patch": "@@ -69,6 +69,7 @@\n #![feature(underscore_lifetimes)]\n #![feature(universal_impl_trait)]\n #![feature(trace_macros)]\n+#![feature(trusted_len)]\n #![feature(catch_expr)]\n #![feature(test)]\n "}, {"sha": "475946468fa35f6f9945ee9373ed16fd305d4109", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 62, "deletions": 3, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a", "patch": "@@ -34,13 +34,13 @@ use std::ascii;\n use std::borrow::{Cow};\n use std::cell::Ref;\n use std::fmt::{self, Debug, Formatter, Write};\n-use std::{iter, u32};\n+use std::{iter, mem, u32};\n use std::ops::{Index, IndexMut};\n use std::rc::Rc;\n use std::vec::IntoIter;\n use syntax::ast::{self, Name};\n use syntax::symbol::InternedString;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n mod cache;\n pub mod tcx;\n@@ -984,11 +984,62 @@ impl<'tcx> BasicBlockData<'tcx> {\n     pub fn retain_statements<F>(&mut self, mut f: F) where F: FnMut(&mut Statement) -> bool {\n         for s in &mut self.statements {\n             if !f(s) {\n-                s.kind = StatementKind::Nop;\n+                s.make_nop();\n             }\n         }\n     }\n \n+    pub fn expand_statements<F, I>(&mut self, mut f: F)\n+        where F: FnMut(&mut Statement<'tcx>) -> Option<I>,\n+              I: iter::TrustedLen<Item = Statement<'tcx>>\n+    {\n+        // Gather all the iterators we'll need to splice in, and their positions.\n+        let mut splices: Vec<(usize, I)> = vec![];\n+        let mut extra_stmts = 0;\n+        for (i, s) in self.statements.iter_mut().enumerate() {\n+            if let Some(mut new_stmts) = f(s) {\n+                if let Some(first) = new_stmts.next() {\n+                    // We can already store the first new statement.\n+                    *s = first;\n+\n+                    // Save the other statements for optimized splicing.\n+                    let remaining = new_stmts.size_hint().0;\n+                    if remaining > 0 {\n+                        splices.push((i + 1 + extra_stmts, new_stmts));\n+                        extra_stmts += remaining;\n+                    }\n+                } else {\n+                    s.make_nop();\n+                }\n+            }\n+        }\n+\n+        // Splice in the new statements, from the end of the block.\n+        // FIXME(eddyb) This could be more efficient with a \"gap buffer\"\n+        // where a range of elements (\"gap\") is left uninitialized, with\n+        // splicing adding new elements to the end of that gap and moving\n+        // existing elements from before the gap to the end of the gap.\n+        // For now, this is safe code, emulating a gap but initializing it.\n+        let mut gap = self.statements.len()..self.statements.len()+extra_stmts;\n+        self.statements.resize(gap.end, Statement {\n+            source_info: SourceInfo {\n+                span: DUMMY_SP,\n+                scope: ARGUMENT_VISIBILITY_SCOPE\n+            },\n+            kind: StatementKind::Nop\n+        });\n+        for (splice_start, new_stmts) in splices.into_iter().rev() {\n+            let splice_end = splice_start + new_stmts.size_hint().0;\n+            while gap.end > splice_end {\n+                gap.start -= 1;\n+                gap.end -= 1;\n+                self.statements.swap(gap.start, gap.end);\n+            }\n+            self.statements.splice(splice_start..splice_end, new_stmts);\n+            gap.end = splice_start;\n+        }\n+    }\n+\n     pub fn visitable(&self, index: usize) -> &dyn MirVisitable<'tcx> {\n         if index < self.statements.len() {\n             &self.statements[index]\n@@ -1157,6 +1208,14 @@ impl<'tcx> Statement<'tcx> {\n     pub fn make_nop(&mut self) {\n         self.kind = StatementKind::Nop\n     }\n+\n+    /// Changes a statement to a nop and returns the original statement.\n+    pub fn replace_nop(&mut self) -> Self {\n+        Statement {\n+            source_info: self.source_info,\n+            kind: mem::replace(&mut self.kind, StatementKind::Nop)\n+        }\n+    }\n }\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]"}, {"sha": "503354ebc4ffd0e064c5f6926086cb8ffc880a7c", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 26, "deletions": 43, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a", "patch": "@@ -39,32 +39,27 @@ impl MirPass for Deaggregator {\n             }\n         }\n \n-        let can_deaggregate = |statement: &Statement| {\n-            if let StatementKind::Assign(_, ref rhs) = statement.kind {\n-                if let Rvalue::Aggregate(ref kind, _) = *rhs {\n-                    // FIXME(#48193) Deaggregate arrays when it's cheaper to do so.\n-                    if let AggregateKind::Array(_) = **kind {\n-                        return false;\n-                    }\n-                    return true;\n-                }\n-            }\n-\n-            false\n-        };\n-\n         let (basic_blocks, local_decls) = mir.basic_blocks_and_local_decls_mut();\n+        let local_decls = &*local_decls;\n         for bb in basic_blocks {\n-            let mut start = 0;\n-            while let Some(i) = bb.statements[start..].iter().position(&can_deaggregate) {\n-                let i = start + i;\n+            bb.expand_statements(|stmt| {\n+                // FIXME(eddyb) don't match twice on `stmt.kind` (post-NLL).\n+                if let StatementKind::Assign(_, ref rhs) = stmt.kind {\n+                    if let Rvalue::Aggregate(ref kind, _) = *rhs {\n+                        // FIXME(#48193) Deaggregate arrays when it's cheaper to do so.\n+                        if let AggregateKind::Array(_) = **kind {\n+                            return None;\n+                        }\n+                    } else {\n+                        return None;\n+                    }\n+                } else {\n+                    return None;\n+                }\n \n-                // FIXME(eddyb) this is probably more expensive than it should be.\n-                // Ideally we'd move the block's statements all at once.\n-                let suffix_stmts = bb.statements.split_off(i + 1);\n-                let orig_stmt = bb.statements.pop().unwrap();\n-                let source_info = orig_stmt.source_info;\n-                let (mut lhs, kind, operands) = match orig_stmt.kind {\n+                let stmt = stmt.replace_nop();\n+                let source_info = stmt.source_info;\n+                let (mut lhs, kind, operands) = match stmt.kind {\n                     StatementKind::Assign(lhs, Rvalue::Aggregate(kind, operands))\n                         => (lhs, kind, operands),\n                     _ => bug!()\n@@ -88,17 +83,11 @@ impl MirPass for Deaggregator {\n                     _ => None\n                 };\n \n-                let new_total_count = bb.statements.len() +\n-                    operands.len() +\n-                    (set_discriminant.is_some() as usize) +\n-                    suffix_stmts.len();\n-                bb.statements.reserve(new_total_count);\n-\n-                for (j, op) in operands.into_iter().enumerate() {\n+                Some(operands.into_iter().enumerate().map(move |(i, op)| {\n                     let lhs_field = if let AggregateKind::Array(_) = *kind {\n                         // FIXME(eddyb) `offset` should be u64.\n-                        let offset = j as u32;\n-                        assert_eq!(offset as usize, j);\n+                        let offset = i as u32;\n+                        assert_eq!(offset as usize, i);\n                         lhs.clone().elem(ProjectionElem::ConstantIndex {\n                             offset,\n                             // FIXME(eddyb) `min_length` doesn't appear to be used.\n@@ -107,21 +96,15 @@ impl MirPass for Deaggregator {\n                         })\n                     } else {\n                         let ty = op.ty(local_decls, tcx);\n-                        let field = Field::new(active_field_index.unwrap_or(j));\n+                        let field = Field::new(active_field_index.unwrap_or(i));\n                         lhs.clone().field(field, ty)\n                     };\n-                    bb.statements.push(Statement {\n+                    Statement {\n                         source_info,\n                         kind: StatementKind::Assign(lhs_field, Rvalue::Use(op)),\n-                    });\n-                }\n-\n-                // If the aggregate was an enum, we need to set the discriminant.\n-                bb.statements.extend(set_discriminant);\n-\n-                start = bb.statements.len();\n-                bb.statements.extend(suffix_stmts);\n-            }\n+                    }\n+                }).chain(set_discriminant))\n+            });\n         }\n     }\n }"}, {"sha": "feadec6bbf76e2667c1ed13be581cbddf3337e95", "filename": "src/test/mir-opt/copy_propagation_arg.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.rs?ref=c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a", "patch": "@@ -78,6 +78,7 @@ fn main() {\n // bb1: {\n //     StorageDead(_3);\n //     _1 = const 5u8;\n+//     ...\n //     return;\n // }\n // END rustc.bar.CopyPropagation.before.mir\n@@ -91,6 +92,7 @@ fn main() {\n //     ...\n //     _1 = const 5u8;\n //     ...\n+//     return;\n // }\n // END rustc.bar.CopyPropagation.after.mir\n // START rustc.baz.CopyPropagation.before.mir\n@@ -99,6 +101,7 @@ fn main() {\n //     _2 = _1;\n //     _1 = move _2;\n //     StorageDead(_2);\n+//     ...\n //     return;\n // }\n // END rustc.baz.CopyPropagation.before.mir\n@@ -108,21 +111,22 @@ fn main() {\n //     _2 = _1;\n //     _1 = move _2;\n //     ...\n+//     return;\n // }\n // END rustc.baz.CopyPropagation.after.mir\n // START rustc.arg_src.CopyPropagation.before.mir\n // bb0: {\n-//       ...\n-//       _3 = _1;\n-//       _2 = move _3;\n-//       ...\n-//       _1 = const 123i32;\n-//       ...\n-//       _4 = _2;\n-//       _0 = move _4;\n-//       ...\n-//       return;\n-//   }\n+//      ...\n+//      _3 = _1;\n+//      _2 = move _3;\n+//      ...\n+//      _1 = const 123i32;\n+//      ...\n+//      _4 = _2;\n+//      _0 = move _4;\n+//      ...\n+//      return;\n+//  }\n // END rustc.arg_src.CopyPropagation.before.mir\n // START rustc.arg_src.CopyPropagation.after.mir\n // bb0: {"}]}