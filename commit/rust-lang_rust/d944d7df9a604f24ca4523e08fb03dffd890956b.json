{"sha": "d944d7df9a604f24ca4523e08fb03dffd890956b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5NDRkN2RmOWE2MDRmMjRjYTQ1MjNlMDhmYjAzZGZmZDg5MDk1NmI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-01-13T16:04:56Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-01-13T16:04:56Z"}, "message": "rustup to 2017-01-12", "tree": {"sha": "1529087d3884f191d15294e95b5a73e7872d26f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1529087d3884f191d15294e95b5a73e7872d26f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d944d7df9a604f24ca4523e08fb03dffd890956b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJYePqoAAoJEFbW7qD8Z6xGGDoQAJh7PGUFABCNnZH9g1A8MFzg\nUpg5Kd3b4Dbreb/hs6xCIq+deUf4qL58RNUKuvoSntZPT90xWdBsAVtdaf1PzgXo\nWIl9TaOVYDh+D3z9cpODyhxjuMDGft6hIp2HeeF5Ag7cZbv0M2KTCIa+kfvwKGMG\nGpwdpnbuv6nIf0mFrFxdUSbLPfnSzPTqCWuJZlsx1kBS81vHsYC5cqrvY/Upl7Al\neKpWdQ3OFLHFt1rZnXjyhAP9DONJXs6VuNwxL6KPnfd+yAppNFRQfWsU9z5JdQxE\nyAKVmQeuWfumvjEbCofMo5B7+uZyiyH1DvMz/qwI7SQm5sAc3BTkok3kv6yxO4t5\nC+CbJ9qy8b1oh7CRO0q3NaMFITUjp8GZe9ZovZ8YWRwYJG5ua5X3kXyiS1c39snf\njHBJgpYXJli2y0ldTOGDfEoBa6UBacEMNpgKJg5ZFHi3j95uR3LC2X0mpv9qVF0D\nySTf8jhQS7cOWW13YN3ymDucyx0R/2Bmni/eDe0ZvCtwU3+s9Rp0s6aOL6G1Q7zN\nFkuUibe9pH1h7tLLUU1agsJV+UFPgTrMgcNkYsIu1agrC+TLh9prDWI68FE1tpNo\nyKgyrNWHmbQpUWySGhY+NCcTTIw8QpaIGc70wB5hzcV7hA0QpsME+DFy6AI9hus5\nwG/3Ydbg15wBYM+9Na/T\n=vzGO\n-----END PGP SIGNATURE-----", "payload": "tree 1529087d3884f191d15294e95b5a73e7872d26f5\nparent d93b96949d1e63a102e946f07b5d1a1ae9a55793\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1484323496 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1484323496 +0100\n\nrustup to 2017-01-12"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d944d7df9a604f24ca4523e08fb03dffd890956b", "html_url": "https://github.com/rust-lang/rust/commit/d944d7df9a604f24ca4523e08fb03dffd890956b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d944d7df9a604f24ca4523e08fb03dffd890956b/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d93b96949d1e63a102e946f07b5d1a1ae9a55793", "url": "https://api.github.com/repos/rust-lang/rust/commits/d93b96949d1e63a102e946f07b5d1a1ae9a55793", "html_url": "https://github.com/rust-lang/rust/commit/d93b96949d1e63a102e946f07b5d1a1ae9a55793"}], "stats": {"total": 484, "additions": 245, "deletions": 239}, "files": [{"sha": "75c82f7a17b5ea16908933c91815a2a145a7865d", "filename": "CHANGELOG.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -1,6 +1,9 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+## 0.0.108 \u2014 2017-01-12\n+* Update to *rustc 1.16.0-nightly (2782e8f8f 2017-01-12)*\n+\n ## 0.0.107 \u2014 2017-01-11\n * Update regex dependency\n * Fix FP when matching `&&mut` by `&ref`"}, {"sha": "57de582f59de5535ce4d1faeea446dc2918f1f09", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.107\"\n+version = \"0.0.108\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\",\n@@ -25,7 +25,7 @@ test = false\n \n [dependencies]\n # begin automatic update\n-clippy_lints = { version = \"0.0.107\", path = \"clippy_lints\" }\n+clippy_lints = { version = \"0.0.108\", path = \"clippy_lints\" }\n # end automatic update\n \n [dev-dependencies]"}, {"sha": "dd73edc44b280c498c06fe711d6d4a7cb5ce4423", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"clippy_lints\"\n # begin automatic update\n-version = \"0.0.107\"\n+version = \"0.0.108\"\n # end automatic update\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\","}, {"sha": "8c370213f8089ed557c0baea25a13a0113e830cd", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n                     hir::BiShr | hir::BiEq | hir::BiLt | hir::BiLe | hir::BiNe | hir::BiGe | hir::BiGt => return,\n                     _ => (),\n                 }\n-                let (l_ty, r_ty) = (cx.tcx.tables().expr_ty(l), cx.tcx.tables().expr_ty(r));\n+                let (l_ty, r_ty) = (cx.tables.expr_ty(l), cx.tables.expr_ty(r));\n                 if l_ty.is_integral() && r_ty.is_integral() {\n                     span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n                     self.span = Some(expr.span);\n@@ -69,7 +69,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n                 }\n             },\n             hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n-                let ty = cx.tcx.tables().expr_ty(arg);\n+                let ty = cx.tables.expr_ty(arg);\n                 if ty.is_integral() {\n                     span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n                     self.span = Some(expr.span);"}, {"sha": "74e9dfddc1cd3d26924d8192e9a1ec3abb41b729", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n-use rustc_const_eval::eval_const_expr_partial;\n+use rustc_const_eval::ConstContext;\n use rustc_const_math::ConstInt;\n use rustc::hir;\n use syntax::ast::RangeLimits;\n@@ -59,12 +59,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n         if let hir::ExprIndex(ref array, ref index) = e.node {\n             // Array with known size can be checked statically\n-            let ty = cx.tcx.tables().expr_ty(array);\n+            let ty = cx.tables.expr_ty(array);\n             if let ty::TyArray(_, size) = ty.sty {\n                 let size = ConstInt::Infer(size as u128);\n+                let constcx = ConstContext::with_tables(cx.tcx, cx.tables);\n \n                 // Index is a constant uint\n-                let const_index = eval_const_expr_partial(cx.tcx, index, ExprTypeChecked, None);\n+                let const_index = constcx.eval(index, ExprTypeChecked);\n                 if let Ok(ConstVal::Integral(const_index)) = const_index {\n                     if size <= const_index {\n                         utils::span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"const index is out of bounds\");\n@@ -76,10 +77,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n                 // Index is a constant range\n                 if let Some(range) = higher::range(index) {\n                     let start = range.start\n-                        .map(|start| eval_const_expr_partial(cx.tcx, start, ExprTypeChecked, None))\n+                        .map(|start| constcx.eval(start, ExprTypeChecked))\n                         .map(|v| v.ok());\n                     let end = range.end\n-                        .map(|end| eval_const_expr_partial(cx.tcx, end, ExprTypeChecked, None))\n+                        .map(|end| constcx.eval(end, ExprTypeChecked))\n                         .map(|v| v.ok());\n \n                     if let Some((start, end)) = to_const_range(start, end, range.limits, size) {"}, {"sha": "fa996beb445c5c1fafbcc02ec3c1f14ac35ac073", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -82,11 +82,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                 if let hir::ExprBinary(binop, ref l, ref r) = rhs.node {\n                     if op.node == binop.node {\n                         let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n-                            let ty = cx.tcx.tables().expr_ty(assignee);\n+                            let ty = cx.tables.expr_ty(assignee);\n                             if ty.walk_shallow().next().is_some() {\n                                 return; // implements_trait does not work with generics\n                             }\n-                            let rty = cx.tcx.tables().expr_ty(rhs);\n+                            let rty = cx.tables.expr_ty(rhs);\n                             if rty.walk_shallow().next().is_some() {\n                                 return; // implements_trait does not work with generics\n                             }\n@@ -116,12 +116,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n             },\n             hir::ExprAssign(ref assignee, ref e) => {\n                 if let hir::ExprBinary(op, ref l, ref r) = e.node {\n+                    #[allow(cyclomatic_complexity)]\n                     let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n-                        let ty = cx.tcx.tables().expr_ty(assignee);\n+                        let ty = cx.tables.expr_ty(assignee);\n                         if ty.walk_shallow().next().is_some() {\n                             return; // implements_trait does not work with generics\n                         }\n-                        let rty = cx.tcx.tables().expr_ty(rhs);\n+                        let rty = cx.tables.expr_ty(rhs);\n                         if rty.walk_shallow().next().is_some() {\n                             return; // implements_trait does not work with generics\n                         }"}, {"sha": "e908aa02c40d506b361353080c2422ab08dcb9c7", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -3,10 +3,11 @@\n use reexport::*;\n use rustc::lint::*;\n use rustc::hir::*;\n+use rustc::ty;\n use semver::Version;\n use syntax::ast::{Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use syntax::codemap::Span;\n-use utils::{in_macro, match_def_path, resolve_node, paths, span_lint, span_lint_and_then, snippet_opt};\n+use utils::{in_macro, match_def_path, paths, span_lint, span_lint_and_then, snippet_opt};\n \n /// **What it does:** Checks for items annotated with `#[inline(always)]`,\n /// unless the annotated function is empty or simply panics.\n@@ -102,7 +103,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if is_relevant_item(cx, item) {\n+        if is_relevant_item(cx.tcx, item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n         match item.node {\n@@ -143,64 +144,66 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n-        if is_relevant_impl(cx, item) {\n+        if is_relevant_impl(cx.tcx, item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n-        if is_relevant_trait(cx, item) {\n+        if is_relevant_trait(cx.tcx, item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n     }\n }\n \n-fn is_relevant_item(cx: &LateContext, item: &Item) -> bool {\n+fn is_relevant_item(tcx: ty::TyCtxt, item: &Item) -> bool {\n     if let ItemFn(_, _, _, _, _, eid) = item.node {\n-        is_relevant_expr(cx, &cx.tcx.map.body(eid).value)\n+        is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.map.body(eid).value)\n     } else {\n         false\n     }\n }\n \n-fn is_relevant_impl(cx: &LateContext, item: &ImplItem) -> bool {\n+fn is_relevant_impl(tcx: ty::TyCtxt, item: &ImplItem) -> bool {\n     match item.node {\n-        ImplItemKind::Method(_, eid) => is_relevant_expr(cx, &cx.tcx.map.body(eid).value),\n+        ImplItemKind::Method(_, eid) => is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.map.body(eid).value),\n         _ => false,\n     }\n }\n \n-fn is_relevant_trait(cx: &LateContext, item: &TraitItem) -> bool {\n+fn is_relevant_trait(tcx: ty::TyCtxt, item: &TraitItem) -> bool {\n     match item.node {\n         TraitItemKind::Method(_, TraitMethod::Required(_)) => true,\n-        TraitItemKind::Method(_, TraitMethod::Provided(eid)) => is_relevant_expr(cx, &cx.tcx.map.body(eid).value),\n+        TraitItemKind::Method(_, TraitMethod::Provided(eid)) => {\n+            is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.map.body(eid).value)\n+        },\n         _ => false,\n     }\n }\n \n-fn is_relevant_block(cx: &LateContext, block: &Block) -> bool {\n+fn is_relevant_block(tcx: ty::TyCtxt, tables: &ty::Tables, block: &Block) -> bool {\n     for stmt in &block.stmts {\n         match stmt.node {\n             StmtDecl(_, _) => return true,\n             StmtExpr(ref expr, _) |\n             StmtSemi(ref expr, _) => {\n-                return is_relevant_expr(cx, expr);\n+                return is_relevant_expr(tcx, tables, expr);\n             },\n         }\n     }\n-    block.expr.as_ref().map_or(false, |e| is_relevant_expr(cx, e))\n+    block.expr.as_ref().map_or(false, |e| is_relevant_expr(tcx, tables, e))\n }\n \n-fn is_relevant_expr(cx: &LateContext, expr: &Expr) -> bool {\n+fn is_relevant_expr(tcx: ty::TyCtxt, tables: &ty::Tables, expr: &Expr) -> bool {\n     match expr.node {\n-        ExprBlock(ref block) => is_relevant_block(cx, block),\n-        ExprRet(Some(ref e)) => is_relevant_expr(cx, e),\n+        ExprBlock(ref block) => is_relevant_block(tcx, tables, block),\n+        ExprRet(Some(ref e)) => is_relevant_expr(tcx, tables, e),\n         ExprRet(None) |\n         ExprBreak(_, None) => false,\n         ExprCall(ref path_expr, _) => {\n             if let ExprPath(ref qpath) = path_expr.node {\n-                let fun_id = resolve_node(cx, qpath, path_expr.id).def_id();\n-                !match_def_path(cx, fun_id, &paths::BEGIN_PANIC)\n+                let fun_id = tables.qpath_def(qpath, path_expr.id).def_id();\n+                !match_def_path(tcx, fun_id, &paths::BEGIN_PANIC)\n             } else {\n                 true\n             }"}, {"sha": "ce886193e2673e1620d8fe00d407417866f208e0", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -246,9 +246,9 @@ fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u128> {\n             }\n         },\n         ExprPath(ref qpath) => {\n-            let def = cx.tcx.tables().qpath_def(qpath, lit.id);\n+            let def = cx.tables.qpath_def(qpath, lit.id);\n             if let Def::Const(def_id) = def {\n-                lookup_const_by_id(cx.tcx, def_id, None).and_then(|(l, _ty)| fetch_int_literal(cx, l))\n+                lookup_const_by_id(cx.tcx, def_id, None).and_then(|(l, _tab, _ty)| fetch_int_literal(cx, l))\n             } else {\n                 None\n             }"}, {"sha": "67034c1673305865daa87d2ab7e8f7635280e7dc", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -1,8 +1,8 @@\n use rustc::lint::{LintArray, LateLintPass, LateContext, LintPass};\n use rustc::hir::*;\n use rustc::hir::intravisit::*;\n-use syntax::ast::{LitKind, DUMMY_NODE_ID};\n-use syntax::codemap::{DUMMY_SP, dummy_spanned};\n+use syntax::ast::{LitKind, DUMMY_NODE_ID, NodeId};\n+use syntax::codemap::{DUMMY_SP, dummy_spanned, Span};\n use syntax::util::ThinVec;\n use utils::{span_lint_and_then, in_macro, snippet_opt, SpanlessEq};\n \n@@ -54,8 +54,16 @@ impl LintPass for NonminimalBool {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonminimalBool {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        NonminimalBoolVisitor { cx: cx }.visit_item(item)\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        _: intravisit::FnKind<'tcx>,\n+        _: &'tcx FnDecl,\n+        body: &'tcx Body,\n+        _: Span,\n+        _: NodeId\n+    ) {\n+        NonminimalBoolVisitor { cx: cx }.visit_body(body)\n     }\n }\n \n@@ -394,7 +402,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n         match e.node {\n             ExprBinary(binop, _, _) if binop.node == BiOr || binop.node == BiAnd => self.bool_expr(e),\n             ExprUnary(UnNot, ref inner) => {\n-                if self.cx.tcx.tables.borrow().node_types[&inner.id].is_bool() {\n+                if self.cx.tables.node_types[&inner.id].is_bool() {\n                     self.bool_expr(e);\n                 } else {\n                     walk_expr(self, e);\n@@ -404,6 +412,6 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n         }\n     }\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.cx.tcx.map)\n+        NestedVisitorMap::None\n     }\n }"}, {"sha": "3c5eda777644489f5decce8eb398bbcb8e875f3b", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -295,15 +295,14 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     /// lookup a possibly constant expression from a ExprPath\n     fn fetch_path(&mut self, qpath: &QPath, id: NodeId) -> Option<Constant> {\n         if let Some(lcx) = self.lcx {\n-            let def = lcx.tcx.tables().qpath_def(qpath, id);\n+            let def = lcx.tables.qpath_def(qpath, id);\n             match def {\n                 Def::Const(def_id) |\n                 Def::AssociatedConst(def_id) => {\n-                    let substs = Some(lcx.tcx\n-                        .tables()\n+                    let substs = Some(lcx.tables\n                         .node_id_item_substs(id)\n                         .unwrap_or_else(|| lcx.tcx.intern_substs(&[])));\n-                    if let Some((const_expr, _ty)) = lookup_const_by_id(lcx.tcx, def_id, substs) {\n+                    if let Some((const_expr, _tab, _ty)) = lookup_const_by_id(lcx.tcx, def_id, substs) {\n                         let ret = self.expr(const_expr);\n                         if ret.is_some() {\n                             self.needed_resolution = true;"}, {"sha": "253e7e160fa6a8aea92cf927b809ef097f979098", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -263,7 +263,7 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<Interned\n             },\n             PatKind::Binding(_, _, ref ident, ref as_pat) => {\n                 if let Entry::Vacant(v) = map.entry(ident.node.as_str()) {\n-                    v.insert(cx.tcx.tables().pat_ty(pat));\n+                    v.insert(cx.tables.pat_ty(pat));\n                 }\n                 if let Some(ref as_pat) = *as_pat {\n                     bindings_impl(cx, as_pat, map);"}, {"sha": "0a452f8ae130341541376a837ff74970adb21fef", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -2,11 +2,10 @@\n \n use rustc::cfg::CFG;\n use rustc::lint::*;\n-use rustc::ty;\n use rustc::hir::*;\n+use rustc::ty;\n use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n-use syntax::ast::Attribute;\n-use syntax::attr;\n+use syntax::ast::{Attribute, NodeId};\n use syntax::codemap::Span;\n \n use utils::{in_macro, LimitStack, span_help_and_lint, paths, match_type};\n@@ -64,7 +63,7 @@ impl CyclomaticComplexity {\n         };\n         helper.visit_expr(expr);\n         let CCHelper { match_arms, divergence, short_circuits, returns, .. } = helper;\n-        let ret_ty = cx.tcx.tables().node_id_to_type(expr.id);\n+        let ret_ty = cx.tables.node_id_to_type(expr.id);\n         let ret_adjust = if match_type(cx, ret_ty, &paths::RESULT) {\n             returns\n         } else {\n@@ -91,23 +90,18 @@ impl CyclomaticComplexity {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CyclomaticComplexity {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemFn(_, _, _, _, _, eid) = item.node {\n-            if !attr::contains_name(&item.attrs, \"test\") {\n-                self.check(cx, &cx.tcx.map.body(eid).value, item.span);\n-            }\n-        }\n-    }\n-\n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n-        if let ImplItemKind::Method(_, eid) = item.node {\n-            self.check(cx, &cx.tcx.map.body(eid).value, item.span);\n-        }\n-    }\n-\n-    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n-        if let TraitItemKind::Method(_, TraitMethod::Provided(eid)) = item.node {\n-            self.check(cx, &cx.tcx.map.body(eid).value, item.span);\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        _: intravisit::FnKind<'tcx>,\n+        _: &'tcx FnDecl,\n+        body: &'tcx Body,\n+        span: Span,\n+        node_id: NodeId\n+    ) {\n+        let def_id = cx.tcx.map.local_def_id(node_id);\n+        if !cx.tcx.has_attr(def_id, \"test\") {\n+            self.check(cx, &body.value, span);\n         }\n     }\n \n@@ -139,7 +133,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n             },\n             ExprCall(ref callee, _) => {\n                 walk_expr(self, e);\n-                let ty = self.cx.tcx.tables().node_id_to_type(callee.id);\n+                let ty = self.cx.tables.node_id_to_type(callee.id);\n                 match ty.sty {\n                     ty::TyFnDef(_, _, ty) |\n                     ty::TyFnPtr(ty) if ty.sig.skip_binder().output().sty == ty::TyNever => {"}, {"sha": "c0c9a7e6800b3f56aac3ff2e25e86d28e1a383d5", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -61,22 +61,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             let ExprPath(ref qpath) = path.node,\n             args.len() == 1,\n         ], {\n-            let def_id = cx.tcx.tables().qpath_def(qpath, path.id).def_id();\n+            let def_id = cx.tables.qpath_def(qpath, path.id).def_id();\n             let lint;\n             let msg;\n-            if match_def_path(cx, def_id, &paths::DROP) {\n+            if match_def_path(cx.tcx, def_id, &paths::DROP) {\n                 lint = DROP_REF;\n                 msg = \"call to `std::mem::drop` with a reference argument. \\\n                        Dropping a reference does nothing\";\n-            } else if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n+            } else if match_def_path(cx.tcx, def_id, &paths::MEM_FORGET) {\n                 lint = FORGET_REF;\n                 msg = \"call to `std::mem::forget` with a reference argument. \\\n                        Forgetting a reference does nothing\";\n             } else {\n                 return;\n             }\n             let arg = &args[0];\n-            let arg_ty = cx.tcx.tables().expr_ty(arg);\n+            let arg_ty = cx.tables.expr_ty(arg);\n             if let ty::TyRef(..) = arg_ty.sty {\n                 span_note_and_lint(cx,\n                                    lint,"}, {"sha": "50bd62a855abf88ef4556cc802b0b1eb5265606c", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -89,7 +89,7 @@ fn check_cond<'a, 'tcx, 'b>(\n         let ExprAddrOf(_, ref key) = params[1].node\n     ], {\n         let map = &params[0];\n-        let obj_ty = walk_ptrs_ty(cx.tcx.tables().expr_ty(map));\n+        let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(map));\n \n         return if match_type(cx, obj_ty, &paths::BTREEMAP) {\n             Some((\"BTreeMap\", map, key))"}, {"sha": "a73f68fcb58e9ab1296787b97bf608522c26f1e1", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -44,10 +44,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n                 let variant = &var.node;\n                 if let Some(body_id) = variant.disr_expr {\n                     use rustc_const_eval::*;\n-                    let bad = match eval_const_expr_partial(cx.tcx,\n-                                                            &cx.tcx.map.body(body_id).value,\n-                                                            EvalHint::ExprTypeChecked,\n-                                                            None) {\n+                    let constcx = ConstContext::new(cx.tcx, body_id);\n+                    let bad = match constcx.eval(&cx.tcx.map.body(body_id).value, EvalHint::ExprTypeChecked) {\n                         Ok(ConstVal::Integral(Usize(Us64(i)))) => i as u32 as u64 != i,\n                         Ok(ConstVal::Integral(Isize(Is64(i)))) => i as i32 as i64 != i,\n                         _ => false,"}, {"sha": "b7d46bd6c2590906b969249347f88d4a8913bde9", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -49,6 +49,7 @@ fn is_non_trait_box(ty: ty::Ty) -> bool {\n struct EscapeDelegate<'a, 'tcx: 'a> {\n     set: NodeSet,\n     tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: &'a ty::Tables<'tcx>,\n     target: TargetDataLayout,\n     too_large_for_stack: u64,\n }\n@@ -67,19 +68,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         _: &'tcx FnDecl,\n         body: &'tcx Body,\n         _: Span,\n-        id: NodeId\n+        _id: NodeId\n     ) {\n         // we store the infcx because it is expensive to recreate\n         // the context each time.\n         let mut v = EscapeDelegate {\n             set: NodeSet(),\n             tcx: cx.tcx,\n+            tables: cx.tables,\n             target: TargetDataLayout::parse(cx.sess()),\n             too_large_for_stack: self.too_large_for_stack,\n         };\n-        let param_env = ty::ParameterEnvironment::for_item(cx.tcx, id);\n \n-        let infcx = cx.tcx.borrowck_fake_infer_ctxt(param_env);\n+        let infcx = cx.tcx.borrowck_fake_infer_ctxt(body.id());\n         {\n             let mut vis = ExprUseVisitor::new(&mut v, &infcx);\n             vis.consume_body(body);\n@@ -161,9 +162,7 @@ impl<'a, 'tcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n         if let Categorization::Local(lid) = cmt.cat {\n             if self.set.contains(&lid) {\n                 if let Some(&Adjust::DerefRef { autoderefs, .. }) =\n-                    self.tcx\n-                        .tables\n-                        .borrow()\n+                    self.tables\n                         .adjustments\n                         .get(&borrow_id)\n                         .map(|a| &a.kind) {\n@@ -178,9 +177,7 @@ impl<'a, 'tcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n                 } else if LoanCause::AddrOf == loan_cause {\n                     // &x\n                     if let Some(&Adjust::DerefRef { autoderefs, .. }) =\n-                        self.tcx\n-                            .tables\n-                            .borrow()\n+                        self.tables\n                             .adjustments\n                             .get(&self.tcx\n                                 .map\n@@ -209,7 +206,7 @@ impl<'a, 'tcx: 'a> EscapeDelegate<'a, 'tcx> {\n         // overflows.\n         match ty.sty {\n             ty::TyBox(inner) => {\n-                self.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+                self.tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n                     if let Ok(layout) = inner.layout(&infcx) {\n                         let size = layout.size(&self.target);\n                         size.bytes() > self.too_large_for_stack"}, {"sha": "b35a9613a183bd48531bca262e9d6b2b8340c472", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -61,7 +61,7 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                 // Are the expression or the arguments type-adjusted? Then we need the closure\n                 return;\n             }\n-            let fn_ty = cx.tcx.tables().expr_ty(caller);\n+            let fn_ty = cx.tables.expr_ty(caller);\n             match fn_ty.sty {\n                 // Is it an unsafe function? They don't implement the closure traits\n                 ty::TyFnDef(_, _, fn_ty) |"}, {"sha": "c54b77a037c41c288ef17892cc88a8e9a3e355ac", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n                 if let ExprPath(ref qpath) = lhs.node {\n                     if let QPath::Resolved(_, ref path) = *qpath {\n                         if path.segments.len() == 1 {\n-                            let var = cx.tcx.tables().qpath_def(qpath, lhs.id).def_id();\n+                            let var = cx.tables.qpath_def(qpath, lhs.id).def_id();\n                             let mut visitor = ReadVisitor {\n                                 cx: cx,\n                                 var: var,\n@@ -126,7 +126,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n         match e.node {\n             ExprAgain(_) | ExprBreak(_, _) | ExprRet(_) => self.report_diverging_sub_expr(e),\n             ExprCall(ref func, _) => {\n-                match self.cx.tcx.tables().expr_ty(func).sty {\n+                match self.cx.tables.expr_ty(func).sty {\n                     ty::TyFnDef(_, _, fn_ty) |\n                     ty::TyFnPtr(fn_ty) => {\n                         if let ty::TyNever = self.cx.tcx.erase_late_bound_regions(&fn_ty.sig).output().sty {\n@@ -138,7 +138,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n             },\n             ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(e.id);\n-                let borrowed_table = self.cx.tcx.tables.borrow();\n+                let borrowed_table = self.cx.tables;\n                 let method_type = borrowed_table.method_map.get(&method_call).expect(\"This should never happen.\");\n                 let result_ty = method_type.ty.fn_ret();\n                 if let ty::TyNever = self.cx.tcx.erase_late_bound_regions(&result_ty).sty {\n@@ -302,7 +302,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n         match expr.node {\n             ExprPath(ref qpath) => {\n                 if let QPath::Resolved(None, ref path) = *qpath {\n-                    if path.segments.len() == 1 && self.cx.tcx.tables().qpath_def(qpath, expr.id).def_id() == self.var {\n+                    if path.segments.len() == 1 && self.cx.tables.qpath_def(qpath, expr.id).def_id() == self.var {\n                         if is_in_assignment_position(self.cx, expr) {\n                             // This is a write, not a read.\n                         } else {"}, {"sha": "6281d34dd939d21a97cbdfdb7f4260fcbe00d1bf", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     if_let_chain!{[\n                         let ExprPath(ref qpath) = fun.node,\n                         args.len() == 2,\n-                        match_def_path(cx, resolve_node(cx, qpath, fun.id).def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n+                        match_def_path(cx.tcx, resolve_node(cx, qpath, fun.id).def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n                         // ensure the format string is `\"{..}\"` with only one argument and no text\n                         check_static_str(cx, &args[0]),\n                         // ensure the format argument is `{}` ie. Display with no fancy option\n@@ -128,9 +128,9 @@ fn check_arg_is_display(cx: &LateContext, expr: &Expr) -> bool {\n         let ExprCall(_, ref args) = exprs[0].node,\n         args.len() == 2,\n         let ExprPath(ref qpath) = args[1].node,\n-        match_def_path(cx, resolve_node(cx, qpath, args[1].id).def_id(), &paths::DISPLAY_FMT_METHOD),\n+        match_def_path(cx.tcx, resolve_node(cx, qpath, args[1].id).def_id(), &paths::DISPLAY_FMT_METHOD),\n     ], {\n-        let ty = walk_ptrs_ty(cx.tcx.tables().pat_ty(&pat[0]));\n+        let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));\n \n         return ty.sty == TypeVariants::TyStr || match_type(cx, ty, &paths::STRING);\n     }}"}, {"sha": "86548854272936e5ebe2d2bca0ac8d5a21444170", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -175,7 +175,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprCall(ref f, ref args) => {\n-                let ty = self.cx.tcx.tables().expr_ty(f);\n+                let ty = self.cx.tables.expr_ty(f);\n \n                 if type_is_unsafe_function(ty) {\n                     for arg in args {\n@@ -185,7 +185,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n             },\n             hir::ExprMethodCall(_, _, ref args) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let base_type = self.cx.tcx.tables.borrow().method_map[&method_call].ty;\n+                let base_type = self.cx.tables.method_map[&method_call].ty;\n \n                 if type_is_unsafe_function(base_type) {\n                     for arg in args {\n@@ -207,7 +207,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n impl<'a, 'tcx: 'a> DerefVisitor<'a, 'tcx> {\n     fn check_arg(&self, ptr: &hir::Expr) {\n         if let hir::ExprPath(ref qpath) = ptr.node {\n-            let def = self.cx.tcx.tables().qpath_def(qpath, ptr.id);\n+            let def = self.cx.tables.qpath_def(qpath, ptr.id);\n             if self.ptrs.contains(&def.def_id()) {\n                 span_lint(self.cx,\n                           NOT_UNSAFE_PTR_ARG_DEREF,"}, {"sha": "6f4d69cbd5a2f8aa779750d355f16f8efac26608", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -203,7 +203,7 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n         })\n     }\n \n-    let ty = &walk_ptrs_ty(cx.tcx.tables().expr_ty(expr));\n+    let ty = &walk_ptrs_ty(cx.tables.expr_ty(expr));\n     match ty.sty {\n         ty::TyDynamic(..) => {\n             cx.tcx"}, {"sha": "618869021ee60e2e0620b4772b3e78600f33b575", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if_let_chain! {[\n             let hir::ExprPath(ref qpath) = expr.node,\n-            self.id == self.cx.tcx.tables().qpath_def(qpath, expr.id).def_id(),\n+            self.id == self.cx.tables.qpath_def(qpath, expr.id).def_id(),\n         ], {\n             self.used = true;\n             return;\n@@ -160,7 +160,7 @@ fn check_assign<'a, 'tcx>(\n         let hir::StmtSemi(ref expr, _) = expr.node,\n         let hir::ExprAssign(ref var, ref value) = expr.node,\n         let hir::ExprPath(ref qpath) = var.node,\n-        decl == cx.tcx.tables().qpath_def(qpath, var.id).def_id(),\n+        decl == cx.tables.qpath_def(qpath, var.id).def_id(),\n     ], {\n         let mut v = UsedVisitor {\n             cx: cx,"}, {"sha": "9c8f1e789278b0ba462d66b42b96f5e31a0f72a2", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -4,6 +4,7 @@\n #![feature(collections)]\n #![feature(custom_attribute)]\n #![feature(i128_type)]\n+#![feature(i128)]\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(stmt_expr_attributes)]\n@@ -17,6 +18,7 @@\n extern crate syntax;\n #[macro_use]\n extern crate rustc;\n+extern crate rustc_data_structures;\n \n extern crate toml;\n "}, {"sha": "ed5c33846556bded80a623dcae749f0df369b8f2", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -246,7 +246,7 @@ impl<'v, 't> RefVisitor<'v, 't> {\n         let last_path_segment = &last_path_segment(qpath).parameters;\n         if let AngleBracketedParameters(ref params) = *last_path_segment {\n             if params.lifetimes.is_empty() {\n-                match self.cx.tcx.tables().qpath_def(qpath, ty.id) {\n+                match self.cx.tables.qpath_def(qpath, ty.id) {\n                     Def::TyAlias(def_id) |\n                     Def::Struct(def_id) => {\n                         let generics = self.cx.tcx.item_generics(def_id);"}, {"sha": "73926fed0f159b2f581e63d3159df2e36adc3dda", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -9,7 +9,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::middle::region::CodeExtent;\n use rustc::ty;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n-use rustc_const_eval::eval_const_expr_partial;\n+use rustc_const_eval::ConstContext;\n use std::collections::HashMap;\n use syntax::ast;\n use utils::sugg;\n@@ -529,8 +529,9 @@ fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n     // if this for loop is iterating over a two-sided range...\n     if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(arg) {\n         // ...and both sides are compile-time constant integers...\n-        if let Ok(start_idx) = eval_const_expr_partial(cx.tcx, start, ExprTypeChecked, None) {\n-            if let Ok(end_idx) = eval_const_expr_partial(cx.tcx, end, ExprTypeChecked, None) {\n+        let constcx = ConstContext::with_tables(cx.tcx, cx.tables);\n+        if let Ok(start_idx) = constcx.eval(start, ExprTypeChecked) {\n+            if let Ok(end_idx) = constcx.eval(end, ExprTypeChecked) {\n                 // ...and the start index is greater than the end index,\n                 // this loop will never run. This is often confusing for developers\n                 // who think that this will iterate from the larger value to the\n@@ -627,7 +628,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n \n /// Check for `for` loops over `Option`s and `Results`\n fn check_arg_type(cx: &LateContext, pat: &Pat, arg: &Expr) {\n-    let ty = cx.tcx.tables().expr_ty(arg);\n+    let ty = cx.tables.expr_ty(arg);\n     if match_type(cx, ty, &paths::OPTION) {\n         span_help_and_lint(cx,\n                            FOR_LOOP_OVER_OPTION,\n@@ -713,7 +714,7 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n     if let PatKind::Tuple(ref pat, _) = pat.node {\n         if pat.len() == 2 {\n             let arg_span = arg.span;\n-            let (new_pat_span, kind, ty, mutbl) = match cx.tcx.tables().expr_ty(arg).sty {\n+            let (new_pat_span, kind, ty, mutbl) = match cx.tables.expr_ty(arg).sty {\n                 ty::TyRef(_, ref tam) => {\n                     match (&pat[0].node, &pat[1].node) {\n                         (key, _) if pat_is_wild(cx, key, body) => (pat[1].span, \"value\", tam.ty, tam.mutbl),\n@@ -800,7 +801,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if let ExprPath(ref qpath) = expr.node {\n             if let QPath::Resolved(None, ref path) = *qpath {\n-                if path.segments.len() == 1 && self.cx.tcx.tables().qpath_def(qpath, expr.id).def_id() == self.var {\n+                if path.segments.len() == 1 && self.cx.tables.qpath_def(qpath, expr.id).def_id() == self.var {\n                     // we are referencing our variable! now check if it's as an index\n                     if_let_chain! {[\n                         let Some(parexpr) = get_parent_expr(self.cx, expr),\n@@ -809,7 +810,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                         let QPath::Resolved(None, ref seqvar) = *seqpath,\n                         seqvar.segments.len() == 1\n                     ], {\n-                        let def = self.cx.tcx.tables().qpath_def(seqpath, seqexpr.id);\n+                        let def = self.cx.tables.qpath_def(seqpath, seqexpr.id);\n                         match def {\n                             Def::Local(..) | Def::Upvar(..) => {\n                                 let def_id = def.def_id();\n@@ -888,7 +889,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n     // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n     // will allow further borrows afterwards\n-    let ty = cx.tcx.tables().expr_ty(e);\n+    let ty = cx.tables.expr_ty(e);\n     is_iterable_array(ty) ||\n     match_type(cx, ty, &paths::VEC) ||\n     match_type(cx, ty, &paths::LINKED_LIST) ||\n@@ -1113,7 +1114,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n \n fn var_def_id(cx: &LateContext, expr: &Expr) -> Option<NodeId> {\n     if let ExprPath(ref qpath) = expr.node {\n-        let path_res = cx.tcx.tables().qpath_def(qpath, expr.id);\n+        let path_res = cx.tables.qpath_def(qpath, expr.id);\n         if let Def::Local(def_id) = path_res {\n             let node_id = cx.tcx.map.as_local_node_id(def_id).expect(\"That DefId should be valid\");\n             return Some(node_id);"}, {"sha": "76ffd89c64ec30217f8d1108664bce126be8f814", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -44,7 +44,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                             // look for derefs, for .map(|x| *x)\n                             if only_derefs(cx, &*closure_expr, arg_ident) &&\n                                 // .cloned() only removes one level of indirection, don't lint on more\n-                                walk_ptrs_ty_depth(cx.tcx.tables().pat_ty(&first_arg.pat)).1 == 1\n+                                walk_ptrs_ty_depth(cx.tables.pat_ty(&first_arg.pat)).1 == 1\n                             {\n                                 span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n                                     \"you seem to be using .map() to clone the contents of an {}, consider \\\n@@ -101,7 +101,7 @@ fn expr_eq_name(expr: &Expr, id: ast::Name) -> bool {\n fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static str> {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         Some(\"iterator\")\n-    } else if match_type(cx, walk_ptrs_ty(cx.tcx.tables().expr_ty(arg)), &paths::OPTION) {\n+    } else if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(arg)), &paths::OPTION) {\n         Some(\"Option\")\n     } else {\n         None"}, {"sha": "cd8592b647dda07f7afe9a4cac15a1bad66be21f", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -3,7 +3,7 @@ use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n-use rustc_const_eval::eval_const_expr_partial;\n+use rustc_const_eval::ConstContext;\n use rustc_const_math::ConstInt;\n use std::cmp::Ordering;\n use syntax::ast::LitKind;\n@@ -163,7 +163,7 @@ fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n             // allow match arms with just expressions\n             return;\n         };\n-        let ty = cx.tcx.tables().expr_ty(ex);\n+        let ty = cx.tables.expr_ty(ex);\n         if ty.sty != ty::TyBool || cx.current_level(MATCH_BOOL) == Allow {\n             check_single_match_single_pattern(cx, ex, arms, expr, els);\n             check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n@@ -254,7 +254,7 @@ fn check_single_match_opt_like(\n \n fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     // type of expression == bool\n-    if cx.tcx.tables().expr_ty(ex).sty == ty::TyBool {\n+    if cx.tables.expr_ty(ex).sty == ty::TyBool {\n         span_lint_and_then(cx,\n                            MATCH_BOOL,\n                            expr.span,\n@@ -305,7 +305,7 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n }\n \n fn check_overlapping_arms(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n-    if arms.len() >= 2 && cx.tcx.tables().expr_ty(ex).is_integral() {\n+    if arms.len() >= 2 && cx.tables.expr_ty(ex).is_integral() {\n         let ranges = all_ranges(cx, arms);\n         let type_ranges = type_ranges(&ranges);\n         if !type_ranges.is_empty() {\n@@ -351,6 +351,7 @@ fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: Match\n \n /// Get all arms that are unbounded `PatRange`s.\n fn all_ranges(cx: &LateContext, arms: &[Arm]) -> Vec<SpannedRange<ConstVal>> {\n+    let constcx = ConstContext::with_tables(cx.tcx, cx.tables);\n     arms.iter()\n         .flat_map(|arm| {\n             if let Arm { ref pats, guard: None, .. } = *arm {\n@@ -361,15 +362,15 @@ fn all_ranges(cx: &LateContext, arms: &[Arm]) -> Vec<SpannedRange<ConstVal>> {\n                 .filter_map(|pat| {\n                     if_let_chain! {[\n                     let PatKind::Range(ref lhs, ref rhs) = pat.node,\n-                    let Ok(lhs) = eval_const_expr_partial(cx.tcx, lhs, ExprTypeChecked, None),\n-                    let Ok(rhs) = eval_const_expr_partial(cx.tcx, rhs, ExprTypeChecked, None)\n+                    let Ok(lhs) = constcx.eval(lhs, ExprTypeChecked),\n+                    let Ok(rhs) = constcx.eval(rhs, ExprTypeChecked)\n                 ], {\n                     return Some(SpannedRange { span: pat.span, node: (lhs, rhs) });\n                 }}\n \n                     if_let_chain! {[\n                     let PatKind::Lit(ref value) = pat.node,\n-                    let Ok(value) = eval_const_expr_partial(cx.tcx, value, ExprTypeChecked, None)\n+                    let Ok(value) = constcx.eval(value, ExprTypeChecked)\n                 ], {\n                     return Some(SpannedRange { span: pat.span, node: (value.clone(), value) });\n                 }}"}, {"sha": "fbb5f32b3b9386ba271d333097c122b620b31e2e", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -31,9 +31,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprCall(ref path_expr, ref args) = e.node {\n             if let ExprPath(ref qpath) = path_expr.node {\n-                let def_id = cx.tcx.tables().qpath_def(qpath, path_expr.id).def_id();\n-                if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n-                    let forgot_ty = cx.tcx.tables().expr_ty(&args[0]);\n+                let def_id = cx.tables.qpath_def(qpath, path_expr.id).def_id();\n+                if match_def_path(cx.tcx, def_id, &paths::MEM_FORGET) {\n+                    let forgot_ty = cx.tables.expr_ty(&args[0]);\n \n                     if match forgot_ty.ty_adt_def() {\n                         Some(def) => def.has_dtor(),"}, {"sha": "21f3f034da1a891bba462b1123d4861894c830b7", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -4,7 +4,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::ty;\n use rustc::hir::def::Def;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n-use rustc_const_eval::eval_const_expr_partial;\n+use rustc_const_eval::ConstContext;\n use std::borrow::Cow;\n use std::fmt;\n use syntax::codemap::Span;\n@@ -603,7 +603,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n                 lint_or_fun_call(cx, expr, &name.node.as_str(), args);\n \n-                let self_ty = cx.tcx.tables().expr_ty_adjusted(&args[0]);\n+                let self_ty = cx.tables.expr_ty_adjusted(&args[0]);\n                 if args.len() == 1 && &*name.node.as_str() == \"clone\" {\n                     lint_clone_on_copy(cx, expr, &args[0], self_ty);\n                 }\n@@ -712,7 +712,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n                 let path: &str = &*last_path_segment(qpath).name.as_str();\n \n                 if [\"default\", \"new\"].contains(&path) {\n-                    let arg_ty = cx.tcx.tables().expr_ty(arg);\n+                    let arg_ty = cx.tables.expr_ty(arg);\n                     let default_trait_id = if let Some(default_trait_id) =\n                         get_trait_def_id(cx, &paths::DEFAULT_TRAIT) {\n                         default_trait_id\n@@ -768,7 +768,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n               (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n               (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\")];\n \n-        let self_ty = cx.tcx.tables().expr_ty(self_expr);\n+        let self_ty = cx.tables.expr_ty(self_expr);\n \n         let (fn_has_arguments, poss, suffix) = if let Some(&(_, fn_has_arguments, poss, suffix)) =\n             know_types.iter().find(|&&i| match_type(cx, self_ty, i.0)) {\n@@ -810,7 +810,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n \n /// Checks for the `CLONE_ON_COPY` lint.\n fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_ty: ty::Ty) {\n-    let ty = cx.tcx.tables().expr_ty(expr);\n+    let ty = cx.tables.expr_ty(expr);\n     let parent = cx.tcx.map.get_parent(expr.id);\n     let parameter_environment = ty::ParameterEnvironment::for_item(cx.tcx, parent);\n     if let ty::TyRef(_, ty::TypeAndMut { ty: inner, .. }) = arg_ty.sty {\n@@ -835,7 +835,7 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n                            expr.span,\n                            \"using `clone` on a `Copy` type\",\n                            |db| if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n-                               if let ty::TyRef(..) = cx.tcx.tables().expr_ty(arg).sty {\n+                               if let ty::TyRef(..) = cx.tables.expr_ty(arg).sty {\n                                    db.span_suggestion(expr.span, \"try dereferencing it\", format!(\"{}\", snip.deref()));\n                                } else {\n                                    db.span_suggestion(expr.span, \"try removing the `clone` call\", format!(\"{}\", snip));\n@@ -845,7 +845,7 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n }\n \n fn lint_vec_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n-    let arg_ty = cx.tcx.tables().expr_ty(&args[1]);\n+    let arg_ty = cx.tables.expr_ty(&args[1]);\n     if let Some(slice) = derefs_to_slice(cx, &args[1], arg_ty) {\n         span_lint_and_then(cx,\n                            EXTEND_FROM_SLICE,\n@@ -863,7 +863,7 @@ fn lint_string_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n     let arg = &args[1];\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n         let target = &arglists[0][0];\n-        let (self_ty, _) = walk_ptrs_ty_depth(cx.tcx.tables().expr_ty(target));\n+        let (self_ty, _) = walk_ptrs_ty_depth(cx.tables.expr_ty(target));\n         let ref_str = if self_ty.sty == ty::TyStr {\n             \"\"\n         } else if match_type(cx, self_ty, &paths::STRING) {\n@@ -884,7 +884,7 @@ fn lint_string_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n }\n \n fn lint_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n-    let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.tables().expr_ty(&args[0]));\n+    let (obj_ty, _) = walk_ptrs_ty_depth(cx.tables.expr_ty(&args[0]));\n     if match_type(cx, obj_ty, &paths::VEC) {\n         lint_vec_extend(cx, expr, args);\n     } else if match_type(cx, obj_ty, &paths::STRING) {\n@@ -897,8 +897,8 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n         let hir::ExprCall(ref fun, ref args) = new.node,\n         args.len() == 1,\n         let hir::ExprPath(ref path) = fun.node,\n-        let Def::Method(did) = cx.tcx.tables().qpath_def(path, fun.id),\n-        match_def_path(cx, did, &paths::CSTRING_NEW)\n+        let Def::Method(did) = cx.tables.qpath_def(path, fun.id),\n+        match_def_path(cx.tcx, did, &paths::CSTRING_NEW)\n     ], {\n         span_lint_and_then(cx, TEMPORARY_CSTRING_AS_PTR, expr.span,\n                            \"you are getting the inner pointer of a temporary `CString`\",\n@@ -911,11 +911,11 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n \n fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr], is_mut: bool) {\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n-    let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tcx.tables().expr_ty(&iter_args[0])).is_some() {\n+    let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some() {\n         \"slice\"\n-    } else if match_type(cx, cx.tcx.tables().expr_ty(&iter_args[0]), &paths::VEC) {\n+    } else if match_type(cx, cx.tables.expr_ty(&iter_args[0]), &paths::VEC) {\n         \"Vec\"\n-    } else if match_type(cx, cx.tcx.tables().expr_ty(&iter_args[0]), &paths::VEC_DEQUE) {\n+    } else if match_type(cx, cx.tables.expr_ty(&iter_args[0]), &paths::VEC_DEQUE) {\n         \"VecDeque\"\n     } else {\n         return; // caller is not a type that we want to lint\n@@ -932,7 +932,7 @@ fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr], is\n fn lint_get_unwrap(cx: &LateContext, expr: &hir::Expr, get_args: &[hir::Expr], is_mut: bool) {\n     // Note: we don't want to lint `get_mut().unwrap` for HashMap or BTreeMap,\n     // because they do not implement `IndexMut`\n-    let expr_ty = cx.tcx.tables().expr_ty(&get_args[0]);\n+    let expr_ty = cx.tables.expr_ty(&get_args[0]);\n     let caller_type = if derefs_to_slice(cx, &get_args[0], expr_ty).is_some() {\n         \"slice\"\n     } else if match_type(cx, expr_ty, &paths::VEC) {\n@@ -988,7 +988,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sug\n     }\n \n     if let hir::ExprMethodCall(name, _, ref args) = expr.node {\n-        if &*name.node.as_str() == \"iter\" && may_slice(cx, cx.tcx.tables().expr_ty(&args[0])) {\n+        if &*name.node.as_str() == \"iter\" && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n             sugg::Sugg::hir_opt(cx, &args[0]).map(|sugg| sugg.addr())\n         } else {\n             None\n@@ -1011,7 +1011,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sug\n \n /// lint use of `unwrap()` for `Option`s and `Result`s\n fn lint_unwrap(cx: &LateContext, expr: &hir::Expr, unwrap_args: &[hir::Expr]) {\n-    let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.tables().expr_ty(&unwrap_args[0]));\n+    let (obj_ty, _) = walk_ptrs_ty_depth(cx.tables.expr_ty(&unwrap_args[0]));\n \n     let mess = if match_type(cx, obj_ty, &paths::OPTION) {\n         Some((OPTION_UNWRAP_USED, \"an Option\", \"None\"))\n@@ -1036,8 +1036,8 @@ fn lint_unwrap(cx: &LateContext, expr: &hir::Expr, unwrap_args: &[hir::Expr]) {\n /// lint use of `ok().expect()` for `Result`s\n fn lint_ok_expect(cx: &LateContext, expr: &hir::Expr, ok_args: &[hir::Expr]) {\n     // lint if the caller of `ok()` is a `Result`\n-    if match_type(cx, cx.tcx.tables().expr_ty(&ok_args[0]), &paths::RESULT) {\n-        let result_type = cx.tcx.tables().expr_ty(&ok_args[0]);\n+    if match_type(cx, cx.tables.expr_ty(&ok_args[0]), &paths::RESULT) {\n+        let result_type = cx.tables.expr_ty(&ok_args[0]);\n         if let Some(error_type) = get_error_type(cx, result_type) {\n             if has_debug_impl(error_type, cx) {\n                 span_lint(cx,\n@@ -1052,7 +1052,7 @@ fn lint_ok_expect(cx: &LateContext, expr: &hir::Expr, ok_args: &[hir::Expr]) {\n /// lint use of `map().unwrap_or()` for `Option`s\n fn lint_map_unwrap_or(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::Expr], unwrap_args: &[hir::Expr]) {\n     // lint if the caller of `map()` is an `Option`\n-    if match_type(cx, cx.tcx.tables().expr_ty(&map_args[0]), &paths::OPTION) {\n+    if match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION) {\n         // lint message\n         let msg = \"called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling \\\n                    `map_or(a, f)` instead\";\n@@ -1081,7 +1081,7 @@ fn lint_map_unwrap_or(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::Expr]\n /// lint use of `map().unwrap_or_else()` for `Option`s\n fn lint_map_unwrap_or_else(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::Expr], unwrap_args: &[hir::Expr]) {\n     // lint if the caller of `map()` is an `Option`\n-    if match_type(cx, cx.tcx.tables().expr_ty(&map_args[0]), &paths::OPTION) {\n+    if match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION) {\n         // lint message\n         let msg = \"called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling \\\n                    `map_or_else(g, f)` instead\";\n@@ -1208,7 +1208,7 @@ fn lint_chars_next(cx: &LateContext, expr: &hir::Expr, chain: &hir::Expr, other:\n         let Some(segment) = single_segment_path(qpath),\n         &*segment.name.as_str() == \"Some\"\n     ], {\n-        let self_ty = walk_ptrs_ty(cx.tcx.tables().expr_ty_adjusted(&args[0][0]));\n+        let self_ty = walk_ptrs_ty(cx.tables.expr_ty_adjusted(&args[0][0]));\n \n         if self_ty.sty != ty::TyStr {\n             return false;\n@@ -1236,7 +1236,7 @@ fn lint_chars_next(cx: &LateContext, expr: &hir::Expr, chain: &hir::Expr, other:\n \n /// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n fn lint_single_char_pattern(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr) {\n-    if let Ok(ConstVal::Str(r)) = eval_const_expr_partial(cx.tcx, arg, ExprTypeChecked, None) {\n+    if let Ok(ConstVal::Str(r)) = ConstContext::with_tables(cx.tcx, cx.tables).eval(arg, ExprTypeChecked) {\n         if r.len() == 1 {\n             let hint = snippet(cx, expr.span, \"..\").replace(&format!(\"\\\"{}\\\"\", r), &format!(\"'{}'\", r));\n             span_lint_and_then(cx,"}, {"sha": "7cf260c7d5bcb2d4dc5351e6b1c66ab24087b468", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -62,11 +62,11 @@ enum MinMax {\n fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'a Expr)> {\n     if let ExprCall(ref path, ref args) = expr.node {\n         if let ExprPath(ref qpath) = path.node {\n-            let def_id = cx.tcx.tables().qpath_def(qpath, path.id).def_id();\n+            let def_id = cx.tables.qpath_def(qpath, path.id).def_id();\n \n-            if match_def_path(cx, def_id, &paths::CMP_MIN) {\n+            if match_def_path(cx.tcx, def_id, &paths::CMP_MIN) {\n                 fetch_const(args, MinMax::Min)\n-            } else if match_def_path(cx, def_id, &paths::CMP_MAX) {\n+            } else if match_def_path(cx.tcx, def_id, &paths::CMP_MAX) {\n                 fetch_const(args, MinMax::Max)\n             } else {\n                 None"}, {"sha": "88b3760378ca3790071b841d2e35ade281ed5e5d", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -5,7 +5,7 @@ use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n-use rustc_const_eval::eval_const_expr_partial;\n+use rustc_const_eval::ConstContext;\n use rustc_const_math::ConstFloat;\n use syntax::codemap::{Span, Spanned, ExpnFormat};\n use utils::{get_item_name, get_parent_expr, implements_trait, in_macro, is_integer_literal, match_path, snippet,\n@@ -312,7 +312,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     &*binding != \"_result\" && // FIXME: #944\n                     is_used(cx, expr) &&\n                     // don't lint if the declaration is in a macro\n-                    non_macro_local(cx, &cx.tcx.tables().qpath_def(qpath, expr.id)) {\n+                    non_macro_local(cx, &cx.tables.qpath_def(qpath, expr.id)) {\n                     Some(binding)\n                 } else {\n                     None\n@@ -362,7 +362,7 @@ fn check_nan(cx: &LateContext, path: &Path, span: Span) {\n }\n \n fn is_allowed(cx: &LateContext, expr: &Expr) -> bool {\n-    let res = eval_const_expr_partial(cx.tcx, expr, ExprTypeChecked, None);\n+    let res = ConstContext::with_tables(cx.tcx, cx.tables).eval(expr, ExprTypeChecked);\n     if let Ok(ConstVal::Float(val)) = res {\n         use std::cmp::Ordering;\n \n@@ -389,23 +389,23 @@ fn is_allowed(cx: &LateContext, expr: &Expr) -> bool {\n }\n \n fn is_float(cx: &LateContext, expr: &Expr) -> bool {\n-    matches!(walk_ptrs_ty(cx.tcx.tables().expr_ty(expr)).sty, ty::TyFloat(_))\n+    matches!(walk_ptrs_ty(cx.tables.expr_ty(expr)).sty, ty::TyFloat(_))\n }\n \n fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: Span) {\n     let (arg_ty, snip) = match expr.node {\n         ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) if args.len() == 1 => {\n             let name = &*name.as_str();\n             if name == \"to_string\" || name == \"to_owned\" && is_str_arg(cx, args) {\n-                (cx.tcx.tables().expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n+                (cx.tables.expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {\n                 return;\n             }\n         },\n         ExprCall(ref path, ref v) if v.len() == 1 => {\n             if let ExprPath(ref path) = path.node {\n                 if match_path(path, &[\"String\", \"from_str\"]) || match_path(path, &[\"String\", \"from\"]) {\n-                    (cx.tcx.tables().expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n+                    (cx.tables.expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n                 } else {\n                     return;\n                 }\n@@ -416,7 +416,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: S\n         _ => return,\n     };\n \n-    let other_ty = cx.tcx.tables().expr_ty(other);\n+    let other_ty = cx.tables.expr_ty(other);\n     let partial_eq_trait_id = match cx.tcx.lang_items.eq_trait() {\n         Some(id) => id,\n         None => return,\n@@ -449,7 +449,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: S\n }\n \n fn is_str_arg(cx: &LateContext, args: &[Expr]) -> bool {\n-    args.len() == 1 && matches!(walk_ptrs_ty(cx.tcx.tables().expr_ty(&args[0])).sty, ty::TyStr)\n+    args.len() == 1 && matches!(walk_ptrs_ty(cx.tables.expr_ty(&args[0])).sty, ty::TyStr)\n }\n \n /// Heuristic to see if an expression is used. Should be compatible with `unused_variables`'s idea"}, {"sha": "4c217e19725066cd27ae9d60ba0889767a8920cb", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -68,7 +68,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n                           MUT_MUT,\n                           expr.span,\n                           \"generally you want to avoid `&mut &mut _` if possible\");\n-            } else if let TyRef(_, TypeAndMut { mutbl: hir::MutMutable, .. }) = self.cx.tcx.tables().expr_ty(e).sty {\n+            } else if let TyRef(_, TypeAndMut { mutbl: hir::MutMutable, .. }) = self.cx.tables.expr_ty(e).sty {\n                 span_lint(self.cx,\n                           MUT_MUT,\n                           expr.span,"}, {"sha": "cb1f33133f548b23197d38ef3fbae5c3ebf40a93", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -34,7 +34,7 @@ impl LintPass for UnnecessaryMutPassed {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        let borrowed_table = cx.tcx.tables.borrow();\n+        let borrowed_table = cx.tables;\n         match e.node {\n             ExprCall(ref fn_expr, ref arguments) => {\n                 let function_type = borrowed_table.node_types"}, {"sha": "daf1f6ec12c35f4d46e7c354d4437a7d154ee57b", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -56,7 +56,7 @@ pub struct MutexAtomic;\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutexAtomic {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        let ty = cx.tcx.tables().expr_ty(expr);\n+        let ty = cx.tables.expr_ty(expr);\n         if let ty::TyAdt(_, subst) = ty.sty {\n             if match_type(cx, ty, &paths::MUTEX) {\n                 let mutex_param = &subst.type_at(0).sty;"}, {"sha": "8071f2903a9f2ddf2a59a58b5a34655792b5e2fa", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -40,9 +40,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n             return;\n         }\n         if let ExprAddrOf(MutImmutable, ref inner) = e.node {\n-            if let ty::TyRef(..) = cx.tcx.tables().expr_ty(inner).sty {\n+            if let ty::TyRef(..) = cx.tables.expr_ty(inner).sty {\n                 if let Some(&ty::adjustment::Adjust::DerefRef { autoderefs, autoref, .. }) =\n-                    cx.tcx.tables.borrow().adjustments.get(&e.id).map(|a| &a.kind) {\n+                    cx.tables.adjustments.get(&e.id).map(|a| &a.kind) {\n                     if autoderefs > 1 && autoref.is_some() {\n                         span_lint(cx,\n                                   NEEDLESS_BORROW,\n@@ -60,7 +60,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n         }\n         if_let_chain! {[\n             let PatKind::Binding(BindingMode::BindByRef(MutImmutable), _, _, _) = pat.node,\n-            let ty::TyRef(_, ref tam) = cx.tcx.tables().pat_ty(pat).sty,\n+            let ty::TyRef(_, ref tam) = cx.tables.pat_ty(pat).sty,\n             tam.mutbl == MutImmutable,\n             let ty::TyRef(_, ref tam) = tam.ty.sty,\n             // only lint immutable refs, because borrowed `&mut T` cannot be moved out"}, {"sha": "532b0cee8ad3260cad5c0472fe09207539895a12", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -33,7 +33,7 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprStruct(_, ref fields, Some(ref base)) = expr.node {\n-            let ty = cx.tcx.tables().expr_ty(expr);\n+            let ty = cx.tables.expr_ty(expr);\n             if let TyAdt(def, _) = ty.sty {\n                 if fields.len() == def.struct_variant().fields.len() {\n                     span_lint(cx,"}, {"sha": "b41423b0a506d8258a3ef6ac3aff9d3763caf206", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -50,7 +50,7 @@ fn check_mul(cx: &LateContext, span: Span, lit: &Expr, exp: &Expr) {\n         let Constant::Int(ref ci) = consts::lit_to_constant(&l.node),\n         let Some(val) = ci.to_u64(),\n         val == 1,\n-        cx.tcx.tables().expr_ty(exp).is_integral()\n+        cx.tables.expr_ty(exp).is_integral()\n     ], {\n         span_lint(cx,\n                   NEG_MULTIPLY,"}, {"sha": "c0ca07b34661a25dc8edaed70a828871948493ec", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -69,7 +69,7 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n         },\n         Expr_::ExprCall(ref callee, ref args) => {\n             if let Expr_::ExprPath(ref qpath) = callee.node {\n-                let def = cx.tcx.tables().qpath_def(qpath, callee.id);\n+                let def = cx.tables.qpath_def(qpath, callee.id);\n                 match def {\n                     Def::Struct(..) |\n                     Def::Variant(..) |\n@@ -153,7 +153,7 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n         },\n         Expr_::ExprCall(ref callee, ref args) => {\n             if let Expr_::ExprPath(ref qpath) = callee.node {\n-                let def = cx.tcx.tables().qpath_def(qpath, callee.id);\n+                let def = cx.tables.qpath_def(qpath, callee.id);\n                 match def {\n                     Def::Struct(..) |\n                     Def::Variant(..) |"}, {"sha": "a831e9bd9b774f3bccf27db1795dced18e11af22", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -50,7 +50,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             method_chain_args(op, &[\"ok\"]).is_some() //test to see if using ok() methoduse std::marker::Sized;\n \n         ], {\n-            let is_result_type = match_type(cx, cx.tcx.tables().expr_ty(&result_types[0]), &paths::RESULT);\n+            let is_result_type = match_type(cx, cx.tables.expr_ty(&result_types[0]), &paths::RESULT);\n             let some_expr_string = snippet(cx, y[0].span, \"\");\n             if print::to_string(print::NO_ANN, |s| s.print_path(x, false)) == \"Some\" && is_result_type {\n                 span_help_and_lint(cx, IF_LET_SOME_RESULT, expr.span,"}, {"sha": "2a6a6789df117a29284c4ad2d27580ef026aad99", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -35,7 +35,7 @@ impl LintPass for NonSensical {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSensical {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprMethodCall(ref name, _, ref arguments) = e.node {\n-            let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.tables().expr_ty(&arguments[0]));\n+            let (obj_ty, _) = walk_ptrs_ty_depth(cx.tables.expr_ty(&arguments[0]));\n             if &*name.node.as_str() == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n                 get_open_options(cx, &arguments[0], &mut options);\n@@ -63,7 +63,7 @@ enum OpenOption {\n \n fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOption, Argument)>) {\n     if let ExprMethodCall(ref name, _, ref arguments) = argument.node {\n-        let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.tables().expr_ty(&arguments[0]));\n+        let (obj_ty, _) = walk_ptrs_ty_depth(cx.tables.expr_ty(&arguments[0]));\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n         if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 2 {"}, {"sha": "e4a4490864427e5e7c8d0b11cfd25d7df4b65545", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -39,8 +39,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n             let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node,\n             let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = second.node,\n             &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n-            cx.tcx.tables().expr_ty(ident1).is_integral(),\n-            cx.tcx.tables().expr_ty(ident2).is_integral()\n+            cx.tables.expr_ty(ident1).is_integral(),\n+            cx.tables.expr_ty(ident2).is_integral()\n         ], {\n             if let BinOp_::BiLt = op.node {\n                 if let BinOp_::BiAdd = op2.node {\n@@ -63,8 +63,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n             let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node,\n             let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = first.node,\n             &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n-            cx.tcx.tables().expr_ty(ident1).is_integral(),\n-            cx.tcx.tables().expr_ty(ident2).is_integral()\n+            cx.tables.expr_ty(ident1).is_integral(),\n+            cx.tables.expr_ty(ident2).is_integral()\n         ], {\n             if let BinOp_::BiGt = op.node {\n                 if let BinOp_::BiAdd = op2.node {"}, {"sha": "1e97d44ff7d265047cfa030a8067978e937b4582", "filename": "clippy_lints/src/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -40,7 +40,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             let ExprCall(ref fun, ref params) = ex.node,\n             params.len() == 2,\n             let ExprPath(ref qpath) = fun.node,\n-            match_def_path(cx, resolve_node(cx, qpath, fun.id).def_id(), &paths::BEGIN_PANIC),\n+            match_def_path(cx.tcx, resolve_node(cx, qpath, fun.id).def_id(), &paths::BEGIN_PANIC),\n             let ExprLit(ref lit) = params[0].node,\n             is_direct_expn_of(cx, params[0].span, \"panic\").is_some(),\n             let LitKind::Str(ref string, _) = lit.node,"}, {"sha": "ad7d720fc51bcf3bcba2c967e2eba000796da062", "filename": "clippy_lints/src/print.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprint.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -76,7 +76,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n             // Search for `std::io::_print(..)` which is unique in a\n             // `print!` expansion.\n-            if match_def_path(cx, fun_id, &paths::IO_PRINT) {\n+            if match_def_path(cx.tcx, fun_id, &paths::IO_PRINT) {\n                 if let Some(span) = is_expn_of(cx, expr.span, \"print\") {\n                     // `println!` uses `print!`.\n                     let (span, name) = match is_expn_of(cx, span, \"println\") {\n@@ -94,7 +94,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         args.len() == 1,\n                         let ExprCall(ref args_fun, ref args_args) = args[0].node,\n                         let ExprPath(ref qpath) = args_fun.node,\n-                        match_def_path(cx, resolve_node(cx, qpath, args_fun.id).def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n+                        match_def_path(cx.tcx,\n+                                       resolve_node(cx, qpath, args_fun.id).def_id(),\n+                                       &paths::FMT_ARGUMENTS_NEWV1),\n                         args_args.len() == 2,\n                         let ExprAddrOf(_, ref match_expr) = args_args[1].node,\n                         let ExprMatch(ref args, _, _) = match_expr.node,\n@@ -119,10 +121,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             }\n             // Search for something like\n             // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n-            else if args.len() == 2 && match_def_path(cx, fun_id, &paths::FMT_ARGUMENTV1_NEW) {\n+            else if args.len() == 2 && match_def_path(cx.tcx, fun_id, &paths::FMT_ARGUMENTV1_NEW) {\n                 if let ExprPath(ref qpath) = args[1].node {\n-                    let def_id = cx.tcx.tables().qpath_def(qpath, args[1].id).def_id();\n-                    if match_def_path(cx, def_id, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr) &&\n+                    let def_id = cx.tables.qpath_def(qpath, args[1].id).def_id();\n+                    if match_def_path(cx.tcx, def_id, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr) &&\n                        is_expn_of(cx, expr.span, \"panic\").is_none() {\n                         span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n                     }"}, {"sha": "731d1b28ea38007198242b2bc9971a59e7f122a9", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -90,7 +90,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StepByZero {\n fn has_step_by(cx: &LateContext, expr: &Expr) -> bool {\n     // No need for walk_ptrs_ty here because step_by moves self, so it\n     // can't be called on a borrowed range.\n-    let ty = cx.tcx.tables().expr_ty(expr);\n+    let ty = cx.tables.expr_ty(expr);\n \n     // Note: `RangeTo`, `RangeToInclusive` and `RangeFull` don't have step_by\n     match_type(cx, ty, &paths::RANGE) || match_type(cx, ty, &paths::RANGE_FROM) ||"}, {"sha": "991d601cf9ae641c0f75b072715725ed0d3f98d8", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -3,7 +3,7 @@ use rustc::hir::*;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n-use rustc_const_eval::eval_const_expr_partial;\n+use rustc_const_eval::ConstContext;\n use std::collections::HashSet;\n use std::error::Error;\n use syntax::ast::{LitKind, NodeId};\n@@ -91,7 +91,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if_let_chain!{[\n             self.last.is_none(),\n             let Some(ref expr) = block.expr,\n-            match_type(cx, cx.tcx.tables().expr_ty(expr), &paths::REGEX),\n+            match_type(cx, cx.tables.expr_ty(expr), &paths::REGEX),\n             let Some(span) = is_expn_of(cx, expr.span, \"regex\"),\n         ], {\n             if !self.spans.contains(&span) {\n@@ -118,16 +118,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             let ExprPath(ref qpath) = fun.node,\n             args.len() == 1,\n         ], {\n-            let def_id = cx.tcx.tables().qpath_def(qpath, fun.id).def_id();\n-            if match_def_path(cx, def_id, &paths::REGEX_NEW) ||\n-               match_def_path(cx, def_id, &paths::REGEX_BUILDER_NEW) {\n+            let def_id = cx.tables.qpath_def(qpath, fun.id).def_id();\n+            if match_def_path(cx.tcx, def_id, &paths::REGEX_NEW) ||\n+               match_def_path(cx.tcx, def_id, &paths::REGEX_BUILDER_NEW) {\n                 check_regex(cx, &args[0], true);\n-            } else if match_def_path(cx, def_id, &paths::REGEX_BYTES_NEW) ||\n-               match_def_path(cx, def_id, &paths::REGEX_BYTES_BUILDER_NEW) {\n+            } else if match_def_path(cx.tcx, def_id, &paths::REGEX_BYTES_NEW) ||\n+               match_def_path(cx.tcx, def_id, &paths::REGEX_BYTES_BUILDER_NEW) {\n                 check_regex(cx, &args[0], false);\n-            } else if match_def_path(cx, def_id, &paths::REGEX_SET_NEW) {\n+            } else if match_def_path(cx.tcx, def_id, &paths::REGEX_SET_NEW) {\n                 check_set(cx, &args[0], true);\n-            } else if match_def_path(cx, def_id, &paths::REGEX_BYTES_SET_NEW) {\n+            } else if match_def_path(cx.tcx, def_id, &paths::REGEX_BYTES_SET_NEW) {\n                 check_set(cx, &args[0], false);\n             }\n         }}\n@@ -151,7 +151,7 @@ fn str_span(base: Span, s: &str, c: usize) -> Span {\n }\n \n fn const_str(cx: &LateContext, e: &Expr) -> Option<InternedString> {\n-    match eval_const_expr_partial(cx.tcx, e, ExprTypeChecked, None) {\n+    match ConstContext::with_tables(cx.tcx, cx.tables).eval(e, ExprTypeChecked) {\n         Ok(ConstVal::Str(r)) => Some(r),\n         _ => None,\n     }"}, {"sha": "34ec29acd7e6c87ed35fda945c09bfd68de04930", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -143,7 +143,7 @@ fn check_decl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx Decl, bindings:\n }\n \n fn is_binding(cx: &LateContext, pat_id: NodeId) -> bool {\n-    let var_ty = cx.tcx.tables().node_id_to_type(pat_id);\n+    let var_ty = cx.tables.node_id_to_type(pat_id);\n     match var_ty.sty {\n         ty::TyAdt(..) => false,\n         _ => true,"}, {"sha": "960ae77e25fe2e50422f6fd068cadcc772416d66", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n }\n \n fn is_string(cx: &LateContext, e: &Expr) -> bool {\n-    match_type(cx, walk_ptrs_ty(cx.tcx.tables().expr_ty(e)), &paths::STRING)\n+    match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(e)), &paths::STRING)\n }\n \n fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {"}, {"sha": "e1f4f1646962b865871dee27d504f18efec2772c", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -89,7 +89,7 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n                 if let ExprIndex(ref lhs1, ref idx1) = lhs1.node {\n                     if let ExprIndex(ref lhs2, ref idx2) = lhs2.node {\n                         if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n-                            let ty = walk_ptrs_ty(cx.tcx.tables().expr_ty(lhs1));\n+                            let ty = walk_ptrs_ty(cx.tables.expr_ty(lhs1));\n \n                             if matches!(ty.sty, ty::TySlice(_)) ||\n                                 matches!(ty.sty, ty::TyArray(_, _)) ||"}, {"sha": "359d2f11ec7e954b3853aaf36013cb4a803bf21c", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -88,11 +88,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprCall(ref path_expr, ref args) = e.node {\n             if let ExprPath(ref qpath) = path_expr.node {\n-                let def_id = cx.tcx.tables().qpath_def(qpath, path_expr.id).def_id();\n+                let def_id = cx.tables.qpath_def(qpath, path_expr.id).def_id();\n \n-                if match_def_path(cx, def_id, &paths::TRANSMUTE) {\n-                    let from_ty = cx.tcx.tables().expr_ty(&args[0]);\n-                    let to_ty = cx.tcx.tables().expr_ty(e);\n+                if match_def_path(cx.tcx, def_id, &paths::TRANSMUTE) {\n+                    let from_ty = cx.tables.expr_ty(&args[0]);\n+                    let to_ty = cx.tables.expr_ty(e);\n \n                     match (&from_ty.sty, &to_ty.sty) {\n                         _ if from_ty == to_ty => {"}, {"sha": "41bccef0ace75f32ab03a5b139e826da67c0856b", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -111,17 +111,17 @@ fn check_ty(cx: &LateContext, ast_ty: &Ty) {\n     }\n     match ast_ty.node {\n         TyPath(ref qpath) => {\n-            let def = cx.tcx.tables().qpath_def(qpath, ast_ty.id);\n+            let def = cx.tables.qpath_def(qpath, ast_ty.id);\n             if let Some(def_id) = opt_def_id(def) {\n                 if Some(def_id) == cx.tcx.lang_items.owned_box() {\n                     let last = last_path_segment(qpath);\n                     if_let_chain! {[\n                         let PathParameters::AngleBracketedParameters(ref ag) = last.parameters,\n                         let Some(ref vec) = ag.types.get(0),\n                         let TyPath(ref qpath) = vec.node,\n-                        let def::Def::Struct(..) = cx.tcx.tables().qpath_def(qpath, vec.id),\n-                        let Some(did) = opt_def_id(cx.tcx.tables().qpath_def(qpath, vec.id)),\n-                        match_def_path(cx, did, &paths::VEC),\n+                        let def::Def::Struct(..) = cx.tables.qpath_def(qpath, vec.id),\n+                        let Some(did) = opt_def_id(cx.tables.qpath_def(qpath, vec.id)),\n+                        match_def_path(cx.tcx, did, &paths::VEC),\n                     ], {\n                         span_help_and_lint(cx,\n                                            BOX_VEC,\n@@ -130,7 +130,7 @@ fn check_ty(cx: &LateContext, ast_ty: &Ty) {\n                                            \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n                         return; // don't recurse into the type\n                     }}\n-                } else if match_def_path(cx, def_id, &paths::LINKED_LIST) {\n+                } else if match_def_path(cx.tcx, def_id, &paths::LINKED_LIST) {\n                     span_help_and_lint(cx,\n                                        LINKEDLIST,\n                                        ast_ty.span,\n@@ -195,7 +195,7 @@ declare_lint! {\n \n fn check_let_unit(cx: &LateContext, decl: &Decl) {\n     if let DeclLocal(ref local) = decl.node {\n-        let bindtype = &cx.tcx.tables().pat_ty(&local.pat).sty;\n+        let bindtype = &cx.tables.pat_ty(&local.pat).sty;\n         match *bindtype {\n             ty::TyTuple(slice) if slice.is_empty() => {\n                 if in_external_macro(cx, decl.span) || in_macro(cx, local.pat.span) {\n@@ -266,7 +266,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n         if let ExprBinary(ref cmp, ref left, _) = expr.node {\n             let op = cmp.node;\n             if op.is_comparison() {\n-                let sty = &cx.tcx.tables().expr_ty(left).sty;\n+                let sty = &cx.tables.expr_ty(left).sty;\n                 match *sty {\n                     ty::TyTuple(slice) if slice.is_empty() => {\n                         let result = match op {\n@@ -510,7 +510,7 @@ impl LintPass for CastPass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprCast(ref ex, _) = expr.node {\n-            let (cast_from, cast_to) = (cx.tcx.tables().expr_ty(ex), cx.tcx.tables().expr_ty(expr));\n+            let (cast_from, cast_to) = (cx.tables.expr_ty(ex), cx.tables.expr_ty(expr));\n             if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx, expr.span) {\n                 match (cast_from.is_integral(), cast_to.is_integral()) {\n                     (true, false) => {\n@@ -754,7 +754,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n         if let ExprCast(ref e, _) = expr.node {\n             if let ExprLit(ref l) = e.node {\n                 if let LitKind::Char(_) = l.node {\n-                    if ty::TyUint(UintTy::U8) == cx.tcx.tables().expr_ty(expr).sty && !in_macro(cx, expr.span) {\n+                    if ty::TyUint(UintTy::U8) == cx.tables.expr_ty(expr).sty && !in_macro(cx, expr.span) {\n                         let msg = \"casting character literal to u8. `char`s \\\n                                    are 4 bytes wide in rust, so casting to u8 \\\n                                    truncates them\";\n@@ -827,7 +827,7 @@ fn detect_absurd_comparison<'a>(\n \n     // absurd comparison only makes sense on primitive types\n     // primitive types don't implement comparison operators with each other\n-    if cx.tcx.tables().expr_ty(lhs) != cx.tcx.tables().expr_ty(rhs) {\n+    if cx.tables.expr_ty(lhs) != cx.tables.expr_ty(rhs) {\n         return None;\n     }\n \n@@ -869,14 +869,14 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n     use rustc_const_eval::*;\n     use types::ExtremeType::*;\n \n-    let ty = &cx.tcx.tables().expr_ty(expr).sty;\n+    let ty = &cx.tables.expr_ty(expr).sty;\n \n     match *ty {\n         ty::TyBool | ty::TyInt(_) | ty::TyUint(_) => (),\n         _ => return None,\n     };\n \n-    let cv = match eval_const_expr_partial(cx.tcx, expr, ExprTypeChecked, None) {\n+    let cv = match ConstContext::with_tables(cx.tcx, cx.tables).eval(expr, ExprTypeChecked) {\n         Ok(val) => val,\n         Err(_) => return None,\n     };\n@@ -1035,7 +1035,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n     use std::*;\n \n     if let ExprCast(ref cast_exp, _) = expr.node {\n-        match cx.tcx.tables().expr_ty(cast_exp).sty {\n+        match cx.tables.expr_ty(cast_exp).sty {\n             TyInt(int_ty) => {\n                 Some(match int_ty {\n                     IntTy::I8 => (FullInt::S(i8::min_value() as i128), FullInt::S(i8::max_value() as i128)),\n@@ -1066,10 +1066,10 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n     use rustc::middle::const_val::ConstVal::*;\n     use rustc_const_eval::EvalHint::ExprTypeChecked;\n-    use rustc_const_eval::eval_const_expr_partial;\n+    use rustc_const_eval::ConstContext;\n     use rustc_const_math::ConstInt;\n \n-    match eval_const_expr_partial(cx.tcx, expr, ExprTypeChecked, None) {\n+    match ConstContext::with_tables(cx.tcx, cx.tables).eval(expr, ExprTypeChecked) {\n         Ok(val) => {\n             if let Integral(const_int) = val {\n                 Some(match const_int.erase_type() {"}, {"sha": "1358e1f28f226859c0b432c8322d3608b51a0624", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -159,11 +159,11 @@ pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e\n         is_expn_of(cx, fun.span, \"vec\").is_some(),\n     ], {\n         let fun_def = resolve_node(cx, path, fun.id);\n-        return if match_def_path(cx, fun_def.def_id(), &paths::VEC_FROM_ELEM) && args.len() == 2 {\n+        return if match_def_path(cx.tcx, fun_def.def_id(), &paths::VEC_FROM_ELEM) && args.len() == 2 {\n             // `vec![elem; size]` case\n             Some(VecArgs::Repeat(&args[0], &args[1]))\n         }\n-        else if match_def_path(cx, fun_def.def_id(), &paths::SLICE_INTO_VEC) && args.len() == 1 {\n+        else if match_def_path(cx.tcx, fun_def.def_id(), &paths::SLICE_INTO_VEC) && args.len() == 1 {\n             // `vec![a, b, c]` case\n             if_let_chain!{[\n                 let hir::ExprBox(ref boxed) = args[0].node,"}, {"sha": "3b1d1a46fac6740ea978334cfb5841d365ff7f02", "filename": "clippy_lints/src/utils/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -527,7 +527,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_name(&path.name);\n             },\n         }\n-        // self.cx.tcx.tables().qpath_def(p, id).hash(&mut self.s);\n+        // self.cx.tables.qpath_def(p, id).hash(&mut self.s);\n     }\n \n     pub fn hash_path(&mut self, p: &Path) {"}, {"sha": "d17ed28cd177c655861cc54b750cefc6eb98dcac", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -138,7 +138,7 @@ fn has_attr(attrs: &[Attribute]) -> bool {\n fn print_decl(cx: &LateContext, decl: &hir::Decl) {\n     match decl.node {\n         hir::DeclLocal(ref local) => {\n-            println!(\"local variable of type {}\", cx.tcx.tables().node_id_to_type(local.id));\n+            println!(\"local variable of type {}\", cx.tables.node_id_to_type(local.id));\n             println!(\"pattern:\");\n             print_pat(cx, &local.pat, 0);\n             if let Some(ref e) = local.init {\n@@ -152,7 +152,7 @@ fn print_decl(cx: &LateContext, decl: &hir::Decl) {\n \n fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n     let ind = \"  \".repeat(indent);\n-    let ty = cx.tcx.tables().node_id_to_type(expr.id);\n+    let ty = cx.tables.node_id_to_type(expr.id);\n     println!(\"{}+\", ind);\n     match expr.node {\n         hir::ExprBox(ref e) => {"}, {"sha": "f27682d0403262d48652802d6c1fb3bda69d2f67", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -141,11 +141,11 @@ pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n ///\n /// # Examples\n /// ```rust,ignore\n-/// match_def_path(cx, id, &[\"core\", \"option\", \"Option\"])\n+/// match_def_path(cx.tcx, id, &[\"core\", \"option\", \"Option\"])\n /// ```\n ///\n /// See also the `paths` module.\n-pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n+pub fn match_def_path(tcx: ty::TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n     use syntax::symbol;\n \n     struct AbsolutePathBuffer {\n@@ -165,15 +165,15 @@ pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n \n     let mut apb = AbsolutePathBuffer { names: vec![] };\n \n-    cx.tcx.push_item_path(&mut apb, def_id);\n+    tcx.push_item_path(&mut apb, def_id);\n \n     apb.names.len() == path.len() && apb.names.iter().zip(path.iter()).all(|(a, &b)| &**a == b)\n }\n \n /// Check if type is struct, enum or union type with given def path.\n pub fn match_type(cx: &LateContext, ty: ty::Ty, path: &[&str]) -> bool {\n     match ty.sty {\n-        ty::TyAdt(adt, _) => match_def_path(cx, adt.did, path),\n+        ty::TyAdt(adt, _) => match_def_path(cx.tcx, adt.did, path),\n         _ => false,\n     }\n }\n@@ -182,14 +182,12 @@ pub fn match_type(cx: &LateContext, ty: ty::Ty, path: &[&str]) -> bool {\n pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = ty::MethodCall::expr(expr.id);\n \n-    let trt_id = cx.tcx\n-        .tables\n-        .borrow()\n+    let trt_id = cx.tables\n         .method_map\n         .get(&method_call)\n         .and_then(|callee| cx.tcx.impl_of_method(callee.def_id));\n     if let Some(trt_id) = trt_id {\n-        match_def_path(cx, trt_id, path)\n+        match_def_path(cx.tcx, trt_id, path)\n     } else {\n         false\n     }\n@@ -199,14 +197,12 @@ pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = ty::MethodCall::expr(expr.id);\n \n-    let trt_id = cx.tcx\n-        .tables\n-        .borrow()\n+    let trt_id = cx.tables\n         .method_map\n         .get(&method_call)\n         .and_then(|callee| cx.tcx.trait_of_item(callee.def_id));\n     if let Some(trt_id) = trt_id {\n-        match_def_path(cx, trt_id, path)\n+        match_def_path(cx.tcx, trt_id, path)\n     } else {\n         false\n     }\n@@ -327,7 +323,7 @@ pub fn implements_trait<'a, 'tcx>(\n     cx.tcx.populate_implementations_for_trait_if_necessary(trait_id);\n \n     let ty = cx.tcx.erase_regions(&ty);\n-    cx.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+    cx.tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n         let obligation = cx.tcx.predicate_for_trait_def(traits::ObligationCause::dummy(), trait_id, 0, ty, &ty_params);\n \n         traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation)\n@@ -336,7 +332,7 @@ pub fn implements_trait<'a, 'tcx>(\n \n /// Resolve the definition of a node from its `NodeId`.\n pub fn resolve_node(cx: &LateContext, qpath: &QPath, id: NodeId) -> def::Def {\n-    cx.tcx.tables().qpath_def(qpath, id)\n+    cx.tables.qpath_def(qpath, id)\n }\n \n /// Match an `Expr` against a chain of methods, and return the matched `Expr`s.\n@@ -622,7 +618,7 @@ pub fn is_integer_literal(expr: &Expr, value: u128) -> bool {\n }\n \n pub fn is_adjusted(cx: &LateContext, e: &Expr) -> bool {\n-    cx.tcx.tables.borrow().adjustments.get(&e.id).is_some()\n+    cx.tables.adjustments.get(&e.id).is_some()\n }\n \n pub struct LimitStack {\n@@ -787,7 +783,7 @@ pub fn same_tys<'a, 'tcx>(\n     parameter_item: NodeId\n ) -> bool {\n     let parameter_env = ty::ParameterEnvironment::for_item(cx.tcx, parameter_item);\n-    cx.tcx.infer_ctxt(None, Some(parameter_env), Reveal::All).enter(|infcx| {\n+    cx.tcx.infer_ctxt(parameter_env, Reveal::All).enter(|infcx| {\n         let new_a = a.subst(infcx.tcx, infcx.parameter_environment.free_substs);\n         let new_b = b.subst(infcx.tcx, infcx.parameter_environment.free_substs);\n         infcx.can_equate(&new_a, &new_b).is_ok()\n@@ -811,7 +807,7 @@ pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, env: Node\n /// Return whether a pattern is refutable.\n pub fn is_refutable(cx: &LateContext, pat: &Pat) -> bool {\n     fn is_enum_variant(cx: &LateContext, qpath: &QPath, did: NodeId) -> bool {\n-        matches!(cx.tcx.tables().qpath_def(qpath, did),\n+        matches!(cx.tables.qpath_def(qpath, did),\n                  def::Def::Variant(..) | def::Def::VariantCtor(..))\n     }\n "}, {"sha": "20f06790589deaca9a466408a06b2957e40d58c5", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -2,7 +2,7 @@ use rustc::hir::*;\n use rustc::lint::*;\n use rustc::ty;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n-use rustc_const_eval::eval_const_expr_partial;\n+use rustc_const_eval::ConstContext;\n use syntax::codemap::Span;\n use utils::{higher, is_copy, snippet, span_lint_and_then};\n \n@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_let_chain!{[\n-            let ty::TypeVariants::TyRef(_, ref ty) = cx.tcx.tables().expr_ty_adjusted(expr).sty,\n+            let ty::TypeVariants::TyRef(_, ref ty) = cx.tables.expr_ty_adjusted(expr).sty,\n             let ty::TypeVariants::TySlice(..) = ty.ty.sty,\n             let ExprAddrOf(_, ref addressee) = expr.node,\n             let Some(vec_args) = higher::vec_macro(cx, addressee),\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if_let_chain!{[\n             let Some((_, arg, _)) = higher::for_loop(expr),\n             let Some(vec_args) = higher::vec_macro(cx, arg),\n-            is_copy(cx, vec_type(cx.tcx.tables().expr_ty_adjusted(arg)), cx.tcx.map.get_parent(expr.id)),\n+            is_copy(cx, vec_type(cx.tables.expr_ty_adjusted(arg)), cx.tcx.map.get_parent(expr.id)),\n         ], {\n             // report the error around the `vec!` not inside `<std macros>:`\n             let span = cx.sess().codemap().source_callsite(arg.span);\n@@ -60,7 +60,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n fn check_vec_macro(cx: &LateContext, vec_args: &higher::VecArgs, span: Span) {\n     let snippet = match *vec_args {\n         higher::VecArgs::Repeat(elem, len) => {\n-            if eval_const_expr_partial(cx.tcx, len, ExprTypeChecked, None).is_ok() {\n+            if ConstContext::with_tables(cx.tcx, cx.tables).eval(len, ExprTypeChecked).is_ok() {\n                 format!(\"&[{}; {}]\", snippet(cx, elem.span, \"elem\"), snippet(cx, len.span, \"len\")).into()\n             } else {\n                 return;"}, {"sha": "30bbcc6cb278a5ab83e3bde153d0022bc0151e66", "filename": "tests/compile-fail/cyclomatic_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d944d7df9a604f24ca4523e08fb03dffd890956b/tests%2Fcompile-fail%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d944d7df9a604f24ca4523e08fb03dffd890956b/tests%2Fcompile-fail%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcyclomatic_complexity.rs?ref=d944d7df9a604f24ca4523e08fb03dffd890956b", "patch": "@@ -146,7 +146,7 @@ fn lots_of_short_circuits2() -> bool { //~ ERROR: the function has a cyclomatic\n \n #[cyclomatic_complexity = \"0\"]\n fn baa() { //~ ERROR: the function has a cyclomatic complexity of 2\n-    let x = || match 99 {\n+    let x = || match 99 { //~ ERROR: the function has a cyclomatic complexity of 2\n         0 => 0,\n         1 => 1,\n         2 => 2,"}]}