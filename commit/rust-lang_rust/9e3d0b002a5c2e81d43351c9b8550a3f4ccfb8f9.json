{"sha": "9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllM2QwYjAwMmE1YzJlODFkNDMzNTFjOWI4NTUwYTNmNGNjZmI4Zjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-04-21T21:58:52Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-25T00:18:48Z"}, "message": "librustc: Remove the fallback to `int` from typechecking.\n\nThis breaks a fair amount of code. The typical patterns are:\n\n* `for _ in range(0, 10)`: change to `for _ in range(0u, 10)`;\n\n* `println!(\"{}\", 3)`: change to `println!(\"{}\", 3i)`;\n\n* `[1, 2, 3].len()`: change to `[1i, 2, 3].len()`.\n\nRFC #30. Closes #6023.\n\n[breaking-change]", "tree": {"sha": "1e9a15e8a55cc3947025ab3ac044c2f7977159d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e9a15e8a55cc3947025ab3ac044c2f7977159d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "html_url": "https://github.com/rust-lang/rust/commit/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7f95c8f5a6294f161800dbb65a0423bb5248f34", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7f95c8f5a6294f161800dbb65a0423bb5248f34", "html_url": "https://github.com/rust-lang/rust/commit/f7f95c8f5a6294f161800dbb65a0423bb5248f34"}], "stats": {"total": 4279, "additions": 2229, "deletions": 2050}, "files": [{"sha": "3fe237b1748adac80b85522fd6bc85a31d95065c", "filename": "src/doc/guide-container.md", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fdoc%2Fguide-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fdoc%2Fguide-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-container.md?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -135,7 +135,7 @@ invalidation*. As long as an iterator is still in scope, the compiler will preve\n modification of the container through another handle.\n \n ~~~\n-let mut xs = [1, 2, 3];\n+let mut xs = [1i, 2, 3];\n {\n     let _it = xs.iter();\n \n@@ -155,16 +155,16 @@ example, the `fold` method will accumulate the items yielded by an `Iterator`\n into a single value:\n \n ~~~\n-let xs = [1, 9, 2, 3, 14, 12];\n+let xs = [1i, 9, 2, 3, 14, 12];\n let result = xs.iter().fold(0, |accumulator, item| accumulator - *item);\n assert_eq!(result, -41);\n ~~~\n \n Most adaptors return an adaptor object implementing the `Iterator` trait itself:\n \n ~~~\n-let xs = [1, 9, 2, 3, 14, 12];\n-let ys = [5, 2, 1, 8];\n+let xs = [1i, 9, 2, 3, 14, 12];\n+let ys = [5i, 2, 1, 8];\n let sum = xs.iter().chain(ys.iter()).fold(0, |a, b| a + *b);\n assert_eq!(sum, 57);\n ~~~\n@@ -180,8 +180,8 @@ iterator adaptor named `fuse()` is provided. This returns an iterator that will\n never call its underlying iterator again once `None` has been returned:\n \n ~~~\n-let xs = [1,2,3,4,5];\n-let mut calls = 0;\n+let xs = [1i,2,3,4,5];\n+let mut calls = 0i;\n \n {\n     let it = xs.iter().scan((), |_, x| {\n@@ -209,11 +209,11 @@ assert_eq!(calls, 3);\n The function `range` (or `range_inclusive`) allows to simply iterate through a given range:\n \n ~~~\n-for i in range(0, 5) {\n+for i in range(0i, 5) {\n   print!(\"{} \", i) // prints \"0 1 2 3 4\"\n }\n \n-for i in std::iter::range_inclusive(0, 5) { // needs explicit import\n+for i in std::iter::range_inclusive(0i, 5) { // needs explicit import\n   print!(\"{} \", i) // prints \"0 1 2 3 4 5\"\n }\n ~~~\n@@ -238,7 +238,7 @@ For loops are *often* used with a temporary iterator object, as above. They can\n also advance the state of an iterator in a mutable location:\n \n ~~~\n-let xs = [1, 2, 3, 4, 5];\n+let xs = [1i, 2, 3, 4, 5];\n let ys = [\"foo\", \"bar\", \"baz\", \"foobar\"];\n \n // create an iterator yielding tuples of elements from both vectors\n@@ -265,7 +265,7 @@ assert!(it.next().is_none());\n Iterators offer generic conversion to containers with the `collect` adaptor:\n \n ~~~\n-let xs = [0, 1, 1, 2, 3, 5, 8];\n+let xs = [0i, 1, 1, 2, 3, 5, 8];\n let ys = xs.iter().rev().skip(1).map(|&x| x * 2).collect::<Vec<int>>();\n assert_eq!(ys, vec![10, 6, 4, 2, 2, 0]);\n ~~~\n@@ -347,7 +347,7 @@ A `DoubleEndedIterator` can have its direction changed with the `rev` adaptor,\n returning another `DoubleEndedIterator` with `next` and `next_back` exchanged.\n \n ~~~\n-let xs = [1, 2, 3, 4, 5, 6];\n+let xs = [1i, 2, 3, 4, 5, 6];\n let mut it = xs.iter();\n println!(\"{}\", it.next()); // prints `Some(1)`\n println!(\"{}\", it.next()); // prints `Some(2)`\n@@ -363,8 +363,8 @@ The `chain`, `map`, `filter`, `filter_map` and `inspect` adaptors are\n `DoubleEndedIterator` implementations if the underlying iterators are.\n \n ~~~\n-let xs = [1, 2, 3, 4];\n-let ys = [5, 6, 7, 8];\n+let xs = [1i, 2, 3, 4];\n+let ys = [5i, 6, 7, 8];\n let mut it = xs.iter().chain(ys.iter()).map(|&x| x * 2);\n \n println!(\"{}\", it.next()); // prints `Some(2)`\n@@ -380,9 +380,9 @@ mutable references. It can be used to reverse a container in-place. Note that\n the trailing underscore is a workaround for issue #5898 and will be removed.\n \n ~~~\n-let mut ys = [1, 2, 3, 4, 5];\n+let mut ys = [1i, 2, 3, 4, 5];\n ys.mut_iter().reverse_();\n-assert!(ys == [5, 4, 3, 2, 1]);\n+assert!(ys == [5i, 4, 3, 2, 1]);\n ~~~\n \n ## Random-access iterators\n@@ -395,8 +395,8 @@ The `chain` adaptor is an implementation of `RandomAccessIterator` if the\n underlying iterators are.\n \n ~~~\n-let xs = [1, 2, 3, 4, 5];\n-let ys = [7, 9, 11];\n+let xs = [1i, 2, 3, 4, 5];\n+let ys = [7i, 9, 11];\n let mut it = xs.iter().chain(ys.iter());\n println!(\"{}\", it.idx(0)); // prints `Some(1)`\n println!(\"{}\", it.idx(5)); // prints `Some(7)`"}, {"sha": "1f44b77d56abb1d47203c79527e4d06dcae22e1c", "filename": "src/doc/guide-lifetimes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fdoc%2Fguide-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fdoc%2Fguide-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-lifetimes.md?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -577,7 +577,7 @@ This is equivalent to the previous definition.\n Named lifetime notation can also be used to control the flow of execution:\n \n ~~~\n-'h: for i in range(0,10) {\n+'h: for i in range(0u, 10) {\n     'g: loop {\n         if i % 2 == 0 { continue 'h; }\n         if i == 9 { break 'h; }"}, {"sha": "0865282209773d3423a5510d3c6ca81e60024615", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -315,7 +315,7 @@ duration a 'lifetime'. Let's try a more complex example:\n \n ~~~rust\n fn main() {\n-    let mut x = box 5;\n+    let mut x = box 5i;\n     if *x < 10 {\n         let y = &x;\n         println!(\"Oh no: {}\", y);\n@@ -332,7 +332,7 @@ mutated, and therefore, lets us pass. This wouldn't work:\n \n ~~~rust{.ignore}\n fn main() {\n-    let mut x = box 5;\n+    let mut x = box 5i;\n     if *x < 10 {\n         let y = &x;\n         *x -= 1;"}, {"sha": "1d6513972a6d26f59e2776a8ae1401fc472e283e", "filename": "src/doc/guide-testing.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fdoc%2Fguide-testing.md", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fdoc%2Fguide-testing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-testing.md?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -269,7 +269,7 @@ use test::Bencher;\n #[bench]\n fn bench_xor_1000_ints(b: &mut Bencher) {\n     b.iter(|| {\n-        range(0, 1000).fold(0, |old, new| old ^ new);\n+        range(0u, 1000).fold(0, |old, new| old ^ new);\n     });\n }\n ~~~\n@@ -293,7 +293,7 @@ example above by adjusting the `bh.iter` call to\n # struct X; impl X { fn iter<T>(&self, _: || -> T) {} } let b = X;\n b.iter(|| {\n     // note lack of `;` (could also use an explicit `return`).\n-    range(0, 1000).fold(0, |old, new| old ^ new)\n+    range(0u, 1000).fold(0, |old, new| old ^ new)\n });\n ~~~\n \n@@ -307,7 +307,7 @@ extern crate test;\n # fn main() {\n # struct X; impl X { fn iter<T>(&self, _: || -> T) {} } let b = X;\n b.iter(|| {\n-    test::black_box(range(0, 1000).fold(0, |old, new| old ^ new));\n+    test::black_box(range(0u, 1000).fold(0, |old, new| old ^ new));\n });\n # }\n ~~~"}, {"sha": "1e577a91131607d12d1bab1e2d0112a8a79ac5c2", "filename": "src/doc/intro.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -198,7 +198,7 @@ Typically, tasks do not share memory but instead communicate amongst each other\n \n ```\n fn main() {\n-    let numbers = vec![1,2,3];\n+    let numbers = vec![1i, 2i, 3i];\n \n     let (tx, rx)  = channel();\n     tx.send(numbers);\n@@ -237,7 +237,7 @@ try to modify the previous example to continue using the variable `numbers`:\n \n ```ignore\n fn main() {\n-    let numbers = vec![1,2,3];\n+    let numbers = vec![1i, 2i, 3i];\n \n     let (tx, rx)  = channel();\n     tx.send(numbers);\n@@ -267,9 +267,9 @@ Let's see an example that uses the `clone` method to create copies of the data:\n \n ```\n fn main() {\n-    let numbers = vec![1,2,3];\n+    let numbers = vec![1i, 2i, 3i];\n \n-    for num in range(0, 3) {\n+    for num in range(0u, 3) {\n         let (tx, rx)  = channel();\n         // Use `clone` to send a *copy* of the array\n         tx.send(numbers.clone());\n@@ -300,10 +300,10 @@ Here's some code:\n use std::sync::Arc;\n \n fn main() {\n-    let numbers = vec![1,2,3];\n+    let numbers = vec![1i, 2i, 3i];\n     let numbers = Arc::new(numbers);\n \n-    for num in range(0, 3) {\n+    for num in range(0u, 3) {\n         let (tx, rx)  = channel();\n         tx.send(numbers.clone());\n \n@@ -346,10 +346,10 @@ and modify it to mutate the shared state:\n use std::sync::{Arc, Mutex};\n \n fn main() {\n-    let numbers = vec![1,2,3];\n+    let numbers = vec![1i, 2i, 3i];\n     let numbers_lock = Arc::new(Mutex::new(numbers));\n \n-    for num in range(0, 3) {\n+    for num in range(0u, 3) {\n         let (tx, rx)  = channel();\n         tx.send(numbers_lock.clone());\n "}, {"sha": "a9814dccb3f86c033f183f7b00f84426697a1687", "filename": "src/doc/rust.md", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -955,11 +955,12 @@ use std::option::{Some, None};\n # fn foo<T>(_: T){}\n \n fn main() {\n-    // Equivalent to 'std::iter::range_step(0, 10, 2);'\n-    range_step(0, 10, 2);\n+    // Equivalent to 'std::iter::range_step(0u, 10u, 2u);'\n+    range_step(0u, 10u, 2u);\n \n-    // Equivalent to 'foo(vec![std::option::Some(1.0), std::option::None]);'\n-    foo(vec![Some(1.0), None]);\n+    // Equivalent to 'foo(vec![std::option::Some(1.0f64),\n+    // std::option::None]);'\n+    foo(vec![Some(1.0f64), None]);\n }\n ~~~~\n \n@@ -1475,7 +1476,7 @@ to pointers to the trait name, used as a type.\n ~~~~\n # trait Shape { }\n # impl Shape for int { }\n-# let mycircle = 0;\n+# let mycircle = 0i;\n let myshape: Box<Shape> = box mycircle as Box<Shape>;\n ~~~~\n \n@@ -3613,7 +3614,7 @@ and no-return value closure has type `proc()`.\n An example of creating and calling a closure:\n \n ```rust\n-let captured_var = 10;\n+let captured_var = 10i;\n \n let closure_no_args = || println!(\"captured_var={}\", captured_var);\n \n@@ -3685,7 +3686,7 @@ fn print(a: Box<Printable>) {\n }\n \n fn main() {\n-   print(box 10 as Box<Printable>);\n+   print(box 10i as Box<Printable>);\n }\n ~~~~\n "}, {"sha": "39d2da30fa425e8bbb76334a281c3022373c6a27", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -220,7 +220,7 @@ mut` instead.\n \n ~~~~\n let hi = \"hi\";\n-let mut count = 0;\n+let mut count = 0i;\n \n while count < 10 {\n     println!(\"count is {}\", count);\n@@ -407,7 +407,7 @@ error when the types of the directives don't match the types of the arguments.\n \n ~~~\n // `{}` will print the \"default format\" of a type\n-println!(\"{} is {}\", \"the answer\", 43);\n+println!(\"{} is {}\", \"the answer\", 43i);\n ~~~\n \n ~~~~\n@@ -535,7 +535,7 @@ A subpattern can also be bound to a variable, using `variable @ pattern`. For\n example:\n \n ~~~~\n-# let age = 23;\n+# let age = 23i;\n match age {\n     a @ 0..20 => println!(\"{} years old\", a),\n     _ => println!(\"older than 21\")\n@@ -594,7 +594,7 @@ it finds one that can be divided by five.\n There is also a for-loop that can be used to iterate over a range of numbers:\n \n ~~~~\n-for n in range(0, 5) {\n+for n in range(0u, 5) {\n     println!(\"{}\", n);\n }\n ~~~~\n@@ -1124,7 +1124,7 @@ as it is only called a single time.\n Avoiding a move can be done with the library-defined `clone` method:\n \n ~~~~\n-let x = box 5;\n+let x = box 5i;\n let y = x.clone(); // `y` is a newly allocated box\n let z = x; // no new memory allocated, `x` can no longer be used\n ~~~~\n@@ -1356,8 +1356,8 @@ impl<T: PartialEq> PartialEq for List<T> {\n     }\n }\n \n-let xs = Cons(5, box Cons(10, box Nil));\n-let ys = Cons(5, box Cons(10, box Nil));\n+let xs = Cons(5i, box Cons(10i, box Nil));\n+let ys = Cons(5i, box Cons(10i, box Nil));\n // The methods below are part of the PartialEq trait,\n // which we implemented on our linked list.\n assert!(xs.eq(&ys));\n@@ -1584,7 +1584,7 @@ elements are mutable if the vector is mutable. Fixed-size strings do not exist.\n \n ~~~\n // A fixed-size vector\n-let numbers = [1, 2, 3];\n+let numbers = [1i, 2, 3];\n let more_numbers = numbers;\n \n // The type of a fixed-size vector is written as `[Type, ..length]`\n@@ -1599,7 +1599,7 @@ the elements are mutable if the vector is mutable.\n use std::string::String;\n \n // A dynamically sized vector (unique vector)\n-let mut numbers = vec![1, 2, 3];\n+let mut numbers = vec![1i, 2, 3];\n numbers.push(4);\n numbers.push(5);\n \n@@ -1694,11 +1694,11 @@ contained value are destroyed.\n use std::rc::Rc;\n \n // A fixed-size array allocated in a reference-counted box\n-let x = Rc::new([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+let x = Rc::new([1i, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n let y = x.clone(); // a new owner\n let z = x; // this moves `x` into `z`, rather than creating a new owner\n \n-assert!(*z == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+assert!(*z == [1i, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n \n // the variable is mutable, but not the contents of the box\n let mut a = Rc::new([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]);\n@@ -1713,11 +1713,11 @@ not have a destructor.\n use std::gc::GC;\n \n // A fixed-size array allocated in a garbage-collected box\n-let x = box(GC) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+let x = box(GC) [1i, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n let y = x; // does not perform a move, unlike with `Rc`\n let z = x;\n \n-assert!(*z == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+assert!(*z == [1i, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n ~~~\n \n With shared ownership, mutability cannot be inherited so the boxes are always immutable. However,\n@@ -3130,7 +3130,7 @@ extern crate num;\n \n fn main() {\n     // The rational number '1/2':\n-    let one_half = ::num::rational::Ratio::new(1, 2);\n+    let one_half = ::num::rational::Ratio::new(1i, 2);\n }\n ~~~\n \n@@ -3165,7 +3165,7 @@ mod farm {\n \n fn main() {\n     farm::dog();\n-    let a_third = Ratio::new(1, 3);\n+    let a_third = Ratio::new(1i, 3);\n }\n ~~~\n \n@@ -3292,13 +3292,13 @@ use iter_range = std::iter::range;\n \n fn main() {\n     // `range` is imported by default\n-    for _ in range(0, 10) {}\n+    for _ in range(0u, 10) {}\n \n     // Doesn't hinder you from importing it under a different name yourself\n-    for _ in iter_range(0, 10) {}\n+    for _ in iter_range(0u, 10) {}\n \n     // Or from not using the automatic import.\n-    for _ in ::std::iter::range(0, 10) {}\n+    for _ in ::std::iter::range(0u, 10) {}\n }\n ~~~\n "}, {"sha": "cccd5cb63efa360460257ca0c694da52dab9fc92", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -39,7 +39,7 @@ use heap::deallocate;\n ///     let numbers = Vec::from_fn(100, |i| i as f32);\n ///     let shared_numbers = Arc::new(numbers);\n ///\n-///     for _ in range(0, 10) {\n+///     for _ in range(0u, 10) {\n ///         let child_numbers = shared_numbers.clone();\n ///\n ///         spawn(proc() {"}, {"sha": "c6e81fa7f7c9bd859a9c102112d8d7290d619d93", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -276,42 +276,42 @@ mod tests {\n \n     #[test]\n     fn test_clone() {\n-        let x = Rc::new(RefCell::new(5));\n+        let x = Rc::new(RefCell::new(5i));\n         let y = x.clone();\n         *x.borrow_mut() = 20;\n         assert_eq!(*y.borrow(), 20);\n     }\n \n     #[test]\n     fn test_simple() {\n-        let x = Rc::new(5);\n+        let x = Rc::new(5i);\n         assert_eq!(*x, 5);\n     }\n \n     #[test]\n     fn test_simple_clone() {\n-        let x = Rc::new(5);\n+        let x = Rc::new(5i);\n         let y = x.clone();\n         assert_eq!(*x, 5);\n         assert_eq!(*y, 5);\n     }\n \n     #[test]\n     fn test_destructor() {\n-        let x = Rc::new(box 5);\n+        let x = Rc::new(box 5i);\n         assert_eq!(**x, 5);\n     }\n \n     #[test]\n     fn test_live() {\n-        let x = Rc::new(5);\n+        let x = Rc::new(5i);\n         let y = x.downgrade();\n         assert!(y.upgrade().is_some());\n     }\n \n     #[test]\n     fn test_dead() {\n-        let x = Rc::new(5);\n+        let x = Rc::new(5i);\n         let y = x.downgrade();\n         drop(x);\n         assert!(y.upgrade().is_none());\n@@ -321,7 +321,7 @@ mod tests {\n     fn gc_inside() {\n         // see issue #11532\n         use std::gc::GC;\n-        let a = Rc::new(RefCell::new(box(GC) 1));\n+        let a = Rc::new(RefCell::new(box(GC) 1i));\n         assert!(a.try_borrow_mut().is_some());\n     }\n "}, {"sha": "aacf9936cce3681a544c9b35092220589d7236dd", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -513,7 +513,7 @@ mod tests {\n     #[test]\n     pub fn test_copy() {\n         let arena = TypedArena::new();\n-        for _ in range(0, 100000) {\n+        for _ in range(0u, 100000) {\n             arena.alloc(Point {\n                 x: 1,\n                 y: 2,\n@@ -567,7 +567,7 @@ mod tests {\n     #[test]\n     pub fn test_noncopy() {\n         let arena = TypedArena::new();\n-        for _ in range(0, 100000) {\n+        for _ in range(0u, 100000) {\n             arena.alloc(Noncopy {\n                 string: \"hello world\".to_string(),\n                 array: vec!( 1, 2, 3, 4, 5 ),"}, {"sha": "234393ce56183b8dfbf330e4bb370a04c4e96d3e", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -572,7 +572,7 @@ impl ops::Index<uint,bool> for Bitv {\n impl fmt::Show for Bitv {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         for bit in self.iter() {\n-            try!(write!(fmt, \"{}\", if bit { 1 } else { 0 }));\n+            try!(write!(fmt, \"{}\", if bit { 1u } else { 0u }));\n         }\n         Ok(())\n     }"}, {"sha": "64bee05a379a72321a34898880da39dc45bac83d", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -785,17 +785,17 @@ mod test_btree {\n     //Tests the functionality of the insert methods (which are unfinished).\n     #[test]\n     fn insert_test_one() {\n-        let b = BTree::new(1, \"abc\".to_string(), 2);\n-        let is_insert = b.insert(2, \"xyz\".to_string());\n+        let b = BTree::new(1i, \"abc\".to_string(), 2);\n+        let is_insert = b.insert(2i, \"xyz\".to_string());\n         //println!(\"{}\", is_insert.clone().to_str());\n         assert!(is_insert.root.is_leaf());\n     }\n \n     #[test]\n     fn insert_test_two() {\n-        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_string());\n-        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_string());\n-        let leaf_elt_3 = LeafElt::new(3, \"ccc\".to_string());\n+        let leaf_elt_1 = LeafElt::new(1i, \"aaa\".to_string());\n+        let leaf_elt_2 = LeafElt::new(2i, \"bbb\".to_string());\n+        let leaf_elt_3 = LeafElt::new(3i, \"ccc\".to_string());\n         let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3));\n         let b = BTree::new_with_node_len(n, 3, 2);\n         //println!(\"{}\", b.clone().insert(4, \"ddd\".to_string()).to_str());\n@@ -804,10 +804,10 @@ mod test_btree {\n \n     #[test]\n     fn insert_test_three() {\n-        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_string());\n-        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_string());\n-        let leaf_elt_3 = LeafElt::new(3, \"ccc\".to_string());\n-        let leaf_elt_4 = LeafElt::new(4, \"ddd\".to_string());\n+        let leaf_elt_1 = LeafElt::new(1i, \"aaa\".to_string());\n+        let leaf_elt_2 = LeafElt::new(2i, \"bbb\".to_string());\n+        let leaf_elt_3 = LeafElt::new(3i, \"ccc\".to_string());\n+        let leaf_elt_4 = LeafElt::new(4i, \"ddd\".to_string());\n         let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n         let b = BTree::new_with_node_len(n, 3, 2);\n         //println!(\"{}\", b.clone().insert(5, \"eee\".to_string()).to_str());\n@@ -816,10 +816,10 @@ mod test_btree {\n \n     #[test]\n     fn insert_test_four() {\n-        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_string());\n-        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_string());\n-        let leaf_elt_3 = LeafElt::new(3, \"ccc\".to_string());\n-        let leaf_elt_4 = LeafElt::new(4, \"ddd\".to_string());\n+        let leaf_elt_1 = LeafElt::new(1i, \"aaa\".to_string());\n+        let leaf_elt_2 = LeafElt::new(2i, \"bbb\".to_string());\n+        let leaf_elt_3 = LeafElt::new(3i, \"ccc\".to_string());\n+        let leaf_elt_4 = LeafElt::new(4i, \"ddd\".to_string());\n         let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n         let mut b = BTree::new_with_node_len(n, 3, 2);\n         b = b.clone().insert(5, \"eee\".to_string());\n@@ -833,33 +833,33 @@ mod test_btree {\n \n     #[test]\n     fn bsearch_test_one() {\n-        let b = BTree::new(1, \"abc\".to_string(), 2);\n+        let b = BTree::new(1i, \"abc\".to_string(), 2u);\n         assert_eq!(Some(1), b.root.bsearch_node(2));\n     }\n \n     #[test]\n     fn bsearch_test_two() {\n-        let b = BTree::new(1, \"abc\".to_string(), 2);\n+        let b = BTree::new(1i, \"abc\".to_string(), 2u);\n         assert_eq!(Some(0), b.root.bsearch_node(0));\n     }\n \n     #[test]\n     fn bsearch_test_three() {\n-        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_string());\n-        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_string());\n-        let leaf_elt_3 = LeafElt::new(4, \"ccc\".to_string());\n-        let leaf_elt_4 = LeafElt::new(5, \"ddd\".to_string());\n+        let leaf_elt_1 = LeafElt::new(1i, \"aaa\".to_string());\n+        let leaf_elt_2 = LeafElt::new(2i, \"bbb\".to_string());\n+        let leaf_elt_3 = LeafElt::new(4i, \"ccc\".to_string());\n+        let leaf_elt_4 = LeafElt::new(5i, \"ddd\".to_string());\n         let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n         let b = BTree::new_with_node_len(n, 3, 2);\n         assert_eq!(Some(2), b.root.bsearch_node(3));\n     }\n \n     #[test]\n     fn bsearch_test_four() {\n-        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_string());\n-        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_string());\n-        let leaf_elt_3 = LeafElt::new(4, \"ccc\".to_string());\n-        let leaf_elt_4 = LeafElt::new(5, \"ddd\".to_string());\n+        let leaf_elt_1 = LeafElt::new(1i, \"aaa\".to_string());\n+        let leaf_elt_2 = LeafElt::new(2i, \"bbb\".to_string());\n+        let leaf_elt_3 = LeafElt::new(4i, \"ccc\".to_string());\n+        let leaf_elt_4 = LeafElt::new(5i, \"ddd\".to_string());\n         let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n         let b = BTree::new_with_node_len(n, 3, 2);\n         assert_eq!(Some(4), b.root.bsearch_node(800));\n@@ -868,47 +868,47 @@ mod test_btree {\n     //Tests the functionality of the get method.\n     #[test]\n     fn get_test() {\n-        let b = BTree::new(1, \"abc\".to_string(), 2);\n+        let b = BTree::new(1i, \"abc\".to_string(), 2);\n         let val = b.get(1);\n         assert_eq!(val, Some(\"abc\".to_string()));\n     }\n \n     //Tests the BTree's clone() method.\n     #[test]\n     fn btree_clone_test() {\n-        let b = BTree::new(1, \"abc\".to_string(), 2);\n+        let b = BTree::new(1i, \"abc\".to_string(), 2);\n         let b2 = b.clone();\n         assert!(b.root == b2.root)\n     }\n \n     //Tests the BTree's cmp() method when one node is \"less than\" another.\n     #[test]\n     fn btree_cmp_test_less() {\n-        let b = BTree::new(1, \"abc\".to_string(), 2);\n-        let b2 = BTree::new(2, \"bcd\".to_string(), 2);\n+        let b = BTree::new(1i, \"abc\".to_string(), 2);\n+        let b2 = BTree::new(2i, \"bcd\".to_string(), 2);\n         assert!(&b.cmp(&b2) == &Less)\n     }\n \n     //Tests the BTree's cmp() method when two nodes are equal.\n     #[test]\n     fn btree_cmp_test_eq() {\n-        let b = BTree::new(1, \"abc\".to_string(), 2);\n-        let b2 = BTree::new(1, \"bcd\".to_string(), 2);\n+        let b = BTree::new(1i, \"abc\".to_string(), 2);\n+        let b2 = BTree::new(1i, \"bcd\".to_string(), 2);\n         assert!(&b.cmp(&b2) == &Equal)\n     }\n \n     //Tests the BTree's cmp() method when one node is \"greater than\" another.\n     #[test]\n     fn btree_cmp_test_greater() {\n-        let b = BTree::new(1, \"abc\".to_string(), 2);\n-        let b2 = BTree::new(2, \"bcd\".to_string(), 2);\n+        let b = BTree::new(1i, \"abc\".to_string(), 2);\n+        let b2 = BTree::new(2i, \"bcd\".to_string(), 2);\n         assert!(&b2.cmp(&b) == &Greater)\n     }\n \n     //Tests the BTree's to_str() method.\n     #[test]\n     fn btree_tostr_test() {\n-        let b = BTree::new(1, \"abc\".to_string(), 2);\n+        let b = BTree::new(1i, \"abc\".to_string(), 2);\n         assert_eq!(b.to_str(), \"Key: 1, value: abc;\".to_string())\n     }\n "}, {"sha": "0e6cbe4e038dcfc959c3698a057e8e03a928a14e", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -693,7 +693,7 @@ mod tests {\n         assert_eq!(m.pop_front(), Some(box 1));\n \n         let mut n = DList::new();\n-        n.push_front(2);\n+        n.push_front(2i);\n         n.push_front(3);\n         {\n             assert_eq!(n.front().unwrap(), &3);\n@@ -713,7 +713,7 @@ mod tests {\n \n     #[cfg(test)]\n     fn generate_test() -> DList<int> {\n-        list_from(&[0,1,2,3,4,5,6])\n+        list_from(&[0i,1,2,3,4,5,6])\n     }\n \n     #[cfg(test)]\n@@ -726,7 +726,7 @@ mod tests {\n         {\n             let mut m = DList::new();\n             let mut n = DList::new();\n-            n.push_back(2);\n+            n.push_back(2i);\n             m.append(n);\n             assert_eq!(m.len(), 1);\n             assert_eq!(m.pop_back(), Some(2));\n@@ -735,15 +735,15 @@ mod tests {\n         {\n             let mut m = DList::new();\n             let n = DList::new();\n-            m.push_back(2);\n+            m.push_back(2i);\n             m.append(n);\n             assert_eq!(m.len(), 1);\n             assert_eq!(m.pop_back(), Some(2));\n             check_links(&m);\n         }\n \n-        let v = vec![1,2,3,4,5];\n-        let u = vec![9,8,1,2,3,4,5];\n+        let v = vec![1i,2,3,4,5];\n+        let u = vec![9i,8,1,2,3,4,5];\n         let mut m = list_from(v.as_slice());\n         m.append(list_from(u.as_slice()));\n         check_links(&m);\n@@ -759,15 +759,15 @@ mod tests {\n         {\n             let mut m = DList::new();\n             let mut n = DList::new();\n-            n.push_back(2);\n+            n.push_back(2i);\n             m.prepend(n);\n             assert_eq!(m.len(), 1);\n             assert_eq!(m.pop_back(), Some(2));\n             check_links(&m);\n         }\n \n-        let v = vec![1,2,3,4,5];\n-        let u = vec![9,8,1,2,3,4,5];\n+        let v = vec![1i,2,3,4,5];\n+        let u = vec![9i,8,1,2,3,4,5];\n         let mut m = list_from(v.as_slice());\n         m.prepend(list_from(u.as_slice()));\n         check_links(&m);\n@@ -786,7 +786,7 @@ mod tests {\n         n.rotate_forward(); check_links(&n);\n         assert_eq!(n.len(), 0);\n \n-        let v = vec![1,2,3,4,5];\n+        let v = vec![1i,2,3,4,5];\n         let mut m = list_from(v.as_slice());\n         m.rotate_backward(); check_links(&m);\n         m.rotate_forward(); check_links(&m);\n@@ -798,7 +798,7 @@ mod tests {\n         m.rotate_backward(); check_links(&m);\n         m.push_front(9); check_links(&m);\n         m.rotate_forward(); check_links(&m);\n-        assert_eq!(vec![3,9,5,1,2], m.move_iter().collect());\n+        assert_eq!(vec![3i,9,5,1,2], m.move_iter().collect());\n     }\n \n     #[test]\n@@ -809,7 +809,7 @@ mod tests {\n         }\n         let mut n = DList::new();\n         assert_eq!(n.iter().next(), None);\n-        n.push_front(4);\n+        n.push_front(4i);\n         let mut it = n.iter();\n         assert_eq!(it.size_hint(), (1, Some(1)));\n         assert_eq!(it.next().unwrap(), &4);\n@@ -820,7 +820,7 @@ mod tests {\n     #[test]\n     fn test_iterator_clone() {\n         let mut n = DList::new();\n-        n.push_back(2);\n+        n.push_back(2i);\n         n.push_back(3);\n         n.push_back(4);\n         let mut it = n.iter();\n@@ -835,7 +835,7 @@ mod tests {\n     fn test_iterator_double_end() {\n         let mut n = DList::new();\n         assert_eq!(n.iter().next(), None);\n-        n.push_front(4);\n+        n.push_front(4i);\n         n.push_front(5);\n         n.push_front(6);\n         let mut it = n.iter();\n@@ -857,7 +857,7 @@ mod tests {\n         }\n         let mut n = DList::new();\n         assert_eq!(n.iter().rev().next(), None);\n-        n.push_front(4);\n+        n.push_front(4i);\n         let mut it = n.iter().rev();\n         assert_eq!(it.size_hint(), (1, Some(1)));\n         assert_eq!(it.next().unwrap(), &4);\n@@ -876,7 +876,7 @@ mod tests {\n         assert_eq!(len, 0);\n         let mut n = DList::new();\n         assert!(n.mut_iter().next().is_none());\n-        n.push_front(4);\n+        n.push_front(4i);\n         n.push_back(5);\n         let mut it = n.mut_iter();\n         assert_eq!(it.size_hint(), (2, Some(2)));\n@@ -890,7 +890,7 @@ mod tests {\n     fn test_iterator_mut_double_end() {\n         let mut n = DList::new();\n         assert!(n.mut_iter().next_back().is_none());\n-        n.push_front(4);\n+        n.push_front(4i);\n         n.push_front(5);\n         n.push_front(6);\n         let mut it = n.mut_iter();\n@@ -906,7 +906,7 @@ mod tests {\n \n     #[test]\n     fn test_insert_prev() {\n-        let mut m = list_from(&[0,2,4,6,8]);\n+        let mut m = list_from(&[0i,2,4,6,8]);\n         let len = m.len();\n         {\n             let mut it = m.mut_iter();\n@@ -933,8 +933,8 @@ mod tests {\n \n     #[test]\n     fn test_merge() {\n-        let mut m = list_from([0, 1, 3, 5, 6, 7, 2]);\n-        let n = list_from([-1, 0, 0, 7, 7, 9]);\n+        let mut m = list_from([0i, 1, 3, 5, 6, 7, 2]);\n+        let n = list_from([-1i, 0, 0, 7, 7, 9]);\n         let len = m.len() + n.len();\n         m.merge(n, |a, b| a <= b);\n         assert_eq!(m.len(), len);\n@@ -946,12 +946,12 @@ mod tests {\n     #[test]\n     fn test_insert_ordered() {\n         let mut n = DList::new();\n-        n.insert_ordered(1);\n+        n.insert_ordered(1i);\n         assert_eq!(n.len(), 1);\n         assert_eq!(n.pop_front(), Some(1));\n \n         let mut m = DList::new();\n-        m.push_back(2);\n+        m.push_back(2i);\n         m.push_back(4);\n         m.insert_ordered(3);\n         check_links(&m);\n@@ -966,15 +966,15 @@ mod tests {\n         }\n         let mut n = DList::new();\n         assert!(n.mut_iter().rev().next().is_none());\n-        n.push_front(4);\n+        n.push_front(4i);\n         let mut it = n.mut_iter().rev();\n         assert!(it.next().is_some());\n         assert!(it.next().is_none());\n     }\n \n     #[test]\n     fn test_send() {\n-        let n = list_from([1,2,3]);\n+        let n = list_from([1i,2,3]);\n         spawn(proc() {\n             check_links(&n);\n             assert_eq!(&[&1,&2,&3], n.iter().collect::<Vec<&int>>().as_slice());\n@@ -991,15 +991,15 @@ mod tests {\n         m.push_back(1);\n         assert!(n == m);\n \n-        let n = list_from([2,3,4]);\n-        let m = list_from([1,2,3]);\n+        let n = list_from([2i,3,4]);\n+        let m = list_from([1i,2,3]);\n         assert!(n != m);\n     }\n \n     #[test]\n     fn test_ord() {\n         let n: DList<int> = list_from([]);\n-        let m = list_from([1,2,3]);\n+        let m = list_from([1i,2,3]);\n         assert!(n < m);\n         assert!(m > n);\n         assert!(n <= n);\n@@ -1008,7 +1008,7 @@ mod tests {\n \n     #[test]\n     fn test_ord_nan() {\n-        let nan = 0.0/0.0;\n+        let nan = 0.0f64/0.0;\n         let n = list_from([nan]);\n         let m = list_from([nan]);\n         assert!(!(n < m));\n@@ -1017,21 +1017,21 @@ mod tests {\n         assert!(!(n >= m));\n \n         let n = list_from([nan]);\n-        let one = list_from([1.0]);\n+        let one = list_from([1.0f64]);\n         assert!(!(n < one));\n         assert!(!(n > one));\n         assert!(!(n <= one));\n         assert!(!(n >= one));\n \n-        let u = list_from([1.0,2.0,nan]);\n-        let v = list_from([1.0,2.0,3.0]);\n+        let u = list_from([1.0f64,2.0,nan]);\n+        let v = list_from([1.0f64,2.0,3.0]);\n         assert!(!(u < v));\n         assert!(!(u > v));\n         assert!(!(u <= v));\n         assert!(!(u >= v));\n \n-        let s = list_from([1.0,2.0,4.0,2.0]);\n-        let t = list_from([1.0,2.0,3.0,2.0]);\n+        let s = list_from([1.0f64,2.0,4.0,2.0]);\n+        let t = list_from([1.0f64,2.0,3.0,2.0]);\n         assert!(!(s < t));\n         assert!(s > one);\n         assert!(!(s <= one));\n@@ -1040,7 +1040,7 @@ mod tests {\n \n     #[test]\n     fn test_fuzz() {\n-        for _ in range(0, 25) {\n+        for _ in range(0u, 25) {\n             fuzz_test(3);\n             fuzz_test(16);\n             fuzz_test(189);\n@@ -1049,7 +1049,7 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let list: DList<int> = range(0, 10).collect();\n+        let list: DList<int> = range(0i, 10).collect();\n         assert!(list.to_str().as_slice() == \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let list: DList<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n@@ -1097,7 +1097,7 @@ mod tests {\n \n     #[bench]\n     fn bench_collect_into(b: &mut test::Bencher) {\n-        let v = &[0, ..64];\n+        let v = &[0i, ..64];\n         b.iter(|| {\n             let _: DList<int> = v.iter().map(|x| *x).collect();\n         })\n@@ -1140,7 +1140,7 @@ mod tests {\n     #[bench]\n     fn bench_rotate_forward(b: &mut test::Bencher) {\n         let mut m: DList<int> = DList::new();\n-        m.push_front(0);\n+        m.push_front(0i);\n         m.push_front(1);\n         b.iter(|| {\n             m.rotate_forward();\n@@ -1150,7 +1150,7 @@ mod tests {\n     #[bench]\n     fn bench_rotate_backward(b: &mut test::Bencher) {\n         let mut m: DList<int> = DList::new();\n-        m.push_front(0);\n+        m.push_front(0i);\n         m.push_front(1);\n         b.iter(|| {\n             m.rotate_backward();\n@@ -1159,31 +1159,31 @@ mod tests {\n \n     #[bench]\n     fn bench_iter(b: &mut test::Bencher) {\n-        let v = &[0, ..128];\n+        let v = &[0i, ..128];\n         let m: DList<int> = v.iter().map(|&x|x).collect();\n         b.iter(|| {\n             assert!(m.iter().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_mut(b: &mut test::Bencher) {\n-        let v = &[0, ..128];\n+        let v = &[0i, ..128];\n         let mut m: DList<int> = v.iter().map(|&x|x).collect();\n         b.iter(|| {\n             assert!(m.mut_iter().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_rev(b: &mut test::Bencher) {\n-        let v = &[0, ..128];\n+        let v = &[0i, ..128];\n         let m: DList<int> = v.iter().map(|&x|x).collect();\n         b.iter(|| {\n             assert!(m.iter().rev().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_mut_rev(b: &mut test::Bencher) {\n-        let v = &[0, ..128];\n+        let v = &[0i, ..128];\n         let mut m: DList<int> = v.iter().map(|&x|x).collect();\n         b.iter(|| {\n             assert!(m.mut_iter().rev().count() == 128);"}, {"sha": "256621d08e54a6be9eef29bee25c527d50890ccc", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -255,8 +255,8 @@ mod tests {\n \n     #[test]\n     fn test_iterator() {\n-        let data = vec!(5, 9, 3);\n-        let iterout = [9, 5, 3];\n+        let data = vec!(5i, 9, 3);\n+        let iterout = [9i, 5, 3];\n         let pq = PriorityQueue::from_vec(data);\n         let mut i = 0;\n         for el in pq.iter() {\n@@ -279,7 +279,7 @@ mod tests {\n \n     #[test]\n     fn test_push() {\n-        let mut heap = PriorityQueue::from_vec(vec!(2, 4, 9));\n+        let mut heap = PriorityQueue::from_vec(vec!(2i, 4, 9));\n         assert_eq!(heap.len(), 3);\n         assert!(*heap.top().unwrap() == 9);\n         heap.push(11);\n@@ -301,7 +301,7 @@ mod tests {\n \n     #[test]\n     fn test_push_unique() {\n-        let mut heap = PriorityQueue::from_vec(vec!(box 2, box 4, box 9));\n+        let mut heap = PriorityQueue::from_vec(vec!(box 2i, box 4, box 9));\n         assert_eq!(heap.len(), 3);\n         assert!(*heap.top().unwrap() == box 9);\n         heap.push(box 11);\n@@ -323,7 +323,7 @@ mod tests {\n \n     #[test]\n     fn test_push_pop() {\n-        let mut heap = PriorityQueue::from_vec(vec!(5, 5, 2, 1, 3));\n+        let mut heap = PriorityQueue::from_vec(vec!(5i, 5, 2, 1, 3));\n         assert_eq!(heap.len(), 5);\n         assert_eq!(heap.push_pop(6), 6);\n         assert_eq!(heap.len(), 5);\n@@ -337,7 +337,7 @@ mod tests {\n \n     #[test]\n     fn test_replace() {\n-        let mut heap = PriorityQueue::from_vec(vec!(5, 5, 2, 1, 3));\n+        let mut heap = PriorityQueue::from_vec(vec!(5i, 5, 2, 1, 3));\n         assert_eq!(heap.len(), 5);\n         assert_eq!(heap.replace(6).unwrap(), 5);\n         assert_eq!(heap.len(), 5);\n@@ -362,18 +362,18 @@ mod tests {\n     #[test]\n     fn test_to_vec() {\n         check_to_vec(vec!());\n-        check_to_vec(vec!(5));\n-        check_to_vec(vec!(3, 2));\n-        check_to_vec(vec!(2, 3));\n-        check_to_vec(vec!(5, 1, 2));\n-        check_to_vec(vec!(1, 100, 2, 3));\n-        check_to_vec(vec!(1, 3, 5, 7, 9, 2, 4, 6, 8, 0));\n-        check_to_vec(vec!(2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1));\n-        check_to_vec(vec!(9, 11, 9, 9, 9, 9, 11, 2, 3, 4, 11, 9, 0, 0, 0, 0));\n-        check_to_vec(vec!(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n-        check_to_vec(vec!(10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0));\n-        check_to_vec(vec!(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 1, 2));\n-        check_to_vec(vec!(5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5, 4, 3, 2, 1));\n+        check_to_vec(vec!(5i));\n+        check_to_vec(vec!(3i, 2));\n+        check_to_vec(vec!(2i, 3));\n+        check_to_vec(vec!(5i, 1, 2));\n+        check_to_vec(vec!(1i, 100, 2, 3));\n+        check_to_vec(vec!(1i, 3, 5, 7, 9, 2, 4, 6, 8, 0));\n+        check_to_vec(vec!(2i, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1));\n+        check_to_vec(vec!(9i, 11, 9, 9, 9, 9, 11, 2, 3, 4, 11, 9, 0, 0, 0, 0));\n+        check_to_vec(vec!(0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n+        check_to_vec(vec!(10i, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0));\n+        check_to_vec(vec!(0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 1, 2));\n+        check_to_vec(vec!(5i, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5, 4, 3, 2, 1));\n     }\n \n     #[test]"}, {"sha": "be0d603696bec9f08486560aaf586b258c99e566", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -431,8 +431,8 @@ mod tests {\n     fn test_simple() {\n         let mut d = RingBuf::new();\n         assert_eq!(d.len(), 0u);\n-        d.push_front(17);\n-        d.push_front(42);\n+        d.push_front(17i);\n+        d.push_front(42i);\n         d.push_back(137);\n         assert_eq!(d.len(), 3u);\n         d.push_back(137);\n@@ -588,7 +588,7 @@ mod tests {\n     fn bench_grow(b: &mut test::Bencher) {\n         let mut deq = RingBuf::new();\n         b.iter(|| {\n-            for _ in range(0, 65) {\n+            for _ in range(0i, 65) {\n                 deq.push_front(1);\n             }\n         })\n@@ -684,7 +684,7 @@ mod tests {\n \n     #[test]\n     fn test_swap() {\n-        let mut d: RingBuf<int> = range(0, 5).collect();\n+        let mut d: RingBuf<int> = range(0i, 5).collect();\n         d.pop_front();\n         d.swap(0, 3);\n         assert_eq!(d.iter().map(|&x|x).collect::<Vec<int>>(), vec!(4, 2, 3, 1));\n@@ -696,12 +696,12 @@ mod tests {\n         assert_eq!(d.iter().next(), None);\n         assert_eq!(d.iter().size_hint(), (0, Some(0)));\n \n-        for i in range(0, 5) {\n+        for i in range(0i, 5) {\n             d.push_back(i);\n         }\n         assert_eq!(d.iter().collect::<Vec<&int>>().as_slice(), &[&0,&1,&2,&3,&4]);\n \n-        for i in range(6, 9) {\n+        for i in range(6i, 9) {\n             d.push_front(i);\n         }\n         assert_eq!(d.iter().collect::<Vec<&int>>().as_slice(), &[&8,&7,&6,&0,&1,&2,&3,&4]);\n@@ -721,12 +721,12 @@ mod tests {\n         let mut d = RingBuf::new();\n         assert_eq!(d.iter().rev().next(), None);\n \n-        for i in range(0, 5) {\n+        for i in range(0i, 5) {\n             d.push_back(i);\n         }\n         assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), &[&4,&3,&2,&1,&0]);\n \n-        for i in range(6, 9) {\n+        for i in range(6i, 9) {\n             d.push_front(i);\n         }\n         assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), &[&4,&3,&2,&1,&0,&6,&7,&8]);\n@@ -737,7 +737,7 @@ mod tests {\n         let mut d = RingBuf::with_capacity(3);\n         assert!(d.mut_iter().rev().next().is_none());\n \n-        d.push_back(1);\n+        d.push_back(1i);\n         d.push_back(2);\n         d.push_back(3);\n         assert_eq!(d.pop_front(), Some(1));\n@@ -796,7 +796,7 @@ mod tests {\n     #[test]\n     fn test_from_iter() {\n         use std::iter;\n-        let v = vec!(1,2,3,4,5,6,7);\n+        let v = vec!(1i,2,3,4,5,6,7);\n         let deq: RingBuf<int> = v.iter().map(|&x| x).collect();\n         let u: Vec<int> = deq.iter().map(|&x| x).collect();\n         assert_eq!(u, v);\n@@ -812,7 +812,7 @@ mod tests {\n     #[test]\n     fn test_clone() {\n         let mut d = RingBuf::new();\n-        d.push_front(17);\n+        d.push_front(17i);\n         d.push_front(42);\n         d.push_back(137);\n         d.push_back(137);\n@@ -830,7 +830,7 @@ mod tests {\n     fn test_eq() {\n         let mut d = RingBuf::new();\n         assert!(d == RingBuf::with_capacity(0));\n-        d.push_front(137);\n+        d.push_front(137i);\n         d.push_front(17);\n         d.push_front(42);\n         d.push_back(137);\n@@ -849,7 +849,7 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let ringbuf: RingBuf<int> = range(0, 10).collect();\n+        let ringbuf: RingBuf<int> = range(0i, 10).collect();\n         assert!(format!(\"{}\", ringbuf).as_slice() == \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let ringbuf: RingBuf<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()"}, {"sha": "ac8ac6102f323d7452c24e694e495baa5fb7e5e8", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 185, "deletions": 183, "changes": 368, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -75,7 +75,7 @@ The iterator yields references to the vector's elements, so if the element\n type of the vector is `int`, the element type of the iterator is `&int`.\n \n ```rust\n-let numbers = [0, 1, 2];\n+let numbers = [0i, 1i, 2i];\n for &x in numbers.iter() {\n     println!(\"{} is a number!\", x);\n }\n@@ -597,10 +597,10 @@ pub trait MutableOrdVector<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = [-5, 4, 1, -3, 2];\n+    /// let mut v = [-5i, 4, 1, -3, 2];\n     ///\n     /// v.sort();\n-    /// assert!(v == [-5, -3, 1, 2, 4]);\n+    /// assert!(v == [-5i, -3, 1, 2, 4]);\n     /// ```\n     fn sort(self);\n \n@@ -611,11 +611,11 @@ pub trait MutableOrdVector<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v = &mut [0, 1, 2];\n+    /// let v = &mut [0i, 1, 2];\n     /// v.next_permutation();\n-    /// assert_eq!(v, &mut [0, 2, 1]);\n+    /// assert_eq!(v, &mut [0i, 2, 1]);\n     /// v.next_permutation();\n-    /// assert_eq!(v, &mut [1, 0, 2]);\n+    /// assert_eq!(v, &mut [1i, 0, 2]);\n     /// ```\n     fn next_permutation(self) -> bool;\n \n@@ -626,11 +626,11 @@ pub trait MutableOrdVector<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v = &mut [1, 0, 2];\n+    /// let v = &mut [1i, 0, 2];\n     /// v.prev_permutation();\n-    /// assert_eq!(v, &mut [0, 2, 1]);\n+    /// assert_eq!(v, &mut [0i, 2, 1]);\n     /// v.prev_permutation();\n-    /// assert_eq!(v, &mut [0, 1, 2]);\n+    /// assert_eq!(v, &mut [0i, 1, 2]);\n     /// ```\n     fn prev_permutation(self) -> bool;\n }\n@@ -796,29 +796,29 @@ mod tests {\n \n     #[test]\n     fn test_get() {\n-        let mut a = vec![11];\n+        let mut a = vec![11i];\n         assert_eq!(a.as_slice().get(1), None);\n-        a = vec![11, 12];\n+        a = vec![11i, 12];\n         assert_eq!(a.as_slice().get(1).unwrap(), &12);\n-        a = vec![11, 12, 13];\n+        a = vec![11i, 12, 13];\n         assert_eq!(a.as_slice().get(1).unwrap(), &12);\n     }\n \n     #[test]\n     fn test_head() {\n         let mut a = vec![];\n         assert_eq!(a.as_slice().head(), None);\n-        a = vec![11];\n+        a = vec![11i];\n         assert_eq!(a.as_slice().head().unwrap(), &11);\n-        a = vec![11, 12];\n+        a = vec![11i, 12];\n         assert_eq!(a.as_slice().head().unwrap(), &11);\n     }\n \n     #[test]\n     fn test_tail() {\n-        let mut a = vec![11];\n+        let mut a = vec![11i];\n         assert_eq!(a.tail(), &[]);\n-        a = vec![11, 12];\n+        a = vec![11i, 12];\n         assert_eq!(a.tail(), &[12]);\n     }\n \n@@ -831,9 +831,9 @@ mod tests {\n \n     #[test]\n     fn test_tailn() {\n-        let mut a = vec![11, 12, 13];\n+        let mut a = vec![11i, 12, 13];\n         assert_eq!(a.tailn(0), &[11, 12, 13]);\n-        a = vec![11, 12, 13];\n+        a = vec![11i, 12, 13];\n         assert_eq!(a.tailn(2), &[13]);\n     }\n \n@@ -846,9 +846,9 @@ mod tests {\n \n     #[test]\n     fn test_init() {\n-        let mut a = vec![11];\n+        let mut a = vec![11i];\n         assert_eq!(a.init(), &[]);\n-        a = vec![11, 12];\n+        a = vec![11i, 12];\n         assert_eq!(a.init(), &[11]);\n     }\n \n@@ -861,9 +861,9 @@ mod tests {\n \n     #[test]\n     fn test_initn() {\n-        let mut a = vec![11, 12, 13];\n+        let mut a = vec![11i, 12, 13];\n         assert_eq!(a.as_slice().initn(0), &[11, 12, 13]);\n-        a = vec![11, 12, 13];\n+        a = vec![11i, 12, 13];\n         assert_eq!(a.as_slice().initn(2), &[11]);\n     }\n \n@@ -878,16 +878,16 @@ mod tests {\n     fn test_last() {\n         let mut a = vec![];\n         assert_eq!(a.as_slice().last(), None);\n-        a = vec![11];\n+        a = vec![11i];\n         assert_eq!(a.as_slice().last().unwrap(), &11);\n-        a = vec![11, 12];\n+        a = vec![11i, 12];\n         assert_eq!(a.as_slice().last().unwrap(), &12);\n     }\n \n     #[test]\n     fn test_slice() {\n         // Test fixed length vector.\n-        let vec_fixed = [1, 2, 3, 4];\n+        let vec_fixed = [1i, 2, 3, 4];\n         let v_a = vec_fixed.slice(1u, vec_fixed.len()).to_owned();\n         assert_eq!(v_a.len(), 3u);\n         let v_a = v_a.as_slice();\n@@ -896,15 +896,15 @@ mod tests {\n         assert_eq!(v_a[2], 4);\n \n         // Test on stack.\n-        let vec_stack = &[1, 2, 3];\n+        let vec_stack = &[1i, 2, 3];\n         let v_b = vec_stack.slice(1u, 3u).to_owned();\n         assert_eq!(v_b.len(), 2u);\n         let v_b = v_b.as_slice();\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n         // Test `Box<[T]>`\n-        let vec_unique = vec![1, 2, 3, 4, 5, 6];\n+        let vec_unique = vec![1i, 2, 3, 4, 5, 6];\n         let v_d = vec_unique.slice(1u, 6u).to_owned();\n         assert_eq!(v_d.len(), 5u);\n         let v_d = v_d.as_slice();\n@@ -917,15 +917,15 @@ mod tests {\n \n     #[test]\n     fn test_slice_from() {\n-        let vec = &[1, 2, 3, 4];\n+        let vec = &[1i, 2, 3, 4];\n         assert_eq!(vec.slice_from(0), vec);\n         assert_eq!(vec.slice_from(2), &[3, 4]);\n         assert_eq!(vec.slice_from(4), &[]);\n     }\n \n     #[test]\n     fn test_slice_to() {\n-        let vec = &[1, 2, 3, 4];\n+        let vec = &[1i, 2, 3, 4];\n         assert_eq!(vec.slice_to(4), vec);\n         assert_eq!(vec.slice_to(2), &[1, 2]);\n         assert_eq!(vec.slice_to(0), &[]);\n@@ -934,7 +934,7 @@ mod tests {\n \n     #[test]\n     fn test_pop() {\n-        let mut v = vec![5];\n+        let mut v = vec![5i];\n         let e = v.pop();\n         assert_eq!(v.len(), 0);\n         assert_eq!(e, Some(5));\n@@ -946,17 +946,17 @@ mod tests {\n \n     #[test]\n     fn test_swap_remove() {\n-        let mut v = vec![1, 2, 3, 4, 5];\n+        let mut v = vec![1i, 2, 3, 4, 5];\n         let mut e = v.swap_remove(0);\n         assert_eq!(e, Some(1));\n-        assert_eq!(v, vec![5, 2, 3, 4]);\n+        assert_eq!(v, vec![5i, 2, 3, 4]);\n         e = v.swap_remove(3);\n         assert_eq!(e, Some(4));\n-        assert_eq!(v, vec![5, 2, 3]);\n+        assert_eq!(v, vec![5i, 2, 3]);\n \n         e = v.swap_remove(3);\n         assert_eq!(e, None);\n-        assert_eq!(v, vec![5, 2, 3]);\n+        assert_eq!(v, vec![5i, 2, 3]);\n     }\n \n     #[test]\n@@ -977,12 +977,12 @@ mod tests {\n     fn test_push() {\n         // Test on-stack push().\n         let mut v = vec![];\n-        v.push(1);\n+        v.push(1i);\n         assert_eq!(v.len(), 1u);\n         assert_eq!(v.as_slice()[0], 1);\n \n         // Test on-heap push().\n-        v.push(2);\n+        v.push(2i);\n         assert_eq!(v.len(), 2u);\n         assert_eq!(v.as_slice()[0], 1);\n         assert_eq!(v.as_slice()[1], 2);\n@@ -992,7 +992,7 @@ mod tests {\n     fn test_grow() {\n         // Test on-stack grow().\n         let mut v = vec![];\n-        v.grow(2u, &1);\n+        v.grow(2u, &1i);\n         {\n             let v = v.as_slice();\n             assert_eq!(v.len(), 2u);\n@@ -1001,7 +1001,7 @@ mod tests {\n         }\n \n         // Test on-heap grow().\n-        v.grow(3u, &2);\n+        v.grow(3u, &2i);\n         {\n             let v = v.as_slice();\n             assert_eq!(v.len(), 5u);\n@@ -1026,7 +1026,7 @@ mod tests {\n \n     #[test]\n     fn test_grow_set() {\n-        let mut v = vec![1, 2, 3];\n+        let mut v = vec![1i, 2, 3];\n         v.grow_set(4u, &4, 5);\n         let v = v.as_slice();\n         assert_eq!(v.len(), 5u);\n@@ -1039,7 +1039,7 @@ mod tests {\n \n     #[test]\n     fn test_truncate() {\n-        let mut v = vec![box 6,box 5,box 4];\n+        let mut v = vec![box 6i,box 5,box 4];\n         v.truncate(1);\n         let v = v.as_slice();\n         assert_eq!(v.len(), 1);\n@@ -1049,7 +1049,7 @@ mod tests {\n \n     #[test]\n     fn test_clear() {\n-        let mut v = vec![box 6,box 5,box 4];\n+        let mut v = vec![box 6i,box 5,box 4];\n         v.clear();\n         assert_eq!(v.len(), 0);\n         // If the unsafe block didn't drop things properly, we blow up here.\n@@ -1063,22 +1063,22 @@ mod tests {\n             assert_eq!(v, b);\n         }\n         case(vec![], vec![]);\n-        case(vec![1], vec![1]);\n-        case(vec![1,1], vec![1]);\n-        case(vec![1,2,3], vec![1,2,3]);\n-        case(vec![1,1,2,3], vec![1,2,3]);\n-        case(vec![1,2,2,3], vec![1,2,3]);\n-        case(vec![1,2,3,3], vec![1,2,3]);\n-        case(vec![1,1,2,2,2,3,3], vec![1,2,3]);\n+        case(vec![1u], vec![1]);\n+        case(vec![1u,1], vec![1]);\n+        case(vec![1u,2,3], vec![1,2,3]);\n+        case(vec![1u,1,2,3], vec![1,2,3]);\n+        case(vec![1u,2,2,3], vec![1,2,3]);\n+        case(vec![1u,2,3,3], vec![1,2,3]);\n+        case(vec![1u,1,2,2,2,3,3], vec![1,2,3]);\n     }\n \n     #[test]\n     fn test_dedup_unique() {\n-        let mut v0 = vec![box 1, box 1, box 2, box 3];\n+        let mut v0 = vec![box 1i, box 1, box 2, box 3];\n         v0.dedup();\n-        let mut v1 = vec![box 1, box 2, box 2, box 3];\n+        let mut v1 = vec![box 1i, box 2, box 2, box 3];\n         v1.dedup();\n-        let mut v2 = vec![box 1, box 2, box 3, box 3];\n+        let mut v2 = vec![box 1i, box 2, box 3, box 3];\n         v2.dedup();\n         /*\n          * If the boxed pointers were leaked or otherwise misused, valgrind\n@@ -1088,11 +1088,11 @@ mod tests {\n \n     #[test]\n     fn test_dedup_shared() {\n-        let mut v0 = vec![box 1, box 1, box 2, box 3];\n+        let mut v0 = vec![box 1i, box 1, box 2, box 3];\n         v0.dedup();\n-        let mut v1 = vec![box 1, box 2, box 2, box 3];\n+        let mut v1 = vec![box 1i, box 2, box 2, box 3];\n         v1.dedup();\n-        let mut v2 = vec![box 1, box 2, box 3, box 3];\n+        let mut v2 = vec![box 1i, box 2, box 3, box 3];\n         v2.dedup();\n         /*\n          * If the pointers were leaked or otherwise misused, valgrind and/or\n@@ -1102,14 +1102,14 @@ mod tests {\n \n     #[test]\n     fn test_retain() {\n-        let mut v = vec![1, 2, 3, 4, 5];\n+        let mut v = vec![1u, 2, 3, 4, 5];\n         v.retain(is_odd);\n-        assert_eq!(v, vec![1, 3, 5]);\n+        assert_eq!(v, vec![1u, 3, 5]);\n     }\n \n     #[test]\n     fn test_element_swaps() {\n-        let mut v = [1, 2, 3];\n+        let mut v = [1i, 2, 3];\n         for (i, (a, b)) in ElementSwaps::new(v.len()).enumerate() {\n             v.swap(a, b);\n             match i {\n@@ -1145,7 +1145,7 @@ mod tests {\n             assert_eq!(it.next(), None);\n         }\n         {\n-            let v = [1, 2, 3];\n+            let v = [1i, 2, 3];\n             let mut it = v.permutations();\n             let (min_size, max_opt) = it.size_hint();\n             assert_eq!(min_size, 3*2);\n@@ -1179,7 +1179,7 @@ mod tests {\n \n     #[test]\n     fn test_lexicographic_permutations() {\n-        let v : &mut[int] = &mut[1, 2, 3, 4, 5];\n+        let v : &mut[int] = &mut[1i, 2, 3, 4, 5];\n         assert!(v.prev_permutation() == false);\n         assert!(v.next_permutation());\n         assert_eq!(v, &mut[1, 2, 3, 5, 4]);\n@@ -1191,7 +1191,7 @@ mod tests {\n         assert!(v.next_permutation());\n         assert_eq!(v, &mut[1, 2, 4, 5, 3]);\n \n-        let v : &mut[int] = &mut[1, 0, 0, 0];\n+        let v : &mut[int] = &mut[1i, 0, 0, 0];\n         assert!(v.next_permutation() == false);\n         assert!(v.prev_permutation());\n         assert_eq!(v, &mut[0, 1, 0, 0]);\n@@ -1210,13 +1210,13 @@ mod tests {\n         assert!(empty.prev_permutation() == false);\n         assert_eq!(empty, &mut[]);\n \n-        let one_elem : &mut[int] = &mut[4];\n+        let one_elem : &mut[int] = &mut[4i];\n         assert!(one_elem.prev_permutation() == false);\n         assert_eq!(one_elem, &mut[4]);\n         assert!(one_elem.next_permutation() == false);\n         assert_eq!(one_elem, &mut[4]);\n \n-        let two_elem : &mut[int] = &mut[1, 2];\n+        let two_elem : &mut[int] = &mut[1i, 2];\n         assert!(two_elem.prev_permutation() == false);\n         assert_eq!(two_elem, &mut[1, 2]);\n         assert!(two_elem.next_permutation());\n@@ -1231,9 +1231,9 @@ mod tests {\n \n     #[test]\n     fn test_position_elem() {\n-        assert!([].position_elem(&1).is_none());\n+        assert!([].position_elem(&1i).is_none());\n \n-        let v1 = vec![1, 2, 3, 3, 2, 5];\n+        let v1 = vec![1i, 2, 3, 3, 2, 5];\n         assert_eq!(v1.as_slice().position_elem(&1), Some(0u));\n         assert_eq!(v1.as_slice().position_elem(&2), Some(1u));\n         assert_eq!(v1.as_slice().position_elem(&5), Some(5u));\n@@ -1242,52 +1242,52 @@ mod tests {\n \n     #[test]\n     fn test_bsearch_elem() {\n-        assert_eq!([1,2,3,4,5].bsearch_elem(&5), Some(4));\n-        assert_eq!([1,2,3,4,5].bsearch_elem(&4), Some(3));\n-        assert_eq!([1,2,3,4,5].bsearch_elem(&3), Some(2));\n-        assert_eq!([1,2,3,4,5].bsearch_elem(&2), Some(1));\n-        assert_eq!([1,2,3,4,5].bsearch_elem(&1), Some(0));\n+        assert_eq!([1i,2,3,4,5].bsearch_elem(&5), Some(4));\n+        assert_eq!([1i,2,3,4,5].bsearch_elem(&4), Some(3));\n+        assert_eq!([1i,2,3,4,5].bsearch_elem(&3), Some(2));\n+        assert_eq!([1i,2,3,4,5].bsearch_elem(&2), Some(1));\n+        assert_eq!([1i,2,3,4,5].bsearch_elem(&1), Some(0));\n \n-        assert_eq!([2,4,6,8,10].bsearch_elem(&1), None);\n-        assert_eq!([2,4,6,8,10].bsearch_elem(&5), None);\n-        assert_eq!([2,4,6,8,10].bsearch_elem(&4), Some(1));\n-        assert_eq!([2,4,6,8,10].bsearch_elem(&10), Some(4));\n+        assert_eq!([2i,4,6,8,10].bsearch_elem(&1), None);\n+        assert_eq!([2i,4,6,8,10].bsearch_elem(&5), None);\n+        assert_eq!([2i,4,6,8,10].bsearch_elem(&4), Some(1));\n+        assert_eq!([2i,4,6,8,10].bsearch_elem(&10), Some(4));\n \n-        assert_eq!([2,4,6,8].bsearch_elem(&1), None);\n-        assert_eq!([2,4,6,8].bsearch_elem(&5), None);\n-        assert_eq!([2,4,6,8].bsearch_elem(&4), Some(1));\n-        assert_eq!([2,4,6,8].bsearch_elem(&8), Some(3));\n+        assert_eq!([2i,4,6,8].bsearch_elem(&1), None);\n+        assert_eq!([2i,4,6,8].bsearch_elem(&5), None);\n+        assert_eq!([2i,4,6,8].bsearch_elem(&4), Some(1));\n+        assert_eq!([2i,4,6,8].bsearch_elem(&8), Some(3));\n \n-        assert_eq!([2,4,6].bsearch_elem(&1), None);\n-        assert_eq!([2,4,6].bsearch_elem(&5), None);\n-        assert_eq!([2,4,6].bsearch_elem(&4), Some(1));\n-        assert_eq!([2,4,6].bsearch_elem(&6), Some(2));\n+        assert_eq!([2i,4,6].bsearch_elem(&1), None);\n+        assert_eq!([2i,4,6].bsearch_elem(&5), None);\n+        assert_eq!([2i,4,6].bsearch_elem(&4), Some(1));\n+        assert_eq!([2i,4,6].bsearch_elem(&6), Some(2));\n \n-        assert_eq!([2,4].bsearch_elem(&1), None);\n-        assert_eq!([2,4].bsearch_elem(&5), None);\n-        assert_eq!([2,4].bsearch_elem(&2), Some(0));\n-        assert_eq!([2,4].bsearch_elem(&4), Some(1));\n+        assert_eq!([2i,4].bsearch_elem(&1), None);\n+        assert_eq!([2i,4].bsearch_elem(&5), None);\n+        assert_eq!([2i,4].bsearch_elem(&2), Some(0));\n+        assert_eq!([2i,4].bsearch_elem(&4), Some(1));\n \n-        assert_eq!([2].bsearch_elem(&1), None);\n-        assert_eq!([2].bsearch_elem(&5), None);\n-        assert_eq!([2].bsearch_elem(&2), Some(0));\n+        assert_eq!([2i].bsearch_elem(&1), None);\n+        assert_eq!([2i].bsearch_elem(&5), None);\n+        assert_eq!([2i].bsearch_elem(&2), Some(0));\n \n-        assert_eq!([].bsearch_elem(&1), None);\n-        assert_eq!([].bsearch_elem(&5), None);\n+        assert_eq!([].bsearch_elem(&1i), None);\n+        assert_eq!([].bsearch_elem(&5i), None);\n \n-        assert!([1,1,1,1,1].bsearch_elem(&1) != None);\n-        assert!([1,1,1,1,2].bsearch_elem(&1) != None);\n-        assert!([1,1,1,2,2].bsearch_elem(&1) != None);\n-        assert!([1,1,2,2,2].bsearch_elem(&1) != None);\n-        assert_eq!([1,2,2,2,2].bsearch_elem(&1), Some(0));\n+        assert!([1i,1,1,1,1].bsearch_elem(&1) != None);\n+        assert!([1i,1,1,1,2].bsearch_elem(&1) != None);\n+        assert!([1i,1,1,2,2].bsearch_elem(&1) != None);\n+        assert!([1i,1,2,2,2].bsearch_elem(&1) != None);\n+        assert_eq!([1i,2,2,2,2].bsearch_elem(&1), Some(0));\n \n-        assert_eq!([1,2,3,4,5].bsearch_elem(&6), None);\n-        assert_eq!([1,2,3,4,5].bsearch_elem(&0), None);\n+        assert_eq!([1i,2,3,4,5].bsearch_elem(&6), None);\n+        assert_eq!([1i,2,3,4,5].bsearch_elem(&0), None);\n     }\n \n     #[test]\n     fn test_reverse() {\n-        let mut v: Vec<int> = vec![10, 20];\n+        let mut v: Vec<int> = vec![10i, 20];\n         assert_eq!(*v.get(0), 10);\n         assert_eq!(*v.get(1), 20);\n         v.reverse();\n@@ -1302,7 +1302,7 @@ mod tests {\n     #[test]\n     fn test_sort() {\n         for len in range(4u, 25) {\n-            for _ in range(0, 100) {\n+            for _ in range(0i, 100) {\n                 let mut v = task_rng().gen_iter::<uint>().take(len)\n                                       .collect::<Vec<uint>>();\n                 let mut v1 = v.clone();\n@@ -1329,9 +1329,9 @@ mod tests {\n \n     #[test]\n     fn test_sort_stability() {\n-        for len in range(4, 25) {\n-            for _ in range(0 , 10) {\n-                let mut counts = [0, .. 10];\n+        for len in range(4i, 25) {\n+            for _ in range(0u, 10) {\n+                let mut counts = [0i, .. 10];\n \n                 // create a vector like [(6, 1), (5, 1), (6, 2), ...],\n                 // where the first item of each tuple is random, but\n@@ -1361,44 +1361,44 @@ mod tests {\n     #[test]\n     fn test_partition() {\n         assert_eq!((vec![]).partition(|x: &int| *x < 3), (vec![], vec![]));\n-        assert_eq!((vec![1, 2, 3]).partition(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n-        assert_eq!((vec![1, 2, 3]).partition(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n-        assert_eq!((vec![1, 2, 3]).partition(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n+        assert_eq!((vec![1i, 2, 3]).partition(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n+        assert_eq!((vec![1i, 2, 3]).partition(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n+        assert_eq!((vec![1i, 2, 3]).partition(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n     }\n \n     #[test]\n     fn test_partitioned() {\n         assert_eq!(([]).partitioned(|x: &int| *x < 3), (vec![], vec![]));\n-        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n-        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n-        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n+        assert_eq!(([1i, 2, 3]).partitioned(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n+        assert_eq!(([1i, 2, 3]).partitioned(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n+        assert_eq!(([1i, 2, 3]).partitioned(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n     }\n \n     #[test]\n     fn test_concat() {\n         let v: [Vec<int>, ..0] = [];\n         assert_eq!(v.concat_vec(), vec![]);\n-        assert_eq!([vec![1], vec![2,3]].concat_vec(), vec![1, 2, 3]);\n+        assert_eq!([vec![1i], vec![2i,3i]].concat_vec(), vec![1, 2, 3]);\n \n-        assert_eq!([&[1], &[2,3]].concat_vec(), vec![1, 2, 3]);\n+        assert_eq!([&[1i], &[2i,3i]].concat_vec(), vec![1, 2, 3]);\n     }\n \n     #[test]\n     fn test_connect() {\n         let v: [Vec<int>, ..0] = [];\n         assert_eq!(v.connect_vec(&0), vec![]);\n-        assert_eq!([vec![1], vec![2, 3]].connect_vec(&0), vec![1, 0, 2, 3]);\n-        assert_eq!([vec![1], vec![2], vec![3]].connect_vec(&0), vec![1, 0, 2, 0, 3]);\n+        assert_eq!([vec![1i], vec![2i, 3]].connect_vec(&0), vec![1, 0, 2, 3]);\n+        assert_eq!([vec![1i], vec![2i], vec![3i]].connect_vec(&0), vec![1, 0, 2, 0, 3]);\n \n-        assert_eq!([&[1], &[2, 3]].connect_vec(&0), vec![1, 0, 2, 3]);\n-        assert_eq!([&[1], &[2], &[3]].connect_vec(&0), vec![1, 0, 2, 0, 3]);\n+        assert_eq!([&[1i], &[2i, 3]].connect_vec(&0), vec![1, 0, 2, 3]);\n+        assert_eq!([&[1i], &[2i], &[3]].connect_vec(&0), vec![1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n     fn test_shift() {\n-        let mut x = vec![1, 2, 3];\n+        let mut x = vec![1i, 2, 3];\n         assert_eq!(x.shift(), Some(1));\n-        assert_eq!(&x, &vec![2, 3]);\n+        assert_eq!(&x, &vec![2i, 3]);\n         assert_eq!(x.shift(), Some(2));\n         assert_eq!(x.shift(), Some(3));\n         assert_eq!(x.shift(), None);\n@@ -1407,52 +1407,52 @@ mod tests {\n \n     #[test]\n     fn test_unshift() {\n-        let mut x = vec![1, 2, 3];\n+        let mut x = vec![1i, 2, 3];\n         x.unshift(0);\n         assert_eq!(x, vec![0, 1, 2, 3]);\n     }\n \n     #[test]\n     fn test_insert() {\n-        let mut a = vec![1, 2, 4];\n+        let mut a = vec![1i, 2, 4];\n         a.insert(2, 3);\n         assert_eq!(a, vec![1, 2, 3, 4]);\n \n-        let mut a = vec![1, 2, 3];\n+        let mut a = vec![1i, 2, 3];\n         a.insert(0, 0);\n         assert_eq!(a, vec![0, 1, 2, 3]);\n \n-        let mut a = vec![1, 2, 3];\n+        let mut a = vec![1i, 2, 3];\n         a.insert(3, 4);\n         assert_eq!(a, vec![1, 2, 3, 4]);\n \n         let mut a = vec![];\n-        a.insert(0, 1);\n+        a.insert(0, 1i);\n         assert_eq!(a, vec![1]);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_insert_oob() {\n-        let mut a = vec![1, 2, 3];\n+        let mut a = vec![1i, 2, 3];\n         a.insert(4, 5);\n     }\n \n     #[test]\n     fn test_remove() {\n-        let mut a = vec![1,2,3,4];\n+        let mut a = vec![1i,2,3,4];\n \n         assert_eq!(a.remove(2), Some(3));\n-        assert_eq!(a, vec![1,2,4]);\n+        assert_eq!(a, vec![1i,2,4]);\n \n         assert_eq!(a.remove(2), Some(4));\n-        assert_eq!(a, vec![1,2]);\n+        assert_eq!(a, vec![1i,2]);\n \n         assert_eq!(a.remove(2), None);\n-        assert_eq!(a, vec![1,2]);\n+        assert_eq!(a, vec![1i,2]);\n \n         assert_eq!(a.remove(0), Some(1));\n-        assert_eq!(a, vec![2]);\n+        assert_eq!(a, vec![2i]);\n \n         assert_eq!(a.remove(0), Some(2));\n         assert_eq!(a, vec![]);\n@@ -1473,7 +1473,7 @@ mod tests {\n \n     #[test]\n     fn test_slice_2() {\n-        let v = vec![1, 2, 3, 4, 5];\n+        let v = vec![1i, 2, 3, 4, 5];\n         let v = v.slice(1u, 3u);\n         assert_eq!(v.len(), 2u);\n         assert_eq!(v[0], 2);\n@@ -1486,7 +1486,7 @@ mod tests {\n     fn test_from_fn_fail() {\n         Vec::from_fn(100, |v| {\n             if v == 50 { fail!() }\n-            box 0\n+            box 0i\n         });\n     }\n \n@@ -1519,15 +1519,15 @@ mod tests {\n             if i == 50 {\n                 fail!()\n             }\n-            (box 0, Rc::new(0))\n+            (box 0i, Rc::new(0i))\n         })\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_permute_fail() {\n-        let v = [(box 0, Rc::new(0)), (box 0, Rc::new(0)),\n-                 (box 0, Rc::new(0)), (box 0, Rc::new(0))];\n+        let v = [(box 0i, Rc::new(0i)), (box 0i, Rc::new(0i)),\n+                 (box 0i, Rc::new(0i)), (box 0i, Rc::new(0i))];\n         let mut i = 0;\n         for _ in v.permutations() {\n             if i == 2 {\n@@ -1541,24 +1541,24 @@ mod tests {\n     #[should_fail]\n     fn test_copy_memory_oob() {\n         unsafe {\n-            let mut a = [1, 2, 3, 4];\n-            let b = [1, 2, 3, 4, 5];\n+            let mut a = [1i, 2, 3, 4];\n+            let b = [1i, 2, 3, 4, 5];\n             a.copy_memory(b);\n         }\n     }\n \n     #[test]\n     fn test_total_ord() {\n-        [1, 2, 3, 4].cmp(& &[1, 2, 3]) == Greater;\n-        [1, 2, 3].cmp(& &[1, 2, 3, 4]) == Less;\n-        [1, 2, 3, 4].cmp(& &[1, 2, 3, 4]) == Equal;\n-        [1, 2, 3, 4, 5, 5, 5, 5].cmp(& &[1, 2, 3, 4, 5, 6]) == Less;\n-        [2, 2].cmp(& &[1, 2, 3, 4]) == Greater;\n+        [1i, 2, 3, 4].cmp(& &[1, 2, 3]) == Greater;\n+        [1i, 2, 3].cmp(& &[1, 2, 3, 4]) == Less;\n+        [1i, 2, 3, 4].cmp(& &[1, 2, 3, 4]) == Equal;\n+        [1i, 2, 3, 4, 5, 5, 5, 5].cmp(& &[1, 2, 3, 4, 5, 6]) == Less;\n+        [2i, 2].cmp(& &[1, 2, 3, 4]) == Greater;\n     }\n \n     #[test]\n     fn test_iterator() {\n-        let xs = [1, 2, 5, 10, 11];\n+        let xs = [1i, 2, 5, 10, 11];\n         let mut it = xs.iter();\n         assert_eq!(it.size_hint(), (5, Some(5)));\n         assert_eq!(it.next().unwrap(), &1);\n@@ -1576,7 +1576,7 @@ mod tests {\n \n     #[test]\n     fn test_random_access_iterator() {\n-        let xs = [1, 2, 5, 10, 11];\n+        let xs = [1i, 2, 5, 10, 11];\n         let mut it = xs.iter();\n \n         assert_eq!(it.indexable(), 5);\n@@ -1614,14 +1614,14 @@ mod tests {\n \n     #[test]\n     fn test_iter_size_hints() {\n-        let mut xs = [1, 2, 5, 10, 11];\n+        let mut xs = [1i, 2, 5, 10, 11];\n         assert_eq!(xs.iter().size_hint(), (5, Some(5)));\n         assert_eq!(xs.mut_iter().size_hint(), (5, Some(5)));\n     }\n \n     #[test]\n     fn test_iter_clone() {\n-        let xs = [1, 2, 5];\n+        let xs = [1i, 2, 5];\n         let mut it = xs.iter();\n         it.next();\n         let mut jt = it.clone();\n@@ -1632,7 +1632,7 @@ mod tests {\n \n     #[test]\n     fn test_mut_iterator() {\n-        let mut xs = [1, 2, 3, 4, 5];\n+        let mut xs = [1i, 2, 3, 4, 5];\n         for x in xs.mut_iter() {\n             *x += 1;\n         }\n@@ -1642,7 +1642,7 @@ mod tests {\n     #[test]\n     fn test_rev_iterator() {\n \n-        let xs = [1, 2, 5, 10, 11];\n+        let xs = [1i, 2, 5, 10, 11];\n         let ys = [11, 10, 5, 2, 1];\n         let mut i = 0;\n         for &x in xs.iter().rev() {\n@@ -1781,39 +1781,39 @@ mod tests {\n \n     #[test]\n     fn test_move_from() {\n-        let mut a = [1,2,3,4,5];\n-        let b = vec![6,7,8];\n+        let mut a = [1i,2,3,4,5];\n+        let b = vec![6i,7,8];\n         assert_eq!(a.move_from(b, 0, 3), 3);\n-        assert!(a == [6,7,8,4,5]);\n-        let mut a = [7,2,8,1];\n-        let b = vec![3,1,4,1,5,9];\n+        assert!(a == [6i,7,8,4,5]);\n+        let mut a = [7i,2,8,1];\n+        let b = vec![3i,1,4,1,5,9];\n         assert_eq!(a.move_from(b, 0, 6), 4);\n-        assert!(a == [3,1,4,1]);\n-        let mut a = [1,2,3,4];\n-        let b = vec![5,6,7,8,9,0];\n+        assert!(a == [3i,1,4,1]);\n+        let mut a = [1i,2,3,4];\n+        let b = vec![5i,6,7,8,9,0];\n         assert_eq!(a.move_from(b, 2, 3), 1);\n-        assert!(a == [7,2,3,4]);\n-        let mut a = [1,2,3,4,5];\n-        let b = vec![5,6,7,8,9,0];\n+        assert!(a == [7i,2,3,4]);\n+        let mut a = [1i,2,3,4,5];\n+        let b = vec![5i,6,7,8,9,0];\n         assert_eq!(a.mut_slice(2,4).move_from(b,1,6), 2);\n-        assert!(a == [1,2,6,7,5]);\n+        assert!(a == [1i,2,6,7,5]);\n     }\n \n     #[test]\n     fn test_copy_from() {\n-        let mut a = [1,2,3,4,5];\n-        let b = [6,7,8];\n+        let mut a = [1i,2,3,4,5];\n+        let b = [6i,7,8];\n         assert_eq!(a.copy_from(b), 3);\n-        assert!(a == [6,7,8,4,5]);\n-        let mut c = [7,2,8,1];\n-        let d = [3,1,4,1,5,9];\n+        assert!(a == [6i,7,8,4,5]);\n+        let mut c = [7i,2,8,1];\n+        let d = [3i,1,4,1,5,9];\n         assert_eq!(c.copy_from(d), 4);\n-        assert!(c == [3,1,4,1]);\n+        assert!(c == [3i,1,4,1]);\n     }\n \n     #[test]\n     fn test_reverse_part() {\n-        let mut values = [1,2,3,4,5];\n+        let mut values = [1i,2,3,4,5];\n         values.mut_slice(1, 4).reverse();\n         assert!(values == [1,4,3,2,5]);\n     }\n@@ -1829,15 +1829,15 @@ mod tests {\n         )\n         let empty: Vec<int> = vec![];\n         test_show_vec!(empty, \"[]\".to_string());\n-        test_show_vec!(vec![1], \"[1]\".to_string());\n-        test_show_vec!(vec![1, 2, 3], \"[1, 2, 3]\".to_string());\n+        test_show_vec!(vec![1i], \"[1]\".to_string());\n+        test_show_vec!(vec![1i, 2, 3], \"[1, 2, 3]\".to_string());\n         test_show_vec!(vec![vec![], vec![1u], vec![1u, 1u]],\n                        \"[[], [1], [1, 1]]\".to_string());\n \n         let empty_mut: &mut [int] = &mut[];\n         test_show_vec!(empty_mut, \"[]\".to_string());\n-        test_show_vec!(&mut[1], \"[1]\".to_string());\n-        test_show_vec!(&mut[1, 2, 3], \"[1, 2, 3]\".to_string());\n+        test_show_vec!(&mut[1i], \"[1]\".to_string());\n+        test_show_vec!(&mut[1i, 2, 3], \"[1, 2, 3]\".to_string());\n         test_show_vec!(&mut[&mut[], &mut[1u], &mut[1u, 1u]],\n                        \"[[], [1], [1, 1]]\".to_string());\n     }\n@@ -1908,7 +1908,7 @@ mod tests {\n     fn test_iter_zero_sized() {\n         let mut v = vec![Foo, Foo, Foo];\n         assert_eq!(v.len(), 3);\n-        let mut cnt = 0;\n+        let mut cnt = 0u;\n \n         for f in v.iter() {\n             assert!(*f == Foo);\n@@ -1946,13 +1946,13 @@ mod tests {\n     #[test]\n     fn test_shrink_to_fit() {\n         let mut xs = vec![0, 1, 2, 3];\n-        for i in range(4, 100) {\n+        for i in range(4i, 100) {\n             xs.push(i)\n         }\n         assert_eq!(xs.capacity(), 128);\n         xs.shrink_to_fit();\n         assert_eq!(xs.capacity(), 100);\n-        assert_eq!(xs, range(0, 100).collect::<Vec<_>>());\n+        assert_eq!(xs, range(0i, 100i).collect::<Vec<_>>());\n     }\n \n     #[test]\n@@ -2011,14 +2011,14 @@ mod tests {\n \n     #[test]\n     fn test_mut_splitator() {\n-        let mut xs = [0,1,0,2,3,0,0,4,5,0];\n+        let mut xs = [0i,1,0,2,3,0,0,4,5,0];\n         assert_eq!(xs.mut_split(|x| *x == 0).count(), 6);\n         for slice in xs.mut_split(|x| *x == 0) {\n             slice.reverse();\n         }\n         assert!(xs == [0,1,0,3,2,0,0,5,4,0]);\n \n-        let mut xs = [0,1,0,2,3,0,0,4,5,0,6,7];\n+        let mut xs = [0i,1,0,2,3,0,0,4,5,0,6,7];\n         for slice in xs.mut_split(|x| *x == 0).take(5) {\n             slice.reverse();\n         }\n@@ -2027,7 +2027,7 @@ mod tests {\n \n     #[test]\n     fn test_mut_splitator_rev() {\n-        let mut xs = [1,2,0,3,4,0,0,5,6,0];\n+        let mut xs = [1i,2,0,3,4,0,0,5,6,0];\n         for slice in xs.mut_split(|x| *x == 0).rev().take(4) {\n             slice.reverse();\n         }\n@@ -2036,7 +2036,7 @@ mod tests {\n \n     #[test]\n     fn test_get_mut() {\n-        let mut v = [0,1,2];\n+        let mut v = [0i,1,2];\n         assert_eq!(v.get_mut(3), None);\n         v.get_mut(1).map(|e| *e = 7);\n         assert_eq!(v[1], 7);\n@@ -2071,7 +2071,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_mut_chunks_0() {\n-        let mut v = [1, 2, 3, 4];\n+        let mut v = [1i, 2, 3, 4];\n         let _it = v.mut_chunks(0);\n     }\n \n@@ -2103,7 +2103,7 @@ mod tests {\n \n     #[test]\n     fn test_mut_last() {\n-        let mut x = [1, 2, 3, 4, 5];\n+        let mut x = [1i, 2, 3, 4, 5];\n         let h = x.mut_last();\n         assert_eq!(*h.unwrap(), 5);\n \n@@ -2140,10 +2140,10 @@ mod bench {\n \n     #[bench]\n     fn mut_iterator(b: &mut Bencher) {\n-        let mut v = Vec::from_elem(100, 0);\n+        let mut v = Vec::from_elem(100, 0i);\n \n         b.iter(|| {\n-            let mut i = 0;\n+            let mut i = 0i;\n             for x in v.mut_iter() {\n                 *x = i;\n                 i += 1;\n@@ -2153,15 +2153,17 @@ mod bench {\n \n     #[bench]\n     fn concat(b: &mut Bencher) {\n-        let xss: Vec<Vec<uint>> = Vec::from_fn(100, |i| range(0, i).collect());\n+        let xss: Vec<Vec<uint>> =\n+            Vec::from_fn(100, |i| range(0u, i).collect());\n         b.iter(|| {\n             xss.as_slice().concat_vec()\n         });\n     }\n \n     #[bench]\n     fn connect(b: &mut Bencher) {\n-        let xss: Vec<Vec<uint>> = Vec::from_fn(100, |i| range(0, i).collect());\n+        let xss: Vec<Vec<uint>> =\n+            Vec::from_fn(100, |i| range(0u, i).collect());\n         b.iter(|| {\n             xss.as_slice().connect_vec(&0)\n         });\n@@ -2288,7 +2290,7 @@ mod bench {\n         let mut rng = weak_rng();\n         b.iter(|| {\n                 let mut v = Vec::from_elem(30, (0u, 0u));\n-                for _ in range(0, 100) {\n+                for _ in range(0u, 100) {\n                     let l = v.len();\n                     v.insert(rng.gen::<uint>() % (l + 1),\n                              (1, 1));\n@@ -2300,7 +2302,7 @@ mod bench {\n         let mut rng = weak_rng();\n         b.iter(|| {\n                 let mut v = Vec::from_elem(130, (0u, 0u));\n-                for _ in range(0, 100) {\n+                for _ in range(0u, 100) {\n                     let l = v.len();\n                     v.remove(rng.gen::<uint>() % l);\n                 }"}, {"sha": "14e41f3fef96546a257d531eb429e91e3b46e37e", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -277,7 +277,7 @@ mod test_map {\n     #[test]\n     fn test_find_mut() {\n         let mut m = SmallIntMap::new();\n-        assert!(m.insert(1, 12));\n+        assert!(m.insert(1, 12i));\n         assert!(m.insert(2, 8));\n         assert!(m.insert(5, 14));\n         let new = 100;\n@@ -292,7 +292,7 @@ mod test_map {\n         let mut map = SmallIntMap::new();\n         assert_eq!(map.len(), 0);\n         assert!(map.is_empty());\n-        assert!(map.insert(5, 20));\n+        assert!(map.insert(5, 20i));\n         assert_eq!(map.len(), 1);\n         assert!(!map.is_empty());\n         assert!(map.insert(11, 12));\n@@ -306,7 +306,7 @@ mod test_map {\n     #[test]\n     fn test_clear() {\n         let mut map = SmallIntMap::new();\n-        assert!(map.insert(5, 20));\n+        assert!(map.insert(5, 20i));\n         assert!(map.insert(11, 12));\n         assert!(map.insert(14, 22));\n         map.clear();\n@@ -349,15 +349,15 @@ mod test_map {\n     #[test]\n     fn test_swap() {\n         let mut m = SmallIntMap::new();\n-        assert_eq!(m.swap(1, 2), None);\n-        assert_eq!(m.swap(1, 3), Some(2));\n-        assert_eq!(m.swap(1, 4), Some(3));\n+        assert_eq!(m.swap(1, 2i), None);\n+        assert_eq!(m.swap(1, 3i), Some(2));\n+        assert_eq!(m.swap(1, 4i), Some(3));\n     }\n \n     #[test]\n     fn test_pop() {\n         let mut m = SmallIntMap::new();\n-        m.insert(1, 2);\n+        m.insert(1, 2i);\n         assert_eq!(m.pop(&1), Some(2));\n         assert_eq!(m.pop(&1), None);\n     }\n@@ -366,7 +366,7 @@ mod test_map {\n     fn test_iterator() {\n         let mut m = SmallIntMap::new();\n \n-        assert!(m.insert(0, 1));\n+        assert!(m.insert(0, 1i));\n         assert!(m.insert(1, 2));\n         assert!(m.insert(3, 5));\n         assert!(m.insert(6, 10));\n@@ -391,7 +391,7 @@ mod test_map {\n     fn test_iterator_size_hints() {\n         let mut m = SmallIntMap::new();\n \n-        assert!(m.insert(0, 1));\n+        assert!(m.insert(0, 1i));\n         assert!(m.insert(1, 2));\n         assert!(m.insert(3, 5));\n         assert!(m.insert(6, 10));\n@@ -407,7 +407,7 @@ mod test_map {\n     fn test_mut_iterator() {\n         let mut m = SmallIntMap::new();\n \n-        assert!(m.insert(0, 1));\n+        assert!(m.insert(0, 1i));\n         assert!(m.insert(1, 2));\n         assert!(m.insert(3, 5));\n         assert!(m.insert(6, 10));\n@@ -430,7 +430,7 @@ mod test_map {\n     fn test_rev_iterator() {\n         let mut m = SmallIntMap::new();\n \n-        assert!(m.insert(0, 1));\n+        assert!(m.insert(0, 1i));\n         assert!(m.insert(1, 2));\n         assert!(m.insert(3, 5));\n         assert!(m.insert(6, 10));\n@@ -449,7 +449,7 @@ mod test_map {\n     fn test_mut_rev_iterator() {\n         let mut m = SmallIntMap::new();\n \n-        assert!(m.insert(0, 1));\n+        assert!(m.insert(0, 1i));\n         assert!(m.insert(1, 2));\n         assert!(m.insert(3, 5));\n         assert!(m.insert(6, 10));\n@@ -471,25 +471,25 @@ mod test_map {\n     #[test]\n     fn test_move_iter() {\n         let mut m = SmallIntMap::new();\n-        m.insert(1, box 2);\n+        m.insert(1, box 2i);\n         let mut called = false;\n         for (k, v) in m.move_iter() {\n             assert!(!called);\n             called = true;\n             assert_eq!(k, 1);\n-            assert_eq!(v, box 2);\n+            assert_eq!(v, box 2i);\n         }\n         assert!(called);\n-        m.insert(2, box 1);\n+        m.insert(2, box 1i);\n     }\n \n     #[test]\n     fn test_show() {\n         let mut map = SmallIntMap::new();\n         let empty = SmallIntMap::<int>::new();\n \n-        map.insert(1, 2);\n-        map.insert(3, 4);\n+        map.insert(1, 2i);\n+        map.insert(3, 4i);\n \n         let map_str = map.to_str();\n         let map_str = map_str.as_slice();"}, {"sha": "90f08bdd9dd8fdc723b0939a4ff63b2e63b14b8b", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -1030,16 +1030,16 @@ mod test_treemap {\n     #[test]\n     fn find_not_found() {\n         let mut m = TreeMap::new();\n-        assert!(m.insert(1, 2));\n-        assert!(m.insert(5, 3));\n-        assert!(m.insert(9, 3));\n+        assert!(m.insert(1i, 2i));\n+        assert!(m.insert(5i, 3i));\n+        assert!(m.insert(9i, 3i));\n         assert_eq!(m.find(&2), None);\n     }\n \n     #[test]\n     fn test_find_mut() {\n         let mut m = TreeMap::new();\n-        assert!(m.insert(1, 12));\n+        assert!(m.insert(1i, 12i));\n         assert!(m.insert(2, 8));\n         assert!(m.insert(5, 14));\n         let new = 100;\n@@ -1052,7 +1052,7 @@ mod test_treemap {\n     #[test]\n     fn insert_replace() {\n         let mut m = TreeMap::new();\n-        assert!(m.insert(5, 2));\n+        assert!(m.insert(5i, 2i));\n         assert!(m.insert(2, 9));\n         assert!(!m.insert(2, 11));\n         assert_eq!(m.find(&2).unwrap(), &11);\n@@ -1062,7 +1062,7 @@ mod test_treemap {\n     fn test_clear() {\n         let mut m = TreeMap::new();\n         m.clear();\n-        assert!(m.insert(5, 11));\n+        assert!(m.insert(5i, 11i));\n         assert!(m.insert(12, -3));\n         assert!(m.insert(19, 2));\n         m.clear();\n@@ -1159,8 +1159,8 @@ mod test_treemap {\n \n         let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(&[42]);\n \n-        for _ in range(0, 3) {\n-            for _ in range(0, 90) {\n+        for _ in range(0u, 3) {\n+            for _ in range(0u, 90) {\n                 let k = rng.gen();\n                 let v = rng.gen();\n                 if !ctrl.iter().any(|x| x == &(k, v)) {\n@@ -1171,7 +1171,7 @@ mod test_treemap {\n                 }\n             }\n \n-            for _ in range(0, 30) {\n+            for _ in range(0u, 30) {\n                 let r = rng.gen_range(0, ctrl.len());\n                 let (key, _) = ctrl.remove(r).unwrap();\n                 assert!(map.remove(&key));\n@@ -1184,7 +1184,7 @@ mod test_treemap {\n     #[test]\n     fn test_len() {\n         let mut m = TreeMap::new();\n-        assert!(m.insert(3, 6));\n+        assert!(m.insert(3i, 6i));\n         assert_eq!(m.len(), 1);\n         assert!(m.insert(0, 0));\n         assert_eq!(m.len(), 2);\n@@ -1204,7 +1204,7 @@ mod test_treemap {\n     fn test_iterator() {\n         let mut m = TreeMap::new();\n \n-        assert!(m.insert(3, 6));\n+        assert!(m.insert(3i, 6i));\n         assert!(m.insert(0, 0));\n         assert!(m.insert(4, 8));\n         assert!(m.insert(2, 4));\n@@ -1222,11 +1222,11 @@ mod test_treemap {\n     #[test]\n     fn test_interval_iteration() {\n         let mut m = TreeMap::new();\n-        for i in range(1, 100) {\n+        for i in range(1i, 100i) {\n             assert!(m.insert(i * 2, i * 4));\n         }\n \n-        for i in range(1, 198) {\n+        for i in range(1i, 198i) {\n             let mut lb_it = m.lower_bound(&i);\n             let (&k, &v) = lb_it.next().unwrap();\n             let lb = i + i % 2;\n@@ -1247,7 +1247,7 @@ mod test_treemap {\n     fn test_rev_iter() {\n         let mut m = TreeMap::new();\n \n-        assert!(m.insert(3, 6));\n+        assert!(m.insert(3i, 6i));\n         assert!(m.insert(0, 0));\n         assert!(m.insert(4, 8));\n         assert!(m.insert(2, 4));\n@@ -1296,19 +1296,19 @@ mod test_treemap {\n     fn test_mut_interval_iter() {\n         let mut m_lower = TreeMap::new();\n         let mut m_upper = TreeMap::new();\n-        for i in range(1, 100) {\n+        for i in range(1i, 100i) {\n             assert!(m_lower.insert(i * 2, i * 4));\n             assert!(m_upper.insert(i * 2, i * 4));\n         }\n \n-        for i in range(1, 199) {\n+        for i in range(1i, 199) {\n             let mut lb_it = m_lower.mut_lower_bound(&i);\n             let (&k, v) = lb_it.next().unwrap();\n             let lb = i + i % 2;\n             assert_eq!(lb, k);\n             *v -= k;\n         }\n-        for i in range(0, 198) {\n+        for i in range(0i, 198) {\n             let mut ub_it = m_upper.mut_upper_bound(&i);\n             let (&k, v) = ub_it.next().unwrap();\n             let ub = i + 2 - i % 2;\n@@ -1330,7 +1330,7 @@ mod test_treemap {\n         let mut b = TreeMap::new();\n \n         assert!(a == b);\n-        assert!(a.insert(0, 5));\n+        assert!(a.insert(0i, 5i));\n         assert!(a != b);\n         assert!(b.insert(0, 4));\n         assert!(a != b);\n@@ -1348,7 +1348,7 @@ mod test_treemap {\n         let mut b = TreeMap::new();\n \n         assert!(!(a < b) && !(b < a));\n-        assert!(b.insert(0, 5));\n+        assert!(b.insert(0i, 5i));\n         assert!(a < b);\n         assert!(a.insert(0, 7));\n         assert!(!(a < b) && b < a);\n@@ -1366,7 +1366,7 @@ mod test_treemap {\n         let mut b = TreeMap::new();\n \n         assert!(a <= b && a >= b);\n-        assert!(a.insert(1, 1));\n+        assert!(a.insert(1i, 1i));\n         assert!(a > b && a >= b);\n         assert!(b < a && b <= a);\n         assert!(b.insert(2, 2));\n@@ -1391,7 +1391,7 @@ mod test_treemap {\n     #[test]\n     fn test_lazy_iterator() {\n         let mut m = TreeMap::new();\n-        let (x1, y1) = (2, 5);\n+        let (x1, y1) = (2i, 5i);\n         let (x2, y2) = (9, 12);\n         let (x3, y3) = (20, -3);\n         let (x4, y4) = (29, 5);\n@@ -1437,7 +1437,7 @@ mod test_treemap {\n \n     #[test]\n     fn test_from_iter() {\n-        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+        let xs = [(1i, 1i), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n         let map: TreeMap<int, int> = xs.iter().map(|&x| x).collect();\n \n@@ -1519,7 +1519,7 @@ mod test_set {\n     fn test_clear() {\n         let mut s = TreeSet::new();\n         s.clear();\n-        assert!(s.insert(5));\n+        assert!(s.insert(5i));\n         assert!(s.insert(12));\n         assert!(s.insert(19));\n         s.clear();\n@@ -1535,8 +1535,8 @@ mod test_set {\n         let mut ys = TreeSet::new();\n         assert!(xs.is_disjoint(&ys));\n         assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(5));\n-        assert!(ys.insert(11));\n+        assert!(xs.insert(5i));\n+        assert!(ys.insert(11i));\n         assert!(xs.is_disjoint(&ys));\n         assert!(ys.is_disjoint(&xs));\n         assert!(xs.insert(7));\n@@ -1554,13 +1554,13 @@ mod test_set {\n     #[test]\n     fn test_subset_and_superset() {\n         let mut a = TreeSet::new();\n-        assert!(a.insert(0));\n+        assert!(a.insert(0i));\n         assert!(a.insert(5));\n         assert!(a.insert(11));\n         assert!(a.insert(7));\n \n         let mut b = TreeSet::new();\n-        assert!(b.insert(0));\n+        assert!(b.insert(0i));\n         assert!(b.insert(7));\n         assert!(b.insert(19));\n         assert!(b.insert(250));\n@@ -1584,7 +1584,7 @@ mod test_set {\n     fn test_iterator() {\n         let mut m = TreeSet::new();\n \n-        assert!(m.insert(3));\n+        assert!(m.insert(3i));\n         assert!(m.insert(0));\n         assert!(m.insert(4));\n         assert!(m.insert(2));\n@@ -1601,7 +1601,7 @@ mod test_set {\n     fn test_rev_iter() {\n         let mut m = TreeSet::new();\n \n-        assert!(m.insert(3));\n+        assert!(m.insert(3i));\n         assert!(m.insert(0));\n         assert!(m.insert(4));\n         assert!(m.insert(2));\n@@ -1616,7 +1616,7 @@ mod test_set {\n \n     #[test]\n     fn test_move_iter() {\n-        let s: TreeSet<int> = range(0, 5).collect();\n+        let s: TreeSet<int> = range(0i, 5).collect();\n \n         let mut n = 0;\n         for x in s.move_iter() {\n@@ -1627,7 +1627,7 @@ mod test_set {\n \n     #[test]\n     fn test_move_iter_size_hint() {\n-        let s: TreeSet<int> = vec!(0, 1).move_iter().collect();\n+        let s: TreeSet<int> = vec!(0i, 1).move_iter().collect();\n \n         let mut it = s.move_iter();\n \n@@ -1645,7 +1645,7 @@ mod test_set {\n     fn test_clone_eq() {\n       let mut m = TreeSet::new();\n \n-      m.insert(1);\n+      m.insert(1i);\n       m.insert(2);\n \n       assert!(m.clone() == m);\n@@ -1762,22 +1762,22 @@ mod test_set {\n     #[test]\n     fn test_swap() {\n         let mut m = TreeMap::new();\n-        assert_eq!(m.swap(1, 2), None);\n-        assert_eq!(m.swap(1, 3), Some(2));\n-        assert_eq!(m.swap(1, 4), Some(3));\n+        assert_eq!(m.swap(1u, 2i), None);\n+        assert_eq!(m.swap(1u, 3i), Some(2));\n+        assert_eq!(m.swap(1u, 4i), Some(3));\n     }\n \n     #[test]\n     fn test_pop() {\n         let mut m = TreeMap::new();\n-        m.insert(1, 2);\n+        m.insert(1u, 2i);\n         assert_eq!(m.pop(&1), Some(2));\n         assert_eq!(m.pop(&1), None);\n     }\n \n     #[test]\n     fn test_from_iter() {\n-        let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n+        let xs = [1i, 2, 3, 4, 5, 6, 7, 8, 9];\n \n         let set: TreeSet<int> = xs.iter().map(|&x| x).collect();\n "}, {"sha": "350c284e1d3b44977ae75a980bf50bb0677c345e", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -682,9 +682,9 @@ mod test_map {\n     #[test]\n     fn test_find_mut() {\n         let mut m = TrieMap::new();\n-        assert!(m.insert(1, 12));\n-        assert!(m.insert(2, 8));\n-        assert!(m.insert(5, 14));\n+        assert!(m.insert(1u, 12i));\n+        assert!(m.insert(2u, 8i));\n+        assert!(m.insert(5u, 14i));\n         let new = 100;\n         match m.find_mut(&5) {\n             None => fail!(), Some(x) => *x = new\n@@ -696,7 +696,7 @@ mod test_map {\n     fn test_find_mut_missing() {\n         let mut m = TrieMap::new();\n         assert!(m.find_mut(&0).is_none());\n-        assert!(m.insert(1, 12));\n+        assert!(m.insert(1u, 12i));\n         assert!(m.find_mut(&0).is_none());\n         assert!(m.insert(2, 8));\n         assert!(m.find_mut(&0).is_none());\n@@ -781,15 +781,15 @@ mod test_map {\n     #[test]\n     fn test_swap() {\n         let mut m = TrieMap::new();\n-        assert_eq!(m.swap(1, 2), None);\n-        assert_eq!(m.swap(1, 3), Some(2));\n-        assert_eq!(m.swap(1, 4), Some(3));\n+        assert_eq!(m.swap(1u, 2i), None);\n+        assert_eq!(m.swap(1u, 3i), Some(2));\n+        assert_eq!(m.swap(1u, 4i), Some(3));\n     }\n \n     #[test]\n     fn test_pop() {\n         let mut m = TrieMap::new();\n-        m.insert(1, 2);\n+        m.insert(1u, 2i);\n         assert_eq!(m.pop(&1), Some(2));\n         assert_eq!(m.pop(&1), None);\n     }\n@@ -943,7 +943,7 @@ mod bench_map {\n     fn bench_iter_small(b: &mut Bencher) {\n         let mut m = TrieMap::<uint>::new();\n         let mut rng = weak_rng();\n-        for _ in range(0, 20) {\n+        for _ in range(0u, 20) {\n             m.insert(rng.gen(), rng.gen());\n         }\n \n@@ -954,7 +954,7 @@ mod bench_map {\n     fn bench_iter_large(b: &mut Bencher) {\n         let mut m = TrieMap::<uint>::new();\n         let mut rng = weak_rng();\n-        for _ in range(0, 1000) {\n+        for _ in range(0u, 1000) {\n             m.insert(rng.gen(), rng.gen());\n         }\n \n@@ -965,12 +965,12 @@ mod bench_map {\n     fn bench_lower_bound(b: &mut Bencher) {\n         let mut m = TrieMap::<uint>::new();\n         let mut rng = weak_rng();\n-        for _ in range(0, 1000) {\n+        for _ in range(0u, 1000) {\n             m.insert(rng.gen(), rng.gen());\n         }\n \n         b.iter(|| {\n-                for _ in range(0, 10) {\n+                for _ in range(0u, 10) {\n                     m.lower_bound(rng.gen());\n                 }\n             });\n@@ -980,12 +980,12 @@ mod bench_map {\n     fn bench_upper_bound(b: &mut Bencher) {\n         let mut m = TrieMap::<uint>::new();\n         let mut rng = weak_rng();\n-        for _ in range(0, 1000) {\n+        for _ in range(0u, 1000) {\n             m.insert(rng.gen(), rng.gen());\n         }\n \n         b.iter(|| {\n-                for _ in range(0, 10) {\n+                for _ in range(0u, 10) {\n                     m.upper_bound(rng.gen());\n                 }\n             });\n@@ -997,7 +997,7 @@ mod bench_map {\n         let mut rng = weak_rng();\n \n         b.iter(|| {\n-                for _ in range(0, 1000) {\n+                for _ in range(0u, 1000) {\n                     m.insert(rng.gen(), [1, .. 10]);\n                 }\n             })\n@@ -1008,7 +1008,7 @@ mod bench_map {\n         let mut rng = weak_rng();\n \n         b.iter(|| {\n-                for _ in range(0, 1000) {\n+                for _ in range(0u, 1000) {\n                     // only have the last few bits set.\n                     m.insert(rng.gen::<uint>() & 0xff_ff, [1, .. 10]);\n                 }\n@@ -1021,7 +1021,7 @@ mod bench_map {\n         let mut rng = weak_rng();\n \n         b.iter(|| {\n-                for _ in range(0, 1000) {\n+                for _ in range(0u, 1000) {\n                     m.insert(rng.gen(), ());\n                 }\n             })\n@@ -1032,7 +1032,7 @@ mod bench_map {\n         let mut rng = weak_rng();\n \n         b.iter(|| {\n-                for _ in range(0, 1000) {\n+                for _ in range(0u, 1000) {\n                     // only have the last few bits set.\n                     m.insert(rng.gen::<uint>() & 0xff_ff, ());\n                 }"}, {"sha": "e3ed3ffbabf1033f839b61eca07fb51f4bd6d401", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -34,8 +34,8 @@ use slice::{Items, MutItems};\n /// ```rust\n /// # use std::vec::Vec;\n /// let mut vec = Vec::new();\n-/// vec.push(1);\n-/// vec.push(2);\n+/// vec.push(1i);\n+/// vec.push(2i);\n ///\n /// assert_eq!(vec.len(), 2);\n /// assert_eq!(vec.get(0), &1);\n@@ -47,7 +47,7 @@ use slice::{Items, MutItems};\n /// The `vec!` macro is provided to make initialization more convenient:\n ///\n /// ```rust\n-/// let mut vec = vec!(1, 2, 3);\n+/// let mut vec = vec!(1i, 2i, 3i);\n /// vec.push(4);\n /// assert_eq!(vec, vec!(1, 2, 3, 4));\n /// ```\n@@ -147,7 +147,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let vec = vec!(1, 2, 3, 4);\n+    /// let vec = vec!(1i, 2i, 3i, 4i);\n     /// let (even, odd) = vec.partition(|&n| n % 2 == 0);\n     /// assert_eq!(even, vec!(2, 4));\n     /// assert_eq!(odd, vec!(1, 3));\n@@ -176,8 +176,8 @@ impl<T: Clone> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let vec = vec!(1, 2);\n-    /// let vec = vec.append([3, 4]);\n+    /// let vec = vec!(1i, 2i);\n+    /// let vec = vec.append([3i, 4i]);\n     /// assert_eq!(vec, vec!(1, 2, 3, 4));\n     /// ```\n     #[inline]\n@@ -192,7 +192,7 @@ impl<T: Clone> Vec<T> {\n     ///\n     /// ```rust\n     /// # use std::vec::Vec;\n-    /// let slice = [1, 2, 3];\n+    /// let slice = [1i, 2, 3];\n     /// let vec = Vec::from_slice(slice);\n     /// ```\n     #[inline]\n@@ -232,8 +232,8 @@ impl<T: Clone> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1);\n-    /// vec.push_all([2, 3, 4]);\n+    /// let mut vec = vec!(1i);\n+    /// vec.push_all([2i, 3, 4]);\n     /// assert_eq!(vec, vec!(1, 2, 3, 4));\n     /// ```\n     #[inline]\n@@ -295,10 +295,10 @@ impl<T: Clone> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let vec = vec!(1, 2, 3, 4);\n+    /// let vec = vec!(1i, 2, 3, 4);\n     /// let (even, odd) = vec.partitioned(|&n| n % 2 == 0);\n-    /// assert_eq!(even, vec!(2, 4));\n-    /// assert_eq!(odd, vec!(1, 3));\n+    /// assert_eq!(even, vec!(2i, 4));\n+    /// assert_eq!(odd, vec!(1i, 3));\n     /// ```\n     pub fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n         let mut lefts = Vec::new();\n@@ -466,7 +466,7 @@ impl<T> Vec<T> {\n      ///\n      /// ```rust\n      /// # use std::vec::Vec;\n-     /// let mut vec: Vec<int> = vec!(1);\n+     /// let mut vec: Vec<int> = vec!(1i);\n      /// vec.reserve_additional(10);\n      /// assert!(vec.capacity() >= 11);\n      /// ```\n@@ -491,7 +491,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1, 2, 3);\n+    /// let mut vec = vec!(1i, 2, 3);\n     /// vec.reserve(10);\n     /// assert!(vec.capacity() >= 10);\n     /// ```\n@@ -533,7 +533,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1, 2, 3);\n+    /// let mut vec = vec!(1i, 2, 3);\n     /// vec.shrink_to_fit();\n     /// ```\n     pub fn shrink_to_fit(&mut self) {\n@@ -565,7 +565,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1, 2, 3);\n+    /// let mut vec = vec!(1i, 2, 3);\n     /// assert_eq!(vec.pop(), Some(3));\n     /// assert_eq!(vec, vec!(1, 2));\n     /// ```\n@@ -590,7 +590,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1, 2);\n+    /// let mut vec = vec!(1i, 2);\n     /// vec.push(3);\n     /// assert_eq!(vec, vec!(1, 2, 3));\n     /// ```\n@@ -626,7 +626,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let vec = vec!(1, 2);\n+    /// let vec = vec!(1i, 2);\n     /// let vec = vec.append_one(3);\n     /// assert_eq!(vec, vec!(1, 2, 3));\n     /// ```\n@@ -644,7 +644,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1, 2, 3, 4);\n+    /// let mut vec = vec!(1i, 2, 3, 4);\n     /// vec.truncate(2);\n     /// assert_eq!(vec, vec!(1, 2));\n     /// ```\n@@ -667,7 +667,7 @@ impl<T> Vec<T> {\n     /// ```rust\n     /// fn foo(slice: &mut [int]) {}\n     ///\n-    /// let mut vec = vec!(1, 2);\n+    /// let mut vec = vec!(1i, 2);\n     /// foo(vec.as_mut_slice());\n     /// ```\n     #[inline]\n@@ -721,7 +721,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let vec = vec!(1, 2, 3);\n+    /// let vec = vec!(1i, 2, 3);\n     /// assert!(vec.get(1) == &2);\n     /// ```\n     #[inline]\n@@ -738,9 +738,9 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1, 2, 3);\n+    /// let mut vec = vec!(1i, 2, 3);\n     /// *vec.get_mut(1) = 4;\n-    /// assert_eq!(vec, vec!(1, 4, 3));\n+    /// assert_eq!(vec, vec!(1i, 4, 3));\n     /// ```\n     #[inline]\n     pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n@@ -753,7 +753,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let vec = vec!(1, 2, 3);\n+    /// let vec = vec!(1i, 2, 3);\n     /// for num in vec.iter() {\n     ///     println!(\"{}\", *num);\n     /// }\n@@ -770,7 +770,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1, 2, 3);\n+    /// let mut vec = vec!(1i, 2, 3);\n     /// for num in vec.mut_iter() {\n     ///     *num = 0;\n     /// }\n@@ -790,11 +790,11 @@ impl<T> Vec<T> {\n     /// ```rust\n     /// let mut v = vec!(5i, 4, 1, 3, 2);\n     /// v.sort_by(|a, b| a.cmp(b));\n-    /// assert_eq!(v, vec!(1, 2, 3, 4, 5));\n+    /// assert_eq!(v, vec!(1i, 2, 3, 4, 5));\n     ///\n     /// // reverse sorting\n     /// v.sort_by(|a, b| b.cmp(a));\n-    /// assert_eq!(v, vec!(5, 4, 3, 2, 1));\n+    /// assert_eq!(v, vec!(5i, 4, 3, 2, 1));\n     /// ```\n     #[inline]\n     pub fn sort_by(&mut self, compare: |&T, &T| -> Ordering) {\n@@ -811,7 +811,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let vec = vec!(1, 2, 3, 4);\n+    /// let vec = vec!(1i, 2, 3, 4);\n     /// assert!(vec.slice(0, 2) == [1, 2]);\n     /// ```\n     #[inline]\n@@ -828,7 +828,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let vec = vec!(1, 2, 3);\n+    /// let vec = vec!(1i, 2, 3);\n     /// assert!(vec.tail() == [2, 3]);\n     /// ```\n     #[inline]\n@@ -845,7 +845,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let vec = vec!(1, 2, 3, 4);\n+    /// let vec = vec!(1i, 2, 3, 4);\n     /// assert!(vec.tailn(2) == [3, 4]);\n     /// ```\n     #[inline]\n@@ -859,7 +859,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let vec = vec!(1, 2, 3);\n+    /// let vec = vec!(1i, 2, 3);\n     /// assert!(vec.last() == Some(&3));\n     /// ```\n     #[inline]\n@@ -873,9 +873,9 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1, 2, 3);\n+    /// let mut vec = vec!(1i, 2, 3);\n     /// *vec.mut_last().unwrap() = 4;\n-    /// assert_eq!(vec, vec!(1, 2, 4));\n+    /// assert_eq!(vec, vec!(1i, 2, 4));\n     /// ```\n     #[inline]\n     pub fn mut_last<'a>(&'a mut self) -> Option<&'a mut T> {\n@@ -921,7 +921,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1, 2, 3);\n+    /// let mut vec = vec!(1i, 2, 3);\n     /// vec.unshift(4);\n     /// assert_eq!(vec, vec!(4, 1, 2, 3));\n     /// ```\n@@ -941,7 +941,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1, 2, 3);\n+    /// let mut vec = vec!(1i, 2, 3);\n     /// assert!(vec.shift() == Some(1));\n     /// assert_eq!(vec, vec!(2, 3));\n     /// ```\n@@ -960,7 +960,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1, 2, 3);\n+    /// let mut vec = vec!(1i, 2, 3);\n     /// vec.insert(1, 4);\n     /// assert_eq!(vec, vec!(1, 4, 2, 3));\n     /// ```\n@@ -992,7 +992,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = vec!(1, 2, 3);\n+    /// let mut v = vec!(1i, 2, 3);\n     /// assert_eq!(v.remove(1), Some(2));\n     /// assert_eq!(v, vec!(1, 3));\n     ///\n@@ -1031,7 +1031,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(box 1);\n+    /// let mut vec = vec!(box 1i);\n     /// vec.push_all_move(vec!(box 2, box 3, box 4));\n     /// assert_eq!(vec, vec!(box 1, box 2, box 3, box 4));\n     /// ```\n@@ -1050,7 +1050,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1, 2, 3, 4);\n+    /// let mut vec = vec!(1i, 2, 3, 4);\n     /// assert!(vec.mut_slice(0, 2) == [1, 2]);\n     /// ```\n     #[inline]\n@@ -1068,7 +1068,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1, 2, 3, 4);\n+    /// let mut vec = vec!(1i, 2, 3, 4);\n     /// assert!(vec.mut_slice_from(2) == [3, 4]);\n     /// ```\n     #[inline]\n@@ -1085,7 +1085,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1, 2, 3, 4);\n+    /// let mut vec = vec!(1i, 2, 3, 4);\n     /// assert!(vec.mut_slice_to(2) == [1, 2]);\n     /// ```\n     #[inline]\n@@ -1106,7 +1106,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1, 2, 3, 4, 5, 6);\n+    /// let mut vec = vec!(1i, 2, 3, 4, 5, 6);\n     ///\n     /// // scoped to restrict the lifetime of the borrows\n     /// {\n@@ -1137,9 +1137,9 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = vec!(1, 2, 3);\n+    /// let mut v = vec!(1i, 2, 3);\n     /// v.reverse();\n-    /// assert_eq!(v, vec!(3, 2, 1));\n+    /// assert_eq!(v, vec!(3i, 2, 1));\n     /// ```\n     #[inline]\n     pub fn reverse(&mut self) {\n@@ -1155,7 +1155,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let vec = vec!(1, 2, 3);\n+    /// let vec = vec!(1i, 2, 3);\n     /// assert!(vec.slice_from(1) == [2, 3]);\n     /// ```\n     #[inline]\n@@ -1172,7 +1172,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let vec = vec!(1, 2, 3);\n+    /// let vec = vec!(1i, 2, 3);\n     /// assert!(vec.slice_to(2) == [1, 2]);\n     /// ```\n     #[inline]\n@@ -1310,7 +1310,7 @@ impl<T:PartialEq> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let vec = vec!(1, 2, 3);\n+    /// let vec = vec!(1i, 2, 3);\n     /// assert!(vec.contains(&1));\n     /// ```\n     #[inline]\n@@ -1325,9 +1325,9 @@ impl<T:PartialEq> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1, 2, 2, 3, 2);\n+    /// let mut vec = vec!(1i, 2, 2, 3, 2);\n     /// vec.dedup();\n-    /// assert_eq!(vec, vec!(1, 2, 3, 2));\n+    /// assert_eq!(vec, vec!(1i, 2, 3, 2));\n     /// ```\n     pub fn dedup(&mut self) {\n         unsafe {\n@@ -1422,7 +1422,7 @@ impl<T> Vector<T> for Vec<T> {\n     /// ```rust\n     /// fn foo(slice: &[int]) {}\n     ///\n-    /// let vec = vec!(1, 2);\n+    /// let vec = vec!(1i, 2);\n     /// foo(vec.as_slice());\n     /// ```\n     #[inline]\n@@ -1611,7 +1611,7 @@ mod tests {\n         v.reserve_additional(2);\n         assert!(v.capacity() >= 2);\n \n-        for i in range(0, 16) {\n+        for i in range(0i, 16) {\n             v.push(i);\n         }\n \n@@ -1630,13 +1630,13 @@ mod tests {\n         let mut v = Vec::new();\n         let mut w = Vec::new();\n \n-        v.extend(range(0, 3));\n-        for i in range(0, 3) { w.push(i) }\n+        v.extend(range(0i, 3));\n+        for i in range(0i, 3) { w.push(i) }\n \n         assert_eq!(v, w);\n \n-        v.extend(range(3, 10));\n-        for i in range(3, 10) { w.push(i) }\n+        v.extend(range(3i, 10));\n+        for i in range(3i, 10) { w.push(i) }\n \n         assert_eq!(v, w);\n     }\n@@ -1691,7 +1691,7 @@ mod tests {\n     #[test]\n     fn test_clone() {\n         let v: Vec<int> = vec!();\n-        let w = vec!(1, 2, 3);\n+        let w = vec!(1i, 2, 3);\n \n         assert_eq!(v, v.clone());\n \n@@ -1704,8 +1704,8 @@ mod tests {\n     #[test]\n     fn test_clone_from() {\n         let mut v = vec!();\n-        let three = vec!(box 1, box 2, box 3);\n-        let two = vec!(box 4, box 5);\n+        let three = vec!(box 1i, box 2, box 3);\n+        let two = vec!(box 4i, box 5);\n         // zero, long\n         v.clone_from(&three);\n         assert_eq!(v, three);\n@@ -1771,22 +1771,22 @@ mod tests {\n     #[test]\n     fn test_partition() {\n         assert_eq!(vec![].partition(|x: &int| *x < 3), (vec![], vec![]));\n-        assert_eq!(vec![1, 2, 3].partition(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n-        assert_eq!(vec![1, 2, 3].partition(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n-        assert_eq!(vec![1, 2, 3].partition(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n+        assert_eq!(vec![1i, 2, 3].partition(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n+        assert_eq!(vec![1i, 2, 3].partition(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n+        assert_eq!(vec![1i, 2, 3].partition(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n     }\n \n     #[test]\n     fn test_partitioned() {\n         assert_eq!(vec![].partitioned(|x: &int| *x < 3), (vec![], vec![]))\n-        assert_eq!(vec![1, 2, 3].partitioned(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n-        assert_eq!(vec![1, 2, 3].partitioned(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n-        assert_eq!(vec![1, 2, 3].partitioned(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n+        assert_eq!(vec![1i, 2, 3].partitioned(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n+        assert_eq!(vec![1i, 2, 3].partitioned(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n+        assert_eq!(vec![1i, 2, 3].partitioned(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n     }\n \n     #[test]\n     fn test_zip_unzip() {\n-        let z1 = vec![(1, 4), (2, 5), (3, 6)];\n+        let z1 = vec![(1i, 4i), (2, 5), (3, 6)];\n \n         let (left, right) = unzip(z1.iter().map(|&x| x));\n \n@@ -1800,13 +1800,13 @@ mod tests {\n     fn test_unsafe_ptrs() {\n         unsafe {\n             // Test on-stack copy-from-buf.\n-            let a = [1, 2, 3];\n+            let a = [1i, 2, 3];\n             let ptr = a.as_ptr();\n             let b = raw::from_buf(ptr, 3u);\n             assert_eq!(b, vec![1, 2, 3]);\n \n             // Test on-heap copy-from-buf.\n-            let c = vec![1, 2, 3, 4, 5];\n+            let c = vec![1i, 2, 3, 4, 5];\n             let ptr = c.as_ptr();\n             let d = raw::from_buf(ptr, 5u);\n             assert_eq!(d, vec![1, 2, 3, 4, 5]);\n@@ -1912,7 +1912,7 @@ mod tests {\n     #[bench]\n     fn bench_from_slice_5(b: &mut Bencher) {\n         b.iter(|| {\n-            let v: Vec<int> = Vec::from_slice([1, 2, 3, 4, 5]);\n+            let v: Vec<int> = Vec::from_slice([1i, 2, 3, 4, 5]);\n             assert!(v.as_slice() == [1, 2, 3, 4, 5]);\n         })\n     }"}, {"sha": "0b621863e2cca7526d5f102a1121ce83b499f69c", "filename": "src/libcore/any.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -284,7 +284,8 @@ mod bench {\n     #[bench]\n     fn bench_as_ref(b: &mut Bencher) {\n         b.iter(|| {\n-            let mut x = 0; let mut y = &mut x as &mut Any;\n+            let mut x = 0i;\n+            let mut y = &mut x as &mut Any;\n             test::black_box(&mut y);\n             test::black_box(y.as_ref::<int>() == Some(&0));\n         });"}, {"sha": "fd694c04f559c6717573d53adf54ba4d6b60ede5", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -389,14 +389,14 @@ mod test {\n \n     #[test]\n     fn smoketest_cell() {\n-        let x = Cell::new(10);\n+        let x = Cell::new(10i);\n         assert!(x == Cell::new(10));\n         assert!(x.get() == 10);\n         x.set(20);\n         assert!(x == Cell::new(20));\n         assert!(x.get() == 20);\n \n-        let y = Cell::new((30, 40));\n+        let y = Cell::new((30i, 40i));\n         assert!(y == Cell::new((30, 40)));\n         assert!(y.get() == (30, 40));\n     }"}, {"sha": "c188ec75ddd09c3f9bc07b6bc9b341ee1f9657c3", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -308,6 +308,7 @@ pub fn escape_unicode(c: char, f: |char|) {\n         _                   => { f('U'); 8 }\n     };\n     for offset in range_step::<i32>(4 * (pad - 1), -1, -4) {\n+        let offset = offset as uint;\n         unsafe {\n             match ((c as i32) >> offset) & 0xf {\n                 i @ 0 .. 9 => { f(transmute('0' as i32 + i)); }"}, {"sha": "4fb887bad940c5c6948c7c7a4c3a9756d05bdada", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -146,8 +146,8 @@ mod test {\n \n     #[test]\n     fn test_clone_from() {\n-        let a = box 5;\n-        let mut b = box 10;\n+        let a = box 5i;\n+        let mut b = box 10i;\n         realclone_from(&mut b, &a);\n         assert_eq!(*b, 5);\n     }"}, {"sha": "ab151460537af4f8edf141457f426925fffaa43e", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -122,7 +122,7 @@ mod test {\n \n     #[test]\n     fn test_success() {\n-        let mut i = 0;\n+        let mut i = 0i;\n         try_finally(\n             &mut i, (),\n             |i, ()| {\n@@ -139,7 +139,7 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_fail() {\n-        let mut i = 0;\n+        let mut i = 0i;\n         try_finally(\n             &mut i, (),\n             |i, ()| {"}, {"sha": "56d0817dd00befee541f79fb1a2cb3b7c0164e7d", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -140,7 +140,7 @@ pub struct RadixFmt<T, R>(T, R);\n ///\n /// ~~~\n /// use std::fmt::radix;\n-/// assert_eq!(format!(\"{}\", radix(55, 36)), \"1j\".to_string());\n+/// assert_eq!(format!(\"{}\", radix(55i, 36)), \"1j\".to_string());\n /// ~~~\n pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n     RadixFmt(x, Radix::new(base))\n@@ -309,11 +309,11 @@ mod tests {\n         assert!(format!(\"{:o}\", 1u64).as_slice() == \"1\");\n \n         // Test a larger number\n-        assert!(format!(\"{:t}\", 55).as_slice() == \"110111\");\n-        assert!(format!(\"{:o}\", 55).as_slice() == \"67\");\n-        assert!(format!(\"{:d}\", 55).as_slice() == \"55\");\n-        assert!(format!(\"{:x}\", 55).as_slice() == \"37\");\n-        assert!(format!(\"{:X}\", 55).as_slice() == \"37\");\n+        assert!(format!(\"{:t}\", 55i).as_slice() == \"110111\");\n+        assert!(format!(\"{:o}\", 55i).as_slice() == \"67\");\n+        assert!(format!(\"{:d}\", 55i).as_slice() == \"55\");\n+        assert!(format!(\"{:x}\", 55i).as_slice() == \"37\");\n+        assert!(format!(\"{:X}\", 55i).as_slice() == \"37\");\n     }\n \n     #[test]\n@@ -335,21 +335,21 @@ mod tests {\n \n     #[test]\n     fn test_format_int_flags() {\n-        assert!(format!(\"{:3d}\", 1).as_slice() == \"  1\");\n-        assert!(format!(\"{:>3d}\", 1).as_slice() == \"  1\");\n-        assert!(format!(\"{:>+3d}\", 1).as_slice() == \" +1\");\n-        assert!(format!(\"{:<3d}\", 1).as_slice() == \"1  \");\n-        assert!(format!(\"{:#d}\", 1).as_slice() == \"1\");\n-        assert!(format!(\"{:#x}\", 10).as_slice() == \"0xa\");\n-        assert!(format!(\"{:#X}\", 10).as_slice() == \"0xA\");\n-        assert!(format!(\"{:#5x}\", 10).as_slice() == \"  0xa\");\n-        assert!(format!(\"{:#o}\", 10).as_slice() == \"0o12\");\n-        assert!(format!(\"{:08x}\", 10).as_slice() == \"0000000a\");\n-        assert!(format!(\"{:8x}\", 10).as_slice() == \"       a\");\n-        assert!(format!(\"{:<8x}\", 10).as_slice() == \"a       \");\n-        assert!(format!(\"{:>8x}\", 10).as_slice() == \"       a\");\n-        assert!(format!(\"{:#08x}\", 10).as_slice() == \"0x00000a\");\n-        assert!(format!(\"{:08d}\", -10).as_slice() == \"-0000010\");\n+        assert!(format!(\"{:3d}\", 1i).as_slice() == \"  1\");\n+        assert!(format!(\"{:>3d}\", 1i).as_slice() == \"  1\");\n+        assert!(format!(\"{:>+3d}\", 1i).as_slice() == \" +1\");\n+        assert!(format!(\"{:<3d}\", 1i).as_slice() == \"1  \");\n+        assert!(format!(\"{:#d}\", 1i).as_slice() == \"1\");\n+        assert!(format!(\"{:#x}\", 10i).as_slice() == \"0xa\");\n+        assert!(format!(\"{:#X}\", 10i).as_slice() == \"0xA\");\n+        assert!(format!(\"{:#5x}\", 10i).as_slice() == \"  0xa\");\n+        assert!(format!(\"{:#o}\", 10i).as_slice() == \"0o12\");\n+        assert!(format!(\"{:08x}\", 10i).as_slice() == \"0000000a\");\n+        assert!(format!(\"{:8x}\", 10i).as_slice() == \"       a\");\n+        assert!(format!(\"{:<8x}\", 10i).as_slice() == \"a       \");\n+        assert!(format!(\"{:>8x}\", 10i).as_slice() == \"       a\");\n+        assert!(format!(\"{:#08x}\", 10i).as_slice() == \"0x00000a\");\n+        assert!(format!(\"{:08d}\", -10i).as_slice() == \"-0000010\");\n         assert!(format!(\"{:x}\", -1u8).as_slice() == \"ff\");\n         assert!(format!(\"{:X}\", -1u8).as_slice() == \"FF\");\n         assert!(format!(\"{:t}\", -1u8).as_slice() == \"11111111\");\n@@ -362,12 +362,12 @@ mod tests {\n \n     #[test]\n     fn test_format_int_sign_padding() {\n-        assert!(format!(\"{:+5d}\", 1).as_slice() == \"   +1\");\n-        assert!(format!(\"{:+5d}\", -1).as_slice() == \"   -1\");\n-        assert!(format!(\"{:05d}\", 1).as_slice() == \"00001\");\n-        assert!(format!(\"{:05d}\", -1).as_slice() == \"-0001\");\n-        assert!(format!(\"{:+05d}\", 1).as_slice() == \"+0001\");\n-        assert!(format!(\"{:+05d}\", -1).as_slice() == \"-0001\");\n+        assert!(format!(\"{:+5d}\", 1i).as_slice() == \"   +1\");\n+        assert!(format!(\"{:+5d}\", -1i).as_slice() == \"   -1\");\n+        assert!(format!(\"{:05d}\", 1i).as_slice() == \"00001\");\n+        assert!(format!(\"{:05d}\", -1i).as_slice() == \"-0001\");\n+        assert!(format!(\"{:+05d}\", 1i).as_slice() == \"+0001\");\n+        assert!(format!(\"{:+05d}\", -1i).as_slice() == \"-0001\");\n     }\n \n     #[test]\n@@ -381,8 +381,8 @@ mod tests {\n \n     #[test]\n     fn test_format_radix() {\n-        assert!(format!(\"{:04}\", radix(3, 2)).as_slice() == \"0011\");\n-        assert!(format!(\"{}\", radix(55, 36)).as_slice() == \"1j\");\n+        assert!(format!(\"{:04}\", radix(3i, 2)).as_slice() == \"0011\");\n+        assert!(format!(\"{}\", radix(55i, 36)).as_slice() == \"1j\");\n     }\n \n     #[test]"}, {"sha": "3f4d3020815df90fbe97dce35097c576f02f35b0", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 100, "deletions": 100, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -35,7 +35,7 @@ into a `loop`, for example, the `for` loop in this example is essentially\n translated to the `loop` below.\n \n ```rust\n-let values = vec![1, 2, 3];\n+let values = vec![1i, 2, 3];\n \n // \"Syntactical sugar\" taking advantage of an iterator\n for &x in values.iter() {\n@@ -112,8 +112,8 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [0];\n-    /// let b = [1];\n+    /// let a = [0i];\n+    /// let b = [1i];\n     /// let mut it = a.iter().chain(b.iter());\n     /// assert_eq!(it.next().unwrap(), &0);\n     /// assert_eq!(it.next().unwrap(), &1);\n@@ -132,8 +132,8 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [0];\n-    /// let b = [1];\n+    /// let a = [0i];\n+    /// let b = [1i];\n     /// let mut it = a.iter().zip(b.iter());\n     /// assert_eq!(it.next().unwrap(), (&0, &1));\n     /// assert!(it.next().is_none());\n@@ -149,7 +149,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1, 2];\n+    /// let a = [1i, 2];\n     /// let mut it = a.iter().map(|&x| 2 * x);\n     /// assert_eq!(it.next().unwrap(), 2);\n     /// assert_eq!(it.next().unwrap(), 4);\n@@ -167,7 +167,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1, 2];\n+    /// let a = [1i, 2];\n     /// let mut it = a.iter().filter(|&x| *x > 1);\n     /// assert_eq!(it.next().unwrap(), &2);\n     /// assert!(it.next().is_none());\n@@ -184,7 +184,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1, 2];\n+    /// let a = [1i, 2];\n     /// let mut it = a.iter().filter_map(|&x| if x > 1 {Some(2 * x)} else {None});\n     /// assert_eq!(it.next().unwrap(), 4);\n     /// assert!(it.next().is_none());\n@@ -200,7 +200,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [100, 200];\n+    /// let a = [100i, 200];\n     /// let mut it = a.iter().enumerate();\n     /// assert_eq!(it.next().unwrap(), (0, &100));\n     /// assert_eq!(it.next().unwrap(), (1, &200));\n@@ -218,7 +218,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let xs = [100, 200, 300];\n+    /// let xs = [100i, 200, 300];\n     /// let mut it = xs.iter().map(|x| *x).peekable();\n     /// assert_eq!(it.peek().unwrap(), &100);\n     /// assert_eq!(it.next().unwrap(), 100);\n@@ -241,7 +241,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1, 2, 3, 2, 1];\n+    /// let a = [1i, 2, 3, 2, 1];\n     /// let mut it = a.iter().skip_while(|&a| *a < 3);\n     /// assert_eq!(it.next().unwrap(), &3);\n     /// assert_eq!(it.next().unwrap(), &2);\n@@ -260,7 +260,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1, 2, 3, 2, 1];\n+    /// let a = [1i, 2, 3, 2, 1];\n     /// let mut it = a.iter().take_while(|&a| *a < 3);\n     /// assert_eq!(it.next().unwrap(), &1);\n     /// assert_eq!(it.next().unwrap(), &2);\n@@ -277,7 +277,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1, 2, 3, 4, 5];\n+    /// let a = [1i, 2, 3, 4, 5];\n     /// let mut it = a.iter().skip(3);\n     /// assert_eq!(it.next().unwrap(), &4);\n     /// assert_eq!(it.next().unwrap(), &5);\n@@ -294,7 +294,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1, 2, 3, 4, 5];\n+    /// let a = [1i, 2, 3, 4, 5];\n     /// let mut it = a.iter().take(3);\n     /// assert_eq!(it.next().unwrap(), &1);\n     /// assert_eq!(it.next().unwrap(), &2);\n@@ -314,7 +314,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1, 2, 3, 4, 5];\n+    /// let a = [1i, 2, 3, 4, 5];\n     /// let mut it = a.iter().scan(1, |fac, &x| {\n     ///   *fac = *fac * x;\n     ///   Some(*fac)\n@@ -378,7 +378,7 @@ pub trait Iterator<A> {\n     ///     }\n     ///     sum\n     /// }\n-    /// let x = vec![1,2,3,7,8,9];\n+    /// let x = vec![1i,2,3,7,8,9];\n     /// assert_eq!(process(x.move_iter()), 1006);\n     /// ```\n     #[inline]\n@@ -417,7 +417,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut xs = range(0, 10);\n+    /// let mut xs = range(0u, 10);\n     /// // sum the first five values\n     /// let partial_sum = xs.by_ref().take(5).fold(0, |a, b| a + b);\n     /// assert!(partial_sum == 10);\n@@ -434,7 +434,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// range(0, 5).advance(|x| {print!(\"{} \", x); true});\n+    /// range(0u, 5).advance(|x| {print!(\"{} \", x); true});\n     /// ```\n     #[inline]\n     fn advance(&mut self, f: |A| -> bool) -> bool {\n@@ -454,7 +454,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1, 2, 3, 4, 5];\n+    /// let a = [1i, 2, 3, 4, 5];\n     /// let b: Vec<int> = a.iter().map(|&x| x).collect();\n     /// assert!(a.as_slice() == b.as_slice());\n     /// ```\n@@ -469,7 +469,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1, 2, 3, 4, 5];\n+    /// let a = [1i, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert!(it.nth(2).unwrap() == &3);\n     /// assert!(it.nth(2) == None);\n@@ -491,7 +491,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1, 2, 3, 4, 5];\n+    /// let a = [1i, 2, 3, 4, 5];\n     /// assert!(a.iter().last().unwrap() == &5);\n     /// ```\n     #[inline]\n@@ -507,7 +507,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1, 2, 3, 4, 5];\n+    /// let a = [1i, 2, 3, 4, 5];\n     /// assert!(a.iter().fold(0, |a, &b| a + b) == 15);\n     /// ```\n     #[inline]\n@@ -527,7 +527,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1, 2, 3, 4, 5];\n+    /// let a = [1i, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert!(it.count() == 5);\n     /// assert!(it.count() == 0);\n@@ -542,7 +542,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1, 2, 3, 4, 5];\n+    /// let a = [1i, 2, 3, 4, 5];\n     /// assert!(a.iter().all(|x| *x > 0));\n     /// assert!(!a.iter().all(|x| *x > 2));\n     /// ```\n@@ -558,7 +558,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1, 2, 3, 4, 5];\n+    /// let a = [1i, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert!(it.any(|x| *x == 3));\n     /// assert!(!it.any(|x| *x == 3));\n@@ -801,7 +801,7 @@ pub trait AdditiveIterator<A> {\n     /// ```rust\n     /// use std::iter::AdditiveIterator;\n     ///\n-    /// let a = [1, 2, 3, 4, 5];\n+    /// let a = [1i, 2, 3, 4, 5];\n     /// let mut it = a.iter().map(|&x| x);\n     /// assert!(it.sum() == 15);\n     /// ```\n@@ -852,7 +852,7 @@ pub trait OrdIterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1, 2, 3, 4, 5];\n+    /// let a = [1i, 2, 3, 4, 5];\n     /// assert!(a.iter().max().unwrap() == &5);\n     /// ```\n     fn max(&mut self) -> Option<A>;\n@@ -862,7 +862,7 @@ pub trait OrdIterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1, 2, 3, 4, 5];\n+    /// let a = [1i, 2, 3, 4, 5];\n     /// assert!(a.iter().min().unwrap() == &1);\n     /// ```\n     fn min(&mut self) -> Option<A>;\n@@ -995,10 +995,10 @@ impl<T: Clone> MinMaxResult<T> {\n     /// let r: MinMaxResult<int> = NoElements;\n     /// assert_eq!(r.into_option(), None)\n     ///\n-    /// let r = OneElement(1);\n+    /// let r = OneElement(1i);\n     /// assert_eq!(r.into_option(), Some((1,1)));\n     ///\n-    /// let r = MinMax(1,2);\n+    /// let r = MinMax(1i,2i);\n     /// assert_eq!(r.into_option(), Some((1,2)));\n     /// ```\n     pub fn into_option(self) -> Option<(T,T)> {\n@@ -1019,7 +1019,7 @@ pub trait CloneableIterator {\n     /// ```rust\n     /// use std::iter::{CloneableIterator, count};\n     ///\n-    /// let a = count(1,1).take(1);\n+    /// let a = count(1i,1i).take(1);\n     /// let mut cy = a.cycle();\n     /// assert_eq!(cy.next(), Some(1));\n     /// assert_eq!(cy.next(), Some(1));\n@@ -2285,8 +2285,8 @@ pub mod order {\n         use slice::ImmutableVector;\n \n         let empty: [int, ..0] = [];\n-        let xs = [1,2,3];\n-        let ys = [1,2,0];\n+        let xs = [1i,2,3];\n+        let ys = [1i,2,0];\n \n         assert!(!lt(xs.iter(), ys.iter()));\n         assert!(!le(xs.iter(), ys.iter()));\n@@ -2304,17 +2304,17 @@ pub mod order {\n         assert!(!ge(empty.iter(), xs.iter()));\n \n         // Sequence with NaN\n-        let u = [1.0, 2.0];\n-        let v = [0.0/0.0, 3.0];\n+        let u = [1.0f64, 2.0];\n+        let v = [0.0f64/0.0, 3.0];\n \n         assert!(!lt(u.iter(), v.iter()));\n         assert!(!le(u.iter(), v.iter()));\n         assert!(!gt(u.iter(), v.iter()));\n         assert!(!ge(u.iter(), v.iter()));\n \n-        let a = [0.0/0.0];\n-        let b = [1.0];\n-        let c = [2.0];\n+        let a = [0.0f64/0.0];\n+        let b = [1.0f64];\n+        let c = [2.0f64];\n \n         assert!(lt(a.iter(), b.iter()) == (a[0] <  b[0]));\n         assert!(le(a.iter(), b.iter()) == (a[0] <= b[0]));\n@@ -2380,7 +2380,7 @@ mod tests {\n \n     #[test]\n     fn test_counter_from_iter() {\n-        let it = count(0, 5).take(10);\n+        let it = count(0i, 5).take(10);\n         let xs: Vec<int> = FromIterator::from_iter(it);\n         assert!(xs == vec![0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n     }\n@@ -2577,64 +2577,64 @@ mod tests {\n \n     #[test]\n     fn test_iterator_nth() {\n-        let v = &[0, 1, 2, 3, 4];\n+        let v = &[0i, 1, 2, 3, 4];\n         for i in range(0u, v.len()) {\n             assert_eq!(v.iter().nth(i).unwrap(), &v[i]);\n         }\n     }\n \n     #[test]\n     fn test_iterator_last() {\n-        let v = &[0, 1, 2, 3, 4];\n+        let v = &[0i, 1, 2, 3, 4];\n         assert_eq!(v.iter().last().unwrap(), &4);\n         assert_eq!(v.slice(0, 1).iter().last().unwrap(), &0);\n     }\n \n     #[test]\n     fn test_iterator_len() {\n-        let v = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+        let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         assert_eq!(v.slice(0, 4).iter().count(), 4);\n         assert_eq!(v.slice(0, 10).iter().count(), 10);\n         assert_eq!(v.slice(0, 0).iter().count(), 0);\n     }\n \n     #[test]\n     fn test_iterator_sum() {\n-        let v = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+        let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         assert_eq!(v.slice(0, 4).iter().map(|&x| x).sum(), 6);\n         assert_eq!(v.iter().map(|&x| x).sum(), 55);\n         assert_eq!(v.slice(0, 0).iter().map(|&x| x).sum(), 0);\n     }\n \n     #[test]\n     fn test_iterator_product() {\n-        let v = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+        let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         assert_eq!(v.slice(0, 4).iter().map(|&x| x).product(), 0);\n         assert_eq!(v.slice(1, 5).iter().map(|&x| x).product(), 24);\n         assert_eq!(v.slice(0, 0).iter().map(|&x| x).product(), 1);\n     }\n \n     #[test]\n     fn test_iterator_max() {\n-        let v = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+        let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         assert_eq!(v.slice(0, 4).iter().map(|&x| x).max(), Some(3));\n         assert_eq!(v.iter().map(|&x| x).max(), Some(10));\n         assert_eq!(v.slice(0, 0).iter().map(|&x| x).max(), None);\n     }\n \n     #[test]\n     fn test_iterator_min() {\n-        let v = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+        let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         assert_eq!(v.slice(0, 4).iter().map(|&x| x).min(), Some(0));\n         assert_eq!(v.iter().map(|&x| x).min(), Some(0));\n         assert_eq!(v.slice(0, 0).iter().map(|&x| x).min(), None);\n     }\n \n     #[test]\n     fn test_iterator_size_hint() {\n-        let c = count(0, 1);\n-        let v = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n-        let v2 = &[10, 11, 12];\n+        let c = count(0i, 1);\n+        let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+        let v2 = &[10i, 11, 12];\n         let vi = v.iter();\n \n         assert_eq!(c.size_hint(), (uint::MAX, None));\n@@ -2669,14 +2669,14 @@ mod tests {\n \n     #[test]\n     fn test_collect() {\n-        let a = vec![1, 2, 3, 4, 5];\n+        let a = vec![1i, 2, 3, 4, 5];\n         let b: Vec<int> = a.iter().map(|&x| x).collect();\n         assert!(a == b);\n     }\n \n     #[test]\n     fn test_all() {\n-        let v: Box<&[int]> = box &[1, 2, 3, 4, 5];\n+        let v: Box<&[int]> = box &[1i, 2, 3, 4, 5];\n         assert!(v.iter().all(|&x| x < 10));\n         assert!(!v.iter().all(|&x| x % 2 == 0));\n         assert!(!v.iter().all(|&x| x > 100));\n@@ -2685,7 +2685,7 @@ mod tests {\n \n     #[test]\n     fn test_any() {\n-        let v: Box<&[int]> = box &[1, 2, 3, 4, 5];\n+        let v: Box<&[int]> = box &[1i, 2, 3, 4, 5];\n         assert!(v.iter().any(|&x| x < 10));\n         assert!(v.iter().any(|&x| x % 2 == 0));\n         assert!(!v.iter().any(|&x| x > 100));\n@@ -2694,43 +2694,43 @@ mod tests {\n \n     #[test]\n     fn test_find() {\n-        let v: &[int] = &[1, 3, 9, 27, 103, 14, 11];\n+        let v: &[int] = &[1i, 3, 9, 27, 103, 14, 11];\n         assert_eq!(*v.iter().find(|x| *x & 1 == 0).unwrap(), 14);\n         assert_eq!(*v.iter().find(|x| *x % 3 == 0).unwrap(), 3);\n         assert!(v.iter().find(|x| *x % 12 == 0).is_none());\n     }\n \n     #[test]\n     fn test_position() {\n-        let v = &[1, 3, 9, 27, 103, 14, 11];\n+        let v = &[1i, 3, 9, 27, 103, 14, 11];\n         assert_eq!(v.iter().position(|x| *x & 1 == 0).unwrap(), 5);\n         assert_eq!(v.iter().position(|x| *x % 3 == 0).unwrap(), 1);\n         assert!(v.iter().position(|x| *x % 12 == 0).is_none());\n     }\n \n     #[test]\n     fn test_count() {\n-        let xs = &[1, 2, 2, 1, 5, 9, 0, 2];\n+        let xs = &[1i, 2, 2, 1, 5, 9, 0, 2];\n         assert_eq!(xs.iter().filter(|x| **x == 2).count(), 3);\n         assert_eq!(xs.iter().filter(|x| **x == 5).count(), 1);\n         assert_eq!(xs.iter().filter(|x| **x == 95).count(), 0);\n     }\n \n     #[test]\n     fn test_max_by() {\n-        let xs: &[int] = &[-3, 0, 1, 5, -10];\n+        let xs: &[int] = &[-3i, 0, 1, 5, -10];\n         assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n     }\n \n     #[test]\n     fn test_min_by() {\n-        let xs: &[int] = &[-3, 0, 1, 5, -10];\n+        let xs: &[int] = &[-3i, 0, 1, 5, -10];\n         assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n     }\n \n     #[test]\n     fn test_by_ref() {\n-        let mut xs = range(0, 10);\n+        let mut xs = range(0i, 10);\n         // sum the first five values\n         let partial_sum = xs.by_ref().take(5).fold(0, |a, b| a + b);\n         assert_eq!(partial_sum, 10);\n@@ -2739,7 +2739,7 @@ mod tests {\n \n     #[test]\n     fn test_rev() {\n-        let xs = [2, 4, 6, 8, 10, 12, 14, 16];\n+        let xs = [2i, 4, 6, 8, 10, 12, 14, 16];\n         let mut it = xs.iter();\n         it.next();\n         it.next();\n@@ -2749,7 +2749,7 @@ mod tests {\n \n     #[test]\n     fn test_double_ended_map() {\n-        let xs = [1, 2, 3, 4, 5, 6];\n+        let xs = [1i, 2, 3, 4, 5, 6];\n         let mut it = xs.iter().map(|&x| x * -1);\n         assert_eq!(it.next(), Some(-1));\n         assert_eq!(it.next(), Some(-2));\n@@ -2762,7 +2762,7 @@ mod tests {\n \n     #[test]\n     fn test_double_ended_enumerate() {\n-        let xs = [1, 2, 3, 4, 5, 6];\n+        let xs = [1i, 2, 3, 4, 5, 6];\n         let mut it = xs.iter().map(|&x| x).enumerate();\n         assert_eq!(it.next(), Some((0, 1)));\n         assert_eq!(it.next(), Some((1, 2)));\n@@ -2775,8 +2775,8 @@ mod tests {\n \n     #[test]\n     fn test_double_ended_zip() {\n-        let xs = [1, 2, 3, 4, 5, 6];\n-        let ys = [1, 2, 3, 7];\n+        let xs = [1i, 2, 3, 4, 5, 6];\n+        let ys = [1i, 2, 3, 7];\n         let a = xs.iter().map(|&x| x);\n         let b = ys.iter().map(|&x| x);\n         let mut it = a.zip(b);\n@@ -2789,7 +2789,7 @@ mod tests {\n \n     #[test]\n     fn test_double_ended_filter() {\n-        let xs = [1, 2, 3, 4, 5, 6];\n+        let xs = [1i, 2, 3, 4, 5, 6];\n         let mut it = xs.iter().filter(|&x| *x & 1 == 0);\n         assert_eq!(it.next_back().unwrap(), &6);\n         assert_eq!(it.next_back().unwrap(), &4);\n@@ -2799,7 +2799,7 @@ mod tests {\n \n     #[test]\n     fn test_double_ended_filter_map() {\n-        let xs = [1, 2, 3, 4, 5, 6];\n+        let xs = [1i, 2, 3, 4, 5, 6];\n         let mut it = xs.iter().filter_map(|&x| if x & 1 == 0 { Some(x * 2) } else { None });\n         assert_eq!(it.next_back().unwrap(), 12);\n         assert_eq!(it.next_back().unwrap(), 8);\n@@ -2809,8 +2809,8 @@ mod tests {\n \n     #[test]\n     fn test_double_ended_chain() {\n-        let xs = [1, 2, 3, 4, 5];\n-        let ys = [7, 9, 11];\n+        let xs = [1i, 2, 3, 4, 5];\n+        let ys = [7i, 9, 11];\n         let mut it = xs.iter().chain(ys.iter()).rev();\n         assert_eq!(it.next().unwrap(), &11)\n         assert_eq!(it.next().unwrap(), &9)\n@@ -2827,7 +2827,7 @@ mod tests {\n     fn test_rposition() {\n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n-        let v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+        let v = [(0i, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n         assert_eq!(v.iter().rposition(f), Some(3u));\n         assert!(v.iter().rposition(g).is_none());\n@@ -2836,9 +2836,9 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_rposition_fail() {\n-        let v = [(box 0, box(GC) 0), (box 0, box(GC) 0),\n-                 (box 0, box(GC) 0), (box 0, box(GC) 0)];\n-        let mut i = 0;\n+        let v = [(box 0i, box(GC) 0i), (box 0i, box(GC) 0i),\n+                 (box 0i, box(GC) 0i), (box 0i, box(GC) 0i)];\n+        let mut i = 0i;\n         v.iter().rposition(|_elt| {\n             if i == 2 {\n                 fail!()\n@@ -2854,7 +2854,7 @@ mod tests {\n     {\n         let mut b = a.clone();\n         assert_eq!(len, b.indexable());\n-        let mut n = 0;\n+        let mut n = 0u;\n         for (i, elt) in a.enumerate() {\n             assert!(Some(elt) == b.idx(i));\n             n += 1;\n@@ -2872,7 +2872,7 @@ mod tests {\n     #[test]\n     fn test_double_ended_flat_map() {\n         let u = [0u,1];\n-        let v = [5,6,7,8];\n+        let v = [5u,6,7,8];\n         let mut it = u.iter().flat_map(|x| v.slice(*x, v.len()).iter());\n         assert_eq!(it.next_back().unwrap(), &8);\n         assert_eq!(it.next().unwrap(),      &5);\n@@ -2888,8 +2888,8 @@ mod tests {\n \n     #[test]\n     fn test_random_access_chain() {\n-        let xs = [1, 2, 3, 4, 5];\n-        let ys = [7, 9, 11];\n+        let xs = [1i, 2, 3, 4, 5];\n+        let ys = [7i, 9, 11];\n         let mut it = xs.iter().chain(ys.iter());\n         assert_eq!(it.idx(0).unwrap(), &1);\n         assert_eq!(it.idx(5).unwrap(), &7);\n@@ -2909,13 +2909,13 @@ mod tests {\n \n     #[test]\n     fn test_random_access_enumerate() {\n-        let xs = [1, 2, 3, 4, 5];\n+        let xs = [1i, 2, 3, 4, 5];\n         check_randacc_iter(xs.iter().enumerate(), xs.len());\n     }\n \n     #[test]\n     fn test_random_access_rev() {\n-        let xs = [1, 2, 3, 4, 5];\n+        let xs = [1i, 2, 3, 4, 5];\n         check_randacc_iter(xs.iter().rev(), xs.len());\n         let mut it = xs.iter().rev();\n         it.next();\n@@ -2926,14 +2926,14 @@ mod tests {\n \n     #[test]\n     fn test_random_access_zip() {\n-        let xs = [1, 2, 3, 4, 5];\n-        let ys = [7, 9, 11];\n+        let xs = [1i, 2, 3, 4, 5];\n+        let ys = [7i, 9, 11];\n         check_randacc_iter(xs.iter().zip(ys.iter()), cmp::min(xs.len(), ys.len()));\n     }\n \n     #[test]\n     fn test_random_access_take() {\n-        let xs = [1, 2, 3, 4, 5];\n+        let xs = [1i, 2, 3, 4, 5];\n         let empty: &[int] = [];\n         check_randacc_iter(xs.iter().take(3), 3);\n         check_randacc_iter(xs.iter().take(20), xs.len());\n@@ -2943,15 +2943,15 @@ mod tests {\n \n     #[test]\n     fn test_random_access_skip() {\n-        let xs = [1, 2, 3, 4, 5];\n+        let xs = [1i, 2, 3, 4, 5];\n         let empty: &[int] = [];\n         check_randacc_iter(xs.iter().skip(2), xs.len() - 2);\n         check_randacc_iter(empty.iter().skip(2), 0);\n     }\n \n     #[test]\n     fn test_random_access_inspect() {\n-        let xs = [1, 2, 3, 4, 5];\n+        let xs = [1i, 2, 3, 4, 5];\n \n         // test .map and .inspect that don't implement Clone\n         let mut it = xs.iter().inspect(|_| {});\n@@ -2964,7 +2964,7 @@ mod tests {\n \n     #[test]\n     fn test_random_access_map() {\n-        let xs = [1, 2, 3, 4, 5];\n+        let xs = [1i, 2, 3, 4, 5];\n \n         let mut it = xs.iter().map(|x| *x);\n         assert_eq!(xs.len(), it.indexable());\n@@ -2975,7 +2975,7 @@ mod tests {\n \n     #[test]\n     fn test_random_access_cycle() {\n-        let xs = [1, 2, 3, 4, 5];\n+        let xs = [1i, 2, 3, 4, 5];\n         let empty: &[int] = [];\n         check_randacc_iter(xs.iter().cycle().take(27), 27);\n         check_randacc_iter(empty.iter().cycle(), 0);\n@@ -3044,10 +3044,10 @@ mod tests {\n         assert!(range(-10i, -1).collect::<Vec<int>>() ==\n                    vec![-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n         assert!(range(0i, 5).rev().collect::<Vec<int>>() == vec![4, 3, 2, 1, 0]);\n-        assert_eq!(range(200, -5).count(), 0);\n-        assert_eq!(range(200, -5).rev().count(), 0);\n-        assert_eq!(range(200, 200).count(), 0);\n-        assert_eq!(range(200, 200).rev().count(), 0);\n+        assert_eq!(range(200i, -5).count(), 0);\n+        assert_eq!(range(200i, -5).rev().count(), 0);\n+        assert_eq!(range(200i, 200).count(), 0);\n+        assert_eq!(range(200i, 200).rev().count(), 0);\n \n         assert_eq!(range(0i, 100).size_hint(), (100, Some(100)));\n         // this test is only meaningful when sizeof uint < sizeof u64\n@@ -3062,10 +3062,10 @@ mod tests {\n                 vec![0i, 1, 2, 3, 4, 5]);\n         assert!(range_inclusive(0i, 5).rev().collect::<Vec<int>>() ==\n                 vec![5i, 4, 3, 2, 1, 0]);\n-        assert_eq!(range_inclusive(200, -5).count(), 0);\n-        assert_eq!(range_inclusive(200, -5).rev().count(), 0);\n-        assert!(range_inclusive(200, 200).collect::<Vec<int>>() == vec![200]);\n-        assert!(range_inclusive(200, 200).rev().collect::<Vec<int>>() == vec![200]);\n+        assert_eq!(range_inclusive(200i, -5).count(), 0);\n+        assert_eq!(range_inclusive(200i, -5).rev().count(), 0);\n+        assert!(range_inclusive(200i, 200).collect::<Vec<int>>() == vec![200]);\n+        assert!(range_inclusive(200i, 200).rev().collect::<Vec<int>>() == vec![200]);\n     }\n \n     #[test]\n@@ -3078,8 +3078,8 @@ mod tests {\n                 vec![20, 14, 8, 2]);\n         assert!(range_step(200u8, 255, 50).collect::<Vec<u8>>() ==\n                 vec![200u8, 250]);\n-        assert!(range_step(200, -5, 1).collect::<Vec<int>>() == vec![]);\n-        assert!(range_step(200, 200, 1).collect::<Vec<int>>() == vec![]);\n+        assert!(range_step(200i, -5, 1).collect::<Vec<int>>() == vec![]);\n+        assert!(range_step(200i, 200, 1).collect::<Vec<int>>() == vec![]);\n     }\n \n     #[test]\n@@ -3092,22 +3092,22 @@ mod tests {\n                 vec![20, 14, 8, 2]);\n         assert!(range_step_inclusive(200u8, 255, 50).collect::<Vec<u8>>() ==\n                 vec![200u8, 250]);\n-        assert!(range_step_inclusive(200, -5, 1).collect::<Vec<int>>() ==\n+        assert!(range_step_inclusive(200i, -5, 1).collect::<Vec<int>>() ==\n                 vec![]);\n-        assert!(range_step_inclusive(200, 200, 1).collect::<Vec<int>>() ==\n+        assert!(range_step_inclusive(200i, 200, 1).collect::<Vec<int>>() ==\n                 vec![200]);\n     }\n \n     #[test]\n     fn test_reverse() {\n-        let mut ys = [1, 2, 3, 4, 5];\n+        let mut ys = [1i, 2, 3, 4, 5];\n         ys.mut_iter().reverse_();\n         assert!(ys == [5, 4, 3, 2, 1]);\n     }\n \n     #[test]\n     fn test_peekable_is_empty() {\n-        let a = [1];\n+        let a = [1i];\n         let mut it = a.iter().peekable();\n         assert!( !it.is_empty() );\n         it.next();\n@@ -3137,10 +3137,10 @@ mod tests {\n         let r: MinMaxResult<int> = NoElements;\n         assert_eq!(r.into_option(), None)\n \n-        let r = OneElement(1);\n+        let r = OneElement(1i);\n         assert_eq!(r.into_option(), Some((1,1)));\n \n-        let r = MinMax(1,2);\n+        let r = MinMax(1i,2);\n         assert_eq!(r.into_option(), Some((1,2)));\n     }\n }"}, {"sha": "a2a3e09a93c07171634385f64180ddd4872cf1de", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -324,7 +324,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// ```\n /// use std::cell::RefCell;\n ///\n-/// let x = RefCell::new(1);\n+/// let x = RefCell::new(1i);\n ///\n /// let mut mutable_borrow = x.borrow_mut();\n /// *mutable_borrow = 1;\n@@ -458,8 +458,8 @@ mod tests {\n \n     #[test]\n     fn test_swap() {\n-        let mut x = 31337;\n-        let mut y = 42;\n+        let mut x = 31337i;\n+        let mut y = 42i;\n         swap(&mut x, &mut y);\n         assert_eq!(x, 42);\n         assert_eq!(y, 31337);\n@@ -483,7 +483,7 @@ mod tests {\n         trait Foo {}\n         impl Foo for int {}\n \n-        let a = box 100 as Box<Foo>;\n+        let a = box 100i as Box<Foo>;\n         unsafe {\n             let x: raw::TraitObject = transmute(a);\n             assert!(*(x.data as *int) == 100);"}, {"sha": "512c107b930b67b559d78154b843d1b2cc2889db", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -322,7 +322,7 @@ trait_impl!(Unsigned for uint u8 u16 u32 u64)\n /// ```rust\n /// use std::num;\n ///\n-/// assert_eq!(num::pow(2, 4), 16);\n+/// assert_eq!(num::pow(2i, 4), 16);\n /// ```\n #[inline]\n pub fn pow<T: One + Mul<T, T>>(mut base: T, mut exp: uint) -> T {\n@@ -1144,7 +1144,7 @@ impl_from_primitive!(f64, n.to_f64())\n /// ```\n /// use std::num;\n ///\n-/// let twenty: f32 = num::cast(0x14).unwrap();\n+/// let twenty: f32 = num::cast(0x14i).unwrap();\n /// assert_eq!(twenty, 20f32);\n /// ```\n ///\n@@ -1378,11 +1378,11 @@ checkeddiv_uint_impl!(uint u8 u16 u32 u64)\n /// Helper function for testing numeric operations\n #[cfg(test)]\n pub fn test_num<T:Num + NumCast + ::std::fmt::Show>(ten: T, two: T) {\n-    assert_eq!(ten.add(&two),  cast(12).unwrap());\n-    assert_eq!(ten.sub(&two),  cast(8).unwrap());\n-    assert_eq!(ten.mul(&two),  cast(20).unwrap());\n-    assert_eq!(ten.div(&two),  cast(5).unwrap());\n-    assert_eq!(ten.rem(&two),  cast(0).unwrap());\n+    assert_eq!(ten.add(&two),  cast(12i).unwrap());\n+    assert_eq!(ten.sub(&two),  cast(8i).unwrap());\n+    assert_eq!(ten.mul(&two),  cast(20i).unwrap());\n+    assert_eq!(ten.div(&two),  cast(5i).unwrap());\n+    assert_eq!(ten.rem(&two),  cast(0i).unwrap());\n \n     assert_eq!(ten.add(&two),  ten + two);\n     assert_eq!(ten.sub(&two),  ten - two);"}, {"sha": "14edd7c70a8dec9807704a21d9e0acfec1d7e6f9", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -570,11 +570,18 @@ pub trait Shl<RHS,Result> {\n \n macro_rules! shl_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n+        #[cfg(stage0)]\n         impl Shl<$t, $t> for $t {\n             #[inline]\n             fn shl(&self, other: &$t) -> $t { (*self) << (*other) }\n         }\n+        #[cfg(not(stage0), not(test))]\n+        impl Shl<$t, $t> for $t {\n+            #[inline]\n+            fn shl(&self, other: &$t) -> $t {\n+                (*self) << (*other as uint)\n+            }\n+        }\n     )*)\n )\n \n@@ -612,11 +619,16 @@ pub trait Shr<RHS,Result> {\n \n macro_rules! shr_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n+        #[cfg(stage0, not(test))]\n         impl Shr<$t, $t> for $t {\n             #[inline]\n             fn shr(&self, other: &$t) -> $t { (*self) >> (*other) }\n         }\n+        #[cfg(not(stage0), not(test))]\n+        impl Shr<$t, $t> for $t {\n+            #[inline]\n+            fn shr(&self, other: &$t) -> $t { (*self) >> (*other as uint) }\n+        }\n     )*)\n )\n "}, {"sha": "e9fb7c3dae3c954f33ea196b9eada930eaa234a8", "filename": "src/libcore/option.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -505,8 +505,8 @@ impl<T: Default> Option<T> {\n     /// let good_year = from_str(good_year_from_input).unwrap_or_default();\n     /// let bad_year = from_str(bad_year_from_input).unwrap_or_default();\n     ///\n-    /// assert_eq!(1909, good_year);\n-    /// assert_eq!(0, bad_year);\n+    /// assert_eq!(1909i, good_year);\n+    /// assert_eq!(0i, bad_year);\n     /// ```\n     #[inline]\n     pub fn unwrap_or_default(self) -> T {\n@@ -675,7 +675,7 @@ mod tests {\n             t.clone()\n         }\n \n-        let i = Rc::new(RefCell::new(0));\n+        let i = Rc::new(RefCell::new(0i));\n         {\n             let x = r(realclone(&i));\n             let opt = Some(x);\n@@ -687,7 +687,7 @@ mod tests {\n     #[test]\n     fn test_option_dance() {\n         let x = Some(());\n-        let mut y = Some(5);\n+        let mut y = Some(5i);\n         let mut y2 = 0;\n         for _x in x.iter() {\n             y2 = y.take_unwrap();\n@@ -705,12 +705,12 @@ mod tests {\n \n     #[test]\n     fn test_and() {\n-        let x: Option<int> = Some(1);\n-        assert_eq!(x.and(Some(2)), Some(2));\n+        let x: Option<int> = Some(1i);\n+        assert_eq!(x.and(Some(2i)), Some(2));\n         assert_eq!(x.and(None::<int>), None);\n \n         let x: Option<int> = None;\n-        assert_eq!(x.and(Some(2)), None);\n+        assert_eq!(x.and(Some(2i)), None);\n         assert_eq!(x.and(None::<int>), None);\n     }\n \n@@ -749,7 +749,7 @@ mod tests {\n \n     #[test]\n     fn test_option_while_some() {\n-        let mut i = 0;\n+        let mut i = 0i;\n         Some(10).while_some(|j| {\n             i += 1;\n             if j > 0 {\n@@ -763,7 +763,7 @@ mod tests {\n \n     #[test]\n     fn test_unwrap() {\n-        assert_eq!(Some(1).unwrap(), 1);\n+        assert_eq!(Some(1i).unwrap(), 1);\n         let s = Some(\"hello\".to_string()).unwrap();\n         assert_eq!(s.as_slice(), \"hello\");\n     }\n@@ -802,15 +802,15 @@ mod tests {\n \n     #[test]\n     fn test_filtered() {\n-        let some_stuff = Some(42);\n+        let some_stuff = Some(42i);\n         let modified_stuff = some_stuff.filtered(|&x| {x < 10});\n         assert_eq!(some_stuff.unwrap(), 42);\n         assert!(modified_stuff.is_none());\n     }\n \n     #[test]\n     fn test_iter() {\n-        let val = 5;\n+        let val = 5i;\n \n         let x = Some(val);\n         let mut it = x.iter();\n@@ -823,8 +823,8 @@ mod tests {\n \n     #[test]\n     fn test_mut_iter() {\n-        let val = 5;\n-        let new_val = 11;\n+        let val = 5i;\n+        let new_val = 11i;\n \n         let mut x = Some(val);\n         {\n@@ -848,9 +848,9 @@ mod tests {\n \n     #[test]\n     fn test_ord() {\n-        let small = Some(1.0);\n-        let big = Some(5.0);\n-        let nan = Some(0.0/0.0);\n+        let small = Some(1.0f64);\n+        let big = Some(5.0f64);\n+        let nan = Some(0.0f64/0.0);\n         assert!(!(nan < big));\n         assert!(!(nan > big));\n         assert!(small < big);\n@@ -874,15 +874,15 @@ mod tests {\n \n     #[test]\n     fn test_collect() {\n-        let v: Option<Vec<int>> = collect(range(0, 0)\n-                                          .map(|_| Some(0)));\n+        let v: Option<Vec<int>> = collect(range(0i, 0)\n+                                          .map(|_| Some(0i)));\n         assert!(v == Some(vec![]));\n \n-        let v: Option<Vec<int>> = collect(range(0, 3)\n+        let v: Option<Vec<int>> = collect(range(0i, 3)\n                                           .map(|x| Some(x)));\n         assert!(v == Some(vec![0, 1, 2]));\n \n-        let v: Option<Vec<int>> = collect(range(0, 3)\n+        let v: Option<Vec<int>> = collect(range(0i, 3)\n                                           .map(|x| if x > 1 { None } else { Some(x) }));\n         assert!(v == None);\n "}, {"sha": "59d7bbfe52dc455b2b968dc56738775be389349a", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -624,7 +624,7 @@ pub mod test {\n     #[test]\n     fn test_ptr_addition() {\n         unsafe {\n-            let xs = Vec::from_elem(16, 5);\n+            let xs = Vec::from_elem(16, 5i);\n             let mut ptr = xs.as_ptr();\n             let end = ptr.offset(16);\n \n@@ -642,7 +642,7 @@ pub mod test {\n                 m_ptr = m_ptr.offset(1);\n             }\n \n-            assert!(xs_mut == Vec::from_elem(16, 10));\n+            assert!(xs_mut == Vec::from_elem(16, 10i));\n         }\n     }\n \n@@ -719,8 +719,8 @@ pub mod test {\n             ];\n \n             let arr_ptr = arr.as_ptr();\n-            let mut ctr = 0;\n-            let mut iteration_count = 0;\n+            let mut ctr = 0u;\n+            let mut iteration_count = 0u;\n             array_each(arr_ptr, |e| {\n                     let actual = str::raw::from_c_str(e);\n                     let expected = expected_arr[ctr].with_ref(|buf| {"}, {"sha": "6c163b7919920b08d0d528b0a437eee6bddd7c4b", "filename": "src/libcore/result.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -654,11 +654,11 @@ mod tests {\n \n     #[test]\n     pub fn test_and() {\n-        assert_eq!(op1().and(Ok(667)).unwrap(), 667);\n+        assert_eq!(op1().and(Ok(667i)).unwrap(), 667);\n         assert_eq!(op1().and(Err::<(), &'static str>(\"bad\")).unwrap_err(),\n                    \"bad\");\n \n-        assert_eq!(op2().and(Ok(667)).unwrap_err(), \"sadface\");\n+        assert_eq!(op2().and(Ok(667i)).unwrap_err(), \"sadface\");\n         assert_eq!(op2().and(Err::<(),&'static str>(\"bad\")).unwrap_err(),\n                    \"sadface\");\n     }\n@@ -708,38 +708,38 @@ mod tests {\n \n     #[test]\n     fn test_collect() {\n-        let v: Result<Vec<int>, ()> = collect(range(0, 0).map(|_| Ok::<int, ()>(0)));\n+        let v: Result<Vec<int>, ()> = collect(range(0i, 0).map(|_| Ok::<int, ()>(0)));\n         assert!(v == Ok(vec![]));\n \n-        let v: Result<Vec<int>, ()> = collect(range(0, 3).map(|x| Ok::<int, ()>(x)));\n+        let v: Result<Vec<int>, ()> = collect(range(0i, 3).map(|x| Ok::<int, ()>(x)));\n         assert!(v == Ok(vec![0, 1, 2]));\n \n-        let v: Result<Vec<int>, int> = collect(range(0, 3)\n+        let v: Result<Vec<int>, int> = collect(range(0i, 3)\n                                                .map(|x| if x > 1 { Err(x) } else { Ok(x) }));\n         assert!(v == Err(2));\n \n         // test that it does not take more elements than it needs\n-        let mut functions = [|| Ok(()), || Err(1), || fail!()];\n+        let mut functions = [|| Ok(()), || Err(1i), || fail!()];\n \n         let v: Result<Vec<()>, int> = collect(functions.mut_iter().map(|f| (*f)()));\n         assert!(v == Err(1));\n     }\n \n     #[test]\n     fn test_fold() {\n-        assert_eq!(fold_(range(0, 0)\n+        assert_eq!(fold_(range(0i, 0)\n                         .map(|_| Ok::<(), ()>(()))),\n                    Ok(()));\n-        assert_eq!(fold(range(0, 3)\n+        assert_eq!(fold(range(0i, 3)\n                         .map(|x| Ok::<int, ()>(x)),\n                         0, |a, b| a + b),\n                    Ok(3));\n-        assert_eq!(fold_(range(0, 3)\n+        assert_eq!(fold_(range(0i, 3)\n                         .map(|x| if x > 1 { Err(x) } else { Ok(()) })),\n                    Err(2));\n \n         // test that it does not take more elements than it needs\n-        let mut functions = [|| Ok(()), || Err(1), || fail!()];\n+        let mut functions = [|| Ok(()), || Err(1i), || fail!()];\n \n         assert_eq!(fold_(functions.mut_iter()\n                         .map(|f| (*f)())),\n@@ -759,7 +759,7 @@ mod tests {\n \n     #[test]\n     pub fn test_unwrap_or() {\n-        let ok: Result<int, &'static str> = Ok(100);\n+        let ok: Result<int, &'static str> = Ok(100i);\n         let ok_err: Result<int, &'static str> = Err(\"Err\");\n \n         assert_eq!(ok.unwrap_or(50), 100);\n@@ -770,7 +770,7 @@ mod tests {\n     pub fn test_unwrap_or_else() {\n         fn handler(msg: &'static str) -> int {\n             if msg == \"I got this.\" {\n-                50\n+                50i\n             } else {\n                 fail!(\"BadBad\")\n             }\n@@ -788,7 +788,7 @@ mod tests {\n     pub fn test_unwrap_or_else_failure() {\n         fn handler(msg: &'static str) -> int {\n             if msg == \"I got this.\" {\n-                50\n+                50i\n             } else {\n                 fail!(\"BadBad\")\n             }"}, {"sha": "14b5f7a6d60e29653a16e2e7ccfede64b467bf11", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -376,7 +376,7 @@ pub trait ImmutableVector<'a, T> {\n      * `[3,4]`):\n      *\n      * ```rust\n-     * let v = &[1,2,3,4];\n+     * let v = &[1i, 2, 3, 4];\n      * for win in v.windows(2) {\n      *     println!(\"{}\", win);\n      * }\n@@ -401,7 +401,7 @@ pub trait ImmutableVector<'a, T> {\n      * `[3,4]`, `[5]`):\n      *\n      * ```rust\n-     * let v = &[1,2,3,4,5];\n+     * let v = &[1i, 2, 3, 4, 5];\n      * for win in v.chunks(2) {\n      *     println!(\"{}\", win);\n      * }\n@@ -830,24 +830,24 @@ pub trait MutableVector<'a, T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = [1, 2, 3, 4, 5, 6];\n+    /// let mut v = [1i, 2, 3, 4, 5, 6];\n     ///\n     /// // scoped to restrict the lifetime of the borrows\n     /// {\n     ///    let (left, right) = v.mut_split_at(0);\n     ///    assert!(left == &mut []);\n-    ///    assert!(right == &mut [1, 2, 3, 4, 5, 6]);\n+    ///    assert!(right == &mut [1i, 2, 3, 4, 5, 6]);\n     /// }\n     ///\n     /// {\n     ///     let (left, right) = v.mut_split_at(2);\n-    ///     assert!(left == &mut [1, 2]);\n-    ///     assert!(right == &mut [3, 4, 5, 6]);\n+    ///     assert!(left == &mut [1i, 2]);\n+    ///     assert!(right == &mut [3i, 4, 5, 6]);\n     /// }\n     ///\n     /// {\n     ///     let (left, right) = v.mut_split_at(6);\n-    ///     assert!(left == &mut [1, 2, 3, 4, 5, 6]);\n+    ///     assert!(left == &mut [1i, 2, 3, 4, 5, 6]);\n     ///     assert!(right == &mut []);\n     /// }\n     /// ```\n@@ -858,9 +858,9 @@ pub trait MutableVector<'a, T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = [1, 2, 3];\n+    /// let mut v = [1i, 2, 3];\n     /// v.reverse();\n-    /// assert!(v == [3, 2, 1]);\n+    /// assert!(v == [3i, 2, 1]);\n     /// ```\n     fn reverse(self);\n \n@@ -1080,15 +1080,15 @@ pub trait MutableCloneableVector<T> {\n     /// ```rust\n     /// use std::slice::MutableCloneableVector;\n     ///\n-    /// let mut dst = [0, 0, 0];\n-    /// let src = [1, 2];\n+    /// let mut dst = [0i, 0, 0];\n+    /// let src = [1i, 2];\n     ///\n     /// assert!(dst.copy_from(src) == 2);\n     /// assert!(dst == [1, 2, 0]);\n     ///\n-    /// let src2 = [3, 4, 5, 6];\n+    /// let src2 = [3i, 4, 5, 6];\n     /// assert!(dst.copy_from(src2) == 3);\n-    /// assert!(dst == [3, 4, 5]);\n+    /// assert!(dst == [3i, 4, 5]);\n     /// ```\n     fn copy_from(self, &[T]) -> uint;\n }"}, {"sha": "13efeab57d492693c9d65923048c2ca214685d4f", "filename": "src/libcore/str.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -364,7 +364,8 @@ impl TwoWaySearcher {\n             period = period2;\n         }\n \n-        let byteset = needle.iter().fold(0, |a, &b| (1 << (b & 0x3f)) | a);\n+        let byteset = needle.iter()\n+                            .fold(0, |a, &b| (1 << ((b & 0x3f) as uint)) | a);\n \n         if needle.slice_to(critPos) == needle.slice_from(needle.len() - critPos) {\n             TwoWaySearcher {\n@@ -396,7 +397,9 @@ impl TwoWaySearcher {\n             }\n \n             // Quickly skip by large portions unrelated to our substring\n-            if (self.byteset >> (haystack[self.position + needle.len() - 1] & 0x3f)) & 1 == 0 {\n+            if (self.byteset >>\n+                    ((haystack[self.position + needle.len() - 1] & 0x3f)\n+                     as uint)) & 1 == 0 {\n                 self.position += needle.len();\n                 continue 'search;\n             }"}, {"sha": "18511474ecf6ba6ea2ab6b2b9a002fba012e02ea", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -38,18 +38,18 @@\n //! Using methods:\n //!\n //! ```\n-//! let pair = (\"pi\", 3.14);\n+//! let pair = (\"pi\", 3.14f64);\n //! assert_eq!(pair.val0(), \"pi\");\n-//! assert_eq!(pair.val1(), 3.14);\n+//! assert_eq!(pair.val1(), 3.14f64);\n //! ```\n //!\n //! Using traits implemented for tuples:\n //!\n //! ```\n //! use std::default::Default;\n //!\n-//! let a = (1, 2);\n-//! let b = (3, 4);\n+//! let a = (1i, 2i);\n+//! let b = (3i, 4i);\n //! assert!(a != b);\n //!\n //! let c = b.clone();\n@@ -300,7 +300,7 @@ mod tests {\n \n     #[test]\n     fn test_clone() {\n-        let a = (1, \"2\");\n+        let a = (1i, \"2\");\n         let b = a.clone();\n         assert_eq!(a, b);\n     }\n@@ -335,7 +335,7 @@ mod tests {\n     fn test_tuple_cmp() {\n         let (small, big) = ((1u, 2u, 3u), (3u, 2u, 1u));\n \n-        let nan = 0.0/0.0;\n+        let nan = 0.0f64/0.0;\n \n         // PartialEq\n         assert_eq!(small, small);\n@@ -357,12 +357,12 @@ mod tests {\n         assert!(big >= small);\n         assert!(big >= big);\n \n-        assert!(!((1.0, 2.0) < (nan, 3.0)));\n-        assert!(!((1.0, 2.0) <= (nan, 3.0)));\n-        assert!(!((1.0, 2.0) > (nan, 3.0)));\n-        assert!(!((1.0, 2.0) >= (nan, 3.0)));\n-        assert!(((1.0, 2.0) < (2.0, nan)));\n-        assert!(!((2.0, 2.0) < (2.0, nan)));\n+        assert!(!((1.0f64, 2.0f64) < (nan, 3.0)));\n+        assert!(!((1.0f64, 2.0f64) <= (nan, 3.0)));\n+        assert!(!((1.0f64, 2.0f64) > (nan, 3.0)));\n+        assert!(!((1.0f64, 2.0f64) >= (nan, 3.0)));\n+        assert!(((1.0f64, 2.0f64) < (2.0, nan)));\n+        assert!(!((2.0f64, 2.0f64) < (2.0, nan)));\n \n         // Ord\n         assert!(small.cmp(&small) == Equal);\n@@ -373,11 +373,11 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let s = format!(\"{}\", (1,));\n+        let s = format!(\"{}\", (1i,));\n         assert_eq!(s.as_slice(), \"(1,)\");\n-        let s = format!(\"{}\", (1, true));\n+        let s = format!(\"{}\", (1i, true));\n         assert_eq!(s.as_slice(), \"(1, true)\");\n-        let s = format!(\"{}\", (1, \"hi\", true));\n+        let s = format!(\"{}\", (1i, \"hi\", true));\n         assert_eq!(s.as_slice(), \"(1, hi, true)\");\n     }\n }"}, {"sha": "26e9b2aa372fa0c8d8705517713aecbb9f0526db", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -116,14 +116,14 @@ mod tests {\n     fn test_flate_round_trip() {\n         let mut r = rand::task_rng();\n         let mut words = vec!();\n-        for _ in range(0, 20) {\n+        for _ in range(0u, 20) {\n             let range = r.gen_range(1u, 10);\n             let v = r.gen_iter::<u8>().take(range).collect::<Vec<u8>>();\n             words.push(v);\n         }\n-        for _ in range(0, 20) {\n+        for _ in range(0u, 20) {\n             let mut input = vec![];\n-            for _ in range(0, 2000) {\n+            for _ in range(0u, 2000) {\n                 input.push_all(r.choose(words.as_slice()).unwrap().as_slice());\n             }\n             debug!(\"de/inflate of {} bytes of random word-sequences\","}, {"sha": "f80208c4743f7c74003029796dd12f8c10e81d7e", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -686,13 +686,13 @@ mod test {\n     fn test_range_pattern() {\n \n         let pat = Pattern::new(\"a[0-9]b\");\n-        for i in range(0, 10) {\n+        for i in range(0u, 10) {\n             assert!(pat.matches(format!(\"a{}b\", i).as_slice()));\n         }\n         assert!(!pat.matches(\"a_b\"));\n \n         let pat = Pattern::new(\"a[!0-9]b\");\n-        for i in range(0, 10) {\n+        for i in range(0u, 10) {\n             assert!(!pat.matches(format!(\"a{}b\", i).as_slice()));\n         }\n         assert!(pat.matches(\"a_b\"));"}, {"sha": "d0224749781899440ac7976eae371ed28059bdff", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -245,7 +245,7 @@ mod test {\n             event_loop_factory: basic::event_loop,\n         });\n \n-        for _ in range(0, 20) {\n+        for _ in range(0u, 20) {\n             pool.spawn(TaskOpts::new(), proc() {\n                 let (tx, rx) = channel();\n                 spawn(proc() {"}, {"sha": "0402a93e468497c1fd8ff1fc9dc21b76b282359b", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -1336,7 +1336,7 @@ mod test {\n     fn multithreading() {\n         run(proc() {\n             let mut rxs = vec![];\n-            for _ in range(0, 10) {\n+            for _ in range(0u, 10) {\n                 let (tx, rx) = channel();\n                 spawn(proc() {\n                     tx.send(());\n@@ -1469,7 +1469,7 @@ mod test {\n     fn single_threaded_yield() {\n         use std::task::deschedule;\n         run(proc() {\n-            for _ in range(0, 5) { deschedule(); }\n+            for _ in range(0u, 5) { deschedule(); }\n         });\n     }\n \n@@ -1480,7 +1480,7 @@ mod test {\n \n         // Testing that a task in one scheduler can block in foreign code\n         // without affecting other schedulers\n-        for _ in range(0, 20) {\n+        for _ in range(0u, 20) {\n             let mut pool = pool();\n             let (start_tx, start_rx) = channel();\n             let (fin_tx, fin_rx) = channel();"}, {"sha": "692b6e14fe7e1622f8c4e8c2a718b5718f4cc08c", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -536,7 +536,7 @@ mod tests {\n     fn yield_test() {\n         let (tx, rx) = channel();\n         spawn_opts(TaskOpts::new(), proc() {\n-            for _ in range(0, 10) { task::deschedule(); }\n+            for _ in range(0u, 10) { task::deschedule(); }\n             tx.send(());\n         });\n         rx.recv();"}, {"sha": "41a741eb1df34e403f21f4e06ffa0bd53ff1d615", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -23,7 +23,7 @@ fn main() {\n     error!(\"this is printed by default\");\n \n     if log_enabled!(log::INFO) {\n-        let x = 3 * 4; // expensive computation\n+        let x = 3i * 4i; // expensive computation\n         info!(\"the answer was: {}\", x);\n     }\n }"}, {"sha": "fe74b7d67ffb93c018f89d2c849ecd4d0ae52138", "filename": "src/liblog/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fliblog%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Fliblog%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fmacros.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -27,7 +27,7 @@\n /// # fn main() {\n /// log!(log::DEBUG, \"this is a debug message\");\n /// log!(log::WARN, \"this is a warning {}\", \"message\");\n-/// log!(6, \"this is a custom logging level: {level}\", level=6);\n+/// log!(6, \"this is a custom logging level: {level}\", level=6u);\n /// # }\n /// ```\n #[macro_export]\n@@ -54,7 +54,7 @@ macro_rules! log(\n /// #[phase(plugin, link)] extern crate log;\n ///\n /// # fn main() {\n-/// # let error = 3;\n+/// # let error = 3u;\n /// error!(\"the build has failed with error code: {}\", error);\n /// # }\n /// ```\n@@ -72,7 +72,7 @@ macro_rules! error(\n /// #[phase(plugin, link)] extern crate log;\n ///\n /// # fn main() {\n-/// # let code = 3;\n+/// # let code = 3u;\n /// warn!(\"you may like to know that a process exited with: {}\", code);\n /// # }\n /// ```\n@@ -90,7 +90,7 @@ macro_rules! warn(\n /// #[phase(plugin, link)] extern crate log;\n ///\n /// # fn main() {\n-/// # let ret = 3;\n+/// # let ret = 3i;\n /// info!(\"this function is about to return: {}\", ret);\n /// # }\n /// ```\n@@ -110,7 +110,7 @@ macro_rules! info(\n /// #[phase(plugin, link)] extern crate log;\n ///\n /// # fn main() {\n-/// debug!(\"x = {x}, y = {y}\", x=10, y=20);\n+/// debug!(\"x = {x}, y = {y}\", x=10i, y=20i);\n /// # }\n /// ```\n #[macro_export]"}, {"sha": "b1bc36e0b05e0273867928745de9e47ccb4ea1d7", "filename": "src/libnative/io/c_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibnative%2Fio%2Fc_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibnative%2Fio%2Fc_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_unix.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -93,7 +93,7 @@ mod select {\n     }\n \n     pub fn fd_set(set: &mut fd_set, fd: i32) {\n-        set.fds_bits[(fd / 32) as uint] |= 1 << (fd % 32);\n+        set.fds_bits[(fd / 32) as uint] |= 1 << ((fd % 32) as uint);\n     }\n }\n "}, {"sha": "8b7c8e61bc35bf3733fe97bf87712a570df72ead", "filename": "src/libnative/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -328,7 +328,7 @@ mod tests {\n     fn yield_test() {\n         let (tx, rx) = channel();\n         spawn(proc() {\n-            for _ in range(0, 10) { task::deschedule(); }\n+            for _ in range(0u, 10) { task::deschedule(); }\n             tx.send(());\n         });\n         rx.recv();"}, {"sha": "06e4792cdcccfdabb1bd8f80462d2bdfdf7fb85d", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -2172,15 +2172,15 @@ mod biguint_tests {\n     fn test_rand_range() {\n         let mut rng = task_rng();\n \n-        for _ in range(0, 10) {\n+        for _ in range(0u, 10) {\n             assert_eq!(rng.gen_bigint_range(&FromPrimitive::from_uint(236).unwrap(),\n                                             &FromPrimitive::from_uint(237).unwrap()),\n                        FromPrimitive::from_uint(236).unwrap());\n         }\n \n         let l = FromPrimitive::from_uint(403469000 + 2352).unwrap();\n         let u = FromPrimitive::from_uint(403469000 + 3513).unwrap();\n-        for _ in range(0, 1000) {\n+        for _ in range(0u, 1000) {\n             let n: BigUint = rng.gen_biguint_below(&u);\n             assert!(n < u);\n \n@@ -2761,15 +2761,15 @@ mod bigint_tests {\n     fn test_rand_range() {\n         let mut rng = task_rng();\n \n-        for _ in range(0, 10) {\n+        for _ in range(0u, 10) {\n             assert_eq!(rng.gen_bigint_range(&FromPrimitive::from_uint(236).unwrap(),\n                                             &FromPrimitive::from_uint(237).unwrap()),\n                        FromPrimitive::from_uint(236).unwrap());\n         }\n \n         fn check(l: BigInt, u: BigInt) {\n             let mut rng = task_rng();\n-            for _ in range(0, 1000) {\n+            for _ in range(0u, 1000) {\n                 let n: BigInt = rng.gen_bigint_range(&l, &u);\n                 assert!(n >= l);\n                 assert!(n < u);\n@@ -2858,7 +2858,7 @@ mod bench {\n         let n = { let one : BigUint = One::one(); one << 1000 };\n         b.iter(|| {\n             let mut m = n.clone();\n-            for _ in range(0, 10) {\n+            for _ in range(0u, 10) {\n                 m = m >> 1;\n             }\n         })"}, {"sha": "971b6b1b51b2dbecac6b5bd7ca4ec49052bcadc5", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -353,10 +353,10 @@ mod test {\n         // check our constants are what Ratio::new etc. would make.\n         assert_eq!(_0, Zero::zero());\n         assert_eq!(_1, One::one());\n-        assert_eq!(_2, Ratio::from_integer(2));\n-        assert_eq!(_1_2, Ratio::new(1,2));\n-        assert_eq!(_3_2, Ratio::new(3,2));\n-        assert_eq!(_neg1_2, Ratio::new(-1,2));\n+        assert_eq!(_2, Ratio::from_integer(2i));\n+        assert_eq!(_1_2, Ratio::new(1i,2i));\n+        assert_eq!(_3_2, Ratio::new(3i,2i));\n+        assert_eq!(_neg1_2, Ratio::new(-1i,2i));\n     }\n \n     #[test]\n@@ -368,7 +368,7 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_new_zero() {\n-        let _a = Ratio::new(1,0);\n+        let _a = Ratio::new(1i,0);\n     }\n \n \n@@ -466,8 +466,8 @@ mod test {\n             }\n \n             test(_1, _1_2, _1_2);\n-            test(_1_2, _3_2, Ratio::new(3,4));\n-            test(_1_2, _neg1_2, Ratio::new(-1, 4));\n+            test(_1_2, _3_2, Ratio::new(3i,4i));\n+            test(_1_2, _neg1_2, Ratio::new(-1i, 4i));\n         }\n \n         #[test]\n@@ -606,7 +606,7 @@ mod test {\n         test16(_2, \"2/1\".to_string());\n         test16(_neg1_2, \"-1/2\".to_string());\n         test16(_neg1_2 / _2, \"-1/4\".to_string());\n-        test16(Ratio::new(13,15), \"d/f\".to_string());\n+        test16(Ratio::new(13i,15i), \"d/f\".to_string());\n         test16(_1_2*_1_2*_1_2*_1_2, \"1/10\".to_string());\n     }\n \n@@ -645,7 +645,7 @@ mod test {\n         test(2f64.powf(100.), (\"1267650600228229401496703205376\", \"1\"));\n         test(-2f64.powf(100.), (\"-1267650600228229401496703205376\", \"1\"));\n         test(684729.48391f64, (\"367611342500051\", \"536870912\"));\n-        test(-8573.5918555, (\"-4713381968463931\", \"549755813888\"));\n+        test(-8573.5918555f64, (\"-4713381968463931\", \"549755813888\"));\n         test(1.0 / 2f64.powf(100.), (\"1\", \"1267650600228229401496703205376\"));\n     }\n "}, {"sha": "7d1a4409718faf42860114fffcdc3653967c2d68", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -101,7 +101,7 @@ mod test {\n     fn test_exp() {\n         let mut exp = Exp::new(10.0);\n         let mut rng = ::test::rng();\n-        for _ in range(0, 1000) {\n+        for _ in range(0u, 1000) {\n             assert!(exp.sample(&mut rng) >= 0.0);\n             assert!(exp.ind_sample(&mut rng) >= 0.0);\n         }"}, {"sha": "a9f24e1a9ecc769d3fc8932a5dde58687d749c3b", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -327,7 +327,7 @@ mod test {\n     fn test_chi_squared_one() {\n         let mut chi = ChiSquared::new(1.0);\n         let mut rng = ::test::rng();\n-        for _ in range(0, 1000) {\n+        for _ in range(0u, 1000) {\n             chi.sample(&mut rng);\n             chi.ind_sample(&mut rng);\n         }\n@@ -336,7 +336,7 @@ mod test {\n     fn test_chi_squared_small() {\n         let mut chi = ChiSquared::new(0.5);\n         let mut rng = ::test::rng();\n-        for _ in range(0, 1000) {\n+        for _ in range(0u, 1000) {\n             chi.sample(&mut rng);\n             chi.ind_sample(&mut rng);\n         }\n@@ -345,7 +345,7 @@ mod test {\n     fn test_chi_squared_large() {\n         let mut chi = ChiSquared::new(30.0);\n         let mut rng = ::test::rng();\n-        for _ in range(0, 1000) {\n+        for _ in range(0u, 1000) {\n             chi.sample(&mut rng);\n             chi.ind_sample(&mut rng);\n         }\n@@ -360,7 +360,7 @@ mod test {\n     fn test_f() {\n         let mut f = FisherF::new(2.0, 32.0);\n         let mut rng = ::test::rng();\n-        for _ in range(0, 1000) {\n+        for _ in range(0u, 1000) {\n             f.sample(&mut rng);\n             f.ind_sample(&mut rng);\n         }\n@@ -370,7 +370,7 @@ mod test {\n     fn test_t() {\n         let mut t = StudentT::new(11.0);\n         let mut rng = ::test::rng();\n-        for _ in range(0, 1000) {\n+        for _ in range(0u, 1000) {\n             t.sample(&mut rng);\n             t.ind_sample(&mut rng);\n         }"}, {"sha": "faafbc4421e249bca473bd33241871d51cc46c68", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -101,7 +101,7 @@ pub struct Weighted<T> {\n ///                      Weighted { weight: 1, item: 'c' });\n /// let wc = WeightedChoice::new(items.as_mut_slice());\n /// let mut rng = rand::task_rng();\n-/// for _ in range(0, 16) {\n+/// for _ in range(0u, 16) {\n ///      // on average prints 'a' 4 times, 'b' 8 and 'c' twice.\n ///      println!(\"{}\", wc.ind_sample(&mut rng));\n /// }\n@@ -308,36 +308,36 @@ mod tests {\n             }}\n         );\n \n-        t!(vec!(Weighted { weight: 1, item: 10}), [10]);\n+        t!(vec!(Weighted { weight: 1, item: 10i}), [10]);\n \n         // skip some\n-        t!(vec!(Weighted { weight: 0, item: 20},\n-                Weighted { weight: 2, item: 21},\n-                Weighted { weight: 0, item: 22},\n-                Weighted { weight: 1, item: 23}),\n+        t!(vec!(Weighted { weight: 0, item: 20i},\n+                Weighted { weight: 2, item: 21i},\n+                Weighted { weight: 0, item: 22i},\n+                Weighted { weight: 1, item: 23i}),\n            [21,21, 23]);\n \n         // different weights\n-        t!(vec!(Weighted { weight: 4, item: 30},\n-                Weighted { weight: 3, item: 31}),\n+        t!(vec!(Weighted { weight: 4, item: 30i},\n+                Weighted { weight: 3, item: 31i}),\n            [30,30,30,30, 31,31,31]);\n \n         // check that we're binary searching\n         // correctly with some vectors of odd\n         // length.\n-        t!(vec!(Weighted { weight: 1, item: 40},\n-                Weighted { weight: 1, item: 41},\n-                Weighted { weight: 1, item: 42},\n-                Weighted { weight: 1, item: 43},\n-                Weighted { weight: 1, item: 44}),\n+        t!(vec!(Weighted { weight: 1, item: 40i},\n+                Weighted { weight: 1, item: 41i},\n+                Weighted { weight: 1, item: 42i},\n+                Weighted { weight: 1, item: 43i},\n+                Weighted { weight: 1, item: 44i}),\n            [40, 41, 42, 43, 44]);\n-        t!(vec!(Weighted { weight: 1, item: 50},\n-                Weighted { weight: 1, item: 51},\n-                Weighted { weight: 1, item: 52},\n-                Weighted { weight: 1, item: 53},\n-                Weighted { weight: 1, item: 54},\n-                Weighted { weight: 1, item: 55},\n-                Weighted { weight: 1, item: 56}),\n+        t!(vec!(Weighted { weight: 1, item: 50i},\n+                Weighted { weight: 1, item: 51i},\n+                Weighted { weight: 1, item: 52i},\n+                Weighted { weight: 1, item: 53i},\n+                Weighted { weight: 1, item: 54i},\n+                Weighted { weight: 1, item: 55i},\n+                Weighted { weight: 1, item: 56i}),\n            [50, 51, 52, 53, 54, 55, 56]);\n     }\n \n@@ -347,15 +347,15 @@ mod tests {\n     }\n     #[test] #[should_fail]\n     fn test_weighted_choice_zero_weight() {\n-        WeightedChoice::new(&mut [Weighted { weight: 0, item: 0},\n-                                  Weighted { weight: 0, item: 1}]);\n+        WeightedChoice::new(&mut [Weighted { weight: 0, item: 0i},\n+                                  Weighted { weight: 0, item: 1i}]);\n     }\n     #[test] #[should_fail]\n     fn test_weighted_choice_weight_overflows() {\n         let x = (-1) as uint / 2; // x + x + 2 is the overflow\n-        WeightedChoice::new(&mut [Weighted { weight: x, item: 0 },\n-                                  Weighted { weight: 1, item: 1 },\n-                                  Weighted { weight: x, item: 2 },\n-                                  Weighted { weight: 1, item: 3 }]);\n+        WeightedChoice::new(&mut [Weighted { weight: x, item: 0i },\n+                                  Weighted { weight: 1, item: 1i },\n+                                  Weighted { weight: x, item: 2i },\n+                                  Weighted { weight: 1, item: 3i }]);\n     }\n }"}, {"sha": "507cafd28359042ba2e25f2cf6612448efb9a745", "filename": "src/librand/distributions/normal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -158,7 +158,7 @@ mod tests {\n     fn test_normal() {\n         let mut norm = Normal::new(10.0, 10.0);\n         let mut rng = ::test::rng();\n-        for _ in range(0, 1000) {\n+        for _ in range(0u, 1000) {\n             norm.sample(&mut rng);\n             norm.ind_sample(&mut rng);\n         }\n@@ -174,7 +174,7 @@ mod tests {\n     fn test_log_normal() {\n         let mut lnorm = LogNormal::new(10.0, 10.0);\n         let mut rng = ::test::rng();\n-        for _ in range(0, 1000) {\n+        for _ in range(0u, 1000) {\n             lnorm.sample(&mut rng);\n             lnorm.ind_sample(&mut rng);\n         }"}, {"sha": "a6b23957fd6487c7e986fcda4f20ff22e24e32dc", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -42,7 +42,7 @@ use distributions::{Sample, IndependentSample};\n ///     let between = Range::new(10u, 10000u);\n ///     let mut rng = rand::task_rng();\n ///     let mut sum = 0;\n-///     for _ in range(0, 1000) {\n+///     for _ in range(0u, 1000) {\n ///         sum += between.ind_sample(&mut rng);\n ///     }\n ///     println!(\"{}\", sum);\n@@ -172,12 +172,12 @@ mod tests {\n     #[should_fail]\n     #[test]\n     fn test_range_bad_limits_equal() {\n-        Range::new(10, 10);\n+        Range::new(10i, 10i);\n     }\n     #[should_fail]\n     #[test]\n     fn test_range_bad_limits_flipped() {\n-        Range::new(10, 5);\n+        Range::new(10i, 5i);\n     }\n \n     #[test]\n@@ -191,7 +191,7 @@ mod tests {\n                                            (Bounded::min_value(), Bounded::max_value())];\n                    for &(low, high) in v.iter() {\n                         let mut sampler: Range<$ty> = Range::new(low, high);\n-                        for _ in range(0, 1000) {\n+                        for _ in range(0u, 1000) {\n                             let v = sampler.sample(&mut rng);\n                             assert!(low <= v && v < high);\n                             let v = sampler.ind_sample(&mut rng);\n@@ -217,7 +217,7 @@ mod tests {\n                                            (-1e35, 1e35)];\n                    for &(low, high) in v.iter() {\n                         let mut sampler: Range<$ty> = Range::new(low, high);\n-                        for _ in range(0, 1000) {\n+                        for _ in range(0u, 1000) {\n                             let v = sampler.sample(&mut rng);\n                             assert!(low <= v && v < high);\n                             let v = sampler.ind_sample(&mut rng);"}, {"sha": "3fff27d479225554d8755a39c2e58339d9f806a3", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 62, "deletions": 32, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -18,7 +18,8 @@ use core::mem;\n use {Rng, SeedableRng, Rand};\n \n static RAND_SIZE_LEN: u32 = 8;\n-static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n+static RAND_SIZE: u32 = 1 << (RAND_SIZE_LEN as uint);\n+static RAND_SIZE_UINT: uint = 1 << (RAND_SIZE_LEN as uint);\n \n /// A random number generator that uses the ISAAC algorithm[1].\n ///\n@@ -31,16 +32,16 @@ static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n /// generator*](http://www.burtleburtle.net/bob/rand/isaacafa.html)\n pub struct IsaacRng {\n     cnt: u32,\n-    rsl: [u32, .. RAND_SIZE],\n-    mem: [u32, .. RAND_SIZE],\n+    rsl: [u32, ..RAND_SIZE_UINT],\n+    mem: [u32, ..RAND_SIZE_UINT],\n     a: u32,\n     b: u32,\n     c: u32\n }\n static EMPTY: IsaacRng = IsaacRng {\n     cnt: 0,\n-    rsl: [0, .. RAND_SIZE],\n-    mem: [0, .. RAND_SIZE],\n+    rsl: [0, ..RAND_SIZE_UINT],\n+    mem: [0, ..RAND_SIZE_UINT],\n     a: 0, b: 0, c: 0\n };\n \n@@ -79,7 +80,9 @@ impl IsaacRng {\n             }}\n         );\n \n-        for _ in range(0, 4) { mix!(); }\n+        for _ in range(0u, 4) {\n+            mix!();\n+        }\n \n         if use_rsl {\n             macro_rules! memloop (\n@@ -115,43 +118,54 @@ impl IsaacRng {\n \n     /// Refills the output buffer (`self.rsl`)\n     #[inline]\n+    #[allow(unsigned_negate)]\n     fn isaac(&mut self) {\n         self.c += 1;\n         // abbreviations\n         let mut a = self.a;\n         let mut b = self.b + self.c;\n \n-        static MIDPOINT: uint = RAND_SIZE as uint / 2;\n+        static MIDPOINT: uint = (RAND_SIZE / 2) as uint;\n \n         macro_rules! ind (($x:expr) => {\n-            self.mem[(($x >> 2) & (RAND_SIZE - 1)) as uint]\n+            self.mem[(($x >> 2) as uint & ((RAND_SIZE - 1) as uint))]\n         });\n-        macro_rules! rngstep(\n+        macro_rules! rngstepp(\n             ($j:expr, $shift:expr) => {{\n                 let base = $j;\n-                let mix = if $shift < 0 {\n-                    a >> -$shift as uint\n-                } else {\n-                    a << $shift as uint\n-                };\n+                let mix = a << $shift as uint;\n \n                 let x = self.mem[base  + mr_offset];\n                 a = (a ^ mix) + self.mem[base + m2_offset];\n                 let y = ind!(x) + a + b;\n                 self.mem[base + mr_offset] = y;\n \n-                b = ind!(y >> RAND_SIZE_LEN) + x;\n+                b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n+                self.rsl[base + mr_offset] = b;\n+            }}\n+        );\n+        macro_rules! rngstepn(\n+            ($j:expr, $shift:expr) => {{\n+                let base = $j;\n+                let mix = a >> $shift as uint;\n+\n+                let x = self.mem[base  + mr_offset];\n+                a = (a ^ mix) + self.mem[base + m2_offset];\n+                let y = ind!(x) + a + b;\n+                self.mem[base + mr_offset] = y;\n+\n+                b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n                 self.rsl[base + mr_offset] = b;\n             }}\n         );\n \n         let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n         for &(mr_offset, m2_offset) in r.iter() {\n             for i in range_step(0u, MIDPOINT, 4) {\n-                rngstep!(i + 0, 13);\n-                rngstep!(i + 1, -6);\n-                rngstep!(i + 2, 2);\n-                rngstep!(i + 3, -16);\n+                rngstepp!(i + 0, 13);\n+                rngstepn!(i + 1, 6);\n+                rngstepp!(i + 2, 2);\n+                rngstepn!(i + 3, 16);\n             }\n         }\n \n@@ -286,7 +300,10 @@ impl Isaac64Rng {\n             }}\n         );\n \n-        for _ in range(0, 4) { mix!(); }\n+        for _ in range(0u, 4) {\n+            mix!();\n+        }\n+\n         if use_rsl {\n             macro_rules! memloop (\n                 ($arr:expr) => {{\n@@ -332,14 +349,27 @@ impl Isaac64Rng {\n                 *self.mem.unsafe_ref(($x as uint >> 3) & (RAND_SIZE_64 - 1))\n             }\n         );\n-        macro_rules! rngstep(\n+        macro_rules! rngstepp(\n+            ($j:expr, $shift:expr) => {{\n+                let base = base + $j;\n+                let mix = a ^ (a << $shift as uint);\n+                let mix = if $j == 0 {!mix} else {mix};\n+\n+                unsafe {\n+                    let x = *self.mem.unsafe_ref(base + mr_offset);\n+                    a = mix + *self.mem.unsafe_ref(base + m2_offset);\n+                    let y = ind!(x) + a + b;\n+                    self.mem.unsafe_set(base + mr_offset, y);\n+\n+                    b = ind!(y >> RAND_SIZE_64_LEN) + x;\n+                    self.rsl.unsafe_set(base + mr_offset, b);\n+                }\n+            }}\n+        );\n+        macro_rules! rngstepn(\n             ($j:expr, $shift:expr) => {{\n                 let base = base + $j;\n-                let mix = a ^ (if $shift < 0 {\n-                    a >> -$shift as uint\n-                } else {\n-                    a << $shift as uint\n-                });\n+                let mix = a ^ (a >> $shift as uint);\n                 let mix = if $j == 0 {!mix} else {mix};\n \n                 unsafe {\n@@ -356,10 +386,10 @@ impl Isaac64Rng {\n \n         for &(mr_offset, m2_offset) in MP_VEC.iter() {\n             for base in range(0, MIDPOINT / 4).map(|i| i * 4) {\n-                rngstep!(0, 21);\n-                rngstep!(1, -5);\n-                rngstep!(2, 12);\n-                rngstep!(3, -33);\n+                rngstepp!(0, 21);\n+                rngstepn!(1, 5);\n+                rngstepp!(2, 12);\n+                rngstepn!(3, 33);\n             }\n         }\n \n@@ -515,7 +545,7 @@ mod test {\n         let seed = &[12345, 67890, 54321, 9876];\n         let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n         // skip forward to the 10000th number\n-        for _ in range(0, 10000) { rb.next_u32(); }\n+        for _ in range(0u, 10000) { rb.next_u32(); }\n \n         let v = Vec::from_fn(10, |_| rb.next_u32());\n         assert_eq!(v,\n@@ -537,7 +567,7 @@ mod test {\n         let seed = &[12345, 67890, 54321, 9876];\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n         // skip forward to the 10000th number\n-        for _ in range(0, 10000) { rb.next_u64(); }\n+        for _ in range(0u, 10000) { rb.next_u64(); }\n \n         let v = Vec::from_fn(10, |_| rb.next_u64());\n         assert_eq!(v,"}, {"sha": "769b23a7e7bf9ea1254bb581d71b421345d993db", "filename": "src/librand/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -180,7 +180,7 @@ pub trait Rng {\n     /// let mut rng = task_rng();\n     /// let n: uint = rng.gen_range(0u, 10);\n     /// println!(\"{}\", n);\n-    /// let m: f64 = rng.gen_range(-40.0, 1.3e5);\n+    /// let m: f64 = rng.gen_range(-40.0f64, 1.3e5f64);\n     /// println!(\"{}\", m);\n     /// ```\n     fn gen_range<T: PartialOrd + SampleRange>(&mut self, low: T, high: T) -> T {\n@@ -225,7 +225,7 @@ pub trait Rng {\n     /// ```\n     /// use std::rand::{task_rng, Rng};\n     ///\n-    /// let choices = [1, 2, 4, 8, 16, 32];\n+    /// let choices = [1i, 2, 4, 8, 16, 32];\n     /// let mut rng = task_rng();\n     /// println!(\"{}\", rng.choose(choices));\n     /// assert_eq!(rng.choose(choices.slice_to(0)), None);\n@@ -252,7 +252,7 @@ pub trait Rng {\n     /// use std::rand::{task_rng, Rng};\n     ///\n     /// let mut rng = task_rng();\n-    /// let mut y = [1,2,3];\n+    /// let mut y = [1i, 2, 3];\n     /// rng.shuffle(y);\n     /// println!(\"{}\", y.as_slice());\n     /// rng.shuffle(y);"}, {"sha": "3dd054cee9d1e6b8f9f25c598f4f4a966fdfa45a", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -244,7 +244,7 @@ mod tests {\n         // this is unlikely to catch an incorrect implementation that\n         // generates exactly 0 or 1, but it keeps it sane.\n         let mut rng = task_rng();\n-        for _ in range(0, 1_000) {\n+        for _ in range(0u, 1_000) {\n             // strict inequalities\n             let Open01(f) = rng.gen::<Open01<f64>>();\n             assert!(0.0 < f && f < 1.0);\n@@ -257,7 +257,7 @@ mod tests {\n     #[test]\n     fn rand_closed() {\n         let mut rng = task_rng();\n-        for _ in range(0, 1_000) {\n+        for _ in range(0u, 1_000) {\n             // strict inequalities\n             let Closed01(f) = rng.gen::<Closed01<f64>>();\n             assert!(0.0 <= f && f <= 1.0);"}, {"sha": "7a237670890cae68e37dbdad31478cc639a9d830", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -184,7 +184,7 @@ mod test {\n         let mut rs = ReseedingRng::new(Counter {i:0}, 400, ReseedWithDefault);\n \n         let mut i = 0;\n-        for _ in range(0, 1000) {\n+        for _ in range(0u, 1000) {\n             assert_eq!(rs.next_u32(), i % 100);\n             i += 1;\n         }"}, {"sha": "c487f674c2d52794b58de889ea78556fecd6b850", "filename": "src/librustc/back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fback%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fback%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fsvh.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -100,7 +100,7 @@ impl Svh {\n \n         let hash = state.result();\n         return Svh {\n-            hash: range_step(0, 64, 4).map(|i| hex(hash >> i)).collect()\n+            hash: range_step(0u, 64u, 4u).map(|i| hex(hash >> i)).collect()\n         };\n \n         fn hex(b: u64) -> char {"}, {"sha": "eca0432229e2f961087610374a2d5d6e65123857", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -347,7 +347,7 @@ impl<'a> Context<'a> {\n     fn extract_one(&mut self, m: HashSet<Path>, flavor: &str,\n                    slot: &mut Option<MetadataBlob>) -> Option<Path> {\n         let mut ret = None::<Path>;\n-        let mut error = 0;\n+        let mut error = 0u;\n \n         if slot.is_some() {\n             // FIXME(#10786): for an optimization, we only read one of the"}, {"sha": "4444cac004353dc18bf372388f48f4327a1b3481", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -367,8 +367,8 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n               BiAnd | BiBitAnd => Ok(const_int(a & b)),\n               BiOr | BiBitOr => Ok(const_int(a | b)),\n               BiBitXor => Ok(const_int(a ^ b)),\n-              BiShl => Ok(const_int(a << b)),\n-              BiShr => Ok(const_int(a >> b)),\n+              BiShl => Ok(const_int(a << b as uint)),\n+              BiShr => Ok(const_int(a >> b as uint)),\n               BiEq => fromb(a == b),\n               BiLt => fromb(a < b),\n               BiLe => fromb(a <= b),\n@@ -394,8 +394,8 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n               BiAnd | BiBitAnd => Ok(const_uint(a & b)),\n               BiOr | BiBitOr => Ok(const_uint(a | b)),\n               BiBitXor => Ok(const_uint(a ^ b)),\n-              BiShl => Ok(const_uint(a << b)),\n-              BiShr => Ok(const_uint(a >> b)),\n+              BiShl => Ok(const_uint(a << b as uint)),\n+              BiShr => Ok(const_uint(a >> b as uint)),\n               BiEq => fromb(a == b),\n               BiLt => fromb(a < b),\n               BiLe => fromb(a <= b),\n@@ -407,15 +407,15 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n           // shifts can have any integral type as their rhs\n           (Ok(const_int(a)), Ok(const_uint(b))) => {\n             match op {\n-              BiShl => Ok(const_int(a << b)),\n-              BiShr => Ok(const_int(a >> b)),\n+              BiShl => Ok(const_int(a << b as uint)),\n+              BiShr => Ok(const_int(a >> b as uint)),\n               _ => Err(\"can't do this op on an int and uint\".to_string())\n             }\n           }\n           (Ok(const_uint(a)), Ok(const_int(b))) => {\n             match op {\n-              BiShl => Ok(const_uint(a << b)),\n-              BiShr => Ok(const_uint(a >> b)),\n+              BiShl => Ok(const_uint(a << b as uint)),\n+              BiShr => Ok(const_uint(a >> b as uint)),\n               _ => Err(\"can't do this op on a uint and int\".to_string())\n             }\n           }"}, {"sha": "5ac85833e221eb3ccbcb47a23c47284ba2acf603", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -595,7 +595,7 @@ fn set_bit(words: &mut [uint], bit: uint) -> bool {\n \n fn bit_str(bit: uint) -> String {\n     let byte = bit >> 8;\n-    let lobits = 1 << (bit & 0xFF);\n+    let lobits = 1u << (bit & 0xFF);\n     format!(\"[{}:{}-{:02x}]\", bit, byte, lobits)\n }\n "}, {"sha": "d862ab39ac1d2543b8610bb6da3e956eda379d1c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -1966,7 +1966,7 @@ impl<'a> Resolver<'a> {\n     /// Resolves all imports for the crate. This method performs the fixed-\n     /// point iteration.\n     fn resolve_imports(&mut self) {\n-        let mut i = 0;\n+        let mut i = 0u;\n         let mut prev_unresolved_imports = 0;\n         loop {\n             debug!(\"(resolving imports) iteration {}, {} imports left\","}, {"sha": "fd76d6d37d10d932709447f110e8c9a6e992c599", "filename": "src/librustc/middle/save/recorder.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Frecorder.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -256,7 +256,7 @@ impl<'a> FmtStrs<'a> {\n         self.check_and_record(Variable,\n                               span,\n                               sub_span,\n-                              svec!(id, name, qualname, value, typ, 0));\n+                              svec!(id, name, qualname, value, typ, 0u));\n     }\n \n     // formal parameters\n@@ -271,7 +271,7 @@ impl<'a> FmtStrs<'a> {\n         self.check_and_record(Variable,\n                               span,\n                               sub_span,\n-                              svec!(id, name, qualname, \"\", typ, 0));\n+                              svec!(id, name, qualname, \"\", typ, 0u));\n     }\n \n     // value is the initialising expression of the static if it is not mut, otherwise \"\".\n@@ -474,7 +474,10 @@ impl<'a> FmtStrs<'a> {\n         self.check_and_record(Inheritance,\n                               span,\n                               sub_span,\n-                              svec!(base_id.node, base_id.krate, deriv_id, 0));\n+                              svec!(base_id.node,\n+                                    base_id.krate,\n+                                    deriv_id,\n+                                    0u));\n     }\n \n     pub fn fn_call_str(&mut self,\n@@ -516,7 +519,7 @@ impl<'a> FmtStrs<'a> {\n         self.record_with_span(ModRef,\n                               span,\n                               sub_span,\n-                              svec!(0, 0, qualname, parent));\n+                              svec!(0u, 0u, qualname, parent));\n     }\n \n     pub fn typedef_str(&mut self,\n@@ -557,7 +560,7 @@ impl<'a> FmtStrs<'a> {\n         self.record_with_span(TypeRef,\n                               span,\n                               sub_span,\n-                              svec!(0, 0, qualname, 0));\n+                              svec!(0u, 0u, qualname, 0u));\n     }\n \n     // A slightly generic function for a reference to an item of any kind."}, {"sha": "d21ee37f2912ef11d570f57ff104810dbc455de9", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -578,6 +578,7 @@ fn load_discr(bcx: &Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n     assert_eq!(val_ty(ptr), llty.ptr_to());\n     let bits = machine::llbitsize_of_real(bcx.ccx(), llty);\n     assert!(bits <= 64);\n+    let  bits = bits as uint;\n     let mask = (-1u64 >> (64 - bits)) as Disr;\n     if (max + 1) & mask == min & mask {\n         // i.e., if the range is everything.  The lo==hi case would be"}, {"sha": "ba13ab05d7cf6150418fb17d2eb15dc285f611f6", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -2095,7 +2095,9 @@ impl EnumMemberDescriptionFactory {\n                 let null_variant_index = (1 - non_null_variant_index) as uint;\n                 let null_variant_ident = self.variants.get(null_variant_index).name;\n                 let null_variant_name = token::get_ident(null_variant_ident);\n-                let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\", 0, null_variant_name);\n+                let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n+                                                0u,\n+                                                null_variant_name);\n \n                 // Finally create the (singleton) list of descriptions of union\n                 // members.\n@@ -3150,7 +3152,7 @@ fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n \n     match debug_location {\n         KnownLocation { scope, line, .. } => {\n-            let col = 0; // Always set the column to zero like Clang and GCC\n+            let col = 0u; // Always set the column to zero like Clang and GCC\n             debug!(\"setting debug location to {} {}\", line, col);\n             let elements = [C_i32(cx, line as i32), C_i32(cx, col as i32), scope, ptr::null()];\n             unsafe {"}, {"sha": "2359f9d72d2b734ac7b779cdd66378ea68b617f0", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -65,7 +65,9 @@ pub fn coerce(fcx: &FnCtxt, sp: Span, expected: ty::t, expr: &ast::Expr) {\n            expected.repr(fcx.ccx.tcx),\n            expr_ty.repr(fcx.ccx.tcx));\n     let expected = if ty::type_needs_infer(expected) {\n-        resolve_type(fcx.infcx(), expected,\n+        resolve_type(fcx.infcx(),\n+                     None,\n+                     expected,\n                      try_resolve_tvar_shallow).unwrap_or(expected)\n     } else { expected };\n     match fcx.mk_assignty(expr, expr_ty, expected) {"}, {"sha": "647b099a10a550501af9a265500abd35a200427b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 320, "deletions": 219, "changes": 539, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -169,6 +169,19 @@ pub struct Inherited<'a> {\n     upvar_borrow_map: RefCell<ty::UpvarBorrowMap>,\n }\n \n+/// When type-checking an expression, we propagate downward\n+/// whatever type hint we are able in the form of an `Expectation`.\n+enum Expectation {\n+    /// We know nothing about what type this expression should have.\n+    NoExpectation,\n+\n+    /// This expression should have the type given (or some subtype)\n+    ExpectHasType(ty::t),\n+\n+    /// This expression will be cast to the `ty::t`\n+    ExpectCastableToType(ty::t),\n+}\n+\n #[deriving(Clone)]\n pub struct FnStyleState {\n     pub def: ast::NodeId,\n@@ -492,7 +505,7 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n         visit.visit_block(body, ());\n     }\n \n-    check_block_with_expected(&fcx, body, Some(ret_ty));\n+    check_block_with_expected(&fcx, body, ExpectHasType(ret_ty));\n \n     // We unify the tail expr's type with the\n     // function result type, if there is a tail expr.\n@@ -1708,7 +1721,11 @@ fn write_call(fcx: &FnCtxt, call_expr: &ast::Expr, output: ty::t) {\n }\n \n // AST fragment checking\n-pub fn check_lit(fcx: &FnCtxt, lit: &ast::Lit) -> ty::t {\n+fn check_lit(fcx: &FnCtxt,\n+             lit: &ast::Lit,\n+             expected: Expectation)\n+             -> ty::t\n+{\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n@@ -1721,15 +1738,29 @@ pub fn check_lit(fcx: &FnCtxt, lit: &ast::Lit) -> ty::t {\n         ast::LitInt(_, t) => ty::mk_mach_int(t),\n         ast::LitUint(_, t) => ty::mk_mach_uint(t),\n         ast::LitIntUnsuffixed(_) => {\n-            // An unsuffixed integer literal could have any integral type,\n-            // so we create an integral type variable for it.\n-            ty::mk_int_var(tcx, fcx.infcx().next_int_var_id())\n+            let opt_ty = expected.map_to_option(fcx, |sty| {\n+                match *sty {\n+                    ty::ty_int(i) => Some(ty::mk_mach_int(i)),\n+                    ty::ty_uint(i) => Some(ty::mk_mach_uint(i)),\n+                    ty::ty_char => Some(ty::mk_mach_uint(ast::TyU8)),\n+                    ty::ty_ptr(..) => Some(ty::mk_mach_uint(ast::TyU)),\n+                    ty::ty_bare_fn(..) => Some(ty::mk_mach_uint(ast::TyU)),\n+                    _ => None\n+                }\n+            });\n+            opt_ty.unwrap_or_else(\n+                || ty::mk_int_var(tcx, fcx.infcx().next_int_var_id()))\n         }\n         ast::LitFloat(_, t) => ty::mk_mach_float(t),\n         ast::LitFloatUnsuffixed(_) => {\n-            // An unsuffixed floating point literal could have any floating point\n-            // type, so we create a floating point type variable for it.\n-            ty::mk_float_var(tcx, fcx.infcx().next_float_var_id())\n+            let opt_ty = expected.map_to_option(fcx, |sty| {\n+                match *sty {\n+                    ty::ty_float(i) => Some(ty::mk_mach_float(i)),\n+                    _ => None\n+                }\n+            });\n+            opt_ty.unwrap_or_else(\n+                || ty::mk_float_var(tcx, fcx.infcx().next_float_var_id()))\n         }\n         ast::LitNil => ty::mk_nil(),\n         ast::LitBool(_) => ty::mk_bool()\n@@ -1746,43 +1777,51 @@ pub fn valid_range_bounds(ccx: &CrateCtxt,\n     }\n }\n \n-pub fn check_expr_has_type(\n-    fcx: &FnCtxt, expr: &ast::Expr,\n-    expected: ty::t) {\n-    check_expr_with_unifier(fcx, expr, Some(expected), NoPreference, || {\n-        demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr));\n-    });\n+pub fn check_expr_has_type(fcx: &FnCtxt,\n+                           expr: &ast::Expr,\n+                           expected: ty::t) {\n+    check_expr_with_unifier(\n+        fcx, expr, ExpectHasType(expected), NoPreference,\n+        || demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr)));\n }\n \n-fn check_expr_coercable_to_type(fcx: &FnCtxt, expr: &ast::Expr, expected: ty::t) {\n-    check_expr_with_unifier(fcx, expr, Some(expected), NoPreference, || {\n-        demand::coerce(fcx, expr.span, expected, expr)\n-    });\n+fn check_expr_coercable_to_type(fcx: &FnCtxt,\n+                                expr: &ast::Expr,\n+                                expected: ty::t) {\n+    check_expr_with_unifier(\n+        fcx, expr, ExpectHasType(expected), NoPreference,\n+        || demand::coerce(fcx, expr.span, expected, expr));\n }\n \n fn check_expr_with_hint(fcx: &FnCtxt, expr: &ast::Expr, expected: ty::t) {\n-    check_expr_with_unifier(fcx, expr, Some(expected), NoPreference, || ())\n+    check_expr_with_unifier(\n+        fcx, expr, ExpectHasType(expected), NoPreference,\n+        || ())\n }\n \n-fn check_expr_with_opt_hint(fcx: &FnCtxt, expr: &ast::Expr,\n-                            expected: Option<ty::t>)  {\n-    check_expr_with_unifier(fcx, expr, expected, NoPreference, || ())\n+fn check_expr_with_expectation(fcx: &FnCtxt,\n+                               expr: &ast::Expr,\n+                               expected: Expectation) {\n+    check_expr_with_unifier(\n+        fcx, expr, expected, NoPreference,\n+        || ())\n }\n \n-fn check_expr_with_opt_hint_and_lvalue_pref(fcx: &FnCtxt,\n+fn check_expr_with_expectation_and_lvalue_pref(fcx: &FnCtxt,\n                                             expr: &ast::Expr,\n-                                            expected: Option<ty::t>,\n-                                            lvalue_pref: LvaluePreference) {\n+                                            expected: Expectation,\n+                                            lvalue_pref: LvaluePreference)\n+{\n     check_expr_with_unifier(fcx, expr, expected, lvalue_pref, || ())\n }\n \n fn check_expr(fcx: &FnCtxt, expr: &ast::Expr)  {\n-    check_expr_with_unifier(fcx, expr, None, NoPreference, || ())\n+    check_expr_with_unifier(fcx, expr, NoExpectation, NoPreference, || ())\n }\n \n fn check_expr_with_lvalue_pref(fcx: &FnCtxt, expr: &ast::Expr,\n                                lvalue_pref: LvaluePreference)  {\n-    check_expr_with_unifier(fcx, expr, None, lvalue_pref, || ())\n+    check_expr_with_unifier(fcx, expr, NoExpectation, lvalue_pref, || ())\n }\n \n \n@@ -1863,9 +1902,10 @@ enum TupleArgumentsFlag {\n /// `ty_bot`, so avoid that when err and bot need to be handled differently.\n fn check_expr_with_unifier(fcx: &FnCtxt,\n                            expr: &ast::Expr,\n-                           expected: Option<ty::t>,\n+                           expected: Expectation,\n                            lvalue_pref: LvaluePreference,\n-                           unifier: ||) {\n+                           unifier: ||)\n+{\n     debug!(\">> typechecking\");\n \n     // A generic function for doing all of the checking for call expressions\n@@ -2001,14 +2041,27 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                        opt_else_expr: Option<Gc<ast::Expr>>,\n                        id: ast::NodeId,\n                        sp: Span,\n-                       expected: Option<ty::t>) {\n+                       expected: Expectation) {\n         check_expr_has_type(fcx, cond_expr, ty::mk_bool());\n \n         let branches_ty = match opt_else_expr {\n             Some(ref else_expr) => {\n+                // Disregard \"castable to\" expectations because they\n+                // can lead us astray. Consider for example `if cond\n+                // {22} else {c} as u8` -- if we propagate the\n+                // \"castable to u8\" constraint to 22, it will pick the\n+                // type 22u8, which is overly constrained (c might not\n+                // be a u8). In effect, the problem is that the\n+                // \"castable to\" expectation is not the tightest thing\n+                // we can say, so we want to drop it in this case.\n+                // The tightest thing we can say is \"must unify with\n+                // else branch\". Note that in the case of a \"has type\"\n+                // constraint, this limitation does not hold.\n+                let expected = expected.only_has_type();\n+\n                 check_block_with_expected(fcx, then_blk, expected);\n                 let then_ty = fcx.node_ty(then_blk.id);\n-                check_expr_with_opt_hint(fcx, &**else_expr, expected);\n+                check_expr_with_expectation(fcx, &**else_expr, expected);\n                 let else_ty = fcx.expr_ty(&**else_expr);\n                 infer::common_supertype(fcx.infcx(),\n                                         infer::IfExpression(sp),\n@@ -2101,10 +2154,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                fcx.expr_ty(&*lhs));\n \n         if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op) {\n-            // Shift is a special case: rhs can be any integral type\n-            check_expr(fcx, &*rhs);\n-            let rhs_t = fcx.expr_ty(&*rhs);\n-            require_integral(fcx, rhs.span, rhs_t);\n+            // Shift is a special case: rhs must be uint, no matter what lhs is\n+            check_expr_has_type(fcx, rhs, ty::mk_uint());\n             fcx.write_ty(expr.id, lhs_t);\n             return;\n         }\n@@ -2243,40 +2294,18 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         })\n     }\n \n-    // Resolves `expected` by a single level if it is a variable and passes it\n-    // through the `unpack` function.  It there is no expected type or\n-    // resolution is not possible (e.g., no constraints yet present), just\n-    // returns `none`.\n-    fn unpack_expected<O>(\n-                       fcx: &FnCtxt,\n-                       expected: Option<ty::t>,\n-                       unpack: |&ty::sty| -> Option<O>)\n-                       -> Option<O> {\n-        match expected {\n-            Some(t) => {\n-                match resolve_type(fcx.infcx(), t, force_tvar) {\n-                    Ok(t) => unpack(&ty::get(t).sty),\n-                    _ => None\n-                }\n-            }\n-            _ => None\n-        }\n-    }\n-\n     fn check_expr_fn(fcx: &FnCtxt,\n                      expr: &ast::Expr,\n                      store: ty::TraitStore,\n                      decl: &ast::FnDecl,\n                      body: ast::P<ast::Block>,\n-                     expected: Option<ty::t>) {\n+                     expected: Expectation) {\n         let tcx = fcx.ccx.tcx;\n \n         // Find the expected input/output types (if any). Substitute\n         // fresh bound regions for any bound regions we find in the\n         // expected types so as to avoid capture.\n-        let expected_sty = unpack_expected(fcx,\n-                                           expected,\n-                                           |x| Some((*x).clone()));\n+        let expected_sty = expected.map_to_option(fcx, |x| Some((*x).clone()));\n         let (expected_sig,\n              expected_onceness,\n              expected_bounds) = {\n@@ -2696,8 +2725,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n           }\n       }\n \n-      ast::ExprLit(ref lit) => {\n-        let typ = check_lit(fcx, &**lit);\n+      ast::ExprLit(lit) => {\n+        let typ = check_lit(fcx, lit, expected);\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprBinary(op, ref lhs, ref rhs) => {\n@@ -2735,21 +2764,31 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         }\n       }\n       ast::ExprUnary(unop, ref oprnd) => {\n-        let exp_inner = unpack_expected(fcx, expected, |sty| {\n+        let expected = expected.only_has_type();\n+        let expected_inner = expected.map(fcx, |sty| {\n             match unop {\n                 ast::UnBox | ast::UnUniq => match *sty {\n-                    ty::ty_box(ty) | ty::ty_uniq(ty) => Some(ty),\n-                    _ => None\n+                    ty::ty_box(ty) | ty::ty_uniq(ty) => {\n+                        ExpectHasType(ty)\n+                    }\n+                    _ => {\n+                        NoExpectation\n+                    }\n                 },\n-                ast::UnNot | ast::UnNeg => expected,\n-                ast::UnDeref => None\n+                ast::UnNot | ast::UnNeg => {\n+                    expected\n+                }\n+                ast::UnDeref => {\n+                    NoExpectation\n+                }\n             }\n         });\n         let lvalue_pref = match unop {\n             ast::UnDeref => lvalue_pref,\n             _ => NoPreference\n         };\n-        check_expr_with_opt_hint_and_lvalue_pref(fcx, &**oprnd, exp_inner, lvalue_pref);\n+        check_expr_with_expectation_and_lvalue_pref(\n+            fcx, &**oprnd, expected_inner, lvalue_pref);\n         let mut oprnd_t = fcx.expr_ty(&**oprnd);\n         if !ty::type_is_error(oprnd_t) && !ty::type_is_bot(oprnd_t) {\n             match unop {\n@@ -2818,15 +2857,19 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         fcx.write_ty(id, oprnd_t);\n       }\n       ast::ExprAddrOf(mutbl, ref oprnd) => {\n-          let hint = unpack_expected(\n-              fcx, expected,\n-              |sty| match *sty { ty::ty_rptr(_, ref mt) => Some(mt.ty),\n-                                 _ => None });\n+        let expected = expected.only_has_type();\n+        let hint = expected.map(fcx, |sty| {\n+            match *sty { ty::ty_rptr(_, ref mt) => ExpectHasType(mt.ty),\n+                         _ => NoExpectation }\n+        });\n         let lvalue_pref = match mutbl {\n             ast::MutMutable => PreferMutLvalue,\n             ast::MutImmutable => NoPreference\n         };\n-        check_expr_with_opt_hint_and_lvalue_pref(fcx, &**oprnd, hint, lvalue_pref);\n+        check_expr_with_expectation_and_lvalue_pref(fcx,\n+                                                    &**oprnd,\n+                                                    hint,\n+                                                    lvalue_pref);\n \n         // Note: at this point, we cannot say what the best lifetime\n         // is to use for resulting pointer.  We want to use the\n@@ -2890,9 +2933,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         }\n         fcx.write_bot(id);\n       }\n-      ast::ExprParen(ref a) => {\n-        check_expr_with_opt_hint_and_lvalue_pref(fcx, &**a, expected, lvalue_pref);\n-        fcx.write_ty(id, fcx.expr_ty(&**a));\n+      ast::ExprParen(a) => {\n+        check_expr_with_expectation_and_lvalue_pref(fcx, a, expected, lvalue_pref);\n+        fcx.write_ty(id, fcx.expr_ty(a));\n       }\n       ast::ExprAssign(ref lhs, ref rhs) => {\n         check_expr_with_lvalue_pref(fcx, &**lhs, PreferMutLvalue);\n@@ -3006,133 +3049,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_bot(id);\n         }\n       }\n-      ast::ExprCast(ref e, ref t) => {\n-        check_expr(fcx, &**e);\n-        let t_1 = fcx.to_ty(&**t);\n-        let t_e = fcx.expr_ty(&**e);\n-\n-        debug!(\"t_1={}\", fcx.infcx().ty_to_str(t_1));\n-        debug!(\"t_e={}\", fcx.infcx().ty_to_str(t_e));\n-\n-        if ty::type_is_error(t_e) {\n-            fcx.write_error(id);\n-        }\n-        else if ty::type_is_bot(t_e) {\n-            fcx.write_bot(id);\n-        }\n-        else {\n-            match ty::get(t_1).sty {\n-                // This will be looked up later on\n-                _ if ty::type_is_trait(t_1) => {},\n-\n-                _ => {\n-                    let t_1 = structurally_resolved_type(fcx, e.span, t_1);\n-                    let t_e = structurally_resolved_type(fcx, e.span, t_e);\n-\n-                    if ty::type_is_nil(t_e) {\n-                        fcx.type_error_message(expr.span, |actual| {\n-                            format!(\"cast from nil: `{}` as `{}`\",\n-                                    actual,\n-                                    fcx.infcx().ty_to_str(t_1))\n-                        }, t_e, None);\n-                    } else if ty::type_is_nil(t_1) {\n-                        fcx.type_error_message(expr.span, |actual| {\n-                            format!(\"cast to nil: `{}` as `{}`\",\n-                                    actual,\n-                                    fcx.infcx().ty_to_str(t_1))\n-                        }, t_e, None);\n-                    }\n-\n-                    let t_1_is_scalar = ty::type_is_scalar(t_1);\n-                    let t_1_is_char = ty::type_is_char(t_1);\n-                    let t_1_is_bare_fn = ty::type_is_bare_fn(t_1);\n-                    let t_1_is_float = ty::type_is_floating_point(t_1);\n-\n-                    // casts to scalars other than `char` and `bare fn` are trivial\n-                    let t_1_is_trivial = t_1_is_scalar && !t_1_is_char && !t_1_is_bare_fn;\n-                    if ty::type_is_c_like_enum(fcx.tcx(), t_e) && t_1_is_trivial {\n-                        if t_1_is_float {\n-                            fcx.type_error_message(expr.span, |actual| {\n-                                format!(\"illegal cast; cast through an \\\n-                                         integer first: `{}` as `{}`\",\n-                                        actual,\n-                                        fcx.infcx().ty_to_str(t_1))\n-                            }, t_e, None);\n-                        }\n-                        // casts from C-like enums are allowed\n-                    } else if t_1_is_char {\n-                        let t_e = fcx.infcx().resolve_type_vars_if_possible(t_e);\n-                        if ty::get(t_e).sty != ty::ty_uint(ast::TyU8) {\n-                            fcx.type_error_message(expr.span, |actual| {\n-                                format!(\"only `u8` can be cast as \\\n-                                         `char`, not `{}`\", actual)\n-                            }, t_e, None);\n-                        }\n-                    } else if ty::get(t_1).sty == ty::ty_bool {\n-                        fcx.tcx()\n-                           .sess\n-                           .span_err(expr.span,\n-                                     \"cannot cast as `bool`, compare with \\\n-                                      zero instead\");\n-                    } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n-                        fn is_vec(t: ty::t) -> bool {\n-                            match ty::get(t).sty {\n-                                ty::ty_vec(..) => true,\n-                                ty::ty_ptr(ty::mt{ty: t, ..}) | ty::ty_rptr(_, ty::mt{ty: t, ..}) |\n-                                ty::ty_box(t) | ty::ty_uniq(t) => match ty::get(t).sty {\n-                                    ty::ty_vec(_, None) => true,\n-                                    _ => false,\n-                                },\n-                                _ => false\n-                            }\n-                        }\n-                        fn types_compatible(fcx: &FnCtxt, sp: Span,\n-                                            t1: ty::t, t2: ty::t) -> bool {\n-                            if !is_vec(t1) {\n-                                false\n-                            } else {\n-                                let el = ty::sequence_element_type(fcx.tcx(),\n-                                                                   t1);\n-                                infer::mk_eqty(fcx.infcx(), false,\n-                                               infer::Misc(sp), el, t2).is_ok()\n-                            }\n-                        }\n-\n-                        // Due to the limitations of LLVM global constants,\n-                        // region pointers end up pointing at copies of\n-                        // vector elements instead of the original values.\n-                        // To allow unsafe pointers to work correctly, we\n-                        // need to special-case obtaining an unsafe pointer\n-                        // from a region pointer to a vector.\n-\n-                        /* this cast is only allowed from &[T] to *T or\n-                        &T to *T. */\n-                        match (&ty::get(t_e).sty, &ty::get(t_1).sty) {\n-                            (&ty::ty_rptr(_, ty::mt { ty: mt1, mutbl: ast::MutImmutable }),\n-                             &ty::ty_ptr(ty::mt { ty: mt2, mutbl: ast::MutImmutable }))\n-                            if types_compatible(fcx, e.span, mt1, mt2) => {\n-                                /* this case is allowed */\n-                            }\n-                            _ => {\n-                                demand::coerce(fcx, e.span, t_1, &**e);\n-                            }\n-                        }\n-                    } else if !(ty::type_is_scalar(t_e) && t_1_is_trivial) {\n-                        /*\n-                        If more type combinations should be supported than are\n-                        supported here, then file an enhancement issue and\n-                        record the issue number in this comment.\n-                        */\n-                        fcx.type_error_message(expr.span, |actual| {\n-                            format!(\"non-scalar cast: `{}` as `{}`\",\n-                                    actual,\n-                                    fcx.infcx().ty_to_str(t_1))\n-                        }, t_e, None);\n-                    }\n-                }\n-            }\n-            fcx.write_ty(id, t_1);\n-        }\n+      ast::ExprCast(expr_from, t) => {\n+        let ty_to = fcx.to_ty(t);\n+        debug!(\"ExprCast ty_to={}\", fcx.infcx().ty_to_str(ty_to));\n+        check_cast(fcx, expr_from, ty_to);\n+        fcx.write_ty(id, ty_to);\n       }\n       ast::ExprVec(ref args) => {\n         let t: ty::t = fcx.infcx().next_ty_var();\n@@ -3144,7 +3065,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprRepeat(ref element, ref count_expr) => {\n-        check_expr_with_hint(fcx, &**count_expr, ty::mk_uint());\n+        check_expr_has_type(fcx, &**count_expr, ty::mk_uint());\n         let count = ty::eval_repeat_count(fcx, &**count_expr);\n         let t: ty::t = fcx.infcx().next_ty_var();\n         check_expr_has_type(fcx, &**element, t);\n@@ -3162,7 +3083,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         }\n       }\n       ast::ExprTup(ref elts) => {\n-        let flds = unpack_expected(fcx, expected, |sty| {\n+        let expected = expected.only_has_type();\n+        let flds = expected.map_to_option(fcx, |sty| {\n             match *sty {\n                 ty::ty_tup(ref flds) => Some((*flds).clone()),\n                 _ => None\n@@ -3173,11 +3095,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         let elt_ts = elts.iter().enumerate().map(|(i, e)| {\n             let opt_hint = match flds {\n-                Some(ref fs) if i < fs.len() => Some(*fs.get(i)),\n-                _ => None\n+                Some(ref fs) if i < fs.len() => ExpectHasType(*fs.get(i)),\n+                _ => NoExpectation\n             };\n-            check_expr_with_opt_hint(fcx, &**e, opt_hint);\n-            let t = fcx.expr_ty(&**e);\n+            check_expr_with_expectation(fcx, *e, opt_hint);\n+            let t = fcx.expr_ty(*e);\n             err_field = err_field || ty::type_is_error(t);\n             bot_field = bot_field || ty::type_is_bot(t);\n             t\n@@ -3263,14 +3185,193 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n            syntax::print::pprust::expr_to_str(expr));\n     debug!(\"... {}, expected is {}\",\n            ppaux::ty_to_str(tcx, fcx.expr_ty(expr)),\n-           match expected {\n-               Some(t) => ppaux::ty_to_str(tcx, t),\n-               _ => \"empty\".to_string()\n-           });\n+           expected.repr(tcx))\n \n     unifier();\n }\n \n+impl Expectation {\n+    fn only_has_type(self) -> Expectation {\n+        match self {\n+            NoExpectation | ExpectCastableToType(..) => NoExpectation,\n+            ExpectHasType(t) => ExpectHasType(t)\n+        }\n+    }\n+\n+    // Resolves `expected` by a single level if it is a variable. If\n+    // there is no expected type or resolution is not possible (e.g.,\n+    // no constraints yet present), just returns `None`.\n+    fn resolve(self, fcx: &FnCtxt) -> Expectation {\n+        match self {\n+            NoExpectation => {\n+                NoExpectation\n+            }\n+            ExpectCastableToType(t) => {\n+                ExpectCastableToType(\n+                    fcx.infcx().resolve_type_vars_if_possible(t))\n+            }\n+            ExpectHasType(t) => {\n+                ExpectHasType(\n+                    fcx.infcx().resolve_type_vars_if_possible(t))\n+            }\n+        }\n+    }\n+\n+    fn map(self, fcx: &FnCtxt, unpack: |&ty::sty| -> Expectation) -> Expectation {\n+        match self.resolve(fcx) {\n+            NoExpectation => NoExpectation,\n+            ExpectCastableToType(t) | ExpectHasType(t) => unpack(&ty::get(t).sty),\n+        }\n+    }\n+\n+    fn map_to_option<O>(self,\n+                        fcx: &FnCtxt,\n+                        unpack: |&ty::sty| -> Option<O>)\n+                        -> Option<O>\n+    {\n+        match self.resolve(fcx) {\n+            NoExpectation => None,\n+            ExpectCastableToType(t) | ExpectHasType(t) => unpack(&ty::get(t).sty),\n+        }\n+    }\n+}\n+\n+impl Repr for Expectation {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        match *self {\n+            NoExpectation => format!(\"NoExpectation\"),\n+            ExpectHasType(t) => format!(\"ExpectHasType({})\",\n+                                        t.repr(tcx)),\n+            ExpectCastableToType(t) => format!(\"ExpectCastableToType({})\",\n+                                               t.repr(tcx)),\n+        }\n+    }\n+}\n+\n+fn check_cast(fcx: &FnCtxt, expr_from: Gc<ast::Expr>, ty_to: ty::t) {\n+    // Find the type of `expr_from`. Supply hints based on the type\n+    // we are casting to, if appropriate.\n+    let ty_to = structurally_resolved_type(fcx, expr_from.span, ty_to);\n+    if ty::type_is_scalar(ty_to) {\n+        // Supply the type as a hint so as to influence integer\n+        // literals and other things that might care.\n+        check_expr_with_hint(fcx, expr_from, ty_to)\n+    } else {\n+        check_expr(fcx, expr_from)\n+    }\n+    let ty_from = fcx.expr_ty(expr_from);\n+\n+    // Object creation is checked during the vtable phase.\n+    if ty::type_is_trait(ty_to) {\n+        check_expr(fcx, expr_from);\n+        return;\n+    }\n+\n+    let ty_from = fcx.infcx().resolve_type_vars_if_possible(ty_from);\n+\n+    if ty::type_is_nil(ty_from) {\n+        fcx.type_error_message(expr_from.span, |actual| {\n+            format!(\"cast from nil: `{}` as `{}`\", actual,\n+                    fcx.infcx().ty_to_str(ty_to))\n+        }, ty_from, None);\n+        return;\n+    }\n+\n+    if ty::type_is_nil(ty_to) {\n+        fcx.type_error_message(expr_from.span, |actual| {\n+            format!(\"cast to nil: `{}` as `{}`\", actual,\n+                    fcx.infcx().ty_to_str(ty_to))\n+        }, ty_from, None);\n+        return;\n+    }\n+\n+    let t_e = structurally_resolved_type(fcx, expr_from.span, ty_from);\n+    let t_1 = structurally_resolved_type(fcx, expr_from.span, ty_to);\n+\n+    let to_is_scalar = ty::type_is_scalar(t_1);\n+    let to_is_float = ty::type_is_floating_point(t_1);\n+    let to_is_char = ty::type_is_char(t_1);\n+    let to_is_bare_fn = ty::type_is_bare_fn(t_1);\n+\n+    // casts to scalars other than `char` and `bare fn` are trivial\n+    let to_is_trivial = to_is_scalar &&\n+        !to_is_char && !to_is_bare_fn;\n+\n+    if ty::type_is_c_like_enum(fcx.tcx(), t_e) && to_is_trivial {\n+        if to_is_float {\n+            fcx.type_error_message(expr_from.span, |actual| {\n+                format!(\"illegal cast; cast through an integer first: `{}` \\\n+                         as `{}`\",\n+                        actual,\n+                        fcx.infcx().ty_to_str(t_1))\n+            }, ty_from, None);\n+        }\n+        // casts from C-like enums are allowed\n+    } else if to_is_char {\n+        if ty::get(ty_from).sty != ty::ty_uint(ast::TyU8) {\n+            fcx.type_error_message(expr_from.span, |actual| {\n+                format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n+            }, ty_from, None);\n+        }\n+    } else if ty::type_is_bool(t_1) {\n+        fcx.tcx().sess.span_err(expr_from.span,\n+                                \"cannot cast as `bool`, compare with zero instead\");\n+    } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n+        fn is_vec(t: ty::t) -> bool {\n+            match ty::get(t).sty {\n+                ty::ty_vec(..) => true,\n+                ty::ty_ptr(ty::mt{ty: t, ..}) |\n+                ty::ty_rptr(_, ty::mt{ty: t, ..}) |\n+                ty::ty_box(t) |\n+                ty::ty_uniq(t) => match ty::get(t).sty {\n+                    ty::ty_vec(_, None) => true,\n+                    _ => false,\n+                },\n+                _ => false\n+            }\n+        }\n+        fn types_compatible(fcx: &FnCtxt, sp: Span,\n+                            t1: ty::t, t2: ty::t) -> bool {\n+            if !is_vec(t1) {\n+                false\n+            } else {\n+                let el = ty::sequence_element_type(fcx.tcx(),\n+                                                   t1);\n+                infer::mk_eqty(fcx.infcx(), false,\n+                               infer::Misc(sp), el, t2).is_ok()\n+            }\n+        }\n+\n+        // Due to the limitations of LLVM global constants,\n+        // region pointers end up pointing at copies of\n+        // vector elements instead of the original values.\n+        // To allow unsafe pointers to work correctly, we\n+        // need to special-case obtaining an unsafe pointer\n+        // from a region pointer to a vector.\n+\n+        /* this cast is only allowed from &[T] to *T or\n+        &T to *T. */\n+        match (&ty::get(t_e).sty, &ty::get(t_1).sty) {\n+            (&ty::ty_rptr(_, ty::mt { ty: mt1, mutbl: ast::MutImmutable }),\n+             &ty::ty_ptr(ty::mt { ty: mt2, mutbl: ast::MutImmutable }))\n+                if types_compatible(fcx, expr_from.span, mt1, mt2) => {\n+                    /* this case is allowed */\n+                }\n+            _ => {\n+                demand::coerce(fcx, expr_from.span, ty_to, expr_from);\n+            }\n+        }\n+    } else if !(ty::type_is_scalar(t_e) && to_is_trivial) {\n+        // If more type combinations should be supported than are\n+        // supported here, then file an enhancement issue and\n+        // record the issue number in this comment.\n+        fcx.type_error_message(expr_from.span, |actual| {\n+            format!(\"non-scalar cast: `{}` as `{}`\", actual,\n+                    fcx.infcx().ty_to_str(ty_to))\n+        }, ty_from, None);\n+    }\n+}\n+\n pub fn require_uint(fcx: &FnCtxt, sp: Span, t: ty::t) {\n     if !type_is_uint(fcx, sp, t) {\n         fcx.type_error_message(sp, |actual| {\n@@ -3371,7 +3472,7 @@ pub fn check_stmt(fcx: &FnCtxt, stmt: &ast::Stmt)  {\n }\n \n pub fn check_block_no_value(fcx: &FnCtxt, blk: &ast::Block)  {\n-    check_block_with_expected(fcx, blk, Some(ty::mk_nil()));\n+    check_block_with_expected(fcx, blk, ExpectHasType(ty::mk_nil()));\n     let blkty = fcx.node_ty(blk.id);\n     if ty::type_is_error(blkty) {\n         fcx.write_error(blk.id);\n@@ -3385,9 +3486,9 @@ pub fn check_block_no_value(fcx: &FnCtxt, blk: &ast::Block)  {\n     }\n }\n \n-pub fn check_block_with_expected(fcx: &FnCtxt,\n-                                 blk: &ast::Block,\n-                                 expected: Option<ty::t>) {\n+fn check_block_with_expected(fcx: &FnCtxt,\n+                             blk: &ast::Block,\n+                             expected: Expectation) {\n     let prev = {\n         let mut fcx_ps = fcx.ps.borrow_mut();\n         let fn_style_state = fcx_ps.recurse(blk);\n@@ -3448,8 +3549,8 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n                              e.span,\n                              \"unreachable expression\".to_string());\n             }\n-            check_expr_with_opt_hint(fcx, &*e, expected);\n-              let ety = fcx.expr_ty(&*e);\n+            check_expr_with_expectation(fcx, e, expected);\n+              let ety = fcx.expr_ty(e);\n               fcx.write_ty(blk.id, ety);\n               if any_err {\n                   fcx.write_error(blk.id);\n@@ -4170,7 +4271,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n // resolution is possible, then an error is reported.\n pub fn structurally_resolved_type(fcx: &FnCtxt, sp: Span, tp: ty::t) -> ty::t {\n-    match infer::resolve_type(fcx.infcx(), tp, force_tvar) {\n+    match infer::resolve_type(fcx.infcx(), Some(sp), tp, force_tvar) {\n         Ok(t_s) if !ty::type_is_ty_var(t_s) => t_s,\n         _ => {\n             fcx.type_error_message(sp, |_actual| {"}, {"sha": "07fb43d0d34dfdb824b55b89e123f6ee9b4769c3", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -228,7 +228,7 @@ impl<'a> Rcx<'a> {\n          * bigger than the let and the `*b` expression, so we will\n          * effectively resolve `<R0>` to be the block B.\n          */\n-        match resolve_type(self.fcx.infcx(), unresolved_ty,\n+        match resolve_type(self.fcx.infcx(), None, unresolved_ty,\n                            resolve_and_force_all_but_regions) {\n             Ok(t) => t,\n             Err(_) => ty::mk_err()"}, {"sha": "7612add9b05704683325ace53e73b9578f536b65", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -481,7 +481,7 @@ fn fixup_ty(vcx: &VtableContext,\n             is_early: bool)\n             -> Option<ty::t> {\n     let tcx = vcx.tcx();\n-    match resolve_type(vcx.infcx, ty, resolve_and_force_all_but_regions) {\n+    match resolve_type(vcx.infcx, Some(span), ty, resolve_and_force_all_but_regions) {\n         Ok(new_type) => Some(new_type),\n         Err(e) if !is_early => {\n             tcx.sess.span_fatal(span,"}, {"sha": "eb43144571e2abc9173e58c0aa05507250fd4f4e", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -456,7 +456,7 @@ impl<'cx> TypeFolder for Resolver<'cx> {\n             return t;\n         }\n \n-        match resolve_type(self.infcx, t, resolve_all | force_all) {\n+        match resolve_type(self.infcx, None, t, resolve_all | force_all) {\n             Ok(t) => t,\n             Err(e) => {\n                 self.report_error(e);"}, {"sha": "32e34d1320eb55b809b017c5fc3b5eeb06d653bc", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -61,6 +61,7 @@ fn get_base_type(inference_context: &InferCtxt,\n                  -> Option<t> {\n     let resolved_type;\n     match resolve_type(inference_context,\n+                       Some(span),\n                        original_type,\n                        resolve_ivar) {\n         Ok(resulting_type) if !type_is_ty_var(resulting_type) => {"}, {"sha": "2b3305442396224e6463a5f73c44583c3dcafae9", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -213,7 +213,8 @@ impl<'f> Coerce<'f> {\n \n     pub fn unpack_actual_value(&self, a: ty::t, f: |&ty::sty| -> CoerceResult)\n                                -> CoerceResult {\n-        match resolve_type(self.get_ref().infcx, a, try_resolve_tvar_shallow) {\n+        match resolve_type(self.get_ref().infcx, None,\n+                           a, try_resolve_tvar_shallow) {\n             Ok(t) => {\n                 f(&ty::get(t).sty)\n             }"}, {"sha": "197a2370eff9e9d4b5cbe852f39f2e62bdda0559", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -238,6 +238,7 @@ pub enum RegionVariableOrigin {\n \n pub enum fixup_err {\n     unresolved_int_ty(IntVid),\n+    unresolved_float_ty(FloatVid),\n     unresolved_ty(TyVid),\n     cyclic_ty(TyVid),\n     unresolved_region(RegionVid),\n@@ -247,6 +248,9 @@ pub enum fixup_err {\n pub fn fixup_err_to_str(f: fixup_err) -> String {\n     match f {\n       unresolved_int_ty(_) => \"unconstrained integral type\".to_string(),\n+      unresolved_float_ty(_) => {\n+          \"unconstrained floating point type\".to_string()\n+      }\n       unresolved_ty(_) => \"unconstrained type\".to_string(),\n       cyclic_ty(_) => \"cyclic type of infinite size\".to_string(),\n       unresolved_region(_) => \"unconstrained region\".to_string(),\n@@ -407,18 +411,17 @@ pub fn mk_coercety(cx: &InferCtxt,\n \n // See comment on the type `resolve_state` below\n pub fn resolve_type(cx: &InferCtxt,\n+                    span: Option<Span>,\n                     a: ty::t,\n                     modes: uint)\n-                 -> fres<ty::t>\n-{\n-    let mut resolver = resolver(cx, modes);\n+                    -> fres<ty::t> {\n+    let mut resolver = resolver(cx, modes, span);\n     cx.commit_unconditionally(|| resolver.resolve_type_chk(a))\n }\n \n pub fn resolve_region(cx: &InferCtxt, r: ty::Region, modes: uint)\n-                   -> fres<ty::Region>\n-{\n-    let mut resolver = resolver(cx, modes);\n+                      -> fres<ty::Region> {\n+    let mut resolver = resolver(cx, modes, None);\n     resolver.resolve_region_chk(r)\n }\n \n@@ -671,9 +674,11 @@ impl<'a> InferCtxt<'a> {\n     }\n \n     pub fn resolve_type_vars_if_possible(&self, typ: ty::t) -> ty::t {\n-        match resolve_type(self, typ, resolve_nested_tvar | resolve_ivar) {\n-            Ok(new_type) => new_type,\n-            Err(_) => typ\n+        match resolve_type(self,\n+                           None,\n+                           typ, resolve_nested_tvar | resolve_ivar) {\n+          Ok(new_type) => new_type,\n+          Err(_) => typ\n         }\n     }\n "}, {"sha": "757b715ec930080f204472e119b953706d5a0f1f", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -1348,7 +1348,7 @@ impl<'a> RegionVarBindings<'a> {\n     fn iterate_until_fixed_point(&self,\n                                  tag: &str,\n                                  body: |constraint: &Constraint| -> bool) {\n-        let mut iteration = 0;\n+        let mut iteration = 0u;\n         let mut changed = true;\n         while changed {\n             changed = false;"}, {"sha": "ed6ea6c96775ebc571ee880845f0daed8e94ee17", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -54,8 +54,9 @@ use middle::ty_fold;\n use middle::typeck::infer::{Bounds, cyclic_ty, fixup_err, fres, InferCtxt};\n use middle::typeck::infer::unresolved_ty;\n use middle::typeck::infer::unify::Root;\n-use util::common::{indent};\n-use util::ppaux::{ty_to_str, Repr};\n+use syntax::codemap::Span;\n+use util::common::indent;\n+use util::ppaux::{Repr, ty_to_str};\n \n use syntax::ast;\n \n@@ -81,16 +82,22 @@ pub struct ResolveState<'a> {\n     modes: uint,\n     err: Option<fixup_err>,\n     v_seen: Vec<TyVid> ,\n-    type_depth: uint\n+    type_depth: uint,\n+    span: Option<Span>,\n }\n \n-pub fn resolver<'a>(infcx: &'a InferCtxt, modes: uint) -> ResolveState<'a> {\n+pub fn resolver<'a>(infcx: &'a InferCtxt,\n+                    modes: uint,\n+                    span: Option<Span>)\n+                    -> ResolveState<'a>\n+{\n     ResolveState {\n         infcx: infcx,\n         modes: modes,\n         err: None,\n         v_seen: Vec::new(),\n-        type_depth: 0\n+        type_depth: 0,\n+        span: span\n     }\n }\n \n@@ -113,7 +120,9 @@ impl<'a> ResolveState<'a> {\n         (self.modes & mode) == mode\n     }\n \n-    pub fn resolve_type_chk(&mut self, typ: ty::t) -> fres<ty::t> {\n+    pub fn resolve_type_chk(&mut self,\n+                            typ: ty::t)\n+                            -> fres<ty::t> {\n         self.err = None;\n \n         debug!(\"Resolving {} (modes={:x})\",\n@@ -138,7 +147,8 @@ impl<'a> ResolveState<'a> {\n         }\n     }\n \n-    pub fn resolve_region_chk(&mut self, orig: ty::Region)\n+    pub fn resolve_region_chk(&mut self,\n+                              orig: ty::Region)\n                               -> fres<ty::Region> {\n         self.err = None;\n         let resolved = indent(|| self.resolve_region(orig) );\n@@ -248,10 +258,20 @@ impl<'a> ResolveState<'a> {\n           Some(UintType(t)) => ty::mk_mach_uint(t),\n           None => {\n             if self.should(force_ivar) {\n-                // As a last resort, default to int.\n+                // As a last resort, default to int and emit an error.\n                 let ty = ty::mk_int();\n                 table.borrow_mut().set(\n                     tcx, node.key, Root(Some(IntType(ast::TyI)), node.rank));\n+\n+                match self.span {\n+                    Some(sp) => {\n+                        self.infcx.tcx.sess.span_err(\n+                            sp,\n+                            \"cannot determine the type of this integer; add \\\n+                             a suffix to specify the type explicitly\");\n+                    }\n+                    None => { }\n+                }\n                 ty\n             } else {\n                 ty::mk_int_var(self.infcx.tcx, vid)\n@@ -272,10 +292,20 @@ impl<'a> ResolveState<'a> {\n           Some(t) => ty::mk_mach_float(t),\n           None => {\n             if self.should(force_fvar) {\n-                // As a last resort, default to f64.\n+                // As a last resort, default to f64 and emit an error.\n                 let ty = ty::mk_f64();\n                 table.borrow_mut().set(\n                     tcx, node.key, Root(Some(ast::TyF64), node.rank));\n+\n+                match self.span {\n+                    Some(sp) => {\n+                        self.infcx.tcx.sess.span_err(\n+                            sp,\n+                            \"cannot determine the type of this number; add \\\n+                             a suffix to specify the type explicitly\");\n+                    }\n+                    None => { }\n+                }\n                 ty\n             } else {\n                 ty::mk_float_var(self.infcx.tcx, vid)"}, {"sha": "0c0bba992a033a0927752e9fd07198482b50fe0f", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -350,10 +350,8 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n       ty_bot => \"!\".to_string(),\n       ty_bool => \"bool\".to_string(),\n       ty_char => \"char\".to_string(),\n-      ty_int(t) => ast_util::int_ty_to_str(t, None,\n-                                           ast_util::AutoSuffix).to_string(),\n-      ty_uint(t) => ast_util::uint_ty_to_str(t, None,\n-                                             ast_util::AutoSuffix).to_string(),\n+      ty_int(t) => ast_util::int_ty_to_str(t, None).to_string(),\n+      ty_uint(t) => ast_util::uint_ty_to_str(t, None).to_string(),\n       ty_float(t) => ast_util::float_ty_to_str(t).to_string(),\n       ty_box(typ) => format!(\"Gc<{}>\", ty_to_str(cx, typ)),\n       ty_uniq(typ) => format!(\"Box<{}>\", ty_to_str(cx, typ)),"}, {"sha": "faddadb832d90dd6a2d6598975299708363e90d2", "filename": "src/librustrt/libunwind.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustrt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustrt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flibunwind.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -57,20 +57,20 @@ pub type _Unwind_Exception_Class = u64;\n pub type _Unwind_Word = libc::uintptr_t;\n \n #[cfg(target_arch = \"x86\")]\n-pub static unwinder_private_data_size: int = 5;\n+pub static unwinder_private_data_size: uint = 5;\n \n #[cfg(target_arch = \"x86_64\")]\n-pub static unwinder_private_data_size: int = 2;\n+pub static unwinder_private_data_size: uint = 2;\n \n #[cfg(target_arch = \"arm\", not(target_os = \"ios\"))]\n-pub static unwinder_private_data_size: int = 20;\n+pub static unwinder_private_data_size: uint = 20;\n \n #[cfg(target_arch = \"arm\", target_os = \"ios\")]\n-pub static unwinder_private_data_size: int = 5;\n+pub static unwinder_private_data_size: uint = 5;\n \n #[cfg(target_arch = \"mips\")]\n #[cfg(target_arch = \"mipsel\")]\n-pub static unwinder_private_data_size: int = 2;\n+pub static unwinder_private_data_size: uint = 2;\n \n pub struct _Unwind_Exception {\n     pub exception_class: _Unwind_Exception_Class,"}, {"sha": "b385f48f33a493a718d96404fc867be8efa2eef0", "filename": "src/librustrt/thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustrt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibrustrt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -333,14 +333,14 @@ mod tests {\n     fn smoke() { Thread::start(proc (){}).join(); }\n \n     #[test]\n-    fn data() { assert_eq!(Thread::start(proc () { 1 }).join(), 1); }\n+    fn data() { assert_eq!(Thread::start(proc () { 1i }).join(), 1); }\n \n     #[test]\n     fn detached() { Thread::spawn(proc () {}) }\n \n     #[test]\n     fn small_stacks() {\n-        assert_eq!(42, Thread::start_stack(0, proc () 42).join());\n-        assert_eq!(42, Thread::start_stack(1, proc () 42).join());\n+        assert_eq!(42i, Thread::start_stack(0, proc () 42i).join());\n+        assert_eq!(42i, Thread::start_stack(1, proc () 42i).join());\n     }\n }"}, {"sha": "ee1e836112e3d5a3c9e15c0cec5f3088b650d440", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -336,7 +336,7 @@ mod tests {\n     fn test_base64_random() {\n         use std::rand::{task_rng, random, Rng};\n \n-        for _ in range(0, 1000) {\n+        for _ in range(0u, 1000) {\n             let times = task_rng().gen_range(1u, 100);\n             let v = Vec::from_fn(times, |_| random::<u8>());\n             assert_eq!(v.as_slice()"}, {"sha": "efee29212e9970dce07c4b56b4d1c78c61fed93c", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -173,7 +173,7 @@ pub mod reader {\n         // the most significant bit is set, the second most significant bit is set etc. we can\n         // replace up to three \"and+branch\" with a single table lookup which gives us a measured\n         // speedup of around 2x on x86_64.\n-        static SHIFT_MASK_TABLE: [(u32, u32), ..16] = [\n+        static SHIFT_MASK_TABLE: [(uint, u32), ..16] = [\n             (0, 0x0), (0, 0x0fffffff),\n             (8, 0x1fffff), (8, 0x1fffff),\n             (16, 0x3fff), (16, 0x3fff), (16, 0x3fff), (16, 0x3fff),"}, {"sha": "2fccbc2fcaf20b443d847c6a2aa13f1ff07f565f", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -173,14 +173,14 @@ mod tests {\n \n     #[test]\n     pub fn test_to_hex_all_bytes() {\n-        for i in range(0, 256) {\n+        for i in range(0u, 256) {\n             assert_eq!([i as u8].to_hex(), format!(\"{:02x}\", i as uint));\n         }\n     }\n \n     #[test]\n     pub fn test_from_hex_all_bytes() {\n-        for i in range(0, 256) {\n+        for i in range(0u, 256) {\n             assert_eq!(format!(\"{:02x}\", i as uint).as_slice()\n                                                    .from_hex()\n                                                    .unwrap()"}, {"sha": "1721bd7ae15e67263faa0903c17fe0c4aa5dcfb0", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -3365,21 +3365,21 @@ mod tests {\n         assert_eq!(true.to_json(), Boolean(true));\n         assert_eq!(false.to_json(), Boolean(false));\n         assert_eq!(\"abc\".to_string().to_json(), String(\"abc\".to_string()));\n-        assert_eq!((1, 2).to_json(), list2);\n-        assert_eq!((1, 2, 3).to_json(), list3);\n-        assert_eq!([1, 2].to_json(), list2);\n-        assert_eq!((&[1, 2, 3]).to_json(), list3);\n-        assert_eq!((vec![1, 2]).to_json(), list2);\n-        assert_eq!(vec!(1, 2, 3).to_json(), list3);\n+        assert_eq!((1i, 2i).to_json(), list2);\n+        assert_eq!((1i, 2i, 3i).to_json(), list3);\n+        assert_eq!([1i, 2].to_json(), list2);\n+        assert_eq!((&[1i, 2, 3]).to_json(), list3);\n+        assert_eq!((vec![1i, 2]).to_json(), list2);\n+        assert_eq!(vec!(1i, 2i, 3i).to_json(), list3);\n         let mut tree_map = TreeMap::new();\n-        tree_map.insert(\"a\".to_string(), 1);\n+        tree_map.insert(\"a\".to_string(), 1i);\n         tree_map.insert(\"b\".to_string(), 2);\n         assert_eq!(tree_map.to_json(), object);\n         let mut hash_map = HashMap::new();\n-        hash_map.insert(\"a\".to_string(), 1);\n+        hash_map.insert(\"a\".to_string(), 1i);\n         hash_map.insert(\"b\".to_string(), 2);\n         assert_eq!(hash_map.to_json(), object);\n-        assert_eq!(Some(15).to_json(), Number(15 as f64));\n+        assert_eq!(Some(15i).to_json(), Number(15 as f64));\n         assert_eq!(None::<int>.to_json(), Null);\n     }\n \n@@ -3420,7 +3420,7 @@ mod tests {\n \n     fn big_json() -> String {\n         let mut src = \"[\\n\".to_string();\n-        for _ in range(0, 500) {\n+        for _ in range(0i, 500) {\n             src.push_str(r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": \\\n                             [1,2,3]},\"#);\n         }"}, {"sha": "d06d4ea71776afa706fd75e330f8fccb8dcd3099", "filename": "src/libstd/collections/hashmap.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -1688,7 +1688,7 @@ mod test_map {\n     fn test_create_capacity_zero() {\n         let mut m = HashMap::with_capacity(0);\n \n-        assert!(m.insert(1, 1));\n+        assert!(m.insert(1i, 1i));\n \n         assert!(m.contains_key(&1));\n         assert!(!m.contains_key(&0));\n@@ -1698,9 +1698,9 @@ mod test_map {\n     fn test_insert() {\n         let mut m = HashMap::new();\n         assert_eq!(m.len(), 0);\n-        assert!(m.insert(1, 2));\n+        assert!(m.insert(1i, 2i));\n         assert_eq!(m.len(), 1);\n-        assert!(m.insert(2, 4));\n+        assert!(m.insert(2i, 4i));\n         assert_eq!(m.len(), 2);\n         assert_eq!(*m.find(&1).unwrap(), 2);\n         assert_eq!(*m.find(&2).unwrap(), 4);\n@@ -1732,7 +1732,7 @@ mod test_map {\n \n     #[test]\n     fn test_drops() {\n-        drop_vector.replace(Some(RefCell::new(Vec::from_elem(200, 0))));\n+        drop_vector.replace(Some(RefCell::new(Vec::from_elem(200, 0i))));\n \n         {\n             let mut m = HashMap::new();\n@@ -1796,10 +1796,10 @@ mod test_map {\n \n         // Try this a few times to make sure we never screw up the hashmap's\n         // internal state.\n-        for _ in range(0, 10) {\n+        for _ in range(0i, 10) {\n             assert!(m.is_empty());\n \n-            for i in range_inclusive(1, 1000) {\n+            for i in range_inclusive(1i, 1000) {\n                 assert!(m.insert(i, i));\n \n                 for j in range_inclusive(1, i) {\n@@ -1813,12 +1813,12 @@ mod test_map {\n                 }\n             }\n \n-            for i in range_inclusive(1001, 2000) {\n+            for i in range_inclusive(1001i, 2000) {\n                 assert!(!m.contains_key(&i));\n             }\n \n             // remove forwards\n-            for i in range_inclusive(1, 1000) {\n+            for i in range_inclusive(1i, 1000) {\n                 assert!(m.remove(&i));\n \n                 for j in range_inclusive(1, i) {\n@@ -1830,16 +1830,16 @@ mod test_map {\n                 }\n             }\n \n-            for i in range_inclusive(1, 1000) {\n+            for i in range_inclusive(1i, 1000) {\n                 assert!(!m.contains_key(&i));\n             }\n \n-            for i in range_inclusive(1, 1000) {\n+            for i in range_inclusive(1i, 1000) {\n                 assert!(m.insert(i, i));\n             }\n \n             // remove backwards\n-            for i in range_step_inclusive(1000, 1, -1) {\n+            for i in range_step_inclusive(1000i, 1, -1) {\n                 assert!(m.remove(&i));\n \n                 for j in range_inclusive(i, 1000) {\n@@ -1856,9 +1856,9 @@ mod test_map {\n     #[test]\n     fn test_find_mut() {\n         let mut m = HashMap::new();\n-        assert!(m.insert(1, 12));\n-        assert!(m.insert(2, 8));\n-        assert!(m.insert(5, 14));\n+        assert!(m.insert(1i, 12i));\n+        assert!(m.insert(2i, 8i));\n+        assert!(m.insert(5i, 14i));\n         let new = 100;\n         match m.find_mut(&5) {\n             None => fail!(), Some(x) => *x = new\n@@ -1869,18 +1869,18 @@ mod test_map {\n     #[test]\n     fn test_insert_overwrite() {\n         let mut m = HashMap::new();\n-        assert!(m.insert(1, 2));\n+        assert!(m.insert(1i, 2i));\n         assert_eq!(*m.find(&1).unwrap(), 2);\n-        assert!(!m.insert(1, 3));\n+        assert!(!m.insert(1i, 3i));\n         assert_eq!(*m.find(&1).unwrap(), 3);\n     }\n \n     #[test]\n     fn test_insert_conflicts() {\n         let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1, 2));\n-        assert!(m.insert(5, 3));\n-        assert!(m.insert(9, 4));\n+        assert!(m.insert(1i, 2i));\n+        assert!(m.insert(5i, 3i));\n+        assert!(m.insert(9i, 4i));\n         assert_eq!(*m.find(&9).unwrap(), 4);\n         assert_eq!(*m.find(&5).unwrap(), 3);\n         assert_eq!(*m.find(&1).unwrap(), 2);\n@@ -1889,7 +1889,7 @@ mod test_map {\n     #[test]\n     fn test_conflict_remove() {\n         let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1, 2));\n+        assert!(m.insert(1i, 2i));\n         assert_eq!(*m.find(&1).unwrap(), 2);\n         assert!(m.insert(5, 3));\n         assert_eq!(*m.find(&1).unwrap(), 2);\n@@ -1906,7 +1906,7 @@ mod test_map {\n     #[test]\n     fn test_is_empty() {\n         let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1, 2));\n+        assert!(m.insert(1i, 2i));\n         assert!(!m.is_empty());\n         assert!(m.remove(&1));\n         assert!(m.is_empty());\n@@ -1915,7 +1915,7 @@ mod test_map {\n     #[test]\n     fn test_pop() {\n         let mut m = HashMap::new();\n-        m.insert(1, 2);\n+        m.insert(1i, 2i);\n         assert_eq!(m.pop(&1), Some(2));\n         assert_eq!(m.pop(&1), None);\n     }\n@@ -1924,26 +1924,26 @@ mod test_map {\n     #[allow(experimental)]\n     fn test_pop_equiv() {\n         let mut m = HashMap::new();\n-        m.insert(1, 2);\n+        m.insert(1i, 2i);\n         assert_eq!(m.pop_equiv(&KindaIntLike(1)), Some(2));\n         assert_eq!(m.pop_equiv(&KindaIntLike(1)), None);\n     }\n \n     #[test]\n     fn test_swap() {\n         let mut m = HashMap::new();\n-        assert_eq!(m.swap(1, 2), None);\n-        assert_eq!(m.swap(1, 3), Some(2));\n-        assert_eq!(m.swap(1, 4), Some(3));\n+        assert_eq!(m.swap(1i, 2i), None);\n+        assert_eq!(m.swap(1i, 3i), Some(2));\n+        assert_eq!(m.swap(1i, 4i), Some(3));\n     }\n \n     #[test]\n     fn test_move_iter() {\n         let hm = {\n             let mut hm = HashMap::new();\n \n-            hm.insert('a', 1);\n-            hm.insert('b', 2);\n+            hm.insert('a', 1i);\n+            hm.insert('b', 2i);\n \n             hm\n         };\n@@ -1971,7 +1971,7 @@ mod test_map {\n \n     #[test]\n     fn test_keys() {\n-        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n+        let vec = vec![(1i, 'a'), (2i, 'b'), (3i, 'c')];\n         let map = vec.move_iter().collect::<HashMap<int, char>>();\n         let keys = map.keys().map(|&k| k).collect::<Vec<int>>();\n         assert_eq!(keys.len(), 3);\n@@ -1982,7 +1982,7 @@ mod test_map {\n \n     #[test]\n     fn test_values() {\n-        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n+        let vec = vec![(1i, 'a'), (2i, 'b'), (3i, 'c')];\n         let map = vec.move_iter().collect::<HashMap<int, char>>();\n         let values = map.values().map(|&v| v).collect::<Vec<char>>();\n         assert_eq!(values.len(), 3);\n@@ -1994,8 +1994,8 @@ mod test_map {\n     #[test]\n     fn test_find() {\n         let mut m = HashMap::new();\n-        assert!(m.find(&1).is_none());\n-        m.insert(1, 2);\n+        assert!(m.find(&1i).is_none());\n+        m.insert(1i, 2i);\n         match m.find(&1) {\n             None => fail!(),\n             Some(v) => assert_eq!(*v, 2)\n@@ -2005,17 +2005,17 @@ mod test_map {\n     #[test]\n     fn test_eq() {\n         let mut m1 = HashMap::new();\n-        m1.insert(1, 2);\n-        m1.insert(2, 3);\n-        m1.insert(3, 4);\n+        m1.insert(1i, 2i);\n+        m1.insert(2i, 3i);\n+        m1.insert(3i, 4i);\n \n         let mut m2 = HashMap::new();\n-        m2.insert(1, 2);\n-        m2.insert(2, 3);\n+        m2.insert(1i, 2i);\n+        m2.insert(2i, 3i);\n \n         assert!(m1 != m2);\n \n-        m2.insert(3, 4);\n+        m2.insert(3i, 4i);\n \n         assert_eq!(m1, m2);\n     }\n@@ -2025,8 +2025,8 @@ mod test_map {\n         let mut map: HashMap<int, int> = HashMap::new();\n         let empty: HashMap<int, int> = HashMap::new();\n \n-        map.insert(1, 2);\n-        map.insert(3, 4);\n+        map.insert(1i, 2i);\n+        map.insert(3i, 4i);\n \n         let map_str = format!(\"{}\", map);\n \n@@ -2102,7 +2102,7 @@ mod test_map {\n     fn test_find_equiv() {\n         let mut m = HashMap::new();\n \n-        let (foo, bar, baz) = (1,2,3);\n+        let (foo, bar, baz) = (1i,2i,3i);\n         m.insert(\"foo\".to_string(), foo);\n         m.insert(\"bar\".to_string(), bar);\n         m.insert(\"baz\".to_string(), baz);\n@@ -2117,7 +2117,7 @@ mod test_map {\n \n     #[test]\n     fn test_from_iter() {\n-        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+        let xs = [(1i, 1i), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n         let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n \n@@ -2128,7 +2128,7 @@ mod test_map {\n \n     #[test]\n     fn test_size_hint() {\n-        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+        let xs = [(1i, 1i), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n         let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n \n@@ -2141,7 +2141,7 @@ mod test_map {\n \n     #[test]\n     fn test_mut_size_hint() {\n-        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+        let xs = [(1i, 1i), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n         let mut map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n \n@@ -2167,8 +2167,8 @@ mod test_set {\n         let mut ys = HashSet::new();\n         assert!(xs.is_disjoint(&ys));\n         assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(5));\n-        assert!(ys.insert(11));\n+        assert!(xs.insert(5i));\n+        assert!(ys.insert(11i));\n         assert!(xs.is_disjoint(&ys));\n         assert!(ys.is_disjoint(&xs));\n         assert!(xs.insert(7));\n@@ -2186,13 +2186,13 @@ mod test_set {\n     #[test]\n     fn test_subset_and_superset() {\n         let mut a = HashSet::new();\n-        assert!(a.insert(0));\n+        assert!(a.insert(0i));\n         assert!(a.insert(5));\n         assert!(a.insert(11));\n         assert!(a.insert(7));\n \n         let mut b = HashSet::new();\n-        assert!(b.insert(0));\n+        assert!(b.insert(0i));\n         assert!(b.insert(7));\n         assert!(b.insert(19));\n         assert!(b.insert(250));\n@@ -2230,15 +2230,15 @@ mod test_set {\n         let mut a = HashSet::new();\n         let mut b = HashSet::new();\n \n-        assert!(a.insert(11));\n+        assert!(a.insert(11i));\n         assert!(a.insert(1));\n         assert!(a.insert(3));\n         assert!(a.insert(77));\n         assert!(a.insert(103));\n         assert!(a.insert(5));\n         assert!(a.insert(-5));\n \n-        assert!(b.insert(2));\n+        assert!(b.insert(2i));\n         assert!(b.insert(11));\n         assert!(b.insert(77));\n         assert!(b.insert(-9));\n@@ -2260,13 +2260,13 @@ mod test_set {\n         let mut a = HashSet::new();\n         let mut b = HashSet::new();\n \n-        assert!(a.insert(1));\n+        assert!(a.insert(1i));\n         assert!(a.insert(3));\n         assert!(a.insert(5));\n         assert!(a.insert(9));\n         assert!(a.insert(11));\n \n-        assert!(b.insert(3));\n+        assert!(b.insert(3i));\n         assert!(b.insert(9));\n \n         let mut i = 0;\n@@ -2283,13 +2283,13 @@ mod test_set {\n         let mut a = HashSet::new();\n         let mut b = HashSet::new();\n \n-        assert!(a.insert(1));\n+        assert!(a.insert(1i));\n         assert!(a.insert(3));\n         assert!(a.insert(5));\n         assert!(a.insert(9));\n         assert!(a.insert(11));\n \n-        assert!(b.insert(-2));\n+        assert!(b.insert(-2i));\n         assert!(b.insert(3));\n         assert!(b.insert(9));\n         assert!(b.insert(14));\n@@ -2309,7 +2309,7 @@ mod test_set {\n         let mut a = HashSet::new();\n         let mut b = HashSet::new();\n \n-        assert!(a.insert(1));\n+        assert!(a.insert(1i));\n         assert!(a.insert(3));\n         assert!(a.insert(5));\n         assert!(a.insert(9));\n@@ -2318,7 +2318,7 @@ mod test_set {\n         assert!(a.insert(19));\n         assert!(a.insert(24));\n \n-        assert!(b.insert(-2));\n+        assert!(b.insert(-2i));\n         assert!(b.insert(1));\n         assert!(b.insert(5));\n         assert!(b.insert(9));\n@@ -2336,7 +2336,7 @@ mod test_set {\n \n     #[test]\n     fn test_from_iter() {\n-        let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n+        let xs = [1i, 2, 3, 4, 5, 6, 7, 8, 9];\n \n         let set: HashSet<int> = xs.iter().map(|&x| x).collect();\n \n@@ -2366,13 +2366,13 @@ mod test_set {\n         // I'm keeping them around to prevent a regression.\n         let mut s1 = HashSet::new();\n \n-        s1.insert(1);\n+        s1.insert(1i);\n         s1.insert(2);\n         s1.insert(3);\n \n         let mut s2 = HashSet::new();\n \n-        s2.insert(1);\n+        s2.insert(1i);\n         s2.insert(2);\n \n         assert!(s1 != s2);\n@@ -2387,7 +2387,7 @@ mod test_set {\n         let mut set: HashSet<int> = HashSet::new();\n         let empty: HashSet<int> = HashSet::new();\n \n-        set.insert(1);\n+        set.insert(1i);\n         set.insert(2);\n \n         let set_str = format!(\"{}\", set);\n@@ -2421,7 +2421,7 @@ mod bench {\n \n         b.iter(|| {\n             let mut m = HashMap::new();\n-            m.insert(0, 0);\n+            m.insert(0i, 0i);\n             assert_eq!(m.len(), 1);\n         })\n     }\n@@ -2432,7 +2432,7 @@ mod bench {\n \n         let mut m = HashMap::new();\n \n-        for i in range_inclusive(1, 1000) {\n+        for i in range_inclusive(1i, 1000) {\n             m.insert(i, i);\n         }\n \n@@ -2450,12 +2450,12 @@ mod bench {\n \n         let mut m = HashMap::new();\n \n-        for i in range_inclusive(1, 1000) {\n+        for i in range_inclusive(1i, 1000) {\n             m.insert(i, i);\n         }\n \n         b.iter(|| {\n-            for i in range_inclusive(1, 1000) {\n+            for i in range_inclusive(1i, 1000) {\n                 m.contains_key(&i);\n             }\n         });\n@@ -2467,12 +2467,12 @@ mod bench {\n \n         let mut m = HashMap::new();\n \n-        for i in range_inclusive(1, 1000) {\n+        for i in range_inclusive(1i, 1000) {\n             m.insert(i, i);\n         }\n \n         b.iter(|| {\n-            for i in range_inclusive(1001, 2000) {\n+            for i in range_inclusive(1001i, 2000) {\n                 m.contains_key(&i);\n             }\n         });\n@@ -2484,11 +2484,11 @@ mod bench {\n \n         let mut m = HashMap::new();\n \n-        for i in range_inclusive(1, 1000) {\n+        for i in range_inclusive(1i, 1000) {\n             m.insert(i, i);\n         }\n \n-        let mut k = 1;\n+        let mut k = 1i;\n \n         b.iter(|| {\n             m.pop(&k);\n@@ -2503,11 +2503,11 @@ mod bench {\n \n         let mut m = HashMap::new();\n \n-        for i in range_inclusive(1, 1000) {\n+        for i in range_inclusive(1i, 1000) {\n             m.insert(i, i);\n         }\n \n-        let mut k = 1;\n+        let mut k = 1i;\n \n         b.iter(|| {\n             m.find(&(k + 400));"}, {"sha": "b1164981c0b83f5d63c7e2af2650351d21a06f18", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -36,12 +36,12 @@ Some examples of the `format!` extension are:\n ```rust\n # extern crate debug;\n # fn main() {\n-format!(\"Hello\");                 // => \"Hello\"\n-format!(\"Hello, {:s}!\", \"world\"); // => \"Hello, world!\"\n-format!(\"The number is {:d}\", 1); // => \"The number is 1\"\n-format!(\"{:?}\", (3, 4));          // => \"(3, 4)\"\n-format!(\"{value}\", value=4);      // => \"4\"\n-format!(\"{} {}\", 1, 2);           // => \"1 2\"\n+format!(\"Hello\");                  // => \"Hello\"\n+format!(\"Hello, {:s}!\", \"world\");  // => \"Hello, world!\"\n+format!(\"The number is {:d}\", 1i); // => \"The number is 1\"\n+format!(\"{:?}\", (3i, 4i));         // => \"(3, 4)\"\n+format!(\"{value}\", value=4i);      // => \"4\"\n+format!(\"{} {}\", 1i, 2i);          // => \"1 2\"\n # }\n ```\n \n@@ -65,7 +65,7 @@ iterator over the argument. Each time a \"next argument\" specifier is seen, the\n iterator advances. This leads to behavior like this:\n \n ```rust\n-format!(\"{1} {} {0} {}\", 1, 2); // => \"2 1 1 2\"\n+format!(\"{1} {} {0} {}\", 1i, 2i); // => \"2 1 1 2\"\n ```\n \n The internal iterator over the argument has not been advanced by the time the\n@@ -94,9 +94,9 @@ For example, the following `format!` expressions all use named argument:\n ```rust\n # extern crate debug;\n # fn main() {\n-format!(\"{argument}\", argument = \"test\");       // => \"test\"\n-format!(\"{name} {}\", 1, name = 2);              // => \"2 1\"\n-format!(\"{a:s} {c:d} {b:?}\", a=\"a\", b=(), c=3); // => \"a 3 ()\"\n+format!(\"{argument}\", argument = \"test\");        // => \"test\"\n+format!(\"{name} {}\", 1i, name = 2i);             // => \"2 1\"\n+format!(\"{a:s} {c:d} {b:?}\", a=\"a\", b=(), c=3i); // => \"a 3 ()\"\n # }\n ```\n "}, {"sha": "5d9865fded3e721951e2cb5071658c60c761e934", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -93,7 +93,7 @@ pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n         let mut n = n;\n         while i > 0u {\n             bytes.push((n & 255_u64) as u8);\n-            n >>= 8_u64;\n+            n >>= 8;\n             i -= 1u;\n         }\n         f(bytes.as_slice())\n@@ -130,7 +130,7 @@ pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n         let mut bytes = vec!();\n         let mut i = size;\n         while i > 0u {\n-            let shift = ((i - 1u) * 8u) as u64;\n+            let shift = (i - 1u) * 8u;\n             bytes.push((n >> shift) as u8);\n             i -= 1u;\n         }"}, {"sha": "d8e04f1823938a4a900ce718599ff216d0dd3d86", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -1164,7 +1164,7 @@ mod test {\n         let dir = &tmpdir.join(\"di_readdir\");\n         check!(mkdir(dir, io::UserRWX));\n         let prefix = \"foo\";\n-        for n in range(0,3) {\n+        for n in range(0i,3) {\n             let f = dir.join(format!(\"{}.txt\", n));\n             let mut w = check!(File::create(&f));\n             let msg_str = format!(\"{}{}\", prefix, n.to_str());"}, {"sha": "3443a85b46819a41a7619ce9f74b64223f2010b5", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -611,7 +611,7 @@ mod test {\n     fn bench_mem_writer(b: &mut Bencher) {\n         b.iter(|| {\n             let mut wr = MemWriter::new();\n-            for _i in range(0, 10) {\n+            for _i in range(0u, 10) {\n                 wr.write([5, .. 10]).unwrap();\n             }\n             assert_eq!(wr.unwrap().as_slice(), [5, .. 100].as_slice());\n@@ -624,7 +624,7 @@ mod test {\n             let buf = Vec::from_slice([5 as u8, ..100]);\n             {\n                 let mut rdr = MemReader::new(buf);\n-                for _i in range(0, 10) {\n+                for _i in range(0u, 10) {\n                     let mut buf = [0 as u8, .. 10];\n                     rdr.read(buf).unwrap();\n                     assert_eq!(buf.as_slice(), [5, .. 10].as_slice());\n@@ -639,7 +639,7 @@ mod test {\n             let mut buf = [0 as u8, ..100];\n             {\n                 let mut wr = BufWriter::new(buf);\n-                for _i in range(0, 10) {\n+                for _i in range(0u, 10) {\n                     wr.write([5, .. 10]).unwrap();\n                 }\n             }\n@@ -653,7 +653,7 @@ mod test {\n             let buf = [5 as u8, ..100];\n             {\n                 let mut rdr = BufReader::new(buf);\n-                for _i in range(0, 10) {\n+                for _i in range(0u, 10) {\n                     let mut buf = [0 as u8, .. 10];\n                     rdr.read(buf).unwrap();\n                     assert_eq!(buf.as_slice(), [5, .. 10].as_slice());"}, {"sha": "7d6ab9d7419b941d0d717e5f66b94ba4903ac50d", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -1154,7 +1154,7 @@ mod test {\n                                            port).unwrap());\n             });\n             let _l = rx.recv();\n-            for i in range(0, 1001) {\n+            for i in range(0i, 1001) {\n                 match a.accept() {\n                     Ok(..) => break,\n                     Err(ref e) if e.kind == TimedOut => {}\n@@ -1258,7 +1258,7 @@ mod test {\n         assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n \n         s.set_timeout(Some(20));\n-        for i in range(0, 1001) {\n+        for i in range(0i, 1001) {\n             match s.write([0, .. 128 * 1024]) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,\n@@ -1298,7 +1298,7 @@ mod test {\n         assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n \n         tx.send(());\n-        for _ in range(0, 100) {\n+        for _ in range(0i, 100) {\n             assert!(s.write([0, ..128 * 1024]).is_ok());\n         }\n     })\n@@ -1318,7 +1318,7 @@ mod test {\n \n         let mut s = a.accept().unwrap();\n         s.set_write_timeout(Some(20));\n-        for i in range(0, 1001) {\n+        for i in range(0i, 1001) {\n             match s.write([0, .. 128 * 1024]) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,"}, {"sha": "5f6de52f86632ba9bfe07267c1bbc82c80935646", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -569,7 +569,7 @@ mod test {\n         let _b = UdpSocket::bind(addr2).unwrap();\n \n         a.set_write_timeout(Some(1000));\n-        for _ in range(0, 100) {\n+        for _ in range(0u, 100) {\n             match a.sendto([0, ..4*1024], addr2) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,"}, {"sha": "c5ddda9945de1f82b86b287b468fba37647228df", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -321,7 +321,7 @@ mod tests {\n         };\n \n         spawn(proc() {\n-            for _ in range(0, times) {\n+            for _ in range(0u, times) {\n                 let mut stream = UnixStream::connect(&path2);\n                 match stream.write([100]) {\n                     Ok(..) => {}\n@@ -477,7 +477,7 @@ mod tests {\n             tx.send(UnixStream::connect(&addr2).unwrap());\n         });\n         let l = rx.recv();\n-        for i in range(0, 1001) {\n+        for i in range(0u, 1001) {\n             match a.accept() {\n                 Ok(..) => break,\n                 Err(ref e) if e.kind == TimedOut => {}\n@@ -586,7 +586,7 @@ mod tests {\n         assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n \n         s.set_timeout(Some(20));\n-        for i in range(0, 1001) {\n+        for i in range(0u, 1001) {\n             match s.write([0, .. 128 * 1024]) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,\n@@ -629,7 +629,7 @@ mod tests {\n         assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n \n         tx.send(());\n-        for _ in range(0, 100) {\n+        for _ in range(0u, 100) {\n             assert!(s.write([0, ..128 * 1024]).is_ok());\n         }\n     })\n@@ -647,7 +647,7 @@ mod tests {\n \n         let mut s = a.accept().unwrap();\n         s.set_write_timeout(Some(20));\n-        for i in range(0, 1001) {\n+        for i in range(0u, 1001) {\n             match s.write([0, .. 128 * 1024]) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,"}, {"sha": "ecd6693990c437ae12c8d27d94b80dd52b28ecb0", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -908,7 +908,7 @@ mod tests {\n     iotest!(fn test_zero() {\n         let mut p = sleeper();\n         p.signal_kill().unwrap();\n-        for _ in range(0, 20) {\n+        for _ in range(0i, 20) {\n             if p.signal(0).is_err() {\n                 assert!(!p.wait().unwrap().success());\n                 return"}, {"sha": "9ae855536acbdeb3688c29ad1b49b5e1b919b260", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -115,7 +115,7 @@ impl Timer {\n     /// let mut timer = Timer::new().unwrap();\n     /// let ten_milliseconds = timer.oneshot(10);\n     ///\n-    /// for _ in range(0, 100) { /* do work */ }\n+    /// for _ in range(0u, 100) { /* do work */ }\n     ///\n     /// // blocks until 10 ms after the `oneshot` call\n     /// ten_milliseconds.recv();\n@@ -157,12 +157,12 @@ impl Timer {\n     /// let mut timer = Timer::new().unwrap();\n     /// let ten_milliseconds = timer.periodic(10);\n     ///\n-    /// for _ in range(0, 100) { /* do work */ }\n+    /// for _ in range(0u, 100) { /* do work */ }\n     ///\n     /// // blocks until 10 ms after the `periodic` call\n     /// ten_milliseconds.recv();\n     ///\n-    /// for _ in range(0, 100) { /* do work */ }\n+    /// for _ in range(0u, 100) { /* do work */ }\n     ///\n     /// // blocks until 20 ms after the `periodic` call (*not* 10ms after the\n     /// // previous `recv`)"}, {"sha": "4db15d2cbbe0b03a216ef26dfb82edfbdd541ee9", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -32,7 +32,7 @@\n /// # #![allow(unreachable_code)]\n /// fail!();\n /// fail!(\"this is a terrible mistake!\");\n-/// fail!(4); // fail with the value of 4 to be collected elsewhere\n+/// fail!(4i); // fail with the value of 4 to be collected elsewhere\n /// fail!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n /// ```\n #[macro_export]\n@@ -80,7 +80,7 @@ macro_rules! fail(\n /// // assert with a custom message\n /// # let x = true;\n /// assert!(x, \"x wasn't true!\");\n-/// # let a = 3; let b = 27;\n+/// # let a = 3i; let b = 27i;\n /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n@@ -105,8 +105,8 @@ macro_rules! assert(\n /// # Example\n ///\n /// ```\n-/// let a = 3;\n-/// let b = 1 + 2;\n+/// let a = 3i;\n+/// let b = 1i + 2i;\n /// assert_eq!(a, b);\n /// ```\n #[macro_export]\n@@ -147,7 +147,7 @@ macro_rules! assert_eq(\n /// // assert with a custom message\n /// # let x = true;\n /// debug_assert!(x, \"x wasn't true!\");\n-/// # let a = 3; let b = 27;\n+/// # let a = 3i; let b = 27i;\n /// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n@@ -168,8 +168,8 @@ macro_rules! debug_assert(\n /// # Example\n ///\n /// ```\n-/// let a = 3;\n-/// let b = 1 + 2;\n+/// let a = 3i;\n+/// let b = 1i + 2i;\n /// debug_assert_eq!(a, b);\n /// ```\n #[macro_export]\n@@ -220,7 +220,7 @@ macro_rules! unimplemented(\n /// ```\n /// format!(\"test\");\n /// format!(\"hello {}\", \"world!\");\n-/// format!(\"x = {}, y = {y}\", 10, y = 30);\n+/// format!(\"x = {}, y = {y}\", 10i, y = 30i);\n /// ```\n #[macro_export]\n macro_rules! format(\n@@ -335,7 +335,7 @@ macro_rules! vec(\n /// let (tx1, rx1) = channel();\n /// let (tx2, rx2) = channel();\n /// # fn long_running_task() {}\n-/// # fn calculate_the_answer() -> int { 42 }\n+/// # fn calculate_the_answer() -> int { 42i }\n ///\n /// spawn(proc() { long_running_task(); tx1.send(()) });\n /// spawn(proc() { tx2.send(calculate_the_answer()) });\n@@ -506,7 +506,7 @@ pub mod builtin {\n     /// # Example\n     ///\n     /// ```\n-    /// let s = concat!(\"test\", 10, 'b', true);\n+    /// let s = concat!(\"test\", 10i, 'b', true);\n     /// assert_eq!(s, \"test10btrue\");\n     /// ```\n     #[macro_export]"}, {"sha": "50b2e0ff343b770a95ad3917595558a5c5e9a194", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -128,11 +128,11 @@ pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n /// Helper function for testing numeric operations\n #[cfg(test)]\n pub fn test_num<T:Num + NumCast + Show>(ten: T, two: T) {\n-    assert_eq!(ten.add(&two),  cast(12).unwrap());\n-    assert_eq!(ten.sub(&two),  cast(8).unwrap());\n-    assert_eq!(ten.mul(&two),  cast(20).unwrap());\n-    assert_eq!(ten.div(&two),  cast(5).unwrap());\n-    assert_eq!(ten.rem(&two),  cast(0).unwrap());\n+    assert_eq!(ten.add(&two),  cast(12i).unwrap());\n+    assert_eq!(ten.sub(&two),  cast(8i).unwrap());\n+    assert_eq!(ten.mul(&two),  cast(20i).unwrap());\n+    assert_eq!(ten.div(&two),  cast(5i).unwrap());\n+    assert_eq!(ten.rem(&two),  cast(0i).unwrap());\n \n     assert_eq!(ten.add(&two),  ten + two);\n     assert_eq!(ten.sub(&two),  ten - two);\n@@ -760,14 +760,14 @@ mod tests {\n                 assert_eq!(result, naive_pow($num, $exp));\n             }}\n         )\n-        assert_pow!((3,    0 ) => 1);\n-        assert_pow!((5,    1 ) => 5);\n-        assert_pow!((-4,   2 ) => 16);\n-        assert_pow!((0.5,  5 ) => 0.03125);\n-        assert_pow!((8,    3 ) => 512);\n-        assert_pow!((8.0,  5 ) => 32768.0);\n-        assert_pow!((8.5,  5 ) => 44370.53125);\n-        assert_pow!((2u64, 50) => 1125899906842624);\n+        assert_pow!((3i,     0 ) => 1);\n+        assert_pow!((5i,     1 ) => 5);\n+        assert_pow!((-4i,    2 ) => 16);\n+        assert_pow!((0.5f64, 5 ) => 0.03125);\n+        assert_pow!((8i,     3 ) => 512);\n+        assert_pow!((8.0f64, 5 ) => 32768.0);\n+        assert_pow!((8.5f64, 5 ) => 44370.53125);\n+        assert_pow!((2u64,   50) => 1125899906842624);\n     }\n }\n \n@@ -781,7 +781,7 @@ mod bench {\n \n     #[bench]\n     fn bench_pow_function(b: &mut Bencher) {\n-        let v = Vec::from_fn(1024, |n| n);\n-        b.iter(|| {v.iter().fold(0, |old, new| num::pow(old, *new));});\n+        let v = Vec::from_fn(1024u, |n| n);\n+        b.iter(|| {v.iter().fold(0u, |old, new| num::pow(old, *new));});\n     }\n }"}, {"sha": "ffe4a94d2a209728870f63ee5747b66de073d418", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -252,7 +252,7 @@ pub fn random<T: Rand>() -> T {\n /// use std::rand::{task_rng, sample};\n ///\n /// let mut rng = task_rng();\n-/// let sample = sample(&mut rng, range(1, 100), 5);\n+/// let sample = sample(&mut rng, range(1i, 100), 5);\n /// println!(\"{}\", sample);\n /// ```\n pub fn sample<T, I: Iterator<T>, R: Rng>(rng: &mut R,\n@@ -305,17 +305,17 @@ mod test {\n     #[test]\n     fn test_gen_range() {\n         let mut r = task_rng();\n-        for _ in range(0, 1000) {\n+        for _ in range(0u, 1000) {\n             let a = r.gen_range(-3i, 42);\n             assert!(a >= -3 && a < 42);\n-            assert_eq!(r.gen_range(0, 1), 0);\n-            assert_eq!(r.gen_range(-12, -11), -12);\n+            assert_eq!(r.gen_range(0i, 1), 0);\n+            assert_eq!(r.gen_range(-12i, -11), -12);\n         }\n \n-        for _ in range(0, 1000) {\n-            let a = r.gen_range(10, 42);\n+        for _ in range(0u, 1000) {\n+            let a = r.gen_range(10i, 42);\n             assert!(a >= 10 && a < 42);\n-            assert_eq!(r.gen_range(0, 1), 0);\n+            assert_eq!(r.gen_range(0i, 1), 0);\n             assert_eq!(r.gen_range(3_000_000u, 3_000_001), 3_000_000);\n         }\n \n@@ -369,7 +369,7 @@ mod test {\n     #[test]\n     fn test_choose() {\n         let mut r = task_rng();\n-        assert_eq!(r.choose([1, 1, 1]).map(|&x|x), Some(1));\n+        assert_eq!(r.choose([1i, 1, 1]).map(|&x|x), Some(1));\n \n         let v: &[int] = &[];\n         assert_eq!(r.choose(v), None);\n@@ -380,15 +380,15 @@ mod test {\n         let mut r = task_rng();\n         let empty: &mut [int] = &mut [];\n         r.shuffle(empty);\n-        let mut one = [1];\n+        let mut one = [1i];\n         r.shuffle(one);\n         assert_eq!(one.as_slice(), &[1]);\n \n-        let mut two = [1, 2];\n+        let mut two = [1i, 2];\n         r.shuffle(two);\n         assert!(two == [1, 2] || two == [2, 1]);\n \n-        let mut x = [1, 1, 1];\n+        let mut x = [1i, 1, 1];\n         r.shuffle(x);\n         assert_eq!(x.as_slice(), &[1, 1, 1]);\n     }\n@@ -397,7 +397,7 @@ mod test {\n     fn test_task_rng() {\n         let mut r = task_rng();\n         r.gen::<int>();\n-        let mut v = [1, 1, 1];\n+        let mut v = [1i, 1, 1];\n         r.shuffle(v);\n         assert_eq!(v.as_slice(), &[1, 1, 1]);\n         assert_eq!(r.gen_range(0u, 1u), 0u);\n@@ -419,8 +419,8 @@ mod test {\n \n     #[test]\n     fn test_sample() {\n-        let min_val = 1;\n-        let max_val = 100;\n+        let min_val = 1i;\n+        let max_val = 100i;\n \n         let mut r = task_rng();\n         let vals = range(min_val, max_val).collect::<Vec<int>>();"}, {"sha": "1c1aab15361379ec12d3c8b784fb3ecd1cec7e27", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -282,7 +282,7 @@ mod test {\n     fn test_os_rng_tasks() {\n \n         let mut txs = vec!();\n-        for _ in range(0, 20) {\n+        for _ in range(0u, 20) {\n             let (tx, rx) = channel();\n             txs.push(tx);\n             task::spawn(proc() {\n@@ -295,7 +295,7 @@ mod test {\n                 task::deschedule();\n                 let mut v = [0u8, .. 1000];\n \n-                for _ in range(0, 100) {\n+                for _ in range(0u, 100) {\n                     r.next_u32();\n                     task::deschedule();\n                     r.next_u64();"}, {"sha": "e3652ffac6e09164606a53ffab3e4a81e9850181", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -949,7 +949,7 @@ mod imp {\n         let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n \n         // And now that we're done with all the setup, do the stack walking!\n-        let mut i = 0;\n+        let mut i = 0i;\n         try!(write!(w, \"stack backtrace:\\n\"));\n         while StackWalk64(image, process, thread, &mut frame, &mut context,\n                           0 as *libc::c_void, 0 as *libc::c_void,"}, {"sha": "78da605143dc54a5f1ee987b8b0f2e5443e6e039", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -181,7 +181,7 @@ mod test {\n \n     #[test]\n     fn test_get_ref_method() {\n-        let mut f = Future::from_value(22);\n+        let mut f = Future::from_value(22i);\n         assert_eq!(*f.get_ref(), 22);\n     }\n "}, {"sha": "da0c3daefe705f306b25a33dea8502b2dd870391", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -89,7 +89,7 @@ impl<T> TaskPool<T> {\n fn test_task_pool() {\n     let f: || -> proc(uint):Send -> uint = || { proc(i) i };\n     let mut pool = TaskPool::new(4, f);\n-    for _ in range(0, 8) {\n+    for _ in range(0u, 8) {\n         pool.execute(proc(i) println!(\"Hello from thread {}!\", *i));\n     }\n }"}, {"sha": "5deb7f151bb625252ed77627190413322f111bc1", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -56,9 +56,9 @@ mod tests {\n     fn test_vectors() {\n         let x: Vec<int> = vec![];\n         assert_eq!(x.to_str(), \"[]\".to_string());\n-        assert_eq!((vec![1]).to_str(), \"[1]\".to_string());\n-        assert_eq!((vec![1, 2, 3]).to_str(), \"[1, 2, 3]\".to_string());\n-        assert!((vec![vec![], vec![1], vec![1, 1]]).to_str() ==\n+        assert_eq!((vec![1i]).to_str(), \"[1]\".to_string());\n+        assert_eq!((vec![1i, 2, 3]).to_str(), \"[1, 2, 3]\".to_string());\n+        assert!((vec![vec![], vec![1i], vec![1i, 1]]).to_str() ==\n                \"[[], [1], [1, 1]]\".to_string());\n     }\n }"}, {"sha": "8ce17b9bf3b64020de6a1154cbbae408a4a91c94", "filename": "src/libsync/atomics.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsync%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsync%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fatomics.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -195,8 +195,8 @@ mod test {\n \n     #[test]\n     fn option_swap() {\n-        let p = AtomicOption::new(box 1);\n-        let a = box 2;\n+        let p = AtomicOption::new(box 1i);\n+        let a = box 2i;\n \n         let b = p.swap(a, SeqCst);\n \n@@ -206,24 +206,24 @@ mod test {\n \n     #[test]\n     fn option_take() {\n-        let p = AtomicOption::new(box 1);\n+        let p = AtomicOption::new(box 1i);\n \n         assert!(p.take(SeqCst) == Some(box 1));\n         assert!(p.take(SeqCst) == None);\n \n-        let p2 = box 2;\n+        let p2 = box 2i;\n         p.swap(p2, SeqCst);\n \n         assert!(p.take(SeqCst) == Some(box 2));\n     }\n \n     #[test]\n     fn option_fill() {\n-        let p = AtomicOption::new(box 1);\n-        assert!(p.fill(box 2, SeqCst).is_some()); // should fail; shouldn't leak!\n+        let p = AtomicOption::new(box 1i);\n+        assert!(p.fill(box 2i, SeqCst).is_some()); // should fail; shouldn't leak!\n         assert!(p.take(SeqCst) == Some(box 1));\n \n-        assert!(p.fill(box 2, SeqCst).is_none()); // shouldn't fail\n+        assert!(p.fill(box 2i, SeqCst).is_none()); // shouldn't fail\n         assert!(p.take(SeqCst) == Some(box 2));\n     }\n }"}, {"sha": "3e8f4eef3705ca44a5f214d281e22befab490b09", "filename": "src/libsync/comm/mod.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsync%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsync%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fmod.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -77,24 +77,24 @@\n //! // Create a simple streaming channel\n //! let (tx, rx) = channel();\n //! spawn(proc() {\n-//!     tx.send(10);\n+//!     tx.send(10i);\n //! });\n-//! assert_eq!(rx.recv(), 10);\n+//! assert_eq!(rx.recv(), 10i);\n //! ```\n //!\n //! Shared usage:\n //!\n //! ```\n //! // Create a shared channel which can be sent along from many tasks\n //! let (tx, rx) = channel();\n-//! for i in range(0, 10) {\n+//! for i in range(0i, 10i) {\n //!     let tx = tx.clone();\n //!     spawn(proc() {\n //!         tx.send(i);\n //!     })\n //! }\n //!\n-//! for _ in range(0, 10) {\n+//! for _ in range(0i, 10i) {\n //!     let j = rx.recv();\n //!     assert!(0 <= j && j < 10);\n //! }\n@@ -113,7 +113,7 @@\n //! Synchronous channels:\n //!\n //! ```\n-//! let (tx, rx) = sync_channel(0);\n+//! let (tx, rx) = sync_channel::<int>(0);\n //! spawn(proc() {\n //!     // This will wait for the parent task to start receiving\n //!     tx.send(53);\n@@ -504,15 +504,15 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// let (tx, rx) = sync_channel(1);\n ///\n /// // this returns immediately\n-/// tx.send(1);\n+/// tx.send(1i);\n ///\n /// spawn(proc() {\n ///     // this will block until the previous message has been received\n-///     tx.send(2);\n+///     tx.send(2i);\n /// });\n ///\n-/// assert_eq!(rx.recv(), 1);\n-/// assert_eq!(rx.recv(), 2);\n+/// assert_eq!(rx.recv(), 1i);\n+/// assert_eq!(rx.recv(), 2i);\n /// ```\n pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n     let a = Arc::new(Unsafe::new(sync::Packet::new(bound)));\n@@ -577,11 +577,11 @@ impl<T: Send> Sender<T> {\n     /// let (tx, rx) = channel();\n     ///\n     /// // This send is always successful\n-    /// assert_eq!(tx.send_opt(1), Ok(()));\n+    /// assert_eq!(tx.send_opt(1i), Ok(()));\n     ///\n     /// // This send will fail because the receiver is gone\n     /// drop(rx);\n-    /// assert_eq!(tx.send_opt(1), Err(1));\n+    /// assert_eq!(tx.send_opt(1i), Err(1));\n     /// ```\n     pub fn send_opt(&self, t: T) -> Result<(), T> {\n         // In order to prevent starvation of other tasks in situations where\n@@ -1041,25 +1041,25 @@ mod test {\n     }\n \n     test!(fn smoke() {\n-        let (tx, rx) = channel();\n+        let (tx, rx) = channel::<int>();\n         tx.send(1);\n         assert_eq!(rx.recv(), 1);\n     })\n \n     test!(fn drop_full() {\n         let (tx, _rx) = channel();\n-        tx.send(box 1);\n+        tx.send(box 1i);\n     })\n \n     test!(fn drop_full_shared() {\n         let (tx, _rx) = channel();\n         drop(tx.clone());\n         drop(tx.clone());\n-        tx.send(box 1);\n+        tx.send(box 1i);\n     })\n \n     test!(fn smoke_shared() {\n-        let (tx, rx) = channel();\n+        let (tx, rx) = channel::<int>();\n         tx.send(1);\n         assert_eq!(rx.recv(), 1);\n         let tx = tx.clone();\n@@ -1068,43 +1068,43 @@ mod test {\n     })\n \n     test!(fn smoke_threads() {\n-        let (tx, rx) = channel();\n+        let (tx, rx) = channel::<int>();\n         spawn(proc() {\n             tx.send(1);\n         });\n         assert_eq!(rx.recv(), 1);\n     })\n \n     test!(fn smoke_port_gone() {\n-        let (tx, rx) = channel();\n+        let (tx, rx) = channel::<int>();\n         drop(rx);\n         tx.send(1);\n     } #[should_fail])\n \n     test!(fn smoke_shared_port_gone() {\n-        let (tx, rx) = channel();\n+        let (tx, rx) = channel::<int>();\n         drop(rx);\n         tx.send(1);\n     } #[should_fail])\n \n     test!(fn smoke_shared_port_gone2() {\n-        let (tx, rx) = channel();\n+        let (tx, rx) = channel::<int>();\n         drop(rx);\n         let tx2 = tx.clone();\n         drop(tx);\n         tx2.send(1);\n     } #[should_fail])\n \n     test!(fn port_gone_concurrent() {\n-        let (tx, rx) = channel();\n+        let (tx, rx) = channel::<int>();\n         spawn(proc() {\n             rx.recv();\n         });\n         loop { tx.send(1) }\n     } #[should_fail])\n \n     test!(fn port_gone_concurrent_shared() {\n-        let (tx, rx) = channel();\n+        let (tx, rx) = channel::<int>();\n         let tx2 = tx.clone();\n         spawn(proc() {\n             rx.recv();\n@@ -1130,7 +1130,7 @@ mod test {\n     } #[should_fail])\n \n     test!(fn chan_gone_concurrent() {\n-        let (tx, rx) = channel();\n+        let (tx, rx) = channel::<int>();\n         spawn(proc() {\n             tx.send(1);\n             tx.send(1);\n@@ -1139,11 +1139,11 @@ mod test {\n     } #[should_fail])\n \n     test!(fn stress() {\n-        let (tx, rx) = channel();\n+        let (tx, rx) = channel::<int>();\n         spawn(proc() {\n-            for _ in range(0, 10000) { tx.send(1); }\n+            for _ in range(0u, 10000) { tx.send(1i); }\n         });\n-        for _ in range(0, 10000) {\n+        for _ in range(0u, 10000) {\n             assert_eq!(rx.recv(), 1);\n         }\n     })\n@@ -1183,14 +1183,14 @@ mod test {\n         let tx4 = tx3.clone();\n         spawn(proc() {\n             tx1.send(());\n-            for _ in range(0, 40) {\n+            for _ in range(0i, 40) {\n                 assert_eq!(rx2.recv(), 1);\n             }\n             tx3.send(());\n         });\n         rx1.recv();\n         native::task::spawn(proc() {\n-            for _ in range(0, 40) {\n+            for _ in range(0i, 40) {\n                 tx2.send(1);\n             }\n             tx4.send(());\n@@ -1204,12 +1204,12 @@ mod test {\n         let (tx, rx) = channel::<int>();\n         let (dtx, drx) = channel();\n         native::task::spawn(proc() {\n-            for _ in range(0, 40) {\n+            for _ in range(0i, 40) {\n                 assert_eq!(rx.recv(), 1);\n             }\n             dtx.send(());\n         });\n-        for _ in range(0, 40) {\n+        for _ in range(0u, 40) {\n             tx.send(1);\n         }\n         drx.recv();\n@@ -1377,10 +1377,10 @@ mod test {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel();\n             spawn(proc() {\n-                tx.send(box 10);\n+                tx.send(box 10i);\n             });\n             spawn(proc() {\n-                assert!(rx.recv() == box 10);\n+                assert!(rx.recv() == box 10i);\n             });\n         }\n     })\n@@ -1415,8 +1415,8 @@ mod test {\n     test!(fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n         let (tx, rx) = channel();\n-        for _ in range(0, 10000) { tx.send(()); }\n-        for _ in range(0, 10000) { rx.recv(); }\n+        for _ in range(0i, 10000) { tx.send(()); }\n+        for _ in range(0i, 10000) { rx.recv(); }\n     })\n \n     test!(fn shared_chan_stress() {\n@@ -1511,7 +1511,7 @@ mod test {\n             tx2.send(());\n         });\n         // make sure the other task has gone to sleep\n-        for _ in range(0, 5000) { task::deschedule(); }\n+        for _ in range(0u, 5000) { task::deschedule(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n@@ -1527,11 +1527,11 @@ mod test {\n \n         let (tx, rx) = channel();\n         let t = Thread::start(proc() {\n-            for _ in range(0, 1000) {\n+            for _ in range(0u, 1000) {\n                 tx.send(());\n             }\n         });\n-        for _ in range(0, 1000) {\n+        for _ in range(0u, 1000) {\n             rx.recv();\n         }\n         t.join();\n@@ -1553,7 +1553,7 @@ mod test {\n             }\n             cdone.send(());\n         });\n-        for _ in range(0, 10) {\n+        for _ in range(0u, 10) {\n             tx.send(());\n         }\n         t.join();\n@@ -1574,18 +1574,18 @@ mod sync_tests {\n     }\n \n     test!(fn smoke() {\n-        let (tx, rx) = sync_channel(1);\n+        let (tx, rx) = sync_channel::<int>(1);\n         tx.send(1);\n         assert_eq!(rx.recv(), 1);\n     })\n \n     test!(fn drop_full() {\n         let (tx, _rx) = sync_channel(1);\n-        tx.send(box 1);\n+        tx.send(box 1i);\n     })\n \n     test!(fn smoke_shared() {\n-        let (tx, rx) = sync_channel(1);\n+        let (tx, rx) = sync_channel::<int>(1);\n         tx.send(1);\n         assert_eq!(rx.recv(), 1);\n         let tx = tx.clone();\n@@ -1594,37 +1594,37 @@ mod sync_tests {\n     })\n \n     test!(fn smoke_threads() {\n-        let (tx, rx) = sync_channel(0);\n+        let (tx, rx) = sync_channel::<int>(0);\n         spawn(proc() {\n             tx.send(1);\n         });\n         assert_eq!(rx.recv(), 1);\n     })\n \n     test!(fn smoke_port_gone() {\n-        let (tx, rx) = sync_channel(0);\n+        let (tx, rx) = sync_channel::<int>(0);\n         drop(rx);\n         tx.send(1);\n     } #[should_fail])\n \n     test!(fn smoke_shared_port_gone2() {\n-        let (tx, rx) = sync_channel(0);\n+        let (tx, rx) = sync_channel::<int>(0);\n         drop(rx);\n         let tx2 = tx.clone();\n         drop(tx);\n         tx2.send(1);\n     } #[should_fail])\n \n     test!(fn port_gone_concurrent() {\n-        let (tx, rx) = sync_channel(0);\n+        let (tx, rx) = sync_channel::<int>(0);\n         spawn(proc() {\n             rx.recv();\n         });\n         loop { tx.send(1) }\n     } #[should_fail])\n \n     test!(fn port_gone_concurrent_shared() {\n-        let (tx, rx) = sync_channel(0);\n+        let (tx, rx) = sync_channel::<int>(0);\n         let tx2 = tx.clone();\n         spawn(proc() {\n             rx.recv();\n@@ -1650,7 +1650,7 @@ mod sync_tests {\n     } #[should_fail])\n \n     test!(fn chan_gone_concurrent() {\n-        let (tx, rx) = sync_channel(0);\n+        let (tx, rx) = sync_channel::<int>(0);\n         spawn(proc() {\n             tx.send(1);\n             tx.send(1);\n@@ -1659,11 +1659,11 @@ mod sync_tests {\n     } #[should_fail])\n \n     test!(fn stress() {\n-        let (tx, rx) = sync_channel(0);\n+        let (tx, rx) = sync_channel::<int>(0);\n         spawn(proc() {\n-            for _ in range(0, 10000) { tx.send(1); }\n+            for _ in range(0u, 10000) { tx.send(1); }\n         });\n-        for _ in range(0, 10000) {\n+        for _ in range(0u, 10000) {\n             assert_eq!(rx.recv(), 1);\n         }\n     })\n@@ -1840,19 +1840,19 @@ mod sync_tests {\n \n     test!(fn oneshot_multi_thread_send_recv_stress() {\n         for _ in range(0, stress_factor()) {\n-            let (tx, rx) = sync_channel(0);\n+            let (tx, rx) = sync_channel::<Box<int>>(0);\n             spawn(proc() {\n-                tx.send(box 10);\n+                tx.send(box 10i);\n             });\n             spawn(proc() {\n-                assert!(rx.recv() == box 10);\n+                assert!(rx.recv() == box 10i);\n             });\n         }\n     })\n \n     test!(fn stream_send_recv_stress() {\n         for _ in range(0, stress_factor()) {\n-            let (tx, rx) = sync_channel(0);\n+            let (tx, rx) = sync_channel::<Box<int>>(0);\n \n             send(tx, 0);\n             recv(rx, 0);\n@@ -1880,8 +1880,8 @@ mod sync_tests {\n     test!(fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n         let (tx, rx) = sync_channel(10000);\n-        for _ in range(0, 10000) { tx.send(()); }\n-        for _ in range(0, 10000) { rx.recv(); }\n+        for _ in range(0u, 10000) { tx.send(()); }\n+        for _ in range(0u, 10000) { rx.recv(); }\n     })\n \n     test!(fn shared_chan_stress() {\n@@ -1968,15 +1968,15 @@ mod sync_tests {\n     // This bug used to end up in a livelock inside of the Receiver destructor\n     // because the internal state of the Shared packet was corrupted\n     test!(fn destroy_upgraded_shared_port_when_sender_still_active() {\n-        let (tx, rx) = sync_channel(0);\n-        let (tx2, rx2) = sync_channel(0);\n+        let (tx, rx) = sync_channel::<()>(0);\n+        let (tx2, rx2) = sync_channel::<()>(0);\n         spawn(proc() {\n             rx.recv(); // wait on a oneshot\n             drop(rx);  // destroy a shared\n             tx2.send(());\n         });\n         // make sure the other task has gone to sleep\n-        for _ in range(0, 5000) { task::deschedule(); }\n+        for _ in range(0u, 5000) { task::deschedule(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n@@ -1990,7 +1990,7 @@ mod sync_tests {\n     test!(fn try_recvs_off_the_runtime() {\n         use std::rt::thread::Thread;\n \n-        let (tx, rx) = sync_channel(0);\n+        let (tx, rx) = sync_channel::<()>(0);\n         let (cdone, pdone) = channel();\n         let t = Thread::start(proc() {\n             let mut hits = 0;\n@@ -2003,34 +2003,34 @@ mod sync_tests {\n             }\n             cdone.send(());\n         });\n-        for _ in range(0, 10) {\n+        for _ in range(0u, 10) {\n             tx.send(());\n         }\n         t.join();\n         pdone.recv();\n     })\n \n     test!(fn send_opt1() {\n-        let (tx, rx) = sync_channel(0);\n+        let (tx, rx) = sync_channel::<int>(0);\n         spawn(proc() { rx.recv(); });\n         assert_eq!(tx.send_opt(1), Ok(()));\n     })\n \n     test!(fn send_opt2() {\n-        let (tx, rx) = sync_channel(0);\n+        let (tx, rx) = sync_channel::<int>(0);\n         spawn(proc() { drop(rx); });\n         assert_eq!(tx.send_opt(1), Err(1));\n     })\n \n     test!(fn send_opt3() {\n-        let (tx, rx) = sync_channel(1);\n+        let (tx, rx) = sync_channel::<int>(1);\n         assert_eq!(tx.send_opt(1), Ok(()));\n         spawn(proc() { drop(rx); });\n         assert_eq!(tx.send_opt(1), Err(1));\n     })\n \n     test!(fn send_opt4() {\n-        let (tx, rx) = sync_channel(0);\n+        let (tx, rx) = sync_channel::<int>(0);\n         let tx2 = tx.clone();\n         let (done, donerx) = channel();\n         let done2 = done.clone();\n@@ -2048,27 +2048,27 @@ mod sync_tests {\n     })\n \n     test!(fn try_send1() {\n-        let (tx, _rx) = sync_channel(0);\n+        let (tx, _rx) = sync_channel::<int>(0);\n         assert_eq!(tx.try_send(1), Err(Full(1)));\n     })\n \n     test!(fn try_send2() {\n-        let (tx, _rx) = sync_channel(1);\n+        let (tx, _rx) = sync_channel::<int>(1);\n         assert_eq!(tx.try_send(1), Ok(()));\n         assert_eq!(tx.try_send(1), Err(Full(1)));\n     })\n \n     test!(fn try_send3() {\n-        let (tx, rx) = sync_channel(1);\n+        let (tx, rx) = sync_channel::<int>(1);\n         assert_eq!(tx.try_send(1), Ok(()));\n         drop(rx);\n         assert_eq!(tx.try_send(1), Err(RecvDisconnected(1)));\n     })\n \n     test!(fn try_send4() {\n-        let (tx, rx) = sync_channel(0);\n+        let (tx, rx) = sync_channel::<int>(0);\n         spawn(proc() {\n-            for _ in range(0, 1000) { task::deschedule(); }\n+            for _ in range(0u, 1000) { task::deschedule(); }\n             assert_eq!(tx.try_send(1), Ok(()));\n         });\n         assert_eq!(rx.recv(), 1);"}, {"sha": "8d56f9a003b3ff3b8b02b553dab62cc95fbc1289", "filename": "src/libsync/comm/select.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsync%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsync%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fselect.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -30,15 +30,15 @@\n //! let (tx1, rx1) = channel();\n //! let (tx2, rx2) = channel();\n //!\n-//! tx1.send(1);\n-//! tx2.send(2);\n+//! tx1.send(1i);\n+//! tx2.send(2i);\n //!\n //! select! {\n //!     val = rx1.recv() => {\n-//!         assert_eq!(val, 1);\n+//!         assert_eq!(val, 1i);\n //!     },\n //!     val = rx2.recv() => {\n-//!         assert_eq!(val, 2);\n+//!         assert_eq!(val, 2i);\n //!     }\n //! }\n //! ```\n@@ -397,10 +397,10 @@ mod test {\n         let (tx3, rx3) = channel::<int>();\n \n         spawn(proc() {\n-            for _ in range(0, 20) { task::deschedule(); }\n+            for _ in range(0u, 20) { task::deschedule(); }\n             tx1.send(1);\n             rx3.recv();\n-            for _ in range(0, 20) { task::deschedule(); }\n+            for _ in range(0u, 20) { task::deschedule(); }\n         });\n \n         select! (\n@@ -420,7 +420,7 @@ mod test {\n         let (tx3, rx3) = channel::<()>();\n \n         spawn(proc() {\n-            for _ in range(0, 20) { task::deschedule(); }\n+            for _ in range(0u, 20) { task::deschedule(); }\n             tx1.send(1);\n             tx2.send(2);\n             rx3.recv();\n@@ -521,7 +521,7 @@ mod test {\n             tx3.send(());\n         });\n \n-        for _ in range(0, 1000) { task::deschedule(); }\n+        for _ in range(0u, 1000) { task::deschedule(); }\n         drop(tx1.clone());\n         tx2.send(());\n         rx3.recv();\n@@ -624,7 +624,7 @@ mod test {\n             tx2.send(());\n         });\n \n-        for _ in range(0, 100) { task::deschedule() }\n+        for _ in range(0u, 100) { task::deschedule() }\n         tx1.send(());\n         rx2.recv();\n     })\n@@ -643,7 +643,7 @@ mod test {\n             tx2.send(());\n         });\n \n-        for _ in range(0, 100) { task::deschedule() }\n+        for _ in range(0u, 100) { task::deschedule() }\n         tx1.send(());\n         rx2.recv();\n     })\n@@ -661,23 +661,23 @@ mod test {\n             tx2.send(());\n         });\n \n-        for _ in range(0, 100) { task::deschedule() }\n+        for _ in range(0u, 100) { task::deschedule() }\n         tx1.send(());\n         rx2.recv();\n     })\n \n     test!(fn sync1() {\n-        let (tx, rx) = sync_channel(1);\n+        let (tx, rx) = sync_channel::<int>(1);\n         tx.send(1);\n         select! {\n             n = rx.recv() => { assert_eq!(n, 1); }\n         }\n     })\n \n     test!(fn sync2() {\n-        let (tx, rx) = sync_channel(0);\n+        let (tx, rx) = sync_channel::<int>(0);\n         spawn(proc() {\n-            for _ in range(0, 100) { task::deschedule() }\n+            for _ in range(0u, 100) { task::deschedule() }\n             tx.send(1);\n         });\n         select! {\n@@ -686,8 +686,8 @@ mod test {\n     })\n \n     test!(fn sync3() {\n-        let (tx1, rx1) = sync_channel(0);\n-        let (tx2, rx2) = channel();\n+        let (tx1, rx1) = sync_channel::<int>(0);\n+        let (tx2, rx2): (Sender<int>, Receiver<int>) = channel();\n         spawn(proc() { tx1.send(1); });\n         spawn(proc() { tx2.send(2); });\n         select! {"}, {"sha": "18608a0a370e0aa31da7681c0477402ce8f924e4", "filename": "src/libsync/deque.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fdeque.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -72,7 +72,7 @@ static K: int = 4;\n // size.\n //\n // The size in question is 1 << MIN_BITS\n-static MIN_BITS: int = 7;\n+static MIN_BITS: uint = 7;\n \n struct Deque<T> {\n     bottom: AtomicInt,\n@@ -138,7 +138,7 @@ pub struct BufferPool<T> {\n ///      LLVM is probably pretty good at doing this already.\n struct Buffer<T> {\n     storage: *T,\n-    log_size: int,\n+    log_size: uint,\n }\n \n impl<T: Send> BufferPool<T> {\n@@ -157,7 +157,7 @@ impl<T: Send> BufferPool<T> {\n          Stealer { deque: b, noshare: marker::NoShare })\n     }\n \n-    fn alloc(&self, bits: int) -> Box<Buffer<T>> {\n+    fn alloc(&mut self, bits: uint) -> Box<Buffer<T>> {\n         unsafe {\n             let mut pool = self.pool.lock();\n             match pool.iter().position(|x| x.size() >= (1 << bits)) {\n@@ -225,7 +225,7 @@ impl<T: Send> Clone for Stealer<T> {\n // personally going to heavily comment what's going on here.\n \n impl<T: Send> Deque<T> {\n-    fn new(pool: BufferPool<T>) -> Deque<T> {\n+    fn new(mut pool: BufferPool<T>) -> Deque<T> {\n         let buf = pool.alloc(MIN_BITS);\n         Deque {\n             bottom: AtomicInt::new(0),\n@@ -345,12 +345,12 @@ impl<T: Send> Drop for Deque<T> {\n }\n \n #[inline]\n-fn buffer_alloc_size<T>(log_size: int) -> uint {\n+fn buffer_alloc_size<T>(log_size: uint) -> uint {\n     (1 << log_size) * size_of::<T>()\n }\n \n impl<T: Send> Buffer<T> {\n-    unsafe fn new(log_size: int) -> Buffer<T> {\n+    unsafe fn new(log_size: uint) -> Buffer<T> {\n         let size = buffer_alloc_size::<T>(log_size);\n         let buffer = allocate(size, min_align_of::<T>());\n         Buffer {\n@@ -383,7 +383,10 @@ impl<T: Send> Buffer<T> {\n     // Again, unsafe because this has incredibly dubious ownership violations.\n     // It is assumed that this buffer is immediately dropped.\n     unsafe fn resize(&self, b: int, t: int, delta: int) -> Buffer<T> {\n-        let buf = Buffer::new(self.log_size + delta);\n+        // NB: not entirely obvious, but thanks to 2's complement,\n+        // casting delta to uint and then adding gives the desired\n+        // effect.\n+        let buf = Buffer::new(self.log_size + delta as uint);\n         for i in range(t, b) {\n             buf.put(i, self.get(i));\n         }\n@@ -419,7 +422,7 @@ mod tests {\n         let (w, s) = pool.deque();\n         assert_eq!(w.pop(), None);\n         assert_eq!(s.steal(), Empty);\n-        w.push(1);\n+        w.push(1i);\n         assert_eq!(w.pop(), Some(1));\n         w.push(1);\n         assert_eq!(s.steal(), Data(1));\n@@ -564,7 +567,7 @@ mod tests {\n         let mut rng = rand::task_rng();\n         let mut expected = 0;\n         while expected < AMT {\n-            if rng.gen_range(0, 3) == 2 {\n+            if rng.gen_range(0i, 3) == 2 {\n                 match w.pop() {\n                     None => {}\n                     Some(2) => unsafe { HITS.fetch_add(1, SeqCst); },\n@@ -629,7 +632,7 @@ mod tests {\n         let mut myhit = false;\n         'outer: loop {\n             for _ in range(0, rng.gen_range(0, AMT)) {\n-                if !myhit && rng.gen_range(0, 3) == 2 {\n+                if !myhit && rng.gen_range(0i, 3) == 2 {\n                     match w.pop() {\n                         None => {}\n                         Some((1, 2)) => myhit = true,"}, {"sha": "dff9fee2b772d96f1a53255699cb9fdd099cb6b7", "filename": "src/libsync/lock.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsync%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsync%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flock.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -259,7 +259,7 @@ impl<'a, T: Send> DerefMut<T> for MutexGuard<'a, T> {\n /// ```\n /// use sync::{RWLock, Arc};\n ///\n-/// let lock1 = Arc::new(RWLock::new(1));\n+/// let lock1 = Arc::new(RWLock::new(1i));\n /// let lock2 = lock1.clone();\n ///\n /// spawn(proc() {\n@@ -396,7 +396,7 @@ impl<'a, T: Send + Share> DerefMut<T> for RWLockWriteGuard<'a, T> {\n /// use sync::{Arc, Barrier};\n ///\n /// let barrier = Arc::new(Barrier::new(10));\n-/// for _ in range(0, 10) {\n+/// for _ in range(0u, 10) {\n ///     let c = barrier.clone();\n ///     // The same messages will be printed together.\n ///     // You will NOT see any interleaving.\n@@ -508,7 +508,7 @@ mod tests {\n \n     #[test] #[should_fail]\n     fn test_mutex_arc_poison() {\n-        let arc = Arc::new(Mutex::new(1));\n+        let arc = Arc::new(Mutex::new(1i));\n         let arc2 = arc.clone();\n         let _ = task::try(proc() {\n             let lock = arc2.lock();\n@@ -522,7 +522,7 @@ mod tests {\n     fn test_mutex_arc_nested() {\n         // Tests nested mutexes and access\n         // to underlying data.\n-        let arc = Arc::new(Mutex::new(1));\n+        let arc = Arc::new(Mutex::new(1i));\n         let arc2 = Arc::new(Mutex::new(arc));\n         task::spawn(proc() {\n             let lock = arc2.lock();\n@@ -554,7 +554,7 @@ mod tests {\n \n     #[test] #[should_fail]\n     fn test_rw_arc_poison_wr() {\n-        let arc = Arc::new(RWLock::new(1));\n+        let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n         let _ = task::try(proc() {\n             let lock = arc2.write();\n@@ -565,7 +565,7 @@ mod tests {\n     }\n     #[test] #[should_fail]\n     fn test_rw_arc_poison_ww() {\n-        let arc = Arc::new(RWLock::new(1));\n+        let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n         let _ = task::try(proc() {\n             let lock = arc2.write();\n@@ -576,7 +576,7 @@ mod tests {\n     }\n     #[test]\n     fn test_rw_arc_no_poison_rr() {\n-        let arc = Arc::new(RWLock::new(1));\n+        let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n         let _ = task::try(proc() {\n             let lock = arc2.read();\n@@ -587,7 +587,7 @@ mod tests {\n     }\n     #[test]\n     fn test_rw_arc_no_poison_rw() {\n-        let arc = Arc::new(RWLock::new(1));\n+        let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n         let _ = task::try(proc() {\n             let lock = arc2.read();\n@@ -598,7 +598,7 @@ mod tests {\n     }\n     #[test]\n     fn test_rw_arc_no_poison_dr() {\n-        let arc = Arc::new(RWLock::new(1));\n+        let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n         let _ = task::try(proc() {\n             let lock = arc2.write().downgrade();\n@@ -610,13 +610,13 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc() {\n-        let arc = Arc::new(RWLock::new(0));\n+        let arc = Arc::new(RWLock::new(0i));\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n \n         task::spawn(proc() {\n             let mut lock = arc2.write();\n-            for _ in range(0, 10) {\n+            for _ in range(0u, 10) {\n                 let tmp = *lock;\n                 *lock = -1;\n                 task::deschedule();\n@@ -627,7 +627,7 @@ mod tests {\n \n         // Readers try to catch the writer in the act\n         let mut children = Vec::new();\n-        for _ in range(0, 5) {\n+        for _ in range(0u, 5) {\n             let arc3 = arc.clone();\n             children.push(try_future(proc() {\n                 let lock = arc3.read();\n@@ -675,11 +675,11 @@ mod tests {\n         // (4) tells writer and all other readers to contend as it downgrades.\n         // (5) Writer attempts to set state back to 42, while downgraded task\n         //     and all reader tasks assert that it's 31337.\n-        let arc = Arc::new(RWLock::new(0));\n+        let arc = Arc::new(RWLock::new(0i));\n \n         // Reader tasks\n         let mut reader_convos = Vec::new();\n-        for _ in range(0, 10) {\n+        for _ in range(0u, 10) {\n             let ((tx1, rx1), (tx2, rx2)) = (channel(), channel());\n             reader_convos.push((tx1, rx2));\n             let arcn = arc.clone();\n@@ -777,7 +777,7 @@ mod tests {\n         let lock = lock.downgrade();\n         // if writer mistakenly got in, make sure it mutates state\n         // before we assert on it\n-        for _ in range(0, 5) { task::deschedule(); }\n+        for _ in range(0u, 5) { task::deschedule(); }\n         // make sure writer didn't get in.\n         assert!(*lock);\n     }\n@@ -788,7 +788,7 @@ mod tests {\n         // deschedules in the intuitively-right locations made it even less\n         // likely, and I wasn't sure why :( . This is a mediocre \"next best\"\n         // option.\n-        for _ in range(0, 8) {\n+        for _ in range(0u, 8) {\n             test_rw_write_cond_downgrade_read_race_helper();\n         }\n     }\n@@ -801,7 +801,7 @@ mod tests {\n         let barrier = Arc::new(Barrier::new(10));\n         let (tx, rx) = channel();\n \n-        for _ in range(0, 9) {\n+        for _ in range(0u, 9) {\n             let c = barrier.clone();\n             let tx = tx.clone();\n             spawn(proc() {\n@@ -819,7 +819,7 @@ mod tests {\n \n         barrier.wait();\n         // Now, the barrier is cleared and we should get data.\n-        for _ in range(0, 9) {\n+        for _ in range(0u, 9) {\n             rx.recv();\n         }\n     }"}, {"sha": "6fad2c8aa404dc609e35aed0bf78e32dcbdba54c", "filename": "src/libsync/one.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsync%2Fone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsync%2Fone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fone.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -129,7 +129,7 @@ mod test {\n     #[test]\n     fn smoke_once() {\n         static mut o: Once = ONCE_INIT;\n-        let mut a = 0;\n+        let mut a = 0i;\n         unsafe { o.doit(|| a += 1); }\n         assert_eq!(a, 1);\n         unsafe { o.doit(|| a += 1); }\n@@ -142,10 +142,10 @@ mod test {\n         static mut run: bool = false;\n \n         let (tx, rx) = channel();\n-        for _ in range(0, 10) {\n+        for _ in range(0u, 10) {\n             let tx = tx.clone();\n             spawn(proc() {\n-                for _ in range(0, 4) { task::deschedule() }\n+                for _ in range(0u, 4) { task::deschedule() }\n                 unsafe {\n                     o.doit(|| {\n                         assert!(!run);\n@@ -165,7 +165,7 @@ mod test {\n             assert!(run);\n         }\n \n-        for _ in range(0, 10) {\n+        for _ in range(0u, 10) {\n             rx.recv();\n         }\n     }"}, {"sha": "28a08a7fef298446083cf36a6274500183d7acef", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -138,7 +138,7 @@ impl<Q: Send> Sem<Q> {\n             });\n             // Uncomment if you wish to test for sem races. Not\n             // valgrind-friendly.\n-            /* for _ in range(0, 1000) { task::deschedule(); } */\n+            /* for _ in range(0u, 1000) { task::deschedule(); } */\n             // Need to wait outside the exclusive.\n             if waiter_nobe.is_some() {\n                 let _ = waiter_nobe.unwrap().recv();\n@@ -642,10 +642,10 @@ mod tests {\n         let s2 = s.clone();\n         task::spawn(proc() {\n             let _g = s2.access();\n-            for _ in range(0, 5) { task::deschedule(); }\n+            for _ in range(0u, 5) { task::deschedule(); }\n         });\n         let _g = s.access();\n-        for _ in range(0, 5) { task::deschedule(); }\n+        for _ in range(0u, 5) { task::deschedule(); }\n     }\n     #[test]\n     fn test_sem_as_cvar() {\n@@ -657,7 +657,7 @@ mod tests {\n             s2.acquire();\n             tx.send(());\n         });\n-        for _ in range(0, 5) { task::deschedule(); }\n+        for _ in range(0u, 5) { task::deschedule(); }\n         s.release();\n         let _ = rx.recv();\n \n@@ -666,7 +666,7 @@ mod tests {\n         let s = Arc::new(Semaphore::new(0));\n         let s2 = s.clone();\n         task::spawn(proc() {\n-            for _ in range(0, 5) { task::deschedule(); }\n+            for _ in range(0u, 5) { task::deschedule(); }\n             s2.release();\n             let _ = rx.recv();\n         });\n@@ -705,7 +705,7 @@ mod tests {\n                 tx.send(());\n             });\n             rx.recv(); // wait for child to come alive\n-            for _ in range(0, 5) { task::deschedule(); } // let the child contend\n+            for _ in range(0u, 5) { task::deschedule(); } // let the child contend\n         }\n         rx.recv(); // wait for child to be done\n     }\n@@ -735,7 +735,7 @@ mod tests {\n         }\n \n         fn access_shared(sharedstate: *mut int, m: &Arc<Mutex>, n: uint) {\n-            for _ in range(0, n) {\n+            for _ in range(0u, n) {\n                 let _g = m.lock();\n                 let oldval = unsafe { *sharedstate };\n                 task::deschedule();\n@@ -780,7 +780,7 @@ mod tests {\n         let m = Arc::new(Mutex::new());\n         let mut rxs = Vec::new();\n \n-        for _ in range(0, num_waiters) {\n+        for _ in range(0u, num_waiters) {\n             let mi = m.clone();\n             let (tx, rx) = channel();\n             rxs.push(rx);\n@@ -907,7 +907,7 @@ mod tests {\n \n         fn access_shared(sharedstate: &mut int, x: &Arc<RWLock>,\n                          mode: RWLockMode, n: uint) {\n-            for _ in range(0, n) {\n+            for _ in range(0u, n) {\n                 lock_rwlock_in_mode(x, mode, || {\n                     let oldval = *sharedstate;\n                     task::deschedule();\n@@ -1033,7 +1033,7 @@ mod tests {\n         let x = Arc::new(RWLock::new());\n         let mut rxs = Vec::new();\n \n-        for _ in range(0, num_waiters) {\n+        for _ in range(0u, num_waiters) {\n             let xi = x.clone();\n             let (tx, rx) = channel();\n             rxs.push(rx);"}, {"sha": "a4da1fd2335470d5f7f3e86d033d70f262590fae", "filename": "src/libsync/spsc_queue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fspsc_queue.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -237,7 +237,7 @@ mod test {\n     #[test]\n     fn smoke() {\n         let q = Queue::new(0);\n-        q.push(1);\n+        q.push(1i);\n         q.push(2);\n         assert_eq!(q.pop(), Some(1));\n         assert_eq!(q.pop(), Some(2));\n@@ -259,7 +259,7 @@ mod test {\n     #[test]\n     fn smoke_bound() {\n         let q = Queue::new(1);\n-        q.push(1);\n+        q.push(1i);\n         q.push(2);\n         assert_eq!(q.pop(), Some(1));\n         assert_eq!(q.pop(), Some(2));\n@@ -281,7 +281,7 @@ mod test {\n             let b = a.clone();\n             let (tx, rx) = channel();\n             native::task::spawn(proc() {\n-                for _ in range(0, 100000) {\n+                for _ in range(0u, 100000) {\n                     loop {\n                         match b.pop() {\n                             Some(1) => break,\n@@ -292,7 +292,7 @@ mod test {\n                 }\n                 tx.send(());\n             });\n-            for _ in range(0, 100000) {\n+            for _ in range(0i, 100000) {\n                 a.push(1);\n             }\n             rx.recv();"}, {"sha": "9771bc9386b169ed89bb8728f5f058eea0f088a9", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -150,7 +150,7 @@ impl Abi {\n \n impl Architecture {\n     fn bit(&self) -> u32 {\n-        1 << (*self as u32)\n+        1 << (*self as uint)\n     }\n }\n \n@@ -198,11 +198,11 @@ fn indices_are_correct() {\n         assert_eq!(i, abi_data.abi.index());\n     }\n \n-    let bits = 1 << (X86 as u32);\n-    let bits = bits | 1 << (X86_64 as u32);\n+    let bits = 1 << (X86 as uint);\n+    let bits = bits | 1 << (X86_64 as uint);\n     assert_eq!(IntelBits, bits);\n \n-    let bits = 1 << (Arm as u32);\n+    let bits = 1 << (Arm as uint);\n     assert_eq!(ArmBits, bits);\n }\n "}, {"sha": "64d381d2b12200082aa14eb8c9f8c63a65d35c10", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -675,8 +675,7 @@ pub enum IntTy {\n \n impl fmt::Show for IntTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\",\n-               ast_util::int_ty_to_str(*self, None, ast_util::AutoSuffix))\n+        write!(f, \"{}\", ast_util::int_ty_to_str(*self, None))\n     }\n }\n \n@@ -691,8 +690,7 @@ pub enum UintTy {\n \n impl fmt::Show for UintTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\",\n-               ast_util::uint_ty_to_str(*self, None, ast_util::AutoSuffix))\n+        write!(f, \"{}\", ast_util::uint_ty_to_str(*self, None))\n     }\n }\n "}, {"sha": "95bd35764e7a954c4aaea2d4b2e6150fbca4853e", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -107,19 +107,11 @@ pub fn is_path(e: Gc<Expr>) -> bool {\n     return match e.node { ExprPath(_) => true, _ => false };\n }\n \n-pub enum SuffixMode {\n-    ForceSuffix,\n-    AutoSuffix,\n-}\n-\n // Get a string representation of a signed int type, with its value.\n // We want to avoid \"45int\" and \"-3int\" in favor of \"45\" and \"-3\"\n-pub fn int_ty_to_str(t: IntTy, val: Option<i64>, mode: SuffixMode) -> String {\n+pub fn int_ty_to_str(t: IntTy, val: Option<i64>) -> String {\n     let s = match t {\n-        TyI if val.is_some() => match mode {\n-            AutoSuffix => \"\",\n-            ForceSuffix => \"i\",\n-        },\n+        TyI if val.is_some() => \"i\",\n         TyI => \"int\",\n         TyI8 => \"i8\",\n         TyI16 => \"i16\",\n@@ -147,12 +139,9 @@ pub fn int_ty_max(t: IntTy) -> u64 {\n \n // Get a string representation of an unsigned int type, with its value.\n // We want to avoid \"42uint\" in favor of \"42u\"\n-pub fn uint_ty_to_str(t: UintTy, val: Option<u64>, mode: SuffixMode) -> String {\n+pub fn uint_ty_to_str(t: UintTy, val: Option<u64>) -> String {\n     let s = match t {\n-        TyU if val.is_some() => match mode {\n-            AutoSuffix => \"\",\n-            ForceSuffix => \"u\",\n-        },\n+        TyU if val.is_some() => \"u\",\n         TyU => \"uint\",\n         TyU8 => \"u8\",\n         TyU16 => \"u16\","}, {"sha": "9549d5b8389dd94dccc1cb11e6430e57632175f6", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -212,10 +212,8 @@ pub fn to_str(t: &Token) -> String {\n           res.push_char('\\'');\n           res\n       }\n-      LIT_INT(i, t) => ast_util::int_ty_to_str(t, Some(i),\n-                                               ast_util::ForceSuffix),\n-      LIT_UINT(u, t) => ast_util::uint_ty_to_str(t, Some(u),\n-                                                 ast_util::ForceSuffix),\n+      LIT_INT(i, t) => ast_util::int_ty_to_str(t, Some(i)),\n+      LIT_UINT(u, t) => ast_util::uint_ty_to_str(t, Some(u)),\n       LIT_INT_UNSUFFIXED(i) => { (i as u64).to_str() }\n       LIT_FLOAT(s, t) => {\n         let mut body = String::from_str(get_ident(s).get());"}, {"sha": "854aa80ca340376f469b07a9f41ed7f6f1ce1112", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -163,7 +163,7 @@ pub fn mk_printer(out: Box<io::Writer>, linewidth: uint) -> Printer {\n     let n: uint = 3 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n     let token: Vec<Token> = Vec::from_elem(n, Eof);\n-    let size: Vec<int> = Vec::from_elem(n, 0);\n+    let size: Vec<int> = Vec::from_elem(n, 0i);\n     let scan_stack: Vec<uint> = Vec::from_elem(n, 0u);\n     Printer {\n         out: out,"}, {"sha": "97e99ca692d1abc41fc2d77c168c5e1575f952b8", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -2319,13 +2319,11 @@ impl<'a> State<'a> {\n             }\n             ast::LitInt(i, t) => {\n                 word(&mut self.s,\n-                     ast_util::int_ty_to_str(t, Some(i),\n-                                             ast_util::AutoSuffix).as_slice())\n+                     ast_util::int_ty_to_str(t, Some(i)).as_slice())\n             }\n             ast::LitUint(u, t) => {\n                 word(&mut self.s,\n-                     ast_util::uint_ty_to_str(t, Some(u),\n-                                              ast_util::ForceSuffix).as_slice())\n+                     ast_util::uint_ty_to_str(t, Some(u)).as_slice())\n             }\n             ast::LitIntUnsuffixed(i) => {\n                 word(&mut self.s, format!(\"{}\", i).as_slice())"}, {"sha": "d5cc2c7f304c7146959312fe50a7d34ccfe0e7b3", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -173,7 +173,7 @@ mod test {\n     #[test]\n     fn test_push_get() {\n         let mut v = SmallVector::zero();\n-        v.push(1);\n+        v.push(1i);\n         assert_eq!(1, v.len());\n         assert_eq!(&1, v.get(0));\n         v.push(2);\n@@ -186,7 +186,7 @@ mod test {\n \n     #[test]\n     fn test_from_iter() {\n-        let v: SmallVector<int> = (vec!(1, 2, 3)).move_iter().collect();\n+        let v: SmallVector<int> = (vec!(1i, 2, 3)).move_iter().collect();\n         assert_eq!(3, v.len());\n         assert_eq!(&1, v.get(0));\n         assert_eq!(&2, v.get(1));\n@@ -199,11 +199,11 @@ mod test {\n         let v: Vec<int> = v.move_iter().collect();\n         assert_eq!(Vec::new(), v);\n \n-        let v = SmallVector::one(1);\n-        assert_eq!(vec!(1), v.move_iter().collect());\n+        let v = SmallVector::one(1i);\n+        assert_eq!(vec!(1i), v.move_iter().collect());\n \n-        let v = SmallVector::many(vec!(1, 2, 3));\n-        assert_eq!(vec!(1, 2, 3), v.move_iter().collect());\n+        let v = SmallVector::many(vec!(1i, 2i, 3i));\n+        assert_eq!(vec!(1i, 2i, 3i), v.move_iter().collect());\n     }\n \n     #[test]\n@@ -220,7 +220,7 @@ mod test {\n \n     #[test]\n     fn test_expect_one_one() {\n-        assert_eq!(1, SmallVector::one(1).expect_one(\"\"));\n-        assert_eq!(1, SmallVector::many(vec!(1)).expect_one(\"\"));\n+        assert_eq!(1i, SmallVector::one(1i).expect_one(\"\"));\n+        assert_eq!(1i, SmallVector::many(vec!(1i)).expect_one(\"\"));\n     }\n }"}, {"sha": "139f1113aaf9434fa3454cd3a5e85e458a306acf", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -123,7 +123,13 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     'c' => if stack.len() > 0 {\n                         match stack.pop().unwrap() {\n                             // if c is 0, use 0200 (128) for ncurses compatibility\n-                            Number(c) => output.push(if c == 0 { 128 } else { c } as u8),\n+                            Number(c) => {\n+                                output.push(if c == 0 {\n+                                    128u8\n+                                } else {\n+                                    c as u8\n+                                })\n+                            }\n                             _       => return Err(\"a non-char was used with %c\".to_string())\n                         }\n                     } else { return Err(\"stack is empty\".to_string()) },"}, {"sha": "71fdea9b9ec8e80f3aaec65dbaa4dda624b10c95", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -186,7 +186,7 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n     let magic = try!(file.read_le_u16());\n     if magic != 0x011A {\n         return Err(format!(\"invalid magic number: expected {:x} but found {:x}\",\n-                           0x011A, magic as uint));\n+                           0x011Au, magic as uint));\n     }\n \n     let names_bytes          = try!(file.read_le_i16()) as int;"}, {"sha": "34e9dce3960514b2851a1ab8d1e3ed418b26983e", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -658,11 +658,11 @@ impl<T: Writer> ConsoleTestState<T> {\n     }\n \n     pub fn write_metric_diff(&mut self, diff: &MetricDiff) -> io::IoResult<()> {\n-        let mut noise = 0;\n-        let mut improved = 0;\n-        let mut regressed = 0;\n-        let mut added = 0;\n-        let mut removed = 0;\n+        let mut noise = 0u;\n+        let mut improved = 0u;\n+        let mut regressed = 0u;\n+        let mut added = 0u;\n+        let mut removed = 0u;\n \n         for (k, v) in diff.iter() {\n             match *v {"}, {"sha": "8db9a4f53aa9bc8a8dab871729aa6839c46d2c20", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -1034,21 +1034,21 @@ mod tests {\n             assert_eq!(out, expected);\n         }\n \n-        t(&Summary::new([-2.0, -1.0]),\n+        t(&Summary::new([-2.0f64, -1.0f64]),\n                         \"-2 |[------******#*****---]| -1\".to_string());\n-        t(&Summary::new([0.0, 2.0]),\n+        t(&Summary::new([0.0f64, 2.0f64]),\n                         \"0 |[-------*****#*******---]| 2\".to_string());\n-        t(&Summary::new([-2.0, 0.0]),\n+        t(&Summary::new([-2.0f64, 0.0f64]),\n                         \"-2 |[------******#******---]| 0\".to_string());\n \n     }\n     #[test]\n     fn test_sum_f64s() {\n-        assert_eq!([0.5, 3.2321, 1.5678].sum(), 5.2999);\n+        assert_eq!([0.5f64, 3.2321f64, 1.5678f64].sum(), 5.2999);\n     }\n     #[test]\n     fn test_sum_f64_between_ints_that_sum_to_0() {\n-        assert_eq!([1e30, 1.2, -1e30].sum(), 1.2);\n+        assert_eq!([1e30f64, 1.2f64, -1e30f64].sum(), 1.2);\n     }\n }\n \n@@ -1060,12 +1060,12 @@ mod bench {\n     #[bench]\n     pub fn sum_three_items(b: &mut Bencher) {\n         b.iter(|| {\n-            [1e20, 1.5, -1e20].sum();\n+            [1e20f64, 1.5f64, -1e20f64].sum();\n         })\n     }\n     #[bench]\n     pub fn sum_many_f64(b: &mut Bencher) {\n-        let nums = [-1e30, 1e60, 1e30, 1.0, -1e60];\n+        let nums = [-1e30f64, 1e60, 1e30, 1.0, -1e60];\n         let v = Vec::from_fn(500, |i| nums[i%5]);\n \n         b.iter(|| {"}, {"sha": "d66cfe9bf636b716867370a728bd5f52091142c6", "filename": "src/test/auxiliary/issue-11224.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fauxiliary%2Fissue-11224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fauxiliary%2Fissue-11224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-11224.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -21,6 +21,6 @@ mod inner {\n }\n \n pub fn foo() {\n-    let a = &1 as &inner::Trait;\n+    let a = &1i as &inner::Trait;\n     a.f();\n }"}, {"sha": "bc310e317113edc611847a26c51933a7f6c00806", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -24,9 +24,9 @@ use rustc::plugin::Registry;\n use std::gc::{Gc, GC};\n \n #[macro_export]\n-macro_rules! exported_macro (() => (2))\n+macro_rules! exported_macro (() => (2i))\n \n-macro_rules! unexported_macro (() => (3))\n+macro_rules! unexported_macro (() => (3i))\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {"}, {"sha": "0d1911af9e06b75750104f27ee77a10f8b30425c", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -63,7 +63,7 @@ fn maybe_run_test(argv: &[String], name: String, test: ||) {\n }\n \n fn shift_push() {\n-    let mut v1 = Vec::from_elem(30000, 1);\n+    let mut v1 = Vec::from_elem(30000, 1i);\n     let mut v2 = Vec::new();\n \n     while v1.len() > 0 {\n@@ -77,7 +77,7 @@ fn read_line() {\n     let mut path = Path::new(env!(\"CFG_SRC_DIR\"));\n     path.push(\"src/test/bench/shootout-k-nucleotide.data\");\n \n-    for _ in range(0, 3) {\n+    for _ in range(0u, 3) {\n         let mut reader = BufferedReader::new(File::open(&path).unwrap());\n         for _line in reader.lines() {\n         }"}, {"sha": "6ec1d5395cf002ffbf013d2beb22b0aa261d9e92", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -101,7 +101,7 @@ fn main() {\n     let mut pixels = [0f32, ..256*256];\n     let n2d = Noise2DContext::new();\n \n-    for _ in range(0, 100) {\n+    for _ in range(0u, 100) {\n         for y in range(0u, 256) {\n             for x in range(0u, 256) {\n                 let v = n2d.get(x as f32 * 0.1, y as f32 * 0.1);"}, {"sha": "822565ec1279b750df68345a95abc15ef217df18", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -94,7 +94,7 @@ fn main() {\n \n     let mut messages = range_step(min_depth, max_depth + 1, 2).map(|depth| {\n             use std::num::pow;\n-            let iterations = pow(2, (max_depth - depth + min_depth) as uint);\n+            let iterations = pow(2i, (max_depth - depth + min_depth) as uint);\n             Future::spawn(proc() {\n                 let mut chk = 0;\n                 for i in range(1, iterations + 1) {"}, {"sha": "8095037662bccf4e95edfe1eac7ecff0ed1a4112", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -111,7 +111,7 @@ fn creature(\n     to_rendezvous: Sender<CreatureInfo>,\n     to_rendezvous_log: Sender<String>\n ) {\n-    let mut creatures_met = 0;\n+    let mut creatures_met = 0i32;\n     let mut evil_clones_met = 0;\n     let mut rendezvous = from_rendezvous.iter();\n "}, {"sha": "91686d00fc39fff48ddeca33536f619ee96be3e5", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -48,7 +48,7 @@ fn fannkuch(n: uint, i: uint) -> (int, int) {\n     let mut perm = Vec::from_fn(n, |e| ((n + e - i) % n + 1) as i32);\n     let mut tperm = perm.clone();\n     let mut count = Vec::from_elem(n, 0u);\n-    let mut perm_count = 0;\n+    let mut perm_count = 0i;\n     let mut checksum = 0;\n \n     for countdown in range(1, fact(n - 1) + 1).rev() {"}, {"sha": "f32a46cd52a4a52d2e0d5a34a119943c1066bfe3", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -136,7 +136,7 @@ fn mask(dy: int, dx: int, id: uint, p: &Vec<(int, int)>) -> Option<u64> {\n         if x < 0 || x > 4 {return None;}\n         let y = y + dy;\n         if y < 0 || y > 9 {return None;}\n-        m |= 1 << (y * 5 + x);\n+        m |= 1 << (y * 5 + x) as uint;\n     }\n     Some(m)\n }\n@@ -146,16 +146,16 @@ fn mask(dy: int, dx: int, id: uint, p: &Vec<(int, int)>) -> Option<u64> {\n // (i/5, i%5).\n fn make_masks() -> Vec<Vec<Vec<u64> > > {\n     let pieces = vec!(\n-        vec!((0,0),(0,1),(0,2),(0,3),(1,3)),\n-        vec!((0,0),(0,2),(0,3),(1,0),(1,1)),\n-        vec!((0,0),(0,1),(0,2),(1,2),(2,1)),\n-        vec!((0,0),(0,1),(0,2),(1,1),(2,1)),\n-        vec!((0,0),(0,2),(1,0),(1,1),(2,1)),\n-        vec!((0,0),(0,1),(0,2),(1,1),(1,2)),\n-        vec!((0,0),(0,1),(1,1),(1,2),(2,1)),\n-        vec!((0,0),(0,1),(0,2),(1,0),(1,2)),\n-        vec!((0,0),(0,1),(0,2),(1,2),(1,3)),\n-        vec!((0,0),(0,1),(0,2),(0,3),(1,2)));\n+        vec!((0i,0i),(0,1),(0,2),(0,3),(1,3)),\n+        vec!((0i,0i),(0,2),(0,3),(1,0),(1,1)),\n+        vec!((0i,0i),(0,1),(0,2),(1,2),(2,1)),\n+        vec!((0i,0i),(0,1),(0,2),(1,1),(2,1)),\n+        vec!((0i,0i),(0,2),(1,0),(1,1),(2,1)),\n+        vec!((0i,0i),(0,1),(0,2),(1,1),(1,2)),\n+        vec!((0i,0i),(0,1),(1,1),(1,2),(2,1)),\n+        vec!((0i,0i),(0,1),(0,2),(1,0),(1,2)),\n+        vec!((0i,0i),(0,1),(0,2),(1,2),(1,3)),\n+        vec!((0i,0i),(0,1),(0,2),(0,3),(1,2)));\n \n     // To break the central symetry of the problem, every\n     // transformation must be taken except for one piece (piece 3\n@@ -165,7 +165,7 @@ fn make_masks() -> Vec<Vec<Vec<u64> > > {\n         .map(|(id, p)| transform(p, id != 3))\n         .collect();\n \n-    range(0, 50).map(|yx| {\n+    range(0i, 50).map(|yx| {\n         transforms.iter().enumerate().map(|(id, t)| {\n             t.iter().filter_map(|p| mask(yx / 5, yx % 5, id, p)).collect()\n         }).collect()\n@@ -208,7 +208,7 @@ fn filter_masks(masks: &mut Vec<Vec<Vec<u64>>>) {\n // Gets the identifier of a mask.\n fn get_id(m: u64) -> u8 {\n     for id in range(0u8, 10) {\n-        if m & (1 << (id + 50)) != 0 {return id;}\n+        if m & (1 << (id + 50) as uint) != 0 {return id;}\n     }\n     fail!(\"{:016x} does not have a valid identifier\", m);\n }"}, {"sha": "85f035b60cbbe23567357b0207ba71badecc6349", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -66,9 +66,9 @@ fn parse_opts(argv: Vec<String> ) -> Config {\n }\n \n fn stress_task(id: int) {\n-    let mut i = 0;\n+    let mut i = 0i;\n     loop {\n-        let n = 15;\n+        let n = 15i;\n         assert_eq!(fib(n), fib(n));\n         i += 1;\n         println!(\"{}: Completed {} iterations\", id, i);\n@@ -108,7 +108,7 @@ fn main() {\n         let num_trials = 10;\n \n         for n in range(1, max + 1) {\n-            for _ in range(0, num_trials) {\n+            for _ in range(0u, num_trials) {\n                 let start = time::precise_time_ns();\n                 let fibn = fib(n);\n                 let stop = time::precise_time_ns();"}, {"sha": "912c635bd448b73272d401ba0a5d8a9936ace35a", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -102,10 +102,10 @@ fn main() {\n     } else {\n         FromStr::from_str(args[1].as_slice()).unwrap()\n     };\n-    let u = Arc::new(RWLock::new(Vec::from_elem(n, 1.)));\n-    let v = Arc::new(RWLock::new(Vec::from_elem(n, 1.)));\n-    let tmp = Arc::new(RWLock::new(Vec::from_elem(n, 1.)));\n-    for _ in range(0, 10) {\n+    let u = Arc::new(RWLock::new(Vec::from_elem(n, 1f64)));\n+    let v = Arc::new(RWLock::new(Vec::from_elem(n, 1f64)));\n+    let tmp = Arc::new(RWLock::new(Vec::from_elem(n, 1f64)));\n+    for _ in range(0u8, 10) {\n         mult_AtAv(u.clone(), v.clone(), tmp.clone());\n         mult_AtAv(v.clone(), u.clone(), tmp.clone());\n     }"}, {"sha": "fbd35c57adc7998985ea1cafdf4b5ee2cbf94a28", "filename": "src/test/bench/silly-test-spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fsilly-test-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fsilly-test-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsilly-test-spawn.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -22,7 +22,7 @@ fn start(argc: int, argv: **u8) -> int {\n }\n \n fn main() {\n-    for _ in range(1, 100_000) {\n+    for _ in range(1u32, 100_000) {\n         spawn(proc() {})\n     }\n }"}, {"sha": "4a81deaf529239541320faf00cc534e8bc4d0630", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -181,7 +181,7 @@ static HEADS: u16 = (1u16 << 10) - 1; /* bits 9..0 */\n impl Colors {\n     fn new(start_color: u8) -> Colors {\n         // Sets bits 9..start_color\n-        let tails = !0u16 << start_color;\n+        let tails = !0u16 << start_color as uint;\n         return Colors(HEADS & tails);\n     }\n \n@@ -198,7 +198,7 @@ impl Colors {\n     fn remove(&mut self, color: u8) {\n         if color != 0u8 {\n             let Colors(val) = *self;\n-            let mask = !(1u16 << color);\n+            let mask = !(1u16 << color as uint);\n             *self    = Colors(val & mask);\n         }\n     }"}, {"sha": "5d58774f1d7fdf5104ac588e3c17653e0e83301d", "filename": "src/test/compile-fail/block-coerce-no.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -22,7 +22,7 @@ fn coerce(b: ||) -> extern fn() {\n }\n \n fn main() {\n-    let i = 8;\n+    let i = 8i;\n     let f = coerce(|| println!(\"{:?}\", i) );\n     f();\n }"}, {"sha": "616320c168b4b8678aa517fcad47a4817d7e2b43", "filename": "src/test/compile-fail/borrowck-lend-flow-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -40,7 +40,7 @@ fn block_overarching_alias_mut() {\n \n     let mut v = box 3;\n     let mut x = &mut v;\n-    for _ in range(0, 3) {\n+    for _ in range(0i, 3) {\n         borrow(v); //~ ERROR cannot borrow\n     }\n     *x = box 5;"}, {"sha": "7a494b5959a8aef6bdeb7ce570b6f3e9e77c9ae0", "filename": "src/test/compile-fail/borrowck-lend-flow-match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -22,10 +22,10 @@ fn separate_arms() {\n         None => {\n             // It is ok to reassign x here, because there is in\n             // fact no outstanding loan of x!\n-            x = Some(0);\n+            x = Some(0i);\n         }\n         Some(ref _i) => {\n-            x = Some(1); //~ ERROR cannot assign\n+            x = Some(1i); //~ ERROR cannot assign\n         }\n     }\n     x.clone(); // just to prevent liveness warnings"}, {"sha": "b6ecb50fac873b8cff5d467b385560042cf2213a", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -15,7 +15,7 @@ fn borrow(v: &int, f: |x: &int|) {\n }\n \n fn box_imm() {\n-    let v = box 3;\n+    let v = box 3i;\n     let _w = &v;\n     task::spawn(proc() {\n         println!(\"v={}\", *v);\n@@ -24,7 +24,7 @@ fn box_imm() {\n }\n \n fn box_imm_explicit() {\n-    let v = box 3;\n+    let v = box 3i;\n     let _w = &v;\n     task::spawn(proc() {\n         println!(\"v={}\", *v);"}, {"sha": "e8ff69ed64141b1f954b8bcf56e694a949bedb1e", "filename": "src/test/compile-fail/borrowck-preserve-cond-box.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-cond-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-cond-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-cond-box.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -15,8 +15,8 @@\n use std::gc::GC;\n \n fn testfn(cond: bool) {\n-    let mut x = box(GC) 3;\n-    let mut y = box(GC) 4;\n+    let mut x = box(GC) 3i;\n+    let mut y = box(GC) 4i;\n \n     // borrow x and y\n     let r_x = &*x;\n@@ -32,13 +32,13 @@ fn testfn(cond: bool) {\n     println!(\"*r = {}, exp = {}\", *r, exp);\n     assert_eq!(*r, exp);\n \n-    x = box(GC) 5; //~ERROR cannot assign to `x` because it is borrowed\n-    y = box(GC) 6; //~ERROR cannot assign to `y` because it is borrowed\n+    x = box(GC) 5i; //~ERROR cannot assign to `x` because it is borrowed\n+    y = box(GC) 6i; //~ERROR cannot assign to `y` because it is borrowed\n \n     println!(\"*r = {}, exp = {}\", *r, exp);\n     assert_eq!(*r, exp);\n-    assert_eq!(x, box(GC) 5);\n-    assert_eq!(y, box(GC) 6);\n+    assert_eq!(x, box(GC) 5i);\n+    assert_eq!(y, box(GC) 6i);\n }\n \n pub fn main() {"}, {"sha": "15a70b2444d5cc4f65ef294018b2a014d7f06b6d", "filename": "src/test/compile-fail/borrowck-while-break.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fborrowck-while-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fborrowck-while-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-while-break.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,7 +11,7 @@\n fn test(cond: bool) {\n     let v;\n     while cond {\n-        v = 3;\n+        v = 3i;\n         break;\n     }\n     println!(\"{}\", v); //~ ERROR use of possibly uninitialized variable: `v`"}, {"sha": "ce58b260f61860ef6dd2107cd17770a2964ce90a", "filename": "src/test/compile-fail/cast-vector-to-unsafe-nonstatic.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f7f95c8f5a6294f161800dbb65a0423bb5248f34/src%2Ftest%2Fcompile-fail%2Fcast-vector-to-unsafe-nonstatic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f95c8f5a6294f161800dbb65a0423bb5248f34/src%2Ftest%2Fcompile-fail%2Fcast-vector-to-unsafe-nonstatic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-vector-to-unsafe-nonstatic.rs?ref=f7f95c8f5a6294f161800dbb65a0423bb5248f34", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    let foo = ['h' as u8, 'i' as u8, 0 as u8];\n-    let bar = &foo as *u8; //~ ERROR mismatched types\n-}"}, {"sha": "27aa43638f4e4081e4b35551556327e970f934ca", "filename": "src/test/compile-fail/destructure-trait-ref.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -25,17 +25,17 @@ fn main() {\n     // if n > m, it's a type mismatch error.\n \n     // n < m\n-    let &x = &(&1 as &T);\n-    let &x = &&(&1 as &T);\n-    let &&x = &&(&1 as &T);\n+    let &x = &(&1i as &T);\n+    let &x = &&(&1i as &T);\n+    let &&x = &&(&1i as &T);\n \n     // n == m\n-    let &x = &1 as &T;      //~ ERROR cannot be dereferenced\n-    let &&x = &(&1 as &T);  //~ ERROR cannot be dereferenced\n-    let box x = box 1 as Box<T>; //~ ERROR cannot be dereferenced\n+    let &x = &1i as &T;      //~ ERROR cannot be dereferenced\n+    let &&x = &(&1i as &T);  //~ ERROR cannot be dereferenced\n+    let box x = box 1i as Box<T>; //~ ERROR cannot be dereferenced\n \n     // n > m\n-    let &&x = &1 as &T;     //~ ERROR found an `&`-pointer pattern\n-    let &&&x = &(&1 as &T); //~ ERROR found an `&`-pointer pattern\n-    let box box x = box 1 as Box<T>;    //~ ERROR found a box pattern\n+    let &&x = &1i as &T;     //~ ERROR found an `&`-pointer pattern\n+    let &&&x = &(&1i as &T); //~ ERROR found an `&`-pointer pattern\n+    let box box x = box 1i as Box<T>;    //~ ERROR found a box pattern\n }"}, {"sha": "eadd16348b2e8573b81138986176cd7d9aca6f4e", "filename": "src/test/compile-fail/issue-4335.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -15,6 +15,6 @@ fn f<'r, T>(v: &'r T) -> ||: 'r -> T {\n }\n \n fn main() {\n-    let v = &5;\n+    let v = &5i;\n     println!(\"{}\", f(v)());\n }"}, {"sha": "b90a7f233b6d4cf3ed618df86853f10d0baf0902", "filename": "src/test/compile-fail/issue-4517.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fissue-4517.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fissue-4517.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4517.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,7 +11,7 @@\n fn bar(int_param: int) {}\n \n fn main() {\n-    let foo: [u8, ..4] = [1u8, ..4u8];\n+    let foo: [u8, ..4] = [1u8, ..4u];\n     bar(foo);\n     //~^ ERROR mismatched types: expected `int` but found `[u8, .. 4]`\n     //         (expected int but found vector)"}, {"sha": "50704a1afbf4ec14b3f5998b13d6ba18c6f970f7", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -24,7 +24,7 @@ fn main() {\n     // ~Repeat<&'blk int> where blk is the lifetime of the block below.\n \n     let y = {\n-        let tmp0 = 3;\n+        let tmp0 = 3i;\n         let tmp1 = &tmp0; //~ ERROR `tmp0` does not live long enough\n         repeater(tmp1)\n     };"}, {"sha": "b0d517d18f7eeff30055df9c690981955479965a", "filename": "src/test/compile-fail/lint-dead-code-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -80,6 +80,6 @@ mod inner {\n }\n \n pub fn foo() {\n-    let a = &1 as &inner::Trait;\n+    let a = &1i as &inner::Trait;\n     a.f();\n }"}, {"sha": "f5ad5e6af0c8a81c10a35a197d97e64ace9bf571", "filename": "src/test/compile-fail/liveness-bad-bang-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fliveness-bad-bang-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fliveness-bad-bang-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-bad-bang-2.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,6 +11,6 @@\n // Tests that a function with a ! annotation always actually fails\n // error-pattern: some control paths may return\n \n-fn bad_bang(i: uint) -> ! { println!(\"{}\", 3); }\n+fn bad_bang(i: uint) -> ! { println!(\"{}\", 3i); }\n \n fn main() { bad_bang(5u); }"}, {"sha": "0b8e65fee0844608871c14a1f9b1cc2c9e32d24b", "filename": "src/test/compile-fail/liveness-use-after-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,7 +11,7 @@\n extern crate debug;\n \n fn main() {\n-    let x = box 5;\n+    let x = box 5i;\n     let y = x;\n     println!(\"{:?}\", *x); //~ ERROR use of partially moved value: `*x`\n     y.clone();"}, {"sha": "1c8b7fbf85cc570ff0ed43ba9d88f8bd5709a1de", "filename": "src/test/compile-fail/method-missing-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fmethod-missing-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fmethod-missing-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-missing-call.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -33,7 +33,7 @@ fn main() {\n                         //~^ NOTE maybe a missing `()` to call it? If not, try an anonymous\n \n     // Ensure the span is useful\n-    let ys = &[1,2,3,4,5,6,7];\n+    let ys = &[1i,2,3,4,5,6,7];\n     let a = ys.iter()\n               .map(|x| x)\n               .filter(|&&x| x == 1)"}, {"sha": "ec218768a98eedf44f764ae006fac58d2ed16bcf", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -14,7 +14,7 @@ use std::sync::Arc;\n use std::task;\n \n fn main() {\n-    let v = vec!(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+    let v = vec!(1i, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n     let arc_v = Arc::new(v);\n \n     task::spawn(proc() {"}, {"sha": "b8009031883c63cacc3887401511df31f9d0e9c0", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -12,7 +12,7 @@ use std::sync::Arc;\n use std::task;\n \n fn main() {\n-    let v = vec!(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+    let v = vec!(1i, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n     let arc_v = Arc::new(v);\n \n     task::spawn(proc() {"}, {"sha": "41ea0c88e0743a3101521610e25e90b02758ca77", "filename": "src/test/compile-fail/non-constant-expr-for-vec-repeat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,7 +11,7 @@\n // Check that non constant exprs fail for vector repeat syntax\n \n fn main() {\n-    fn bar(n: int) {\n+    fn bar(n: uint) {\n         let _x = [0, ..n]; //~ ERROR expected constant integer for repeat count but found variable\n     }\n }"}, {"sha": "842fe3fde41fc7dc5b7fbab2d3869f39fb099458", "filename": "src/test/compile-fail/regions-appearance-constraint.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fregions-appearance-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fregions-appearance-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-appearance-constraint.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -15,23 +15,23 @@\n use std::gc::GC;\n \n fn testfn(cond: bool) {\n-    let mut x = box(GC) 3;\n-    let mut y = box(GC) 4;\n+    let mut x = box(GC) 3i;\n+    let mut y = box(GC) 4i;\n \n     let mut a = &*x;\n \n-    let mut exp = 3;\n+    let mut exp = 3i;\n     if cond {\n         a = &*y;\n \n         exp = 4;\n     }\n \n-    x = box(GC) 5; //~ERROR cannot assign to `x` because it is borrowed\n-    y = box(GC) 6; //~ERROR cannot assign to `y` because it is borrowed\n+    x = box(GC) 5i; //~ERROR cannot assign to `x` because it is borrowed\n+    y = box(GC) 6i; //~ERROR cannot assign to `y` because it is borrowed\n     assert_eq!(*a, exp);\n-    assert_eq!(x, box(GC) 5);\n-    assert_eq!(y, box(GC) 6);\n+    assert_eq!(x, box(GC) 5i);\n+    assert_eq!(y, box(GC) 6i);\n }\n \n pub fn main() {}"}, {"sha": "cef3b52599799787fec31e87697fbc862f1c2baf", "filename": "src/test/compile-fail/regions-freevar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,7 +11,7 @@\n fn wants_static_fn(_x: ||: 'static) {}\n \n fn main() {\n-    let i = 3;\n+    let i = 3i;\n     wants_static_fn(|| { //~ ERROR cannot infer\n         println!(\"i={}\", i);\n     })"}, {"sha": "a954b16699fda43c2a6be38f6931e8fc9759fdb9", "filename": "src/test/compile-fail/regions-var-type-out-of-scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -14,8 +14,8 @@ fn foo(cond: bool) {\n     let mut x;\n \n     if cond {\n-        x = &3; //~ ERROR borrowed value does not live long enough\n-        assert_eq!(*x, 3);\n+        x = &3i; //~ ERROR borrowed value does not live long enough\n+        assert_eq!(*x, 3i);\n     }\n }\n "}, {"sha": "3dce0178597cfdda50f123c6a65c6630dbe6a8b0", "filename": "src/test/compile-fail/trait-test-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -16,5 +16,5 @@ impl bar for uint { fn dup(&self) -> uint { *self } fn blah<X>(&self) {} }\n fn main() {\n     10i.dup::<int>(); //~ ERROR does not take type parameters\n     10i.blah::<int, int>(); //~ ERROR incorrect number of type parameters\n-    (box 10 as Box<bar>).dup(); //~ ERROR contains a self-type\n+    (box 10i as Box<bar>).dup(); //~ ERROR contains a self-type\n }"}, {"sha": "94383d9724cbe57b11ff60c35a68becafd2f4079", "filename": "src/test/pretty/path-type-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -19,6 +19,6 @@ fn foo(x: Box<Tr+ Share>) -> Box<Tr+ Share> { x }\n fn main() {\n     let x: Box<Tr+ Share>;\n \n-    box() 1 as Box<Tr+ Share>;\n+    box() 1i as Box<Tr+ Share>;\n }\n "}, {"sha": "69ed025070b4f95d088f3d08c3c739733abef32b", "filename": "src/test/run-fail/assert-eq-macro-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-fail%2Fassert-eq-macro-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-fail%2Fassert-eq-macro-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fassert-eq-macro-fail.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,5 +11,5 @@\n // error-pattern:assertion failed: `(left == right) && (right == left)` (left: `14`, right: `15`)\n \n fn main() {\n-    assert_eq!(14,15);\n+    assert_eq!(14i,15i);\n }"}, {"sha": "72222ce43627eaa45028a00ba7b5acf88b8f136d", "filename": "src/test/run-fail/assert-macro-fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-fail%2Fassert-macro-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-fail%2Fassert-macro-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fassert-macro-fmt.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,5 +11,5 @@\n // error-pattern:failed at 'test-assert-fmt 42 rust'\n \n fn main() {\n-    assert!(false, \"test-assert-fmt {} {}\", 42, \"rust\");\n+    assert!(false, \"test-assert-fmt {} {}\", 42i, \"rust\");\n }"}, {"sha": "528f18dde0d3bacdf06a02801f42702ba3ec1f25", "filename": "src/test/run-fail/fail-macro-any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-fail%2Ffail-macro-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-fail%2Ffail-macro-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-macro-any.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -12,5 +12,5 @@\n \n \n fn main() {\n-    fail!(box 413 as Box<::std::any::Any+Send>);\n+    fail!(box 413i as Box<::std::any::Any+Send>);\n }"}, {"sha": "b3984c210b5b412ea8f08a8ea6f484f0eb5381be", "filename": "src/test/run-fail/fail-macro-fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-fail%2Ffail-macro-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-fail%2Ffail-macro-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-macro-fmt.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,5 +11,5 @@\n // error-pattern:failed at 'test-fail-fmt 42 rust'\n \n fn main() {\n-    fail!(\"test-fail-fmt {} {}\", 42, \"rust\");\n+    fail!(\"test-fail-fmt {} {}\", 42i, \"rust\");\n }"}, {"sha": "22ab9d0bbaea29f3cb1aa28d37beb0465d439fa4", "filename": "src/test/run-fail/unwind-box-fn-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-fail%2Funwind-box-fn-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-fail%2Funwind-box-fn-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-fn-unique.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -21,7 +21,7 @@ fn failfn() {\n }\n \n fn main() {\n-    let y = box 0;\n+    let y = box 0i;\n     let x: Gc<proc():Send> = box(GC) (proc() {\n         println!(\"{:?}\", y.clone());\n     });"}, {"sha": "1eae3f49f27339c9a5e2f8d5766af1c049e6e1d3", "filename": "src/test/run-fail/unwind-box-unique-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-fail%2Funwind-box-unique-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-fail%2Funwind-box-unique-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-unique-unique.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -21,7 +21,7 @@ fn failfn() {\n }\n \n fn main() {\n-    let x = box(GC) box box 0;\n+    let x = box(GC) box box 0i;\n     failfn();\n     println!(\"{:?}\", x);\n }"}, {"sha": "be4c929a2f2bcd09f52b8ee6f97e04a12a70c6d6", "filename": "src/test/run-fail/unwind-box-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-fail%2Funwind-box-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-fail%2Funwind-box-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-unique.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -21,7 +21,7 @@ fn failfn() {\n }\n \n fn main() {\n-    let x = box(GC) box 0;\n+    let x = box(GC) box 0i;\n     failfn();\n     println!(\"{:?}\", x);\n }"}, {"sha": "acf87b19c76d24076772d293525c09461a1d31a6", "filename": "src/test/run-fail/unwind-box-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-fail%2Funwind-box-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-fail%2Funwind-box-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-vec.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -21,7 +21,7 @@ fn failfn() {\n }\n \n fn main() {\n-    let x = box(GC) vec!(0, 1, 2, 3, 4, 5);\n+    let x = box(GC) vec!(0i, 1, 2, 3, 4, 5);\n     failfn();\n     println!(\"{:?}\", x);\n }"}, {"sha": "314949cc593126e39fad5f83572b07a6b7d69a9b", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -22,7 +22,7 @@ fn random_char() -> char {\n     let mut rng = task_rng();\n     // a subset of the XID_start unicode table (ensuring that the\n     // compiler doesn't fail with an \"unrecognised token\" error)\n-    let (lo, hi): (u32, u32) = match rng.gen_range(1, 4 + 1) {\n+    let (lo, hi): (u32, u32) = match rng.gen_range(1u32, 4u32 + 1) {\n         1 => (0x41, 0x5a),\n         2 => (0xf8, 0x1ba),\n         3 => (0x1401, 0x166c),\n@@ -43,11 +43,11 @@ fn main() {\n             .write_str(\"mod unicode_input_multiple_files_chars;\");\n     }\n \n-    for _ in range(0, 100) {\n+    for _ in range(0u, 100) {\n         {\n             let randoms = tmpdir.join(\"unicode_input_multiple_files_chars.rs\");\n             let mut w = File::create(&randoms).unwrap();\n-            for _ in range(0, 30) {\n+            for _ in range(0u, 30) {\n                 let _ = w.write_char(random_char());\n             }\n         }"}, {"sha": "903ca69f247f25847d08320066cbbdc4c9df3acd", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -21,7 +21,7 @@ fn random_char() -> char {\n     let mut rng = task_rng();\n     // a subset of the XID_start unicode table (ensuring that the\n     // compiler doesn't fail with an \"unrecognised token\" error)\n-    let (lo, hi): (u32, u32) = match rng.gen_range(1, 4 + 1) {\n+    let (lo, hi): (u32, u32) = match rng.gen_range(1u32, 4u32 + 1) {\n         1 => (0x41, 0x5a),\n         2 => (0xf8, 0x1ba),\n         3 => (0x1401, 0x166c),\n@@ -37,7 +37,7 @@ fn main() {\n     let tmpdir = Path::new(args.get(2).as_slice());\n     let main_file = tmpdir.join(\"span_main.rs\");\n \n-    for _ in range(0, 100) {\n+    for _ in range(0u, 100) {\n         let n = task_rng().gen_range(3u, 20);\n \n         {"}, {"sha": "820606179bc1ecbc9684871b24383d74450210d2", "filename": "src/test/run-pass-fulldeps/syntax-extension-hexfloat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-hexfloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-hexfloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-hexfloat.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -17,7 +17,7 @@ extern crate hexfloat;\n \n pub fn main() {\n     let a = hexfloat!(\"0x1.999999999999ap-4\");\n-    assert_eq!(a, 0.1);\n+    assert_eq!(a, 0.1f64);\n     let b = hexfloat!(\"-0x1.fffp-4\", f32);\n     assert_eq!(b, -0.12498474_f32);\n     let c = hexfloat!(\"0x.12345p5\", f64);"}, {"sha": "1e043d77fa811cea1c02646b926560293e920e99", "filename": "src/test/run-pass/arith-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Farith-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Farith-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-1.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -22,7 +22,7 @@ pub fn main() {\n     assert_eq!(i32_a * i32_a * i32_a, 1000);\n     assert_eq!(i32_a * i32_a * i32_a * i32_a, 10000);\n     assert_eq!(i32_a * i32_a / i32_a * i32_a, 100);\n-    assert_eq!(i32_a * (i32_a - 1) << 2 + i32_a, 368640);\n+    assert_eq!(i32_a * (i32_a - 1) << (2 + i32_a as uint), 368640);\n     let i32_b: int = 0x10101010;\n     assert_eq!(i32_b + 1 - 1, i32_b);\n     assert_eq!(i32_b << 1, i32_b << 1);"}, {"sha": "63d9c6063b613ba60f4d1264ae344bc79460a286", "filename": "src/test/run-pass/assert-eq-macro-success.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -16,7 +16,7 @@ use std::gc::GC;\n struct Point { x : int }\n \n pub fn main() {\n-    assert_eq!(14,14);\n+    assert_eq!(14i,14i);\n     assert_eq!(\"abc\".to_string(),\"abc\".to_string());\n     assert_eq!(box Point{x:34},box Point{x:34});\n     assert_eq!(&Point{x:34},&Point{x:34});"}, {"sha": "f1fe1e945870a7c2d591d02742eafabb8c133097", "filename": "src/test/run-pass/auto-instantiate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -17,5 +17,5 @@ fn f<T,U>(x: T, y: U) -> Pair<T, U> { return Pair {a: x, b: y}; }\n \n pub fn main() {\n     println!(\"{:?}\", f(Triple {x: 3, y: 4, z: 5}, 4).a.x);\n-    println!(\"{:?}\", f(5, 6).a);\n+    println!(\"{:?}\", f(5i, 6i).a);\n }"}, {"sha": "88884dfeb502c207be2eea5f078256ea446632a2", "filename": "src/test/run-pass/auto-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-loop.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let mut sum = 0;\n+    let mut sum = 0i;\n     let xs = vec!(1, 2, 3, 4, 5);\n     for x in xs.iter() {\n         sum += *x;"}, {"sha": "fd3ede07e210ff500aa24f5dbec8571b8e4f463d", "filename": "src/test/run-pass/auto-ref-sliceable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -20,7 +20,7 @@ impl<T> Pushable<T> for Vec<T> {\n }\n \n pub fn main() {\n-    let mut v = vec!(1);\n+    let mut v = vec!(1i);\n     v.push_val(2);\n     v.push_val(3);\n     assert_eq!(v, vec!(1, 2, 3));"}, {"sha": "616b247bbb77c28e6c65e5bc8b6fb501bf98ba34", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -75,7 +75,7 @@ fn runtest(me: &str) {\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();\n     let mut i = 0;\n-    for _ in range(0, 2) {\n+    for _ in range(0i, 2) {\n         i += s.slice_from(i + 10).find_str(\"stack backtrace\").unwrap() + 10;\n     }\n     assert!(s.slice_from(i + 10).find_str(\"stack backtrace\").is_none(),"}, {"sha": "c21ea343b161ab6c6deb7b7771b89736533b7b74", "filename": "src/test/run-pass/big-literals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbig-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbig-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbig-literals.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -16,5 +16,5 @@ pub fn main() {\n \n     assert_eq!(-2147483648i32 - 1i32, 2147483647i32);\n     assert_eq!(-9223372036854775808i64 - 1i64, 9223372036854775807i64);\n-    assert_eq!(-9223372036854775808 - 1, 9223372036854775807);\n+    assert_eq!(-9223372036854775808i - 1, 9223372036854775807);\n }"}, {"sha": "9c6e6ab60abe20f453088638355561f7f16b6037", "filename": "src/test/run-pass/binary-minus-without-space.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,6 +11,6 @@\n // Check that issue #954 stays fixed\n \n pub fn main() {\n-    match -1 { -1 => {}, _ => fail!(\"wat\") }\n-    assert_eq!(1-1, 0);\n+    match -1i { -1 => {}, _ => fail!(\"wat\") }\n+    assert_eq!(1i-1, 0i);\n }"}, {"sha": "ff4dcc18bb495245b04b928a645d2124c62cfc5c", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -47,14 +47,14 @@ fn test_bool() {\n }\n \n fn test_box() {\n-    assert_eq!(box(GC) 10, box(GC) 10);\n+    assert_eq!(box(GC) 10i, box(GC) 10i);\n }\n \n fn test_ptr() {\n     unsafe {\n-        let p1: *u8 = ::std::mem::transmute(0);\n-        let p2: *u8 = ::std::mem::transmute(0);\n-        let p3: *u8 = ::std::mem::transmute(1);\n+        let p1: *u8 = ::std::mem::transmute(0u);\n+        let p2: *u8 = ::std::mem::transmute(0u);\n+        let p3: *u8 = ::std::mem::transmute(1u);\n \n         assert_eq!(p1, p2);\n         assert!(p1 != p3);"}, {"sha": "8c2dba243c87c7da5f95bb6729b942eaef6b6b7f", "filename": "src/test/run-pass/bitv-perf-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -19,5 +19,5 @@ fn bitv_test() {\n }\n \n pub fn main() {\n-    for _ in range(0, 10000) { bitv_test(); }\n+    for _ in range(0i, 10000) { bitv_test(); }\n }"}, {"sha": "305739a56d750c04a7c7d68fb05f229bc09d0d4e", "filename": "src/test/run-pass/bitwise.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbitwise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbitwise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitwise.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -30,12 +30,12 @@ fn general() {\n     println!(\"{}\", b);\n     assert_eq!(b, 1);\n     assert_eq!(a, 2);\n-    assert_eq!(!0xf0 & 0xff, 0xf);\n-    assert_eq!(0xf0 | 0xf, 0xff);\n-    assert_eq!(0xf << 4, 0xf0);\n-    assert_eq!(0xf0 >> 4, 0xf);\n-    assert_eq!(-16 >> 2, -4);\n-    assert_eq!(0b1010_1010 | 0b0101_0101, 0xff);\n+    assert_eq!(!0xf0i & 0xff, 0xf);\n+    assert_eq!(0xf0i | 0xf, 0xff);\n+    assert_eq!(0xfi << 4, 0xf0);\n+    assert_eq!(0xf0i >> 4, 0xf);\n+    assert_eq!(-16i >> 2, -4);\n+    assert_eq!(0b1010_1010i | 0b0101_0101, 0xff);\n }\n \n pub fn main() {"}, {"sha": "31d0d52f8b4f7d5de90f261c00846c5be5c264f7", "filename": "src/test/run-pass/block-expr-precedence.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fblock-expr-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fblock-expr-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-expr-precedence.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -58,9 +58,9 @@ pub fn main() {\n \n   let num = 12;\n \n-  assert_eq!(if (true) { 12 } else { 12 } - num, 0);\n-  assert_eq!(12 - if (true) { 12 } else { 12 }, 0);\n-  if (true) { 12; } {-num};\n-  if (true) { 12; }; {-num};\n-  if (true) { 12; };;; -num;\n+  assert_eq!(if (true) { 12i } else { 12 } - num, 0);\n+  assert_eq!(12i - if (true) { 12i } else { 12 }, 0);\n+  if (true) { 12i; } {-num};\n+  if (true) { 12i; }; {-num};\n+  if (true) { 12i; };;; -num;\n }"}, {"sha": "dee013a9140323834194bb9c41ee00be78fc407b", "filename": "src/test/run-pass/block-iter-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -13,8 +13,8 @@ extern crate debug;\n fn iter_vec<T>(v: Vec<T> , f: |&T|) { for x in v.iter() { f(x); } }\n \n pub fn main() {\n-    let v = vec!(1, 2, 3, 4, 5, 6, 7);\n-    let mut odds = 0;\n+    let v = vec!(1i, 2, 3, 4, 5, 6, 7);\n+    let mut odds = 0i;\n     iter_vec(v, |i| {\n         if *i % 2 == 1 {\n             odds += 1;"}, {"sha": "82b162ba4bc68bf6b64fd63ba8549823465d36e0", "filename": "src/test/run-pass/block-iter-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -13,7 +13,7 @@ extern crate debug;\n fn iter_vec<T>(v: Vec<T> , f: |&T|) { for x in v.iter() { f(x); } }\n \n pub fn main() {\n-    let v = vec!(1, 2, 3, 4, 5);\n+    let v = vec!(1i, 2, 3, 4, 5);\n     let mut sum = 0;\n     iter_vec(v.clone(), |i| {\n         iter_vec(v.clone(), |j| {"}, {"sha": "71c8936570afb4a0964d7e82ca54cf5f1080d974", "filename": "src/test/run-pass/borrowck-fixed-length-vecs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fborrowck-fixed-length-vecs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fborrowck-fixed-length-vecs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-fixed-length-vecs.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let x = [22];\n+    let x = [22i];\n     let y = &x[0];\n     assert_eq!(*y, 22);\n }"}, {"sha": "4044e9f06afbb5624ed4ee37c46ac15f8d49f58e", "filename": "src/test/run-pass/borrowck-freeze-frozen-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fborrowck-freeze-frozen-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fborrowck-freeze-frozen-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-freeze-frozen-mut.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -19,7 +19,7 @@ fn get<'a, T>(ms: &'a MutSlice<'a, T>, index: uint) -> &'a T {\n }\n \n pub fn main() {\n-    let mut data = [1, 2, 3];\n+    let mut data = [1i, 2, 3];\n     {\n         let slice = MutSlice { data: data };\n         slice.data[0] += 4;"}, {"sha": "6136bc90fd42c942b7b3e1f46bcab6bffd055d6b", "filename": "src/test/run-pass/borrowck-pat-reassign-no-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fborrowck-pat-reassign-no-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fborrowck-pat-reassign-no-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-pat-reassign-no-binding.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -14,7 +14,7 @@ pub fn main() {\n       None => {\n         // It is ok to reassign x here, because there is in\n         // fact no outstanding loan of x!\n-        x = Some(0);\n+        x = Some(0i);\n       }\n       Some(_) => { }\n     }"}, {"sha": "e50317f71e802ff0176011b3e1a44ec0f60f3d24", "filename": "src/test/run-pass/borrowed-ptr-pattern-infallible.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-infallible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-infallible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-infallible.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,7 +11,7 @@\n #![feature(managed_boxes)]\n \n pub fn main() {\n-    let (&x, &y) = (&3, &'a');\n+    let (&x, &y) = (&3i, &'a');\n     assert_eq!(x, 3);\n     assert_eq!(y, 'a');\n }"}, {"sha": "3636d4d769d80e0699423a68db69c7e8218ae724", "filename": "src/test/run-pass/borrowed-ptr-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -15,6 +15,6 @@ fn foo<T:Clone>(x: &T) -> T{\n }\n \n pub fn main() {\n-    assert_eq!(foo(&3), 3);\n+    assert_eq!(foo(&3i), 3i);\n     assert_eq!(foo(&'a'), 'a');\n }"}, {"sha": "2ba2823eb9117917235320889ecedba35ae8e272", "filename": "src/test/run-pass/box-compare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbox-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbox-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-compare.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -13,7 +13,7 @@\n use std::gc::GC;\n \n pub fn main() {\n-    assert!((box(GC) 1 < box(GC) 3));\n+    assert!((box(GC) 1i < box(GC) 3i));\n     assert!((box(GC) box(GC) \"hello \".to_string() >\n              box(GC) box(GC) \"hello\".to_string()));\n     assert!((box(GC) box(GC) box(GC) \"hello\".to_string() !="}, {"sha": "21d1d2359019a60839d9b444833bb7b343dd2620", "filename": "src/test/run-pass/box-pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbox-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbox-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-pattern.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n fn main() {\n-    let box x = box 3;\n-    match box 3 {\n+    let box x = box 3i;\n+    match box 3i {\n         box y => {\n             assert!(x == y);\n             println!(\"{} {}\", x, y);"}, {"sha": "89745bd167c41b0dd9712c92c185e4c6b60056cf", "filename": "src/test/run-pass/break.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbreak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbreak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbreak.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n pub fn main() {\n-    let mut i = 0;\n+    let mut i = 0i;\n     while i < 20 { i += 1; if i == 10 { break; } }\n     assert_eq!(i, 10);\n     loop { i += 1; if i == 20 { break; } }\n     assert_eq!(i, 20);\n-    let xs = [1, 2, 3, 4, 5, 6];\n+    let xs = [1i, 2, 3, 4, 5, 6];\n     for x in xs.iter() {\n         if *x == 3 { break; } assert!((*x <= 3));\n     }\n@@ -25,7 +25,7 @@ pub fn main() {\n         i += 1; if i % 2 == 0 { continue; } assert!((i % 2 != 0));\n         if i >= 10 { break; }\n     }\n-    let ys = vec!(1, 2, 3, 4, 5, 6);\n+    let ys = vec!(1i, 2, 3, 4, 5, 6);\n     for x in ys.iter() {\n         if *x % 2 == 0 { continue; }\n         assert!((*x % 2 != 0));"}, {"sha": "8c4d10a2d598cf1b5a656af78821b73da861bc97", "filename": "src/test/run-pass/bug-7183-generics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -34,11 +34,11 @@ impl<T: Speak> Speak for Option<T> {\n \n \n pub fn main() {\n-    assert_eq!(3.hi(), \"hello: 3\".to_string());\n-    assert_eq!(Some(Some(3)).hi(),\n+    assert_eq!(3i.hi(), \"hello: 3\".to_string());\n+    assert_eq!(Some(Some(3i)).hi(),\n                \"something!something!hello: 3\".to_string());\n     assert_eq!(None::<int>.hi(), \"hello - none\".to_string());\n \n     assert_eq!(Some(None::<int>).hi(), \"something!hello - none\".to_string());\n-    assert_eq!(Some(3).hi(), \"something!hello: 3\".to_string());\n+    assert_eq!(Some(3i).hi(), \"something!hello: 3\".to_string());\n }"}, {"sha": "2abc58d8a4954f7b38f838fbc8128e1e8954e278", "filename": "src/test/run-pass/builtin-superkinds-capabilities-transitive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-transitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-transitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-transitive.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -26,6 +26,6 @@ fn foo<T: Foo>(val: T, chan: Sender<T>) {\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    foo(31337, tx);\n-    assert!(rx.recv() == 31337);\n+    foo(31337i, tx);\n+    assert!(rx.recv() == 31337i);\n }"}, {"sha": "51238b0ee52c98b2f5111202f0c8290882f94ee2", "filename": "src/test/run-pass/builtin-superkinds-capabilities-xc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -28,7 +28,7 @@ fn foo<T: RequiresRequiresShareAndSend>(val: T, chan: Sender<T>) {\n }\n \n pub fn main() {\n-    let (tx, rx) = channel();\n-    foo(X(31337), tx);\n-    assert!(rx.recv() == X(31337));\n+    let (tx, rx): (Sender<X<int>>, Receiver<X<int>>) = channel();\n+    foo(X(31337i), tx);\n+    assert!(rx.recv() == X(31337i));\n }"}, {"sha": "fb3e1b0272858c5e4e32a035a5e402949fb33fd6", "filename": "src/test/run-pass/builtin-superkinds-capabilities.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -21,7 +21,7 @@ fn foo<T: Foo>(val: T, chan: Sender<T>) {\n }\n \n pub fn main() {\n-    let (tx, rx) = channel();\n-    foo(31337, tx);\n-    assert!(rx.recv() == 31337);\n+    let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n+    foo(31337i, tx);\n+    assert!(rx.recv() == 31337i);\n }"}, {"sha": "1e28c44206ffc9492333bac1ed1ca273935d3c92", "filename": "src/test/run-pass/byte-literals.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbyte-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fbyte-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbyte-literals.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -25,8 +25,6 @@ pub fn main() {\n     assert_eq!(b'\\xF0', 240u8);\n     assert_eq!(FOO, 240u8);\n \n-    assert_eq!([42, ..b'\\t'].as_slice(), &[42, 42, 42, 42, 42, 42, 42, 42, 42]);\n-\n     match 42 {\n         b'*' => {},\n         _ => fail!()"}, {"sha": "df03c93dad3ad3488c75f18591414e22fd492566", "filename": "src/test/run-pass/cci_iter_exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -15,7 +15,7 @@ extern crate cci_iter_lib;\n pub fn main() {\n     //let bt0 = sys::rusti::frame_address(1u32);\n     //println!(\"%?\", bt0);\n-    cci_iter_lib::iter([1, 2, 3], |i| {\n+    cci_iter_lib::iter([1i, 2, 3], |i| {\n         println!(\"{}\", *i);\n         //assert!(bt0 == sys::rusti::frame_address(2u32));\n     })"}, {"sha": "6666b8e3cfad581e4f20508c23c92dfbddd0adb7", "filename": "src/test/run-pass/closure-inference2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fclosure-inference2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fclosure-inference2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-inference2.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -12,6 +12,6 @@\n \n pub fn main() {\n     let f = {|i| i};\n-    assert_eq!(f(2), 2);\n-    assert_eq!(f(5), 5);\n+    assert_eq!(f(2i), 2i);\n+    assert_eq!(f(5i), 5i);\n }"}, {"sha": "34292453ec407dff6e5f54126ca0221eaf11bd5d", "filename": "src/test/run-pass/complex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomplex.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -35,8 +35,8 @@ fn foo(x: int) -> int {\n }\n \n pub fn main() {\n-    let x: int = 2 + 2;\n+    let x: int = 2i + 2;\n     println!(\"{}\", x);\n     println!(\"hello, world\");\n-    println!(\"{}\", 10);\n+    println!(\"{}\", 10i);\n }"}, {"sha": "5dd9f829d0a2c50b8e9bd0c973d4510bed3817bf", "filename": "src/test/run-pass/const-expr-in-vec-repeat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fconst-expr-in-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fconst-expr-in-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-expr-in-vec-repeat.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -12,7 +12,7 @@\n \n pub fn main() {\n \n-    static FOO: int = 2;\n-    let _v = [0, ..FOO*3*2/2];\n+    static FOO: uint = 2;\n+    let _v = [0i, ..FOO*3*2/2];\n \n }"}, {"sha": "2a15774fb17a847aa2624b23bb9adf06654cae5f", "filename": "src/test/run-pass/consts-in-patterns.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fconsts-in-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fconsts-in-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts-in-patterns.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -12,11 +12,11 @@ static FOO: int = 10;\n static BAR: int = 3;\n \n pub fn main() {\n-    let x: int = 3;\n+    let x: int = 3i;\n     let y = match x {\n-        FOO => 1,\n-        BAR => 2,\n-        _ => 3\n+        FOO => 1i,\n+        BAR => 2i,\n+        _ => 3i\n     };\n     assert_eq!(y, 2);\n }"}, {"sha": "753fada58ab927d7a98793f77f5dafaa8ed4fccb", "filename": "src/test/run-pass/deref-lval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fderef-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fderef-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderef-lval.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -16,7 +16,7 @@ use std::cell::Cell;\n use std::gc::GC;\n \n pub fn main() {\n-    let x = box(GC) Cell::new(5);\n-    x.set(1000);\n+    let x = box(GC) Cell::new(5i);\n+    x.set(1000i);\n     println!(\"{:?}\", x.get());\n }"}, {"sha": "03697875d5646238a574bc8b9c06c4550e14281f", "filename": "src/test/run-pass/deref-rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fderef-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fderef-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderef-rc.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,6 +11,6 @@\n use std::rc::Rc;\n \n fn main() {\n-    let x = Rc::new([1, 2, 3, 4]);\n+    let x = Rc::new([1i, 2, 3, 4]);\n     assert!(*x == [1, 2, 3, 4]);\n }"}, {"sha": "692a62f4ed0b045152fc00b400a86b17d6fcae73", "filename": "src/test/run-pass/deriving-cmp-generic-enum.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -17,10 +17,10 @@ enum E<T> {\n \n pub fn main() {\n     let e0 = E0;\n-    let e11 = E1(1);\n-    let e12 = E1(2);\n-    let e21 = E2(1, 1);\n-    let e22 = E2(1, 2);\n+    let e11 = E1(1i);\n+    let e12 = E1(2i);\n+    let e21 = E2(1i, 1i);\n+    let e22 = E2(1i, 2i);\n \n     // in order for both PartialOrd and Ord\n     let es = [e0, e11, e12, e21, e22];"}, {"sha": "2add2b6711f316a4f369fed0ccc774db2b25ed8a", "filename": "src/test/run-pass/deriving-cmp-generic-struct-enum.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -18,7 +18,17 @@ enum ES<T> {\n \n \n pub fn main() {\n-    let (es11, es12, es21, es22) = (ES1 {x: 1}, ES1 {x: 2}, ES2 {x: 1, y: 1}, ES2 {x: 1, y: 2});\n+    let (es11, es12, es21, es22) = (ES1 {\n+        x: 1i\n+    }, ES1 {\n+        x: 2i\n+    }, ES2 {\n+        x: 1i,\n+        y: 1i\n+    }, ES2 {\n+        x: 1i,\n+        y: 2i\n+    });\n \n     // in order for both PartialOrd and Ord\n     let ess = [es11, es12, es21, es22];"}, {"sha": "2576cce6503d41eb014ae33304677ce4a16c9b22", "filename": "src/test/run-pass/deriving-cmp-generic-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -15,8 +15,8 @@ struct S<T> {\n }\n \n pub fn main() {\n-    let s1 = S {x: 1, y: 1};\n-    let s2 = S {x: 1, y: 2};\n+    let s1 = S {x: 1i, y: 1i};\n+    let s2 = S {x: 1i, y: 2i};\n \n     // in order for both PartialOrd and Ord\n     let ss = [s1, s2];"}, {"sha": "8ab529996e50c5a9fcb32824869897c4f23efe60", "filename": "src/test/run-pass/deriving-cmp-generic-tuple-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -13,8 +13,8 @@ struct TS<T>(T,T);\n \n \n pub fn main() {\n-    let ts1 = TS(1, 1);\n-    let ts2 = TS(1, 2);\n+    let ts1 = TS(1i, 1i);\n+    let ts2 = TS(1i, 2i);\n \n     // in order for both PartialOrd and Ord\n     let tss = [ts1, ts2];"}, {"sha": "f0f2f86a7c6229532ad3aa350b52c1bed3d3977e", "filename": "src/test/run-pass/deriving-rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fderiving-rand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fderiving-rand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-rand.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -33,7 +33,7 @@ enum D {\n \n pub fn main() {\n     // check there's no segfaults\n-    for _ in range(0, 20) {\n+    for _ in range(0i, 20) {\n         rand::random::<A>();\n         rand::random::<B>();\n         rand::random::<C>();"}, {"sha": "a3151e0a8fa6fff8542dcf15186f45bad6bb6567", "filename": "src/test/run-pass/deriving-via-extension-type-params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -17,8 +17,8 @@ struct Foo<T> {\n }\n \n pub fn main() {\n-    let a = Foo { x: 1, y: 2.0, z: 3 };\n-    let b = Foo { x: 1, y: 2.0, z: 3 };\n+    let a = Foo { x: 1, y: 2.0f64, z: 3 };\n+    let b = Foo { x: 1, y: 2.0f64, z: 3 };\n     assert_eq!(a, b);\n     assert!(!(a != b));\n     assert!(a.eq(&b));"}, {"sha": "70030c66ca2aac481756e405c1cfd93f52fee66d", "filename": "src/test/run-pass/early-vtbl-resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fearly-vtbl-resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fearly-vtbl-resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fearly-vtbl-resolution.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -19,5 +19,5 @@ fn foo_func<A, B: thing<A>>(x: B) -> Option<A> { x.foo() }\n struct A { a: int }\n \n pub fn main() {\n-    let _x: Option<f64> = foo_func(0);\n+    let _x: Option<f64> = foo_func(0i);\n }"}, {"sha": "bb236638905ba9d47c21d65fa67122ff3176c215", "filename": "src/test/run-pass/exponential-notation.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexponential-notation.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -17,18 +17,18 @@ macro_rules! t(($a:expr, $b:expr) => { { let (r, _) = $a; assert_eq!(r, $b.to_st\n \n pub fn main() {\n     // Basic usage\n-    t!(to_str(1.2345678e-5, 10u, true, s::SignNeg, s::DigMax(6), s::ExpDec, false),\n+    t!(to_str(1.2345678e-5f64, 10u, true, s::SignNeg, s::DigMax(6), s::ExpDec, false),\n              \"1.234568e-5\")\n \n     // Hexadecimal output\n-    t!(to_str(7.281738281250e+01, 16u, true, s::SignAll, s::DigMax(6), s::ExpBin, false),\n+    t!(to_str(7.281738281250e+01f64, 16u, true, s::SignAll, s::DigMax(6), s::ExpBin, false),\n               \"+1.2345p+6\")\n-    t!(to_str(-1.777768135071e-02, 16u, true, s::SignAll, s::DigMax(6), s::ExpBin, false),\n+    t!(to_str(-1.777768135071e-02f64, 16u, true, s::SignAll, s::DigMax(6), s::ExpBin, false),\n              \"-1.2345p-6\")\n \n     // Some denormals\n-    t!(to_str(4.9406564584124654e-324, 10u, true, s::SignNeg, s::DigMax(6), s::ExpBin, false),\n+    t!(to_str(4.9406564584124654e-324f64, 10u, true, s::SignNeg, s::DigMax(6), s::ExpBin, false),\n              \"1p-1074\")\n-    t!(to_str(2.2250738585072009e-308, 10u, true, s::SignNeg, s::DigMax(6), s::ExpBin, false),\n+    t!(to_str(2.2250738585072009e-308f64, 10u, true, s::SignNeg, s::DigMax(6), s::ExpBin, false),\n              \"1p-1022\")\n }"}, {"sha": "7af9e790504df5b1b67986a9dac79a6a6d231044", "filename": "src/test/run-pass/expr-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fexpr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fexpr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -20,7 +20,7 @@ struct RS { v1: int, v2: int }\n fn test_rec() { let rs = { RS {v1: 10, v2: 20} }; assert!((rs.v2 == 20)); }\n \n fn test_filled_with_stuff() {\n-    let rs = { let mut a = 0; while a < 10 { a += 1; } a };\n+    let rs = { let mut a = 0i; while a < 10 { a += 1; } a };\n     assert_eq!(rs, 10);\n }\n "}, {"sha": "fc2912c184fefac51eae9072a7180ec1023c7d98", "filename": "src/test/run-pass/expr-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-fn.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -22,7 +22,7 @@ fn test_vec() {\n \n fn test_generic() {\n     fn f<T>(t: T) -> T { t }\n-    assert_eq!(f(10), 10);\n+    assert_eq!(f(10i), 10);\n }\n \n fn test_alt() {"}, {"sha": "ce101b0d23c1421531574a524bb9e3bc96834fea", "filename": "src/test/run-pass/expr-if-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fexpr-if-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fexpr-if-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-box.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -14,7 +14,7 @@ use std::gc::{Gc, GC};\n \n // Tests for if as expressions returning boxed types\n fn test_box() {\n-    let rs = if true { box(GC) 100 } else { box(GC) 101 };\n+    let rs = if true { box(GC) 100i } else { box(GC) 101i };\n     assert_eq!(*rs, 100);\n }\n "}, {"sha": "023ba508ae5f393a676896102359c3954219eb4f", "filename": "src/test/run-pass/expr-if-fail.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fexpr-if-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fexpr-if-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-fail.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,13 +11,13 @@\n fn test_if_fail() { let x = if false { fail!() } else { 10 }; assert!((x == 10)); }\n \n fn test_else_fail() {\n-    let x = if true { 10 } else { fail!() };\n-    assert_eq!(x, 10);\n+    let x = if true { 10i } else { fail!() };\n+    assert_eq!(x, 10i);\n }\n \n fn test_elseif_fail() {\n-    let x = if false { 0 } else if false { fail!() } else { 10 };\n-    assert_eq!(x, 10);\n+    let x = if false { 0 } else if false { fail!() } else { 10i };\n+    assert_eq!(x, 10i);\n }\n \n pub fn main() { test_if_fail(); test_else_fail(); test_elseif_fail(); }"}, {"sha": "b1fdf51d9b13368f6ec7d32064c2bfb72f2482a6", "filename": "src/test/run-pass/expr-if-unique.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fexpr-if-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fexpr-if-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-unique.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -14,8 +14,8 @@\n \n // Tests for if as expressions returning boxed types\n fn test_box() {\n-    let rs = if true { box 100 } else { box 101 };\n-    assert_eq!(*rs, 100);\n+    let rs = if true { box 100i } else { box 101i };\n+    assert_eq!(*rs, 100i);\n }\n \n pub fn main() { test_box(); }"}, {"sha": "dc92df4d08e9193d9289558cc303e9da51f9cfad", "filename": "src/test/run-pass/expr-match-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fexpr-match-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fexpr-match-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-box.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -14,8 +14,8 @@ use std::gc::GC;\n \n // Tests for match as expressions resulting in boxed types\n fn test_box() {\n-    let res = match true { true => { box(GC) 100 } _ => fail!(\"wat\") };\n-    assert_eq!(*res, 100);\n+    let res = match true { true => { box(GC) 100i } _ => fail!(\"wat\") };\n+    assert_eq!(*res, 100i);\n }\n \n fn test_str() {"}, {"sha": "872701e33eef1bfd02a01f4ac17763287178e743", "filename": "src/test/run-pass/expr-match-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fexpr-match-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fexpr-match-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-fail.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -15,8 +15,8 @@ fn test_simple() {\n }\n \n fn test_box() {\n-    let r = match true { true => { vec!(10) } false => { fail!() } };\n-    assert_eq!(*r.get(0), 10);\n+    let r = match true { true => { vec!(10i) } false => { fail!() } };\n+    assert_eq!(*r.get(0), 10i);\n }\n \n pub fn main() { test_simple(); test_box(); }"}, {"sha": "3ee0a232d19c06377253a9bd04172a5730bfa4e3", "filename": "src/test/run-pass/expr-match-unique.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fexpr-match-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fexpr-match-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-unique.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,8 +11,8 @@\n \n // Tests for match as expressions resulting in boxed types\n fn test_box() {\n-    let res = match true { true => { box 100 }, _ => fail!() };\n-    assert_eq!(*res, 100);\n+    let res = match true { true => { box 100i }, _ => fail!() };\n+    assert_eq!(*res, 100i);\n }\n \n pub fn main() { test_box(); }"}, {"sha": "a137aa5bd63dd98d46e5e570a776298864727712", "filename": "src/test/run-pass/fat-arrow-match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Ffat-arrow-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Ffat-arrow-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffat-arrow-match.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -17,8 +17,8 @@ enum color {\n \n pub fn main() {\n     println!(\"{}\", match red {\n-        red => { 1 }\n-        green => { 2 }\n-        blue => { 3 }\n+        red => { 1i }\n+        green => { 2i }\n+        blue => { 3i }\n     });\n }"}, {"sha": "dc34cec7fa2b0600ee61f8d504a00631af0497c1", "filename": "src/test/run-pass/fixed_length_copy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Ffixed_length_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Ffixed_length_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed_length_copy.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n pub fn main() {\n-    let arr = [1,2,3];\n+    let arr = [1i,2i,3i];\n     let arr2 = arr;\n-    assert_eq!(arr[1], 2);\n-    assert_eq!(arr2[2], 3);\n+    assert_eq!(arr[1], 2i);\n+    assert_eq!(arr2[2], 3i);\n }"}, {"sha": "f2a41b4f09ed6e2444558ba33007ef03c525a110", "filename": "src/test/run-pass/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,7 +11,7 @@\n extern crate debug;\n \n pub fn main() {\n-    let pi = 3.1415927;\n+    let pi = 3.1415927f64;\n     println!(\"{:?}\", -pi * (pi + 2.0 / pi) - pi * 5.0);\n     if pi == 5.0 || pi < 10.0 || pi <= 2.0 || pi != 22.0 / 7.0 || pi >= 10.0\n            || pi > 1.0 {"}, {"sha": "9c75979628f3c27c2a6b8eba4969dca8679fd6bc", "filename": "src/test/run-pass/float2.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Ffloat2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Ffloat2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat2.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,17 +11,17 @@\n \n \n pub fn main() {\n-    let a = 1.5e6;\n-    let b = 1.5E6;\n-    let c = 1e6;\n-    let d = 1E6;\n+    let a = 1.5e6f64;\n+    let b = 1.5E6f64;\n+    let c = 1e6f64;\n+    let d = 1E6f64;\n     let e = 3.0f32;\n     let f = 5.9f64;\n     let g = 1e6f32;\n     let h = 1.0e7f64;\n     let i = 1.0E7f64;\n-    let j = 3.1e+9;\n-    let k = 3.2e-10;\n+    let j = 3.1e+9f64;\n+    let k = 3.2e-10f64;\n     assert_eq!(a, b);\n     assert!((c < b));\n     assert_eq!(c, d);"}, {"sha": "4305ae956989e3e99e44cb70f3db18ee82c89f45", "filename": "src/test/run-pass/foreach-external-iterators-hashmap-break-restart.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap-break-restart.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap-break-restart.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap-break-restart.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -18,7 +18,7 @@ use std::collections::HashMap;\n \n pub fn main() {\n     let mut h = HashMap::new();\n-    let kvs = [(1, 10), (2, 20), (3, 30)];\n+    let kvs = [(1i, 10i), (2i, 20i), (3i, 30i)];\n     for &(k,v) in kvs.iter() {\n         h.insert(k,v);\n     }"}, {"sha": "ab20f9f97780195b4248b5ee6743b6de090ebc17", "filename": "src/test/run-pass/foreach-external-iterators-hashmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -14,12 +14,12 @@ use std::collections::HashMap;\n \n pub fn main() {\n     let mut h = HashMap::new();\n-    let kvs = [(1, 10), (2, 20), (3, 30)];\n+    let kvs = [(1i, 10i), (2i, 20i), (3i, 30i)];\n     for &(k,v) in kvs.iter() {\n         h.insert(k,v);\n     }\n-    let mut x = 0;\n-    let mut y = 0;\n+    let mut x = 0i;\n+    let mut y = 0i;\n     for (&k,&v) in h.iter() {\n         x += k;\n         y += v;"}, {"sha": "c6c2d42392749cf3ce1dffa1048af036f4761229", "filename": "src/test/run-pass/foreach-external-iterators-loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-loop.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n pub fn main() {\n-    let x = [1,..100];\n-    let mut y = 0;\n+    let x = [1i,..100];\n+    let mut y = 0i;\n     for (n,i) in x.iter().enumerate() {\n         if n < 10 {\n             continue;"}, {"sha": "f9d054582615e09312382654cec0a93330d788f4", "filename": "src/test/run-pass/generic-alias-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -13,7 +13,7 @@ extern crate debug;\n fn id<T:Send>(t: T) -> T { return t; }\n \n pub fn main() {\n-    let expected = box 100;\n+    let expected = box 100i;\n     let actual = id::<Box<int>>(expected.clone());\n     println!(\"{:?}\", *actual);\n     assert_eq!(*expected, *actual);"}, {"sha": "e7e189c0049e2c6427dc92a5dcbe0273dbbf0994", "filename": "src/test/run-pass/generic-fn-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fgeneric-fn-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fgeneric-fn-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-box.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -16,4 +16,4 @@ use std::gc::{Gc, GC};\n \n fn f<T>(x: Gc<T>) -> Gc<T> { return x; }\n \n-pub fn main() { let x = f(box(GC) 3); println!(\"{:?}\", *x); }\n+pub fn main() { let x = f(box(GC) 3i); println!(\"{:?}\", *x); }"}, {"sha": "14991ca3ba6415b63570583a632513d82b95536e", "filename": "src/test/run-pass/generic-fn-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fgeneric-fn-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fgeneric-fn-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-unique.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -12,4 +12,4 @@ extern crate debug;\n \n fn f<T>(x: Box<T>) -> Box<T> { return x; }\n \n-pub fn main() { let x = f(box 3); println!(\"{:?}\", *x); }\n+pub fn main() { let x = f(box 3i); println!(\"{:?}\", *x); }"}, {"sha": "032db16c61714def782e849db6a2af2dce2085a3", "filename": "src/test/run-pass/generic-static-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -24,5 +24,5 @@ impl<T> vec_utils<T> for Vec<T> {\n }\n \n pub fn main() {\n-    assert_eq!(vec_utils::map_(&vec!(1,2,3), |&x| x+1), vec!(2,3,4));\n+    assert_eq!(vec_utils::map_(&vec!(1i,2i,3i), |&x| x+1), vec!(2i,3i,4i));\n }"}, {"sha": "2f41cac62588dca0c6b6ed67041b0871b3738f7e", "filename": "src/test/run-pass/generic-tup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -13,7 +13,7 @@ extern crate debug;\n fn get_third<T>(t: (T, T, T)) -> T { let (_, _, x) = t; return x; }\n \n pub fn main() {\n-    println!(\"{:?}\", get_third((1, 2, 3)));\n-    assert_eq!(get_third((1, 2, 3)), 3);\n+    println!(\"{:?}\", get_third((1i, 2i, 3i)));\n+    assert_eq!(get_third((1i, 2i, 3i)), 3);\n     assert_eq!(get_third((5u8, 6u8, 7u8)), 7u8);\n }"}, {"sha": "450620767e301cf23483b5a971fd913bb38693b9", "filename": "src/test/run-pass/guards.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fguards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fguards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fguards.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,11 +11,11 @@\n struct Pair { x: int, y: int }\n \n pub fn main() {\n-    let a =\n+    let a: int =\n         match 10 { x if x < 7 => { 1 } x if x < 11 => { 2 } 10 => { 3 } _ => { 4 } };\n     assert_eq!(a, 2);\n \n-    let b =\n+    let b: int =\n         match (Pair {x: 10, y: 20}) {\n           x if x.x < 5 && x.y < 5 => { 1 }\n           Pair {x: x, y: y} if x == 10 && y == 20 => { 2 }"}, {"sha": "e6c1046d1fa7c278cebfe27abef42ee5237f1e35", "filename": "src/test/run-pass/hygienic-labels-in-let.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fhygienic-labels-in-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fhygienic-labels-in-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygienic-labels-in-let.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -22,14 +22,14 @@ macro_rules! loop_x {\n macro_rules! run_once {\n     ($e: expr) => {\n         // ditto\n-        'x: for _ in range(0, 1) { $e }\n+        'x: for _ in range(0i, 1) { $e }\n     }\n }\n \n pub fn main() {\n     let mut i = 0i;\n \n-    let j = {\n+    let j: int = {\n         'x: loop {\n             // this 'x should refer to the outer loop, lexically\n             loop_x!(break 'x);\n@@ -39,8 +39,8 @@ pub fn main() {\n     };\n     assert_eq!(j, 1i);\n \n-    let k = {\n-        'x: for _ in range(0, 1) {\n+    let k: int = {\n+        'x: for _ in range(0i, 1) {\n             // ditto\n             loop_x!(break 'x);\n             i += 1;\n@@ -49,8 +49,8 @@ pub fn main() {\n     };\n     assert_eq!(k, 1i);\n \n-    let n = {\n-        'x: for _ in range(0, 1) {\n+    let n: int = {\n+        'x: for _ in range(0i, 1) {\n             // ditto\n             run_once!(continue 'x);\n             i += 1;"}, {"sha": "320441204dfe831ad8dcd613f93fe0646cfadd3f", "filename": "src/test/run-pass/hygienic-labels.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fhygienic-labels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fhygienic-labels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygienic-labels.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -20,12 +20,12 @@ macro_rules! loop_x {\n macro_rules! run_once {\n     ($e: expr) => {\n         // ditto\n-        'x: for _ in range(0, 1) { $e }\n+        'x: for _ in range(0i, 1) { $e }\n     }\n }\n \n pub fn main() {\n-    'x: for _ in range(0, 1) {\n+    'x: for _ in range(0i, 1) {\n         // this 'x should refer to the outer loop, lexically\n         loop_x!(break 'x);\n         fail!(\"break doesn't act hygienically inside for loop\");\n@@ -37,7 +37,7 @@ pub fn main() {\n         fail!(\"break doesn't act hygienically inside infinite loop\");\n     }\n \n-    'x: for _ in range(0, 1) {\n+    'x: for _ in range(0i, 1) {\n         // ditto\n         run_once!(continue 'x);\n         fail!(\"continue doesn't act hygienically inside for loop\");"}, {"sha": "4b678d78834d17508f3c4b9c5fe0dd59008c7dd4", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -40,10 +40,10 @@ macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a.as_slice(), $b) })\n \n pub fn main() {\n     // Make sure there's a poly formatter that takes anything\n-    t!(format!(\"{:?}\", 1), \"1\");\n+    t!(format!(\"{:?}\", 1i), \"1\");\n     t!(format!(\"{:?}\", A), \"A\");\n     t!(format!(\"{:?}\", ()), \"()\");\n-    t!(format!(\"{:?}\", box(GC) (box 1, \"foo\")), \"box(GC) (box 1, \\\"foo\\\")\");\n+    t!(format!(\"{:?}\", box(GC) (box 1i, \"foo\")), \"box(GC) (box 1, \\\"foo\\\")\");\n \n     // Various edge cases without formats\n     t!(format!(\"\"), \"\");\n@@ -61,8 +61,8 @@ pub fn main() {\n     // At least exercise all the formats\n     t!(format!(\"{:b}\", true), \"true\");\n     t!(format!(\"{:c}\", '\u2603'), \"\u2603\");\n-    t!(format!(\"{:d}\", 10), \"10\");\n-    t!(format!(\"{:i}\", 10), \"10\");\n+    t!(format!(\"{:d}\", 10i), \"10\");\n+    t!(format!(\"{:i}\", 10i), \"10\");\n     t!(format!(\"{:u}\", 10u), \"10\");\n     t!(format!(\"{:o}\", 10u), \"12\");\n     t!(format!(\"{:x}\", 10u), \"a\");\n@@ -74,12 +74,12 @@ pub fn main() {\n     t!(format!(\"{:d}\", A), \"aloha\");\n     t!(format!(\"{:d}\", B), \"adios\");\n     t!(format!(\"foo {:s} \u2603\u2603\u2603\u2603\u2603\u2603\", \"bar\"), \"foo bar \u2603\u2603\u2603\u2603\u2603\u2603\");\n-    t!(format!(\"{1} {0}\", 0, 1), \"1 0\");\n-    t!(format!(\"{foo} {bar}\", foo=0, bar=1), \"0 1\");\n-    t!(format!(\"{foo} {1} {bar} {0}\", 0, 1, foo=2, bar=3), \"2 1 3 0\");\n+    t!(format!(\"{1} {0}\", 0i, 1i), \"1 0\");\n+    t!(format!(\"{foo} {bar}\", foo=0i, bar=1i), \"0 1\");\n+    t!(format!(\"{foo} {1} {bar} {0}\", 0i, 1i, foo=2i, bar=3i), \"2 1 3 0\");\n     t!(format!(\"{} {0}\", \"a\"), \"a a\");\n-    t!(format!(\"{foo_bar}\", foo_bar=1), \"1\");\n-    t!(format!(\"{:d}\", 5 + 5), \"10\");\n+    t!(format!(\"{foo_bar}\", foo_bar=1i), \"1\");\n+    t!(format!(\"{:d}\", 5i + 5i), \"10\");\n \n     // Formatting strings and their arguments\n     t!(format!(\"{:s}\", \"a\"), \"a\");\n@@ -132,7 +132,7 @@ pub fn main() {\n     test_order();\n \n     // make sure that format! doesn't move out of local variables\n-    let a = box 3;\n+    let a = box 3i;\n     format!(\"{:?}\", a);\n     format!(\"{:?}\", a);\n \n@@ -154,10 +154,10 @@ pub fn main() {\n // io::Writer instance.\n fn test_write() {\n     let mut buf = MemWriter::new();\n-    write!(&mut buf as &mut io::Writer, \"{}\", 3);\n+    write!(&mut buf as &mut io::Writer, \"{}\", 3i);\n     {\n         let w = &mut buf as &mut io::Writer;\n-        write!(w, \"{foo}\", foo=4);\n+        write!(w, \"{foo}\", foo=4i);\n         write!(w, \"{:s}\", \"hello\");\n         writeln!(w, \"{}\", \"line\");\n         writeln!(w, \"{foo}\", foo=\"bar\");\n@@ -183,9 +183,9 @@ fn test_format_args() {\n     let mut buf = MemWriter::new();\n     {\n         let w = &mut buf as &mut io::Writer;\n-        format_args!(|args| { write!(w, \"{}\", args); }, \"{}\", 1);\n+        format_args!(|args| { write!(w, \"{}\", args); }, \"{}\", 1i);\n         format_args!(|args| { write!(w, \"{}\", args); }, \"test\");\n-        format_args!(|args| { write!(w, \"{}\", args); }, \"{test}\", test=3);\n+        format_args!(|args| { write!(w, \"{}\", args); }, \"{test}\", test=3i);\n     }\n     let s = str::from_utf8(buf.unwrap().as_slice()).unwrap().to_string();\n     t!(s, \"1test3\");"}, {"sha": "5ffcbb7e0fdd934d0da8cf5497ff91d917cba183", "filename": "src/test/run-pass/import-glob-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -16,7 +16,7 @@ use std::mem::*;\n \n pub fn main() {\n     assert_eq!(size_of::<u8>(), 1);\n-    let (mut x, mut y) = (1, 2);\n+    let (mut x, mut y) = (1i, 2i);\n     swap(&mut x, &mut y);\n     assert_eq!(x, 2);\n     assert_eq!(y, 1);"}, {"sha": "b1a92f70449adbbbc386b0d9effe4ddaafd5dcdb", "filename": "src/test/run-pass/integer-literal-radix.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Finteger-literal-radix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Finteger-literal-radix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finteger-literal-radix.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n pub fn main() {\n-    let a = 0xBEEF;\n-    let b = 0o755;\n-    let c = 0b10101;\n-    let d = -0xBEEF;\n-    let e = -0o755;\n-    let f = -0b10101;\n+    let a = 0xBEEFi;\n+    let b = 0o755i;\n+    let c = 0b10101i;\n+    let d = -0xBEEFi;\n+    let e = -0o755i;\n+    let f = -0b10101i;\n \n     assert_eq!(a, 48879);\n     assert_eq!(b, 493);"}, {"sha": "f28ba7b8bc03b89834c8103f461a1de653b297b4", "filename": "src/test/run-pass/intrinsic-atomics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -38,7 +38,7 @@ mod rusti {\n \n pub fn main() {\n     unsafe {\n-        let mut x = box 1;\n+        let mut x = box 1i;\n \n         assert_eq!(rusti::atomic_load(&*x), 1);\n         *x = 5;"}, {"sha": "4375c63a1b8c03e368fcf74c93c76afc8c5216cc", "filename": "src/test/run-pass/intrinsic-move-val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -21,7 +21,7 @@ mod rusti {\n \n pub fn main() {\n     unsafe {\n-        let x = box 1;\n+        let x = box 1i;\n         let mut y = rusti::init();\n         let mut z: *uint = transmute(&x);\n         rusti::move_val_init(&mut y, x);"}, {"sha": "8a6e300bd15b6b2c9c0102f991790c4ecdccc463", "filename": "src/test/run-pass/issue-10626.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10626.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -19,10 +19,10 @@ pub fn main () {\n     let args = os::args();\n     let args = args.as_slice();\n     if args.len() > 1 && args[1].as_slice() == \"child\" {\n-        for _ in range(0, 1000) {\n+        for _ in range(0i, 1000i) {\n             println!(\"hello?\");\n         }\n-        for _ in range(0, 1000) {\n+        for _ in range(0i, 1000i) {\n             println!(\"hello?\");\n         }\n         return;"}, {"sha": "bcdbfb2775340db89e6c4e584f9967b632f04c99", "filename": "src/test/run-pass/issue-11225-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-11225-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-11225-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11225-1.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -13,5 +13,5 @@\n extern crate foo = \"issue-11225-1\";\n \n pub fn main() {\n-    foo::foo(1);\n+    foo::foo(1i);\n }"}, {"sha": "a9b70b1d7c253124eda858abfc00d037a866fc52", "filename": "src/test/run-pass/issue-11225-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-11225-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-11225-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11225-2.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -13,5 +13,5 @@\n extern crate foo = \"issue-11225-2\";\n \n pub fn main() {\n-    foo::foo(1);\n+    foo::foo(1i);\n }"}, {"sha": "418fd54cc139e8bfdf531abe5f690843bfaa3d1e", "filename": "src/test/run-pass/issue-12582.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-12582.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-12582.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12582.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -9,18 +9,18 @@\n // except according to those terms.\n \n pub fn main() {\n-    let x = 1;\n-    let y = 2;\n+    let x = 1i;\n+    let y = 2i;\n \n-    assert_eq!(3, match (x, y) {\n+    assert_eq!(3i, match (x, y) {\n         (1, 1) => 1,\n         (2, 2) => 2,\n         (1..2, 2) => 3,\n         _ => 4,\n     });\n \n     // nested tuple\n-    assert_eq!(3, match ((x, y),) {\n+    assert_eq!(3i, match ((x, y),) {\n         ((1, 1),) => 1,\n         ((2, 2),) => 2,\n         ((1..2, 2),) => 3,"}, {"sha": "8acaa889a0490a7fcc2f7cfa1d9643761f54318f", "filename": "src/test/run-pass/issue-13027.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-13027.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-13027.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13027.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -27,115 +27,115 @@ pub fn main() {\n }\n \n fn lit_shadow_range() {\n-    assert_eq!(2, match 1 {\n+    assert_eq!(2i, match 1 {\n         1 if false => 1,\n         1..2 => 2,\n         _ => 3\n     });\n \n-    let x = 0;\n-    assert_eq!(2, match x+1 {\n+    let x = 0i;\n+    assert_eq!(2i, match x+1 {\n         0 => 0,\n         1 if false => 1,\n         1..2 => 2,\n         _ => 3\n     });\n \n-    assert_eq!(2, match val() {\n+    assert_eq!(2i, match val() {\n         1 if false => 1,\n         1..2 => 2,\n         _ => 3\n     });\n \n-    assert_eq!(2, match CONST {\n+    assert_eq!(2i, match CONST {\n         0 => 0,\n         1 if false => 1,\n         1..2 => 2,\n         _ => 3\n     });\n \n     // value is out of the range of second arm, should match wildcard pattern\n-    assert_eq!(3, match 3 {\n+    assert_eq!(3i, match 3 {\n         1 if false => 1,\n         1..2 => 2,\n         _ => 3\n     });\n }\n \n fn range_shadow_lit() {\n-    assert_eq!(2, match 1 {\n+    assert_eq!(2i, match 1 {\n         1..2 if false => 1,\n         1 => 2,\n         _ => 3\n     });\n \n-    let x = 0;\n-    assert_eq!(2, match x+1 {\n+    let x = 0i;\n+    assert_eq!(2i, match x+1 {\n         0 => 0,\n         1..2 if false => 1,\n         1 => 2,\n         _ => 3\n     });\n \n-    assert_eq!(2, match val() {\n+    assert_eq!(2i, match val() {\n         1..2 if false => 1,\n         1 => 2,\n         _ => 3\n     });\n \n-    assert_eq!(2, match CONST {\n+    assert_eq!(2i, match CONST {\n         0 => 0,\n         1..2 if false => 1,\n         1 => 2,\n         _ => 3\n     });\n \n     // ditto\n-    assert_eq!(3, match 3 {\n+    assert_eq!(3i, match 3 {\n         1..2 if false => 1,\n         1 => 2,\n         _ => 3\n     });\n }\n \n fn range_shadow_range() {\n-    assert_eq!(2, match 1 {\n+    assert_eq!(2i, match 1 {\n         0..2 if false => 1,\n         1..3 => 2,\n         _ => 3,\n     });\n \n-    let x = 0;\n-    assert_eq!(2, match x+1 {\n+    let x = 0i;\n+    assert_eq!(2i, match x+1 {\n         100 => 0,\n         0..2 if false => 1,\n         1..3 => 2,\n         _ => 3,\n     });\n \n-    assert_eq!(2, match val() {\n+    assert_eq!(2i, match val() {\n         0..2 if false => 1,\n         1..3 => 2,\n         _ => 3,\n     });\n \n-    assert_eq!(2, match CONST {\n+    assert_eq!(2i, match CONST {\n         100 => 0,\n         0..2 if false => 1,\n         1..3 => 2,\n         _ => 3,\n     });\n \n     // ditto\n-    assert_eq!(3, match 5 {\n+    assert_eq!(3i, match 5 {\n         0..2 if false => 1,\n         1..3 => 2,\n         _ => 3,\n     });\n }\n \n fn multi_pats_shadow_lit() {\n-    assert_eq!(2, match 1 {\n+    assert_eq!(2i, match 1 {\n         100 => 0,\n         0 | 1..10 if false => 1,\n         1 => 2,\n@@ -144,7 +144,7 @@ fn multi_pats_shadow_lit() {\n }\n \n fn multi_pats_shadow_range() {\n-    assert_eq!(2, match 1 {\n+    assert_eq!(2i, match 1 {\n         100 => 0,\n         0 | 1..10 if false => 1,\n         1..3 => 2,\n@@ -153,7 +153,7 @@ fn multi_pats_shadow_range() {\n }\n \n fn lit_shadow_multi_pats() {\n-    assert_eq!(2, match 1 {\n+    assert_eq!(2i, match 1 {\n         100 => 0,\n         1 if false => 1,\n         0 | 1..10 => 2,\n@@ -162,7 +162,7 @@ fn lit_shadow_multi_pats() {\n }\n \n fn range_shadow_multi_pats() {\n-    assert_eq!(2, match 1 {\n+    assert_eq!(2i, match 1 {\n         100 => 0,\n         1..3 if false => 1,\n         0 | 1..10 => 2,\n@@ -178,9 +178,9 @@ fn misc() {\n     // which is a rare combination of vector patterns, multiple wild-card\n     // patterns and guard functions.\n     let r = match [Bar(0, false)].as_slice() {\n-        [Bar(_, pred)] if pred => 1,\n-        [Bar(_, pred)] if !pred => 2,\n-        _ => 0,\n+        [Bar(_, pred)] if pred => 1i,\n+        [Bar(_, pred)] if !pred => 2i,\n+        _ => 0i,\n     };\n     assert_eq!(2, r);\n }"}, {"sha": "a4f88d7c04c6e38093150b7e2627b8b98feb5d76", "filename": "src/test/run-pass/issue-13494.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13494.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -30,7 +30,7 @@ fn test() {\n     let (tx, rx) = channel();\n     spawn(proc() { helper(rx) });\n     let (snd, rcv) = channel();\n-    for _ in range(1, 100000) {\n+    for _ in range(1i, 100000i) {\n         snd.send(1);\n         let (tx2, rx2) = channel();\n         tx.send(tx2);"}, {"sha": "8bea2e7804602c396b18061af4c79b3189c060e5", "filename": "src/test/run-pass/issue-13867.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-13867.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-13867.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13867.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -18,39 +18,39 @@ enum Foo {\n \n fn main() {\n     let r = match (FooNullary, 'a') {\n-        (FooUint(..), 'a'..'z') => 1,\n-        (FooNullary, 'x') => 2,\n+        (FooUint(..), 'a'..'z') => 1i,\n+        (FooNullary, 'x') => 2i,\n         _ => 0\n     };\n     assert_eq!(r, 0);\n \n     let r = match (FooUint(0), 'a') {\n-        (FooUint(1), 'a'..'z') => 1,\n-        (FooUint(..), 'x') => 2,\n-        (FooNullary, 'a') => 3,\n+        (FooUint(1), 'a'..'z') => 1i,\n+        (FooUint(..), 'x') => 2i,\n+        (FooNullary, 'a') => 3i,\n         _ => 0\n     };\n     assert_eq!(r, 0);\n \n     let r = match ('a', FooUint(0)) {\n-        ('a'..'z', FooUint(1)) => 1,\n-        ('x', FooUint(..)) => 2,\n-        ('a', FooNullary) => 3,\n+        ('a'..'z', FooUint(1)) => 1i,\n+        ('x', FooUint(..)) => 2i,\n+        ('a', FooNullary) => 3i,\n         _ => 0\n     };\n     assert_eq!(r, 0);\n \n     let r = match ('a', 'a') {\n-        ('a'..'z', 'b') => 1,\n-        ('x', 'a'..'z') => 2,\n+        ('a'..'z', 'b') => 1i,\n+        ('x', 'a'..'z') => 2i,\n         _ => 0\n     };\n     assert_eq!(r, 0);\n \n     let r = match ('a', 'a') {\n-        ('a'..'z', 'b') => 1,\n-        ('x', 'a'..'z') => 2,\n-        ('a', 'a') => 3,\n+        ('a'..'z', 'b') => 1i,\n+        ('x', 'a'..'z') => 2i,\n+        ('a', 'a') => 3i,\n         _ => 0\n     };\n     assert_eq!(r, 3);"}, {"sha": "82a1a16ba57d449ada309e2e316736b7a8b5a853", "filename": "src/test/run-pass/issue-14308.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-14308.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-14308.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14308.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -13,20 +13,20 @@ struct B;\n \n fn main() {\n     let x = match A(3) {\n-        A(..) => 1\n+        A(..) => 1i\n     };\n     assert_eq!(x, 1);\n     let x = match A(4) {\n-        A(1) => 1,\n-        A(..) => 2\n+        A(1) => 1i,\n+        A(..) => 2i\n     };\n     assert_eq!(x, 2);\n \n     // This next test uses a (..) wildcard match on a nullary struct.\n     // There's no particularly good reason to support this, but it's currently allowed,\n     // and this makes sure it doesn't ICE or break LLVM.\n     let x = match B {\n-        B(..) => 3\n+        B(..) => 3i\n     };\n     assert_eq!(x, 3);\n }"}, {"sha": "c84b1eae8e0978540ad088c3cbc02e968e9bfd12", "filename": "src/test/run-pass/issue-14865.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-14865.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-14865.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14865.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -15,14 +15,14 @@ enum X {\n \n fn main() {\n     let x = match Foo(42) {\n-        Foo(..) => 1,\n+        Foo(..) => 1i,\n         _ if true => 0,\n         Bar(..) => fail!(\"Oh dear\")\n     };\n     assert_eq!(x, 1);\n \n     let x = match Foo(42) {\n-        _ if true => 0,\n+        _ if true => 0i,\n         Foo(..) => 1,\n         Bar(..) => fail!(\"Oh dear\")\n     };"}, {"sha": "b0741391d8039ec6fb77becfa370065de01322fb", "filename": "src/test/run-pass/issue-15080.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-15080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-15080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15080.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let mut x = &[1, 2, 3, 4];\n+    let mut x = &[1i, 2, 3, 4];\n \n     let mut result = vec!();\n     loop {"}, {"sha": "7276b11b1816cd4596408436403f6e4772db4dbe", "filename": "src/test/run-pass/issue-2216.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-2216.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-2216.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2216.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,7 +11,7 @@\n extern crate debug;\n \n pub fn main() {\n-    let mut x = 0;\n+    let mut x = 0i;\n \n     'foo: loop {\n         'bar: loop {"}, {"sha": "e2a03c696f2f2eb3ba03c2650396e7141950f98c", "filename": "src/test/run-pass/issue-2633-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-2633-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-2633-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2633-2.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -14,6 +14,6 @@ fn a_val(x: Box<int>, y: Box<int>) -> int {\n }\n \n pub fn main() {\n-    let z = box 22;\n+    let z = box 22i;\n     a_val(z.clone(), z.clone());\n }"}, {"sha": "2e287e24e23fcddc8cdeb10d2c8e354776094ef0", "filename": "src/test/run-pass/issue-3091.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-3091.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-3091.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3091.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let x = 1;\n-    let y = 1;\n+    let x = 1i;\n+    let y = 1i;\n     assert_eq!(&x, &y);\n }"}, {"sha": "c52c23b5d754383d3aaa85968e742a35a49ec59e", "filename": "src/test/run-pass/issue-3211.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-3211.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-3211.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3211.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n pub fn main() {\n-    let mut x = 0;\n-    for _ in range(0, 4096) { x += 1; }\n+    let mut x = 0i;\n+    for _ in range(0i, 4096) { x += 1; }\n     assert_eq!(x, 4096);\n     println!(\"x = {}\", x);\n }"}, {"sha": "139d984b50733cd7a7a3e4c090a146cee46c4ef3", "filename": "src/test/run-pass/issue-3290.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-3290.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-3290.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3290.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-   let mut x = box 3;\n+   let mut x = box 3i;\n    x = x;\n    assert_eq!(*x, 3);\n }"}, {"sha": "53f92246e54c9966ac9c2de41ada6b4f0b73dd9a", "filename": "src/test/run-pass/issue-3559.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3559.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -22,8 +22,8 @@ fn check_strs(actual: &str, expected: &str) -> bool {\n \n pub fn main() {\n     let mut table = HashMap::new();\n-    table.insert(\"one\".to_string(), 1);\n-    table.insert(\"two\".to_string(), 2);\n+    table.insert(\"one\".to_string(), 1i);\n+    table.insert(\"two\".to_string(), 2i);\n     assert!(check_strs(table.to_str().as_slice(), \"{one: 1, two: 2}\") ||\n             check_strs(table.to_str().as_slice(), \"{two: 2, one: 1}\"));\n }"}, {"sha": "bebaad2d297c73bdec020542254b8083793fa76a", "filename": "src/test/run-pass/issue-3743.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-3743.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-3743.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3743.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -36,15 +36,15 @@ impl RhsOfVec2Mul<Vec2> for f64 {\n \n // Usage with failing inference\n pub fn main() {\n-    let a = Vec2 { x: 3.0, y: 4.0 };\n+    let a = Vec2 { x: 3.0f64, y: 4.0f64 };\n \n     // the following compiles and works properly\n-    let v1: Vec2 = a * 3.0;\n+    let v1: Vec2 = a * 3.0f64;\n     println!(\"{} {}\", v1.x, v1.y);\n \n     // the following compiles but v2 will not be Vec2 yet and\n     // using it later will cause an error that the type of v2\n     // must be known\n-    let v2 = a * 3.0;\n+    let v2 = a * 3.0f64;\n     println!(\"{} {}\", v2.x, v2.y); // error regarding v2's type\n }"}, {"sha": "c251fafc24b878edc699c3b2b008c737996bf77f", "filename": "src/test/run-pass/issue-4401.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-4401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-4401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4401.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n pub fn main() {\n-    let mut count = 0;\n-    for _ in range(0, 999_999) { count += 1; }\n+    let mut count = 0i;\n+    for _ in range(0i, 999_999) { count += 1; }\n     assert_eq!(count, 999_999);\n     println!(\"{}\", count);\n }"}, {"sha": "39c8562e4589b3a709fea93cbac06745b076d016", "filename": "src/test/run-pass/issue-5708.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-5708.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-5708.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5708.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -41,7 +41,7 @@ impl<'a> Outer<'a> {\n }\n \n pub fn main() {\n-    let inner = 5;\n+    let inner = 5i;\n     let outer = Outer::new(&inner as &Inner);\n     outer.inner.print();\n }"}, {"sha": "d307a057038438ca5315856cb28d2e2bde5b668c", "filename": "src/test/run-pass/issue-7784.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7784.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -16,7 +16,7 @@ fn bar(a: &'static str, b: &'static str) -> [&'static str, ..4] {\n }\n \n fn main() {\n-    assert_eq!(foo([1, 2, 3]), (1, 3, 6));\n+    assert_eq!(foo([1i, 2i, 3i]), (1i, 3i, 6i));\n \n     let [a, b, c, d] = bar(\"foo\", \"bar\");\n     assert_eq!(a, \"foo\");\n@@ -33,4 +33,4 @@ fn main() {\n     assert_eq!(a, \"baz\");\n     assert!(xs == [\"foo\", \"foo\"]);\n     assert_eq!(d, \"baz\");\n-}\n\\ No newline at end of file\n+}"}, {"sha": "468e656318277b758522022bd0ed45c49d996456", "filename": "src/test/run-pass/issue-8391.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-8391.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-8391.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8391.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n fn main() {\n-    let x = match Some(1) {\n-        ref _y @ Some(_) => 1,\n-        None => 2,\n+    let x = match Some(1i) {\n+        ref _y @ Some(_) => 1i,\n+        None => 2i,\n     };\n     assert_eq!(x, 1);\n }"}, {"sha": "173414d1d41cbee80316fded42add44c27e34644", "filename": "src/test/run-pass/issue-8827.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-8827.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-8827.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8827.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -46,7 +46,7 @@ fn main() {\n     let ints = integers();\n     let threes = periodical(3);\n     let fives = periodical(5);\n-    for _ in range(1, 100) {\n+    for _ in range(1i, 100i) {\n         match (ints.recv(), threes.recv(), fives.recv()) {\n             (_, true, true) => println!(\"FizzBuzz\"),\n             (_, true, false) => println!(\"Fizz\"),"}, {"sha": "ac200e6c1ac48a32251fddfb510dc52745ec0616", "filename": "src/test/run-pass/issue-9719.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-9719.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue-9719.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9719.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -17,7 +17,7 @@ mod a {\n     impl X for int {}\n \n     pub struct Z<'a>(Enum<&'a X>);\n-    fn foo() { let x = 42; let z = Z(A(&x as &X)); let _ = z; }\n+    fn foo() { let x = 42i; let z = Z(A(&x as &X)); let _ = z; }\n }\n \n mod b {\n@@ -28,7 +28,7 @@ mod b {\n     }\n \n     fn bar() {\n-        let x = 42;\n+        let x = 42i;\n         let _y = Y { x: Some(&x as &X) };\n     }\n }\n@@ -37,7 +37,7 @@ mod c {\n     pub trait X { fn f(&self); }\n     impl X for int { fn f(&self) {} }\n     pub struct Z<'a>(Option<&'a X>);\n-    fn main() { let x = 42; let z = Z(Some(&x as &X)); let _ = z; }\n+    fn main() { let x = 42i; let z = Z(Some(&x as &X)); let _ = z; }\n }\n \n pub fn main() {}"}, {"sha": "c453a538c7e2baa874824dc565a4ba70ae6275a6", "filename": "src/test/run-pass/issue2378c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue2378c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fissue2378c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue2378c.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -18,6 +18,6 @@ use issue2378a::{just};\n use issue2378b::{two_maybes};\n \n pub fn main() {\n-    let x = two_maybes{a: just(3), b: just(5)};\n+    let x = two_maybes{a: just(3i), b: just(5i)};\n     assert_eq!(x[0u], (3, 5));\n }"}, {"sha": "511629a6d7a34224ca45cb8cc80e00741a24ca73", "filename": "src/test/run-pass/kindck-owned-trait-contains-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -23,7 +23,7 @@ fn repeater<A:Clone + 'static>(v: Box<A>) -> Box<repeat<A>> {\n }\n \n pub fn main() {\n-    let x = 3;\n+    let x = 3i;\n     let y = repeater(box x);\n     assert_eq!(x, y.get());\n }"}, {"sha": "091a57620f0566a75ef4edf9d285f2ef61e13c79", "filename": "src/test/run-pass/labeled-break.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Flabeled-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Flabeled-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flabeled-break.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -15,7 +15,7 @@ pub fn main() {\n         }\n     }\n \n-    'bar: for _ in range(0, 100) {\n+    'bar: for _ in range(0i, 100i) {\n         loop {\n             break 'bar;\n         }"}, {"sha": "c9ea520576a756335a397ca89a7a5e893052b2b7", "filename": "src/test/run-pass/last-use-in-cap-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -14,7 +14,7 @@\n struct A { a: Box<int> }\n \n fn foo() -> ||: 'static -> int {\n-    let k = box 22;\n+    let k = box 22i;\n     let _u = A {a: k.clone()};\n     let result: ||: 'static -> int = || 22;\n     result"}, {"sha": "fa3f3117c6468735abb922fdc14b37bef98ff555", "filename": "src/test/run-pass/last-use-is-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Flast-use-is-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Flast-use-is-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-is-capture.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -16,7 +16,7 @@ struct A { a: Box<int> }\n \n pub fn main() {\n     fn invoke(f: ||) { f(); }\n-    let k = box 22;\n+    let k = box 22i;\n     let _u = A {a: k.clone()};\n     invoke(|| println!(\"{:?}\", k.clone()) )\n }"}, {"sha": "7b9fa3bcf7fc4986ee36712f2eadf781f3c5f03c", "filename": "src/test/run-pass/let-var-hygiene.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Flet-var-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Flet-var-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flet-var-hygiene.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,8 +11,8 @@\n #![feature(macro_rules)]\n \n // shouldn't affect evaluation of $ex:\n-macro_rules! bad_macro (($ex:expr) => ({let _x = 9; $ex}))\n+macro_rules! bad_macro (($ex:expr) => ({let _x = 9i; $ex}))\n pub fn main() {\n-    let _x = 8;\n-    assert_eq!(bad_macro!(_x),8)\n+    let _x = 8i;\n+    assert_eq!(bad_macro!(_x),8i)\n }"}, {"sha": "1dc212ba8e951c9409385568c64d18c92a0cf377", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,8 +11,8 @@\n extern crate debug;\n \n pub fn main() {\n-    let x = vec!(1, 2, 3);\n-    let mut y = 0;\n+    let x = vec!(1i, 2i, 3i);\n+    let mut y = 0i;\n     for i in x.iter() { println!(\"{:?}\", *i); y += *i; }\n     println!(\"{:?}\", y);\n     assert_eq!(y, 6);"}, {"sha": "6ad2be68e8f2e680aa89793c0472a9459553db88", "filename": "src/test/run-pass/liveness-loop-break.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fliveness-loop-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fliveness-loop-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fliveness-loop-break.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,7 +11,7 @@\n fn test() {\n     let v;\n     loop {\n-        v = 3;\n+        v = 3i;\n         break;\n     }\n     println!(\"{}\", v);"}, {"sha": "c265bb0bcb132754813ff23a0927a36719e4a4cb", "filename": "src/test/run-pass/log-poly.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Flog-poly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Flog-poly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-poly.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -15,8 +15,8 @@ enum Numbers {\n }\n \n pub fn main() {\n-    println!(\"{}\", 1);\n-    println!(\"{}\", 2.0);\n+    println!(\"{}\", 1i);\n+    println!(\"{}\", 2.0f64);\n     println!(\"{:?}\", Three);\n-    println!(\"{:?}\", vec!(4));\n+    println!(\"{:?}\", vec!(4i));\n }"}, {"sha": "4b8ccad068cc7870fe906eed72a073c6e616e747", "filename": "src/test/run-pass/loop-scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Floop-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Floop-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Floop-scope.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n pub fn main() {\n-    let x = vec!(10, 20, 30);\n-    let mut sum = 0;\n+    let x = vec!(10i, 20i, 30i);\n+    let mut sum = 0i;\n     for x in x.iter() { sum += *x; }\n     assert_eq!(sum, 60);\n }"}, {"sha": "70080fcc3c91dcf37392adffcbc3c0f53a1e4852", "filename": "src/test/run-pass/macro-crate-def-only.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmacro-crate-def-only.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmacro-crate-def-only.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-crate-def-only.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -16,5 +16,5 @@\n extern crate macro_crate_def_only;\n \n pub fn main() {\n-    assert_eq!(5, make_a_5!());\n+    assert_eq!(5i, make_a_5!());\n }"}, {"sha": "88ca466b4afdf30c97ce8306913a58638b671c53", "filename": "src/test/run-pass/macro-export-inner-module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmacro-export-inner-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmacro-export-inner-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-export-inner-module.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -17,5 +17,5 @@\n extern crate macro_export_inner_module;\n \n pub fn main() {\n-    assert_eq!(1, foo!());\n+    assert_eq!(1i, foo!());\n }"}, {"sha": "3e89466bc0f76ce5ffcca7352960a64e72c3b8dd", "filename": "src/test/run-pass/macro-pat.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmacro-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmacro-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-pat.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -49,27 +49,27 @@ fn f(c: Option<char>) -> uint {\n }\n \n pub fn main() {\n-    assert_eq!(1, f(Some('x')));\n-    assert_eq!(2, f(Some('y')));\n-    assert_eq!(3, f(None));\n+    assert_eq!(1u, f(Some('x')));\n+    assert_eq!(2u, f(Some('y')));\n+    assert_eq!(3u, f(None));\n \n-    assert_eq!(1, match Some('x') {\n-        Some(char_x!()) => 1,\n-        _ => 2,\n+    assert_eq!(1i, match Some('x') {\n+        Some(char_x!()) => 1i,\n+        _ => 2i,\n     });\n \n-    assert_eq!(1, match Some('x') {\n-        some!(char_x!()) => 1,\n-        _ => 2,\n+    assert_eq!(1i, match Some('x') {\n+        some!(char_x!()) => 1i,\n+        _ => 2i,\n     });\n \n-    assert_eq!(1, match Some('x') {\n-        indirect!() => 1,\n-        _ => 2,\n+    assert_eq!(1i, match Some('x') {\n+        indirect!() => 1i,\n+        _ => 2i,\n     });\n \n-    assert_eq!(3, {\n-        let ident_pat!(x) = 2;\n-        x+1\n+    assert_eq!(3i, {\n+        let ident_pat!(x) = 2i;\n+        x+1i\n     });\n }"}, {"sha": "49e146cb0cf88386b25a85fb4a72c7cf0592f9ee", "filename": "src/test/run-pass/macro-stmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmacro-stmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmacro-stmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-stmt.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -28,17 +28,17 @@ pub fn main() {\n         )\n     );\n \n-    mylet!(y, 8*2);\n-    assert_eq!(y, 16);\n+    mylet!(y, 8i*2);\n+    assert_eq!(y, 16i);\n \n     myfn!(mult, (a,b), { a*b } );\n \n     assert_eq!(mult(2, add(4,4)), 16);\n \n     macro_rules! actually_an_expr_macro (\n-        () => ( 16 )\n+        () => ( 16i )\n     )\n \n-    assert_eq!({ actually_an_expr_macro!() }, 16);\n+    assert_eq!({ actually_an_expr_macro!() }, 16i);\n \n }"}, {"sha": "aaa2be66ff44ea7d66feddac7012a3bb81f82dec", "filename": "src/test/run-pass/macro-with-attrs1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmacro-with-attrs1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmacro-with-attrs1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-with-attrs1.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -13,11 +13,11 @@\n #![feature(macro_rules)]\n \n #[cfg(foo)]\n-macro_rules! foo( () => (1) )\n+macro_rules! foo( () => (1i) )\n \n #[cfg(not(foo))]\n-macro_rules! foo( () => (2) )\n+macro_rules! foo( () => (2i) )\n \n pub fn main() {\n-    assert_eq!(foo!(), 1);\n+    assert_eq!(foo!(), 1i);\n }"}, {"sha": "4a191b2fa66cebf0af87432caad52f46eec2cb16", "filename": "src/test/run-pass/macro-with-attrs2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmacro-with-attrs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmacro-with-attrs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-with-attrs2.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,12 +11,12 @@\n #![feature(macro_rules)]\n \n #[cfg(foo)]\n-macro_rules! foo( () => (1) )\n+macro_rules! foo( () => (1i) )\n \n #[cfg(not(foo))]\n-macro_rules! foo( () => (2) )\n+macro_rules! foo( () => (2i) )\n \n pub fn main() {\n-    assert_eq!(foo!(), 2);\n+    assert_eq!(foo!(), 2i);\n }\n "}, {"sha": "52d966a12d71a9d36b66a6d4dac21d0a2920d10f", "filename": "src/test/run-pass/match-pipe-binding.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmatch-pipe-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmatch-pipe-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-pipe-binding.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -20,7 +20,7 @@ fn test1() {\n }\n \n fn test2() {\n-    match (1, 2, 3) {\n+    match (1i, 2i, 3i) {\n         (1, a, b) | (2, b, a) => {\n             assert_eq!(a, 2);\n             assert_eq!(b, 3);\n@@ -30,7 +30,7 @@ fn test2() {\n }\n \n fn test3() {\n-    match (1, 2, 3) {\n+    match (1i, 2i, 3i) {\n         (1, ref a, ref b) | (2, ref b, ref a) => {\n             assert_eq!(*a, 2);\n             assert_eq!(*b, 3);\n@@ -40,7 +40,7 @@ fn test3() {\n }\n \n fn test4() {\n-    match (1, 2, 3) {\n+    match (1i, 2i, 3i) {\n         (1, a, b) | (2, b, a) if a == 2 => {\n             assert_eq!(a, 2);\n             assert_eq!(b, 3);\n@@ -50,7 +50,7 @@ fn test4() {\n }\n \n fn test5() {\n-    match (1, 2, 3) {\n+    match (1i, 2i, 3i) {\n         (1, ref a, ref b) | (2, ref b, ref a) if *a == 2 => {\n             assert_eq!(*a, 2);\n             assert_eq!(*b, 3);"}, {"sha": "c983903ac184ade30052ac7e84b3c1074478ed57", "filename": "src/test/run-pass/match-ref-binding-mut-option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-mut-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-mut-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-mut-option.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let mut v = Some(22);\n+    let mut v = Some(22i);\n     match v {\n       None => {}\n       Some(ref mut p) => { *p += 1; }"}, {"sha": "d31f7a60715105b63b7e6d28984e86ebf2a8dded", "filename": "src/test/run-pass/match-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmatch-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmatch-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-str.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -23,7 +23,7 @@ pub fn main() {\n       _ => fail!()\n     }\n \n-    let x = match \"a\" { \"a\" => 1, \"b\" => 2, _ => fail!() };\n+    let x = match \"a\" { \"a\" => 1i, \"b\" => 2i, _ => fail!() };\n     assert_eq!(x, 1);\n \n     match \"a\" { \"a\" => { } \"b\" => { }, _ => fail!() }"}, {"sha": "f6b2027e0fe0da0e991071c830b94642c909ff88", "filename": "src/test/run-pass/match-unique-bind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmatch-unique-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmatch-unique-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-unique-bind.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -11,7 +11,7 @@\n extern crate debug;\n \n pub fn main() {\n-    match box 100 {\n+    match box 100i {\n       box x => {\n         println!(\"{:?}\", x);\n         assert_eq!(x, 100);"}, {"sha": "70c3b386a8ad3df12fd75727ad7464f19e1d1541", "filename": "src/test/run-pass/match-vec-rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmatch-vec-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmatch-vec-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-vec-rvalue.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -12,7 +12,7 @@\n \n \n pub fn main() {\n-    match vec!(1, 2, 3) {\n+    match vec!(1i, 2i, 3i) {\n         x => {\n             assert_eq!(x.len(), 3);\n             assert_eq!(*x.get(0), 1);"}, {"sha": "2b23787dd0f7f364da442d0d38a1dbd43e991a88", "filename": "src/test/run-pass/mod-view-items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmod-view-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmod-view-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod-view-items.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -16,7 +16,7 @@\n // begin failing.\n \n mod m {\n-    pub fn f() -> Vec<int> { Vec::from_elem(1u, 0) }\n+    pub fn f() -> Vec<int> { Vec::from_elem(1u, 0i) }\n }\n \n pub fn main() { let _x = m::f(); }"}, {"sha": "04d642094e33ce6cee1fe2a5a9bd4162ef2ea775", "filename": "src/test/run-pass/monomorphized-callees-with-ty-params-3314.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -33,9 +33,9 @@ impl Serializer for int {\n }\n \n pub fn main() {\n-    let foo = F { a: 1 };\n+    let foo = F { a: 1i };\n     foo.serialize(1i);\n \n-    let bar = F { a: F {a: 1 } };\n+    let bar = F { a: F {a: 1i } };\n     bar.serialize(2i);\n }"}, {"sha": "10abe4ce710fb85cb1383edbd1c190e8526eeaa1", "filename": "src/test/run-pass/multiple-trait-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmultiple-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmultiple-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmultiple-trait-bounds.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -12,5 +12,5 @@ fn f<T:PartialEq + PartialOrd>(_: T) {\n }\n \n pub fn main() {\n-    f(3);\n+    f(3i);\n }"}, {"sha": "f90e5a56d9941ca892bcaaacd0b93758dfe44148", "filename": "src/test/run-pass/mut-in-ident-patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmut-in-ident-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmut-in-ident-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmut-in-ident-patterns.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -20,7 +20,7 @@ struct X;\n impl Foo for X {}\n \n pub fn main() {\n-    let (a, mut b) = (23, 4);\n+    let (a, mut b) = (23i, 4i);\n     assert_eq!(a, 23);\n     assert_eq!(b, 4);\n     b = a + b;\n@@ -34,7 +34,7 @@ pub fn main() {\n        Baz(f32, u8)\n     }\n \n-    let (x, mut y) = (32, Foo(21));\n+    let (x, mut y) = (32i, Foo(21));\n \n     match x {\n         mut z @ 32 => {"}, {"sha": "ffab06e2203e8335a0ef88570f1e444f42cb0d85", "filename": "src/test/run-pass/mutability-inherits-through-fixed-length-vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmutability-inherits-through-fixed-length-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fmutability-inherits-through-fixed-length-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutability-inherits-through-fixed-length-vec.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n fn test1() {\n-    let mut ints = [0, ..32];\n+    let mut ints = [0i, ..32];\n     ints[0] += 1;\n     assert_eq!(ints[0], 1);\n }\n \n fn test2() {\n-    let mut ints = [0, ..32];\n+    let mut ints = [0i, ..32];\n     for i in ints.mut_iter() { *i += 22; }\n     for i in ints.iter() { assert!(*i == 22); }\n }"}, {"sha": "e95ee4c99c52eaca366a77b3254b6acca8c6a85d", "filename": "src/test/run-pass/nested-matchs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fnested-matchs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fnested-matchs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-matchs.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -16,7 +16,7 @@ fn foo() {\n     match Some::<int>(5) {\n       Some::<int>(_x) => {\n         let mut bar;\n-        match None::<int> { None::<int> => { bar = 5; } _ => { baz(); } }\n+        match None::<int> { None::<int> => { bar = 5i; } _ => { baz(); } }\n         println!(\"{:?}\", bar);\n       }\n       None::<int> => { println!(\"hello\"); }"}, {"sha": "4d15e4fe215938210bc142d7bff6e3208bea3dab", "filename": "src/test/run-pass/newtype-polymorphic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -23,7 +23,7 @@ fn myvec_elt<X>(mv: myvec<X>) -> X {\n }\n \n pub fn main() {\n-    let mv = myvec(vec!(1, 2, 3));\n+    let mv = myvec(vec!(1i, 2, 3));\n     let mv_clone = mv.clone();\n     let mv_clone = myvec_deref(mv_clone);\n     assert_eq!(*mv_clone.get(1), 2);"}, {"sha": "de5456ef1c03f553a4a728f875428f7bc9c4daaa", "filename": "src/test/run-pass/overload-index-operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -46,8 +46,8 @@ pub fn main() {\n     let bar = \"bar\".to_string();\n \n     let mut list = AssociationList {pairs: Vec::new()};\n-    list.push(foo.clone(), 22);\n-    list.push(bar.clone(), 44);\n+    list.push(foo.clone(), 22i);\n+    list.push(bar.clone(), 44i);\n \n     assert!(list[foo] == 22)\n     assert!(list[bar] == 44)"}, {"sha": "37e7ee6c21633c309118ef3c8cdb3e6e651b0ea1", "filename": "src/test/run-pass/overloaded-autoderef-indexing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-indexing.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -19,6 +19,6 @@ impl<'a, T> Deref<&'a [T]> for DerefArray<'a, T> {\n }\n \n pub fn main() {\n-    let a = &[1, 2, 3];\n+    let a = &[1i, 2i, 3i];\n     assert_eq!(DerefArray {inner: a}[1], 2);\n }"}, {"sha": "188c62751bcd979b6f99922b62e5211f75d2c358", "filename": "src/test/run-pass/overloaded-autoderef-order.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-order.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -50,7 +50,7 @@ mod priv_test {\n }\n \n pub fn main() {\n-    let nested = DerefWrapper {x: true, y: DerefWrapper {x: 0, y: 1}};\n+    let nested = DerefWrapper {x: true, y: DerefWrapper {x: 0i, y: 1i}};\n \n     // Use the first field that you can find.\n     assert_eq!(nested.x, true);\n@@ -64,7 +64,7 @@ pub fn main() {\n     // Also go through multiple levels of indirection.\n     assert_eq!(Rc::new(nested).x, true);\n \n-    let nested_priv = priv_test::DerefWrapperHideX::new(true, DerefWrapper {x: 0, y: 1});\n+    let nested_priv = priv_test::DerefWrapperHideX::new(true, DerefWrapper {x: 0i, y: 1i});\n     // FIXME(eddyb) #12808 should skip private fields.\n     // assert_eq!(nested_priv.x, 0);\n     assert_eq!((*nested_priv).x, 0);"}, {"sha": "4f449b344e3f8bf84dad28cb442896536c4b1e75", "filename": "src/test/run-pass/overloaded-autoderef-xcrate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-xcrate.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -13,5 +13,5 @@\n extern crate overloaded_autoderef_xc;\n \n fn main() {\n-    assert!(overloaded_autoderef_xc::check(5, 5));\n+    assert!(overloaded_autoderef_xc::check(5i, 5i));\n }"}, {"sha": "a0686e7f17f8bdc55f2a29909f8cab96522a45f1", "filename": "src/test/run-pass/overloaded-autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -25,7 +25,7 @@ pub fn main() {\n     assert_eq!(point.x, 2);\n     assert_eq!(point.y, 4);\n \n-    let i = Rc::new(RefCell::new(2));\n+    let i = Rc::new(RefCell::new(2i));\n     let i_value = *i.borrow();\n     *i.borrow_mut() = 5;\n     assert_eq!((i_value, *i.borrow()), (2, 5));\n@@ -45,7 +45,7 @@ pub fn main() {\n     p.borrow_mut().y += 3;\n     assert_eq!(*p.borrow(), Point {x: 3, y: 5});\n \n-    let v = Rc::new(RefCell::new([1, 2, 3]));\n+    let v = Rc::new(RefCell::new([1i, 2, 3]));\n     v.borrow_mut()[0] = 3;\n     v.borrow_mut()[1] += 3;\n     assert_eq!((v.borrow()[0], v.borrow()[1], v.borrow()[2]), (3, 5, 3));"}, {"sha": "49edf1bad57f0a9525ed357ea0778e6680b9248f", "filename": "src/test/run-pass/overloaded-deref-count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -47,7 +47,7 @@ impl<T> DerefMut<T> for DerefCounter<T> {\n }\n \n pub fn main() {\n-    let mut n = DerefCounter::new(0);\n+    let mut n = DerefCounter::new(0i);\n     let mut v = DerefCounter::new(Vec::new());\n \n     let _ = *n; // Immutable deref + copy a POD.\n@@ -60,7 +60,7 @@ pub fn main() {\n     assert_eq!(n.counts(), (2, 1)); assert_eq!(v.counts(), (1, 1));\n \n     let mut v2 = Vec::new();\n-    v2.push(1);\n+    v2.push(1i);\n \n     *n = 5; *v = v2; // Mutable deref + assignment.\n     assert_eq!(n.counts(), (2, 2)); assert_eq!(v.counts(), (1, 2));"}, {"sha": "96cf3102a42815d521b6e1f1bad044d3fa700b16", "filename": "src/test/run-pass/overloaded-deref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -19,11 +19,11 @@ struct Point {\n }\n \n pub fn main() {\n-    assert_eq!(*Rc::new(5), 5);\n-    assert_eq!(***Rc::new(box box 5), 5);\n+    assert_eq!(*Rc::new(5i), 5);\n+    assert_eq!(***Rc::new(box box 5i), 5);\n     assert_eq!(*Rc::new(Point {x: 2, y: 4}), Point {x: 2, y: 4});\n \n-    let i = Rc::new(RefCell::new(2));\n+    let i = Rc::new(RefCell::new(2i));\n     let i_value = *(*i).borrow();\n     *(*i).borrow_mut() = 5;\n     assert_eq!((i_value, *(*i).borrow()), (2, 5));\n@@ -43,7 +43,7 @@ pub fn main() {\n     (*(*p).borrow_mut()).y += 3;\n     assert_eq!(*(*p).borrow(), Point {x: 3, y: 5});\n \n-    let v = Rc::new(RefCell::new(vec!(1, 2, 3)));\n+    let v = Rc::new(RefCell::new(vec!(1i, 2, 3)));\n     *(*(*v).borrow_mut()).get_mut(0) = 3;\n     *(*(*v).borrow_mut()).get_mut(1) += 3;\n     assert_eq!((*(*(*v).borrow()).get(0),"}, {"sha": "8968b700540d58ea03f98ca761b823f334efd6f4", "filename": "src/test/run-pass/proc-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fproc-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fproc-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fproc-bounds.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -27,7 +27,7 @@ pub fn main() {\n     is_static::<proc():'static>();\n \n \n-    let a = 3;\n+    let a = 3i;\n     bar::<proc()>(proc() {\n         let b = &a;\n         println!(\"{}\", *b);"}, {"sha": "0d0fdb13db346793135787e27a4e6c3c760a6001", "filename": "src/test/run-pass/reexported-static-methods-cross-crate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Freexported-static-methods-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Freexported-static-methods-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freexported-static-methods-cross-crate.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -17,8 +17,8 @@ use reexported_static_methods::Boz;\n use reexported_static_methods::Bort;\n \n pub fn main() {\n-    assert_eq!(42, Foo::foo());\n-    assert_eq!(84, Baz::bar());\n-    assert!(Boz::boz(1));\n+    assert_eq!(42i, Foo::foo());\n+    assert_eq!(84i, Baz::bar());\n+    assert!(Boz::boz(1i));\n     assert_eq!(\"bort()\".to_string(), Bort::bort());\n }"}, {"sha": "65cecb2d5008bbfdb976ccdfd7d807a7835d2654", "filename": "src/test/run-pass/regions-copy-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -17,7 +17,7 @@ fn box_it<'r>(x: ||: 'r) -> closure_box<'r> {\n }\n \n pub fn main() {\n-    let mut i = 3;\n+    let mut i = 3i;\n     assert_eq!(i, 3);\n     {\n         let cl = || i += 1;"}, {"sha": "6deae8618fa696c94687429ec7560bc643398341", "filename": "src/test/run-pass/regions-early-bound-trait-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fregions-early-bound-trait-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fregions-early-bound-trait-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-early-bound-trait-param.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -79,7 +79,7 @@ impl<'s> Trait<'s> for (int,int) {\n }\n \n impl<'t> MakerTrait<'t> for Box<Trait<'t>> {\n-    fn mk() -> Box<Trait<'t>> { box() (4,5) as Box<Trait> }\n+    fn mk() -> Box<Trait<'t>> { box() (4i,5i) as Box<Trait> }\n }\n \n enum List<'l> {\n@@ -109,7 +109,7 @@ impl<'t> RefMakerTrait<'t> for List<'t> {\n }\n \n pub fn main() {\n-    let t = (2,3);\n+    let t = (2i,3i);\n     let o = &t as &Trait;\n     let s1 = Struct1 { f: o };\n     let s2 = Struct2 { f: o };"}, {"sha": "c262370ac5d628920c38e6a7acb06b675977f107", "filename": "src/test/run-pass/regions-early-bound-used-in-bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -30,6 +30,6 @@ fn add<'a,G:GetRef<'a, int>>(g1: G, g2: G) -> int {\n }\n \n pub fn main() {\n-    let b1 = Box { t: &3 };\n-    assert_eq!(add(b1, b1), 6);\n+    let b1 = Box { t: &3i };\n+    assert_eq!(add(b1, b1), 6i);\n }"}, {"sha": "708664f33e930697b320544f085f88f5a14dff9d", "filename": "src/test/run-pass/regions-early-bound-used-in-type-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-type-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-type-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-type-param.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -30,6 +30,6 @@ fn add<'a,G:Get<&'a int>>(g1: G, g2: G) -> int {\n }\n \n pub fn main() {\n-    let b1 = Box { t: &3 };\n-    assert_eq!(add(b1, b1), 6);\n+    let b1 = Box { t: &3i };\n+    assert_eq!(add(b1, b1), 6i);\n }"}, {"sha": "8f05531853390cd2f51d395e0e60c49595ea241f", "filename": "src/test/run-pass/regions-infer-borrow-scope-within-loop-ok.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-within-loop-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-within-loop-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-within-loop-ok.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -13,7 +13,7 @@ use std::gc::GC;\n fn borrow<'r, T>(x: &'r T) -> &'r T {x}\n \n pub fn main() {\n-    let x = box(GC) 3;\n+    let x = box(GC) 3i;\n     loop {\n         let y = borrow(x);\n         assert_eq!(*x, *y);"}, {"sha": "d1530c4c7b91a13e82d7444c3b5637f1e0ee1b47", "filename": "src/test/run-pass/regions-return-interior-of-option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fregions-return-interior-of-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9/src%2Ftest%2Frun-pass%2Fregions-return-interior-of-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-return-interior-of-option.rs?ref=9e3d0b002a5c2e81d43351c9b8550a3f4ccfb8f9", "patch": "@@ -16,14 +16,14 @@ fn get<'r, T>(opt: &'r Option<T>) -> &'r T {\n }\n \n pub fn main() {\n-    let mut x = Some(23);\n+    let mut x = Some(23i);\n \n     {\n         let y = get(&x);\n         assert_eq!(*y, 23);\n     }\n \n-    x = Some(24);\n+    x = Some(24i);\n \n     {\n         let y = get(&x);"}]}