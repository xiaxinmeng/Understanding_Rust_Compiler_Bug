{"sha": "503d25cbfdad2e31e4aac9491660bf33c14a85e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwM2QyNWNiZmRhZDJlMzFlNGFhYzk0OTE2NjBiZjMzYzE0YTg1ZTU=", "commit": {"author": {"name": "Basile Desloges", "email": "basile.desloges@gmail.com", "date": "2017-11-22T16:35:52Z"}, "committer": {"name": "Basile Desloges", "email": "basile.desloges@gmail.com", "date": "2017-11-28T12:44:09Z"}, "message": "mir-borrowck: `describe_lvalue()` can fail if a local doesn't have a name", "tree": {"sha": "830f42d28429dc9d618fd3c596ea9bcc6af34ad3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/830f42d28429dc9d618fd3c596ea9bcc6af34ad3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/503d25cbfdad2e31e4aac9491660bf33c14a85e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/503d25cbfdad2e31e4aac9491660bf33c14a85e5", "html_url": "https://github.com/rust-lang/rust/commit/503d25cbfdad2e31e4aac9491660bf33c14a85e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/503d25cbfdad2e31e4aac9491660bf33c14a85e5/comments", "author": {"login": "zilbuz", "id": 434964, "node_id": "MDQ6VXNlcjQzNDk2NA==", "avatar_url": "https://avatars.githubusercontent.com/u/434964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zilbuz", "html_url": "https://github.com/zilbuz", "followers_url": "https://api.github.com/users/zilbuz/followers", "following_url": "https://api.github.com/users/zilbuz/following{/other_user}", "gists_url": "https://api.github.com/users/zilbuz/gists{/gist_id}", "starred_url": "https://api.github.com/users/zilbuz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zilbuz/subscriptions", "organizations_url": "https://api.github.com/users/zilbuz/orgs", "repos_url": "https://api.github.com/users/zilbuz/repos", "events_url": "https://api.github.com/users/zilbuz/events{/privacy}", "received_events_url": "https://api.github.com/users/zilbuz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zilbuz", "id": 434964, "node_id": "MDQ6VXNlcjQzNDk2NA==", "avatar_url": "https://avatars.githubusercontent.com/u/434964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zilbuz", "html_url": "https://github.com/zilbuz", "followers_url": "https://api.github.com/users/zilbuz/followers", "following_url": "https://api.github.com/users/zilbuz/following{/other_user}", "gists_url": "https://api.github.com/users/zilbuz/gists{/gist_id}", "starred_url": "https://api.github.com/users/zilbuz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zilbuz/subscriptions", "organizations_url": "https://api.github.com/users/zilbuz/orgs", "repos_url": "https://api.github.com/users/zilbuz/repos", "events_url": "https://api.github.com/users/zilbuz/events{/privacy}", "received_events_url": "https://api.github.com/users/zilbuz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "436ac8928aa2e94f621111d6d99901713060b568", "url": "https://api.github.com/repos/rust-lang/rust/commits/436ac8928aa2e94f621111d6d99901713060b568", "html_url": "https://github.com/rust-lang/rust/commit/436ac8928aa2e94f621111d6d99901713060b568"}], "stats": {"total": 95, "additions": 62, "deletions": 33}, "files": [{"sha": "d83656dc25ab379f464f5107acb8534057f0bdea", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 62, "deletions": 33, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/503d25cbfdad2e31e4aac9491660bf33c14a85e5/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/503d25cbfdad2e31e4aac9491660bf33c14a85e5/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=503d25cbfdad2e31e4aac9491660bf33c14a85e5", "patch": "@@ -1343,20 +1343,25 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             |moi| curr_move_out.contains(moi)).collect::<Vec<_>>();\n \n         if mois.is_empty() {\n+            let item_msg = match self.describe_lvalue(lvalue) {\n+                Some(name) => format!(\"`{}`\", name),\n+                None => \"value\".to_owned()\n+            };\n             self.tcx.cannot_act_on_uninitialized_variable(span,\n                                                           desired_action.as_noun(),\n-                                                          &self.describe_lvalue(lvalue),\n+                                                          &self.describe_lvalue(lvalue)\n+                                                            .unwrap_or(\"_\".to_owned()),\n                                                           Origin::Mir)\n-                    .span_label(span, format!(\"use of possibly uninitialized `{}`\",\n-                                              self.describe_lvalue(lvalue)))\n+                    .span_label(span, format!(\"use of possibly uninitialized {}\", item_msg))\n                     .emit();\n         } else {\n             let msg = \"\"; //FIXME: add \"partially \" or \"collaterally \"\n \n             let mut err = self.tcx.cannot_act_on_moved_value(span,\n                                                              desired_action.as_noun(),\n                                                              msg,\n-                                                             &self.describe_lvalue(lvalue),\n+                                                             &self.describe_lvalue(lvalue)\n+                                                                .unwrap_or(\"_\".to_owned()),\n                                                              Origin::Mir);\n \n             err.span_label(span, format!(\"value {} here after move\",\n@@ -1381,14 +1386,20 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                       _context: Context,\n                                       (lvalue, span): (&Lvalue<'tcx>, Span),\n                                       borrow: &BorrowData<'tcx>) {\n+        let value_msg = match self.describe_lvalue(lvalue) {\n+            Some(name) => format!(\"`{}`\", name),\n+            None => \"value\".to_owned()\n+        };\n+        let borrow_msg = match self.describe_lvalue(&borrow.lvalue) {\n+            Some(name) => format!(\"`{}`\", name),\n+            None => \"value\".to_owned()\n+        };\n         self.tcx.cannot_move_when_borrowed(span,\n-                                           &self.describe_lvalue(lvalue),\n+                                           &self.describe_lvalue(lvalue).unwrap_or(\"_\".to_owned()),\n                                            Origin::Mir)\n                 .span_label(self.retrieve_borrow_span(borrow),\n-                            format!(\"borrow of `{}` occurs here\",\n-                                    self.describe_lvalue(&borrow.lvalue)))\n-                .span_label(span, format!(\"move out of `{}` occurs here\",\n-                                          self.describe_lvalue(lvalue)))\n+                            format!(\"borrow of {} occurs here\", borrow_msg))\n+                .span_label(span, format!(\"move out of {} occurs here\", value_msg))\n                 .emit();\n     }\n \n@@ -1398,8 +1409,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                          borrow : &BorrowData<'tcx>) {\n \n         let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n-            span, &self.describe_lvalue(lvalue),\n-            self.retrieve_borrow_span(borrow), &self.describe_lvalue(&borrow.lvalue),\n+            span,\n+            &self.describe_lvalue(lvalue).unwrap_or(\"_\".to_owned()),\n+            self.retrieve_borrow_span(borrow),\n+            &self.describe_lvalue(&borrow.lvalue).unwrap_or(\"_\".to_owned()),\n             Origin::Mir);\n \n         err.emit();\n@@ -1488,7 +1501,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let old_closure_span = self.find_closure_span(issued_span, issued_borrow.location);\n         let issued_span = old_closure_span.map(|(args, _)| args).unwrap_or(issued_span);\n \n-        let desc_lvalue = self.describe_lvalue(lvalue);\n+        let desc_lvalue = self.describe_lvalue(lvalue).unwrap_or(\"_\".to_owned());\n \n         // FIXME: supply non-\"\" `opt_via` when appropriate\n         let mut err = match (gen_borrow_kind, \"immutable\", \"mutable\",\n@@ -1566,7 +1579,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                            (lvalue, span): (&Lvalue<'tcx>, Span),\n                                            loan: &BorrowData) {\n         let mut err = self.tcx.cannot_assign_to_borrowed(\n-            span, self.retrieve_borrow_span(loan), &self.describe_lvalue(lvalue), Origin::Mir);\n+            span,\n+            self.retrieve_borrow_span(loan),\n+            &self.describe_lvalue(lvalue).unwrap_or(\"_\".to_owned()),\n+            Origin::Mir);\n \n         err.emit();\n     }\n@@ -1576,12 +1592,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                    (lvalue, span): (&Lvalue<'tcx>, Span),\n                                    assigned_span: Span) {\n         let mut err = self.tcx.cannot_reassign_immutable(span,\n-                                           &self.describe_lvalue(lvalue),\n+                                           &self.describe_lvalue(lvalue).unwrap_or(\"_\".to_owned()),\n                                            Origin::Mir);\n         err.span_label(span, \"cannot assign twice to immutable variable\");\n         if span != assigned_span {\n-            err.span_label(assigned_span, format!(\"first assignment to `{}`\",\n-                                              self.describe_lvalue(lvalue)));\n+            let value_msg = match self.describe_lvalue(lvalue) {\n+                Some(name) => format!(\"`{}`\", name),\n+                None => \"value\".to_owned()\n+            };\n+            err.span_label(assigned_span, format!(\"first assignment to {}\", value_msg));\n         }\n         err.emit();\n     }\n@@ -1596,11 +1615,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-    // End-user visible description of `lvalue`\n-    fn describe_lvalue(&self, lvalue: &Lvalue<'tcx>) -> String {\n+    // End-user visible description of `lvalue` if one can be found. If the\n+    // lvalue is a temporary for instance, None will be returned.\n+    fn describe_lvalue(&self, lvalue: &Lvalue<'tcx>) -> Option<String> {\n         let mut buf = String::new();\n-        self.append_lvalue_to_string(lvalue, &mut buf, false);\n-        buf\n+        match self.append_lvalue_to_string(lvalue, &mut buf, false) {\n+            Ok(()) => Some(buf),\n+            Err(()) => None\n+        }\n     }\n \n     /// If this is a field projection, and the field is being projected from a closure type,\n@@ -1632,10 +1654,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn append_lvalue_to_string(&self,\n                                lvalue: &Lvalue<'tcx>,\n                                buf: &mut String,\n-                               mut autoderef: bool) {\n+                               mut autoderef: bool) -> Result<(), ()> {\n         match *lvalue {\n             Lvalue::Local(local) => {\n-                self.append_local_to_string(local, buf, \"_\");\n+                self.append_local_to_string(local, buf,)?;\n             }\n             Lvalue::Static(ref static_) => {\n                 buf.push_str(&format!(\"{}\", &self.tcx.item_name(static_.def_id)));\n@@ -1653,15 +1675,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             }\n                         } else {\n                             if autoderef {\n-                                self.append_lvalue_to_string(&proj.base, buf, autoderef);\n+                                self.append_lvalue_to_string(&proj.base, buf, autoderef)?;\n                             } else {\n                                 buf.push_str(&\"*\");\n-                                self.append_lvalue_to_string(&proj.base, buf, autoderef);\n+                                self.append_lvalue_to_string(&proj.base, buf, autoderef)?;\n                             }\n                         }\n                     },\n                     ProjectionElem::Downcast(..) => {\n-                        self.append_lvalue_to_string(&proj.base, buf, autoderef);\n+                        self.append_lvalue_to_string(&proj.base, buf, autoderef)?;\n                     },\n                     ProjectionElem::Field(field, _ty) => {\n                         autoderef = true;\n@@ -1672,38 +1694,45 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             buf.push_str(&name);\n                         } else {\n                             let field_name = self.describe_field(&proj.base, field);\n-                            self.append_lvalue_to_string(&proj.base, buf, autoderef);\n+                            self.append_lvalue_to_string(&proj.base, buf, autoderef)?;\n                             buf.push_str(&format!(\".{}\", field_name));\n                         }\n                     },\n                     ProjectionElem::Index(index) => {\n                         autoderef = true;\n \n-                        self.append_lvalue_to_string(&proj.base, buf, autoderef);\n+                        self.append_lvalue_to_string(&proj.base, buf, autoderef)?;\n                         buf.push_str(\"[\");\n-                        self.append_local_to_string(index, buf, \"..\");\n+                        if let Err(_) = self.append_local_to_string(index, buf) {\n+                            buf.push_str(\"..\");\n+                        }\n                         buf.push_str(\"]\");\n                     },\n                     ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n                         autoderef = true;\n                         // Since it isn't possible to borrow an element on a particular index and\n                         // then use another while the borrow is held, don't output indices details\n                         // to avoid confusing the end-user\n-                        self.append_lvalue_to_string(&proj.base, buf, autoderef);\n+                        self.append_lvalue_to_string(&proj.base, buf, autoderef)?;\n                         buf.push_str(&\"[..]\");\n                     },\n                 };\n             }\n         }\n+\n+        Ok(())\n     }\n \n     // Appends end-user visible description of the `local` lvalue to `buf`. If `local` doesn't have\n-    // a name, then `none_string` is appended instead\n-    fn append_local_to_string(&self, local_index: Local, buf: &mut String, none_string: &str) {\n+    // a name, then `Err` is returned\n+    fn append_local_to_string(&self, local_index: Local, buf: &mut String) -> Result<(), ()> {\n         let local = &self.mir.local_decls[local_index];\n         match local.name {\n-            Some(name) => buf.push_str(&format!(\"{}\", name)),\n-            None => buf.push_str(none_string)\n+            Some(name) => {\n+                buf.push_str(&format!(\"{}\", name));\n+                Ok(())\n+            },\n+            None => Err(())\n         }\n     }\n "}]}