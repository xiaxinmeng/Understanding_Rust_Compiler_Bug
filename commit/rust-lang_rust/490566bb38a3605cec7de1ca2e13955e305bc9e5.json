{"sha": "490566bb38a3605cec7de1ca2e13955e305bc9e5", "node_id": "C_kwDOAAsO6NoAKDQ5MDU2NmJiMzhhMzYwNWNlYzdkZTFjYTJlMTM5NTVlMzA1YmM5ZTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-31T17:36:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-31T17:36:04Z"}, "message": "Auto merge of #8179 - nmathewson:unused_async_io_amount, r=xFrednet\n\nExtend unused_io_amount to cover async io.\n\nClippy helpfully warns about code like this, telling you that you\nprobably meant \"write_all\":\n\n    fn say_hi<W:Write>(w: &mut W) {\n       w.write(b\"hello\").unwrap();\n    }\n\nThis patch attempts to extend the lint so it also covers this\ncase:\n\n    async fn say_hi<W:AsyncWrite>(w: &mut W) {\n       w.write(b\"hello\").await.unwrap();\n    }\n\n(I've run into this second case several times in my own programming,\nand so have my coworkers, so unless we're especially accident-prone\nin this area, it's probably worth addressing?)\n\nSince this is my first attempt at a clippy patch, I've probably\nmade all kinds of mistakes: please help me fix them?  I'd like\nto learn more here.\n\nOpen questions I have:\n\n  * Should this be a separate lint from unused_io_amount?  Maybe\n    unused_async_io_amount?  If so, how should I structure their\n    shared code?\n  * Should this cover tokio's AsyncWrite too?\n  * Is it okay to write lints for stuff that isn't part of\n    the standard library?  I see that \"regex\" also has lints,\n    and I figure that \"futures\" is probably okay too, since it's\n    an official rust-lang repository.\n  * What other tests are needed?\n  * How should I improve the code?\n\nThanks for your time!\n\n---\n\nchangelog: [`unused_io_amount`] now supports async read and write traits", "tree": {"sha": "e6acb595faa37bad0bcb31c64800a501643d40b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6acb595faa37bad0bcb31c64800a501643d40b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/490566bb38a3605cec7de1ca2e13955e305bc9e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/490566bb38a3605cec7de1ca2e13955e305bc9e5", "html_url": "https://github.com/rust-lang/rust/commit/490566bb38a3605cec7de1ca2e13955e305bc9e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/490566bb38a3605cec7de1ca2e13955e305bc9e5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0eff589afc83e21a03a168497bbab6b4dfbb4ef6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0eff589afc83e21a03a168497bbab6b4dfbb4ef6", "html_url": "https://github.com/rust-lang/rust/commit/0eff589afc83e21a03a168497bbab6b4dfbb4ef6"}, {"sha": "b6bcf0c51b0d719cfd141c1c010b41ebe74f2abb", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6bcf0c51b0d719cfd141c1c010b41ebe74f2abb", "html_url": "https://github.com/rust-lang/rust/commit/b6bcf0c51b0d719cfd141c1c010b41ebe74f2abb"}], "stats": {"total": 259, "additions": 227, "deletions": 32}, "files": [{"sha": "79a7ec92071c0068a33d1e7a0bf9f4cd0df38ba1", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/490566bb38a3605cec7de1ca2e13955e305bc9e5/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/490566bb38a3605cec7de1ca2e13955e305bc9e5/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=490566bb38a3605cec7de1ca2e13955e305bc9e5", "patch": "@@ -47,7 +47,9 @@ itertools = \"0.10\"\n quote = \"1.0\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n syn = { version = \"1.0\", features = [\"full\"] }\n+futures = \"0.3\"\n parking_lot = \"0.11.2\"\n+tokio = { version = \"1\", features = [\"io-util\"] }\n \n [build-dependencies]\n rustc_tools_util = { version = \"0.2\", path = \"rustc_tools_util\" }"}, {"sha": "287ac5b4a90835d162e12b4c9407e29f563e5578", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 76, "deletions": 13, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/490566bb38a3605cec7de1ca2e13955e305bc9e5/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490566bb38a3605cec7de1ca2e13955e305bc9e5/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=490566bb38a3605cec7de1ca2e13955e305bc9e5", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::{is_try, match_trait_method, paths};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n@@ -17,10 +17,17 @@ declare_clippy_lint! {\n     /// partial-write/read, use\n     /// `write_all`/`read_exact` instead.\n     ///\n+    /// When working with asynchronous code (either with the `futures`\n+    /// crate or with `tokio`), a similar issue exists for\n+    /// `AsyncWriteExt::write()` and `AsyncReadExt::read()` : these\n+    /// functions are also not guaranteed to process the entire\n+    /// buffer.  Your code should either handle partial-writes/reads, or\n+    /// call the `write_all`/`read_exact` methods on those traits instead.\n+    ///\n     /// ### Known problems\n     /// Detects only common patterns.\n     ///\n-    /// ### Example\n+    /// ### Examples\n     /// ```rust,ignore\n     /// use std::io;\n     /// fn foo<W: io::Write>(w: &mut W) -> io::Result<()> {\n@@ -68,6 +75,23 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n     }\n }\n \n+/// If `expr` is an (e).await, return the inner expression \"e\" that's being\n+/// waited on.  Otherwise return None.\n+fn try_remove_await<'a>(expr: &'a hir::Expr<'a>) -> Option<&hir::Expr<'a>> {\n+    if let hir::ExprKind::Match(expr, _, hir::MatchSource::AwaitDesugar) = expr.kind {\n+        if let hir::ExprKind::Call(func, [ref arg_0, ..]) = expr.kind {\n+            if matches!(\n+                func.kind,\n+                hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::IntoFutureIntoFuture, ..))\n+            ) {\n+                return Some(arg_0);\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n fn check_map_error(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>) {\n     let mut call = call;\n     while let hir::ExprKind::MethodCall(path, _, args, _) = call.kind {\n@@ -77,30 +101,69 @@ fn check_map_error(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<\n             break;\n         }\n     }\n-    check_method_call(cx, call, expr);\n+\n+    if let Some(call) = try_remove_await(call) {\n+        check_method_call(cx, call, expr, true);\n+    } else {\n+        check_method_call(cx, call, expr, false);\n+    }\n }\n \n-fn check_method_call(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>) {\n+fn check_method_call(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>, is_await: bool) {\n     if let hir::ExprKind::MethodCall(path, _, _, _) = call.kind {\n         let symbol = path.ident.as_str();\n-        let read_trait = match_trait_method(cx, call, &paths::IO_READ);\n-        let write_trait = match_trait_method(cx, call, &paths::IO_WRITE);\n+        let read_trait = if is_await {\n+            match_trait_method(cx, call, &paths::FUTURES_IO_ASYNCREADEXT)\n+                || match_trait_method(cx, call, &paths::TOKIO_IO_ASYNCREADEXT)\n+        } else {\n+            match_trait_method(cx, call, &paths::IO_READ)\n+        };\n+        let write_trait = if is_await {\n+            match_trait_method(cx, call, &paths::FUTURES_IO_ASYNCWRITEEXT)\n+                || match_trait_method(cx, call, &paths::TOKIO_IO_ASYNCWRITEEXT)\n+        } else {\n+            match_trait_method(cx, call, &paths::IO_WRITE)\n+        };\n \n-        match (read_trait, write_trait, symbol) {\n-            (true, _, \"read\") => span_lint(\n+        match (read_trait, write_trait, symbol, is_await) {\n+            (true, _, \"read\", false) => span_lint_and_help(\n+                cx,\n+                UNUSED_IO_AMOUNT,\n+                expr.span,\n+                \"read amount is not handled\",\n+                None,\n+                \"use `Read::read_exact` instead, or handle partial reads\",\n+            ),\n+            (true, _, \"read\", true) => span_lint_and_help(\n                 cx,\n                 UNUSED_IO_AMOUNT,\n                 expr.span,\n-                \"read amount is not handled. Use `Read::read_exact` instead\",\n+                \"read amount is not handled\",\n+                None,\n+                \"use `AsyncReadExt::read_exact` instead, or handle partial reads\",\n             ),\n-            (true, _, \"read_vectored\") => span_lint(cx, UNUSED_IO_AMOUNT, expr.span, \"read amount is not handled\"),\n-            (_, true, \"write\") => span_lint(\n+            (true, _, \"read_vectored\", _) => {\n+                span_lint(cx, UNUSED_IO_AMOUNT, expr.span, \"read amount is not handled\");\n+            },\n+            (_, true, \"write\", false) => span_lint_and_help(\n                 cx,\n                 UNUSED_IO_AMOUNT,\n                 expr.span,\n-                \"written amount is not handled. Use `Write::write_all` instead\",\n+                \"written amount is not handled\",\n+                None,\n+                \"use `Write::write_all` instead, or handle partial writes\",\n             ),\n-            (_, true, \"write_vectored\") => span_lint(cx, UNUSED_IO_AMOUNT, expr.span, \"written amount is not handled\"),\n+            (_, true, \"write\", true) => span_lint_and_help(\n+                cx,\n+                UNUSED_IO_AMOUNT,\n+                expr.span,\n+                \"written amount is not handled\",\n+                None,\n+                \"use `AsyncWriteExt::write_all` instead, or handle partial writes\",\n+            ),\n+            (_, true, \"write_vectored\", _) => {\n+                span_lint(cx, UNUSED_IO_AMOUNT, expr.span, \"written amount is not handled\");\n+            },\n             _ => (),\n         }\n     }"}, {"sha": "aa3b3af2356700348dda96075fd136ae55b1101c", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/490566bb38a3605cec7de1ca2e13955e305bc9e5/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490566bb38a3605cec7de1ca2e13955e305bc9e5/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=490566bb38a3605cec7de1ca2e13955e305bc9e5", "patch": "@@ -64,6 +64,10 @@ pub const FROM_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"From\n pub const FROM_ITERATOR_METHOD: [&str; 6] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\", \"from_iter\"];\n pub const FROM_STR_METHOD: [&str; 5] = [\"core\", \"str\", \"traits\", \"FromStr\", \"from_str\"];\n pub const FUTURE_FROM_GENERATOR: [&str; 3] = [\"core\", \"future\", \"from_generator\"];\n+#[allow(clippy::invalid_paths)] // internal lints do not know about all external crates\n+pub const FUTURES_IO_ASYNCREADEXT: [&str; 3] = [\"futures_util\", \"io\", \"AsyncReadExt\"];\n+#[allow(clippy::invalid_paths)] // internal lints do not know about all external crates\n+pub const FUTURES_IO_ASYNCWRITEEXT: [&str; 3] = [\"futures_util\", \"io\", \"AsyncWriteExt\"];\n pub const HASH: [&str; 3] = [\"core\", \"hash\", \"Hash\"];\n pub const HASHMAP_CONTAINS_KEY: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"contains_key\"];\n pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n@@ -194,6 +198,10 @@ pub const SYM_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"sym\"];\n pub const SYNTAX_CONTEXT: [&str; 3] = [\"rustc_span\", \"hygiene\", \"SyntaxContext\"];\n pub const TO_OWNED_METHOD: [&str; 4] = [\"alloc\", \"borrow\", \"ToOwned\", \"to_owned\"];\n pub const TO_STRING_METHOD: [&str; 4] = [\"alloc\", \"string\", \"ToString\", \"to_string\"];\n+#[allow(clippy::invalid_paths)] // internal lints do not know about all external crates\n+pub const TOKIO_IO_ASYNCREADEXT: [&str; 5] = [\"tokio\", \"io\", \"util\", \"async_read_ext\", \"AsyncReadExt\"];\n+#[allow(clippy::invalid_paths)] // internal lints do not know about all external crates\n+pub const TOKIO_IO_ASYNCWRITEEXT: [&str; 5] = [\"tokio\", \"io\", \"util\", \"async_write_ext\", \"AsyncWriteExt\"];\n pub const TRY_FROM: [&str; 4] = [\"core\", \"convert\", \"TryFrom\", \"try_from\"];\n pub const VEC_AS_MUT_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_mut_slice\"];\n pub const VEC_AS_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_slice\"];"}, {"sha": "d602d2042ee7fd30f6255eebd293993abc95c77a", "filename": "tests/compile-test.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/490566bb38a3605cec7de1ca2e13955e305bc9e5/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490566bb38a3605cec7de1ca2e13955e305bc9e5/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=490566bb38a3605cec7de1ca2e13955e305bc9e5", "patch": "@@ -21,13 +21,15 @@ const RUN_INTERNAL_TESTS: bool = cfg!(feature = \"internal-lints\");\n static TEST_DEPENDENCIES: &[&str] = &[\n     \"clippy_utils\",\n     \"derive_new\",\n+    \"futures\",\n     \"if_chain\",\n     \"itertools\",\n     \"quote\",\n     \"regex\",\n     \"serde\",\n     \"serde_derive\",\n     \"syn\",\n+    \"tokio\",\n     \"parking_lot\",\n ];\n \n@@ -38,6 +40,8 @@ extern crate clippy_utils;\n #[allow(unused_extern_crates)]\n extern crate derive_new;\n #[allow(unused_extern_crates)]\n+extern crate futures;\n+#[allow(unused_extern_crates)]\n extern crate if_chain;\n #[allow(unused_extern_crates)]\n extern crate itertools;\n@@ -47,6 +51,8 @@ extern crate parking_lot;\n extern crate quote;\n #[allow(unused_extern_crates)]\n extern crate syn;\n+#[allow(unused_extern_crates)]\n+extern crate tokio;\n \n /// Produces a string with an `--extern` flag for all UI test crate\n /// dependencies."}, {"sha": "4b059558173fb783044655ef7358f968cd633d88", "filename": "tests/ui/unused_io_amount.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/490566bb38a3605cec7de1ca2e13955e305bc9e5/tests%2Fui%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490566bb38a3605cec7de1ca2e13955e305bc9e5/tests%2Fui%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_io_amount.rs?ref=490566bb38a3605cec7de1ca2e13955e305bc9e5", "patch": "@@ -1,6 +1,8 @@\n #![allow(dead_code)]\n #![warn(clippy::unused_io_amount)]\n \n+extern crate futures;\n+use futures::io::{AsyncRead, AsyncReadExt, AsyncWrite, AsyncWriteExt};\n use std::io::{self, Read};\n \n fn question_mark<T: io::Read + io::Write>(s: &mut T) -> io::Result<()> {\n@@ -61,4 +63,55 @@ fn combine_or(file: &str) -> Result<(), Error> {\n     Ok(())\n }\n \n+async fn bad_async_write<W: AsyncWrite + Unpin>(w: &mut W) {\n+    w.write(b\"hello world\").await.unwrap();\n+}\n+\n+async fn bad_async_read<R: AsyncRead + Unpin>(r: &mut R) {\n+    let mut buf = [0u8; 0];\n+    r.read(&mut buf[..]).await.unwrap();\n+}\n+\n+async fn io_not_ignored_async_write<W: AsyncWrite + Unpin>(mut w: W) {\n+    // Here we're forgetting to await the future, so we should get a\n+    // warning about _that_ (or we would, if it were enabled), but we\n+    // won't get one about ignoring the return value.\n+    w.write(b\"hello world\");\n+}\n+\n+fn bad_async_write_closure<W: AsyncWrite + Unpin + 'static>(w: W) -> impl futures::Future<Output = io::Result<()>> {\n+    let mut w = w;\n+    async move {\n+        w.write(b\"hello world\").await?;\n+        Ok(())\n+    }\n+}\n+\n+async fn async_read_nested_or<R: AsyncRead + Unpin>(r: &mut R, do_it: bool) -> Result<[u8; 1], Error> {\n+    let mut buf = [0u8; 1];\n+    if do_it {\n+        r.read(&mut buf[..]).await.or(Err(Error::Kind))?;\n+    }\n+    Ok(buf)\n+}\n+\n+use tokio::io::{AsyncRead as TokioAsyncRead, AsyncReadExt as _, AsyncWrite as TokioAsyncWrite, AsyncWriteExt as _};\n+\n+async fn bad_async_write_tokio<W: TokioAsyncWrite + Unpin>(w: &mut W) {\n+    w.write(b\"hello world\").await.unwrap();\n+}\n+\n+async fn bad_async_read_tokio<R: TokioAsyncRead + Unpin>(r: &mut R) {\n+    let mut buf = [0u8; 0];\n+    r.read(&mut buf[..]).await.unwrap();\n+}\n+\n+async fn undetected_bad_async_write<W: AsyncWrite + Unpin>(w: &mut W) {\n+    // It would be good to detect this case some day, but the current lint\n+    // doesn't handle it. (The documentation says that this lint \"detects\n+    // only common patterns\".)\n+    let future = w.write(b\"Hello world\");\n+    future.await.unwrap();\n+}\n+\n fn main() {}"}, {"sha": "e5bdd993aa1ad260736e52313562233762107b36", "filename": "tests/ui/unused_io_amount.stderr", "status": "modified", "additions": 82, "deletions": 19, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/490566bb38a3605cec7de1ca2e13955e305bc9e5/tests%2Fui%2Funused_io_amount.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/490566bb38a3605cec7de1ca2e13955e305bc9e5/tests%2Fui%2Funused_io_amount.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_io_amount.stderr?ref=490566bb38a3605cec7de1ca2e13955e305bc9e5", "patch": "@@ -1,68 +1,131 @@\n-error: written amount is not handled. Use `Write::write_all` instead\n-  --> $DIR/unused_io_amount.rs:7:5\n+error: written amount is not handled\n+  --> $DIR/unused_io_amount.rs:9:5\n    |\n LL |     s.write(b\"test\")?;\n    |     ^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::unused-io-amount` implied by `-D warnings`\n+   = help: use `Write::write_all` instead, or handle partial writes\n \n-error: read amount is not handled. Use `Read::read_exact` instead\n-  --> $DIR/unused_io_amount.rs:9:5\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:11:5\n    |\n LL |     s.read(&mut buf)?;\n    |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `Read::read_exact` instead, or handle partial reads\n \n-error: written amount is not handled. Use `Write::write_all` instead\n-  --> $DIR/unused_io_amount.rs:14:5\n+error: written amount is not handled\n+  --> $DIR/unused_io_amount.rs:16:5\n    |\n LL |     s.write(b\"test\").unwrap();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `Write::write_all` instead, or handle partial writes\n \n-error: read amount is not handled. Use `Read::read_exact` instead\n-  --> $DIR/unused_io_amount.rs:16:5\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:18:5\n    |\n LL |     s.read(&mut buf).unwrap();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `Read::read_exact` instead, or handle partial reads\n \n error: read amount is not handled\n-  --> $DIR/unused_io_amount.rs:20:5\n+  --> $DIR/unused_io_amount.rs:22:5\n    |\n LL |     s.read_vectored(&mut [io::IoSliceMut::new(&mut [])])?;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: written amount is not handled\n-  --> $DIR/unused_io_amount.rs:21:5\n+  --> $DIR/unused_io_amount.rs:23:5\n    |\n LL |     s.write_vectored(&[io::IoSlice::new(&[])])?;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: read amount is not handled. Use `Read::read_exact` instead\n-  --> $DIR/unused_io_amount.rs:28:5\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:30:5\n    |\n LL |     reader.read(&mut result).ok()?;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `Read::read_exact` instead, or handle partial reads\n \n-error: read amount is not handled. Use `Read::read_exact` instead\n-  --> $DIR/unused_io_amount.rs:37:5\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:39:5\n    |\n LL |     reader.read(&mut result).or_else(|err| Err(err))?;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `Read::read_exact` instead, or handle partial reads\n \n-error: read amount is not handled. Use `Read::read_exact` instead\n-  --> $DIR/unused_io_amount.rs:49:5\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:51:5\n    |\n LL |     reader.read(&mut result).or(Err(Error::Kind))?;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `Read::read_exact` instead, or handle partial reads\n \n-error: read amount is not handled. Use `Read::read_exact` instead\n-  --> $DIR/unused_io_amount.rs:56:5\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:58:5\n    |\n LL | /     reader\n LL | |         .read(&mut result)\n LL | |         .or(Err(Error::Kind))\n LL | |         .or(Err(Error::Kind))\n LL | |         .expect(\"error\");\n    | |________________________^\n+   |\n+   = help: use `Read::read_exact` instead, or handle partial reads\n+\n+error: written amount is not handled\n+  --> $DIR/unused_io_amount.rs:67:5\n+   |\n+LL |     w.write(b\"hello world\").await.unwrap();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `AsyncWriteExt::write_all` instead, or handle partial writes\n+\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:72:5\n+   |\n+LL |     r.read(&mut buf[..]).await.unwrap();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `AsyncReadExt::read_exact` instead, or handle partial reads\n+\n+error: written amount is not handled\n+  --> $DIR/unused_io_amount.rs:85:9\n+   |\n+LL |         w.write(b\"hello world\").await?;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `AsyncWriteExt::write_all` instead, or handle partial writes\n+\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:93:9\n+   |\n+LL |         r.read(&mut buf[..]).await.or(Err(Error::Kind))?;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `AsyncReadExt::read_exact` instead, or handle partial reads\n+\n+error: written amount is not handled\n+  --> $DIR/unused_io_amount.rs:101:5\n+   |\n+LL |     w.write(b\"hello world\").await.unwrap();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `AsyncWriteExt::write_all` instead, or handle partial writes\n+\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:106:5\n+   |\n+LL |     r.read(&mut buf[..]).await.unwrap();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `AsyncReadExt::read_exact` instead, or handle partial reads\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 16 previous errors\n "}]}