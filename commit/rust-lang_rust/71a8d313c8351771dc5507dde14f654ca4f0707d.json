{"sha": "71a8d313c8351771dc5507dde14f654ca4f0707d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxYThkMzEzYzgzNTE3NzFkYzU1MDdkZGUxNGY2NTRjYTRmMDcwN2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-09T04:28:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-09T04:28:57Z"}, "message": "Auto merge of #25627 - murarth:execution-engine-fix, r=nrc\n\n* Removes `RustJITMemoryManager` from public API.\r\n  This was really sort of an implementation detail to begin with.\r\n* `__morestack` is linked to C++ wrapper code and this pointer\r\n  is used when resolving the symbol for `ExecutionEngine` code.\r\n* `__morestack_addr` is also resolved for `ExecutionEngine` code.\r\n  This function is sometimes referenced in LLVM-generated code,\r\n  but was not able to be resolved on Mac OS systems.\r\n* Added Windows support to `ExecutionEngine` API.\r\n* Added a test for basic `ExecutionEngine` functionality.", "tree": {"sha": "b428370aa123041e946c1275471ad6be32bff79b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b428370aa123041e946c1275471ad6be32bff79b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71a8d313c8351771dc5507dde14f654ca4f0707d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71a8d313c8351771dc5507dde14f654ca4f0707d", "html_url": "https://github.com/rust-lang/rust/commit/71a8d313c8351771dc5507dde14f654ca4f0707d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71a8d313c8351771dc5507dde14f654ca4f0707d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "html_url": "https://github.com/rust-lang/rust/commit/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe"}, {"sha": "021e48326db304559a74f2f338d511f9674d0da7", "url": "https://api.github.com/repos/rust-lang/rust/commits/021e48326db304559a74f2f338d511f9674d0da7", "html_url": "https://github.com/rust-lang/rust/commit/021e48326db304559a74f2f338d511f9674d0da7"}], "stats": {"total": 323, "additions": 293, "deletions": 30}, "files": [{"sha": "4d7f00e95230aa17a5b933217acf0f9dcfad0c1a", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71a8d313c8351771dc5507dde14f654ca4f0707d/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a8d313c8351771dc5507dde14f654ca4f0707d/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=71a8d313c8351771dc5507dde14f654ca4f0707d", "patch": "@@ -478,9 +478,6 @@ pub type BuilderRef = *mut Builder_opaque;\n pub enum ExecutionEngine_opaque {}\n pub type ExecutionEngineRef = *mut ExecutionEngine_opaque;\n #[allow(missing_copy_implementations)]\n-pub enum RustJITMemoryManager_opaque {}\n-pub type RustJITMemoryManagerRef = *mut RustJITMemoryManager_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum MemoryBuffer_opaque {}\n pub type MemoryBufferRef = *mut MemoryBuffer_opaque;\n #[allow(missing_copy_implementations)]\n@@ -1090,10 +1087,7 @@ extern {\n     pub fn LLVMDisposeBuilder(Builder: BuilderRef);\n \n     /* Execution engine */\n-    pub fn LLVMRustCreateJITMemoryManager(morestack: *const ())\n-                                          -> RustJITMemoryManagerRef;\n-    pub fn LLVMBuildExecutionEngine(Mod: ModuleRef,\n-                                    MM: RustJITMemoryManagerRef) -> ExecutionEngineRef;\n+    pub fn LLVMBuildExecutionEngine(Mod: ModuleRef) -> ExecutionEngineRef;\n     pub fn LLVMDisposeExecutionEngine(EE: ExecutionEngineRef);\n     pub fn LLVMExecutionEngineFinalizeObject(EE: ExecutionEngineRef);\n     pub fn LLVMRustLoadDynamicLibrary(path: *const c_char) -> Bool;"}, {"sha": "e37ede82bb5604b623cd5accee0468915b22ae42", "filename": "src/rustllvm/ExecutionEngineWrapper.cpp", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/71a8d313c8351771dc5507dde14f654ca4f0707d/src%2Frustllvm%2FExecutionEngineWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/71a8d313c8351771dc5507dde14f654ca4f0707d/src%2Frustllvm%2FExecutionEngineWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FExecutionEngineWrapper.cpp?ref=71a8d313c8351771dc5507dde14f654ca4f0707d", "patch": "@@ -16,34 +16,38 @@ using namespace llvm;\n using namespace llvm::sys;\n using namespace llvm::object;\n \n+// libmorestack is not used on Windows\n+#ifndef _WIN32\n+extern \"C\" void __morestack(void);\n+\n+static void* morestack_addr() {\n+    return reinterpret_cast<void*>(__morestack);\n+}\n+#endif\n+\n class RustJITMemoryManager : public SectionMemoryManager\n {\n     typedef SectionMemoryManager Base;\n \n-    const void *morestack;\n-\n     public:\n \n-    RustJITMemoryManager(const void *morestack_ptr)\n-        : morestack(morestack_ptr)\n-        {}\n+    RustJITMemoryManager() {}\n \n     uint64_t getSymbolAddress(const std::string &Name) override\n     {\n+#ifndef _WIN32\n         if (Name == \"__morestack\" || Name == \"___morestack\")\n-            return reinterpret_cast<uint64_t>(morestack);\n+            return reinterpret_cast<uint64_t>(__morestack);\n+        if (Name == \"__morestack_addr\" || Name == \"___morestack_addr\")\n+            return reinterpret_cast<uint64_t>(morestack_addr);\n+#endif\n \n         return Base::getSymbolAddress(Name);\n     }\n };\n \n DEFINE_SIMPLE_CONVERSION_FUNCTIONS(RustJITMemoryManager, LLVMRustJITMemoryManagerRef)\n \n-extern \"C\" LLVMRustJITMemoryManagerRef LLVMRustCreateJITMemoryManager(void *morestack)\n-{\n-    return wrap(new RustJITMemoryManager(morestack));\n-}\n-\n extern \"C\" LLVMBool LLVMRustLoadDynamicLibrary(const char *path)\n {\n     std::string err;\n@@ -60,6 +64,13 @@ extern \"C\" LLVMBool LLVMRustLoadDynamicLibrary(const char *path)\n extern \"C\" void LLVMExecutionEngineAddModule(\n     LLVMExecutionEngineRef eeref, LLVMModuleRef mref)\n {\n+#ifdef _WIN32\n+    // On Windows, MCJIT must generate ELF objects\n+    std::string target = getProcessTriple();\n+    target += \"-elf\";\n+    target = Triple::normalize(target);\n+    unwrap(mref)->setTargetTriple(target);\n+#endif\n     LLVMAddModule(eeref, mref);\n }\n \n@@ -74,27 +85,36 @@ extern \"C\" LLVMBool LLVMExecutionEngineRemoveModule(\n     return ee->removeModule(m);\n }\n \n-extern \"C\" LLVMExecutionEngineRef LLVMBuildExecutionEngine(\n-    LLVMModuleRef mod, LLVMRustJITMemoryManagerRef mref)\n+extern \"C\" LLVMExecutionEngineRef LLVMBuildExecutionEngine(LLVMModuleRef mod)\n {\n     // These are necessary for code generation to work properly.\n     InitializeNativeTarget();\n     InitializeNativeTargetAsmPrinter();\n     InitializeNativeTargetAsmParser();\n \n+#ifdef _WIN32\n+    // On Windows, MCJIT must generate ELF objects\n+    std::string target = getProcessTriple();\n+    target += \"-elf\";\n+    target = Triple::normalize(target);\n+    unwrap(mod)->setTargetTriple(target);\n+#endif\n+\n     std::string error_str;\n     TargetOptions options;\n \n     options.JITEmitDebugInfo = true;\n     options.NoFramePointerElim = true;\n \n+    RustJITMemoryManager *mm = new RustJITMemoryManager;\n+\n     ExecutionEngine *ee =\n     #if LLVM_VERSION_MINOR >= 6\n         EngineBuilder(std::unique_ptr<Module>(unwrap(mod)))\n-            .setMCJITMemoryManager(std::unique_ptr<RustJITMemoryManager>(unwrap(mref)))\n+            .setMCJITMemoryManager(std::unique_ptr<RustJITMemoryManager>(mm))\n     #else\n         EngineBuilder(unwrap(mod))\n-            .setMCJITMemoryManager(unwrap(mref))\n+            .setMCJITMemoryManager(mm)\n     #endif\n             .setEngineKind(EngineKind::JIT)\n             .setErrorStr(&error_str)"}, {"sha": "bb82c0c818677607252355e6e119cdccec3bf383", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71a8d313c8351771dc5507dde14f654ca4f0707d/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/71a8d313c8351771dc5507dde14f654ca4f0707d/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=71a8d313c8351771dc5507dde14f654ca4f0707d", "patch": "@@ -51,14 +51,6 @@\n #include \"llvm/IR/DIBuilder.h\"\n #include \"llvm/Linker/Linker.h\"\n \n-// Used by RustMCJITMemoryManager::getPointerToNamedFunction()\n-// to get around glibc issues. See the function for more information.\n-#ifdef __linux__\n-#include <sys/stat.h>\n-#include <fcntl.h>\n-#include <unistd.h>\n-#endif\n-\n void LLVMRustSetLastError(const char*);\n \n typedef struct OpaqueRustString *RustStringRef;"}, {"sha": "387905f45d84a343b5187c88f8760484e84d0ee0", "filename": "src/test/run-make/execution-engine/Makefile", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71a8d313c8351771dc5507dde14f654ca4f0707d/src%2Ftest%2Frun-make%2Fexecution-engine%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/71a8d313c8351771dc5507dde14f654ca4f0707d/src%2Ftest%2Frun-make%2Fexecution-engine%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2FMakefile?ref=71a8d313c8351771dc5507dde14f654ca4f0707d", "patch": "@@ -0,0 +1,8 @@\n+-include ../tools.mk\n+\n+# This is a basic test of LLVM ExecutionEngine functionality using compiled\n+# Rust code built using the `rustc` crate.\n+\n+all:\n+\t$(RUSTC) test.rs\n+\t$(call RUN,test $(RUSTC))"}, {"sha": "ba6d0d246e4e4c5b15974cfe78ff9e959715cb61", "filename": "src/test/run-make/execution-engine/test.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/71a8d313c8351771dc5507dde14f654ca4f0707d/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a8d313c8351771dc5507dde14f654ca4f0707d/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=71a8d313c8351771dc5507dde14f654ca4f0707d", "patch": "@@ -0,0 +1,249 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_private)]\n+\n+extern crate rustc;\n+extern crate rustc_driver;\n+extern crate rustc_lint;\n+extern crate rustc_resolve;\n+extern crate syntax;\n+\n+use std::ffi::{CStr, CString};\n+use std::mem::transmute;\n+use std::path::PathBuf;\n+use std::thread::Builder;\n+\n+use rustc::llvm;\n+use rustc::metadata::cstore::RequireDynamic;\n+use rustc::middle::ty;\n+use rustc::session::config::{self, basic_options, build_configuration, Input, Options};\n+use rustc::session::build_session;\n+use rustc_driver::driver;\n+use rustc_resolve::MakeGlobMap;\n+\n+use syntax::ast_map;\n+use syntax::diagnostics::registry::Registry;\n+\n+fn main() {\n+    let program = r#\"\n+    #[no_mangle]\n+    pub static TEST_STATIC: i32 = 42;\n+    \"#;\n+\n+    let program2 = r#\"\n+    #[no_mangle]\n+    pub fn test_add(a: i32, b: i32) -> i32 { a + b }\n+    \"#;\n+\n+    let mut path = match std::env::args().nth(2) {\n+        Some(path) => PathBuf::from(&path),\n+        None => panic!(\"missing rustc path\")\n+    };\n+\n+    // Remove two segments from rustc path to get sysroot.\n+    path.pop();\n+    path.pop();\n+\n+    let mut ee = ExecutionEngine::new(program, path);\n+\n+    let test_static = match ee.get_global(\"TEST_STATIC\") {\n+        Some(g) => g as *const i32,\n+        None => panic!(\"failed to get global\")\n+    };\n+\n+    assert_eq!(unsafe { *test_static }, 42);\n+\n+    ee.add_module(program2);\n+\n+    let test_add: fn(i32, i32) -> i32;\n+\n+    test_add = match ee.get_function(\"test_add\") {\n+        Some(f) => unsafe { transmute(f) },\n+        None => panic!(\"failed to get function\")\n+    };\n+\n+    assert_eq!(test_add(1, 2), 3);\n+}\n+\n+struct ExecutionEngine {\n+    ee: llvm::ExecutionEngineRef,\n+    modules: Vec<llvm::ModuleRef>,\n+    sysroot: PathBuf,\n+}\n+\n+impl ExecutionEngine {\n+    pub fn new(program: &str, sysroot: PathBuf) -> ExecutionEngine {\n+        let (llmod, deps) = compile_program(program, sysroot.clone())\n+            .expect(\"failed to compile program\");\n+\n+        let ee = unsafe { llvm::LLVMBuildExecutionEngine(llmod) };\n+\n+        if ee.is_null() {\n+            panic!(\"Failed to create ExecutionEngine: {}\", llvm_error());\n+        }\n+\n+        let ee = ExecutionEngine{\n+            ee: ee,\n+            modules: vec![llmod],\n+            sysroot: sysroot,\n+        };\n+\n+        ee.load_deps(&deps);\n+        ee\n+    }\n+\n+    pub fn add_module(&mut self, program: &str) {\n+        let (llmod, deps) = compile_program(program, self.sysroot.clone())\n+            .expect(\"failed to compile program in add_module\");\n+\n+        unsafe { llvm::LLVMExecutionEngineAddModule(self.ee, llmod); }\n+\n+        self.modules.push(llmod);\n+        self.load_deps(&deps);\n+    }\n+\n+    /// Returns a raw pointer to the named function.\n+    pub fn get_function(&mut self, name: &str) -> Option<*const ()> {\n+        let s = CString::new(name.as_bytes()).unwrap();\n+\n+        for &m in &self.modules {\n+            let fv = unsafe { llvm::LLVMGetNamedFunction(m, s.as_ptr()) };\n+\n+            if !fv.is_null() {\n+                let fp = unsafe { llvm::LLVMGetPointerToGlobal(self.ee, fv) };\n+\n+                assert!(!fp.is_null());\n+                return Some(fp);\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Returns a raw pointer to the named global item.\n+    pub fn get_global(&mut self, name: &str) -> Option<*const ()> {\n+        let s = CString::new(name.as_bytes()).unwrap();\n+\n+        for &m in &self.modules {\n+            let gv = unsafe { llvm::LLVMGetNamedGlobal(m, s.as_ptr()) };\n+\n+            if !gv.is_null() {\n+                let gp = unsafe { llvm::LLVMGetPointerToGlobal(self.ee, gv) };\n+\n+                assert!(!gp.is_null());\n+                return Some(gp);\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Loads all dependencies of compiled code.\n+    /// Expects a series of paths to dynamic library files.\n+    fn load_deps(&self, deps: &[PathBuf]) {\n+        for path in deps {\n+            let s = match path.as_os_str().to_str() {\n+                Some(s) => s,\n+                None => panic!(\n+                    \"Could not convert crate path to UTF-8 string: {:?}\", path)\n+            };\n+            let cs = CString::new(s).unwrap();\n+\n+            let res = unsafe { llvm::LLVMRustLoadDynamicLibrary(cs.as_ptr()) };\n+\n+            if res == 0 {\n+                panic!(\"Failed to load crate {:?}: {}\",\n+                    path.display(), llvm_error());\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for ExecutionEngine {\n+    fn drop(&mut self) {\n+        unsafe { llvm::LLVMDisposeExecutionEngine(self.ee) };\n+    }\n+}\n+\n+/// Returns last error from LLVM wrapper code.\n+fn llvm_error() -> String {\n+    String::from_utf8_lossy(\n+        unsafe { CStr::from_ptr(llvm::LLVMRustGetLastError()).to_bytes() })\n+        .into_owned()\n+}\n+\n+fn build_exec_options(sysroot: PathBuf) -> Options {\n+    let mut opts = basic_options();\n+\n+    // librustc derives sysroot from the executable name.\n+    // Since we are not rustc, we must specify it.\n+    opts.maybe_sysroot = Some(sysroot);\n+\n+    // Prefer faster build time\n+    opts.optimize = config::No;\n+\n+    // Don't require a `main` function\n+    opts.crate_types = vec![config::CrateTypeDylib];\n+\n+    opts\n+}\n+\n+/// Compiles input up to phase 4, translation to LLVM.\n+///\n+/// Returns the LLVM `ModuleRef` and a series of paths to dynamic libraries\n+/// for crates used in the given input.\n+fn compile_program(input: &str, sysroot: PathBuf)\n+                   -> Option<(llvm::ModuleRef, Vec<PathBuf>)> {\n+    let input = Input::Str(input.to_string());\n+    let thread = Builder::new().name(\"compile_program\".to_string());\n+\n+    let handle = thread.spawn(move || {\n+        let opts = build_exec_options(sysroot);\n+        let sess = build_session(opts, None, Registry::new(&rustc::DIAGNOSTICS));\n+        rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n+\n+        let cfg = build_configuration(&sess);\n+\n+        let id = \"input\".to_string();\n+\n+        let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n+\n+        let krate = driver::phase_2_configure_and_expand(&sess, krate, &id, None)\n+            .expect(\"phase_2 returned `None`\");\n+\n+        let mut forest = ast_map::Forest::new(krate);\n+        let arenas = ty::CtxtArenas::new();\n+        let ast_map = driver::assign_node_ids_and_map(&sess, &mut forest);\n+\n+        let analysis = driver::phase_3_run_analysis_passes(\n+            sess, ast_map, &arenas, id, MakeGlobMap::No);\n+\n+        let (tcx, trans) = driver::phase_4_translate_to_llvm(analysis);\n+\n+        let crates = tcx.sess.cstore.get_used_crates(RequireDynamic);\n+\n+        // Collect crates used in the session.\n+        // Reverse order finds dependencies first.\n+        let deps = crates.into_iter().rev()\n+            .filter_map(|(_, p)| p).collect();\n+\n+        assert_eq!(trans.modules.len(), 1);\n+        let llmod = trans.modules[0].llmod;\n+\n+        // Workaround because raw pointers do not impl Send\n+        let modp = llmod as usize;\n+\n+        (modp, deps)\n+    }).unwrap();\n+\n+    match handle.join() {\n+        Ok((llmod, deps)) => Some((llmod as llvm::ModuleRef, deps)),\n+        Err(_) => None\n+    }\n+}"}]}