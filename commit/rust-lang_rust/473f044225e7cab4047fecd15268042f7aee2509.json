{"sha": "473f044225e7cab4047fecd15268042f7aee2509", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3M2YwNDQyMjVlN2NhYjQwNDdmZWNkMTUyNjgwNDJmN2FlZTI1MDk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-01T12:39:51Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-01T16:48:57Z"}, "message": "MIR: s/lv(al(ue)?)?/place in function/variable/module names.", "tree": {"sha": "5158f34246ff2d4f549cfee7e8a312d37b2305ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5158f34246ff2d4f549cfee7e8a312d37b2305ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/473f044225e7cab4047fecd15268042f7aee2509", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/473f044225e7cab4047fecd15268042f7aee2509", "html_url": "https://github.com/rust-lang/rust/commit/473f044225e7cab4047fecd15268042f7aee2509", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/473f044225e7cab4047fecd15268042f7aee2509/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "511743c438c4cb1511b97fb851585d57492d7642", "url": "https://api.github.com/repos/rust-lang/rust/commits/511743c438c4cb1511b97fb851585d57492d7642", "html_url": "https://github.com/rust-lang/rust/commit/511743c438c4cb1511b97fb851585d57492d7642"}], "stats": {"total": 2093, "additions": 1047, "deletions": 1046}, "files": [{"sha": "331b44ac119c6b7f0fddb4704cd5585364b0e983", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -272,24 +272,24 @@ for mir::StatementKind<'gcx> {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n-                lvalue.hash_stable(hcx, hasher);\n+            mir::StatementKind::Assign(ref place, ref rvalue) => {\n+                place.hash_stable(hcx, hasher);\n                 rvalue.hash_stable(hcx, hasher);\n             }\n-            mir::StatementKind::SetDiscriminant { ref lvalue, variant_index } => {\n-                lvalue.hash_stable(hcx, hasher);\n+            mir::StatementKind::SetDiscriminant { ref place, variant_index } => {\n+                place.hash_stable(hcx, hasher);\n                 variant_index.hash_stable(hcx, hasher);\n             }\n-            mir::StatementKind::StorageLive(ref lvalue) |\n-            mir::StatementKind::StorageDead(ref lvalue) => {\n-                lvalue.hash_stable(hcx, hasher);\n+            mir::StatementKind::StorageLive(ref place) |\n+            mir::StatementKind::StorageDead(ref place) => {\n+                place.hash_stable(hcx, hasher);\n             }\n             mir::StatementKind::EndRegion(ref region_scope) => {\n                 region_scope.hash_stable(hcx, hasher);\n             }\n-            mir::StatementKind::Validate(ref op, ref lvalues) => {\n+            mir::StatementKind::Validate(ref op, ref places) => {\n                 op.hash_stable(hcx, hasher);\n-                lvalues.hash_stable(hcx, hasher);\n+                places.hash_stable(hcx, hasher);\n             }\n             mir::StatementKind::Nop => {}\n             mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n@@ -309,7 +309,7 @@ impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>)\n     {\n-        self.lval.hash_stable(hcx, hasher);\n+        self.place.hash_stable(hcx, hasher);\n         self.ty.hash_stable(hcx, hasher);\n         self.re.hash_stable(hcx, hasher);\n         self.mutbl.hash_stable(hcx, hasher);\n@@ -330,8 +330,8 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Place<'gcx> {\n             mir::Place::Static(ref statik) => {\n                 statik.hash_stable(hcx, hasher);\n             }\n-            mir::Place::Projection(ref lvalue_projection) => {\n-                lvalue_projection.hash_stable(hcx, hasher);\n+            mir::Place::Projection(ref place_projection) => {\n+                place_projection.hash_stable(hcx, hasher);\n             }\n         }\n     }\n@@ -420,11 +420,11 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Operand<'gcx> {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            mir::Operand::Copy(ref lvalue) => {\n-                lvalue.hash_stable(hcx, hasher);\n+            mir::Operand::Copy(ref place) => {\n+                place.hash_stable(hcx, hasher);\n             }\n-            mir::Operand::Move(ref lvalue) => {\n-                lvalue.hash_stable(hcx, hasher);\n+            mir::Operand::Move(ref place) => {\n+                place.hash_stable(hcx, hasher);\n             }\n             mir::Operand::Constant(ref constant) => {\n                 constant.hash_stable(hcx, hasher);\n@@ -447,13 +447,13 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Rvalue<'gcx> {\n                 operand.hash_stable(hcx, hasher);\n                 val.hash_stable(hcx, hasher);\n             }\n-            mir::Rvalue::Ref(region, borrow_kind, ref lvalue) => {\n+            mir::Rvalue::Ref(region, borrow_kind, ref place) => {\n                 region.hash_stable(hcx, hasher);\n                 borrow_kind.hash_stable(hcx, hasher);\n-                lvalue.hash_stable(hcx, hasher);\n+                place.hash_stable(hcx, hasher);\n             }\n-            mir::Rvalue::Len(ref lvalue) => {\n-                lvalue.hash_stable(hcx, hasher);\n+            mir::Rvalue::Len(ref place) => {\n+                place.hash_stable(hcx, hasher);\n             }\n             mir::Rvalue::Cast(cast_kind, ref operand, ty) => {\n                 cast_kind.hash_stable(hcx, hasher);\n@@ -470,8 +470,8 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Rvalue<'gcx> {\n                 op.hash_stable(hcx, hasher);\n                 operand.hash_stable(hcx, hasher);\n             }\n-            mir::Rvalue::Discriminant(ref lvalue) => {\n-                lvalue.hash_stable(hcx, hasher);\n+            mir::Rvalue::Discriminant(ref place) => {\n+                place.hash_stable(hcx, hasher);\n             }\n             mir::Rvalue::NullaryOp(op, ty) => {\n                 op.hash_stable(hcx, hasher);"}, {"sha": "0cbd945095a959fbabd7da8d403ce532f71d7939", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 79, "deletions": 76, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -139,7 +139,7 @@ impl<'tcx> Mir<'tcx> {\n                upvar_decls: Vec<UpvarDecl>,\n                span: Span) -> Self\n     {\n-        // We need `arg_count` locals, and one for the return pointer\n+        // We need `arg_count` locals, and one for the return place\n         assert!(local_decls.len() >= arg_count + 1,\n             \"expected at least {} locals, got {}\", arg_count + 1, local_decls.len());\n \n@@ -200,7 +200,7 @@ impl<'tcx> Mir<'tcx> {\n         let index = local.0 as usize;\n         if index == 0 {\n             debug_assert!(self.local_decls[local].mutability == Mutability::Mut,\n-                          \"return pointer should be mutable\");\n+                          \"return place should be mutable\");\n \n             LocalKind::ReturnPointer\n         } else if index < self.arg_count + 1 {\n@@ -249,7 +249,7 @@ impl<'tcx> Mir<'tcx> {\n     }\n \n     /// Returns an iterator over all user-defined variables and compiler-generated temporaries (all\n-    /// locals that are neither arguments nor the return pointer).\n+    /// locals that are neither arguments nor the return place).\n     #[inline]\n     pub fn vars_and_temps_iter(&self) -> impl Iterator<Item=Local> {\n         let arg_count = self.arg_count;\n@@ -280,7 +280,7 @@ impl<'tcx> Mir<'tcx> {\n \n     /// Return the return type, it always return first element from `local_decls` array\n     pub fn return_ty(&self) -> Ty<'tcx> {\n-        self.local_decls[RETURN_POINTER].ty\n+        self.local_decls[RETURN_PLACE].ty\n     }\n }\n \n@@ -417,7 +417,7 @@ pub enum BorrowKind {\n newtype_index!(Local\n     {\n         DEBUG_FORMAT = \"_{}\",\n-        const RETURN_POINTER = 0,\n+        const RETURN_PLACE = 0,\n     });\n \n /// Classifies locals into categories. See `Mir::local_kind`.\n@@ -436,12 +436,12 @@ pub enum LocalKind {\n /// A MIR local.\n ///\n /// This can be a binding declared by the user, a temporary inserted by the compiler, a function\n-/// argument, or the return pointer.\n+/// argument, or the return place.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct LocalDecl<'tcx> {\n     /// `let mut x` vs `let x`.\n     ///\n-    /// Temporaries and the return pointer are always mutable.\n+    /// Temporaries and the return place are always mutable.\n     pub mutability: Mutability,\n \n     /// True if this corresponds to a user-declared local variable.\n@@ -520,11 +520,11 @@ impl<'tcx> LocalDecl<'tcx> {\n         }\n     }\n \n-    /// Builds a `LocalDecl` for the return pointer.\n+    /// Builds a `LocalDecl` for the return place.\n     ///\n     /// This must be inserted into the `local_decls` list as the first local.\n     #[inline]\n-    pub fn new_return_pointer(return_ty: Ty, span: Span) -> LocalDecl {\n+    pub fn new_return_place(return_ty: Ty, span: Span) -> LocalDecl {\n         LocalDecl {\n             mutability: Mutability::Mut,\n             ty: return_ty,\n@@ -634,8 +634,8 @@ pub enum TerminatorKind<'tcx> {\n     /// continue. Emitted by build::scope::diverge_cleanup.\n     Resume,\n \n-    /// Indicates a normal return. The return pointer lvalue should\n-    /// have been filled in by now. This should occur at most once.\n+    /// Indicates a normal return. The return place should have\n+    /// been filled in by now. This should occur at most once.\n     Return,\n \n     /// Indicates a terminator that can never be reached.\n@@ -650,7 +650,7 @@ pub enum TerminatorKind<'tcx> {\n \n     /// Drop the Place and assign the new value over it. This ensures\n     /// that the assignment to LV occurs *even if* the destructor for\n-    /// lvalue unwinds. Its semantics are best explained by by the\n+    /// place unwinds. Its semantics are best explained by by the\n     /// elaboration:\n     ///\n     /// ```\n@@ -878,7 +878,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n         use self::TerminatorKind::*;\n         match *self {\n             Goto { .. } => write!(fmt, \"goto\"),\n-            SwitchInt { discr: ref lv, .. } => write!(fmt, \"switchInt({:?})\", lv),\n+            SwitchInt { discr: ref place, .. } => write!(fmt, \"switchInt({:?})\", place),\n             Return => write!(fmt, \"return\"),\n             GeneratorDrop => write!(fmt, \"generator_drop\"),\n             Resume => write!(fmt, \"resume\"),\n@@ -1006,7 +1006,7 @@ pub enum StatementKind<'tcx> {\n     Assign(Place<'tcx>, Rvalue<'tcx>),\n \n     /// Write the discriminant for a variant to the enum Place.\n-    SetDiscriminant { lvalue: Place<'tcx>, variant_index: usize },\n+    SetDiscriminant { place: Place<'tcx>, variant_index: usize },\n \n     /// Start a live range for the storage of the local.\n     StorageLive(Local),\n@@ -1021,7 +1021,7 @@ pub enum StatementKind<'tcx> {\n         inputs: Vec<Operand<'tcx>>\n     },\n \n-    /// Assert the given lvalues to be valid inhabitants of their type.  These statements are\n+    /// Assert the given places to be valid inhabitants of their type.  These statements are\n     /// currently only interpreted by miri and only generated when \"-Z mir-emit-validate\" is passed.\n     /// See <https://internals.rust-lang.org/t/types-as-contracts/5562/73> for more details.\n     Validate(ValidationOp, Vec<ValidationOperand<'tcx, Place<'tcx>>>),\n@@ -1038,9 +1038,9 @@ pub enum StatementKind<'tcx> {\n /// `Validate` statement.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, PartialEq, Eq)]\n pub enum ValidationOp {\n-    /// Recursively traverse the lvalue following the type and validate that all type\n+    /// Recursively traverse the place following the type and validate that all type\n     /// invariants are maintained.  Furthermore, acquire exclusive/read-only access to the\n-    /// memory reachable from the lvalue.\n+    /// memory reachable from the place.\n     Acquire,\n     /// Recursive traverse the *mutable* part of the type and relinquish all exclusive\n     /// access.\n@@ -1065,15 +1065,15 @@ impl Debug for ValidationOp {\n // This is generic so that it can be reused by miri\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct ValidationOperand<'tcx, T> {\n-    pub lval: T,\n+    pub place: T,\n     pub ty: Ty<'tcx>,\n     pub re: Option<region::Scope>,\n     pub mutbl: hir::Mutability,\n }\n \n impl<'tcx, T: Debug> Debug for ValidationOperand<'tcx, T> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n-        write!(fmt, \"{:?}: {:?}\", self.lval, self.ty)?;\n+        write!(fmt, \"{:?}: {:?}\", self.place, self.ty)?;\n         if let Some(ce) = self.re {\n             // (reuse lifetime rendering policy from ppaux.)\n             write!(fmt, \"/{}\", ty::ReScope(ce))?;\n@@ -1089,14 +1089,14 @@ impl<'tcx> Debug for Statement<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::StatementKind::*;\n         match self.kind {\n-            Assign(ref lv, ref rv) => write!(fmt, \"{:?} = {:?}\", lv, rv),\n+            Assign(ref place, ref rv) => write!(fmt, \"{:?} = {:?}\", place, rv),\n             // (reuse lifetime rendering policy from ppaux.)\n             EndRegion(ref ce) => write!(fmt, \"EndRegion({})\", ty::ReScope(*ce)),\n-            Validate(ref op, ref lvalues) => write!(fmt, \"Validate({:?}, {:?})\", op, lvalues),\n-            StorageLive(ref lv) => write!(fmt, \"StorageLive({:?})\", lv),\n-            StorageDead(ref lv) => write!(fmt, \"StorageDead({:?})\", lv),\n-            SetDiscriminant{lvalue: ref lv, variant_index: index} => {\n-                write!(fmt, \"discriminant({:?}) = {:?}\", lv, index)\n+            Validate(ref op, ref places) => write!(fmt, \"Validate({:?}, {:?})\", op, places),\n+            StorageLive(ref place) => write!(fmt, \"StorageLive({:?})\", place),\n+            StorageDead(ref place) => write!(fmt, \"StorageDead({:?})\", place),\n+            SetDiscriminant { ref place, variant_index } => {\n+                write!(fmt, \"discriminant({:?}) = {:?}\", place, variant_index)\n             },\n             InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm, outputs, inputs)\n@@ -1119,7 +1119,7 @@ pub enum Place<'tcx> {\n     /// static or static mut variable\n     Static(Box<Static<'tcx>>),\n \n-    /// projection out of an lvalue (access a field, deref a pointer, etc)\n+    /// projection out of a place (access a field, deref a pointer, etc)\n     Projection(Box<PlaceProjection<'tcx>>),\n }\n \n@@ -1184,11 +1184,11 @@ pub enum ProjectionElem<'tcx, V, T> {\n     Downcast(&'tcx AdtDef, usize),\n }\n \n-/// Alias for projections as they appear in lvalues, where the base is an lvalue\n+/// Alias for projections as they appear in places, where the base is a place\n /// and the index is a local.\n pub type PlaceProjection<'tcx> = Projection<'tcx, Place<'tcx>, Local, Ty<'tcx>>;\n \n-/// Alias for projections as they appear in lvalues, where the base is an lvalue\n+/// Alias for projections as they appear in places, where the base is a place\n /// and the index is a local.\n pub type PlaceElem<'tcx> = ProjectionElem<'tcx, Local, Ty<'tcx>>;\n \n@@ -1273,13 +1273,13 @@ pub struct VisibilityScopeData {\n // Operands\n \n /// These are values that can appear inside an rvalue (or an index\n-/// lvalue). They are intentionally limited to prevent rvalues from\n+/// place). They are intentionally limited to prevent rvalues from\n /// being nested in one another.\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Operand<'tcx> {\n     /// Copy: The value must be available for use afterwards.\n     ///\n-    /// This implies that the type of the lvalue must be `Copy`; this is true\n+    /// This implies that the type of the place must be `Copy`; this is true\n     /// by construction during build, but also checked by the MIR type checker.\n     Copy(Place<'tcx>),\n     /// Move: The value (including old borrows of it) will not be used again.\n@@ -1296,8 +1296,8 @@ impl<'tcx> Debug for Operand<'tcx> {\n         use self::Operand::*;\n         match *self {\n             Constant(ref a) => write!(fmt, \"{:?}\", a),\n-            Copy(ref lv) => write!(fmt, \"{:?}\", lv),\n-            Move(ref lv) => write!(fmt, \"move {:?}\", lv),\n+            Copy(ref place) => write!(fmt, \"{:?}\", place),\n+            Move(ref place) => write!(fmt, \"move {:?}\", place),\n         }\n     }\n }\n@@ -1470,18 +1470,20 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n         use self::Rvalue::*;\n \n         match *self {\n-            Use(ref lvalue) => write!(fmt, \"{:?}\", lvalue),\n+            Use(ref place) => write!(fmt, \"{:?}\", place),\n             Repeat(ref a, ref b) => write!(fmt, \"[{:?}; {:?}]\", a, b),\n             Len(ref a) => write!(fmt, \"Len({:?})\", a),\n-            Cast(ref kind, ref lv, ref ty) => write!(fmt, \"{:?} as {:?} ({:?})\", lv, ty, kind),\n+            Cast(ref kind, ref place, ref ty) => {\n+                write!(fmt, \"{:?} as {:?} ({:?})\", place, ty, kind)\n+            }\n             BinaryOp(ref op, ref a, ref b) => write!(fmt, \"{:?}({:?}, {:?})\", op, a, b),\n             CheckedBinaryOp(ref op, ref a, ref b) => {\n                 write!(fmt, \"Checked{:?}({:?}, {:?})\", op, a, b)\n             }\n             UnaryOp(ref op, ref a) => write!(fmt, \"{:?}({:?})\", op, a),\n-            Discriminant(ref lval) => write!(fmt, \"discriminant({:?})\", lval),\n+            Discriminant(ref place) => write!(fmt, \"discriminant({:?})\", place),\n             NullaryOp(ref op, ref t) => write!(fmt, \"{:?}({:?})\", op, t),\n-            Ref(region, borrow_kind, ref lv) => {\n+            Ref(region, borrow_kind, ref place) => {\n                 let kind_str = match borrow_kind {\n                     BorrowKind::Shared => \"\",\n                     BorrowKind::Mut | BorrowKind::Unique => \"mut \",\n@@ -1496,26 +1498,26 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     // Do not even print 'static\n                     \"\".to_owned()\n                 };\n-                write!(fmt, \"&{}{}{:?}\", region, kind_str, lv)\n+                write!(fmt, \"&{}{}{:?}\", region, kind_str, place)\n             }\n \n-            Aggregate(ref kind, ref lvs) => {\n-                fn fmt_tuple(fmt: &mut Formatter, lvs: &[Operand]) -> fmt::Result {\n+            Aggregate(ref kind, ref places) => {\n+                fn fmt_tuple(fmt: &mut Formatter, places: &[Operand]) -> fmt::Result {\n                     let mut tuple_fmt = fmt.debug_tuple(\"\");\n-                    for lv in lvs {\n-                        tuple_fmt.field(lv);\n+                    for place in places {\n+                        tuple_fmt.field(place);\n                     }\n                     tuple_fmt.finish()\n                 }\n \n                 match **kind {\n-                    AggregateKind::Array(_) => write!(fmt, \"{:?}\", lvs),\n+                    AggregateKind::Array(_) => write!(fmt, \"{:?}\", places),\n \n                     AggregateKind::Tuple => {\n-                        match lvs.len() {\n+                        match places.len() {\n                             0 => write!(fmt, \"()\"),\n-                            1 => write!(fmt, \"({:?},)\", lvs[0]),\n-                            _ => fmt_tuple(fmt, lvs),\n+                            1 => write!(fmt, \"({:?},)\", places[0]),\n+                            _ => fmt_tuple(fmt, places),\n                         }\n                     }\n \n@@ -1526,11 +1528,11 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                         match variant_def.ctor_kind {\n                             CtorKind::Const => Ok(()),\n-                            CtorKind::Fn => fmt_tuple(fmt, lvs),\n+                            CtorKind::Fn => fmt_tuple(fmt, places),\n                             CtorKind::Fictive => {\n                                 let mut struct_fmt = fmt.debug_struct(\"\");\n-                                for (field, lv) in variant_def.fields.iter().zip(lvs) {\n-                                    struct_fmt.field(&field.name.as_str(), lv);\n+                                for (field, place) in variant_def.fields.iter().zip(places) {\n+                                    struct_fmt.field(&field.name.as_str(), place);\n                                 }\n                                 struct_fmt.finish()\n                             }\n@@ -1547,9 +1549,9 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             tcx.with_freevars(node_id, |freevars| {\n-                                for (freevar, lv) in freevars.iter().zip(lvs) {\n+                                for (freevar, place) in freevars.iter().zip(places) {\n                                     let var_name = tcx.hir.name(freevar.var_id());\n-                                    struct_fmt.field(&var_name.as_str(), lv);\n+                                    struct_fmt.field(&var_name.as_str(), place);\n                                 }\n                             });\n \n@@ -1565,14 +1567,14 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             tcx.with_freevars(node_id, |freevars| {\n-                                for (freevar, lv) in freevars.iter().zip(lvs) {\n+                                for (freevar, place) in freevars.iter().zip(places) {\n                                     let var_name = tcx.hir.name(freevar.var_id());\n-                                    struct_fmt.field(&var_name.as_str(), lv);\n+                                    struct_fmt.field(&var_name.as_str(), place);\n                                 }\n-                                struct_fmt.field(\"$state\", &lvs[freevars.len()]);\n-                                for i in (freevars.len() + 1)..lvs.len() {\n+                                struct_fmt.field(\"$state\", &places[freevars.len()]);\n+                                for i in (freevars.len() + 1)..places.len() {\n                                     struct_fmt.field(&format!(\"${}\", i - freevars.len() - 1),\n-                                                     &lvs[i]);\n+                                                     &places[i]);\n                                 }\n                             });\n \n@@ -1831,15 +1833,15 @@ impl<'tcx> TypeFoldable<'tcx> for BasicBlockData<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for ValidationOperand<'tcx, Place<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ValidationOperand {\n-            lval: self.lval.fold_with(folder),\n+            place: self.place.fold_with(folder),\n             ty: self.ty.fold_with(folder),\n             re: self.re,\n             mutbl: self.mutbl,\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.lval.visit_with(visitor) || self.ty.visit_with(visitor)\n+        self.place.visit_with(visitor) || self.ty.visit_with(visitor)\n     }\n }\n \n@@ -1848,9 +1850,9 @@ impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n         use mir::StatementKind::*;\n \n         let kind = match self.kind {\n-            Assign(ref lval, ref rval) => Assign(lval.fold_with(folder), rval.fold_with(folder)),\n-            SetDiscriminant { ref lvalue, variant_index } => SetDiscriminant {\n-                lvalue: lvalue.fold_with(folder),\n+            Assign(ref place, ref rval) => Assign(place.fold_with(folder), rval.fold_with(folder)),\n+            SetDiscriminant { ref place, variant_index } => SetDiscriminant {\n+                place: place.fold_with(folder),\n                 variant_index,\n             },\n             StorageLive(ref local) => StorageLive(local.fold_with(folder)),\n@@ -1867,9 +1869,9 @@ impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n             // trait with a `fn fold_scope`.\n             EndRegion(ref region_scope) => EndRegion(region_scope.clone()),\n \n-            Validate(ref op, ref lvals) =>\n+            Validate(ref op, ref places) =>\n                 Validate(op.clone(),\n-                         lvals.iter().map(|operand| operand.fold_with(folder)).collect()),\n+                         places.iter().map(|operand| operand.fold_with(folder)).collect()),\n \n             Nop => Nop,\n         };\n@@ -1883,8 +1885,8 @@ impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n         use mir::StatementKind::*;\n \n         match self.kind {\n-            Assign(ref lval, ref rval) => { lval.visit_with(visitor) || rval.visit_with(visitor) }\n-            SetDiscriminant { ref lvalue, .. } => lvalue.visit_with(visitor),\n+            Assign(ref place, ref rval) => { place.visit_with(visitor) || rval.visit_with(visitor) }\n+            SetDiscriminant { ref place, .. } => place.visit_with(visitor),\n             StorageLive(ref local) |\n             StorageDead(ref local) => local.visit_with(visitor),\n             InlineAsm { ref outputs, ref inputs, .. } =>\n@@ -1896,8 +1898,8 @@ impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n             // trait with a `fn visit_scope`.\n             EndRegion(ref _scope) => false,\n \n-            Validate(ref _op, ref lvalues) =>\n-                lvalues.iter().any(|ty_and_lvalue| ty_and_lvalue.visit_with(visitor)),\n+            Validate(ref _op, ref places) =>\n+                places.iter().any(|ty_and_place| ty_and_place.visit_with(visitor)),\n \n             Nop => false,\n         }\n@@ -2035,15 +2037,16 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n         match *self {\n             Use(ref op) => Use(op.fold_with(folder)),\n             Repeat(ref op, len) => Repeat(op.fold_with(folder), len),\n-            Ref(region, bk, ref lval) => Ref(region.fold_with(folder), bk, lval.fold_with(folder)),\n-            Len(ref lval) => Len(lval.fold_with(folder)),\n+            Ref(region, bk, ref place) =>\n+                Ref(region.fold_with(folder), bk, place.fold_with(folder)),\n+            Len(ref place) => Len(place.fold_with(folder)),\n             Cast(kind, ref op, ty) => Cast(kind, op.fold_with(folder), ty.fold_with(folder)),\n             BinaryOp(op, ref rhs, ref lhs) =>\n                 BinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder)),\n             CheckedBinaryOp(op, ref rhs, ref lhs) =>\n                 CheckedBinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder)),\n             UnaryOp(op, ref val) => UnaryOp(op, val.fold_with(folder)),\n-            Discriminant(ref lval) => Discriminant(lval.fold_with(folder)),\n+            Discriminant(ref place) => Discriminant(place.fold_with(folder)),\n             NullaryOp(op, ty) => NullaryOp(op, ty.fold_with(folder)),\n             Aggregate(ref kind, ref fields) => {\n                 let kind = box match **kind {\n@@ -2068,14 +2071,14 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n         match *self {\n             Use(ref op) => op.visit_with(visitor),\n             Repeat(ref op, _) => op.visit_with(visitor),\n-            Ref(region, _, ref lval) => region.visit_with(visitor) || lval.visit_with(visitor),\n-            Len(ref lval) => lval.visit_with(visitor),\n+            Ref(region, _, ref place) => region.visit_with(visitor) || place.visit_with(visitor),\n+            Len(ref place) => place.visit_with(visitor),\n             Cast(_, ref op, ty) => op.visit_with(visitor) || ty.visit_with(visitor),\n             BinaryOp(_, ref rhs, ref lhs) |\n             CheckedBinaryOp(_, ref rhs, ref lhs) =>\n                 rhs.visit_with(visitor) || lhs.visit_with(visitor),\n             UnaryOp(_, ref val) => val.visit_with(visitor),\n-            Discriminant(ref lval) => lval.visit_with(visitor),\n+            Discriminant(ref place) => place.visit_with(visitor),\n             NullaryOp(_, ty) => ty.visit_with(visitor),\n             Aggregate(ref kind, ref fields) => {\n                 (match **kind {\n@@ -2094,16 +2097,16 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            Operand::Copy(ref lval) => Operand::Copy(lval.fold_with(folder)),\n-            Operand::Move(ref lval) => Operand::Move(lval.fold_with(folder)),\n+            Operand::Copy(ref place) => Operand::Copy(place.fold_with(folder)),\n+            Operand::Move(ref place) => Operand::Move(place.fold_with(folder)),\n             Operand::Constant(ref c) => Operand::Constant(c.fold_with(folder)),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n-            Operand::Copy(ref lval) |\n-            Operand::Move(ref lval) => lval.visit_with(visitor),\n+            Operand::Copy(ref place) |\n+            Operand::Move(ref place) => place.visit_with(visitor),\n             Operand::Constant(ref c) => c.visit_with(visitor)\n         }\n     }"}, {"sha": "23f360d5c3922a6e6a998675df01594e70ac18d7", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -151,11 +151,11 @@ impl<'tcx> Rvalue<'tcx> {\n             Rvalue::Repeat(ref operand, count) => {\n                 tcx.mk_array_const_usize(operand.ty(local_decls, tcx), count)\n             }\n-            Rvalue::Ref(reg, bk, ref lv) => {\n-                let lv_ty = lv.ty(local_decls, tcx).to_ty(tcx);\n+            Rvalue::Ref(reg, bk, ref place) => {\n+                let place_ty = place.ty(local_decls, tcx).to_ty(tcx);\n                 tcx.mk_ref(reg,\n                     ty::TypeAndMut {\n-                        ty: lv_ty,\n+                        ty: place_ty,\n                         mutbl: bk.to_mutbl_lossy()\n                     }\n                 )\n@@ -177,8 +177,8 @@ impl<'tcx> Rvalue<'tcx> {\n             Rvalue::UnaryOp(UnOp::Neg, ref operand) => {\n                 operand.ty(local_decls, tcx)\n             }\n-            Rvalue::Discriminant(ref lval) => {\n-                let ty = lval.ty(local_decls, tcx).to_ty(tcx);\n+            Rvalue::Discriminant(ref place) => {\n+                let ty = place.ty(local_decls, tcx).to_ty(tcx);\n                 if let ty::TyAdt(adt_def, _) = ty.sty {\n                     adt_def.repr.discr_type().to_ty(tcx)\n                 } else {"}, {"sha": "d90bf1b61a7d31bde107340606270a3dbc48b878", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -107,10 +107,10 @@ macro_rules! make_mir_visitor {\n \n             fn visit_assign(&mut self,\n                             block: BasicBlock,\n-                            lvalue: & $($mutability)* Place<'tcx>,\n+                            place: & $($mutability)* Place<'tcx>,\n                             rvalue: & $($mutability)* Rvalue<'tcx>,\n                             location: Location) {\n-                self.super_assign(block, lvalue, rvalue, location);\n+                self.super_assign(block, place, rvalue, location);\n             }\n \n             fn visit_terminator(&mut self,\n@@ -145,11 +145,11 @@ macro_rules! make_mir_visitor {\n                 self.super_operand(operand, location);\n             }\n \n-            fn visit_lvalue(&mut self,\n-                            lvalue: & $($mutability)* Place<'tcx>,\n+            fn visit_place(&mut self,\n+                            place: & $($mutability)* Place<'tcx>,\n                             context: PlaceContext<'tcx>,\n                             location: Location) {\n-                self.super_lvalue(lvalue, context, location);\n+                self.super_place(place, context, location);\n             }\n \n             fn visit_static(&mut self,\n@@ -160,17 +160,17 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_projection(&mut self,\n-                                lvalue: & $($mutability)* PlaceProjection<'tcx>,\n+                                place: & $($mutability)* PlaceProjection<'tcx>,\n                                 context: PlaceContext<'tcx>,\n                                 location: Location) {\n-                self.super_projection(lvalue, context, location);\n+                self.super_projection(place, context, location);\n             }\n \n             fn visit_projection_elem(&mut self,\n-                                     lvalue: & $($mutability)* PlaceElem<'tcx>,\n+                                     place: & $($mutability)* PlaceElem<'tcx>,\n                                      context: PlaceContext<'tcx>,\n                                      location: Location) {\n-                self.super_projection_elem(lvalue, context, location);\n+                self.super_projection_elem(place, context, location);\n             }\n \n             fn visit_branch(&mut self,\n@@ -350,21 +350,21 @@ macro_rules! make_mir_visitor {\n \n                 self.visit_source_info(source_info);\n                 match *kind {\n-                    StatementKind::Assign(ref $($mutability)* lvalue,\n+                    StatementKind::Assign(ref $($mutability)* place,\n                                           ref $($mutability)* rvalue) => {\n-                        self.visit_assign(block, lvalue, rvalue, location);\n+                        self.visit_assign(block, place, rvalue, location);\n                     }\n                     StatementKind::EndRegion(_) => {}\n-                    StatementKind::Validate(_, ref $($mutability)* lvalues) => {\n-                        for operand in lvalues {\n-                            self.visit_lvalue(& $($mutability)* operand.lval,\n+                    StatementKind::Validate(_, ref $($mutability)* places) => {\n+                        for operand in places {\n+                            self.visit_place(& $($mutability)* operand.place,\n                                               PlaceContext::Validate, location);\n                             self.visit_ty(& $($mutability)* operand.ty,\n                                           TyContext::Location(location));\n                         }\n                     }\n-                    StatementKind::SetDiscriminant{ ref $($mutability)* lvalue, .. } => {\n-                        self.visit_lvalue(lvalue, PlaceContext::Store, location);\n+                    StatementKind::SetDiscriminant{ ref $($mutability)* place, .. } => {\n+                        self.visit_place(place, PlaceContext::Store, location);\n                     }\n                     StatementKind::StorageLive(ref $($mutability)* local) => {\n                         self.visit_local(local, PlaceContext::StorageLive, location);\n@@ -376,7 +376,7 @@ macro_rules! make_mir_visitor {\n                                                ref $($mutability)* inputs,\n                                                asm: _ } => {\n                         for output in & $($mutability)* outputs[..] {\n-                            self.visit_lvalue(output, PlaceContext::Store, location);\n+                            self.visit_place(output, PlaceContext::Store, location);\n                         }\n                         for input in & $($mutability)* inputs[..] {\n                             self.visit_operand(input, location);\n@@ -388,10 +388,10 @@ macro_rules! make_mir_visitor {\n \n             fn super_assign(&mut self,\n                             _block: BasicBlock,\n-                            lvalue: &$($mutability)* Place<'tcx>,\n+                            place: &$($mutability)* Place<'tcx>,\n                             rvalue: &$($mutability)* Rvalue<'tcx>,\n                             location: Location) {\n-                self.visit_lvalue(lvalue, PlaceContext::Store, location);\n+                self.visit_place(place, PlaceContext::Store, location);\n                 self.visit_rvalue(rvalue, location);\n             }\n \n@@ -440,7 +440,7 @@ macro_rules! make_mir_visitor {\n                     TerminatorKind::Drop { ref $($mutability)* location,\n                                            target,\n                                            unwind } => {\n-                        self.visit_lvalue(location, PlaceContext::Drop, source_location);\n+                        self.visit_place(location, PlaceContext::Drop, source_location);\n                         self.visit_branch(block, target);\n                         unwind.map(|t| self.visit_branch(block, t));\n                     }\n@@ -449,7 +449,7 @@ macro_rules! make_mir_visitor {\n                                                      ref $($mutability)* value,\n                                                      target,\n                                                      unwind } => {\n-                        self.visit_lvalue(location, PlaceContext::Drop, source_location);\n+                        self.visit_place(location, PlaceContext::Drop, source_location);\n                         self.visit_operand(value, source_location);\n                         self.visit_branch(block, target);\n                         unwind.map(|t| self.visit_branch(block, t));\n@@ -464,7 +464,7 @@ macro_rules! make_mir_visitor {\n                             self.visit_operand(arg, source_location);\n                         }\n                         if let Some((ref $($mutability)* destination, target)) = *destination {\n-                            self.visit_lvalue(destination, PlaceContext::Call, source_location);\n+                            self.visit_place(destination, PlaceContext::Call, source_location);\n                             self.visit_branch(block, target);\n                         }\n                         cleanup.map(|t| self.visit_branch(block, t));\n@@ -532,14 +532,14 @@ macro_rules! make_mir_visitor {\n \n                     Rvalue::Ref(ref $($mutability)* r, bk, ref $($mutability)* path) => {\n                         self.visit_region(r, location);\n-                        self.visit_lvalue(path, PlaceContext::Borrow {\n+                        self.visit_place(path, PlaceContext::Borrow {\n                             region: *r,\n                             kind: bk\n                         }, location);\n                     }\n \n                     Rvalue::Len(ref $($mutability)* path) => {\n-                        self.visit_lvalue(path, PlaceContext::Inspect, location);\n+                        self.visit_place(path, PlaceContext::Inspect, location);\n                     }\n \n                     Rvalue::Cast(_cast_kind,\n@@ -563,8 +563,8 @@ macro_rules! make_mir_visitor {\n                         self.visit_operand(op, location);\n                     }\n \n-                    Rvalue::Discriminant(ref $($mutability)* lvalue) => {\n-                        self.visit_lvalue(lvalue, PlaceContext::Inspect, location);\n+                    Rvalue::Discriminant(ref $($mutability)* place) => {\n+                        self.visit_place(place, PlaceContext::Inspect, location);\n                     }\n \n                     Rvalue::NullaryOp(_op, ref $($mutability)* ty) => {\n@@ -611,23 +611,23 @@ macro_rules! make_mir_visitor {\n                              operand: & $($mutability)* Operand<'tcx>,\n                              location: Location) {\n                 match *operand {\n-                    Operand::Copy(ref $($mutability)* lvalue) => {\n-                        self.visit_lvalue(lvalue, PlaceContext::Copy, location);\n+                    Operand::Copy(ref $($mutability)* place) => {\n+                        self.visit_place(place, PlaceContext::Copy, location);\n                     }\n-                    Operand::Move(ref $($mutability)* lvalue) => {\n-                        self.visit_lvalue(lvalue, PlaceContext::Move, location);\n+                    Operand::Move(ref $($mutability)* place) => {\n+                        self.visit_place(place, PlaceContext::Move, location);\n                     }\n                     Operand::Constant(ref $($mutability)* constant) => {\n                         self.visit_constant(constant, location);\n                     }\n                 }\n             }\n \n-            fn super_lvalue(&mut self,\n-                            lvalue: & $($mutability)* Place<'tcx>,\n+            fn super_place(&mut self,\n+                            place: & $($mutability)* Place<'tcx>,\n                             context: PlaceContext<'tcx>,\n                             location: Location) {\n-                match *lvalue {\n+                match *place {\n                     Place::Local(ref $($mutability)* local) => {\n                         self.visit_local(local, context, location);\n                     }\n@@ -665,7 +665,7 @@ macro_rules! make_mir_visitor {\n                 } else {\n                     PlaceContext::Projection(Mutability::Not)\n                 };\n-                self.visit_lvalue(base, context, location);\n+                self.visit_place(base, context, location);\n                 self.visit_projection_elem(elem, context, location);\n             }\n \n@@ -847,10 +847,10 @@ pub enum PlaceContext<'tcx> {\n     // Being borrowed\n     Borrow { region: Region<'tcx>, kind: BorrowKind },\n \n-    // Used as base for another lvalue, e.g. `x` in `x.y`.\n+    // Used as base for another place, e.g. `x` in `x.y`.\n     //\n     // The `Mutability` argument specifies whether the projection is being performed in order to\n-    // (potentially) mutate the lvalue. For example, the projection `x.y` is marked as a mutation\n+    // (potentially) mutate the place. For example, the projection `x.y` is marked as a mutation\n     // in these cases:\n     //\n     //     x.y = ...;\n@@ -875,39 +875,39 @@ pub enum PlaceContext<'tcx> {\n }\n \n impl<'tcx> PlaceContext<'tcx> {\n-    /// Returns true if this lvalue context represents a drop.\n+    /// Returns true if this place context represents a drop.\n     pub fn is_drop(&self) -> bool {\n         match *self {\n             PlaceContext::Drop => true,\n             _ => false,\n         }\n     }\n \n-    /// Returns true if this lvalue context represents a storage live or storage dead marker.\n+    /// Returns true if this place context represents a storage live or storage dead marker.\n     pub fn is_storage_marker(&self) -> bool {\n         match *self {\n             PlaceContext::StorageLive | PlaceContext::StorageDead => true,\n             _ => false,\n         }\n     }\n \n-    /// Returns true if this lvalue context represents a storage live marker.\n+    /// Returns true if this place context represents a storage live marker.\n     pub fn is_storage_live_marker(&self) -> bool {\n         match *self {\n             PlaceContext::StorageLive => true,\n             _ => false,\n         }\n     }\n \n-    /// Returns true if this lvalue context represents a storage dead marker.\n+    /// Returns true if this place context represents a storage dead marker.\n     pub fn is_storage_dead_marker(&self) -> bool {\n         match *self {\n             PlaceContext::StorageDead => true,\n             _ => false,\n         }\n     }\n \n-    /// Returns true if this lvalue context represents a use that potentially changes the value.\n+    /// Returns true if this place context represents a use that potentially changes the value.\n     pub fn is_mutating_use(&self) -> bool {\n         match *self {\n             PlaceContext::Store | PlaceContext::Call |\n@@ -924,7 +924,7 @@ impl<'tcx> PlaceContext<'tcx> {\n         }\n     }\n \n-    /// Returns true if this lvalue context represents a use that does not change the value.\n+    /// Returns true if this place context represents a use that does not change the value.\n     pub fn is_nonmutating_use(&self) -> bool {\n         match *self {\n             PlaceContext::Inspect | PlaceContext::Borrow { kind: BorrowKind::Shared, .. } |"}, {"sha": "63b4175ce449f8278b1be4849665063e610939d7", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 207, "deletions": 207, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -247,17 +247,17 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 // NOTE: NLL RFC calls for *shallow* write; using Deep\n                 // for short-term compat w/ AST-borrowck. Also, switch\n                 // to shallow requires to dataflow: \"if this is an\n-                // assignment `lv = <rvalue>`, then any loan for some\n-                // path P of which `lv` is a prefix is killed.\"\n-                self.mutate_lvalue(ContextKind::AssignLhs.new(location),\n+                // assignment `place = <rvalue>`, then any loan for some\n+                // path P of which `place` is a prefix is killed.\"\n+                self.mutate_place(ContextKind::AssignLhs.new(location),\n                                    (lhs, span), Deep, JustWrite, flow_state);\n \n                 self.consume_rvalue(ContextKind::AssignRhs.new(location),\n                                     (rhs, span), location, flow_state);\n             }\n-            StatementKind::SetDiscriminant { ref lvalue, variant_index: _ } => {\n-                self.mutate_lvalue(ContextKind::SetDiscrim.new(location),\n-                                   (lvalue, span),\n+            StatementKind::SetDiscriminant { ref place, variant_index: _ } => {\n+                self.mutate_place(ContextKind::SetDiscrim.new(location),\n+                                   (place, span),\n                                    Shallow(Some(ArtificialField::Discriminant)),\n                                    JustWrite,\n                                    flow_state);\n@@ -267,16 +267,16 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 for (o, output) in asm.outputs.iter().zip(outputs) {\n                     if o.is_indirect {\n                         // FIXME(eddyb) indirect inline asm outputs should\n-                        // be encoeded through MIR lvalue derefs instead.\n-                        self.access_lvalue(context,\n+                        // be encoeded through MIR place derefs instead.\n+                        self.access_place(context,\n                                            (output, span),\n                                            (Deep, Read(ReadKind::Copy)),\n                                            LocalMutationIsAllowed::No,\n                                            flow_state);\n                         self.check_if_path_is_moved(context, InitializationRequiringAction::Use,\n                                                     (output, span), flow_state);\n                     } else {\n-                        self.mutate_lvalue(context,\n+                        self.mutate_place(context,\n                                            (output, span),\n                                            Deep,\n                                            if o.is_rw { WriteAndRead } else { JustWrite },\n@@ -299,7 +299,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n             }\n \n             StatementKind::StorageDead(local) => {\n-                self.access_lvalue(ContextKind::StorageDead.new(location),\n+                self.access_place(ContextKind::StorageDead.new(location),\n                     (&Place::Local(local), span),\n                     (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n@@ -321,19 +321,19 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 self.consume_operand(ContextKind::SwitchInt.new(loc),\n                                      (discr, span), flow_state);\n             }\n-            TerminatorKind::Drop { location: ref drop_lvalue, target: _, unwind: _ } => {\n-                self.access_lvalue(ContextKind::Drop.new(loc),\n-                                   (drop_lvalue, span),\n+            TerminatorKind::Drop { location: ref drop_place, target: _, unwind: _ } => {\n+                self.access_place(ContextKind::Drop.new(loc),\n+                                   (drop_place, span),\n                                    (Deep, Write(WriteKind::StorageDeadOrDrop)),\n                                    LocalMutationIsAllowed::Yes,\n                                    flow_state);\n             }\n-            TerminatorKind::DropAndReplace { location: ref drop_lvalue,\n+            TerminatorKind::DropAndReplace { location: ref drop_place,\n                                              value: ref new_value,\n                                              target: _,\n                                              unwind: _ } => {\n-                self.mutate_lvalue(ContextKind::DropAndReplace.new(loc),\n-                                   (drop_lvalue, span),\n+                self.mutate_place(ContextKind::DropAndReplace.new(loc),\n+                                   (drop_place, span),\n                                    Deep,\n                                    JustWrite,\n                                    flow_state);\n@@ -348,7 +348,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                                          (arg, span), flow_state);\n                 }\n                 if let Some((ref dest, _/*bb*/)) = *destination {\n-                    self.mutate_lvalue(ContextKind::CallDest.new(loc),\n+                    self.mutate_place(ContextKind::CallDest.new(loc),\n                                        (dest, span),\n                                        Deep,\n                                        JustWrite,\n@@ -385,24 +385,24 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 // so this \"extra check\" serves as a kind of backup.\n                 let domain = flow_state.borrows.base_results.operator();\n                 for borrow in domain.borrows() {\n-                    let root_lvalue = self.prefixes(\n-                        &borrow.lvalue,\n+                    let root_place = self.prefixes(\n+                        &borrow.place,\n                         PrefixSet::All\n                     ).last().unwrap();\n-                    match root_lvalue {\n+                    match root_place {\n                         Place::Static(_) => {\n-                            self.access_lvalue(\n+                            self.access_place(\n                                 ContextKind::StorageDead.new(loc),\n-                                (&root_lvalue, self.mir.source_info(borrow.location).span),\n+                                (&root_place, self.mir.source_info(borrow.location).span),\n                                 (Deep, Write(WriteKind::StorageDeadOrDrop)),\n                                 LocalMutationIsAllowed::Yes,\n                                 flow_state\n                             );\n                         }\n                         Place::Local(_) => {\n-                            self.access_lvalue(\n+                            self.access_place(\n                                 ContextKind::StorageDead.new(loc),\n-                                (&root_lvalue, self.mir.source_info(borrow.location).span),\n+                                (&root_place, self.mir.source_info(borrow.location).span),\n                                 (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n                                 LocalMutationIsAllowed::Yes,\n                                 flow_state\n@@ -446,7 +446,7 @@ enum ShallowOrDeep {\n     Shallow(Option<ArtificialField>),\n \n     /// From the RFC: \"A *deep* access means that all data reachable\n-    /// through the given lvalue may be invalidated or accesses by\n+    /// through the given place may be invalidated or accesses by\n     /// this action.\"\n     Deep,\n }\n@@ -483,8 +483,8 @@ enum WriteKind {\n     Move,\n }\n \n-/// When checking permissions for an lvalue access, this flag is used to indicate that an immutable\n-/// local lvalue can be mutated.\n+/// When checking permissions for a place access, this flag is used to indicate that an immutable\n+/// local place can be mutated.\n ///\n /// FIXME: @nikomatsakis suggested that this flag could be removed with the following modifications:\n /// - Merge `check_access_permissions()` and `check_if_reassignment_to_immutable_state()`\n@@ -526,21 +526,21 @@ impl InitializationRequiringAction {\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-    /// Checks an access to the given lvalue to see if it is allowed. Examines the set of borrows\n+    /// Checks an access to the given place to see if it is allowed. Examines the set of borrows\n     /// that are in scope, as well as which paths have been initialized, to ensure that (a) the\n-    /// lvalue is initialized and (b) it is not borrowed in some way that would prevent this\n+    /// place is initialized and (b) it is not borrowed in some way that would prevent this\n     /// access.\n     ///\n     /// Returns true if an error is reported, false otherwise.\n-    fn access_lvalue(&mut self,\n+    fn access_place(&mut self,\n                      context: Context,\n-                     lvalue_span: (&Place<'tcx>, Span),\n+                     place_span: (&Place<'tcx>, Span),\n                      kind: (ShallowOrDeep, ReadOrWrite),\n                      is_local_mutation_allowed: LocalMutationIsAllowed,\n                      flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         let (sd, rw) = kind;\n \n-        let storage_dead_or_drop_local = match (lvalue_span.0, rw) {\n+        let storage_dead_or_drop_local = match (place_span.0, rw) {\n             (&Place::Local(local), Write(WriteKind::StorageDeadOrDrop)) => Some(local),\n             _ => None\n         };\n@@ -553,12 +553,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         // Check permissions\n-        let mut error_reported = self.check_access_permissions(lvalue_span,\n+        let mut error_reported = self.check_access_permissions(place_span,\n                                                                rw,\n                                                                is_local_mutation_allowed);\n \n         self.each_borrow_involving_path(\n-            context, (sd, lvalue_span.0), flow_state, |this, _index, borrow, common_prefix| {\n+            context, (sd, place_span.0), flow_state, |this, _index, borrow, common_prefix| {\n                 match (rw, borrow.kind) {\n                     (Read(_), BorrowKind::Shared) => {\n                         Control::Continue\n@@ -569,15 +569,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             ReadKind::Copy => {\n                                 error_reported = true;\n                                 this.report_use_while_mutably_borrowed(\n-                                    context, lvalue_span, borrow)\n+                                    context, place_span, borrow)\n                             },\n                             ReadKind::Borrow(bk) => {\n                                 let end_issued_loan_span =\n                                     flow_state.borrows.base_results.operator().opt_region_end_span(\n                                         &borrow.region);\n                                 error_reported = true;\n                                 this.report_conflicting_borrow(\n-                                    context, common_prefix, lvalue_span, bk,\n+                                    context, common_prefix, place_span, bk,\n                                     &borrow, end_issued_loan_span)\n                             }\n                         }\n@@ -591,7 +591,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                         &borrow.region);\n                                 error_reported = true;\n                                 this.report_conflicting_borrow(\n-                                    context, common_prefix, lvalue_span, bk,\n+                                    context, common_prefix, place_span, bk,\n                                     &borrow, end_issued_loan_span)\n                             }\n                              WriteKind::StorageDeadOrDrop => {\n@@ -600,17 +600,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                         &borrow.region);\n                                 error_reported = true;\n                                 this.report_borrowed_value_does_not_live_long_enough(\n-                                    context, lvalue_span, end_span)\n+                                    context, place_span, end_span)\n                             },\n                             WriteKind::Mutate => {\n                                 error_reported = true;\n                                 this.report_illegal_mutation_of_borrowed(\n-                                    context, lvalue_span, borrow)\n+                                    context, place_span, borrow)\n                             },\n                             WriteKind::Move => {\n                                 error_reported = true;\n                                 this.report_move_out_while_borrowed(\n-                                    context, lvalue_span, &borrow)\n+                                    context, place_span, &borrow)\n                             },\n                         }\n                         Control::Break\n@@ -625,31 +625,31 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn mutate_lvalue(&mut self,\n+    fn mutate_place(&mut self,\n                      context: Context,\n-                     lvalue_span: (&Place<'tcx>, Span),\n+                     place_span: (&Place<'tcx>, Span),\n                      kind: ShallowOrDeep,\n                      mode: MutateMode,\n                      flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         // Write of P[i] or *P, or WriteAndRead of any P, requires P init'd.\n         match mode {\n             MutateMode::WriteAndRead => {\n                 self.check_if_path_is_moved(context, InitializationRequiringAction::Update,\n-                                            lvalue_span, flow_state);\n+                                            place_span, flow_state);\n             }\n             MutateMode::JustWrite => {\n-                self.check_if_assigned_path_is_moved(context, lvalue_span, flow_state);\n+                self.check_if_assigned_path_is_moved(context, place_span, flow_state);\n             }\n         }\n \n-        self.access_lvalue(context,\n-                           lvalue_span,\n+        self.access_place(context,\n+                           place_span,\n                            (kind, Write(WriteKind::Mutate)),\n                            LocalMutationIsAllowed::Yes,\n                            flow_state);\n \n         // check for reassignments to immutable local variables\n-        self.check_if_reassignment_to_immutable_state(context, lvalue_span, flow_state);\n+        self.check_if_reassignment_to_immutable_state(context, place_span, flow_state);\n     }\n \n     fn consume_rvalue(&mut self,\n@@ -658,19 +658,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                       _location: Location,\n                       flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         match *rvalue {\n-            Rvalue::Ref(_/*rgn*/, bk, ref lvalue) => {\n+            Rvalue::Ref(_/*rgn*/, bk, ref place) => {\n                 let access_kind = match bk {\n                     BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),\n                     BorrowKind::Unique |\n                     BorrowKind::Mut => (Deep, Write(WriteKind::MutableBorrow(bk))),\n                 };\n-                self.access_lvalue(context,\n-                                   (lvalue, span),\n+                self.access_place(context,\n+                                   (place, span),\n                                    access_kind,\n                                    LocalMutationIsAllowed::No,\n                                    flow_state);\n                 self.check_if_path_is_moved(context, InitializationRequiringAction::Borrow,\n-                                            (lvalue, span), flow_state);\n+                                            (place, span), flow_state);\n             }\n \n             Rvalue::Use(ref operand) |\n@@ -680,20 +680,20 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 self.consume_operand(context, (operand, span), flow_state)\n             }\n \n-            Rvalue::Len(ref lvalue) |\n-            Rvalue::Discriminant(ref lvalue) => {\n+            Rvalue::Len(ref place) |\n+            Rvalue::Discriminant(ref place) => {\n                 let af = match *rvalue {\n                     Rvalue::Len(..) => ArtificialField::ArrayLength,\n                     Rvalue::Discriminant(..) => ArtificialField::Discriminant,\n                     _ => unreachable!(),\n                 };\n-                self.access_lvalue(context,\n-                                   (lvalue, span),\n+                self.access_place(context,\n+                                   (place, span),\n                                    (Shallow(Some(af)), Read(ReadKind::Copy)),\n                                    LocalMutationIsAllowed::No,\n                                    flow_state);\n                 self.check_if_path_is_moved(context, InitializationRequiringAction::Use,\n-                                            (lvalue, span), flow_state);\n+                                            (place, span), flow_state);\n             }\n \n             Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2) |\n@@ -723,30 +723,30 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                        (operand, span): (&Operand<'tcx>, Span),\n                        flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         match *operand {\n-            Operand::Copy(ref lvalue) => {\n-                // copy of lvalue: check if this is \"copy of frozen path\"\n+            Operand::Copy(ref place) => {\n+                // copy of place: check if this is \"copy of frozen path\"\n                 // (FIXME: see check_loans.rs)\n-                self.access_lvalue(context,\n-                                   (lvalue, span),\n+                self.access_place(context,\n+                                   (place, span),\n                                    (Deep, Read(ReadKind::Copy)),\n                                    LocalMutationIsAllowed::No,\n                                    flow_state);\n \n                 // Finally, check if path was already moved.\n                 self.check_if_path_is_moved(context, InitializationRequiringAction::Use,\n-                                            (lvalue, span), flow_state);\n+                                            (place, span), flow_state);\n             }\n-            Operand::Move(ref lvalue) => {\n-                // move of lvalue: check if this is move of already borrowed path\n-                self.access_lvalue(context,\n-                                   (lvalue, span),\n+            Operand::Move(ref place) => {\n+                // move of place: check if this is move of already borrowed path\n+                self.access_place(context,\n+                                   (place, span),\n                                    (Deep, Write(WriteKind::Move)),\n                                    LocalMutationIsAllowed::Yes,\n                                    flow_state);\n \n                 // Finally, check if path was already moved.\n                 self.check_if_path_is_moved(context, InitializationRequiringAction::Use,\n-                                            (lvalue, span), flow_state);\n+                                            (place, span), flow_state);\n             }\n             Operand::Constant(_) => {}\n         }\n@@ -756,32 +756,32 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn check_if_reassignment_to_immutable_state(&mut self,\n                                                 context: Context,\n-                                                (lvalue, span): (&Place<'tcx>, Span),\n+                                                (place, span): (&Place<'tcx>, Span),\n                                                 flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         let move_data = self.move_data;\n \n         // determine if this path has a non-mut owner (and thus needs checking).\n-        if let Ok(()) = self.is_mutable(lvalue, LocalMutationIsAllowed::No) {\n+        if let Ok(()) = self.is_mutable(place, LocalMutationIsAllowed::No) {\n             return;\n         }\n \n-        if let Err(_) = self.is_mutable(lvalue, LocalMutationIsAllowed::Yes) {\n+        if let Err(_) = self.is_mutable(place, LocalMutationIsAllowed::Yes) {\n             return;\n         }\n \n-        match self.move_path_closest_to(lvalue) {\n+        match self.move_path_closest_to(place) {\n             Ok(mpi) => {\n                 for ii in &move_data.init_path_map[mpi] {\n                     if flow_state.ever_inits.curr_state.contains(ii) {\n                         let first_assign_span = self.move_data.inits[*ii].span;\n                         self.report_illegal_reassignment(\n-                            context, (lvalue, span), first_assign_span);\n+                            context, (place, span), first_assign_span);\n                         break;\n                     }\n                 }\n             },\n             Err(NoMovePathFound::ReachedStatic) => {\n-                let item_msg = match self.describe_lvalue(lvalue) {\n+                let item_msg = match self.describe_place(place) {\n                     Some(name) => format!(\"immutable static item `{}`\", name),\n                     None => \"immutable static item\".to_owned()\n                 };\n@@ -795,11 +795,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn check_if_path_is_moved(&mut self,\n                               context: Context,\n                               desired_action: InitializationRequiringAction,\n-                              lvalue_span: (&Place<'tcx>, Span),\n+                              place_span: (&Place<'tcx>, Span),\n                               flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n-        // FIXME: analogous code in check_loans first maps `lvalue` to\n+        // FIXME: analogous code in check_loans first maps `place` to\n         // its base_path ... but is that what we want here?\n-        let lvalue = self.base_path(lvalue_span.0);\n+        let place = self.base_path(place_span.0);\n \n         let maybe_uninits = &flow_state.uninits;\n         let curr_move_outs = &flow_state.move_outs.curr_state;\n@@ -836,16 +836,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         // Therefore, if we seek out the *closest* prefix for which we\n         // have a MovePath, that should capture the initialization\n-        // state for the lvalue scenario.\n+        // state for the place scenario.\n         //\n         // This code covers scenarios 1, 2, and 4.\n \n-        debug!(\"check_if_path_is_moved part1 lvalue: {:?}\", lvalue);\n-        match self.move_path_closest_to(lvalue) {\n+        debug!(\"check_if_path_is_moved part1 place: {:?}\", place);\n+        match self.move_path_closest_to(place) {\n             Ok(mpi) => {\n                 if maybe_uninits.curr_state.contains(&mpi) {\n                     self.report_use_of_moved_or_uninitialized(context, desired_action,\n-                                                              lvalue_span, mpi,\n+                                                              place_span, mpi,\n                                                               curr_move_outs);\n                     return; // don't bother finding other problems.\n                 }\n@@ -862,40 +862,40 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             // to do such a query based on partial-init feature-gate.)\n         }\n \n-        // A move of any shallow suffix of `lvalue` also interferes\n-        // with an attempt to use `lvalue`. This is scenario 3 above.\n+        // A move of any shallow suffix of `place` also interferes\n+        // with an attempt to use `place`. This is scenario 3 above.\n         //\n         // (Distinct from handling of scenarios 1+2+4 above because\n-        // `lvalue` does not interfere with suffixes of its prefixes,\n+        // `place` does not interfere with suffixes of its prefixes,\n         // e.g. `a.b.c` does not interfere with `a.b.d`)\n \n-        debug!(\"check_if_path_is_moved part2 lvalue: {:?}\", lvalue);\n-        if let Some(mpi) = self.move_path_for_lvalue(lvalue) {\n+        debug!(\"check_if_path_is_moved part2 place: {:?}\", place);\n+        if let Some(mpi) = self.move_path_for_place(place) {\n             if let Some(child_mpi) = maybe_uninits.has_any_child_of(mpi) {\n                 self.report_use_of_moved_or_uninitialized(context, desired_action,\n-                                                          lvalue_span, child_mpi,\n+                                                          place_span, child_mpi,\n                                                           curr_move_outs);\n                 return; // don't bother finding other problems.\n             }\n         }\n     }\n \n-    /// Currently MoveData does not store entries for all lvalues in\n+    /// Currently MoveData does not store entries for all places in\n     /// the input MIR. For example it will currently filter out\n-    /// lvalues that are Copy; thus we do not track lvalues of shared\n-    /// reference type. This routine will walk up an lvalue along its\n-    /// prefixes, searching for a foundational lvalue that *is*\n+    /// places that are Copy; thus we do not track places of shared\n+    /// reference type. This routine will walk up a place along its\n+    /// prefixes, searching for a foundational place that *is*\n     /// tracked in the MoveData.\n     ///\n     /// An Err result includes a tag indicated why the search failed.\n-    /// Currenly this can only occur if the lvalue is built off of a\n+    /// Currenly this can only occur if the place is built off of a\n     /// static variable, as we do not track those in the MoveData.\n-    fn move_path_closest_to(&mut self, lvalue: &Place<'tcx>)\n+    fn move_path_closest_to(&mut self, place: &Place<'tcx>)\n                             -> Result<MovePathIndex, NoMovePathFound>\n     {\n-        let mut last_prefix = lvalue;\n-        for prefix in self.prefixes(lvalue, PrefixSet::All) {\n-            if let Some(mpi) = self.move_path_for_lvalue(prefix) {\n+        let mut last_prefix = place;\n+        for prefix in self.prefixes(place, PrefixSet::All) {\n+            if let Some(mpi) = self.move_path_for_place(prefix) {\n                 return Ok(mpi);\n             }\n             last_prefix = prefix;\n@@ -907,28 +907,28 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn move_path_for_lvalue(&mut self,\n-                            lvalue: &Place<'tcx>)\n+    fn move_path_for_place(&mut self,\n+                            place: &Place<'tcx>)\n                             -> Option<MovePathIndex>\n     {\n         // If returns None, then there is no move path corresponding\n-        // to a direct owner of `lvalue` (which means there is nothing\n+        // to a direct owner of `place` (which means there is nothing\n         // that borrowck tracks for its analysis).\n \n-        match self.move_data.rev_lookup.find(lvalue) {\n+        match self.move_data.rev_lookup.find(place) {\n             LookupResult::Parent(_) => None,\n             LookupResult::Exact(mpi) => Some(mpi),\n         }\n     }\n \n     fn check_if_assigned_path_is_moved(&mut self,\n                                        context: Context,\n-                                       (lvalue, span): (&Place<'tcx>, Span),\n+                                       (place, span): (&Place<'tcx>, Span),\n                                        flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n-        // recur down lvalue; dispatch to check_if_path_is_moved when necessary\n-        let mut lvalue = lvalue;\n+        // recur down place; dispatch to check_if_path_is_moved when necessary\n+        let mut place = place;\n         loop {\n-            match *lvalue {\n+            match *place {\n                 Place::Local(_) | Place::Static(_) => {\n                     // assigning to `x` does not require `x` be initialized.\n                     break;\n@@ -977,35 +977,35 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         }\n                     }\n \n-                    lvalue = base;\n+                    place = base;\n                     continue;\n                 }\n             }\n         }\n     }\n \n-    /// Check the permissions for the given lvalue and read or write kind\n+    /// Check the permissions for the given place and read or write kind\n     ///\n     /// Returns true if an error is reported, false otherwise.\n     fn check_access_permissions(&self,\n-                                (lvalue, span): (&Place<'tcx>, Span),\n+                                (place, span): (&Place<'tcx>, Span),\n                                 kind: ReadOrWrite,\n                                 is_local_mutation_allowed: LocalMutationIsAllowed)\n                                 -> bool {\n         debug!(\"check_access_permissions({:?}, {:?}, {:?})\",\n-               lvalue, kind, is_local_mutation_allowed);\n+               place, kind, is_local_mutation_allowed);\n         let mut error_reported = false;\n         match kind {\n             Write(WriteKind::MutableBorrow(BorrowKind::Unique)) => {\n-                if let Err(_lvalue_err) = self.is_unique(lvalue) {\n-                    span_bug!(span, \"&unique borrow for {:?} should not fail\", lvalue);\n+                if let Err(_place_err) = self.is_unique(place) {\n+                    span_bug!(span, \"&unique borrow for {:?} should not fail\", place);\n                 }\n             },\n             Write(WriteKind::MutableBorrow(BorrowKind::Mut)) => {\n-                if let Err(lvalue_err) = self.is_mutable(lvalue, is_local_mutation_allowed) {\n+                if let Err(place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n                     error_reported = true;\n \n-                    let item_msg = match self.describe_lvalue(lvalue) {\n+                    let item_msg = match self.describe_place(place) {\n                         Some(name) => format!(\"immutable item `{}`\", name),\n                         None => \"immutable item\".to_owned()\n                     };\n@@ -1015,8 +1015,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         Origin::Mir);\n                     err.span_label(span, \"cannot borrow as mutable\");\n \n-                    if lvalue != lvalue_err {\n-                        if let Some(name) = self.describe_lvalue(lvalue_err) {\n+                    if place != place_err {\n+                        if let Some(name) = self.describe_place(place_err) {\n                             err.note(&format!(\"Value not mutable causing this error: `{}`\", name));\n                         }\n                     }\n@@ -1025,10 +1025,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n             },\n             Write(WriteKind::Mutate) => {\n-                if let Err(lvalue_err) = self.is_mutable(lvalue, is_local_mutation_allowed) {\n+                if let Err(place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n                     error_reported = true;\n \n-                    let item_msg = match self.describe_lvalue(lvalue) {\n+                    let item_msg = match self.describe_place(place) {\n                         Some(name) => format!(\"immutable item `{}`\", name),\n                         None => \"immutable item\".to_owned()\n                     };\n@@ -1038,8 +1038,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         Origin::Mir);\n                     err.span_label(span, \"cannot mutate\");\n \n-                    if lvalue != lvalue_err {\n-                        if let Some(name) = self.describe_lvalue(lvalue_err) {\n+                    if place != place_err {\n+                        if let Some(name) = self.describe_place(place_err) {\n                             err.note(&format!(\"Value not mutable causing this error: `{}`\", name));\n                         }\n                     }\n@@ -1050,10 +1050,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Write(WriteKind::Move) |\n             Write(WriteKind::StorageDeadOrDrop) |\n             Write(WriteKind::MutableBorrow(BorrowKind::Shared)) => {\n-                if let Err(_lvalue_err) = self.is_mutable(lvalue, is_local_mutation_allowed) {\n+                if let Err(_place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n                     self.tcx.sess.delay_span_bug(span,\n                         &format!(\"Accessing `{:?}` with the kind `{:?}` shouldn't be possible\",\n-                            lvalue,\n+                            place,\n                             kind));\n                 }\n             },\n@@ -1068,24 +1068,24 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     /// Can this value be written or borrowed mutably\n     fn is_mutable<'d>(&self,\n-                      lvalue: &'d Place<'tcx>,\n+                      place: &'d Place<'tcx>,\n                       is_local_mutation_allowed: LocalMutationIsAllowed)\n                       -> Result<(), &'d Place<'tcx>> {\n-        match *lvalue {\n+        match *place {\n             Place::Local(local) => {\n                 let local = &self.mir.local_decls[local];\n                 match local.mutability {\n                     Mutability::Not =>\n                         match is_local_mutation_allowed {\n                             LocalMutationIsAllowed::Yes => Ok(()),\n-                            LocalMutationIsAllowed::No => Err(lvalue),\n+                            LocalMutationIsAllowed::No => Err(place),\n                         },\n                     Mutability::Mut => Ok(())\n                 }\n             },\n             Place::Static(ref static_) => {\n                 if !self.tcx.is_static_mut(static_.def_id) {\n-                    Err(lvalue)\n+                    Err(place)\n                 } else {\n                     Ok(())\n                 }\n@@ -1100,7 +1100,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             ty::TyRef(_, tnm) => {\n                                 match tnm.mutbl {\n                                     // Shared borrowed data is never mutable\n-                                    hir::MutImmutable => Err(lvalue),\n+                                    hir::MutImmutable => Err(place),\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n@@ -1115,7 +1115,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             ty::TyRawPtr(tnm) => {\n                                 match tnm.mutbl {\n                                     // `*const` raw pointers are not mutable\n-                                    hir::MutImmutable => Err(lvalue),\n+                                    hir::MutImmutable => Err(place),\n                                     // `*mut` raw pointers are always mutable, regardless of context\n                                     // The users have to check by themselve.\n                                     hir::MutMutable => Ok(()),\n@@ -1135,14 +1135,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     ProjectionElem::ConstantIndex{..} |\n                     ProjectionElem::Subslice{..} |\n                     ProjectionElem::Downcast(..) => {\n-                        let field_projection = self.is_upvar_field_projection(lvalue);\n+                        let field_projection = self.is_upvar_field_projection(place);\n \n                         if let Some(field) = field_projection {\n                             let decl = &self.mir.upvar_decls[field.index()];\n \n                             return match decl.mutability {\n                                 Mutability::Mut => self.is_unique(&proj.base),\n-                                Mutability::Not => Err(lvalue),\n+                                Mutability::Not => Err(place),\n                             };\n                         }\n \n@@ -1153,16 +1153,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Does this lvalue have a unique path\n-    fn is_unique<'d>(&self, lvalue: &'d Place<'tcx>) -> Result<(), &'d Place<'tcx>> {\n-        match *lvalue {\n+    /// Does this place have a unique path\n+    fn is_unique<'d>(&self, place: &'d Place<'tcx>) -> Result<(), &'d Place<'tcx>> {\n+        match *place {\n             Place::Local(..) => {\n                 // Local variables are unique\n                 Ok(())\n             },\n             Place::Static(..) => {\n                 // Static variables are not\n-                Err(lvalue)\n+                Err(place)\n             },\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n@@ -1178,8 +1178,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         match base_ty.sty {\n                             ty::TyRef(_, tnm) => {\n                                 match tnm.mutbl {\n-                                    // lvalue represent an aliased location\n-                                    hir::MutImmutable => Err(lvalue),\n+                                    // place represent an aliased location\n+                                    hir::MutImmutable => Err(place),\n                                     // `&mut T` is as unique as the context in which it is found\n                                     hir::MutMutable => self.is_unique(&proj.base),\n                                 }\n@@ -1217,14 +1217,14 @@ enum NoMovePathFound {\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn each_borrow_involving_path<F>(&mut self,\n                                      _context: Context,\n-                                     access_lvalue: (ShallowOrDeep, &Place<'tcx>),\n+                                     access_place: (ShallowOrDeep, &Place<'tcx>),\n                                      flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n                                      mut op: F)\n         where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>, &Place<'tcx>) -> Control\n     {\n-        let (access, lvalue) = access_lvalue;\n+        let (access, place) = access_place;\n \n-        // FIXME: analogous code in check_loans first maps `lvalue` to\n+        // FIXME: analogous code in check_loans first maps `place` to\n         // its base_path.\n \n         let domain = flow_state.borrows.base_results.operator();\n@@ -1235,21 +1235,21 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         'next_borrow: for i in flow_state.borrows.elems_incoming() {\n             let borrowed = &data[i];\n \n-            // Is `lvalue` (or a prefix of it) already borrowed? If\n+            // Is `place` (or a prefix of it) already borrowed? If\n             // so, that's relevant.\n             //\n             // FIXME: Differs from AST-borrowck; includes drive-by fix\n             // to #38899. Will probably need back-compat mode flag.\n-            for accessed_prefix in self.prefixes(lvalue, PrefixSet::All) {\n-                if *accessed_prefix == borrowed.lvalue {\n+            for accessed_prefix in self.prefixes(place, PrefixSet::All) {\n+                if *accessed_prefix == borrowed.place {\n                     // FIXME: pass in enum describing case we are in?\n                     let ctrl = op(self, i, borrowed, accessed_prefix);\n                     if ctrl == Control::Break { return; }\n                 }\n             }\n \n-            // Is `lvalue` a prefix (modulo access type) of the\n-            // `borrowed.lvalue`? If so, that's relevant.\n+            // Is `place` a prefix (modulo access type) of the\n+            // `borrowed.place`? If so, that's relevant.\n \n             let prefix_kind = match access {\n                 Shallow(Some(ArtificialField::Discriminant)) |\n@@ -1258,16 +1258,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     // additional fields on the type; they do not\n                     // overlap any existing data there. Furthermore,\n                     // they cannot actually be a prefix of any\n-                    // borrowed lvalue (at least in MIR as it is\n+                    // borrowed place (at least in MIR as it is\n                     // currently.)\n                     continue 'next_borrow;\n                 }\n                 Shallow(None) => PrefixSet::Shallow,\n                 Deep => PrefixSet::Supporting,\n             };\n \n-            for borrowed_prefix in self.prefixes(&borrowed.lvalue, prefix_kind) {\n-                if borrowed_prefix == lvalue {\n+            for borrowed_prefix in self.prefixes(&borrowed.place, prefix_kind) {\n+                if borrowed_prefix == place {\n                     // FIXME: pass in enum describing case we are in?\n                     let ctrl = op(self, i, borrowed, borrowed_prefix);\n                     if ctrl == Control::Break { return; }\n@@ -1280,7 +1280,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n use self::prefixes::PrefixSet;\n \n /// From the NLL RFC: \"The deep [aka 'supporting'] prefixes for an\n-/// lvalue are formed by stripping away fields and derefs, except that\n+/// place are formed by stripping away fields and derefs, except that\n /// we stop when we reach the deref of a shared reference. [...] \"\n ///\n /// \"Shallow prefixes are found by stripping away fields, but stop at\n@@ -1337,15 +1337,15 @@ mod prefixes {\n     }\n \n     impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-        /// Returns an iterator over the prefixes of `lvalue`\n+        /// Returns an iterator over the prefixes of `place`\n         /// (inclusive) from longest to smallest, potentially\n         /// terminating the iteration early based on `kind`.\n         pub(super) fn prefixes(&self,\n-                               lvalue: &'cx Place<'tcx>,\n+                               place: &'cx Place<'tcx>,\n                                kind: PrefixSet)\n                                -> Prefixes<'cx, 'gcx, 'tcx>\n         {\n-            Prefixes { next: Some(lvalue), kind, mir: self.mir, tcx: self.tcx }\n+            Prefixes { next: Some(place), kind, mir: self.mir, tcx: self.tcx }\n         }\n     }\n \n@@ -1354,11 +1354,11 @@ mod prefixes {\n         fn next(&mut self) -> Option<Self::Item> {\n             let mut cursor = match self.next {\n                 None => return None,\n-                Some(lvalue) => lvalue,\n+                Some(place) => place,\n             };\n \n-            // Post-processing `lvalue`: Enqueue any remaining\n-            // work. Also, `lvalue` may not be a prefix itself, but\n+            // Post-processing `place`: Enqueue any remaining\n+            // work. Also, `place` may not be a prefix itself, but\n             // may hold one further down (e.g. we never return\n             // downcasts here, but may return a base of a downcast).\n \n@@ -1447,21 +1447,21 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn report_use_of_moved_or_uninitialized(&mut self,\n                            _context: Context,\n                            desired_action: InitializationRequiringAction,\n-                           (lvalue, span): (&Place<'tcx>, Span),\n+                           (place, span): (&Place<'tcx>, Span),\n                            mpi: MovePathIndex,\n                            curr_move_out: &IdxSetBuf<MoveOutIndex>) {\n \n         let mois = self.move_data.path_map[mpi].iter().filter(\n             |moi| curr_move_out.contains(moi)).collect::<Vec<_>>();\n \n         if mois.is_empty() {\n-            let item_msg = match self.describe_lvalue(lvalue) {\n+            let item_msg = match self.describe_place(place) {\n                 Some(name) => format!(\"`{}`\", name),\n                 None => \"value\".to_owned()\n             };\n             self.tcx.cannot_act_on_uninitialized_variable(span,\n                                                           desired_action.as_noun(),\n-                                                          &self.describe_lvalue(lvalue)\n+                                                          &self.describe_place(place)\n                                                             .unwrap_or(\"_\".to_owned()),\n                                                           Origin::Mir)\n                     .span_label(span, format!(\"use of possibly uninitialized {}\", item_msg))\n@@ -1472,7 +1472,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let mut err = self.tcx.cannot_act_on_moved_value(span,\n                                                              desired_action.as_noun(),\n                                                              msg,\n-                                                             &self.describe_lvalue(lvalue)\n+                                                             &self.describe_place(place)\n                                                                 .unwrap_or(\"_\".to_owned()),\n                                                              Origin::Mir);\n \n@@ -1496,18 +1496,18 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn report_move_out_while_borrowed(&mut self,\n                                       _context: Context,\n-                                      (lvalue, span): (&Place<'tcx>, Span),\n+                                      (place, span): (&Place<'tcx>, Span),\n                                       borrow: &BorrowData<'tcx>) {\n-        let value_msg = match self.describe_lvalue(lvalue) {\n+        let value_msg = match self.describe_place(place) {\n             Some(name) => format!(\"`{}`\", name),\n             None => \"value\".to_owned()\n         };\n-        let borrow_msg = match self.describe_lvalue(&borrow.lvalue) {\n+        let borrow_msg = match self.describe_place(&borrow.place) {\n             Some(name) => format!(\"`{}`\", name),\n             None => \"value\".to_owned()\n         };\n         self.tcx.cannot_move_when_borrowed(span,\n-                                           &self.describe_lvalue(lvalue).unwrap_or(\"_\".to_owned()),\n+                                           &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n                                            Origin::Mir)\n                 .span_label(self.retrieve_borrow_span(borrow),\n                             format!(\"borrow of {} occurs here\", borrow_msg))\n@@ -1517,14 +1517,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn report_use_while_mutably_borrowed(&mut self,\n                                          _context: Context,\n-                                         (lvalue, span): (&Place<'tcx>, Span),\n+                                         (place, span): (&Place<'tcx>, Span),\n                                          borrow : &BorrowData<'tcx>) {\n \n         let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n             span,\n-            &self.describe_lvalue(lvalue).unwrap_or(\"_\".to_owned()),\n+            &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n             self.retrieve_borrow_span(borrow),\n-            &self.describe_lvalue(&borrow.lvalue).unwrap_or(\"_\".to_owned()),\n+            &self.describe_place(&borrow.place).unwrap_or(\"_\".to_owned()),\n             Origin::Mir);\n \n         err.emit();\n@@ -1555,9 +1555,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 break;\n             }\n \n-            if let StatementKind::Assign(_, Rvalue::Aggregate(ref kind, ref lvs)) = stmt.kind {\n+            if let StatementKind::Assign(_, Rvalue::Aggregate(ref kind, ref places)) = stmt.kind {\n                 if let AggregateKind::Closure(def_id, _) = **kind {\n-                    debug!(\"find_closure_span: found closure {:?}\", lvs);\n+                    debug!(\"find_closure_span: found closure {:?}\", places);\n \n                     return if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                         let args_span = if let ExprClosure(_, _, _, span, _) =\n@@ -1569,8 +1569,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         };\n \n                         self.tcx.with_freevars(node_id, |freevars| {\n-                            for (v, lv) in freevars.iter().zip(lvs) {\n-                                match *lv {\n+                            for (v, place) in freevars.iter().zip(places) {\n+                                match *place {\n                                     Operand::Copy(Place::Local(l)) |\n                                     Operand::Move(Place::Local(l)) if local == l => {\n                                         debug!(\n@@ -1597,14 +1597,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn report_conflicting_borrow(&mut self,\n                                  context: Context,\n                                  common_prefix: &Place<'tcx>,\n-                                 (lvalue, span): (&Place<'tcx>, Span),\n+                                 (place, span): (&Place<'tcx>, Span),\n                                  gen_borrow_kind: BorrowKind,\n                                  issued_borrow: &BorrowData,\n                                  end_issued_loan_span: Option<Span>) {\n         use self::prefixes::IsPrefixOf;\n \n-        assert!(common_prefix.is_prefix_of(lvalue));\n-        assert!(common_prefix.is_prefix_of(&issued_borrow.lvalue));\n+        assert!(common_prefix.is_prefix_of(place));\n+        assert!(common_prefix.is_prefix_of(&issued_borrow.place));\n \n         let issued_span = self.retrieve_borrow_span(issued_borrow);\n \n@@ -1613,35 +1613,35 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let old_closure_span = self.find_closure_span(issued_span, issued_borrow.location);\n         let issued_span = old_closure_span.map(|(args, _)| args).unwrap_or(issued_span);\n \n-        let desc_lvalue = self.describe_lvalue(lvalue).unwrap_or(\"_\".to_owned());\n+        let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n \n         // FIXME: supply non-\"\" `opt_via` when appropriate\n         let mut err = match (gen_borrow_kind, \"immutable\", \"mutable\",\n                              issued_borrow.kind, \"immutable\", \"mutable\") {\n             (BorrowKind::Shared, lft, _, BorrowKind::Mut, _, rgt) |\n             (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) =>\n                 self.tcx.cannot_reborrow_already_borrowed(\n-                    span, &desc_lvalue, \"\", lft, issued_span,\n+                    span, &desc_place, \"\", lft, issued_span,\n                     \"it\", rgt, \"\", end_issued_loan_span, Origin::Mir),\n \n             (BorrowKind::Mut, _, _, BorrowKind::Mut, _, _) =>\n                 self.tcx.cannot_mutably_borrow_multiply(\n-                    span, &desc_lvalue, \"\", issued_span,\n+                    span, &desc_place, \"\", issued_span,\n                     \"\", end_issued_loan_span, Origin::Mir),\n \n             (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) =>\n                 self.tcx.cannot_uniquely_borrow_by_two_closures(\n-                    span, &desc_lvalue, issued_span,\n+                    span, &desc_place, issued_span,\n                     end_issued_loan_span, Origin::Mir),\n \n             (BorrowKind::Unique, _, _, _, _, _) =>\n                 self.tcx.cannot_uniquely_borrow_by_one_closure(\n-                    span, &desc_lvalue, \"\",\n+                    span, &desc_place, \"\",\n                     issued_span, \"it\", \"\", end_issued_loan_span, Origin::Mir),\n \n             (_, _, _, BorrowKind::Unique, _, _) =>\n                 self.tcx.cannot_reborrow_already_uniquely_borrowed(\n-                    span, &desc_lvalue, \"it\", \"\",\n+                    span, &desc_place, \"it\", \"\",\n                     issued_span, \"\", end_issued_loan_span, Origin::Mir),\n \n             (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _) =>\n@@ -1651,14 +1651,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if let Some((_, var_span)) = old_closure_span {\n             err.span_label(\n                 var_span,\n-                format!(\"previous borrow occurs due to use of `{}` in closure\", desc_lvalue),\n+                format!(\"previous borrow occurs due to use of `{}` in closure\", desc_place),\n             );\n         }\n \n         if let Some((_, var_span)) = new_closure_span {\n             err.span_label(\n                 var_span,\n-                format!(\"borrow occurs due to use of `{}` in closure\", desc_lvalue),\n+                format!(\"borrow occurs due to use of `{}` in closure\", desc_place),\n             );\n         }\n \n@@ -1667,9 +1667,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn report_borrowed_value_does_not_live_long_enough(&mut self,\n                                                        _: Context,\n-                                                       (lvalue, span): (&Place, Span),\n+                                                       (place, span): (&Place, Span),\n                                                        end_span: Option<Span>) {\n-        let proper_span = match *lvalue {\n+        let proper_span = match *place {\n             Place::Local(local) => self.mir.local_decls[local].source_info.span,\n             _ => span\n         };\n@@ -1688,27 +1688,27 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn report_illegal_mutation_of_borrowed(&mut self,\n                                            _: Context,\n-                                           (lvalue, span): (&Place<'tcx>, Span),\n+                                           (place, span): (&Place<'tcx>, Span),\n                                            loan: &BorrowData) {\n         let mut err = self.tcx.cannot_assign_to_borrowed(\n             span,\n             self.retrieve_borrow_span(loan),\n-            &self.describe_lvalue(lvalue).unwrap_or(\"_\".to_owned()),\n+            &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n             Origin::Mir);\n \n         err.emit();\n     }\n \n     fn report_illegal_reassignment(&mut self,\n                                    _context: Context,\n-                                   (lvalue, span): (&Place<'tcx>, Span),\n+                                   (place, span): (&Place<'tcx>, Span),\n                                    assigned_span: Span) {\n         let mut err = self.tcx.cannot_reassign_immutable(span,\n-                                           &self.describe_lvalue(lvalue).unwrap_or(\"_\".to_owned()),\n+                                           &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n                                            Origin::Mir);\n         err.span_label(span, \"cannot assign twice to immutable variable\");\n         if span != assigned_span {\n-            let value_msg = match self.describe_lvalue(lvalue) {\n+            let value_msg = match self.describe_place(place) {\n                 Some(name) => format!(\"`{}`\", name),\n                 None => \"value\".to_owned()\n             };\n@@ -1719,11 +1719,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-    // End-user visible description of `lvalue` if one can be found. If the\n-    // lvalue is a temporary for instance, None will be returned.\n-    fn describe_lvalue(&self, lvalue: &Place<'tcx>) -> Option<String> {\n+    // End-user visible description of `place` if one can be found. If the\n+    // place is a temporary for instance, None will be returned.\n+    fn describe_place(&self, place: &Place<'tcx>) -> Option<String> {\n         let mut buf = String::new();\n-        match self.append_lvalue_to_string(lvalue, &mut buf, false) {\n+        match self.append_place_to_string(place, &mut buf, false) {\n             Ok(()) => Some(buf),\n             Err(()) => None\n         }\n@@ -1733,8 +1733,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// then returns the index of the field being projected. Note that this closure will always\n     /// be `self` in the current MIR, because that is the only time we directly access the fields\n     /// of a closure type.\n-    fn is_upvar_field_projection(&self, lvalue: &Place<'tcx>) -> Option<Field> {\n-        match *lvalue {\n+    fn is_upvar_field_projection(&self, place: &Place<'tcx>) -> Option<Field> {\n+        match *place {\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Field(field, _ty) => {\n@@ -1754,12 +1754,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    // Appends end-user visible description of `lvalue` to `buf`.\n-    fn append_lvalue_to_string(&self,\n-                               lvalue: &Place<'tcx>,\n+    // Appends end-user visible description of `place` to `buf`.\n+    fn append_place_to_string(&self,\n+                               place: &Place<'tcx>,\n                                buf: &mut String,\n                                mut autoderef: bool) -> Result<(), ()> {\n-        match *lvalue {\n+        match *place {\n             Place::Local(local) => {\n                 self.append_local_to_string(local, buf,)?;\n             }\n@@ -1779,33 +1779,33 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             }\n                         } else {\n                             if autoderef {\n-                                self.append_lvalue_to_string(&proj.base, buf, autoderef)?;\n+                                self.append_place_to_string(&proj.base, buf, autoderef)?;\n                             } else {\n                                 buf.push_str(&\"*\");\n-                                self.append_lvalue_to_string(&proj.base, buf, autoderef)?;\n+                                self.append_place_to_string(&proj.base, buf, autoderef)?;\n                             }\n                         }\n                     },\n                     ProjectionElem::Downcast(..) => {\n-                        self.append_lvalue_to_string(&proj.base, buf, autoderef)?;\n+                        self.append_place_to_string(&proj.base, buf, autoderef)?;\n                     },\n                     ProjectionElem::Field(field, _ty) => {\n                         autoderef = true;\n \n-                        if let Some(field) = self.is_upvar_field_projection(lvalue) {\n+                        if let Some(field) = self.is_upvar_field_projection(place) {\n                             let var_index = field.index();\n                             let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n                             buf.push_str(&name);\n                         } else {\n                             let field_name = self.describe_field(&proj.base, field);\n-                            self.append_lvalue_to_string(&proj.base, buf, autoderef)?;\n+                            self.append_place_to_string(&proj.base, buf, autoderef)?;\n                             buf.push_str(&format!(\".{}\", field_name));\n                         }\n                     },\n                     ProjectionElem::Index(index) => {\n                         autoderef = true;\n \n-                        self.append_lvalue_to_string(&proj.base, buf, autoderef)?;\n+                        self.append_place_to_string(&proj.base, buf, autoderef)?;\n                         buf.push_str(\"[\");\n                         if let Err(_) = self.append_local_to_string(index, buf) {\n                             buf.push_str(\"..\");\n@@ -1817,7 +1817,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         // Since it isn't possible to borrow an element on a particular index and\n                         // then use another while the borrow is held, don't output indices details\n                         // to avoid confusing the end-user\n-                        self.append_lvalue_to_string(&proj.base, buf, autoderef)?;\n+                        self.append_place_to_string(&proj.base, buf, autoderef)?;\n                         buf.push_str(&\"[..]\");\n                     },\n                 };\n@@ -1827,7 +1827,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n-    // Appends end-user visible description of the `local` lvalue to `buf`. If `local` doesn't have\n+    // Appends end-user visible description of the `local` place to `buf`. If `local` doesn't have\n     // a name, then `Err` is returned\n     fn append_local_to_string(&self, local_index: Local, buf: &mut String) -> Result<(), ()> {\n         let local = &self.mir.local_decls[local_index];\n@@ -1923,20 +1923,20 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     // moves out of a Box. They should be removed when/if we stop\n     // treating Box specially (e.g. when/if DerefMove is added...)\n \n-    fn base_path<'d>(&self, lvalue: &'d Place<'tcx>) -> &'d Place<'tcx> {\n+    fn base_path<'d>(&self, place: &'d Place<'tcx>) -> &'d Place<'tcx> {\n         //! Returns the base of the leftmost (deepest) dereference of an\n-        //! Box in `lvalue`. If there is no dereference of an Box\n-        //! in `lvalue`, then it just returns `lvalue` itself.\n+        //! Box in `place`. If there is no dereference of an Box\n+        //! in `place`, then it just returns `place` itself.\n \n-        let mut cursor = lvalue;\n-        let mut deepest = lvalue;\n+        let mut cursor = place;\n+        let mut deepest = place;\n         loop {\n             let proj = match *cursor {\n                 Place::Local(..) | Place::Static(..) => return deepest,\n                 Place::Projection(ref proj) => proj,\n             };\n             if proj.elem == ProjectionElem::Deref &&\n-                lvalue.ty(self.mir, self.tcx).to_ty(self.tcx).is_box()\n+                place.ty(self.mir, self.tcx).to_ty(self.tcx).is_box()\n             {\n                 deepest = &proj.base;\n             }"}, {"sha": "d1bb1f39e221c88b93e82325f3bd5b4855a4871f", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -61,11 +61,11 @@ impl<'tcx> CFG<'tcx> {\n     pub fn push_assign(&mut self,\n                        block: BasicBlock,\n                        source_info: SourceInfo,\n-                       lvalue: &Place<'tcx>,\n+                       place: &Place<'tcx>,\n                        rvalue: Rvalue<'tcx>) {\n         self.push(block, Statement {\n             source_info,\n-            kind: StatementKind::Assign(lvalue.clone(), rvalue)\n+            kind: StatementKind::Assign(place.clone(), rvalue)\n         });\n     }\n \n@@ -81,8 +81,8 @@ impl<'tcx> CFG<'tcx> {\n     pub fn push_assign_unit(&mut self,\n                             block: BasicBlock,\n                             source_info: SourceInfo,\n-                            lvalue: &Place<'tcx>) {\n-        self.push_assign(block, source_info, lvalue, Rvalue::Aggregate(\n+                            place: &Place<'tcx>) {\n+        self.push_assign(block, source_info, place, Rvalue::Aggregate(\n             box AggregateKind::Tuple, vec![]\n         ));\n     }"}, {"sha": "7eae414a391377b682419f36d6b9a45385560a39", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -32,7 +32,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     /// Compile `expr` into a value that can be used as an operand.\n-    /// If `expr` is an lvalue like `x`, this will introduce a\n+    /// If `expr` is a place like `x`, this will introduce a\n     /// temporary `tmp = x`, so that we capture the value of `x` at\n     /// this time.\n     ///"}, {"sha": "9e21790851167c3be29513c493189c969b36f5ef", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "renamed", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -18,47 +18,47 @@ use rustc::mir::*;\n use rustc_data_structures::indexed_vec::Idx;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n-    /// Compile `expr`, yielding an lvalue that we can move from etc.\n-    pub fn as_lvalue<M>(&mut self,\n+    /// Compile `expr`, yielding a place that we can move from etc.\n+    pub fn as_place<M>(&mut self,\n                         block: BasicBlock,\n                         expr: M)\n                         -> BlockAnd<Place<'tcx>>\n         where M: Mirror<'tcx, Output=Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n-        self.expr_as_lvalue(block, expr)\n+        self.expr_as_place(block, expr)\n     }\n \n-    fn expr_as_lvalue(&mut self,\n+    fn expr_as_place(&mut self,\n                       mut block: BasicBlock,\n                       expr: Expr<'tcx>)\n                       -> BlockAnd<Place<'tcx>> {\n-        debug!(\"expr_as_lvalue(block={:?}, expr={:?})\", block, expr);\n+        debug!(\"expr_as_place(block={:?}, expr={:?})\", block, expr);\n \n         let this = self;\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n         match expr.kind {\n             ExprKind::Scope { region_scope, lint_level, value } => {\n                 this.in_scope((region_scope, source_info), lint_level, block, |this| {\n-                    this.as_lvalue(block, value)\n+                    this.as_place(block, value)\n                 })\n             }\n             ExprKind::Field { lhs, name } => {\n-                let lvalue = unpack!(block = this.as_lvalue(block, lhs));\n-                let lvalue = lvalue.field(name, expr.ty);\n-                block.and(lvalue)\n+                let place = unpack!(block = this.as_place(block, lhs));\n+                let place = place.field(name, expr.ty);\n+                block.and(place)\n             }\n             ExprKind::Deref { arg } => {\n-                let lvalue = unpack!(block = this.as_lvalue(block, arg));\n-                let lvalue = lvalue.deref();\n-                block.and(lvalue)\n+                let place = unpack!(block = this.as_place(block, arg));\n+                let place = place.deref();\n+                block.and(place)\n             }\n             ExprKind::Index { lhs, index } => {\n                 let (usize_ty, bool_ty) = (this.hir.usize_ty(), this.hir.bool_ty());\n \n-                let slice = unpack!(block = this.as_lvalue(block, lhs));\n-                // region_scope=None so lvalue indexes live forever. They are scalars so they\n+                let slice = unpack!(block = this.as_place(block, lhs));\n+                // region_scope=None so place indexes live forever. They are scalars so they\n                 // do not need storage annotations, and they are often copied between\n                 // places.\n                 let idx = unpack!(block = this.as_temp(block, None, index));\n@@ -122,7 +122,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::InlineAsm { .. } |\n             ExprKind::Yield { .. } |\n             ExprKind::Call { .. } => {\n-                // these are not lvalues, so we need to make a temporary.\n+                // these are not places, so we need to make a temporary.\n                 debug_assert!(match Category::of(&expr.kind) {\n                     Some(Category::Place) => false,\n                     _ => true,", "previous_filename": "src/librustc_mir/build/expr/as_lvalue.rs"}, {"sha": "88f1fb4f57518a3a3330b686b663bde1a6448408", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -68,8 +68,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.and(Rvalue::Repeat(value_operand, count))\n             }\n             ExprKind::Borrow { region, borrow_kind, arg } => {\n-                let arg_lvalue = unpack!(block = this.as_lvalue(block, arg));\n-                block.and(Rvalue::Ref(region, borrow_kind, arg_lvalue))\n+                let arg_place = unpack!(block = this.as_place(block, arg));\n+                block.and(Rvalue::Ref(region, borrow_kind, arg_place))\n             }\n             ExprKind::Binary { op, lhs, rhs } => {\n                 let lhs = unpack!(block = this.as_operand(block, scope, lhs));\n@@ -229,7 +229,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let field_names = this.hir.all_fields(adt_def, variant_index);\n \n                 let fields = if let Some(FruInfo { base, field_types }) = base {\n-                    let base = unpack!(block = this.as_lvalue(block, base));\n+                    let base = unpack!(block = this.as_place(block, base));\n \n                     // MIR does not natively support FRU, so for each\n                     // base-supplied field, generate an operand that"}, {"sha": "1fc608c52c658a80bde7801c12990e7325350357", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -58,16 +58,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n \n         // Careful here not to cause an infinite cycle. If we always\n-        // called `into`, then for lvalues like `x.f`, it would\n+        // called `into`, then for places like `x.f`, it would\n         // eventually fallback to us, and we'd loop. There's a reason\n         // for this: `as_temp` is the point where we bridge the \"by\n-        // reference\" semantics of `as_lvalue` with the \"by value\"\n+        // reference\" semantics of `as_place` with the \"by value\"\n         // semantics of `into`, `as_operand`, `as_rvalue`, and (of\n         // course) `as_temp`.\n         match Category::of(&expr.kind).unwrap() {\n             Category::Place => {\n-                let lvalue = unpack!(block = this.as_lvalue(block, expr));\n-                let rvalue = Rvalue::Use(this.consume_by_copy_or_move(lvalue));\n+                let place = unpack!(block = this.as_place(block, expr));\n+                let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n                 this.cfg.push_assign(block, source_info, &Place::Local(temp), rvalue);\n             }\n             _ => {"}, {"sha": "025e77343e718b39d65d5897af20019020761f1e", "filename": "src/librustc_mir/build/expr/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -24,13 +24,13 @@\n //! - `as_operand` -- evaluates the value and yields an `Operand`,\n //!   suitable for use as an argument to an `Rvalue`\n //! - `as_temp` -- evaluates into a temporary; this is similar to `as_operand`\n-//!   except it always returns a fresh lvalue, even for constants\n+//!   except it always returns a fresh place, even for constants\n //! - `as_rvalue` -- yields an `Rvalue`, suitable for use in an assignment;\n //!   as of this writing, never needed outside of the `expr` module itself\n //!\n //! Sometimes though want the expression's *location*. An example\n //! would be during a match statement, or the operand of the `&`\n-//! operator. In that case, you want `as_lvalue`. This will create a\n+//! operator. In that case, you want `as_place`. This will create a\n //! temporary if necessary.\n //!\n //! Finally, if it's a constant you seek, then call\n@@ -46,20 +46,20 @@\n //! struct expression (or other expression that creates a new value)\n //! is typically easiest to write in terms of `as_rvalue` or `into`,\n //! whereas a reference to a field is easiest to write in terms of\n-//! `as_lvalue`. (The exception to this is scope and paren\n+//! `as_place`. (The exception to this is scope and paren\n //! expressions, which have no category.)\n //!\n //! Therefore, the various functions above make use of one another in\n //! a descending fashion. For any given expression, you should pick\n //! the most suitable spot to implement it, and then just let the\n //! other fns cycle around. The handoff works like this:\n //!\n-//! - `into(lv)` -> fallback is to create a rvalue with `as_rvalue` and assign it to `lv`\n+//! - `into(place)` -> fallback is to create a rvalue with `as_rvalue` and assign it to `place`\n //! - `as_rvalue` -> fallback is to create an Operand with `as_operand` and use `Rvalue::use`\n //! - `as_operand` -> either invokes `as_constant` or `as_temp`\n //! - `as_constant` -> (no fallback)\n-//! - `as_temp` -> creates a temporary and either calls `as_lvalue` or `into`\n-//! - `as_lvalue` -> for rvalues, falls back to `as_temp` and returns that\n+//! - `as_temp` -> creates a temporary and either calls `as_place` or `into`\n+//! - `as_place` -> for rvalues, falls back to `as_temp` and returns that\n //!\n //! As you can see, there is a cycle where `into` can (in theory) fallback to `as_temp`\n //! which can fallback to `into`. So if one of the `ExprKind` variants is not, in fact,\n@@ -68,10 +68,10 @@\n //! Of those fallbacks, the most interesting one is `as_temp`, because\n //! it discriminates based on the category of the expression. This is\n //! basically the point where the \"by value\" operations are bridged\n-//! over to the \"by reference\" mode (`as_lvalue`).\n+//! over to the \"by reference\" mode (`as_place`).\n \n mod as_constant;\n-mod as_lvalue;\n+mod as_place;\n mod as_rvalue;\n mod as_operand;\n mod as_temp;"}, {"sha": "6f1fe8335780db3ff8e1f921adae6906daad6e2d", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -41,14 +41,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // dropped.\n                 if this.hir.needs_drop(lhs.ty) {\n                     let rhs = unpack!(block = this.as_local_operand(block, rhs));\n-                    let lhs = unpack!(block = this.as_lvalue(block, lhs));\n+                    let lhs = unpack!(block = this.as_place(block, lhs));\n                     unpack!(block = this.build_drop_and_replace(\n                         block, lhs_span, lhs, rhs\n                     ));\n                     block.unit()\n                 } else {\n                     let rhs = unpack!(block = this.as_local_rvalue(block, rhs));\n-                    let lhs = unpack!(block = this.as_lvalue(block, lhs));\n+                    let lhs = unpack!(block = this.as_place(block, lhs));\n                     this.cfg.push_assign(block, source_info, &lhs, rhs);\n                     block.unit()\n                 }\n@@ -67,7 +67,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 // As above, RTL.\n                 let rhs = unpack!(block = this.as_local_operand(block, rhs));\n-                let lhs = unpack!(block = this.as_lvalue(block, lhs));\n+                let lhs = unpack!(block = this.as_place(block, lhs));\n \n                 // we don't have to drop prior contents or anything\n                 // because AssignOp is only legal for Copy types\n@@ -107,12 +107,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Return { value } => {\n                 block = match value {\n                     Some(value) => {\n-                        unpack!(this.into(&Place::Local(RETURN_POINTER), block, value))\n+                        unpack!(this.into(&Place::Local(RETURN_PLACE), block, value))\n                     }\n                     None => {\n                         this.cfg.push_assign_unit(block,\n                                                   source_info,\n-                                                  &Place::Local(RETURN_POINTER));\n+                                                  &Place::Local(RETURN_PLACE));\n                         block\n                     }\n                 };\n@@ -123,7 +123,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             ExprKind::InlineAsm { asm, outputs, inputs } => {\n                 let outputs = outputs.into_iter().map(|output| {\n-                    unpack!(block = this.as_lvalue(block, output))\n+                    unpack!(block = this.as_place(block, output))\n                 }).collect();\n                 let inputs = inputs.into_iter().map(|input| {\n                     unpack!(block = this.as_local_operand(block, input))"}, {"sha": "23095bc4269b5e645c33ca66d9218e2cf85172c9", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                       discriminant: ExprRef<'tcx>,\n                       arms: Vec<Arm<'tcx>>)\n                       -> BlockAnd<()> {\n-        let discriminant_lvalue = unpack!(block = self.as_lvalue(block, discriminant));\n+        let discriminant_place = unpack!(block = self.as_place(block, discriminant));\n \n         let mut arm_blocks = ArmBlocks {\n             blocks: arms.iter()\n@@ -77,7 +77,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                        (pre_binding_block, next_candidate_pre_binding_block))| {\n                     Candidate {\n                         span: pattern.span,\n-                        match_pairs: vec![MatchPair::new(discriminant_lvalue.clone(), pattern)],\n+                        match_pairs: vec![MatchPair::new(discriminant_place.clone(), pattern)],\n                         bindings: vec![],\n                         guard,\n                         arm_index,\n@@ -91,7 +91,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         self.cfg.terminate(*pre_binding_blocks.last().unwrap(),\n                            outer_source_info, TerminatorKind::Unreachable);\n \n-        // this will generate code to test discriminant_lvalue and\n+        // this will generate code to test discriminant_place and\n         // branch to the appropriate arm block\n         let otherwise = self.match_candidates(span, &mut arm_blocks, candidates, block);\n \n@@ -139,19 +139,19 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             PatternKind::Binding { mode: BindingMode::ByValue,\n                                    var,\n                                    subpattern: None, .. } => {\n-                let lvalue = self.storage_live_binding(block, var, irrefutable_pat.span);\n-                unpack!(block = self.into(&lvalue, block, initializer));\n+                let place = self.storage_live_binding(block, var, irrefutable_pat.span);\n+                unpack!(block = self.into(&place, block, initializer));\n                 self.schedule_drop_for_binding(var, irrefutable_pat.span);\n                 block.unit()\n             }\n             _ => {\n-                let lvalue = unpack!(block = self.as_lvalue(block, initializer));\n-                self.lvalue_into_pattern(block, irrefutable_pat, &lvalue)\n+                let place = unpack!(block = self.as_place(block, initializer));\n+                self.place_into_pattern(block, irrefutable_pat, &place)\n             }\n         }\n     }\n \n-    pub fn lvalue_into_pattern(&mut self,\n+    pub fn place_into_pattern(&mut self,\n                                mut block: BasicBlock,\n                                irrefutable_pat: Pattern<'tcx>,\n                                initializer: &Place<'tcx>)\n@@ -315,8 +315,8 @@ struct Binding<'tcx> {\n \n #[derive(Clone, Debug)]\n pub struct MatchPair<'pat, 'tcx:'pat> {\n-    // this lvalue...\n-    lvalue: Place<'tcx>,\n+    // this place...\n+    place: Place<'tcx>,\n \n     // ... must match this pattern.\n     pattern: &'pat Pattern<'tcx>,\n@@ -635,7 +635,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         match test.kind {\n             TestKind::SwitchInt { switch_ty, ref mut options, ref mut indices } => {\n                 for candidate in candidates.iter() {\n-                    if !self.add_cases_to_switch(&match_pair.lvalue,\n+                    if !self.add_cases_to_switch(&match_pair.place,\n                                                  candidate,\n                                                  switch_ty,\n                                                  options,\n@@ -646,7 +646,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             TestKind::Switch { adt_def: _, ref mut variants} => {\n                 for candidate in candidates.iter() {\n-                    if !self.add_variants_to_switch(&match_pair.lvalue,\n+                    if !self.add_variants_to_switch(&match_pair.place,\n                                                     candidate,\n                                                     variants) {\n                         break;\n@@ -661,7 +661,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // vector of candidates. Those are the candidates that still\n         // apply if the test has that particular outcome.\n         debug!(\"match_candidates: test={:?} match_pair={:?}\", test, match_pair);\n-        let target_blocks = self.perform_test(block, &match_pair.lvalue, &test);\n+        let target_blocks = self.perform_test(block, &match_pair.place, &test);\n         let mut target_candidates: Vec<_> = (0..target_blocks.len()).map(|_| vec![]).collect();\n \n         // Sort the candidates into the appropriate vector in\n@@ -670,7 +670,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // that point, we stop sorting.\n         let tested_candidates =\n             candidates.iter()\n-                      .take_while(|c| self.sort_candidate(&match_pair.lvalue,\n+                      .take_while(|c| self.sort_candidate(&match_pair.place,\n                                                           &test,\n                                                           c,\n                                                           &mut target_candidates))"}, {"sha": "4ae373c7c8223c15e0edb37edf51d4fd7a984edd", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -10,11 +10,11 @@\n \n //! Simplifying Candidates\n //!\n-//! *Simplifying* a match pair `lvalue @ pattern` means breaking it down\n+//! *Simplifying* a match pair `place @ pattern` means breaking it down\n //! into bindings or other, simpler match pairs. For example:\n //!\n-//! - `lvalue @ (P1, P2)` can be simplified to `[lvalue.0 @ P1, lvalue.1 @ P2]`\n-//! - `lvalue @ x` can be simplified to `[]` by binding `x` to `lvalue`\n+//! - `place @ (P1, P2)` can be simplified to `[place.0 @ P1, place.1 @ P2]`\n+//! - `place @ x` can be simplified to `[]` by binding `x` to `place`\n //!\n //! The `simplify_candidate` routine just repeatedly applies these\n //! sort of simplifications until there is nothing left to\n@@ -73,15 +73,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     name,\n                     mutability,\n                     span: match_pair.pattern.span,\n-                    source: match_pair.lvalue.clone(),\n+                    source: match_pair.place.clone(),\n                     var_id: var,\n                     var_ty: ty,\n                     binding_mode: mode,\n                 });\n \n                 if let Some(subpattern) = subpattern.as_ref() {\n                     // this is the `x @ P` case; have to keep matching against `P` now\n-                    candidate.match_pairs.push(MatchPair::new(match_pair.lvalue, subpattern));\n+                    candidate.match_pairs.push(MatchPair::new(match_pair.place, subpattern));\n                 }\n \n                 Ok(())\n@@ -105,8 +105,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                 });\n                 if irrefutable {\n-                    let lvalue = match_pair.lvalue.downcast(adt_def, variant_index);\n-                    candidate.match_pairs.extend(self.field_match_pairs(lvalue, subpatterns));\n+                    let place = match_pair.place.downcast(adt_def, variant_index);\n+                    candidate.match_pairs.extend(self.field_match_pairs(place, subpatterns));\n                     Ok(())\n                 } else {\n                     Err(match_pair)\n@@ -115,7 +115,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n                 self.prefix_slice_suffix(&mut candidate.match_pairs,\n-                                         &match_pair.lvalue,\n+                                         &match_pair.place,\n                                          prefix,\n                                          slice.as_ref(),\n                                          suffix);\n@@ -125,13 +125,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             PatternKind::Leaf { ref subpatterns } => {\n                 // tuple struct, match subpats (if any)\n                 candidate.match_pairs\n-                         .extend(self.field_match_pairs(match_pair.lvalue, subpatterns));\n+                         .extend(self.field_match_pairs(match_pair.place, subpatterns));\n                 Ok(())\n             }\n \n             PatternKind::Deref { ref subpattern } => {\n-                let lvalue = match_pair.lvalue.deref();\n-                candidate.match_pairs.push(MatchPair::new(lvalue, subpattern));\n+                let place = match_pair.place.deref();\n+                candidate.match_pairs.push(MatchPair::new(place, subpattern));\n                 Ok(())\n             }\n         }"}, {"sha": "7c9f190670ba8bcc97445ba8e1ba2fdff54516bc", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -109,21 +109,21 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn add_cases_to_switch<'pat>(&mut self,\n-                                     test_lvalue: &Place<'tcx>,\n+                                     test_place: &Place<'tcx>,\n                                      candidate: &Candidate<'pat, 'tcx>,\n                                      switch_ty: Ty<'tcx>,\n                                      options: &mut Vec<&'tcx ty::Const<'tcx>>,\n                                      indices: &mut FxHashMap<&'tcx ty::Const<'tcx>, usize>)\n                                      -> bool\n     {\n-        let match_pair = match candidate.match_pairs.iter().find(|mp| mp.lvalue == *test_lvalue) {\n+        let match_pair = match candidate.match_pairs.iter().find(|mp| mp.place == *test_place) {\n             Some(match_pair) => match_pair,\n             _ => { return false; }\n         };\n \n         match *match_pair.pattern.kind {\n             PatternKind::Constant { value } => {\n-                // if the lvalues match, the type should match\n+                // if the places match, the type should match\n                 assert_eq!(match_pair.pattern.ty, switch_ty);\n \n                 indices.entry(value)\n@@ -150,12 +150,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn add_variants_to_switch<'pat>(&mut self,\n-                                        test_lvalue: &Place<'tcx>,\n+                                        test_place: &Place<'tcx>,\n                                         candidate: &Candidate<'pat, 'tcx>,\n                                         variants: &mut BitVector)\n                                         -> bool\n     {\n-        let match_pair = match candidate.match_pairs.iter().find(|mp| mp.lvalue == *test_lvalue) {\n+        let match_pair = match candidate.match_pairs.iter().find(|mp| mp.place == *test_place) {\n             Some(match_pair) => match_pair,\n             _ => { return false; }\n         };\n@@ -177,7 +177,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Generates the code to perform a test.\n     pub fn perform_test(&mut self,\n                         block: BasicBlock,\n-                        lvalue: &Place<'tcx>,\n+                        place: &Place<'tcx>,\n                         test: &Test<'tcx>)\n                         -> Vec<BasicBlock> {\n         let source_info = self.source_info(test.span);\n@@ -212,7 +212,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let discr_ty = adt_def.repr.discr_type().to_ty(tcx);\n                 let discr = self.temp(discr_ty, test.span);\n                 self.cfg.push_assign(block, source_info, &discr,\n-                                     Rvalue::Discriminant(lvalue.clone()));\n+                                     Rvalue::Discriminant(place.clone()));\n                 assert_eq!(values.len() + 1, targets.len());\n                 self.cfg.terminate(block, source_info, TerminatorKind::SwitchInt {\n                     discr: Operand::Move(discr),\n@@ -233,7 +233,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         ConstVal::Bool(false) => vec![false_bb, true_bb],\n                         v => span_bug!(test.span, \"expected boolean value but got {:?}\", v)\n                     };\n-                    (ret, TerminatorKind::if_(self.hir.tcx(), Operand::Copy(lvalue.clone()),\n+                    (ret, TerminatorKind::if_(self.hir.tcx(), Operand::Copy(place.clone()),\n                                               true_bb, false_bb))\n                 } else {\n                     // The switch may be inexhaustive so we\n@@ -248,7 +248,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         v.val.to_const_int().expect(\"switching on integral\")\n                     ).collect();\n                     (targets.clone(), TerminatorKind::SwitchInt {\n-                        discr: Operand::Copy(lvalue.clone()),\n+                        discr: Operand::Copy(place.clone()),\n                         switch_ty,\n                         values: From::from(values),\n                         targets,\n@@ -259,14 +259,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             TestKind::Eq { value, mut ty } => {\n-                let mut val = Operand::Copy(lvalue.clone());\n+                let mut val = Operand::Copy(place.clone());\n \n                 // If we're using b\"...\" as a pattern, we need to insert an\n                 // unsizing coercion, as the byte string has the type &[u8; N].\n                 let expect = if let ConstVal::ByteStr(bytes) = value.val {\n                     let tcx = self.hir.tcx();\n \n-                    // Unsize the lvalue to &[u8], too, if necessary.\n+                    // Unsize the place to &[u8], too, if necessary.\n                     if let ty::TyRef(region, mt) = ty.sty {\n                         if let ty::TyArray(_, _) = mt.ty.sty {\n                             ty = tcx.mk_imm_ref(region, tcx.mk_slice(tcx.types.u8));\n@@ -335,7 +335,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // Test `val` by computing `lo <= val && val <= hi`, using primitive comparisons.\n                 let lo = self.literal_operand(test.span, ty.clone(), lo.clone());\n                 let hi = self.literal_operand(test.span, ty.clone(), hi.clone());\n-                let val = Operand::Copy(lvalue.clone());\n+                let val = Operand::Copy(place.clone());\n \n                 let fail = self.cfg.start_new_block();\n                 let block = self.compare(block, fail, test.span, BinOp::Le, lo, val.clone());\n@@ -352,9 +352,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let (actual, result) = (self.temp(usize_ty, test.span),\n                                         self.temp(bool_ty, test.span));\n \n-                // actual = len(lvalue)\n+                // actual = len(place)\n                 self.cfg.push_assign(block, source_info,\n-                                     &actual, Rvalue::Len(lvalue.clone()));\n+                                     &actual, Rvalue::Len(place.clone()));\n \n                 // expected = <N>\n                 let expected = self.push_usize(block, source_info, len);\n@@ -399,7 +399,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         target_block\n     }\n \n-    /// Given that we are performing `test` against `test_lvalue`,\n+    /// Given that we are performing `test` against `test_place`,\n     /// this job sorts out what the status of `candidate` will be\n     /// after the test. The `resulting_candidates` vector stores, for\n     /// each possible outcome of `test`, a vector of the candidates\n@@ -430,25 +430,25 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// not apply to this candidate, but it might be we can get\n     /// tighter match code if we do something a bit different.\n     pub fn sort_candidate<'pat>(&mut self,\n-                                test_lvalue: &Place<'tcx>,\n+                                test_place: &Place<'tcx>,\n                                 test: &Test<'tcx>,\n                                 candidate: &Candidate<'pat, 'tcx>,\n                                 resulting_candidates: &mut [Vec<Candidate<'pat, 'tcx>>])\n                                 -> bool {\n-        // Find the match_pair for this lvalue (if any). At present,\n+        // Find the match_pair for this place (if any). At present,\n         // afaik, there can be at most one. (In the future, if we\n         // adopted a more general `@` operator, there might be more\n         // than one, but it'd be very unusual to have two sides that\n         // both require tests; you'd expect one side to be simplified\n         // away.)\n         let tested_match_pair = candidate.match_pairs.iter()\n                                                      .enumerate()\n-                                                     .filter(|&(_, mp)| mp.lvalue == *test_lvalue)\n+                                                     .filter(|&(_, mp)| mp.place == *test_place)\n                                                      .next();\n         let (match_pair_index, match_pair) = match tested_match_pair {\n             Some(pair) => pair,\n             None => {\n-                // We are not testing this lvalue. Therefore, this\n+                // We are not testing this place. Therefore, this\n                 // candidate applies to ALL outcomes.\n                 return false;\n             }\n@@ -614,7 +614,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.candidate_without_match_pair(match_pair_index, candidate);\n         self.prefix_slice_suffix(\n             &mut new_candidate.match_pairs,\n-            &candidate.match_pairs[match_pair_index].lvalue,\n+            &candidate.match_pairs[match_pair_index].place,\n             prefix,\n             opt_slice,\n             suffix);\n@@ -635,15 +635,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // we want to create a set of derived match-patterns like\n         // `(x as Variant).0 @ P1` and `(x as Variant).1 @ P1`.\n         let elem = ProjectionElem::Downcast(adt_def, variant_index);\n-        let downcast_lvalue = match_pair.lvalue.clone().elem(elem); // `(x as Variant)`\n+        let downcast_place = match_pair.place.clone().elem(elem); // `(x as Variant)`\n         let consequent_match_pairs =\n             subpatterns.iter()\n                        .map(|subpattern| {\n                            // e.g., `(x as Variant).0`\n-                           let lvalue = downcast_lvalue.clone().field(subpattern.field,\n+                           let place = downcast_place.clone().field(subpattern.field,\n                                                                       subpattern.pattern.ty);\n                            // e.g., `(x as Variant).0 @ P1`\n-                           MatchPair::new(lvalue, &subpattern.pattern)\n+                           MatchPair::new(place, &subpattern.pattern)\n                        });\n \n         // In addition, we need all the other match pairs from the old candidate."}, {"sha": "cfd9100fc6ae7c8482b3a1667fd3a01f5d28b010", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -16,21 +16,21 @@ use std::u32;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn field_match_pairs<'pat>(&mut self,\n-                                   lvalue: Place<'tcx>,\n+                                   place: Place<'tcx>,\n                                    subpatterns: &'pat [FieldPattern<'tcx>])\n                                    -> Vec<MatchPair<'pat, 'tcx>> {\n         subpatterns.iter()\n                    .map(|fieldpat| {\n-                       let lvalue = lvalue.clone().field(fieldpat.field,\n+                       let place = place.clone().field(fieldpat.field,\n                                                          fieldpat.pattern.ty);\n-                       MatchPair::new(lvalue, &fieldpat.pattern)\n+                       MatchPair::new(place, &fieldpat.pattern)\n                    })\n                    .collect()\n     }\n \n     pub fn prefix_slice_suffix<'pat>(&mut self,\n                                      match_pairs: &mut Vec<MatchPair<'pat, 'tcx>>,\n-                                     lvalue: &Place<'tcx>,\n+                                     place: &Place<'tcx>,\n                                      prefix: &'pat [Pattern<'tcx>],\n                                      opt_slice: Option<&'pat Pattern<'tcx>>,\n                                      suffix: &'pat [Pattern<'tcx>]) {\n@@ -47,13 +47,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                           min_length,\n                           from_end: false,\n                       };\n-                      let lvalue = lvalue.clone().elem(elem);\n-                      MatchPair::new(lvalue, subpattern)\n+                      let place = place.clone().elem(elem);\n+                      MatchPair::new(place, subpattern)\n                   })\n         );\n \n         if let Some(subslice_pat) = opt_slice {\n-            let subslice = lvalue.clone().elem(ProjectionElem::Subslice {\n+            let subslice = place.clone().elem(ProjectionElem::Subslice {\n                 from: prefix.len() as u32,\n                 to: suffix.len() as u32\n             });\n@@ -70,17 +70,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                           min_length,\n                           from_end: true,\n                       };\n-                      let lvalue = lvalue.clone().elem(elem);\n-                      MatchPair::new(lvalue, subpattern)\n+                      let place = place.clone().elem(elem);\n+                      MatchPair::new(place, subpattern)\n                   })\n         );\n     }\n }\n \n impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n-    pub fn new(lvalue: Place<'tcx>, pattern: &'pat Pattern<'tcx>) -> MatchPair<'pat, 'tcx> {\n+    pub fn new(place: Place<'tcx>, pattern: &'pat Pattern<'tcx>) -> MatchPair<'pat, 'tcx> {\n         MatchPair {\n-            lvalue,\n+            place,\n             pattern,\n             slice_len_checked: false,\n         }"}, {"sha": "8486c63baac66624875a978d4622a78010fdff69", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -29,10 +29,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// call `schedule_drop` once the temporary is initialized.\n     pub fn temp(&mut self, ty: Ty<'tcx>, span: Span) -> Place<'tcx> {\n         let temp = self.local_decls.push(LocalDecl::new_temp(ty, span));\n-        let lvalue = Place::Local(temp);\n+        let place = Place::Local(temp);\n         debug!(\"temp: created temp {:?} with type {:?}\",\n-               lvalue, self.local_decls[temp].ty);\n-        lvalue\n+               place, self.local_decls[temp].ty);\n+        place\n     }\n \n     pub fn literal_operand(&mut self,\n@@ -134,13 +134,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         temp\n     }\n \n-    pub fn consume_by_copy_or_move(&self, lvalue: Place<'tcx>) -> Operand<'tcx> {\n+    pub fn consume_by_copy_or_move(&self, place: Place<'tcx>) -> Operand<'tcx> {\n         let tcx = self.hir.tcx();\n-        let ty = lvalue.ty(&self.local_decls, tcx).to_ty(tcx);\n+        let ty = place.ty(&self.local_decls, tcx).to_ty(tcx);\n         if self.hir.type_moves_by_default(ty, DUMMY_SP) {\n-            Operand::Move(lvalue)\n+            Operand::Move(place)\n         } else {\n-            Operand::Copy(lvalue)\n+            Operand::Copy(place)\n         }\n     }\n }"}, {"sha": "4349820dbe9e1255225558dbd08474888fe3a998", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -480,7 +480,7 @@ fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n \n     let mut block = START_BLOCK;\n     let expr = builder.hir.mirror(ast_expr);\n-    unpack!(block = builder.into_expr(&Place::Local(RETURN_POINTER), block, expr));\n+    unpack!(block = builder.into_expr(&Place::Local(RETURN_PLACE), block, expr));\n \n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n@@ -523,7 +523,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             push_unsafe_count: 0,\n             unpushed_unsafe: safety,\n             breakable_scopes: vec![],\n-            local_decls: IndexVec::from_elem_n(LocalDecl::new_return_pointer(return_ty,\n+            local_decls: IndexVec::from_elem_n(LocalDecl::new_return_place(return_ty,\n                                                                              span), 1),\n             var_indices: NodeMap(),\n             unit_temp: None,\n@@ -597,9 +597,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let mut scope = None;\n         // Bind the argument patterns\n         for (index, &(ty, pattern)) in arguments.iter().enumerate() {\n-            // Function arguments always get the first Local indices after the return pointer\n+            // Function arguments always get the first Local indices after the return place\n             let local = Local::new(index + 1);\n-            let lvalue = Place::Local(local);\n+            let place = Place::Local(local);\n \n             if let Some(pattern) = pattern {\n                 let pattern = self.hir.pattern_from_hir(pattern);\n@@ -613,14 +613,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     _ => {\n                         scope = self.declare_bindings(scope, ast_body.span,\n                                                       LintLevel::Inherited, &pattern);\n-                        unpack!(block = self.lvalue_into_pattern(block, pattern, &lvalue));\n+                        unpack!(block = self.place_into_pattern(block, pattern, &place));\n                     }\n                 }\n             }\n \n             // Make sure we drop (parts of) the argument even when not matched on.\n             self.schedule_drop(pattern.as_ref().map_or(ast_body.span, |pat| pat.span),\n-                               argument_scope, &lvalue, ty);\n+                               argument_scope, &place, ty);\n \n         }\n \n@@ -630,7 +630,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n \n         let body = self.hir.mirror(ast_body);\n-        self.into(&Place::Local(RETURN_POINTER), block, body)\n+        self.into(&Place::Local(RETURN_PLACE), block, body)\n     }\n \n     fn get_unit_temp(&mut self) -> Place<'tcx> {"}, {"sha": "3814dde17bb679339c44f18970b2a14ead563eaa", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -39,10 +39,10 @@ mapping is from one scope to a vector of SEME regions.\n ### Drops\n \n The primary purpose for scopes is to insert drops: while translating\n-the contents, we also accumulate lvalues that need to be dropped upon\n+the contents, we also accumulate places that need to be dropped upon\n exit from each scope. This is done by calling `schedule_drop`. Once a\n drop is scheduled, whenever we branch out we will insert drops of all\n-those lvalues onto the outgoing edge. Note that we don't know the full\n+those places onto the outgoing edge. Note that we don't know the full\n set of scheduled drops up front, and so whenever we exit from the\n scope we only drop the values scheduled thus far. For example, consider\n the scope S corresponding to this loop:\n@@ -120,7 +120,7 @@ pub struct Scope<'tcx> {\n     ///  * freeing up stack space has no effect during unwinding\n     needs_cleanup: bool,\n \n-    /// set of lvalues to drop when exiting this scope. This starts\n+    /// set of places to drop when exiting this scope. This starts\n     /// out empty but grows as variables are declared during the\n     /// building process. This is a stack, so we always drop from the\n     /// end of the vector (top of the stack) first.\n@@ -138,10 +138,10 @@ pub struct Scope<'tcx> {\n \n #[derive(Debug)]\n struct DropData<'tcx> {\n-    /// span where drop obligation was incurred (typically where lvalue was declared)\n+    /// span where drop obligation was incurred (typically where place was declared)\n     span: Span,\n \n-    /// lvalue to drop\n+    /// place to drop\n     location: Place<'tcx>,\n \n     /// Whether this is a full value Drop, or just a StorageDead.\n@@ -608,19 +608,19 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     // Scheduling drops\n     // ================\n-    /// Indicates that `lvalue` should be dropped on exit from\n+    /// Indicates that `place` should be dropped on exit from\n     /// `region_scope`.\n     pub fn schedule_drop(&mut self,\n                          span: Span,\n                          region_scope: region::Scope,\n-                         lvalue: &Place<'tcx>,\n-                         lvalue_ty: Ty<'tcx>) {\n-        let needs_drop = self.hir.needs_drop(lvalue_ty);\n+                         place: &Place<'tcx>,\n+                         place_ty: Ty<'tcx>) {\n+        let needs_drop = self.hir.needs_drop(place_ty);\n         let drop_kind = if needs_drop {\n             DropKind::Value { cached_block: CachedBlock::default() }\n         } else {\n             // Only temps and vars need their storage dead.\n-            match *lvalue {\n+            match *place {\n                 Place::Local(index) if index.index() > self.arg_count => DropKind::Storage,\n                 _ => return\n             }\n@@ -685,13 +685,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let scope_end = region_scope_span.with_lo(region_scope_span.hi());\n                 scope.drops.push(DropData {\n                     span: scope_end,\n-                    location: lvalue.clone(),\n+                    location: place.clone(),\n                     kind: drop_kind\n                 });\n                 return;\n             }\n         }\n-        span_bug!(span, \"region scope {:?} not in scope to drop {:?}\", region_scope, lvalue);\n+        span_bug!(span, \"region scope {:?} not in scope to drop {:?}\", region_scope, place);\n     }\n \n     // Other"}, {"sha": "f0ecaea15649c71e4eeae8016fe8e522999e5d7d", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -24,7 +24,7 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n {\n     let mut next_child = move_data.move_paths[path].first_child;\n     while let Some(child_index) = next_child {\n-        match move_data.move_paths[child_index].lvalue {\n+        match move_data.move_paths[child_index].place {\n             mir::Place::Projection(ref proj) => {\n                 if cond(proj) {\n                     return Some(child_index)\n@@ -56,19 +56,19 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n /// is no need to maintain separate drop flags to track such state.\n ///\n /// FIXME: we have to do something for moving slice patterns.\n-fn lvalue_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+fn place_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                             mir: &Mir<'tcx>,\n-                                                            lv: &mir::Place<'tcx>) -> bool {\n-    let ty = lv.ty(mir, tcx).to_ty(tcx);\n+                                                            place: &mir::Place<'tcx>) -> bool {\n+    let ty = place.ty(mir, tcx).to_ty(tcx);\n     match ty.sty {\n         ty::TyArray(..) | ty::TySlice(..) | ty::TyRef(..) | ty::TyRawPtr(..) => {\n-            debug!(\"lvalue_contents_drop_state_cannot_differ lv: {:?} ty: {:?} refd => true\",\n-                   lv, ty);\n+            debug!(\"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} refd => true\",\n+                   place, ty);\n             true\n         }\n         ty::TyAdt(def, _) if (def.has_dtor(tcx) && !def.is_box()) || def.is_union() => {\n-            debug!(\"lvalue_contents_drop_state_cannot_differ lv: {:?} ty: {:?} Drop => true\",\n-                   lv, ty);\n+            debug!(\"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} Drop => true\",\n+                   place, ty);\n             true\n         }\n         _ => {\n@@ -109,8 +109,8 @@ pub(crate) fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n         move_data: &MoveData<'tcx>,\n         path: MovePathIndex) -> bool\n     {\n-        lvalue_contents_drop_state_cannot_differ(\n-            tcx, mir, &move_data.move_paths[path].lvalue)\n+        place_contents_drop_state_cannot_differ(\n+            tcx, mir, &move_data.move_paths[path].place)\n     }\n \n     fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n@@ -145,9 +145,9 @@ pub(crate) fn on_all_drop_children_bits<'a, 'gcx, 'tcx, F>(\n     where F: FnMut(MovePathIndex)\n {\n     on_all_children_bits(tcx, mir, &ctxt.move_data, path, |child| {\n-        let lvalue = &ctxt.move_data.move_paths[path].lvalue;\n-        let ty = lvalue.ty(mir, tcx).to_ty(tcx);\n-        debug!(\"on_all_drop_children_bits({:?}, {:?} : {:?})\", path, lvalue, ty);\n+        let place = &ctxt.move_data.move_paths[path].place;\n+        let ty = place.ty(mir, tcx).to_ty(tcx);\n+        debug!(\"on_all_drop_children_bits({:?}, {:?} : {:?})\", path, place, ty);\n \n         let gcx = tcx.global_tcx();\n         let erased_ty = gcx.lift(&tcx.erase_regions(&ty)).unwrap();\n@@ -168,8 +168,8 @@ pub(crate) fn drop_flag_effects_for_function_entry<'a, 'gcx, 'tcx, F>(\n {\n     let move_data = &ctxt.move_data;\n     for arg in mir.args_iter() {\n-        let lvalue = mir::Place::Local(arg);\n-        let lookup_result = move_data.rev_lookup.find(&lvalue);\n+        let place = mir::Place::Local(arg);\n+        let lookup_result = move_data.rev_lookup.find(&place);\n         on_lookup_result_bits(tcx, mir, move_data,\n                               lookup_result,\n                               |mpi| callback(mpi, DropFlagState::Present));"}, {"sha": "32dcf28cd948376a86de0242cbe1fa139026072e", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -42,15 +42,15 @@ pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n }\n \n // temporarily allow some dead fields: `kind` and `region` will be\n-// needed by borrowck; `lvalue` will probably be a MovePathIndex when\n+// needed by borrowck; `place` will probably be a MovePathIndex when\n // that is extended to include borrowed data paths.\n #[allow(dead_code)]\n #[derive(Debug)]\n pub struct BorrowData<'tcx> {\n     pub(crate) location: Location,\n     pub(crate) kind: mir::BorrowKind,\n     pub(crate) region: Region<'tcx>,\n-    pub(crate) lvalue: mir::Place<'tcx>,\n+    pub(crate) place: mir::Place<'tcx>,\n }\n \n impl<'tcx> fmt::Display for BorrowData<'tcx> {\n@@ -62,7 +62,7 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n         };\n         let region = format!(\"{}\", self.region);\n         let region = if region.len() > 0 { format!(\"{} \", region) } else { region };\n-        write!(w, \"&{}{}{:?}\", region, kind, self.lvalue)\n+        write!(w, \"&{}{}{:?}\", region, kind, self.place)\n     }\n }\n \n@@ -101,11 +101,11 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             fn visit_rvalue(&mut self,\n                             rvalue: &mir::Rvalue<'tcx>,\n                             location: mir::Location) {\n-                if let mir::Rvalue::Ref(region, kind, ref lvalue) = *rvalue {\n-                    if is_unsafe_lvalue(self.tcx, self.mir, lvalue) { return; }\n+                if let mir::Rvalue::Ref(region, kind, ref place) = *rvalue {\n+                    if is_unsafe_place(self.tcx, self.mir, place) { return; }\n \n                     let borrow = BorrowData {\n-                        location: location, kind: kind, region: region, lvalue: lvalue.clone(),\n+                        location: location, kind: kind, region: region, place: place.clone(),\n                     };\n                     let idx = self.idx_vec.push(borrow);\n                     self.location_map.insert(location, idx);\n@@ -206,8 +206,8 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             }\n \n             mir::StatementKind::Assign(_, ref rhs) => {\n-                if let mir::Rvalue::Ref(region, _, ref lvalue) = *rhs {\n-                    if is_unsafe_lvalue(self.tcx, self.mir, lvalue) { return; }\n+                if let mir::Rvalue::Ref(region, _, ref place) = *rhs {\n+                    if is_unsafe_place(self.tcx, self.mir, place) { return; }\n                     let index = self.location_map.get(&location).unwrap_or_else(|| {\n                         panic!(\"could not find BorrowIndex for location {:?}\", location);\n                     });\n@@ -269,7 +269,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                              _in_out: &mut IdxSet<BorrowIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n-                             _dest_lval: &mir::Place) {\n+                             _dest_place: &mir::Place) {\n         // there are no effects on the region scopes from method calls.\n     }\n }\n@@ -288,15 +288,15 @@ impl<'a, 'gcx, 'tcx> DataflowOperator for Borrows<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn is_unsafe_lvalue<'a, 'gcx: 'tcx, 'tcx: 'a>(\n+fn is_unsafe_place<'a, 'gcx: 'tcx, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n-    lvalue: &mir::Place<'tcx>\n+    place: &mir::Place<'tcx>\n ) -> bool {\n     use self::mir::Place::*;\n     use self::mir::ProjectionElem;\n \n-    match *lvalue {\n+    match *place {\n         Local(_) => false,\n         Static(ref static_) => tcx.is_static_mut(static_.def_id),\n         Projection(ref proj) => {\n@@ -306,13 +306,13 @@ fn is_unsafe_lvalue<'a, 'gcx: 'tcx, 'tcx: 'a>(\n                 ProjectionElem::Subslice { .. } |\n                 ProjectionElem::ConstantIndex { .. } |\n                 ProjectionElem::Index(_) => {\n-                    is_unsafe_lvalue(tcx, mir, &proj.base)\n+                    is_unsafe_place(tcx, mir, &proj.base)\n                 }\n                 ProjectionElem::Deref => {\n                     let ty = proj.base.ty(mir, tcx).to_ty(tcx);\n                     match ty.sty {\n                         ty::TyRawPtr(..) => true,\n-                        _ => is_unsafe_lvalue(tcx, mir, &proj.base),\n+                        _ => is_unsafe_place(tcx, mir, &proj.base),\n                     }\n                 }\n             }"}, {"sha": "50c8df3c2e3d01665a63bde683944baa7712d0d1", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -368,11 +368,11 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n                              in_out: &mut IdxSet<MovePathIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n-                             dest_lval: &mir::Place) {\n+                             dest_place: &mir::Place) {\n         // when a call returns successfully, that means we need to set\n-        // the bits for that dest_lval to 1 (initialized).\n+        // the bits for that dest_place to 1 (initialized).\n         on_lookup_result_bits(self.tcx, self.mir, self.move_data(),\n-                              self.move_data().rev_lookup.find(dest_lval),\n+                              self.move_data().rev_lookup.find(dest_place),\n                               |mpi| { in_out.add(&mpi); });\n     }\n }\n@@ -384,7 +384,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n         self.move_data().move_paths.len()\n     }\n \n-    // sets on_entry bits for Arg lvalues\n+    // sets on_entry bits for Arg places\n     fn start_block_effect(&self, sets: &mut BlockSets<MovePathIndex>) {\n         // set all bits to 1 (uninit) before gathering counterevidence\n         for e in sets.on_entry.words_mut() { *e = !0; }\n@@ -423,11 +423,11 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n                              in_out: &mut IdxSet<MovePathIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n-                             dest_lval: &mir::Place) {\n+                             dest_place: &mir::Place) {\n         // when a call returns successfully, that means we need to set\n-        // the bits for that dest_lval to 0 (initialized).\n+        // the bits for that dest_place to 0 (initialized).\n         on_lookup_result_bits(self.tcx, self.mir, self.move_data(),\n-                              self.move_data().rev_lookup.find(dest_lval),\n+                              self.move_data().rev_lookup.find(dest_place),\n                               |mpi| { in_out.remove(&mpi); });\n     }\n }\n@@ -439,7 +439,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'gcx, 'tcx\n         self.move_data().move_paths.len()\n     }\n \n-    // sets on_entry bits for Arg lvalues\n+    // sets on_entry bits for Arg places\n     fn start_block_effect(&self, sets: &mut BlockSets<MovePathIndex>) {\n         for e in sets.on_entry.words_mut() { *e = 0; }\n \n@@ -477,11 +477,11 @@ impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'gcx, 'tcx\n                              in_out: &mut IdxSet<MovePathIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n-                             dest_lval: &mir::Place) {\n+                             dest_place: &mir::Place) {\n         // when a call returns successfully, that means we need to set\n-        // the bits for that dest_lval to 1 (initialized).\n+        // the bits for that dest_place to 1 (initialized).\n         on_lookup_result_bits(self.tcx, self.mir, self.move_data(),\n-                              self.move_data().rev_lookup.find(dest_lval),\n+                              self.move_data().rev_lookup.find(dest_place),\n                               |mpi| { in_out.add(&mpi); });\n     }\n }\n@@ -561,15 +561,15 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n                              in_out: &mut IdxSet<MoveOutIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n-                             dest_lval: &mir::Place) {\n+                             dest_place: &mir::Place) {\n         let move_data = self.move_data();\n         let bits_per_block = self.bits_per_block();\n \n         let path_map = &move_data.path_map;\n         on_lookup_result_bits(self.tcx,\n                               self.mir,\n                               move_data,\n-                              move_data.rev_lookup.find(dest_lval),\n+                              move_data.rev_lookup.find(dest_place),\n                               |mpi| for moi in &path_map[mpi] {\n                                   assert!(moi.index() < bits_per_block);\n                                   in_out.remove(&moi);\n@@ -647,7 +647,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n                              in_out: &mut IdxSet<InitIndex>,\n                              call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n-                             _dest_lval: &mir::Place) {\n+                             _dest_place: &mir::Place) {\n         let move_data = self.move_data();\n         let bits_per_block = self.bits_per_block();\n         let init_loc_map = &move_data.init_loc_map;"}, {"sha": "fe6cd660b1e83647daffc68c6f9f44f42fdad490", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> BitDenotation for MaybeStorageLive<'a, 'tcx> {\n                              _in_out: &mut IdxSet<Local>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n-                             _dest_lval: &mir::Place) {\n+                             _dest_place: &mir::Place) {\n         // Nothing to do when a call returns successfully\n     }\n }"}, {"sha": "6be006b1ea972437de0af167d873abafc17de2cd", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -610,7 +610,7 @@ pub trait BitDenotation: DataflowOperator {\n                              in_out: &mut IdxSet<Self::Idx>,\n                              call_bb: mir::BasicBlock,\n                              dest_bb: mir::BasicBlock,\n-                             dest_lval: &mir::Place);\n+                             dest_place: &mir::Place);\n }\n \n impl<'a, 'gcx, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n@@ -714,11 +714,11 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n                         self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n                     }\n                 }\n-                if let Some((ref dest_lval, ref dest_bb)) = *destination {\n+                if let Some((ref dest_place, ref dest_bb)) = *destination {\n                     // N.B.: This must be done *last*, after all other\n                     // propagation, as documented in comment above.\n                     self.flow_state.operator.propagate_call_return(\n-                        in_out, bb, *dest_bb, dest_lval);\n+                        in_out, bb, *dest_bb, dest_place);\n                     self.propagate_bits_into_entry_set_for(in_out, changed, dest_bb);\n                 }\n             }"}, {"sha": "c20beb7d8c2a72a4c1edce1b816a152ff46861cc", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -68,14 +68,14 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n                      path_map: &mut IndexVec<MovePathIndex, Vec<MoveOutIndex>>,\n                      init_path_map: &mut IndexVec<MovePathIndex, Vec<InitIndex>>,\n                      parent: Option<MovePathIndex>,\n-                     lvalue: Place<'tcx>)\n+                     place: Place<'tcx>)\n                      -> MovePathIndex\n     {\n         let move_path = move_paths.push(MovePath {\n             next_sibling: None,\n             first_child: None,\n             parent,\n-            lvalue,\n+            place,\n         });\n \n         if let Some(parent) = parent {\n@@ -95,52 +95,52 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n }\n \n impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n-    /// This creates a MovePath for a given lvalue, returning an `MovePathError`\n-    /// if that lvalue can't be moved from.\n+    /// This creates a MovePath for a given place, returning an `MovePathError`\n+    /// if that place can't be moved from.\n     ///\n-    /// NOTE: lvalues behind references *do not* get a move path, which is\n+    /// NOTE: places behind references *do not* get a move path, which is\n     /// problematic for borrowck.\n     ///\n     /// Maybe we should have separate \"borrowck\" and \"moveck\" modes.\n-    fn move_path_for(&mut self, lval: &Place<'tcx>)\n+    fn move_path_for(&mut self, place: &Place<'tcx>)\n                      -> Result<MovePathIndex, MoveError<'tcx>>\n     {\n-        debug!(\"lookup({:?})\", lval);\n-        match *lval {\n+        debug!(\"lookup({:?})\", place);\n+        match *place {\n             Place::Local(local) => Ok(self.builder.data.rev_lookup.locals[local]),\n             Place::Static(..) => {\n                 let span = self.builder.mir.source_info(self.loc).span;\n                 Err(MoveError::cannot_move_out_of(span, Static))\n             }\n             Place::Projection(ref proj) => {\n-                self.move_path_for_projection(lval, proj)\n+                self.move_path_for_projection(place, proj)\n             }\n         }\n     }\n \n-    fn create_move_path(&mut self, lval: &Place<'tcx>) {\n+    fn create_move_path(&mut self, place: &Place<'tcx>) {\n         // This is an assignment, not a move, so this not being a valid\n         // move path is OK.\n-        let _ = self.move_path_for(lval);\n+        let _ = self.move_path_for(place);\n     }\n \n     fn move_path_for_projection(&mut self,\n-                                lval: &Place<'tcx>,\n+                                place: &Place<'tcx>,\n                                 proj: &PlaceProjection<'tcx>)\n                                 -> Result<MovePathIndex, MoveError<'tcx>>\n     {\n         let base = try!(self.move_path_for(&proj.base));\n         let mir = self.builder.mir;\n         let tcx = self.builder.tcx;\n-        let lv_ty = proj.base.ty(mir, tcx).to_ty(tcx);\n-        match lv_ty.sty {\n+        let place_ty = proj.base.ty(mir, tcx).to_ty(tcx);\n+        match place_ty.sty {\n             ty::TyRef(..) | ty::TyRawPtr(..) =>\n                 return Err(MoveError::cannot_move_out_of(mir.source_info(self.loc).span,\n                                                          BorrowedContent)),\n             ty::TyAdt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() =>\n                 return Err(MoveError::cannot_move_out_of(mir.source_info(self.loc).span,\n                                                          InteriorOfTypeWithDestructor {\n-                    container_ty: lv_ty\n+                    container_ty: place_ty\n                 })),\n             // move out of union - always move the entire union\n             ty::TyAdt(adt, _) if adt.is_union() =>\n@@ -149,7 +149,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                 return Err(MoveError::cannot_move_out_of(\n                     mir.source_info(self.loc).span,\n                     InteriorOfSliceOrArray {\n-                        ty: lv_ty, is_index: match proj.elem {\n+                        ty: place_ty, is_index: match proj.elem {\n                             ProjectionElem::Index(..) => true,\n                             _ => false\n                         },\n@@ -159,7 +159,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                     return Err(MoveError::cannot_move_out_of(\n                         mir.source_info(self.loc).span,\n                         InteriorOfSliceOrArray {\n-                            ty: lv_ty, is_index: true\n+                            ty: place_ty, is_index: true\n                         })),\n                 _ => {\n                     // FIXME: still badly broken\n@@ -175,7 +175,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                     &mut self.builder.data.path_map,\n                     &mut self.builder.data.init_path_map,\n                     Some(base),\n-                    lval.clone()\n+                    place.clone()\n                 );\n                 ent.insert(path);\n                 Ok(path)\n@@ -265,16 +265,16 @@ struct Gatherer<'b, 'a: 'b, 'gcx: 'tcx, 'tcx: 'a> {\n impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n     fn gather_statement(&mut self, stmt: &Statement<'tcx>) {\n         match stmt.kind {\n-            StatementKind::Assign(ref lval, ref rval) => {\n-                self.create_move_path(lval);\n+            StatementKind::Assign(ref place, ref rval) => {\n+                self.create_move_path(place);\n                 if let RvalueInitializationState::Shallow = rval.initialization_state() {\n                     // Box starts out uninitialized - need to create a separate\n                     // move-path for the interior so it will be separate from\n                     // the exterior.\n-                    self.create_move_path(&lval.clone().deref());\n-                    self.gather_init(lval, InitKind::Shallow);\n+                    self.create_move_path(&place.clone().deref());\n+                    self.gather_init(place, InitKind::Shallow);\n                 } else {\n-                    self.gather_init(lval, InitKind::Deep);\n+                    self.gather_init(place, InitKind::Deep);\n                 }\n                 self.gather_rvalue(rval);\n             }\n@@ -318,7 +318,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             Rvalue::NullaryOp(NullOp::Box, _) => {\n                 // This returns an rvalue with uninitialized contents. We can't\n                 // move out of it here because it is an rvalue - assignments always\n-                // completely initialize their lvalue.\n+                // completely initialize their place.\n                 //\n                 // However, this does not matter - MIR building is careful to\n                 // only emit a shallow free for the partially-initialized\n@@ -339,7 +339,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             TerminatorKind::Unreachable => { }\n \n             TerminatorKind::Return => {\n-                self.gather_move(&Place::Local(RETURN_POINTER));\n+                self.gather_move(&Place::Local(RETURN_PLACE));\n             }\n \n             TerminatorKind::Assert { .. } |\n@@ -376,16 +376,16 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         match *operand {\n             Operand::Constant(..) |\n             Operand::Copy(..) => {} // not-a-move\n-            Operand::Move(ref lval) => { // a move\n-                self.gather_move(lval);\n+            Operand::Move(ref place) => { // a move\n+                self.gather_move(place);\n             }\n         }\n     }\n \n-    fn gather_move(&mut self, lval: &Place<'tcx>) {\n-        debug!(\"gather_move({:?}, {:?})\", self.loc, lval);\n+    fn gather_move(&mut self, place: &Place<'tcx>) {\n+        debug!(\"gather_move({:?}, {:?})\", self.loc, place);\n \n-        let path = match self.move_path_for(lval) {\n+        let path = match self.move_path_for(place) {\n             Ok(path) | Err(MoveError::UnionMove { path }) => path,\n             Err(error @ MoveError::IllegalMove { .. }) => {\n                 self.builder.errors.push(error);\n@@ -395,24 +395,24 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         let move_out = self.builder.data.moves.push(MoveOut { path: path, source: self.loc });\n \n         debug!(\"gather_move({:?}, {:?}): adding move {:?} of {:?}\",\n-               self.loc, lval, move_out, path);\n+               self.loc, place, move_out, path);\n \n         self.builder.data.path_map[path].push(move_out);\n         self.builder.data.loc_map[self.loc].push(move_out);\n     }\n \n-    fn gather_init(&mut self, lval: &Place<'tcx>, kind: InitKind) {\n-        debug!(\"gather_init({:?}, {:?})\", self.loc, lval);\n+    fn gather_init(&mut self, place: &Place<'tcx>, kind: InitKind) {\n+        debug!(\"gather_init({:?}, {:?})\", self.loc, place);\n \n-        if let LookupResult::Exact(path) = self.builder.data.rev_lookup.find(lval) {\n+        if let LookupResult::Exact(path) = self.builder.data.rev_lookup.find(place) {\n             let init = self.builder.data.inits.push(Init {\n                 span: self.builder.mir.source_info(self.loc).span,\n                 path,\n                 kind,\n             });\n \n             debug!(\"gather_init({:?}, {:?}): adding init {:?} of {:?}\",\n-               self.loc, lval, init, path);\n+               self.loc, place, init, path);\n \n             self.builder.data.init_path_map[path].push(init);\n             self.builder.data.init_loc_map[self.loc].push(init);"}, {"sha": "294f48178a8ac6d98630ef1b6fad808152d43ddf", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -94,7 +94,7 @@ pub struct MovePath<'tcx> {\n     pub next_sibling: Option<MovePathIndex>,\n     pub first_child: Option<MovePathIndex>,\n     pub parent: Option<MovePathIndex>,\n-    pub lvalue: Place<'tcx>,\n+    pub place: Place<'tcx>,\n }\n \n impl<'tcx> fmt::Debug for MovePath<'tcx> {\n@@ -109,13 +109,13 @@ impl<'tcx> fmt::Debug for MovePath<'tcx> {\n         if let Some(next_sibling) = self.next_sibling {\n             write!(w, \" next_sibling: {:?}\", next_sibling)?;\n         }\n-        write!(w, \" lvalue: {:?} }}\", self.lvalue)\n+        write!(w, \" place: {:?} }}\", self.place)\n     }\n }\n \n impl<'tcx> fmt::Display for MovePath<'tcx> {\n     fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n-        write!(w, \"{:?}\", self.lvalue)\n+        write!(w, \"{:?}\", self.place)\n     }\n }\n \n@@ -224,11 +224,11 @@ impl fmt::Debug for Init {\n pub struct MovePathLookup<'tcx> {\n     locals: IndexVec<Local, MovePathIndex>,\n \n-    /// projections are made from a base-lvalue and a projection\n-    /// elem. The base-lvalue will have a unique MovePathIndex; we use\n+    /// projections are made from a base-place and a projection\n+    /// elem. The base-place will have a unique MovePathIndex; we use\n     /// the latter as the index into the outer vector (narrowing\n     /// subsequent search so that it is solely relative to that\n-    /// base-lvalue). For the remaining lookup, we map the projection\n+    /// base-place). For the remaining lookup, we map the projection\n     /// elem to the associated MovePathIndex.\n     projections: FxHashMap<(MovePathIndex, AbstractElem<'tcx>), MovePathIndex>\n }\n@@ -246,8 +246,8 @@ impl<'tcx> MovePathLookup<'tcx> {\n     // alternative will *not* create a MovePath on the fly for an\n     // unknown l-value, but will rather return the nearest available\n     // parent.\n-    pub fn find(&self, lval: &Place<'tcx>) -> LookupResult {\n-        match *lval {\n+    pub fn find(&self, place: &Place<'tcx>) -> LookupResult {\n+        match *place {\n             Place::Local(local) => LookupResult::Exact(self.locals[local]),\n             Place::Static(..) => LookupResult::Parent(None),\n             Place::Projection(ref proj) => {"}, {"sha": "848c2d3c811e99495a83aade112bffb9a4b100c6", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -116,7 +116,7 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 },\n             };\n \n-            overloaded_lvalue(cx, hir_expr, adjustment.target, Some(call), vec![expr.to_ref()])\n+            overloaded_place(cx, hir_expr, adjustment.target, Some(call), vec![expr.to_ref()])\n         }\n         Adjust::Borrow(AutoBorrow::Ref(r, m)) => {\n             ExprKind::Borrow {\n@@ -335,7 +335,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprIndex(ref lhs, ref index) => {\n             if cx.tables().is_method_call(expr) {\n-                overloaded_lvalue(cx, expr, expr_ty, None, vec![lhs.to_ref(), index.to_ref()])\n+                overloaded_place(cx, expr, expr_ty, None, vec![lhs.to_ref(), index.to_ref()])\n             } else {\n                 ExprKind::Index {\n                     lhs: lhs.to_ref(),\n@@ -346,7 +346,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n             if cx.tables().is_method_call(expr) {\n-                overloaded_lvalue(cx, expr, expr_ty, None, vec![arg.to_ref()])\n+                overloaded_place(cx, expr, expr_ty, None, vec![arg.to_ref()])\n             } else {\n                 ExprKind::Deref { arg: arg.to_ref() }\n             }\n@@ -844,15 +844,15 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     }\n }\n \n-fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+fn overloaded_place<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n-                                     lvalue_ty: Ty<'tcx>,\n+                                     place_ty: Ty<'tcx>,\n                                      custom_callee: Option<(DefId, &'tcx Substs<'tcx>)>,\n                                      args: Vec<ExprRef<'tcx>>)\n                                      -> ExprKind<'tcx> {\n     // For an overloaded *x or x[y] expression of type T, the method\n     // call returns an &T and we must add the deref so that the types\n-    // line up (this is because `*x` and `x[y]` represent lvalues):\n+    // line up (this is because `*x` and `x[y]` represent places):\n \n     let recv_ty = match args[0] {\n         ExprRef::Hair(e) => cx.tables().expr_ty_adjusted(e),\n@@ -864,10 +864,10 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n     let (region, mt) = match recv_ty.sty {\n         ty::TyRef(region, mt) => (region, mt),\n-        _ => span_bug!(expr.span, \"overloaded_lvalue: receiver is not a reference\"),\n+        _ => span_bug!(expr.span, \"overloaded_place: receiver is not a reference\"),\n     };\n     let ref_ty = cx.tcx.mk_ref(region, ty::TypeAndMut {\n-        ty: lvalue_ty,\n+        ty: place_ty,\n         mutbl: mt.mutbl,\n     });\n "}, {"sha": "ad228e24e6b13a249c20f5e3980579b4b32a0e0b", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -384,14 +384,14 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         let rcvr = Place::Local(Local::new(1+0)).deref();\n         let ret_statement = self.make_statement(\n             StatementKind::Assign(\n-                Place::Local(RETURN_POINTER),\n+                Place::Local(RETURN_PLACE),\n                 Rvalue::Use(Operand::Copy(rcvr))\n             )\n         );\n         self.block(vec![ret_statement], TerminatorKind::Return, false);\n     }\n \n-    fn make_lvalue(&mut self, mutability: Mutability, ty: Ty<'tcx>) -> Place<'tcx> {\n+    fn make_place(&mut self, mutability: Mutability, ty: Ty<'tcx>) -> Place<'tcx> {\n         let span = self.span;\n         Place::Local(\n             self.local_decls.push(temp_decl(mutability, ty, span))\n@@ -427,15 +427,15 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             },\n         });\n \n-        let ref_loc = self.make_lvalue(\n+        let ref_loc = self.make_place(\n             Mutability::Not,\n             tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n                 ty,\n                 mutbl: hir::Mutability::MutImmutable,\n             })\n         );\n \n-        let loc = self.make_lvalue(Mutability::Not, ty);\n+        let loc = self.make_place(Mutability::Not, ty);\n \n         // `let ref_loc: &ty = &rcvr_field;`\n         let statement = self.make_statement(\n@@ -466,7 +466,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n     ) {\n         let tcx = self.tcx;\n \n-        let cond = self.make_lvalue(Mutability::Mut, tcx.types.bool);\n+        let cond = self.make_place(Mutability::Mut, tcx.types.bool);\n         let compute_cond = self.make_statement(\n             StatementKind::Assign(\n                 cond.clone(),\n@@ -502,8 +502,8 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         let rcvr = Place::Local(Local::new(1+0)).deref();\n \n         let beg = self.local_decls.push(temp_decl(Mutability::Mut, tcx.types.usize, span));\n-        let end = self.make_lvalue(Mutability::Not, tcx.types.usize);\n-        let ret = self.make_lvalue(Mutability::Mut, tcx.mk_array(ty, len));\n+        let end = self.make_place(Mutability::Not, tcx.types.usize);\n+        let ret = self.make_place(Mutability::Mut, tcx.mk_array(ty, len));\n \n         // BB #0\n         // `let mut beg = 0;`\n@@ -567,7 +567,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         // `return ret;`\n         let ret_statement = self.make_statement(\n             StatementKind::Assign(\n-                Place::Local(RETURN_POINTER),\n+                Place::Local(RETURN_PLACE),\n                 Rvalue::Use(Operand::Move(ret.clone())),\n             )\n         );\n@@ -663,7 +663,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         // `return kind(returns[0], returns[1], ..., returns[tys.len() - 1]);`\n         let ret_statement = self.make_statement(\n             StatementKind::Assign(\n-                Place::Local(RETURN_POINTER),\n+                Place::Local(RETURN_PLACE),\n                 Rvalue::Aggregate(\n                     box kind,\n                     returns.into_iter().map(Operand::Move).collect()\n@@ -749,8 +749,8 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     if let Some(untuple_args) = untuple_args {\n         args.extend(untuple_args.iter().enumerate().map(|(i, ity)| {\n-            let arg_lv = Place::Local(Local::new(1+1));\n-            Operand::Move(arg_lv.field(Field::new(i), *ity))\n+            let arg_place = Place::Local(Local::new(1+1));\n+            Operand::Move(arg_place.field(Field::new(i), *ity))\n         }));\n     } else {\n         args.extend((1..sig.inputs().len()).map(|i| {\n@@ -771,7 +771,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     block(&mut blocks, statements, TerminatorKind::Call {\n         func: callee,\n         args,\n-        destination: Some((Place::Local(RETURN_POINTER),\n+        destination: Some((Place::Local(RETURN_PLACE),\n                            BasicBlock::new(1))),\n         cleanup: if let Adjustment::RefMut = rcvr_adjustment {\n             Some(BasicBlock::new(3))\n@@ -864,7 +864,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n         statements: vec![Statement {\n             source_info,\n             kind: StatementKind::Assign(\n-                Place::Local(RETURN_POINTER),\n+                Place::Local(RETURN_PLACE),\n                 Rvalue::Aggregate(\n                     box AggregateKind::Adt(adt_def, variant_no, substs, None),\n                     (1..sig.inputs().len()+1).map(|i| {"}, {"sha": "f0f6add3f6f81c399bdb785eb8994aa44101e102", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -22,17 +22,17 @@ use transform::{MirPass, MirSource};\n \n pub struct AddValidation;\n \n-/// Determine the \"context\" of the lval: Mutability and region.\n-fn lval_context<'a, 'tcx, D>(\n-    lval: &Place<'tcx>,\n+/// Determine the \"context\" of the place: Mutability and region.\n+fn place_context<'a, 'tcx, D>(\n+    place: &Place<'tcx>,\n     local_decls: &D,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>\n ) -> (Option<region::Scope>, hir::Mutability)\n     where D: HasLocalDecls<'tcx>\n {\n     use rustc::mir::Place::*;\n \n-    match *lval {\n+    match *place {\n         Local { .. } => (None, hir::MutMutable),\n         Static(_) => (None, hir::MutImmutable),\n         Projection(ref proj) => {\n@@ -66,15 +66,15 @@ fn lval_context<'a, 'tcx, D>(\n                         // This is already as restricted as it gets, no need to even recurse\n                         context\n                     } else {\n-                        let base_context = lval_context(&proj.base, local_decls, tcx);\n+                        let base_context = place_context(&proj.base, local_decls, tcx);\n                         // The region of the outermost Deref is always most restrictive.\n                         let re = context.0.or(base_context.0);\n                         let mutbl = context.1.and(base_context.1);\n                         (re, mutbl)\n                     }\n \n                 }\n-                _ => lval_context(&proj.base, local_decls, tcx),\n+                _ => place_context(&proj.base, local_decls, tcx),\n             }\n         }\n     }\n@@ -198,11 +198,11 @@ impl MirPass for AddValidation {\n         let restricted_validation = emit_validate == 1 && fn_contains_unsafe(tcx, src);\n         let local_decls = mir.local_decls.clone(); // FIXME: Find a way to get rid of this clone.\n \n-        // Convert an lvalue to a validation operand.\n-        let lval_to_operand = |lval: Place<'tcx>| -> ValidationOperand<'tcx, Place<'tcx>> {\n-            let (re, mutbl) = lval_context(&lval, &local_decls, tcx);\n-            let ty = lval.ty(&local_decls, tcx).to_ty(tcx);\n-            ValidationOperand { lval, ty, re, mutbl }\n+        // Convert a place to a validation operand.\n+        let place_to_operand = |place: Place<'tcx>| -> ValidationOperand<'tcx, Place<'tcx>> {\n+            let (re, mutbl) = place_context(&place, &local_decls, tcx);\n+            let ty = place.ty(&local_decls, tcx).to_ty(tcx);\n+            ValidationOperand { place, ty, re, mutbl }\n         };\n \n         // Emit an Acquire at the beginning of the given block.  If we are in restricted emission\n@@ -237,7 +237,7 @@ impl MirPass for AddValidation {\n             };\n             // Gather all arguments, skip return value.\n             let operands = mir.local_decls.iter_enumerated().skip(1).take(mir.arg_count)\n-                    .map(|(local, _)| lval_to_operand(Place::Local(local))).collect();\n+                    .map(|(local, _)| place_to_operand(Place::Local(local))).collect();\n             emit_acquire(&mut mir.basic_blocks_mut()[START_BLOCK], source_info, operands);\n         }\n \n@@ -256,13 +256,13 @@ impl MirPass for AddValidation {\n                         let release_stmt = Statement {\n                             source_info,\n                             kind: StatementKind::Validate(ValidationOp::Release,\n-                                destination.iter().map(|dest| lval_to_operand(dest.0.clone()))\n+                                destination.iter().map(|dest| place_to_operand(dest.0.clone()))\n                                 .chain(\n                                     args.iter().filter_map(|op| {\n                                         match op {\n-                                            &Operand::Copy(ref lval) |\n-                                            &Operand::Move(ref lval) =>\n-                                                Some(lval_to_operand(lval.clone())),\n+                                            &Operand::Copy(ref place) |\n+                                            &Operand::Move(ref place) =>\n+                                                Some(place_to_operand(place.clone())),\n                                             &Operand::Constant(..) => { None },\n                                         }\n                                     })\n@@ -275,16 +275,16 @@ impl MirPass for AddValidation {\n                         returns.push((source_info, destination.0.clone(), destination.1));\n                     }\n                 }\n-                Some(Terminator { kind: TerminatorKind::Drop { location: ref lval, .. },\n+                Some(Terminator { kind: TerminatorKind::Drop { location: ref place, .. },\n                                   source_info }) |\n-                Some(Terminator { kind: TerminatorKind::DropAndReplace { location: ref lval, .. },\n+                Some(Terminator { kind: TerminatorKind::DropAndReplace { location: ref place, .. },\n                                   source_info }) => {\n                     // Before the call: Release all arguments\n                     if !restricted_validation {\n                         let release_stmt = Statement {\n                             source_info,\n                             kind: StatementKind::Validate(ValidationOp::Release,\n-                                    vec![lval_to_operand(lval.clone())]),\n+                                    vec![place_to_operand(place.clone())]),\n                         };\n                         block_data.statements.push(release_stmt);\n                     }\n@@ -296,11 +296,11 @@ impl MirPass for AddValidation {\n             }\n         }\n         // Now we go over the returns we collected to acquire the return values.\n-        for (source_info, dest_lval, dest_block) in returns {\n+        for (source_info, dest_place, dest_block) in returns {\n             emit_acquire(\n                 &mut mir.basic_blocks_mut()[dest_block],\n                 source_info,\n-                vec![lval_to_operand(dest_lval)]\n+                vec![place_to_operand(dest_place)]\n             );\n         }\n \n@@ -321,22 +321,20 @@ impl MirPass for AddValidation {\n                     StatementKind::Assign(_, Rvalue::Ref(_, _, _)) => {\n                         // Due to a lack of NLL; we can't capture anything directly here.\n                         // Instead, we have to re-match and clone there.\n-                        let (dest_lval, re, src_lval) = match block_data.statements[i].kind {\n-                            StatementKind::Assign(ref dest_lval,\n-                                                  Rvalue::Ref(re, _, ref src_lval)) => {\n-                                (dest_lval.clone(), re, src_lval.clone())\n+                        let (dest_place, re, src_place) = match block_data.statements[i].kind {\n+                            StatementKind::Assign(ref dest_place,\n+                                                  Rvalue::Ref(re, _, ref src_place)) => {\n+                                (dest_place.clone(), re, src_place.clone())\n                             },\n                             _ => bug!(\"We already matched this.\"),\n                         };\n                         // So this is a ref, and we got all the data we wanted.\n                         // Do an acquire of the result -- but only what it points to, so add a Deref\n                         // projection.\n-                        let dest_lval = Projection { base: dest_lval, elem: ProjectionElem::Deref };\n-                        let dest_lval = Place::Projection(Box::new(dest_lval));\n                         let acquire_stmt = Statement {\n                             source_info: block_data.statements[i].source_info,\n                             kind: StatementKind::Validate(ValidationOp::Acquire,\n-                                    vec![lval_to_operand(dest_lval)]),\n+                                    vec![place_to_operand(dest_place.deref())]),\n                         };\n                         block_data.statements.insert(i+1, acquire_stmt);\n \n@@ -349,7 +347,7 @@ impl MirPass for AddValidation {\n                         };\n                         let release_stmt = Statement {\n                             source_info: block_data.statements[i].source_info,\n-                            kind: StatementKind::Validate(op, vec![lval_to_operand(src_lval)]),\n+                            kind: StatementKind::Validate(op, vec![place_to_operand(src_place)]),\n                         };\n                         block_data.statements.insert(i, release_stmt);\n                     }\n@@ -360,13 +358,13 @@ impl MirPass for AddValidation {\n                     {\n                         // Due to a lack of NLL; we can't capture anything directly here.\n                         // Instead, we have to re-match and clone there.\n-                        let (dest_lval, src_lval) = match block_data.statements[i].kind {\n-                            StatementKind::Assign(ref dest_lval,\n-                                    Rvalue::Cast(_, Operand::Copy(ref src_lval), _)) |\n-                            StatementKind::Assign(ref dest_lval,\n-                                    Rvalue::Cast(_, Operand::Move(ref src_lval), _)) =>\n+                        let (dest_place, src_place) = match block_data.statements[i].kind {\n+                            StatementKind::Assign(ref dest_place,\n+                                    Rvalue::Cast(_, Operand::Copy(ref src_place), _)) |\n+                            StatementKind::Assign(ref dest_place,\n+                                    Rvalue::Cast(_, Operand::Move(ref src_place), _)) =>\n                             {\n-                                (dest_lval.clone(), src_lval.clone())\n+                                (dest_place.clone(), src_place.clone())\n                             },\n                             _ => bug!(\"We already matched this.\"),\n                         };\n@@ -375,15 +373,15 @@ impl MirPass for AddValidation {\n                         let acquire_stmt = Statement {\n                             source_info: block_data.statements[i].source_info,\n                             kind: StatementKind::Validate(ValidationOp::Acquire,\n-                                    vec![lval_to_operand(dest_lval)]),\n+                                    vec![place_to_operand(dest_place)]),\n                         };\n                         block_data.statements.insert(i+1, acquire_stmt);\n \n                         // Release of the input\n                         let release_stmt = Statement {\n                             source_info: block_data.statements[i].source_info,\n                             kind: StatementKind::Validate(ValidationOp::Release,\n-                                                            vec![lval_to_operand(src_lval)]),\n+                                                            vec![place_to_operand(src_place)]),\n                         };\n                         block_data.statements.insert(i, release_stmt);\n                     }"}, {"sha": "7833f4bbac7aaff50c3748e8611f5505cd4a2f90", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -135,12 +135,12 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n         self.super_rvalue(rvalue, location);\n     }\n \n-    fn visit_lvalue(&mut self,\n-                    lvalue: &Place<'tcx>,\n+    fn visit_place(&mut self,\n+                    place: &Place<'tcx>,\n                     context: PlaceContext<'tcx>,\n                     location: Location) {\n         if let PlaceContext::Borrow { .. } = context {\n-            if util::is_disaligned(self.tcx, self.mir, self.param_env, lvalue) {\n+            if util::is_disaligned(self.tcx, self.mir, self.param_env, place) {\n                 let source_info = self.source_info;\n                 let lint_root =\n                     self.visibility_scope_info[source_info.scope].lint_root;\n@@ -152,7 +152,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             }\n         }\n \n-        match lvalue {\n+        match place {\n             &Place::Projection(box Projection {\n                 ref base, ref elem\n             }) => {\n@@ -180,7 +180,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                                     _ => span_bug!(\n                                         self.source_info.span,\n                                         \"non-field projection {:?} from union?\",\n-                                        lvalue)\n+                                        place)\n                                 };\n                                 if elem_ty.moves_by_default(self.tcx, self.param_env,\n                                                             self.source_info.span) {\n@@ -216,7 +216,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 }\n             }\n         };\n-        self.super_lvalue(lvalue, context, location);\n+        self.super_place(place, context, location);\n     }\n }\n "}, {"sha": "6047b4e174a23216d668e116ba961b8e56f32534", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -108,8 +108,8 @@ impl MirPass for CopyPropagation {\n                             dest_local);\n                         continue;\n                     }\n-                    let dest_lvalue_def = dest_use_info.defs_not_including_drop().next().unwrap();\n-                    location = dest_lvalue_def.location;\n+                    let dest_place_def = dest_use_info.defs_not_including_drop().next().unwrap();\n+                    location = dest_place_def.location;\n \n                     let basic_block = &mir[location.block];\n                     let statement_index = location.statement_index;\n@@ -126,9 +126,9 @@ impl MirPass for CopyPropagation {\n                         StatementKind::Assign(Place::Local(local), Rvalue::Use(ref operand)) if\n                                 local == dest_local => {\n                             let maybe_action = match *operand {\n-                                Operand::Copy(ref src_lvalue) |\n-                                Operand::Move(ref src_lvalue) => {\n-                                    Action::local_copy(&mir, &def_use_analysis, src_lvalue)\n+                                Operand::Copy(ref src_place) |\n+                                Operand::Move(ref src_place) => {\n+                                    Action::local_copy(&mir, &def_use_analysis, src_place)\n                                 }\n                                 Operand::Constant(ref src_constant) => {\n                                     Action::constant(src_constant)\n@@ -202,10 +202,10 @@ enum Action<'tcx> {\n }\n \n impl<'tcx> Action<'tcx> {\n-    fn local_copy(mir: &Mir<'tcx>, def_use_analysis: &DefUseAnalysis, src_lvalue: &Place<'tcx>)\n+    fn local_copy(mir: &Mir<'tcx>, def_use_analysis: &DefUseAnalysis, src_place: &Place<'tcx>)\n                   -> Option<Action<'tcx>> {\n         // The source must be a local.\n-        let src_local = if let Place::Local(local) = *src_lvalue {\n+        let src_local = if let Place::Local(local) = *src_place {\n             local\n         } else {\n             debug!(\"  Can't copy-propagate local: source is not a local\");\n@@ -269,14 +269,14 @@ impl<'tcx> Action<'tcx> {\n                 debug!(\"  Replacing all uses of {:?} with {:?} (local)\",\n                        dest_local,\n                        src_local);\n-                for lvalue_use in &def_use_analysis.local_info(dest_local).defs_and_uses {\n-                    if lvalue_use.context.is_storage_marker() {\n-                        mir.make_statement_nop(lvalue_use.location)\n+                for place_use in &def_use_analysis.local_info(dest_local).defs_and_uses {\n+                    if place_use.context.is_storage_marker() {\n+                        mir.make_statement_nop(place_use.location)\n                     }\n                 }\n-                for lvalue_use in &def_use_analysis.local_info(src_local).defs_and_uses {\n-                    if lvalue_use.context.is_storage_marker() {\n-                        mir.make_statement_nop(lvalue_use.location)\n+                for place_use in &def_use_analysis.local_info(src_local).defs_and_uses {\n+                    if place_use.context.is_storage_marker() {\n+                        mir.make_statement_nop(place_use.location)\n                     }\n                 }\n \n@@ -297,22 +297,22 @@ impl<'tcx> Action<'tcx> {\n                        dest_local,\n                        src_constant);\n                 let dest_local_info = def_use_analysis.local_info(dest_local);\n-                for lvalue_use in &dest_local_info.defs_and_uses {\n-                    if lvalue_use.context.is_storage_marker() {\n-                        mir.make_statement_nop(lvalue_use.location)\n+                for place_use in &dest_local_info.defs_and_uses {\n+                    if place_use.context.is_storage_marker() {\n+                        mir.make_statement_nop(place_use.location)\n                     }\n                 }\n \n                 // Replace all uses of the destination local with the constant.\n                 let mut visitor = ConstantPropagationVisitor::new(dest_local,\n                                                                   src_constant);\n-                for dest_lvalue_use in &dest_local_info.defs_and_uses {\n-                    visitor.visit_location(mir, dest_lvalue_use.location)\n+                for dest_place_use in &dest_local_info.defs_and_uses {\n+                    visitor.visit_location(mir, dest_place_use.location)\n                 }\n \n                 // Zap the assignment instruction if we eliminated all the uses. We won't have been\n                 // able to do that if the destination was used in a projection, because projections\n-                // must have lvalues on their LHS.\n+                // must have places on their LHS.\n                 let use_count = dest_local_info.use_count();\n                 if visitor.uses_replaced == use_count {\n                     debug!(\"  {} of {} use(s) replaced; deleting assignment\","}, {"sha": "eccb0d231b89d4a5f2d3d4bceadb934a2340988f", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -92,7 +92,7 @@ impl MirPass for Deaggregator {\n                 if adt_def.is_enum() {\n                     let set_discriminant = Statement {\n                         kind: StatementKind::SetDiscriminant {\n-                            lvalue: lhs.clone(),\n+                            place: lhs.clone(),\n                             variant_index: variant,\n                         },\n                         source_info: src_info,"}, {"sha": "cb79fc8d7eb27e360337c5b51ba39fa62a92c9ee", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -358,7 +358,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             });\n \n             let path = self.move_data().rev_lookup.find(location);\n-            debug!(\"collect_drop_flags: {:?}, lv {:?} ({:?})\",\n+            debug!(\"collect_drop_flags: {:?}, place {:?} ({:?})\",\n                    bb, location, path);\n \n             let path = match path {\n@@ -368,7 +368,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                     let (_maybe_live, maybe_dead) = init_data.state(parent);\n                     if maybe_dead {\n                         span_bug!(terminator.source_info.span,\n-                                  \"drop of untracked, uninitialized value {:?}, lv {:?} ({:?})\",\n+                                  \"drop of untracked, uninitialized value {:?}, place {:?} ({:?})\",\n                                   bb, location, path);\n                     }\n                     continue\n@@ -443,7 +443,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     /// The desugaring drops the location if needed, and then writes\n     /// the value (including setting the drop flag) over it in *both* arms.\n     ///\n-    /// The `replace` terminator can also be called on lvalues that\n+    /// The `replace` terminator can also be called on places that\n     /// are not tracked by elaboration (for example,\n     /// `replace x[i] <- tmp0`). The borrow checker requires that\n     /// these locations are initialized before the assignment,\n@@ -554,12 +554,12 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn drop_flags_for_fn_rets(&mut self) {\n         for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n             if let TerminatorKind::Call {\n-                destination: Some((ref lv, tgt)), cleanup: Some(_), ..\n+                destination: Some((ref place, tgt)), cleanup: Some(_), ..\n             } = data.terminator().kind {\n                 assert!(!self.patch.is_patched(bb));\n \n                 let loc = Location { block: tgt, statement_index: 0 };\n-                let path = self.move_data().rev_lookup.find(lv);\n+                let path = self.move_data().rev_lookup.find(place);\n                 on_lookup_result_bits(\n                     self.tcx, self.mir, self.move_data(), path,\n                     |child| self.set_drop_flag(loc, child, DropFlagState::Present)\n@@ -628,12 +628,12 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             // so mark the return as initialized *before* the\n             // call.\n             if let TerminatorKind::Call {\n-                destination: Some((ref lv, _)), cleanup: None, ..\n+                destination: Some((ref place, _)), cleanup: None, ..\n             } = data.terminator().kind {\n                 assert!(!self.patch.is_patched(bb));\n \n                 let loc = Location { block: bb, statement_index: data.statements.len() };\n-                let path = self.move_data().rev_lookup.find(lv);\n+                let path = self.move_data().rev_lookup.find(place);\n                 on_lookup_result_bits(\n                     self.tcx, self.mir, self.move_data(), path,\n                     |child| self.set_drop_flag(loc, child, DropFlagState::Present)"}, {"sha": "aaa28634eb82c99d56fa16116c8e38f77cfdfdf3", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -108,17 +108,17 @@ impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n         assert_ne!(*local, self_arg());\n     }\n \n-    fn visit_lvalue(&mut self,\n-                    lvalue: &mut Place<'tcx>,\n+    fn visit_place(&mut self,\n+                    place: &mut Place<'tcx>,\n                     context: PlaceContext<'tcx>,\n                     location: Location) {\n-        if *lvalue == Place::Local(self_arg()) {\n-            *lvalue = Place::Projection(Box::new(Projection {\n-                base: lvalue.clone(),\n+        if *place == Place::Local(self_arg()) {\n+            *place = Place::Projection(Box::new(Projection {\n+                base: place.clone(),\n                 elem: ProjectionElem::Deref,\n             }));\n         } else {\n-            self.super_lvalue(lvalue, context, location);\n+            self.super_place(place, context, location);\n         }\n     }\n }\n@@ -151,7 +151,7 @@ struct TransformVisitor<'a, 'tcx: 'a> {\n     // A list of suspension points, generated during the transform\n     suspension_points: Vec<SuspensionPoint>,\n \n-    // The original RETURN_POINTER local\n+    // The original RETURN_PLACE local\n     new_ret_local: Local,\n }\n \n@@ -200,17 +200,17 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n         assert_eq!(self.remap.get(local), None);\n     }\n \n-    fn visit_lvalue(&mut self,\n-                    lvalue: &mut Place<'tcx>,\n+    fn visit_place(&mut self,\n+                    place: &mut Place<'tcx>,\n                     context: PlaceContext<'tcx>,\n                     location: Location) {\n-        if let Place::Local(l) = *lvalue {\n+        if let Place::Local(l) = *place {\n             // Replace an Local in the remap with a generator struct access\n             if let Some(&(ty, idx)) = self.remap.get(&l) {\n-                *lvalue = self.make_field(idx, ty);\n+                *place = self.make_field(idx, ty);\n             }\n         } else {\n-            self.super_lvalue(lvalue, context, location);\n+            self.super_place(place, context, location);\n         }\n     }\n \n@@ -244,7 +244,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n             // We must assign the value first in case it gets declared dead below\n             data.statements.push(Statement {\n                 source_info,\n-                kind: StatementKind::Assign(Place::Local(RETURN_POINTER),\n+                kind: StatementKind::Assign(Place::Local(RETURN_PLACE),\n                     self.make_state(state_idx, v)),\n             });\n             let state = if let Some(resume) = resume { // Yield\n@@ -310,7 +310,7 @@ fn replace_result_variable<'tcx>(ret_ty: Ty<'tcx>,\n     mir.local_decls.swap(0, new_ret_local.index());\n \n     RenameLocalVisitor {\n-        from: RETURN_POINTER,\n+        from: RETURN_PLACE,\n         to: new_ret_local,\n     }.visit_mir(mir);\n \n@@ -557,7 +557,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n     }\n \n     // Replace the return variable\n-    mir.local_decls[RETURN_POINTER] = LocalDecl {\n+    mir.local_decls[RETURN_PLACE] = LocalDecl {\n         mutability: Mutability::Mut,\n         ty: tcx.mk_nil(),\n         name: None,\n@@ -783,8 +783,8 @@ impl MirPass for StateTransform {\n             Kind::from(mir.return_ty())].iter());\n         let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n \n-        // We rename RETURN_POINTER which has type mir.return_ty to new_ret_local\n-        // RETURN_POINTER then is a fresh unused local with type ret_ty.\n+        // We rename RETURN_PLACE which has type mir.return_ty to new_ret_local\n+        // RETURN_PLACE then is a fresh unused local with type ret_ty.\n         let new_ret_local = replace_result_variable(ret_ty, mir);\n \n         // Extract locals which are live across suspension point into `layout`"}, {"sha": "7216384795278915cf5d256500729916824c074a", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -406,9 +406,9 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 // `i : &mut usize`, then just duplicating the `a[*i]`\n                 // Place could result in two different locations if `f`\n                 // writes to `i`. To prevent this we need to create a temporary\n-                // borrow of the lvalue and pass the destination as `*temp` instead.\n-                fn dest_needs_borrow(lval: &Place) -> bool {\n-                    match *lval {\n+                // borrow of the place and pass the destination as `*temp` instead.\n+                fn dest_needs_borrow(place: &Place) -> bool {\n+                    match *place {\n                         Place::Projection(ref p) => {\n                             match p.elem {\n                                 ProjectionElem::Deref |\n@@ -456,8 +456,8 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     // needs to generate the cast.\n                     // FIXME: we should probably just generate correct MIR in the first place...\n \n-                    let arg = if let Operand::Move(ref lval) = args[0] {\n-                        lval.clone()\n+                    let arg = if let Operand::Move(ref place) = args[0] {\n+                        place.clone()\n                     } else {\n                         bug!(\"Constant arg to \\\"box_free\\\"\");\n                     };\n@@ -715,13 +715,13 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                    local: &mut Local,\n                    _ctxt: PlaceContext<'tcx>,\n                    _location: Location) {\n-        if *local == RETURN_POINTER {\n+        if *local == RETURN_PLACE {\n             match self.destination {\n                 Place::Local(l) => {\n                     *local = l;\n                     return;\n                 },\n-                ref lval => bug!(\"Return lvalue is {:?}, not local\", lval)\n+                ref place => bug!(\"Return place is {:?}, not local\", place)\n             }\n         }\n         let idx = local.index() - 1;\n@@ -732,15 +732,15 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n         *local = self.local_map[Local::new(idx - self.args.len())];\n     }\n \n-    fn visit_lvalue(&mut self,\n-                    lvalue: &mut Place<'tcx>,\n+    fn visit_place(&mut self,\n+                    place: &mut Place<'tcx>,\n                     _ctxt: PlaceContext<'tcx>,\n                     _location: Location) {\n-        if let Place::Local(RETURN_POINTER) = *lvalue {\n-            // Return pointer; update the lvalue itself\n-            *lvalue = self.destination.clone();\n+        if let Place::Local(RETURN_PLACE) = *place {\n+            // Return pointer; update the place itself\n+            *place = self.destination.clone();\n         } else {\n-            self.super_lvalue(lvalue, _ctxt, _location);\n+            self.super_place(place, _ctxt, _location);\n         }\n     }\n "}, {"sha": "8856d263864cd19380ea19cdeef0e2a189d8e7c1", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -52,14 +52,14 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n         if self.optimizations.and_stars.remove(&location) {\n             debug!(\"Replacing `&*`: {:?}\", rvalue);\n-            let new_lvalue = match *rvalue {\n+            let new_place = match *rvalue {\n                 Rvalue::Ref(_, _, Place::Projection(ref mut projection)) => {\n                     // Replace with dummy\n                     mem::replace(&mut projection.base, Place::Local(Local::new(0)))\n                 }\n                 _ => bug!(\"Detected `&*` but didn't find `&*`!\"),\n             };\n-            *rvalue = Rvalue::Use(Operand::Copy(new_lvalue))\n+            *rvalue = Rvalue::Use(Operand::Copy(new_place))\n         }\n \n         if let Some(constant) = self.optimizations.arrays_lengths.remove(&location) {\n@@ -98,9 +98,9 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n             }\n         }\n \n-        if let Rvalue::Len(ref lvalue) = *rvalue {\n-            let lvalue_ty = lvalue.ty(&self.mir.local_decls, self.tcx).to_ty(self.tcx);\n-            if let TypeVariants::TyArray(_, len) = lvalue_ty.sty {\n+        if let Rvalue::Len(ref place) = *rvalue {\n+            let place_ty = place.ty(&self.mir.local_decls, self.tcx).to_ty(self.tcx);\n+            if let TypeVariants::TyArray(_, len) = place_ty.sty {\n                 let span = self.mir.source_info(location).span;\n                 let ty = self.tcx.types.usize;\n                 let literal = Literal::Value { value: len };"}, {"sha": "7027d827c84f5caf1404c53a3b620dc098f0ffb4", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -75,19 +75,19 @@ impl Lower128Bit {\n                 };\n \n                 let bin_statement = block.statements.pop().unwrap();\n-                let (source_info, lvalue, lhs, mut rhs) = match bin_statement {\n+                let (source_info, place, lhs, mut rhs) = match bin_statement {\n                     Statement {\n                         source_info,\n                         kind: StatementKind::Assign(\n-                            lvalue,\n+                            place,\n                             Rvalue::BinaryOp(_, lhs, rhs))\n-                    } => (source_info, lvalue, lhs, rhs),\n+                    } => (source_info, place, lhs, rhs),\n                     Statement {\n                         source_info,\n                         kind: StatementKind::Assign(\n-                            lvalue,\n+                            place,\n                             Rvalue::CheckedBinaryOp(_, lhs, rhs))\n-                    } => (source_info, lvalue, lhs, rhs),\n+                    } => (source_info, place, lhs, rhs),\n                     _ => bug!(\"Statement doesn't match pattern any more?\"),\n                 };\n \n@@ -109,7 +109,7 @@ impl Lower128Bit {\n                 }\n \n                 let call_did = check_lang_item_type(\n-                    lang_item, &lvalue, &lhs, &rhs, local_decls, tcx);\n+                    lang_item, &place, &lhs, &rhs, local_decls, tcx);\n \n                 let bb = BasicBlock::new(cur_len + new_blocks.len());\n                 new_blocks.push(after_call);\n@@ -121,7 +121,7 @@ impl Lower128Bit {\n                             func: Operand::function_handle(tcx, call_did,\n                                 Slice::empty(), source_info.span),\n                             args: vec![lhs, rhs],\n-                            destination: Some((lvalue, bb)),\n+                            destination: Some((place, bb)),\n                             cleanup: None,\n                         },\n                     });\n@@ -134,7 +134,7 @@ impl Lower128Bit {\n \n fn check_lang_item_type<'a, 'tcx, D>(\n     lang_item: LangItem,\n-    lvalue: &Place<'tcx>,\n+    place: &Place<'tcx>,\n     lhs: &Operand<'tcx>,\n     rhs: &Operand<'tcx>,\n     local_decls: &D,\n@@ -147,8 +147,8 @@ fn check_lang_item_type<'a, 'tcx, D>(\n     let sig = tcx.no_late_bound_regions(&poly_sig).unwrap();\n     let lhs_ty = lhs.ty(local_decls, tcx);\n     let rhs_ty = rhs.ty(local_decls, tcx);\n-    let lvalue_ty = lvalue.ty(local_decls, tcx).to_ty(tcx);\n-    let expected = [lhs_ty, rhs_ty, lvalue_ty];\n+    let place_ty = place.ty(local_decls, tcx).to_ty(tcx);\n+    let expected = [lhs_ty, rhs_ty, place_ty];\n     assert_eq!(sig.inputs_and_output[..], expected,\n         \"lang item {}\", tcx.def_symbol_name(did));\n     did"}, {"sha": "73d5a610dbd537ac8e2e2353ad3f34629b386e50", "filename": "src/librustc_mir/transform/nll/constraint_generation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -189,9 +189,9 @@ impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n         &mut self,\n         location: Location,\n         borrow_region: ty::Region<'tcx>,\n-        borrowed_lv: &Place<'tcx>,\n+        borrowed_place: &Place<'tcx>,\n     ) {\n-        if let Projection(ref proj) = *borrowed_lv {\n+        if let Projection(ref proj) = *borrowed_place {\n             let PlaceProjection { ref base, ref elem } = **proj;\n \n             if let ProjectionElem::Deref = *elem {\n@@ -232,8 +232,8 @@ impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cx, 'gcx, 'tcx> {\n         // where L is the path that is borrowed. In that case, we have\n         // to add the reborrow constraints (which don't fall out\n         // naturally from the type-checker).\n-        if let Rvalue::Ref(region, _bk, ref borrowed_lv) = *rvalue {\n-            self.add_reborrow_constraint(location, region, borrowed_lv);\n+        if let Rvalue::Ref(region, _bk, ref borrowed_place) = *rvalue {\n+            self.add_reborrow_constraint(location, region, borrowed_place);\n         }\n \n         self.super_rvalue(rvalue, location);"}, {"sha": "1e5b0bc1392bcf30eb722c893a50f0230b6c3bba", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -316,7 +316,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             statement_index: usize::MAX\n         });\n \n-        self.assign(RETURN_POINTER, rvalue, span);\n+        self.assign(RETURN_PLACE, rvalue, span);\n         self.source.promoted.push(self.promoted);\n     }\n }\n@@ -373,8 +373,8 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n             }\n         };\n \n-        // Declare return pointer local\n-        let initial_locals = iter::once(LocalDecl::new_return_pointer(ty, span))\n+        // Declare return place local\n+        let initial_locals = iter::once(LocalDecl::new_return_place(ty, span))\n             .collect();\n \n         let mut promoter = Promoter {"}, {"sha": "b9b86dd6e840fddd1900fa01bdeb6a1b14c92380", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -51,7 +51,7 @@ bitflags! {\n         // Function argument.\n         const FN_ARGUMENT       = 1 << 2;\n \n-        // Static lvalue or move from a static.\n+        // Static place or move from a static.\n         const STATIC            = 1 << 3;\n \n         // Reference to a static.\n@@ -261,7 +261,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                 store(&mut self.temp_qualif[index])\n             }\n             Place::Local(index) if self.mir.local_kind(index) == LocalKind::ReturnPointer => {\n-                debug!(\"store to return pointer {:?}\", index);\n+                debug!(\"store to return place {:?}\", index);\n                 store(&mut self.return_qualif)\n             }\n \n@@ -280,7 +280,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             // This must be an explicit assignment.\n             _ => {\n                 // Catch more errors in the destination.\n-                self.visit_lvalue(dest, PlaceContext::Store, location);\n+                self.visit_place(dest, PlaceContext::Store, location);\n                 self.statement_like();\n             }\n         }\n@@ -438,11 +438,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n         }\n     }\n \n-    fn visit_lvalue(&mut self,\n-                    lvalue: &Place<'tcx>,\n+    fn visit_place(&mut self,\n+                    place: &Place<'tcx>,\n                     context: PlaceContext<'tcx>,\n                     location: Location) {\n-        match *lvalue {\n+        match *place {\n             Place::Local(ref local) => self.visit_local(local, context, location),\n             Place::Static(ref global) => {\n                 self.add(Qualif::STATIC);\n@@ -467,7 +467,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             }\n             Place::Projection(ref proj) => {\n                 self.nest(|this| {\n-                    this.super_lvalue(lvalue, context, location);\n+                    this.super_place(place, context, location);\n                     match proj.elem {\n                         ProjectionElem::Deref => {\n                             if !this.try_consume() {\n@@ -502,7 +502,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                           \"cannot refer to the interior of another \\\n                                            static, use a constant instead\");\n                             }\n-                            let ty = lvalue.ty(this.mir, this.tcx).to_ty(this.tcx);\n+                            let ty = place.ty(this.mir, this.tcx).to_ty(this.tcx);\n                             this.qualif.restrict(ty, this.tcx, this.param_env);\n                         }\n \n@@ -519,15 +519,15 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n     fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n         match *operand {\n-            Operand::Copy(ref lvalue) |\n-            Operand::Move(ref lvalue) => {\n+            Operand::Copy(ref place) |\n+            Operand::Move(ref place) => {\n                 self.nest(|this| {\n                     this.super_operand(operand, location);\n                     this.try_consume();\n                 });\n \n                 // Mark the consumed locals to indicate later drops are noops.\n-                if let Place::Local(local) = *lvalue {\n+                if let Place::Local(local) = *place {\n                     self.local_needs_drop[local] = None;\n                 }\n             }\n@@ -555,7 +555,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n     }\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-        // Recurse through operands and lvalues.\n+        // Recurse through operands and places.\n         self.super_rvalue(rvalue, location);\n \n         match *rvalue {\n@@ -572,20 +572,20 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             Rvalue::Discriminant(..) => {}\n \n             Rvalue::Len(_) => {\n-                // Static lvalues in consts would have errored already,\n+                // Static places in consts would have errored already,\n                 // don't treat length checks as reads from statics.\n                 self.qualif = self.qualif - Qualif::STATIC;\n             }\n \n-            Rvalue::Ref(_, kind, ref lvalue) => {\n-                // Static lvalues in consts would have errored already,\n+            Rvalue::Ref(_, kind, ref place) => {\n+                // Static places in consts would have errored already,\n                 // only keep track of references to them here.\n                 if self.qualif.intersects(Qualif::STATIC) {\n                     self.qualif = self.qualif - Qualif::STATIC;\n                     self.add(Qualif::STATIC_REF);\n                 }\n \n-                let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n                 if kind == BorrowKind::Mut {\n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n@@ -635,7 +635,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 let candidate = Candidate::Ref(location);\n                 if !self.qualif.intersects(Qualif::NEVER_PROMOTE) {\n                     // We can only promote direct borrows of temps.\n-                    if let Place::Local(local) = *lvalue {\n+                    if let Place::Local(local) = *place {\n                         if self.mir.local_kind(local) == LocalKind::Temp {\n                             self.promotion_candidates.push(candidate);\n                         }\n@@ -829,22 +829,22 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n                 self.assign(dest, location);\n             }\n-        } else if let TerminatorKind::Drop { location: ref lvalue, .. } = *kind {\n+        } else if let TerminatorKind::Drop { location: ref place, .. } = *kind {\n             self.super_terminator_kind(bb, kind, location);\n \n             // Deny *any* live drops anywhere other than functions.\n             if self.mode != Mode::Fn {\n                 // HACK(eddyb) Emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n-                let needs_drop = if let Place::Local(local) = *lvalue {\n+                let needs_drop = if let Place::Local(local) = *place {\n                     self.local_needs_drop[local]\n                 } else {\n                     None\n                 };\n \n                 if let Some(span) = needs_drop {\n                     // Double-check the type being dropped, to minimize false positives.\n-                    let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n                     if ty.needs_drop(self.tcx, self.param_env) {\n                         struct_span_err!(self.tcx.sess, span, E0493,\n                                          \"destructors cannot be evaluated at compile-time\")\n@@ -905,8 +905,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n         self.nest(|this| {\n             this.visit_source_info(&statement.source_info);\n             match statement.kind {\n-                StatementKind::Assign(ref lvalue, ref rvalue) => {\n-                    this.visit_assign(bb, lvalue, rvalue, location);\n+                StatementKind::Assign(ref place, ref rvalue) => {\n+                    this.visit_assign(bb, place, rvalue, location);\n                 }\n                 StatementKind::SetDiscriminant { .. } |\n                 StatementKind::StorageLive(_) |"}, {"sha": "08508143976e61aaeed3779cb5200c8e549011f3", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -123,13 +123,13 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         None => return,\n     };\n     assert!(args.len() == 1);\n-    let peek_arg_lval = match args[0] {\n-        mir::Operand::Copy(ref lval @ mir::Place::Local(_)) |\n-        mir::Operand::Move(ref lval @ mir::Place::Local(_)) => Some(lval),\n+    let peek_arg_place = match args[0] {\n+        mir::Operand::Copy(ref place @ mir::Place::Local(_)) |\n+        mir::Operand::Move(ref place @ mir::Place::Local(_)) => Some(place),\n         _ => None,\n     };\n \n-    let peek_arg_lval = match peek_arg_lval {\n+    let peek_arg_place = match peek_arg_place {\n         Some(arg) => arg,\n         None => {\n             tcx.sess.diagnostic().span_err(\n@@ -143,8 +143,8 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut kill = results.0.sets.kill_set_for(bb.index()).to_owned();\n \n     // Emulate effect of all statements in the block up to (but not\n-    // including) the borrow within `peek_arg_lval`. Do *not* include\n-    // call to `peek_arg_lval` itself (since we are peeking the state\n+    // including) the borrow within `peek_arg_place`. Do *not* include\n+    // call to `peek_arg_place` itself (since we are peeking the state\n     // of the argument at time immediate preceding Call to\n     // `rustc_peek`).\n \n@@ -154,9 +154,9 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     for (j, stmt) in statements.iter().enumerate() {\n         debug!(\"rustc_peek: ({:?},{}) {:?}\", bb, j, stmt);\n-        let (lvalue, rvalue) = match stmt.kind {\n-            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n-                (lvalue, rvalue)\n+        let (place, rvalue) = match stmt.kind {\n+            mir::StatementKind::Assign(ref place, ref rvalue) => {\n+                (place, rvalue)\n             }\n             mir::StatementKind::StorageLive(_) |\n             mir::StatementKind::StorageDead(_) |\n@@ -169,14 +169,14 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           \"sanity_check should run before Deaggregator inserts SetDiscriminant\"),\n         };\n \n-        if lvalue == peek_arg_lval {\n-            if let mir::Rvalue::Ref(_, mir::BorrowKind::Shared, ref peeking_at_lval) = *rvalue {\n+        if place == peek_arg_place {\n+            if let mir::Rvalue::Ref(_, mir::BorrowKind::Shared, ref peeking_at_place) = *rvalue {\n                 // Okay, our search is over.\n-                match move_data.rev_lookup.find(peeking_at_lval) {\n+                match move_data.rev_lookup.find(peeking_at_place) {\n                     LookupResult::Exact(peek_mpi) => {\n                         let bit_state = sets.on_entry.contains(&peek_mpi);\n                         debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n-                               lvalue, peeking_at_lval, bit_state);\n+                               place, peeking_at_place, bit_state);\n                         if !bit_state {\n                             tcx.sess.span_err(span, \"rustc_peek: bit not set\");\n                         }\n@@ -196,10 +196,10 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         }\n \n-        let lhs_mpi = move_data.rev_lookup.find(lvalue);\n+        let lhs_mpi = move_data.rev_lookup.find(place);\n \n-        debug!(\"rustc_peek: computing effect on lvalue: {:?} ({:?}) in stmt: {:?}\",\n-               lvalue, lhs_mpi, stmt);\n+        debug!(\"rustc_peek: computing effect on place: {:?} ({:?}) in stmt: {:?}\",\n+               place, lhs_mpi, stmt);\n         // reset GEN and KILL sets before emulating their effect.\n         for e in sets.gen_set.words_mut() { *e = 0; }\n         for e in sets.kill_set.words_mut() { *e = 0; }"}, {"sha": "3b41b2545bf5597714751f3cec4aacb4f2c59308", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -104,13 +104,13 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_lvalue(\n+    fn visit_place(\n         &mut self,\n-        lvalue: &Place<'tcx>,\n+        place: &Place<'tcx>,\n         context: PlaceContext,\n         location: Location,\n     ) {\n-        self.sanitize_lvalue(lvalue, location, context);\n+        self.sanitize_place(place, location, context);\n     }\n \n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n@@ -164,26 +164,26 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn sanitize_lvalue(&mut self,\n-                       lvalue: &Place<'tcx>,\n+    fn sanitize_place(&mut self,\n+                       place: &Place<'tcx>,\n                        location: Location,\n                        context: PlaceContext)\n                        -> PlaceTy<'tcx> {\n-        debug!(\"sanitize_lvalue: {:?}\", lvalue);\n-        let lvalue_ty = match *lvalue {\n+        debug!(\"sanitize_place: {:?}\", place);\n+        let place_ty = match *place {\n             Place::Local(index) => PlaceTy::Ty {\n                 ty: self.mir.local_decls[index].ty,\n             },\n             Place::Static(box Static { def_id, ty: sty }) => {\n-                let sty = self.sanitize_type(lvalue, sty);\n+                let sty = self.sanitize_type(place, sty);\n                 let ty = self.tcx().type_of(def_id);\n                 let ty = self.cx.normalize(&ty, location);\n                 if let Err(terr) = self.cx\n                     .eq_types(self.last_span, ty, sty, location.at_self())\n                 {\n                     span_mirbug!(\n                         self,\n-                        lvalue,\n+                        place,\n                         \"bad static type ({:?}: {:?}): {:?}\",\n                         ty,\n                         sty,\n@@ -198,7 +198,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 } else {\n                     PlaceContext::Projection(Mutability::Not)\n                 };\n-                let base_ty = self.sanitize_lvalue(&proj.base, location, base_context);\n+                let base_ty = self.sanitize_place(&proj.base, location, base_context);\n                 if let PlaceTy::Ty { ty } = base_ty {\n                     if ty.references_error() {\n                         assert!(self.errors_reported);\n@@ -207,27 +207,27 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         };\n                     }\n                 }\n-                self.sanitize_projection(base_ty, &proj.elem, lvalue, location)\n+                self.sanitize_projection(base_ty, &proj.elem, place, location)\n             }\n         };\n         if let PlaceContext::Copy = context {\n-            let ty = lvalue_ty.to_ty(self.tcx());\n+            let ty = place_ty.to_ty(self.tcx());\n             if self.cx.infcx.type_moves_by_default(self.cx.param_env, ty, DUMMY_SP) {\n-                span_mirbug!(self, lvalue,\n+                span_mirbug!(self, place,\n                              \"attempted copy of non-Copy type ({:?})\", ty);\n             }\n         }\n-        lvalue_ty\n+        place_ty\n     }\n \n     fn sanitize_projection(\n         &mut self,\n         base: PlaceTy<'tcx>,\n         pi: &PlaceElem<'tcx>,\n-        lvalue: &Place<'tcx>,\n+        place: &Place<'tcx>,\n         location: Location,\n     ) -> PlaceTy<'tcx> {\n-        debug!(\"sanitize_projection: {:?} {:?} {:?}\", base, pi, lvalue);\n+        debug!(\"sanitize_projection: {:?} {:?} {:?}\", base, pi, place);\n         let tcx = self.tcx();\n         let base_ty = base.to_ty(tcx);\n         let span = self.last_span;\n@@ -236,7 +236,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 let deref_ty = base_ty.builtin_deref(true, ty::LvaluePreference::NoPreference);\n                 PlaceTy::Ty {\n                     ty: deref_ty.map(|t| t.ty).unwrap_or_else(|| {\n-                        span_mirbug_and_err!(self, lvalue, \"deref of non-pointer {:?}\", base_ty)\n+                        span_mirbug_and_err!(self, place, \"deref of non-pointer {:?}\", base_ty)\n                     }),\n                 }\n             }\n@@ -249,7 +249,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 } else {\n                     PlaceTy::Ty {\n                         ty: base_ty.builtin_index().unwrap_or_else(|| {\n-                            span_mirbug_and_err!(self, lvalue, \"index of non-array {:?}\", base_ty)\n+                            span_mirbug_and_err!(self, place, \"index of non-array {:?}\", base_ty)\n                         }),\n                     }\n                 }\n@@ -258,7 +258,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 // consider verifying in-bounds\n                 PlaceTy::Ty {\n                     ty: base_ty.builtin_index().unwrap_or_else(|| {\n-                        span_mirbug_and_err!(self, lvalue, \"index of non-array {:?}\", base_ty)\n+                        span_mirbug_and_err!(self, place, \"index of non-array {:?}\", base_ty)\n                     }),\n                 }\n             }\n@@ -272,14 +272,14 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         } else {\n                             span_mirbug_and_err!(\n                                 self,\n-                                lvalue,\n+                                place,\n                                 \"taking too-small slice of {:?}\",\n                                 base_ty\n                             )\n                         }\n                     }\n                     ty::TySlice(..) => base_ty,\n-                    _ => span_mirbug_and_err!(self, lvalue, \"slice of non-array {:?}\", base_ty),\n+                    _ => span_mirbug_and_err!(self, place, \"slice of non-array {:?}\", base_ty),\n                 },\n             },\n             ProjectionElem::Downcast(adt_def1, index) => match base_ty.sty {\n@@ -288,7 +288,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         PlaceTy::Ty {\n                             ty: span_mirbug_and_err!(\n                                 self,\n-                                lvalue,\n+                                place,\n                                 \"cast to variant #{:?} but enum only has {:?}\",\n                                 index,\n                                 adt_def.variants.len()\n@@ -305,21 +305,21 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 _ => PlaceTy::Ty {\n                     ty: span_mirbug_and_err!(\n                         self,\n-                        lvalue,\n+                        place,\n                         \"can't downcast {:?} as {:?}\",\n                         base_ty,\n                         adt_def1\n                     ),\n                 },\n             },\n             ProjectionElem::Field(field, fty) => {\n-                let fty = self.sanitize_type(lvalue, fty);\n-                match self.field_ty(lvalue, base, field, location) {\n+                let fty = self.sanitize_type(place, fty);\n+                match self.field_ty(place, base, field, location) {\n                     Ok(ty) => {\n                         if let Err(terr) = self.cx.eq_types(span, ty, fty, location.at_self()) {\n                             span_mirbug!(\n                                 self,\n-                                lvalue,\n+                                place,\n                                 \"bad field access ({:?}: {:?}): {:?}\",\n                                 ty,\n                                 fty,\n@@ -329,7 +329,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     }\n                     Err(FieldAccessError::OutOfRange { field_count }) => span_mirbug!(\n                         self,\n-                        lvalue,\n+                        place,\n                         \"accessed field #{} but variant only has {}\",\n                         field.index(),\n                         field_count\n@@ -551,35 +551,35 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         debug!(\"check_stmt: {:?}\", stmt);\n         let tcx = self.tcx();\n         match stmt.kind {\n-            StatementKind::Assign(ref lv, ref rv) => {\n-                let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n+            StatementKind::Assign(ref place, ref rv) => {\n+                let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n                 if let Err(terr) =\n-                    self.sub_types(rv_ty, lv_ty, location.at_successor_within_block())\n+                    self.sub_types(rv_ty, place_ty, location.at_successor_within_block())\n                 {\n                     span_mirbug!(\n                         self,\n                         stmt,\n                         \"bad assignment ({:?} = {:?}): {:?}\",\n-                        lv_ty,\n+                        place_ty,\n                         rv_ty,\n                         terr\n                     );\n                 }\n                 self.check_rvalue(mir, rv, location);\n             }\n             StatementKind::SetDiscriminant {\n-                ref lvalue,\n+                ref place,\n                 variant_index,\n             } => {\n-                let lvalue_type = lvalue.ty(mir, tcx).to_ty(tcx);\n-                let adt = match lvalue_type.sty {\n+                let place_type = place.ty(mir, tcx).to_ty(tcx);\n+                let adt = match place_type.sty {\n                     TypeVariants::TyAdt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n                         span_bug!(\n                             stmt.source_info.span,\n                             \"bad set discriminant ({:?} = {:?}): lhs is not an enum\",\n-                            lvalue,\n+                            place,\n                             variant_index\n                         );\n                     }\n@@ -588,7 +588,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     span_bug!(\n                         stmt.source_info.span,\n                         \"bad set discriminant ({:?} = {:?}): value of of range\",\n-                        lvalue,\n+                        place,\n                         variant_index\n                     );\n                 };\n@@ -627,19 +627,19 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 target,\n                 unwind,\n             } => {\n-                let lv_ty = location.ty(mir, tcx).to_ty(tcx);\n+                let place_ty = location.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = value.ty(mir, tcx);\n \n                 let locations = Locations {\n                     from_location: term_location,\n                     at_location: target.start_location(),\n                 };\n-                if let Err(terr) = self.sub_types(rv_ty, lv_ty, locations) {\n+                if let Err(terr) = self.sub_types(rv_ty, place_ty, locations) {\n                     span_mirbug!(\n                         self,\n                         term,\n                         \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n-                        lv_ty,\n+                        place_ty,\n                         rv_ty,\n                         terr\n                     );\n@@ -653,12 +653,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         from_location: term_location,\n                         at_location: unwind.start_location(),\n                     };\n-                    if let Err(terr) = self.sub_types(rv_ty, lv_ty, locations) {\n+                    if let Err(terr) = self.sub_types(rv_ty, place_ty, locations) {\n                         span_mirbug!(\n                             self,\n                             term,\n                             \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n-                            lv_ty,\n+                            place_ty,\n                             rv_ty,\n                             terr\n                         );\n@@ -1209,8 +1209,8 @@ trait AtLocation {\n     /// its successor within the block is the at-location. This means\n     /// that any required region relationships must hold only upon\n     /// **exiting** the statement/terminator indicated by `self`. This\n-    /// is for example used when you have a `lv = rv` statement: it\n-    /// indicates that the `typeof(rv) <: typeof(lv)` as of the\n+    /// is for example used when you have a `place = rv` statement: it\n+    /// indicates that the `typeof(rv) <: typeof(place)` as of the\n     /// **next** statement.\n     fn at_successor_within_block(self) -> Locations;\n }"}, {"sha": "d1410210bda96e8653e7e09a1ec53397a8223daa", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -12,47 +12,47 @@\n use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n \n-/// Return `true` if this lvalue is allowed to be less aligned\n+/// Return `true` if this place is allowed to be less aligned\n /// than its containing struct (because it is within a packed\n /// struct).\n pub fn is_disaligned<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   local_decls: &L,\n                                   param_env: ty::ParamEnv<'tcx>,\n-                                  lvalue: &Place<'tcx>)\n+                                  place: &Place<'tcx>)\n                                   -> bool\n     where L: HasLocalDecls<'tcx>\n {\n-    debug!(\"is_disaligned({:?})\", lvalue);\n-    if !is_within_packed(tcx, local_decls, lvalue) {\n-        debug!(\"is_disaligned({:?}) - not within packed\", lvalue);\n+    debug!(\"is_disaligned({:?})\", place);\n+    if !is_within_packed(tcx, local_decls, place) {\n+        debug!(\"is_disaligned({:?}) - not within packed\", place);\n         return false\n     }\n \n-    let ty = lvalue.ty(local_decls, tcx).to_ty(tcx);\n+    let ty = place.ty(local_decls, tcx).to_ty(tcx);\n     match tcx.layout_raw(param_env.and(ty)) {\n         Ok(layout) if layout.align.abi() == 1 => {\n             // if the alignment is 1, the type can't be further\n             // disaligned.\n-            debug!(\"is_disaligned({:?}) - align = 1\", lvalue);\n+            debug!(\"is_disaligned({:?}) - align = 1\", place);\n             false\n         }\n         _ => {\n-            debug!(\"is_disaligned({:?}) - true\", lvalue);\n+            debug!(\"is_disaligned({:?}) - true\", place);\n             true\n         }\n     }\n }\n \n fn is_within_packed<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  local_decls: &L,\n-                                 lvalue: &Place<'tcx>)\n+                                 place: &Place<'tcx>)\n                                  -> bool\n     where L: HasLocalDecls<'tcx>\n {\n-    let mut lvalue = lvalue;\n+    let mut place = place;\n     while let &Place::Projection(box Projection {\n         ref base, ref elem\n-    }) = lvalue {\n+    }) = place {\n         match *elem {\n             // encountered a Deref, which is ABI-aligned\n             ProjectionElem::Deref => break,\n@@ -67,7 +67,7 @@ fn is_within_packed<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n             _ => {}\n         }\n-        lvalue = base;\n+        place = base;\n     }\n \n     false"}, {"sha": "07de346e795f92375b3783f57bc102a371afb97b", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -64,10 +64,10 @@ impl<'tcx> DefUseAnalysis<'tcx> {\n                                where F: for<'a> FnMut(&'a mut Local,\n                                                       PlaceContext<'tcx>,\n                                                       Location) {\n-        for lvalue_use in &self.info[local].defs_and_uses {\n+        for place_use in &self.info[local].defs_and_uses {\n             MutateUseVisitor::new(local,\n                                   &mut callback,\n-                                  mir).visit_location(mir, lvalue_use.location)\n+                                  mir).visit_location(mir, place_use.location)\n         }\n     }\n \n@@ -108,7 +108,7 @@ impl<'tcx> Info<'tcx> {\n     }\n \n     pub fn def_count(&self) -> usize {\n-        self.defs_and_uses.iter().filter(|lvalue_use| lvalue_use.context.is_mutating_use()).count()\n+        self.defs_and_uses.iter().filter(|place_use| place_use.context.is_mutating_use()).count()\n     }\n \n     pub fn def_count_not_including_drop(&self) -> usize {\n@@ -118,14 +118,14 @@ impl<'tcx> Info<'tcx> {\n     pub fn defs_not_including_drop(\n         &self,\n     ) -> iter::Filter<slice::Iter<Use<'tcx>>, fn(&&Use<'tcx>) -> bool> {\n-        self.defs_and_uses.iter().filter(|lvalue_use| {\n-            lvalue_use.context.is_mutating_use() && !lvalue_use.context.is_drop()\n+        self.defs_and_uses.iter().filter(|place_use| {\n+            place_use.context.is_mutating_use() && !place_use.context.is_drop()\n         })\n     }\n \n     pub fn use_count(&self) -> usize {\n-        self.defs_and_uses.iter().filter(|lvalue_use| {\n-            lvalue_use.context.is_nonmutating_use()\n+        self.defs_and_uses.iter().filter(|place_use| {\n+            place_use.context.is_nonmutating_use()\n         }).count()\n     }\n }"}, {"sha": "e7d1e5a9ccc74c1834e7e8e1352ed231f9a50f07", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -105,7 +105,7 @@ struct DropCtxt<'l, 'b: 'l, 'tcx: 'b, D>\n \n     source_info: SourceInfo,\n \n-    lvalue: &'l Place<'tcx>,\n+    place: &'l Place<'tcx>,\n     path: D::Path,\n     succ: BasicBlock,\n     unwind: Unwind,\n@@ -114,23 +114,23 @@ struct DropCtxt<'l, 'b: 'l, 'tcx: 'b, D>\n pub fn elaborate_drop<'b, 'tcx, D>(\n     elaborator: &mut D,\n     source_info: SourceInfo,\n-    lvalue: &Place<'tcx>,\n+    place: &Place<'tcx>,\n     path: D::Path,\n     succ: BasicBlock,\n     unwind: Unwind,\n     bb: BasicBlock)\n     where D: DropElaborator<'b, 'tcx>\n {\n     DropCtxt {\n-        elaborator, source_info, lvalue, path, succ, unwind\n+        elaborator, source_info, place, path, succ, unwind\n     }.elaborate_drop(bb)\n }\n \n impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     where D: DropElaborator<'b, 'tcx>\n {\n-    fn lvalue_ty(&self, lvalue: &Place<'tcx>) -> Ty<'tcx> {\n-        lvalue.ty(self.elaborator.mir(), self.tcx()).to_ty(self.tcx())\n+    fn place_ty(&self, place: &Place<'tcx>) -> Ty<'tcx> {\n+        place.ty(self.elaborator.mir(), self.tcx()).to_ty(self.tcx())\n     }\n \n     fn tcx(&self) -> TyCtxt<'b, 'tcx, 'tcx> {\n@@ -169,7 +169,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 let loc = self.terminator_loc(bb);\n                 self.elaborator.clear_drop_flag(loc, self.path, DropFlagMode::Deep);\n                 self.elaborator.patch().patch_terminator(bb, TerminatorKind::Drop {\n-                    location: self.lvalue.clone(),\n+                    location: self.place.clone(),\n                     target: self.succ,\n                     unwind: self.unwind.into_option(),\n                 });\n@@ -191,10 +191,10 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         }\n     }\n \n-    /// Return the lvalue and move path for each field of `variant`,\n+    /// Return the place and move path for each field of `variant`,\n     /// (the move path is `None` if the field is a rest field).\n     fn move_paths_for_fields(&self,\n-                             base_lv: &Place<'tcx>,\n+                             base_place: &Place<'tcx>,\n                              variant_path: D::Path,\n                              variant: &'tcx ty::VariantDef,\n                              substs: &'tcx Substs<'tcx>)\n@@ -209,32 +209,32 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                     &f.ty(self.tcx(), substs),\n                     self.elaborator.param_env()\n                 );\n-            (base_lv.clone().field(field, field_ty), subpath)\n+            (base_place.clone().field(field, field_ty), subpath)\n         }).collect()\n     }\n \n     fn drop_subpath(&mut self,\n-                    lvalue: &Place<'tcx>,\n+                    place: &Place<'tcx>,\n                     path: Option<D::Path>,\n                     succ: BasicBlock,\n                     unwind: Unwind)\n                     -> BasicBlock\n     {\n         if let Some(path) = path {\n-            debug!(\"drop_subpath: for std field {:?}\", lvalue);\n+            debug!(\"drop_subpath: for std field {:?}\", place);\n \n             DropCtxt {\n                 elaborator: self.elaborator,\n                 source_info: self.source_info,\n-                path, lvalue, succ, unwind,\n+                path, place, succ, unwind,\n             }.elaborated_drop_block()\n         } else {\n-            debug!(\"drop_subpath: for rest field {:?}\", lvalue);\n+            debug!(\"drop_subpath: for rest field {:?}\", place);\n \n             DropCtxt {\n                 elaborator: self.elaborator,\n                 source_info: self.source_info,\n-                lvalue, succ, unwind,\n+                place, succ, unwind,\n                 // Using `self.path` here to condition the drop on\n                 // our own drop flag.\n                 path: self.path\n@@ -256,8 +256,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     {\n         Some(succ).into_iter().chain(\n             fields.iter().rev().zip(unwind_ladder)\n-                .map(|(&(ref lv, path), &unwind_succ)| {\n-                    succ = self.drop_subpath(lv, path, succ, unwind_succ);\n+                .map(|(&(ref place, path), &unwind_succ)| {\n+                    succ = self.drop_subpath(place, path, succ, unwind_succ);\n                     succ\n                 })\n         ).collect()\n@@ -302,8 +302,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         debug!(\"drop_ladder({:?}, {:?})\", self, fields);\n \n         let mut fields = fields;\n-        fields.retain(|&(ref lvalue, _)| {\n-            self.lvalue_ty(lvalue).needs_drop(self.tcx(), self.elaborator.param_env())\n+        fields.retain(|&(ref place, _)| {\n+            self.place_ty(place).needs_drop(self.tcx(), self.elaborator.param_env())\n         });\n \n         debug!(\"drop_ladder - fields needing drop: {:?}\", fields);\n@@ -328,7 +328,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         debug!(\"open_drop_for_tuple({:?}, {:?})\", self, tys);\n \n         let fields = tys.iter().enumerate().map(|(i, &ty)| {\n-            (self.lvalue.clone().field(Field::new(i), ty),\n+            (self.place.clone().field(Field::new(i), ty),\n              self.elaborator.field_subpath(self.path, Field::new(i)))\n         }).collect();\n \n@@ -340,7 +340,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     {\n         debug!(\"open_drop_for_box({:?}, {:?})\", self, ty);\n \n-        let interior = self.lvalue.clone().deref();\n+        let interior = self.place.clone().deref();\n         let interior_path = self.elaborator.deref_subpath(self.path);\n \n         let succ = self.succ; // FIXME(#6393)\n@@ -386,7 +386,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let (succ, unwind) = self.drop_ladder_bottom();\n         if !adt.is_enum() {\n             let fields = self.move_paths_for_fields(\n-                self.lvalue,\n+                self.place,\n                 self.path,\n                 &adt.variants[0],\n                 substs\n@@ -416,11 +416,11 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             let subpath = self.elaborator.downcast_subpath(\n                 self.path, variant_index);\n             if let Some(variant_path) = subpath {\n-                let base_lv = self.lvalue.clone().elem(\n+                let base_place = self.place.clone().elem(\n                     ProjectionElem::Downcast(adt, variant_index)\n                         );\n                 let fields = self.move_paths_for_fields(\n-                    &base_lv,\n+                    &base_place,\n                     variant_path,\n                     &adt.variants[variant_index],\n                     substs);\n@@ -492,7 +492,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         // way lies only trouble.\n         let discr_ty = adt.repr.discr_type().to_ty(self.tcx());\n         let discr = Place::Local(self.new_temp(discr_ty));\n-        let discr_rv = Rvalue::Discriminant(self.lvalue.clone());\n+        let discr_rv = Rvalue::Discriminant(self.place.clone());\n         let switch_block = BasicBlockData {\n             statements: vec![self.assign(&discr, discr_rv)],\n             terminator: Some(Terminator {\n@@ -517,26 +517,26 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let tcx = self.tcx();\n         let drop_trait = tcx.lang_items().drop_trait().unwrap();\n         let drop_fn = tcx.associated_items(drop_trait).next().unwrap();\n-        let ty = self.lvalue_ty(self.lvalue);\n+        let ty = self.place_ty(self.place);\n         let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n \n         let ref_ty = tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n             ty,\n             mutbl: hir::Mutability::MutMutable\n         });\n-        let ref_lvalue = self.new_temp(ref_ty);\n+        let ref_place = self.new_temp(ref_ty);\n         let unit_temp = Place::Local(self.new_temp(tcx.mk_nil()));\n \n         let result = BasicBlockData {\n             statements: vec![self.assign(\n-                &Place::Local(ref_lvalue),\n-                Rvalue::Ref(tcx.types.re_erased, BorrowKind::Mut, self.lvalue.clone())\n+                &Place::Local(ref_place),\n+                Rvalue::Ref(tcx.types.re_erased, BorrowKind::Mut, self.place.clone())\n             )],\n             terminator: Some(Terminator {\n                 kind: TerminatorKind::Call {\n                     func: Operand::function_handle(tcx, drop_fn.def_id, substs,\n                                                    self.source_info.span),\n-                    args: vec![Operand::Move(Place::Local(ref_lvalue))],\n+                    args: vec![Operand::Move(Place::Local(ref_place))],\n                     destination: Some((unit_temp, succ)),\n                     cleanup: unwind.into_option(),\n                 },\n@@ -572,8 +572,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                  ptr_based: bool)\n                  -> BasicBlock\n     {\n-        let copy = |lv: &Place<'tcx>| Operand::Copy(lv.clone());\n-        let move_ = |lv: &Place<'tcx>| Operand::Move(lv.clone());\n+        let copy = |place: &Place<'tcx>| Operand::Copy(place.clone());\n+        let move_ = |place: &Place<'tcx>| Operand::Move(place.clone());\n         let tcx = self.tcx();\n \n         let ref_ty = tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n@@ -591,7 +591,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             (Rvalue::Ref(\n                  tcx.types.re_erased,\n                  BorrowKind::Mut,\n-                 self.lvalue.clone().index(cur)),\n+                 self.place.clone().index(cur)),\n              Rvalue::BinaryOp(BinOp::Add, copy(&Place::Local(cur)), one))\n         };\n \n@@ -643,7 +643,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         let tcx = self.tcx();\n \n-        let move_ = |lv: &Place<'tcx>| Operand::Move(lv.clone());\n+        let move_ = |place: &Place<'tcx>| Operand::Move(place.clone());\n         let size = &Place::Local(self.new_temp(tcx.types.usize));\n         let size_is_zero = &Place::Local(self.new_temp(tcx.types.bool));\n         let base_block = BasicBlockData {\n@@ -667,7 +667,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         self.elaborator.patch().new_block(base_block)\n     }\n \n-    // create a pair of drop-loops of `lvalue`, which drops its contents\n+    // create a pair of drop-loops of `place`, which drops its contents\n     // even in the case of 1 panic. If `ptr_based`, create a pointer loop,\n     // otherwise create an index loop.\n     fn drop_loop_pair(&mut self, ety: Ty<'tcx>, ptr_based: bool) -> BasicBlock {\n@@ -708,15 +708,15 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let cur = Place::Local(cur);\n         let zero = self.constant_usize(0);\n         let mut drop_block_stmts = vec![];\n-        drop_block_stmts.push(self.assign(&length, Rvalue::Len(self.lvalue.clone())));\n+        drop_block_stmts.push(self.assign(&length, Rvalue::Len(self.place.clone())));\n         if ptr_based {\n-            let tmp_ty = tcx.mk_mut_ptr(self.lvalue_ty(self.lvalue));\n+            let tmp_ty = tcx.mk_mut_ptr(self.place_ty(self.place));\n             let tmp = Place::Local(self.new_temp(tmp_ty));\n             // tmp = &LV;\n             // cur = tmp as *mut T;\n             // end = Offset(cur, len);\n             drop_block_stmts.push(self.assign(&tmp, Rvalue::Ref(\n-                tcx.types.re_erased, BorrowKind::Mut, self.lvalue.clone()\n+                tcx.types.re_erased, BorrowKind::Mut, self.place.clone()\n             )));\n             drop_block_stmts.push(self.assign(&cur, Rvalue::Cast(\n                 CastKind::Misc, Operand::Move(tmp.clone()), iter_ty\n@@ -752,7 +752,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     /// This creates a \"drop ladder\" that drops the needed fields of the\n     /// ADT, both in the success case or if one of the destructors fail.\n     fn open_drop<'a>(&mut self) -> BasicBlock {\n-        let ty = self.lvalue_ty(self.lvalue);\n+        let ty = self.place_ty(self.place);\n         match ty.sty {\n             ty::TyClosure(def_id, substs) |\n             // Note that `elaborate_drops` only drops the upvars of a generator,\n@@ -786,13 +786,13 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         }\n     }\n \n-    /// Return a basic block that drop an lvalue using the context\n+    /// Return a basic block that drop a place using the context\n     /// and path in `c`. If `mode` is something, also clear `c`\n     /// according to it.\n     ///\n     /// if FLAG(self.path)\n     ///     if let Some(mode) = mode: FLAG(self.path)[mode] = false\n-    ///     drop(self.lv)\n+    ///     drop(self.place)\n     fn complete_drop<'a>(&mut self,\n                          drop_mode: Option<DropFlagMode>,\n                          succ: BasicBlock,\n@@ -855,7 +855,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         let call = TerminatorKind::Call {\n             func: Operand::function_handle(tcx, free_func, substs, self.source_info.span),\n-            args: vec![Operand::Move(self.lvalue.clone())],\n+            args: vec![Operand::Move(self.place.clone())],\n             destination: Some((unit_temp, target)),\n             cleanup: None\n         }; // FIXME(#6393)\n@@ -868,7 +868,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n     fn drop_block<'a>(&mut self, target: BasicBlock, unwind: Unwind) -> BasicBlock {\n         let block = TerminatorKind::Drop {\n-            location: self.lvalue.clone(),\n+            location: self.place.clone(),\n             target,\n             unwind: unwind.into_option()\n         };"}, {"sha": "9da593fb48e3bb858fe1817098e69b63c1b31c61", "filename": "src/librustc_mir/util/patch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -127,8 +127,8 @@ impl<'tcx> MirPatch<'tcx> {\n         self.new_statements.push((loc, stmt));\n     }\n \n-    pub fn add_assign(&mut self, loc: Location, lv: Place<'tcx>, rv: Rvalue<'tcx>) {\n-        self.add_statement(loc, StatementKind::Assign(lv, rv));\n+    pub fn add_assign(&mut self, loc: Location, place: Place<'tcx>, rv: Rvalue<'tcx>) {\n+        self.add_statement(loc, StatementKind::Assign(place, rv));\n     }\n \n     pub fn apply(self, mir: &mut Mir<'tcx>) {"}, {"sha": "4a0090204851c55d1fe8dbe40f10b440471a2637", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -344,12 +344,12 @@ pub fn write_mir_intro<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         }\n     }\n \n-    // Print return pointer\n+    // Print return place\n     let indented_retptr = format!(\"{}let mut {:?}: {};\",\n                                   INDENT,\n-                                  RETURN_POINTER,\n-                                  mir.local_decls[RETURN_POINTER].ty);\n-    writeln!(w, \"{0:1$} // return pointer\",\n+                                  RETURN_PLACE,\n+                                  mir.local_decls[RETURN_PLACE].ty);\n+    writeln!(w, \"{0:1$} // return place\",\n              indented_retptr,\n              ALIGN)?;\n "}, {"sha": "8a9936ecb8bb4fe9a483531bbb07c701cab9df22", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -188,41 +188,41 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_operand(operand, location);\n     }\n \n-    fn visit_lvalue(&mut self,\n-                    lvalue: &Place<'tcx>,\n+    fn visit_place(&mut self,\n+                    place: &Place<'tcx>,\n                     context: mir_visit::PlaceContext<'tcx>,\n                     location: Location) {\n-        self.record(\"Place\", lvalue);\n-        self.record(match *lvalue {\n+        self.record(\"Place\", place);\n+        self.record(match *place {\n             Place::Local(..) => \"Place::Local\",\n             Place::Static(..) => \"Place::Static\",\n             Place::Projection(..) => \"Place::Projection\",\n-        }, lvalue);\n-        self.super_lvalue(lvalue, context, location);\n+        }, place);\n+        self.super_place(place, context, location);\n     }\n \n     fn visit_projection(&mut self,\n-                        lvalue: &PlaceProjection<'tcx>,\n+                        place: &PlaceProjection<'tcx>,\n                         context: mir_visit::PlaceContext<'tcx>,\n                         location: Location) {\n-        self.record(\"PlaceProjection\", lvalue);\n-        self.super_projection(lvalue, context, location);\n+        self.record(\"PlaceProjection\", place);\n+        self.super_projection(place, context, location);\n     }\n \n     fn visit_projection_elem(&mut self,\n-                             lvalue: &PlaceElem<'tcx>,\n+                             place: &PlaceElem<'tcx>,\n                              context: mir_visit::PlaceContext<'tcx>,\n                              location: Location) {\n-        self.record(\"PlaceElem\", lvalue);\n-        self.record(match *lvalue {\n+        self.record(\"PlaceElem\", place);\n+        self.record(match *place {\n             ProjectionElem::Deref => \"PlaceElem::Deref\",\n             ProjectionElem::Subslice { .. } => \"PlaceElem::Subslice\",\n             ProjectionElem::Field(..) => \"PlaceElem::Field\",\n             ProjectionElem::Index(..) => \"PlaceElem::Index\",\n             ProjectionElem::ConstantIndex { .. } => \"PlaceElem::ConstantIndex\",\n             ProjectionElem::Downcast(..) => \"PlaceElem::Downcast\",\n-        }, lvalue);\n-        self.super_projection_elem(lvalue, context, location);\n+        }, place);\n+        self.super_projection_elem(place, context, location);\n     }\n \n     fn visit_constant(&mut self,"}, {"sha": "834558fc16614825af9dd3dde7684502fcde389b", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -30,7 +30,7 @@ use cabi_sparc64;\n use cabi_nvptx;\n use cabi_nvptx64;\n use cabi_hexagon;\n-use mir::lvalue::{Alignment, PlaceRef};\n+use mir::place::{Alignment, PlaceRef};\n use mir::operand::OperandValue;\n use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n@@ -545,14 +545,14 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         self.mode == PassMode::Ignore\n     }\n \n-    /// Get the LLVM type for an lvalue of the original Rust type of\n+    /// Get the LLVM type for an place of the original Rust type of\n     /// this argument/return, i.e. the result of `type_of::type_of`.\n     pub fn memory_ty(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n         self.layout.llvm_type(ccx)\n     }\n \n     /// Store a direct/indirect value described by this ArgType into a\n-    /// lvalue for the original Rust type of this argument/return.\n+    /// place for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n     pub fn store(&self, bcx: &Builder<'a, 'tcx>, val: ValueRef, dst: PlaceRef<'tcx>) {"}, {"sha": "ef76fece088fe24af69d2ad116ab6677a6c6adc7", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -18,7 +18,7 @@ use builder::Builder;\n \n use rustc::hir;\n \n-use mir::lvalue::PlaceRef;\n+use mir::place::PlaceRef;\n use mir::operand::OperandValue;\n \n use std::ffi::CString;\n@@ -37,15 +37,15 @@ pub fn trans_inline_asm<'a, 'tcx>(\n \n     // Prepare the output operands\n     let mut indirect_outputs = vec![];\n-    for (i, (out, lvalue)) in ia.outputs.iter().zip(&outputs).enumerate() {\n+    for (i, (out, place)) in ia.outputs.iter().zip(&outputs).enumerate() {\n         if out.is_rw {\n-            inputs.push(lvalue.load(bcx).immediate());\n+            inputs.push(place.load(bcx).immediate());\n             ext_constraints.push(i.to_string());\n         }\n         if out.is_indirect {\n-            indirect_outputs.push(lvalue.load(bcx).immediate());\n+            indirect_outputs.push(place.load(bcx).immediate());\n         } else {\n-            output_types.push(lvalue.layout.llvm_type(bcx.ccx));\n+            output_types.push(place.layout.llvm_type(bcx.ccx));\n         }\n     }\n     if !indirect_outputs.is_empty() {\n@@ -100,9 +100,9 @@ pub fn trans_inline_asm<'a, 'tcx>(\n \n     // Again, based on how many outputs we have\n     let outputs = ia.outputs.iter().zip(&outputs).filter(|&(ref o, _)| !o.is_indirect);\n-    for (i, (_, &lvalue)) in outputs.enumerate() {\n+    for (i, (_, &place)) in outputs.enumerate() {\n         let v = if num_outputs == 1 { r } else { bcx.extract_value(r, i as u64) };\n-        OperandValue::Immediate(v).store(bcx, lvalue);\n+        OperandValue::Immediate(v).store(bcx, place);\n     }\n \n     // Store mark in a metadata node so we can map LLVM errors"}, {"sha": "43e7938e98c78575855dec84f9f086a4b474e30f", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -50,7 +50,7 @@ use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n use rustc_incremental;\n use allocator;\n-use mir::lvalue::PlaceRef;\n+use mir::place::PlaceRef;\n use attributes;\n use builder::Builder;\n use callee;"}, {"sha": "a35afb806111c4b807fd43e1da9cf103b6968ee5", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -14,7 +14,7 @@ use intrinsics::{self, Intrinsic};\n use llvm;\n use llvm::{ValueRef};\n use abi::{Abi, FnType, PassMode};\n-use mir::lvalue::{PlaceRef, Alignment};\n+use mir::place::{PlaceRef, Alignment};\n use mir::operand::{OperandRef, OperandValue};\n use base::*;\n use common::*;"}, {"sha": "b5e5dd3b9ce166c1ad6f779a58b7870f0a4643d8", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -22,7 +22,7 @@ use rustc::ty::layout::LayoutOf;\n use type_of::LayoutLlvmExt;\n use super::MirContext;\n \n-pub fn lvalue_locals<'a, 'tcx>(mircx: &MirContext<'a, 'tcx>) -> BitVector {\n+pub fn memory_locals<'a, 'tcx>(mircx: &MirContext<'a, 'tcx>) -> BitVector {\n     let mir = mircx.mir;\n     let mut analyzer = LocalAnalyzer::new(mircx);\n \n@@ -44,24 +44,24 @@ pub fn lvalue_locals<'a, 'tcx>(mircx: &MirContext<'a, 'tcx>) -> BitVector {\n             // (e.g. structs) into an alloca unconditionally, just so\n             // that we don't have to deal with having two pathways\n             // (gep vs extractvalue etc).\n-            analyzer.mark_as_lvalue(mir::Local::new(index));\n+            analyzer.mark_as_memory(mir::Local::new(index));\n         }\n     }\n \n-    analyzer.lvalue_locals\n+    analyzer.memory_locals\n }\n \n struct LocalAnalyzer<'mir, 'a: 'mir, 'tcx: 'a> {\n     cx: &'mir MirContext<'a, 'tcx>,\n-    lvalue_locals: BitVector,\n+    memory_locals: BitVector,\n     seen_assigned: BitVector\n }\n \n impl<'mir, 'a, 'tcx> LocalAnalyzer<'mir, 'a, 'tcx> {\n     fn new(mircx: &'mir MirContext<'a, 'tcx>) -> LocalAnalyzer<'mir, 'a, 'tcx> {\n         let mut analyzer = LocalAnalyzer {\n             cx: mircx,\n-            lvalue_locals: BitVector::new(mircx.mir.local_decls.len()),\n+            memory_locals: BitVector::new(mircx.mir.local_decls.len()),\n             seen_assigned: BitVector::new(mircx.mir.local_decls.len())\n         };\n \n@@ -73,33 +73,33 @@ impl<'mir, 'a, 'tcx> LocalAnalyzer<'mir, 'a, 'tcx> {\n         analyzer\n     }\n \n-    fn mark_as_lvalue(&mut self, local: mir::Local) {\n-        debug!(\"marking {:?} as lvalue\", local);\n-        self.lvalue_locals.insert(local.index());\n+    fn mark_as_memory(&mut self, local: mir::Local) {\n+        debug!(\"marking {:?} as memory\", local);\n+        self.memory_locals.insert(local.index());\n     }\n \n     fn mark_assigned(&mut self, local: mir::Local) {\n         if !self.seen_assigned.insert(local.index()) {\n-            self.mark_as_lvalue(local);\n+            self.mark_as_memory(local);\n         }\n     }\n }\n \n impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n     fn visit_assign(&mut self,\n                     block: mir::BasicBlock,\n-                    lvalue: &mir::Place<'tcx>,\n+                    place: &mir::Place<'tcx>,\n                     rvalue: &mir::Rvalue<'tcx>,\n                     location: Location) {\n-        debug!(\"visit_assign(block={:?}, lvalue={:?}, rvalue={:?})\", block, lvalue, rvalue);\n+        debug!(\"visit_assign(block={:?}, place={:?}, rvalue={:?})\", block, place, rvalue);\n \n-        if let mir::Place::Local(index) = *lvalue {\n+        if let mir::Place::Local(index) = *place {\n             self.mark_assigned(index);\n             if !self.cx.rvalue_creates_operand(rvalue) {\n-                self.mark_as_lvalue(index);\n+                self.mark_as_memory(index);\n             }\n         } else {\n-            self.visit_lvalue(lvalue, PlaceContext::Store, location);\n+            self.visit_place(place, PlaceContext::Store, location);\n         }\n \n         self.visit_rvalue(rvalue, location);\n@@ -121,8 +121,8 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                 // box_free(x) shares with `drop x` the property that it\n                 // is not guaranteed to be statically dominated by the\n                 // definition of x, so x must always be in an alloca.\n-                if let mir::Operand::Move(ref lvalue) = args[0] {\n-                    self.visit_lvalue(lvalue, PlaceContext::Drop, location);\n+                if let mir::Operand::Move(ref place) = args[0] {\n+                    self.visit_place(place, PlaceContext::Drop, location);\n                 }\n             }\n             _ => {}\n@@ -131,14 +131,14 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n         self.super_terminator_kind(block, kind, location);\n     }\n \n-    fn visit_lvalue(&mut self,\n-                    lvalue: &mir::Place<'tcx>,\n+    fn visit_place(&mut self,\n+                    place: &mir::Place<'tcx>,\n                     context: PlaceContext<'tcx>,\n                     location: Location) {\n-        debug!(\"visit_lvalue(lvalue={:?}, context={:?})\", lvalue, context);\n+        debug!(\"visit_place(place={:?}, context={:?})\", place, context);\n         let ccx = self.cx.ccx;\n \n-        if let mir::Place::Projection(ref proj) = *lvalue {\n+        if let mir::Place::Projection(ref proj) = *place {\n             // Allow uses of projections that are ZSTs or from scalar fields.\n             let is_consume = match context {\n                 PlaceContext::Copy | PlaceContext::Move => true,\n@@ -160,20 +160,20 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                     if layout.is_llvm_immediate() || layout.is_llvm_scalar_pair() {\n                         // Recurse with the same context, instead of `Projection`,\n                         // potentially stopping at non-operand projections,\n-                        // which would trigger `mark_as_lvalue` on locals.\n-                        self.visit_lvalue(&proj.base, context, location);\n+                        // which would trigger `mark_as_memory` on locals.\n+                        self.visit_place(&proj.base, context, location);\n                         return;\n                     }\n                 }\n             }\n \n-            // A deref projection only reads the pointer, never needs the lvalue.\n+            // A deref projection only reads the pointer, never needs the place.\n             if let mir::ProjectionElem::Deref = proj.elem {\n-                return self.visit_lvalue(&proj.base, PlaceContext::Copy, location);\n+                return self.visit_place(&proj.base, PlaceContext::Copy, location);\n             }\n         }\n \n-        self.super_lvalue(lvalue, context, location);\n+        self.super_place(place, context, location);\n     }\n \n     fn visit_local(&mut self,\n@@ -195,16 +195,16 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n             PlaceContext::Store |\n             PlaceContext::Borrow { .. } |\n             PlaceContext::Projection(..) => {\n-                self.mark_as_lvalue(index);\n+                self.mark_as_memory(index);\n             }\n \n             PlaceContext::Drop => {\n                 let ty = mir::Place::Local(index).ty(self.cx.mir, self.cx.ccx.tcx());\n                 let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n \n-                // Only need the lvalue if we're actually dropping it.\n+                // Only need the place if we're actually dropping it.\n                 if self.cx.ccx.shared().type_needs_drop(ty) {\n-                    self.mark_as_lvalue(index);\n+                    self.mark_as_memory(index);\n                 }\n             }\n         }"}, {"sha": "94c8d469c642d6c947e42bd68d32e085c93a4c27", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -31,7 +31,7 @@ use syntax_pos::Pos;\n \n use super::{MirContext, LocalRef};\n use super::constant::Const;\n-use super::lvalue::{Alignment, PlaceRef};\n+use super::place::{Alignment, PlaceRef};\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n@@ -214,7 +214,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     }\n \n                     PassMode::Direct(_) | PassMode::Pair(..) => {\n-                        let op = self.trans_consume(&bcx, &mir::Place::Local(mir::RETURN_POINTER));\n+                        let op = self.trans_consume(&bcx, &mir::Place::Local(mir::RETURN_PLACE));\n                         if let Ref(llval, align) = op.val {\n                             bcx.load(llval, align.non_abi())\n                         } else {\n@@ -223,13 +223,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     }\n \n                     PassMode::Cast(cast_ty) => {\n-                        let op = match self.locals[mir::RETURN_POINTER] {\n+                        let op = match self.locals[mir::RETURN_PLACE] {\n                             LocalRef::Operand(Some(op)) => op,\n                             LocalRef::Operand(None) => bug!(\"use of return before def\"),\n-                            LocalRef::Place(tr_lvalue) => {\n+                            LocalRef::Place(tr_place) => {\n                                 OperandRef {\n-                                    val: Ref(tr_lvalue.llval, tr_lvalue.alignment),\n-                                    layout: tr_lvalue.layout\n+                                    val: Ref(tr_place.llval, tr_place.alignment),\n+                                    layout: tr_place.layout\n                                 }\n                             }\n                         };\n@@ -241,7 +241,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             }\n                             Ref(llval, align) => {\n                                 assert_eq!(align, Alignment::AbiAligned,\n-                                           \"return pointer is unaligned!\");\n+                                           \"return place is unaligned!\");\n                                 llval\n                             }\n                         };\n@@ -268,17 +268,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     return\n                 }\n \n-                let lvalue = self.trans_lvalue(&bcx, location);\n-                let mut args: &[_] = &[lvalue.llval, lvalue.llextra];\n-                args = &args[..1 + lvalue.has_extra() as usize];\n+                let place = self.trans_place(&bcx, location);\n+                let mut args: &[_] = &[place.llval, place.llextra];\n+                args = &args[..1 + place.has_extra() as usize];\n                 let (drop_fn, fn_ty) = match ty.sty {\n                     ty::TyDynamic(..) => {\n                         let fn_ty = common::instance_ty(bcx.ccx.tcx(), &drop_fn);\n                         let sig = common::ty_fn_sig(bcx.ccx, fn_ty);\n                         let sig = bcx.tcx().erase_late_bound_regions_and_normalize(&sig);\n                         let fn_ty = FnType::new_vtable(bcx.ccx, sig, &[]);\n                         args = &args[..1];\n-                        (meth::DESTRUCTOR.get_fn(&bcx, lvalue.llextra, &fn_ty), fn_ty)\n+                        (meth::DESTRUCTOR.get_fn(&bcx, place.llextra, &fn_ty), fn_ty)\n                     }\n                     _ => {\n                         (callee::get_fn(bcx.ccx, drop_fn),\n@@ -792,7 +792,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             match self.locals[index] {\n                 LocalRef::Place(dest) => dest,\n                 LocalRef::Operand(None) => {\n-                    // Handle temporary lvalues, specifically Operand ones, as\n+                    // Handle temporary places, specifically Operand ones, as\n                     // they don't have allocas\n                     return if fn_ret.is_indirect() {\n                         // Odd, but possible, case, we have an operand temporary,\n@@ -813,11 +813,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n                 }\n                 LocalRef::Operand(Some(_)) => {\n-                    bug!(\"lvalue local already assigned to\");\n+                    bug!(\"place local already assigned to\");\n                 }\n             }\n         } else {\n-            self.trans_lvalue(bcx, dest)\n+            self.trans_place(bcx, dest)\n         };\n         if fn_ret.is_indirect() {\n             match dest.alignment {\n@@ -845,15 +845,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                        dst: &mir::Place<'tcx>) {\n         if let mir::Place::Local(index) = *dst {\n             match self.locals[index] {\n-                LocalRef::Place(lvalue) => self.trans_transmute_into(bcx, src, lvalue),\n+                LocalRef::Place(place) => self.trans_transmute_into(bcx, src, place),\n                 LocalRef::Operand(None) => {\n-                    let dst_layout = bcx.ccx.layout_of(self.monomorphized_lvalue_ty(dst));\n+                    let dst_layout = bcx.ccx.layout_of(self.monomorphized_place_ty(dst));\n                     assert!(!dst_layout.ty.has_erasable_regions());\n-                    let lvalue = PlaceRef::alloca(bcx, dst_layout, \"transmute_temp\");\n-                    lvalue.storage_live(bcx);\n-                    self.trans_transmute_into(bcx, src, lvalue);\n-                    let op = lvalue.load(bcx);\n-                    lvalue.storage_dead(bcx);\n+                    let place = PlaceRef::alloca(bcx, dst_layout, \"transmute_temp\");\n+                    place.storage_live(bcx);\n+                    self.trans_transmute_into(bcx, src, place);\n+                    let op = place.load(bcx);\n+                    place.storage_dead(bcx);\n                     self.locals[index] = LocalRef::Operand(Some(op));\n                 }\n                 LocalRef::Operand(Some(op)) => {\n@@ -862,7 +862,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n             }\n         } else {\n-            let dst = self.trans_lvalue(bcx, dst);\n+            let dst = self.trans_place(bcx, dst);\n             self.trans_transmute_into(bcx, src, dst);\n         }\n     }\n@@ -918,8 +918,8 @@ enum ReturnDest<'tcx> {\n     Nothing,\n     // Store the return value to the pointer\n     Store(PlaceRef<'tcx>),\n-    // Stores an indirect return value to an operand local lvalue\n+    // Stores an indirect return value to an operand local place\n     IndirectOperand(PlaceRef<'tcx>, mir::Local),\n-    // Stores a direct return value to an operand local lvalue\n+    // Stores a direct return value to an operand local place\n     DirectOperand(mir::Local)\n }"}, {"sha": "764021983e99c02c4aac601ec7760c2a3a3175b2", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -42,7 +42,7 @@ use syntax::ast;\n use std::fmt;\n use std::ptr;\n \n-use super::lvalue::Alignment;\n+use super::place::Alignment;\n use super::operand::{OperandRef, OperandValue};\n use super::MirContext;\n \n@@ -156,7 +156,7 @@ impl<'a, 'tcx> Const<'tcx> {\n         self.get_pair(ccx)\n     }\n \n-    fn as_lvalue(&self) -> ConstPlace<'tcx> {\n+    fn as_place(&self) -> ConstPlace<'tcx> {\n         ConstPlace {\n             base: Base::Value(self.llval),\n             llextra: ptr::null_mut(),\n@@ -210,7 +210,7 @@ enum Base {\n     Static(ValueRef)\n }\n \n-/// An lvalue as seen from a constant.\n+/// An place as seen from a constant.\n #[derive(Copy, Clone)]\n struct ConstPlace<'tcx> {\n     base: Base,\n@@ -348,7 +348,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 mir::TerminatorKind::Goto { target } => target,\n                 mir::TerminatorKind::Return => {\n                     failure?;\n-                    return self.locals[mir::RETURN_POINTER].clone().unwrap_or_else(|| {\n+                    return self.locals[mir::RETURN_PLACE].clone().unwrap_or_else(|| {\n                         span_bug!(span, \"no returned value in constant\");\n                     });\n                 }\n@@ -437,17 +437,17 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         }\n     }\n \n-    fn const_lvalue(&self, lvalue: &mir::Place<'tcx>, span: Span)\n+    fn const_place(&self, place: &mir::Place<'tcx>, span: Span)\n                     -> Result<ConstPlace<'tcx>, ConstEvalErr<'tcx>> {\n         let tcx = self.ccx.tcx();\n \n-        if let mir::Place::Local(index) = *lvalue {\n+        if let mir::Place::Local(index) = *place {\n             return self.locals[index].clone().unwrap_or_else(|| {\n-                span_bug!(span, \"{:?} not initialized\", lvalue)\n-            }).map(|v| v.as_lvalue());\n+                span_bug!(span, \"{:?} not initialized\", place)\n+            }).map(|v| v.as_place());\n         }\n \n-        let lvalue = match *lvalue {\n+        let place = match *place {\n             mir::Place::Local(_)  => bug!(), // handled above\n             mir::Place::Static(box mir::Static { def_id, ty }) => {\n                 ConstPlace {\n@@ -457,7 +457,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 }\n             }\n             mir::Place::Projection(ref projection) => {\n-                let tr_base = self.const_lvalue(&projection.base, span)?;\n+                let tr_base = self.const_place(&projection.base, span)?;\n                 let projected_ty = PlaceTy::Ty { ty: tr_base.ty }\n                     .projection_ty(tcx, &projection.elem);\n                 let base = tr_base.to_const(span);\n@@ -533,16 +533,16 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 }\n             }\n         };\n-        Ok(lvalue)\n+        Ok(place)\n     }\n \n     fn const_operand(&self, operand: &mir::Operand<'tcx>, span: Span)\n                      -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n         debug!(\"const_operand({:?} @ {:?})\", operand, span);\n         let result = match *operand {\n-            mir::Operand::Copy(ref lvalue) |\n-            mir::Operand::Move(ref lvalue) => {\n-                Ok(self.const_lvalue(lvalue, span)?.to_const(span))\n+            mir::Operand::Copy(ref place) |\n+            mir::Operand::Move(ref place) => {\n+                Ok(self.const_place(place, span)?.to_const(span))\n             }\n \n             mir::Operand::Constant(ref constant) => {\n@@ -779,14 +779,14 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 Const::new(val, cast_ty)\n             }\n \n-            mir::Rvalue::Ref(_, bk, ref lvalue) => {\n-                let tr_lvalue = self.const_lvalue(lvalue, span)?;\n+            mir::Rvalue::Ref(_, bk, ref place) => {\n+                let tr_place = self.const_place(place, span)?;\n \n-                let ty = tr_lvalue.ty;\n+                let ty = tr_place.ty;\n                 let ref_ty = tcx.mk_ref(tcx.types.re_erased,\n                     ty::TypeAndMut { ty: ty, mutbl: bk.to_mutbl_lossy() });\n \n-                let base = match tr_lvalue.base {\n+                let base = match tr_place.base {\n                     Base::Value(llval) => {\n                         // FIXME: may be wrong for &*(&simd_vec as &fmt::Debug)\n                         let align = if self.ccx.shared().type_is_sized(ty) {\n@@ -807,14 +807,14 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let ptr = if self.ccx.shared().type_is_sized(ty) {\n                     base\n                 } else {\n-                    C_fat_ptr(self.ccx, base, tr_lvalue.llextra)\n+                    C_fat_ptr(self.ccx, base, tr_place.llextra)\n                 };\n                 Const::new(ptr, ref_ty)\n             }\n \n-            mir::Rvalue::Len(ref lvalue) => {\n-                let tr_lvalue = self.const_lvalue(lvalue, span)?;\n-                Const::new(tr_lvalue.len(self.ccx), tcx.types.usize)\n+            mir::Rvalue::Len(ref place) => {\n+                let tr_place = self.const_place(place, span)?;\n+                Const::new(tr_place.len(self.ccx), tcx.types.usize)\n             }\n \n             mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {"}, {"sha": "39e2503081af8033cae9476825a184411701eb83", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -35,7 +35,7 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n pub use self::constant::trans_static_initializer;\n \n use self::analyze::CleanupKind;\n-use self::lvalue::{Alignment, PlaceRef};\n+use self::place::{Alignment, PlaceRef};\n use rustc::mir::traversal;\n \n use self::operand::{OperandRef, OperandValue};\n@@ -87,7 +87,7 @@ pub struct MirContext<'a, 'tcx:'a> {\n     /// - the type of the local must be judged \"immediate\" by `is_llvm_immediate`\n     /// - the operand must never be referenced indirectly\n     ///     - we should not take its address using the `&` operator\n-    ///     - nor should it appear in an lvalue path like `tmp.a`\n+    ///     - nor should it appear in a place path like `tmp.a`\n     /// - the operand must be defined by an rvalue that can generate immediate\n     ///   values\n     ///\n@@ -244,11 +244,11 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n         },\n     };\n \n-    let lvalue_locals = analyze::lvalue_locals(&mircx);\n+    let memory_locals = analyze::memory_locals(&mircx);\n \n     // Allocate variable and temp allocas\n     mircx.locals = {\n-        let args = arg_local_refs(&bcx, &mircx, &mircx.scopes, &lvalue_locals);\n+        let args = arg_local_refs(&bcx, &mircx, &mircx.scopes, &memory_locals);\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n@@ -260,30 +260,30 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                 let debug_scope = mircx.scopes[decl.source_info.scope];\n                 let dbg = debug_scope.is_valid() && bcx.sess().opts.debuginfo == FullDebugInfo;\n \n-                if !lvalue_locals.contains(local.index()) && !dbg {\n+                if !memory_locals.contains(local.index()) && !dbg {\n                     debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n                     return LocalRef::new_operand(bcx.ccx, layout);\n                 }\n \n-                debug!(\"alloc: {:?} ({}) -> lvalue\", local, name);\n-                let lvalue = PlaceRef::alloca(&bcx, layout, &name.as_str());\n+                debug!(\"alloc: {:?} ({}) -> place\", local, name);\n+                let place = PlaceRef::alloca(&bcx, layout, &name.as_str());\n                 if dbg {\n                     let (scope, span) = mircx.debug_loc(decl.source_info);\n                     declare_local(&bcx, &mircx.debug_context, name, layout.ty, scope,\n-                        VariableAccess::DirectVariable { alloca: lvalue.llval },\n+                        VariableAccess::DirectVariable { alloca: place.llval },\n                         VariableKind::LocalVariable, span);\n                 }\n-                LocalRef::Place(lvalue)\n+                LocalRef::Place(place)\n             } else {\n-                // Temporary or return pointer\n-                if local == mir::RETURN_POINTER && mircx.fn_ty.ret.is_indirect() {\n-                    debug!(\"alloc: {:?} (return pointer) -> lvalue\", local);\n+                // Temporary or return place\n+                if local == mir::RETURN_PLACE && mircx.fn_ty.ret.is_indirect() {\n+                    debug!(\"alloc: {:?} (return place) -> place\", local);\n                     let llretptr = llvm::get_param(llfn, 0);\n                     LocalRef::Place(PlaceRef::new_sized(llretptr,\n                                                           layout,\n                                                           Alignment::AbiAligned))\n-                } else if lvalue_locals.contains(local.index()) {\n-                    debug!(\"alloc: {:?} -> lvalue\", local);\n+                } else if memory_locals.contains(local.index()) {\n+                    debug!(\"alloc: {:?} -> place\", local);\n                     LocalRef::Place(PlaceRef::alloca(&bcx, layout, &format!(\"{:?}\", local)))\n                 } else {\n                     // If this is an immediate local, we do not create an\n@@ -295,7 +295,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n             }\n         };\n \n-        let retptr = allocate_local(mir::RETURN_POINTER);\n+        let retptr = allocate_local(mir::RETURN_PLACE);\n         iter::once(retptr)\n             .chain(args.into_iter())\n             .chain(mir.vars_and_temps_iter().map(allocate_local))\n@@ -355,12 +355,12 @@ fn create_funclets<'a, 'tcx>(\n }\n \n /// Produce, for each argument, a `ValueRef` pointing at the\n-/// argument's value. As arguments are lvalues, these are always\n+/// argument's value. As arguments are places, these are always\n /// indirect.\n fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             mircx: &MirContext<'a, 'tcx>,\n                             scopes: &IndexVec<mir::VisibilityScope, debuginfo::MirDebugScope>,\n-                            lvalue_locals: &BitVector)\n+                            memory_locals: &BitVector)\n                             -> Vec<LocalRef<'tcx>> {\n     let mir = mircx.mir;\n     let tcx = bcx.tcx();\n@@ -400,18 +400,18 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n-            let lvalue = PlaceRef::alloca(bcx, bcx.ccx.layout_of(arg_ty), &name);\n+            let place = PlaceRef::alloca(bcx, bcx.ccx.layout_of(arg_ty), &name);\n             for i in 0..tupled_arg_tys.len() {\n                 let arg = &mircx.fn_ty.args[idx];\n                 idx += 1;\n-                arg.store_fn_arg(bcx, &mut llarg_idx, lvalue.project_field(bcx, i));\n+                arg.store_fn_arg(bcx, &mut llarg_idx, place.project_field(bcx, i));\n             }\n \n             // Now that we have one alloca that contains the aggregate value,\n             // we can create one debuginfo entry for the argument.\n             arg_scope.map(|scope| {\n                 let variable_access = VariableAccess::DirectVariable {\n-                    alloca: lvalue.llval\n+                    alloca: place.llval\n                 };\n                 declare_local(\n                     bcx,\n@@ -424,7 +424,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 );\n             });\n \n-            return LocalRef::Place(lvalue);\n+            return LocalRef::Place(place);\n         }\n \n         let arg = &mircx.fn_ty.args[idx];\n@@ -433,7 +433,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             llarg_idx += 1;\n         }\n \n-        if arg_scope.is_none() && !lvalue_locals.contains(local.index()) {\n+        if arg_scope.is_none() && !memory_locals.contains(local.index()) {\n             // We don't have to cast or keep the argument in the alloca.\n             // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n             // of putting everything in allocas just so we can use llvm.dbg.declare.\n@@ -467,7 +467,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             }\n         }\n \n-        let lvalue = if arg.is_indirect() {\n+        let place = if arg.is_indirect() {\n             // Don't copy an indirect argument to an alloca, the caller\n             // already put it in a temporary alloca and gave it up.\n             // FIXME: lifetimes\n@@ -487,13 +487,13 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 // need to insert a deref here, but the C ABI uses a pointer and a copy using the\n                 // byval attribute, for which LLVM does the deref itself, so we must not add it.\n                 let mut variable_access = VariableAccess::DirectVariable {\n-                    alloca: lvalue.llval\n+                    alloca: place.llval\n                 };\n \n                 if let PassMode::Indirect(ref attrs) = arg.mode {\n                     if !attrs.contains(ArgAttribute::ByVal) {\n                         variable_access = VariableAccess::IndirectVariable {\n-                            alloca: lvalue.llval,\n+                            alloca: place.llval,\n                             address_operations: &deref_op,\n                         };\n                     }\n@@ -535,10 +535,10 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 let alloc = PlaceRef::alloca(bcx,\n                     bcx.ccx.layout_of(tcx.mk_mut_ptr(arg.layout.ty)),\n                     \"__debuginfo_env_ptr\");\n-                bcx.store(lvalue.llval, alloc.llval, None);\n+                bcx.store(place.llval, alloc.llval, None);\n                 alloc.llval\n             } else {\n-                lvalue.llval\n+                place.llval\n             };\n \n             for (i, (decl, ty)) in mir.upvar_decls.iter().zip(upvar_tys).enumerate() {\n@@ -580,14 +580,14 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 );\n             }\n         });\n-        LocalRef::Place(lvalue)\n+        LocalRef::Place(place)\n     }).collect()\n }\n \n mod analyze;\n mod block;\n mod constant;\n-pub mod lvalue;\n+pub mod place;\n pub mod operand;\n mod rvalue;\n mod statement;"}, {"sha": "9f9710257723145ef02efafe333773f0ab98f5ac", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -25,7 +25,7 @@ use std::fmt;\n use std::ptr;\n \n use super::{MirContext, LocalRef};\n-use super::lvalue::{Alignment, PlaceRef};\n+use super::place::{Alignment, PlaceRef};\n \n /// The representation of a Rust value. The enum variant is in fact\n /// uniquely determined by the value's type, but is kept as a\n@@ -243,20 +243,20 @@ impl<'a, 'tcx> OperandValue {\n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     fn maybe_trans_consume_direct(&mut self,\n                                   bcx: &Builder<'a, 'tcx>,\n-                                  lvalue: &mir::Place<'tcx>)\n+                                  place: &mir::Place<'tcx>)\n                                    -> Option<OperandRef<'tcx>>\n     {\n-        debug!(\"maybe_trans_consume_direct(lvalue={:?})\", lvalue);\n+        debug!(\"maybe_trans_consume_direct(place={:?})\", place);\n \n         // watch out for locals that do not have an\n         // alloca; they are handled somewhat differently\n-        if let mir::Place::Local(index) = *lvalue {\n+        if let mir::Place::Local(index) = *place {\n             match self.locals[index] {\n                 LocalRef::Operand(Some(o)) => {\n                     return Some(o);\n                 }\n                 LocalRef::Operand(None) => {\n-                    bug!(\"use of {:?} before def\", lvalue);\n+                    bug!(\"use of {:?} before def\", place);\n                 }\n                 LocalRef::Place(..) => {\n                     // use path below\n@@ -265,7 +265,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         }\n \n         // Moves out of scalar and scalar pair fields are trivial.\n-        if let &mir::Place::Projection(ref proj) = lvalue {\n+        if let &mir::Place::Projection(ref proj) = place {\n             if let mir::ProjectionElem::Field(ref f, _) = proj.elem {\n                 if let Some(o) = self.maybe_trans_consume_direct(bcx, &proj.base) {\n                     return Some(o.extract_field(bcx, f.index()));\n@@ -278,26 +278,26 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     pub fn trans_consume(&mut self,\n                          bcx: &Builder<'a, 'tcx>,\n-                         lvalue: &mir::Place<'tcx>)\n+                         place: &mir::Place<'tcx>)\n                          -> OperandRef<'tcx>\n     {\n-        debug!(\"trans_consume(lvalue={:?})\", lvalue);\n+        debug!(\"trans_consume(place={:?})\", place);\n \n-        let ty = self.monomorphized_lvalue_ty(lvalue);\n+        let ty = self.monomorphized_place_ty(place);\n         let layout = bcx.ccx.layout_of(ty);\n \n         // ZSTs don't require any actual memory access.\n         if layout.is_zst() {\n             return OperandRef::new_zst(bcx.ccx, layout);\n         }\n \n-        if let Some(o) = self.maybe_trans_consume_direct(bcx, lvalue) {\n+        if let Some(o) = self.maybe_trans_consume_direct(bcx, place) {\n             return o;\n         }\n \n-        // for most lvalues, to consume them we just load them\n+        // for most places, to consume them we just load them\n         // out from their home\n-        self.trans_lvalue(bcx, lvalue).load(bcx)\n+        self.trans_place(bcx, place).load(bcx)\n     }\n \n     pub fn trans_operand(&mut self,\n@@ -308,9 +308,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         debug!(\"trans_operand(operand={:?})\", operand);\n \n         match *operand {\n-            mir::Operand::Copy(ref lvalue) |\n-            mir::Operand::Move(ref lvalue) => {\n-                self.trans_consume(bcx, lvalue)\n+            mir::Operand::Copy(ref place) |\n+            mir::Operand::Move(ref place) => {\n+                self.trans_consume(bcx, place)\n             }\n \n             mir::Operand::Constant(ref constant) => {"}, {"sha": "3bcbb7f3b46eba8ea5ee24f5370f12184b0733f7", "filename": "src/librustc_trans/mir/place.rs", "status": "renamed", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fplace.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -74,16 +74,16 @@ impl Alignment {\n \n #[derive(Copy, Clone, Debug)]\n pub struct PlaceRef<'tcx> {\n-    /// Pointer to the contents of the lvalue\n+    /// Pointer to the contents of the place\n     pub llval: ValueRef,\n \n-    /// This lvalue's extra data if it is unsized, or null\n+    /// This place's extra data if it is unsized, or null\n     pub llextra: ValueRef,\n \n-    /// Monomorphized type of this lvalue, including variant information\n+    /// Monomorphized type of this place, including variant information\n     pub layout: TyLayout<'tcx>,\n \n-    /// Whether this lvalue is known to be aligned according to its layout\n+    /// Whether this place is known to be aligned according to its layout\n     pub alignment: Alignment,\n }\n \n@@ -444,27 +444,27 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n }\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n-    pub fn trans_lvalue(&mut self,\n+    pub fn trans_place(&mut self,\n                         bcx: &Builder<'a, 'tcx>,\n-                        lvalue: &mir::Place<'tcx>)\n+                        place: &mir::Place<'tcx>)\n                         -> PlaceRef<'tcx> {\n-        debug!(\"trans_lvalue(lvalue={:?})\", lvalue);\n+        debug!(\"trans_place(place={:?})\", place);\n \n         let ccx = bcx.ccx;\n         let tcx = ccx.tcx();\n \n-        if let mir::Place::Local(index) = *lvalue {\n+        if let mir::Place::Local(index) = *place {\n             match self.locals[index] {\n-                LocalRef::Place(lvalue) => {\n-                    return lvalue;\n+                LocalRef::Place(place) => {\n+                    return place;\n                 }\n                 LocalRef::Operand(..) => {\n-                    bug!(\"using operand local {:?} as lvalue\", lvalue);\n+                    bug!(\"using operand local {:?} as place\", place);\n                 }\n             }\n         }\n \n-        let result = match *lvalue {\n+        let result = match *place {\n             mir::Place::Local(_) => bug!(), // handled above\n             mir::Place::Static(box mir::Static { def_id, ty }) => {\n                 PlaceRef::new_sized(consts::get_static(ccx, def_id),\n@@ -479,7 +479,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 self.trans_consume(bcx, base).deref(bcx.ccx)\n             }\n             mir::Place::Projection(ref projection) => {\n-                let tr_base = self.trans_lvalue(bcx, &projection.base);\n+                let tr_base = self.trans_place(bcx, &projection.base);\n \n                 match projection.elem {\n                     mir::ProjectionElem::Deref => bug!(),\n@@ -519,7 +519,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 C_usize(bcx.ccx, (from as u64) + (to as u64)));\n                         }\n \n-                        // Cast the lvalue pointer type to the new\n+                        // Cast the place pointer type to the new\n                         // array or slice type (*[%_; new_len]).\n                         subslice.llval = bcx.pointercast(subslice.llval,\n                             subslice.layout.llvm_type(bcx.ccx).ptr_to());\n@@ -532,14 +532,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n             }\n         };\n-        debug!(\"trans_lvalue(lvalue={:?}) => {:?}\", lvalue, result);\n+        debug!(\"trans_place(place={:?}) => {:?}\", place, result);\n         result\n     }\n \n-    pub fn monomorphized_lvalue_ty(&self, lvalue: &mir::Place<'tcx>) -> Ty<'tcx> {\n+    pub fn monomorphized_place_ty(&self, place: &mir::Place<'tcx>) -> Ty<'tcx> {\n         let tcx = self.ccx.tcx();\n-        let lvalue_ty = lvalue.ty(self.mir, tcx);\n-        self.monomorphize(&lvalue_ty.to_ty(tcx))\n+        let place_ty = place.ty(self.mir, tcx);\n+        self.monomorphize(&place_ty.to_ty(tcx))\n     }\n }\n ", "previous_filename": "src/librustc_trans/mir/lvalue.rs"}, {"sha": "a93c0cea11869a724782a8714a4644a507bb2d57", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -32,7 +32,7 @@ use value::Value;\n use super::{MirContext, LocalRef};\n use super::constant::const_scalar_checked_binop;\n use super::operand::{OperandRef, OperandValue};\n-use super::lvalue::PlaceRef;\n+use super::place::PlaceRef;\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n@@ -334,17 +334,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 })\n             }\n \n-            mir::Rvalue::Ref(_, bk, ref lvalue) => {\n-                let tr_lvalue = self.trans_lvalue(&bcx, lvalue);\n+            mir::Rvalue::Ref(_, bk, ref place) => {\n+                let tr_place = self.trans_place(&bcx, place);\n \n-                let ty = tr_lvalue.layout.ty;\n+                let ty = tr_place.layout.ty;\n \n-                // Note: lvalues are indirect, so storing the `llval` into the\n+                // Note: places are indirect, so storing the `llval` into the\n                 // destination effectively creates a reference.\n                 let val = if !bcx.ccx.shared().type_has_metadata(ty) {\n-                    OperandValue::Immediate(tr_lvalue.llval)\n+                    OperandValue::Immediate(tr_place.llval)\n                 } else {\n-                    OperandValue::Pair(tr_lvalue.llval, tr_lvalue.llextra)\n+                    OperandValue::Pair(tr_place.llval, tr_place.llextra)\n                 };\n                 (bcx, OperandRef {\n                     val,\n@@ -355,8 +355,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 })\n             }\n \n-            mir::Rvalue::Len(ref lvalue) => {\n-                let size = self.evaluate_array_len(&bcx, lvalue);\n+            mir::Rvalue::Len(ref place) => {\n+                let size = self.evaluate_array_len(&bcx, place);\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(size),\n                     layout: bcx.ccx.layout_of(bcx.tcx().types.usize),\n@@ -424,9 +424,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 })\n             }\n \n-            mir::Rvalue::Discriminant(ref lvalue) => {\n+            mir::Rvalue::Discriminant(ref place) => {\n                 let discr_ty = rvalue.ty(&*self.mir, bcx.tcx());\n-                let discr =  self.trans_lvalue(&bcx, lvalue)\n+                let discr =  self.trans_place(&bcx, place)\n                     .trans_get_discr(&bcx, discr_ty);\n                 (bcx, OperandRef {\n                     val: OperandValue::Immediate(discr),\n@@ -486,11 +486,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     fn evaluate_array_len(&mut self,\n                           bcx: &Builder<'a, 'tcx>,\n-                          lvalue: &mir::Place<'tcx>) -> ValueRef\n+                          place: &mir::Place<'tcx>) -> ValueRef\n     {\n         // ZST are passed as operands and require special handling\n-        // because trans_lvalue() panics if Local is operand.\n-        if let mir::Place::Local(index) = *lvalue {\n+        // because trans_place() panics if Local is operand.\n+        if let mir::Place::Local(index) = *place {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::TyArray(_, n) = op.layout.ty.sty {\n                     let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n@@ -499,7 +499,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n         }\n         // use common size calculation for non zero-sized types\n-        let tr_value = self.trans_lvalue(&bcx, lvalue);\n+        let tr_value = self.trans_place(&bcx, place);\n         return tr_value.len(bcx.ccx);\n     }\n "}, {"sha": "e0ca5dcc9d08293cb122d778c37bf137343c3c89", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473f044225e7cab4047fecd15268042f7aee2509/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=473f044225e7cab4047fecd15268042f7aee2509", "patch": "@@ -25,8 +25,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         self.set_debug_loc(&bcx, statement.source_info);\n         match statement.kind {\n-            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n-                if let mir::Place::Local(index) = *lvalue {\n+            mir::StatementKind::Assign(ref place, ref rvalue) => {\n+                if let mir::Place::Local(index) = *place {\n                     match self.locals[index] {\n                         LocalRef::Place(tr_dest) => {\n                             self.trans_rvalue(bcx, tr_dest, rvalue)\n@@ -49,30 +49,30 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         }\n                     }\n                 } else {\n-                    let tr_dest = self.trans_lvalue(&bcx, lvalue);\n+                    let tr_dest = self.trans_place(&bcx, place);\n                     self.trans_rvalue(bcx, tr_dest, rvalue)\n                 }\n             }\n-            mir::StatementKind::SetDiscriminant{ref lvalue, variant_index} => {\n-                self.trans_lvalue(&bcx, lvalue)\n+            mir::StatementKind::SetDiscriminant{ref place, variant_index} => {\n+                self.trans_place(&bcx, place)\n                     .trans_set_discr(&bcx, variant_index);\n                 bcx\n             }\n             mir::StatementKind::StorageLive(local) => {\n-                if let LocalRef::Place(tr_lval) = self.locals[local] {\n-                    tr_lval.storage_live(&bcx);\n+                if let LocalRef::Place(tr_place) = self.locals[local] {\n+                    tr_place.storage_live(&bcx);\n                 }\n                 bcx\n             }\n             mir::StatementKind::StorageDead(local) => {\n-                if let LocalRef::Place(tr_lval) = self.locals[local] {\n-                    tr_lval.storage_dead(&bcx);\n+                if let LocalRef::Place(tr_place) = self.locals[local] {\n+                    tr_place.storage_dead(&bcx);\n                 }\n                 bcx\n             }\n             mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 let outputs = outputs.iter().map(|output| {\n-                    self.trans_lvalue(&bcx, output)\n+                    self.trans_place(&bcx, output)\n                 }).collect();\n \n                 let input_vals = inputs.iter().map(|input| {"}]}