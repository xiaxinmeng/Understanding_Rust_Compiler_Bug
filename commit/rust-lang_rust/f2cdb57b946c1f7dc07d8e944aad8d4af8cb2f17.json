{"sha": "f2cdb57b946c1f7dc07d8e944aad8d4af8cb2f17", "node_id": "C_kwDOAAsO6NoAKGYyY2RiNTdiOTQ2YzFmN2RjMDdkOGU5NDRhYWQ4ZDRhZjhjYjJmMTc", "commit": {"author": {"name": "Thomas de Zeeuw", "email": "thomasdezeeuw@gmail.com", "date": "2022-01-23T16:11:06Z"}, "committer": {"name": "Thomas de Zeeuw", "email": "thomasdezeeuw@gmail.com", "date": "2022-01-23T16:11:06Z"}, "message": "Add os::unix::net::SocketAddr::unix\n\nCreates a new SocketAddr from a path, supports both regular paths and\nabstract namespaces.", "tree": {"sha": "bde6fdfe7724ec22898551f2c17d359e3949d9f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bde6fdfe7724ec22898551f2c17d359e3949d9f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2cdb57b946c1f7dc07d8e944aad8d4af8cb2f17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2cdb57b946c1f7dc07d8e944aad8d4af8cb2f17", "html_url": "https://github.com/rust-lang/rust/commit/f2cdb57b946c1f7dc07d8e944aad8d4af8cb2f17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2cdb57b946c1f7dc07d8e944aad8d4af8cb2f17/comments", "author": {"login": "Thomasdezeeuw", "id": 3159064, "node_id": "MDQ6VXNlcjMxNTkwNjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3159064?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Thomasdezeeuw", "html_url": "https://github.com/Thomasdezeeuw", "followers_url": "https://api.github.com/users/Thomasdezeeuw/followers", "following_url": "https://api.github.com/users/Thomasdezeeuw/following{/other_user}", "gists_url": "https://api.github.com/users/Thomasdezeeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/Thomasdezeeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Thomasdezeeuw/subscriptions", "organizations_url": "https://api.github.com/users/Thomasdezeeuw/orgs", "repos_url": "https://api.github.com/users/Thomasdezeeuw/repos", "events_url": "https://api.github.com/users/Thomasdezeeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/Thomasdezeeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Thomasdezeeuw", "id": 3159064, "node_id": "MDQ6VXNlcjMxNTkwNjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3159064?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Thomasdezeeuw", "html_url": "https://github.com/Thomasdezeeuw", "followers_url": "https://api.github.com/users/Thomasdezeeuw/followers", "following_url": "https://api.github.com/users/Thomasdezeeuw/following{/other_user}", "gists_url": "https://api.github.com/users/Thomasdezeeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/Thomasdezeeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Thomasdezeeuw/subscriptions", "organizations_url": "https://api.github.com/users/Thomasdezeeuw/orgs", "repos_url": "https://api.github.com/users/Thomasdezeeuw/repos", "events_url": "https://api.github.com/users/Thomasdezeeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/Thomasdezeeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e4067957bd5d0e12c1657e720903209ecc291dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e4067957bd5d0e12c1657e720903209ecc291dc", "html_url": "https://github.com/rust-lang/rust/commit/1e4067957bd5d0e12c1657e720903209ecc291dc"}], "stats": {"total": 69, "additions": 68, "deletions": 1}, "files": [{"sha": "b8e8e9b506d337bdeca1957efb790d0d519925e4", "filename": "library/std/src/os/unix/net/addr.rs", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f2cdb57b946c1f7dc07d8e944aad8d4af8cb2f17/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2cdb57b946c1f7dc07d8e944aad8d4af8cb2f17/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs?ref=f2cdb57b946c1f7dc07d8e944aad8d4af8cb2f17", "patch": "@@ -2,7 +2,7 @@ use crate::ffi::OsStr;\n use crate::os::unix::ffi::OsStrExt;\n use crate::path::Path;\n use crate::sys::cvt;\n-use crate::{ascii, fmt, io, iter, mem};\n+use crate::{ascii, fmt, io, iter, mem, ptr};\n \n // FIXME(#43348): Make libc adapt #[doc(cfg(...))] so we don't need these fake definitions here?\n #[cfg(not(unix))]\n@@ -127,6 +127,73 @@ impl SocketAddr {\n         Ok(SocketAddr { addr, len })\n     }\n \n+    /// Constructs a `SockAddr` with the family `AF_UNIX` and the provided path.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns an error if the path is longer than `SUN_LEN`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(unix_socket_creation)]\n+    /// use std::os::unix::net::SocketAddr;\n+    /// use std::path::Path;\n+    ///\n+    /// # fn main() -> std::io::Result<()> {\n+    /// let address = SocketAddr::unix(\"/path/to/socket\")?;\n+    /// assert_eq!(address.as_pathname(), Some(Path::new(\"/path/to/socket\")));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_creation\", issue = \"65275\")]\n+    pub fn unix<P>(path: P) -> io::Result<SocketAddr>\n+    where\n+        P: AsRef<Path>,\n+    {\n+        // SAFETY: All zeros is a valid representation for `sockaddr_un`.\n+        let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };\n+\n+        let bytes = path.as_ref().as_os_str().as_bytes();\n+        let too_long = match bytes.first() {\n+            None => false,\n+            // linux abstract namespaces aren't null-terminated.\n+            Some(&0) => bytes.len() > storage.sun_path.len(),\n+            Some(_) => bytes.len() >= storage.sun_path.len(),\n+        };\n+        if too_long {\n+            return Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"path must be shorter than SUN_LEN\",\n+            ));\n+        }\n+\n+        storage.sun_family = libc::AF_UNIX as _;\n+        // SAFETY: `bytes` and `addr.sun_path` are not overlapping and\n+        // both point to valid memory.\n+        // NOTE: We zeroed the memory above, so the path is already null\n+        // terminated.\n+        unsafe {\n+            ptr::copy_nonoverlapping(\n+                bytes.as_ptr(),\n+                storage.sun_path.as_mut_ptr().cast(),\n+                bytes.len(),\n+            )\n+        };\n+\n+        let base = &storage as *const _ as usize;\n+        let path = &storage.sun_path as *const _ as usize;\n+        let sun_path_offset = path - base;\n+        let length = sun_path_offset\n+            + bytes.len()\n+            + match bytes.first() {\n+                Some(&0) | None => 0,\n+                Some(_) => 1,\n+            };\n+\n+        Ok(SocketAddr { addr: storage, len: length as _ })\n+    }\n+\n     /// Returns `true` if the address is unnamed.\n     ///\n     /// # Examples"}]}