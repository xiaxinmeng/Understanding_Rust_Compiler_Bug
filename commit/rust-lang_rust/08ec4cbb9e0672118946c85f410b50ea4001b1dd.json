{"sha": "08ec4cbb9e0672118946c85f410b50ea4001b1dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZWM0Y2JiOWUwNjcyMTE4OTQ2Yzg1ZjQxMGI1MGVhNDAwMWIxZGQ=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-06-23T02:21:56Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-06-23T02:21:56Z"}, "message": "moves coverage data computation from pass to query", "tree": {"sha": "166d348dcb72b5d1a03f91425b9bc67132262bf1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/166d348dcb72b5d1a03f91425b9bc67132262bf1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08ec4cbb9e0672118946c85f410b50ea4001b1dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08ec4cbb9e0672118946c85f410b50ea4001b1dd", "html_url": "https://github.com/rust-lang/rust/commit/08ec4cbb9e0672118946c85f410b50ea4001b1dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08ec4cbb9e0672118946c85f410b50ea4001b1dd/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "994d9d03272363d57a655ebacbf58f0069b3b177", "url": "https://api.github.com/repos/rust-lang/rust/commits/994d9d03272363d57a655ebacbf58f0069b3b177", "html_url": "https://github.com/rust-lang/rust/commit/994d9d03272363d57a655ebacbf58f0069b3b177"}], "stats": {"total": 112, "additions": 56, "deletions": 56}, "files": [{"sha": "b9193a85b1e482e7de2c4bbf6e2ce5468d2f0c3a", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08ec4cbb9e0672118946c85f410b50ea4001b1dd/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ec4cbb9e0672118946c85f410b50ea4001b1dd/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=08ec4cbb9e0672118946c85f410b50ea4001b1dd", "patch": "@@ -140,18 +140,15 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 self.call(llfn, &[], None)\n             }\n             \"count_code_region\" => {\n-                let coverage_data = tcx\n-                    .coverage_data(caller_instance.def_id())\n-                    .as_ref()\n-                    .expect(\"LLVM intrinsic count_code_region call has associated coverage_data\");\n+                let coverage_data = tcx.coverage_data(caller_instance.def_id());\n                 let mangled_fn = tcx.symbol_name(caller_instance);\n                 let (mangled_fn_name, _len_val) = self.const_str(mangled_fn.name);\n                 let hash = self.const_u64(coverage_data.hash);\n-                let index = args[0].immediate();\n                 let num_counters = self.const_u32(coverage_data.num_counters);\n+                let index = args[0].immediate();\n                 debug!(\n                     \"count_code_region to LLVM intrinsic instrprof.increment(fn_name={}, hash={:?}, num_counters={:?}, index={:?})\",\n-                    mangled_fn.name, hash, index, num_counters\n+                    mangled_fn.name, hash, num_counters, index\n                 );\n                 self.instrprof_increment(mangled_fn_name, hash, num_counters, index)\n             }"}, {"sha": "854fda095b65b276f74737dcd5d3153139c72706", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/08ec4cbb9e0672118946c85f410b50ea4001b1dd/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ec4cbb9e0672118946c85f410b50ea4001b1dd/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=08ec4cbb9e0672118946c85f410b50ea4001b1dd", "patch": "@@ -88,19 +88,6 @@ impl MirPhase {\n     }\n }\n \n-/// Coverage data computed by the `InstrumentCoverage` MIR pass, when compiling with\n-/// `-Zinstrument_coverage`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable, TypeFoldable)]\n-pub struct CoverageData {\n-    /// A hash value that can be used by the consumer of the coverage profile data to detect\n-    /// changes to the instrumented source of the associated MIR body (typically, for an\n-    /// individual function).\n-    pub hash: u64,\n-\n-    /// The total number of coverage region counters added to this MIR Body.\n-    pub num_counters: u32,\n-}\n-\n /// The lowered representation of a single function.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable, TypeFoldable)]\n pub struct Body<'tcx> {\n@@ -184,10 +171,6 @@ pub struct Body<'tcx> {\n     /// FIXME(oli-obk): rewrite the promoted during promotion to eliminate the cell components.\n     pub ignore_interior_mut_in_const_validation: bool,\n \n-    /// If compiling with `-Zinstrument_coverage`, the `InstrumentCoverage` pass stores summary\n-    /// information associated with the MIR, used in code generation of the coverage counters.\n-    pub coverage_data: Option<CoverageData>,\n-\n     predecessor_cache: PredecessorCache,\n }\n \n@@ -228,7 +211,6 @@ impl<'tcx> Body<'tcx> {\n             required_consts: Vec::new(),\n             ignore_interior_mut_in_const_validation: false,\n             control_flow_destroyed,\n-            coverage_data: None,\n             predecessor_cache: PredecessorCache::new(),\n         }\n     }\n@@ -256,7 +238,6 @@ impl<'tcx> Body<'tcx> {\n             generator_kind: None,\n             var_debug_info: Vec::new(),\n             ignore_interior_mut_in_const_validation: false,\n-            coverage_data: None,\n             predecessor_cache: PredecessorCache::new(),\n         }\n     }\n@@ -2938,3 +2919,18 @@ impl Location {\n         }\n     }\n }\n+\n+/// Coverage data associated with each function (MIR) instrumented with coverage counters, when\n+/// compiled with `-Zinstrument_coverage`. The query `tcx.coverage_data(DefId)` computes these\n+/// values on demand (during code generation). This query is only valid after executing the MIR pass\n+/// `InstrumentCoverage`.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+pub struct CoverageData {\n+    /// A hash value that can be used by the consumer of the coverage profile data to detect\n+    /// changes to the instrumented source of the associated MIR body (typically, for an\n+    /// individual function).\n+    pub hash: u64,\n+\n+    /// The total number of coverage region counters added to the MIR `Body`.\n+    pub num_counters: u32,\n+}"}, {"sha": "4815f2617b69ba8d6ff551aa46a0692ccf69c954", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08ec4cbb9e0672118946c85f410b50ea4001b1dd/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ec4cbb9e0672118946c85f410b50ea4001b1dd/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=08ec4cbb9e0672118946c85f410b50ea4001b1dd", "patch": "@@ -214,7 +214,7 @@ rustc_queries! {\n             cache_on_disk_if { key.is_local() }\n         }\n \n-        query coverage_data(key: DefId) -> Option<mir::CoverageData> {\n+        query coverage_data(key: DefId) -> mir::CoverageData {\n             desc { |tcx| \"retrieving coverage data from MIR for `{}`\", tcx.def_path_str(key) }\n             storage(ArenaCacheSelector<'tcx>)\n             cache_on_disk_if { key.is_local() }"}, {"sha": "8d263c3089c47f1737cb38f5b64f0c3dc0a7367b", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/08ec4cbb9e0672118946c85f410b50ea4001b1dd/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ec4cbb9e0672118946c85f410b50ea4001b1dd/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=08ec4cbb9e0672118946c85f410b50ea4001b1dd", "patch": "@@ -7,10 +7,12 @@ use rustc_middle::hir;\n use rustc_middle::ich::StableHashingContext;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::{\n-    self, BasicBlock, BasicBlockData, CoverageData, Operand, Place, SourceInfo, StatementKind,\n-    Terminator, TerminatorKind, START_BLOCK,\n+    self, traversal, BasicBlock, BasicBlockData, CoverageData, Operand, Place, SourceInfo,\n+    StatementKind, Terminator, TerminatorKind, START_BLOCK,\n };\n use rustc_middle::ty;\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::FnDef;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::DefId;\n use rustc_span::Span;\n@@ -19,6 +21,31 @@ use rustc_span::Span;\n /// the intrinsic llvm.instrprof.increment.\n pub struct InstrumentCoverage;\n \n+/// The `query` provider for `CoverageData`, requested by `codegen_intrinsic_call()` when\n+/// constructing the arguments for `llvm.instrprof.increment`.\n+pub(crate) fn provide(providers: &mut Providers<'_>) {\n+    providers.coverage_data = |tcx, def_id| {\n+        let body = tcx.optimized_mir(def_id);\n+        let count_code_region_fn =\n+            tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None);\n+        let mut num_counters: u32 = 0;\n+        for (_, data) in traversal::preorder(body) {\n+            if let Some(terminator) = &data.terminator {\n+                if let TerminatorKind::Call { func: Operand::Constant(func), .. } = &terminator.kind\n+                {\n+                    if let FnDef(called_fn_def_id, _) = func.literal.ty.kind {\n+                        if called_fn_def_id == count_code_region_fn {\n+                            num_counters += 1;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        let hash = if num_counters > 0 { hash_mir_source(tcx, def_id) } else { 0 };\n+        CoverageData { num_counters, hash }\n+    };\n+}\n+\n struct Instrumentor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     num_counters: u32,\n@@ -30,20 +57,12 @@ impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n             // If the InstrumentCoverage pass is called on promoted MIRs, skip them.\n             // See: https://github.com/rust-lang/rust/pull/73011#discussion_r438317601\n             if src.promoted.is_none() {\n-                assert!(mir_body.coverage_data.is_none());\n-\n-                let hash = hash_mir_source(tcx, &src);\n-\n                 debug!(\n-                    \"instrumenting {:?}, hash: {}, span: {}\",\n+                    \"instrumenting {:?}, span: {}\",\n                     src.def_id(),\n-                    hash,\n                     tcx.sess.source_map().span_to_string(mir_body.span)\n                 );\n-\n-                let num_counters = Instrumentor::new(tcx).inject_counters(mir_body);\n-\n-                mir_body.coverage_data = Some(CoverageData { hash, num_counters });\n+                Instrumentor::new(tcx).inject_counters(mir_body);\n             }\n         }\n     }\n@@ -60,15 +79,13 @@ impl<'tcx> Instrumentor<'tcx> {\n         next\n     }\n \n-    fn inject_counters(&mut self, mir_body: &mut mir::Body<'tcx>) -> u32 {\n+    fn inject_counters(&mut self, mir_body: &mut mir::Body<'tcx>) {\n         // FIXME(richkadel): As a first step, counters are only injected at the top of each\n         // function. The complete solution will inject counters at each conditional code branch.\n         let top_of_function = START_BLOCK;\n         let entire_function = mir_body.span;\n \n         self.inject_counter(mir_body, top_of_function, entire_function);\n-\n-        self.num_counters\n     }\n \n     fn inject_counter(\n@@ -138,14 +155,9 @@ fn placeholder_block(span: Span) -> BasicBlockData<'tcx> {\n     }\n }\n \n-fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, src: &MirSource<'tcx>) -> u64 {\n-    let fn_body_id = match tcx.hir().get_if_local(src.def_id()) {\n-        Some(node) => match hir::map::associated_body(node) {\n-            Some(body_id) => body_id,\n-            _ => bug!(\"instrumented MirSource does not include a function body: {:?}\", node),\n-        },\n-        None => bug!(\"instrumented MirSource is not local: {:?}\", src),\n-    };\n+fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> u64 {\n+    let hir_node = tcx.hir().get_if_local(def_id).expect(\"DefId is local\");\n+    let fn_body_id = hir::map::associated_body(hir_node).expect(\"HIR node is a function with body\");\n     let hir_body = tcx.hir().body(fn_body_id);\n     let mut hcx = tcx.create_no_span_stable_hashing_context();\n     hash(&mut hcx, &hir_body.value).to_smaller_hash()"}, {"sha": "8ca240d2c7da77eeffcc15137d77304ed3ba7706", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08ec4cbb9e0672118946c85f410b50ea4001b1dd/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ec4cbb9e0672118946c85f410b50ea4001b1dd/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=08ec4cbb9e0672118946c85f410b50ea4001b1dd", "patch": "@@ -6,7 +6,7 @@ use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::Visitor as _;\n-use rustc_middle::mir::{traversal, Body, ConstQualifs, CoverageData, MirPhase, Promoted};\n+use rustc_middle::mir::{traversal, Body, ConstQualifs, MirPhase, Promoted};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::steal::Steal;\n use rustc_middle::ty::{InstanceDef, TyCtxt, TypeFoldable};\n@@ -53,10 +53,10 @@ pub(crate) fn provide(providers: &mut Providers<'_>) {\n         mir_drops_elaborated_and_const_checked,\n         optimized_mir,\n         is_mir_available,\n-        coverage_data,\n         promoted_mir,\n         ..*providers\n     };\n+    instrument_coverage::provide(providers);\n }\n \n fn is_mir_available(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n@@ -423,11 +423,6 @@ fn run_optimization_passes<'tcx>(\n     );\n }\n \n-fn coverage_data(tcx: TyCtxt<'_>, def_id: DefId) -> Option<CoverageData> {\n-    let body = tcx.optimized_mir(def_id);\n-    body.coverage_data.clone()\n-}\n-\n fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n     if tcx.is_constructor(def_id) {\n         // There's no reason to run all of the MIR passes on constructors when"}]}