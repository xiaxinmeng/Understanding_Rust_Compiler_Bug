{"sha": "448a97bf528edc93e33beb85336bd9a14e20b9b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0OGE5N2JmNTI4ZWRjOTNlMzNiZWI4NTMzNmJkOWExNGUyMGI5YjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-02T17:34:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-02T17:34:08Z"}, "message": "Auto merge of #81405 - bugadani:ast, r=cjgillot\n\nBox the biggest ast::ItemKind variants\n\nThis PR is a different approach on https://github.com/rust-lang/rust/pull/81400, aiming to save memory in humongous ASTs.\n\nThe three affected item kind enums are:\n - `ast::ItemKind` (208 -> 112 bytes)\n - `ast::AssocItemKind` (176 -> 72 bytes)\n - `ast::ForeignItemKind` (176 -> 72 bytes)", "tree": {"sha": "836fb73e546203bf37d410df57fe9b2cdb184938", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/836fb73e546203bf37d410df57fe9b2cdb184938"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/448a97bf528edc93e33beb85336bd9a14e20b9b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/448a97bf528edc93e33beb85336bd9a14e20b9b0", "html_url": "https://github.com/rust-lang/rust/commit/448a97bf528edc93e33beb85336bd9a14e20b9b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/448a97bf528edc93e33beb85336bd9a14e20b9b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9607b5c6ac2d6b3d2117c8d5868435581c5e67d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9607b5c6ac2d6b3d2117c8d5868435581c5e67d1", "html_url": "https://github.com/rust-lang/rust/commit/9607b5c6ac2d6b3d2117c8d5868435581c5e67d1"}, {"sha": "6fd01e0b6e04e41d54b8cd95bbf5bc0f907391cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fd01e0b6e04e41d54b8cd95bbf5bc0f907391cb", "html_url": "https://github.com/rust-lang/rust/commit/6fd01e0b6e04e41d54b8cd95bbf5bc0f907391cb"}], "stats": {"total": 148, "additions": 94, "deletions": 54}, "files": [{"sha": "fa0289c977c7253ab2ed3bfa9dd579fed7b261d2", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/448a97bf528edc93e33beb85336bd9a14e20b9b0/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/448a97bf528edc93e33beb85336bd9a14e20b9b0/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=448a97bf528edc93e33beb85336bd9a14e20b9b0", "patch": "@@ -1,7 +1,7 @@\n use crate::utils::{implements_trait, is_entrypoint_fn, is_type_diagnostic_item, return_ty, span_lint};\n use if_chain::if_chain;\n use itertools::Itertools;\n-use rustc_ast::ast::{Async, AttrKind, Attribute, FnRetTy, ItemKind};\n+use rustc_ast::ast::{Async, AttrKind, Attribute, FnKind, FnRetTy, ItemKind};\n use rustc_ast::token::CommentKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n@@ -492,7 +492,9 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                             | ItemKind::ExternCrate(..)\n                             | ItemKind::ForeignMod(..) => return false,\n                             // We found a main function ...\n-                            ItemKind::Fn(_, sig, _, Some(block)) if item.ident.name == sym::main => {\n+                            ItemKind::Fn(box FnKind(_, sig, _, Some(block)))\n+                                if item.ident.name == sym::main =>\n+                            {\n                                 let is_async = matches!(sig.header.asyncness, Async::Yes { .. });\n                                 let returns_nothing = match &sig.decl.output {\n                                     FnRetTy::Default(..) => true,"}, {"sha": "fecde8e2743483d16b51c4a6295192ff1a8bdc6f", "filename": "clippy_lints/src/excessive_bools.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/448a97bf528edc93e33beb85336bd9a14e20b9b0/clippy_lints%2Fsrc%2Fexcessive_bools.rs", "raw_url": "https://github.com/rust-lang/rust/raw/448a97bf528edc93e33beb85336bd9a14e20b9b0/clippy_lints%2Fsrc%2Fexcessive_bools.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_bools.rs?ref=448a97bf528edc93e33beb85336bd9a14e20b9b0", "patch": "@@ -1,5 +1,7 @@\n use crate::utils::{attr_by_name, in_macro, match_path_ast, span_lint_and_help};\n-use rustc_ast::ast::{AssocItemKind, Extern, FnSig, Item, ItemKind, Ty, TyKind};\n+use rustc_ast::ast::{\n+    AssocItemKind, Extern, FnKind, FnSig, ImplKind, Item, ItemKind, TraitKind, Ty, TyKind,\n+};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;\n@@ -158,18 +160,16 @@ impl EarlyLintPass for ExcessiveBools {\n                         \"consider using a state machine or refactoring bools into two-variant enums\",\n                     );\n                 }\n-            },\n-            ItemKind::Impl {\n-                of_trait: None, items, ..\n             }\n-            | ItemKind::Trait(_, _, _, _, items) => {\n+            ItemKind::Impl(box ImplKind { of_trait: None, items, .. })\n+            | ItemKind::Trait(box TraitKind(.., items)) => {\n                 for item in items {\n-                    if let AssocItemKind::Fn(_, fn_sig, _, _) = &item.kind {\n+                    if let AssocItemKind::Fn(box FnKind(_, fn_sig, _, _)) = &item.kind {\n                         self.check_fn_sig(cx, fn_sig, item.span);\n                     }\n                 }\n-            },\n-            ItemKind::Fn(_, fn_sig, _, _) => self.check_fn_sig(cx, fn_sig, item.span),\n+            }\n+            ItemKind::Fn(box FnKind(_, fn_sig, _, _)) => self.check_fn_sig(cx, fn_sig, item.span),\n             _ => (),\n         }\n     }"}, {"sha": "d5222a030d7afbb495da5f060b9b44d7313f6255", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/448a97bf528edc93e33beb85336bd9a14e20b9b0/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/448a97bf528edc93e33beb85336bd9a14e20b9b0/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=448a97bf528edc93e33beb85336bd9a14e20b9b0", "patch": "@@ -1,5 +1,8 @@\n use crate::utils::{span_lint, span_lint_and_then};\n-use rustc_ast::ast::{Arm, AssocItem, AssocItemKind, Attribute, Block, FnDecl, Item, ItemKind, Local, Pat, PatKind};\n+use rustc_ast::ast::{\n+    Arm, AssocItem, AssocItemKind, Attribute, Block, FnDecl, FnKind, Item, ItemKind, Local, Pat,\n+    PatKind,\n+};\n use rustc_ast::visit::{walk_block, walk_expr, walk_pat, Visitor};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_middle::lint::in_external_macro;\n@@ -364,7 +367,7 @@ impl EarlyLintPass for NonExpressiveNames {\n             return;\n         }\n \n-        if let ItemKind::Fn(_, ref sig, _, Some(ref blk)) = item.kind {\n+        if let ItemKind::Fn(box FnKind(_, ref sig, _, Some(ref blk))) = item.kind {\n             do_check(self, cx, &item.attrs, &sig.decl, blk);\n         }\n     }\n@@ -374,7 +377,7 @@ impl EarlyLintPass for NonExpressiveNames {\n             return;\n         }\n \n-        if let AssocItemKind::Fn(_, ref sig, _, Some(ref blk)) = item.kind {\n+        if let AssocItemKind::Fn(box FnKind(_, ref sig, _, Some(ref blk))) = item.kind {\n             do_check(self, cx, &item.attrs, &sig.decl, blk);\n         }\n     }"}, {"sha": "69492e84e4ac58c44c79316000d830451cd37b28", "filename": "clippy_lints/src/utils/ast_utils.rs", "status": "modified", "additions": 43, "deletions": 24, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/448a97bf528edc93e33beb85336bd9a14e20b9b0/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/448a97bf528edc93e33beb85336bd9a14e20b9b0/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=448a97bf528edc93e33beb85336bd9a14e20b9b0", "patch": "@@ -229,17 +229,26 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n     match (l, r) {\n         (ExternCrate(l), ExternCrate(r)) => l == r,\n         (Use(l), Use(r)) => eq_use_tree(l, r),\n-        (Static(lt, lm, le), Static(rt, rm, re)) => lm == rm && eq_ty(lt, rt) && eq_expr_opt(le, re),\n-        (Const(ld, lt, le), Const(rd, rt, re)) => eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re),\n-        (Fn(ld, lf, lg, lb), Fn(rd, rf, rg, rb)) => {\n-            eq_defaultness(*ld, *rd) && eq_fn_sig(lf, rf) && eq_generics(lg, rg) && both(lb, rb, |l, r| eq_block(l, r))\n-        },\n-        (Mod(l), Mod(r)) => l.inline == r.inline && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_item_kind)),\n+        (Static(lt, lm, le), Static(rt, rm, re)) => {\n+            lm == rm && eq_ty(lt, rt) && eq_expr_opt(le, re)\n+        }\n+        (Const(ld, lt, le), Const(rd, rt, re)) => {\n+            eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re)\n+        }\n+        (Fn(box FnKind(ld, lf, lg, lb)), Fn(box FnKind(rd, rf, rg, rb))) => {\n+            eq_defaultness(*ld, *rd)\n+                && eq_fn_sig(lf, rf)\n+                && eq_generics(lg, rg)\n+                && both(lb, rb, |l, r| eq_block(l, r))\n+        }\n+        (Mod(l), Mod(r)) => {\n+            l.inline == r.inline && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_item_kind))\n+        }\n         (ForeignMod(l), ForeignMod(r)) => {\n             both(&l.abi, &r.abi, |l, r| eq_str_lit(l, r))\n                 && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_foreign_item_kind))\n-        },\n-        (TyAlias(ld, lg, lb, lt), TyAlias(rd, rg, rb, rt)) => {\n+        }\n+        (TyAlias(box TyAliasKind(ld, lg, lb, lt)), TyAlias(box TyAliasKind(rd, rg, rb, rt))) => {\n             eq_defaultness(*ld, *rd)\n                 && eq_generics(lg, rg)\n                 && over(lb, rb, |l, r| eq_generic_bound(l, r))\n@@ -250,8 +259,8 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n         },\n         (Struct(lv, lg), Struct(rv, rg)) | (Union(lv, lg), Union(rv, rg)) => {\n             eq_variant_data(lv, rv) && eq_generics(lg, rg)\n-        },\n-        (Trait(la, lu, lg, lb, li), Trait(ra, ru, rg, rb, ri)) => {\n+        }\n+        (Trait(box TraitKind(la, lu, lg, lb, li)), Trait(box TraitKind(ra, ru, rg, rb, ri))) => {\n             la == ra\n                 && matches!(lu, Unsafe::No) == matches!(ru, Unsafe::No)\n                 && eq_generics(lg, rg)\n@@ -260,7 +269,7 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n         },\n         (TraitAlias(lg, lb), TraitAlias(rg, rb)) => eq_generics(lg, rg) && over(lb, rb, |l, r| eq_generic_bound(l, r)),\n         (\n-            Impl {\n+            Impl(box ImplKind {\n                 unsafety: lu,\n                 polarity: lp,\n                 defaultness: ld,\n@@ -269,8 +278,8 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n                 of_trait: lot,\n                 self_ty: lst,\n                 items: li,\n-            },\n-            Impl {\n+            }),\n+            Impl(box ImplKind {\n                 unsafety: ru,\n                 polarity: rp,\n                 defaultness: rd,\n@@ -279,7 +288,7 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n                 of_trait: rot,\n                 self_ty: rst,\n                 items: ri,\n-            },\n+            }),\n         ) => {\n             matches!(lu, Unsafe::No) == matches!(ru, Unsafe::No)\n                 && matches!(lp, ImplPolarity::Positive) == matches!(rp, ImplPolarity::Positive)\n@@ -299,11 +308,16 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n pub fn eq_foreign_item_kind(l: &ForeignItemKind, r: &ForeignItemKind) -> bool {\n     use ForeignItemKind::*;\n     match (l, r) {\n-        (Static(lt, lm, le), Static(rt, rm, re)) => lm == rm && eq_ty(lt, rt) && eq_expr_opt(le, re),\n-        (Fn(ld, lf, lg, lb), Fn(rd, rf, rg, rb)) => {\n-            eq_defaultness(*ld, *rd) && eq_fn_sig(lf, rf) && eq_generics(lg, rg) && both(lb, rb, |l, r| eq_block(l, r))\n-        },\n-        (TyAlias(ld, lg, lb, lt), TyAlias(rd, rg, rb, rt)) => {\n+        (Static(lt, lm, le), Static(rt, rm, re)) => {\n+            lm == rm && eq_ty(lt, rt) && eq_expr_opt(le, re)\n+        }\n+        (Fn(box FnKind(ld, lf, lg, lb)), Fn(box FnKind(rd, rf, rg, rb))) => {\n+            eq_defaultness(*ld, *rd)\n+                && eq_fn_sig(lf, rf)\n+                && eq_generics(lg, rg)\n+                && both(lb, rb, |l, r| eq_block(l, r))\n+        }\n+        (TyAlias(box TyAliasKind(ld, lg, lb, lt)), TyAlias(box TyAliasKind(rd, rg, rb, rt))) => {\n             eq_defaultness(*ld, *rd)\n                 && eq_generics(lg, rg)\n                 && over(lb, rb, |l, r| eq_generic_bound(l, r))\n@@ -317,11 +331,16 @@ pub fn eq_foreign_item_kind(l: &ForeignItemKind, r: &ForeignItemKind) -> bool {\n pub fn eq_assoc_item_kind(l: &AssocItemKind, r: &AssocItemKind) -> bool {\n     use AssocItemKind::*;\n     match (l, r) {\n-        (Const(ld, lt, le), Const(rd, rt, re)) => eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re),\n-        (Fn(ld, lf, lg, lb), Fn(rd, rf, rg, rb)) => {\n-            eq_defaultness(*ld, *rd) && eq_fn_sig(lf, rf) && eq_generics(lg, rg) && both(lb, rb, |l, r| eq_block(l, r))\n-        },\n-        (TyAlias(ld, lg, lb, lt), TyAlias(rd, rg, rb, rt)) => {\n+        (Const(ld, lt, le), Const(rd, rt, re)) => {\n+            eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re)\n+        }\n+        (Fn(box FnKind(ld, lf, lg, lb)), Fn(box FnKind(rd, rf, rg, rb))) => {\n+            eq_defaultness(*ld, *rd)\n+                && eq_fn_sig(lf, rf)\n+                && eq_generics(lg, rg)\n+                && both(lb, rb, |l, r| eq_block(l, r))\n+        }\n+        (TyAlias(box TyAliasKind(ld, lg, lb, lt)), TyAlias(box TyAliasKind(rd, rg, rb, rt))) => {\n             eq_defaultness(*ld, *rd)\n                 && eq_generics(lg, rg)\n                 && over(lb, rb, |l, r| eq_generic_bound(l, r))"}, {"sha": "b9e97077c540f46cfeb3c9a3f33e49864dcbb210", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/448a97bf528edc93e33beb85336bd9a14e20b9b0/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/448a97bf528edc93e33beb85336bd9a14e20b9b0/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=448a97bf528edc93e33beb85336bd9a14e20b9b0", "patch": "@@ -3,7 +3,9 @@ use std::ops::Range;\n \n use crate::utils::{snippet_with_applicability, span_lint, span_lint_and_sugg, span_lint_and_then};\n use if_chain::if_chain;\n-use rustc_ast::ast::{Expr, ExprKind, Item, ItemKind, LitKind, MacCall, StrLit, StrStyle};\n+use rustc_ast::ast::{\n+    Expr, ExprKind, ImplKind, Item, ItemKind, LitKind, MacCall, StrLit, StrStyle,\n+};\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_errors::Applicability;\n@@ -231,11 +233,7 @@ impl_lint_pass!(Write => [\n \n impl EarlyLintPass for Write {\n     fn check_item(&mut self, _: &EarlyContext<'_>, item: &Item) {\n-        if let ItemKind::Impl {\n-            of_trait: Some(trait_ref),\n-            ..\n-        } = &item.kind\n-        {\n+        if let ItemKind::Impl(box ImplKind { of_trait: Some(trait_ref), .. }) = &item.kind {\n             let trait_name = trait_ref\n                 .path\n                 .segments\n@@ -377,10 +375,15 @@ impl Write {\n     /// (Some(\"string to write: {}\"), Some(buf))\n     /// ```\n     #[allow(clippy::too_many_lines)]\n-    fn check_tts<'a>(&self, cx: &EarlyContext<'a>, tts: TokenStream, is_write: bool) -> (Option<StrLit>, Option<Expr>) {\n+    fn check_tts<'a>(\n+        &self,\n+        cx: &EarlyContext<'a>,\n+        tts: TokenStream,\n+        is_write: bool,\n+    ) -> (Option<StrLit>, Option<Expr>) {\n         use rustc_parse_format::{\n-            AlignUnknown, ArgumentImplicitlyIs, ArgumentIs, ArgumentNamed, CountImplied, FormatSpec, ParseMode, Parser,\n-            Piece,\n+            AlignUnknown, ArgumentImplicitlyIs, ArgumentIs, ArgumentNamed, CountImplied,\n+            FormatSpec, ParseMode, Parser, Piece,\n         };\n \n         let mut parser = parser::Parser::new(&cx.sess.parse_sess, tts, false, None);\n@@ -410,7 +413,12 @@ impl Write {\n             if let Piece::NextArgument(arg) = piece {\n                 if !self.in_debug_impl && arg.format.ty == \"?\" {\n                     // FIXME: modify rustc's fmt string parser to give us the current span\n-                    span_lint(cx, USE_DEBUG, parser.prev_token.span, \"use of `Debug`-based formatting\");\n+                    span_lint(\n+                        cx,\n+                        USE_DEBUG,\n+                        parser.prev_token.span,\n+                        \"use of `Debug`-based formatting\",\n+                    );\n                 }\n                 args.push(arg);\n             }\n@@ -438,7 +446,9 @@ impl Write {\n                 return (Some(fmtstr), None);\n             };\n             match &token_expr.kind {\n-                ExprKind::Lit(lit) if !matches!(lit.kind, LitKind::Int(..) | LitKind::Float(..)) => {\n+                ExprKind::Lit(lit)\n+                    if !matches!(lit.kind, LitKind::Int(..) | LitKind::Float(..)) =>\n+                {\n                     let mut all_simple = true;\n                     let mut seen = false;\n                     for arg in &args {\n@@ -448,15 +458,15 @@ impl Write {\n                                     all_simple &= arg.format == SIMPLE;\n                                     seen = true;\n                                 }\n-                            },\n-                            ArgumentNamed(_) => {},\n+                            }\n+                            ArgumentNamed(_) => {}\n                         }\n                     }\n                     if all_simple && seen {\n                         span_lint(cx, lint, token_expr.span, \"literal with an empty format string\");\n                     }\n                     idx += 1;\n-                },\n+                }\n                 ExprKind::Assign(lhs, rhs, _) => {\n                     if_chain! {\n                         if let ExprKind::Lit(ref lit) = rhs.kind;\n@@ -481,7 +491,7 @@ impl Write {\n                             }\n                         }\n                     }\n-                },\n+                }\n                 _ => idx += 1,\n             }\n         }\n@@ -513,11 +523,17 @@ impl Write {\n                     cx,\n                     PRINT_WITH_NEWLINE,\n                     mac.span(),\n-                    &format!(\"using `{}!()` with a format string that ends in a single newline\", name),\n+                    &format!(\n+                        \"using `{}!()` with a format string that ends in a single newline\",\n+                        name\n+                    ),\n                     |err| {\n                         err.multipart_suggestion(\n                             &format!(\"use `{}!` instead\", suggested),\n-                            vec![(mac.path.span, suggested), (newline_span(&fmt_str), String::new())],\n+                            vec![\n+                                (mac.path.span, suggested),\n+                                (newline_span(&fmt_str), String::new()),\n+                            ],\n                             Applicability::MachineApplicable,\n                         );\n                     },"}]}