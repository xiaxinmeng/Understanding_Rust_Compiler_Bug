{"sha": "a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "node_id": "C_kwDOAAsO6NoAKGE3ZDY0MDhiMDU5MTIzOTY2MThkZmRjYzljYzcxM2QzYWNlMmFhOWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-13T11:18:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-13T11:18:01Z"}, "message": "Auto merge of #96899 - oli-obk:closure_wf_check_bounds, r=nikomatsakis\n\nCheck that closures satisfy their where bounds\n\nfixes https://github.com/rust-lang/rust/issues/53092\nfixes https://github.com/rust-lang/rust/issues/90409\n\nbased on https://github.com/rust-lang/rust/pull/96736", "tree": {"sha": "b910c7ea0ec5136d8b763d77817aff710a4b0312", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b910c7ea0ec5136d8b763d77817aff710a4b0312"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "html_url": "https://github.com/rust-lang/rust/commit/a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c80ac003b59a2e708f127a721904e92ea51d0b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c80ac003b59a2e708f127a721904e92ea51d0b9", "html_url": "https://github.com/rust-lang/rust/commit/1c80ac003b59a2e708f127a721904e92ea51d0b9"}, {"sha": "7a4ac84a902084e613f1668b9e08297f4901320a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a4ac84a902084e613f1668b9e08297f4901320a", "html_url": "https://github.com/rust-lang/rust/commit/7a4ac84a902084e613f1668b9e08297f4901320a"}], "stats": {"total": 511, "additions": 325, "deletions": 186}, "files": [{"sha": "810737587912b6e1795e33ce87b97110d2146f9d", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 106, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -1,11 +1,8 @@\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::def_id::DefId;\n use rustc_hir::OpaqueTyOrigin;\n use rustc_infer::infer::InferCtxt;\n-use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, OpaqueHiddenType, OpaqueTypeKey, TyCtxt, TypeFoldable};\n-use rustc_span::Span;\n use rustc_trait_selection::opaque_types::InferCtxtExt;\n \n use super::RegionInferenceContext;\n@@ -107,21 +104,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             let opaque_type_key =\n                 OpaqueTypeKey { def_id: opaque_type_key.def_id, substs: universal_substs };\n-            let remapped_type = infcx.infer_opaque_definition_from_instantiation(\n+            let ty = infcx.infer_opaque_definition_from_instantiation(\n                 opaque_type_key,\n                 universal_concrete_type,\n                 origin,\n             );\n-            let ty = if check_opaque_type_parameter_valid(\n-                infcx.tcx,\n-                opaque_type_key,\n-                origin,\n-                concrete_type.span,\n-            ) {\n-                remapped_type\n-            } else {\n-                infcx.tcx.ty_error()\n-            };\n             // Sometimes two opaque types are the same only after we remap the generic parameters\n             // back to the opaque type definition. E.g. we may have `OpaqueType<X, Y>` mapped to `(X, Y)`\n             // and `OpaqueType<Y, X>` mapped to `(Y, X)`, and those are the same, but we only know that\n@@ -184,95 +171,3 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         })\n     }\n }\n-\n-fn check_opaque_type_parameter_valid(\n-    tcx: TyCtxt<'_>,\n-    opaque_type_key: OpaqueTypeKey<'_>,\n-    origin: OpaqueTyOrigin,\n-    span: Span,\n-) -> bool {\n-    match origin {\n-        // No need to check return position impl trait (RPIT)\n-        // because for type and const parameters they are correct\n-        // by construction: we convert\n-        //\n-        // fn foo<P0..Pn>() -> impl Trait\n-        //\n-        // into\n-        //\n-        // type Foo<P0...Pn>\n-        // fn foo<P0..Pn>() -> Foo<P0...Pn>.\n-        //\n-        // For lifetime parameters we convert\n-        //\n-        // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n-        //\n-        // into\n-        //\n-        // type foo::<'p0..'pn>::Foo<'q0..'qm>\n-        // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n-        //\n-        // which would error here on all of the `'static` args.\n-        OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return true,\n-        // Check these\n-        OpaqueTyOrigin::TyAlias => {}\n-    }\n-    let opaque_generics = tcx.generics_of(opaque_type_key.def_id);\n-    let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n-    for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n-        let arg_is_param = match arg.unpack() {\n-            GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n-            GenericArgKind::Lifetime(lt) if lt.is_static() => {\n-                tcx.sess\n-                    .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                    .span_label(\n-                        tcx.def_span(opaque_generics.param_at(i, tcx).def_id),\n-                        \"cannot use static lifetime; use a bound lifetime \\\n-                                    instead or remove the lifetime parameter from the \\\n-                                    opaque type\",\n-                    )\n-                    .emit();\n-                return false;\n-            }\n-            GenericArgKind::Lifetime(lt) => {\n-                matches!(*lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n-            }\n-            GenericArgKind::Const(ct) => matches!(ct.val(), ty::ConstKind::Param(_)),\n-        };\n-\n-        if arg_is_param {\n-            seen_params.entry(arg).or_default().push(i);\n-        } else {\n-            // Prevent `fn foo() -> Foo<u32>` from being defining.\n-            let opaque_param = opaque_generics.param_at(i, tcx);\n-            tcx.sess\n-                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                .span_note(\n-                    tcx.def_span(opaque_param.def_id),\n-                    &format!(\n-                        \"used non-generic {} `{}` for generic parameter\",\n-                        opaque_param.kind.descr(),\n-                        arg,\n-                    ),\n-                )\n-                .emit();\n-            return false;\n-        }\n-    }\n-\n-    for (_, indices) in seen_params {\n-        if indices.len() > 1 {\n-            let descr = opaque_generics.param_at(indices[0], tcx).kind.descr();\n-            let spans: Vec<_> = indices\n-                .into_iter()\n-                .map(|i| tcx.def_span(opaque_generics.param_at(i, tcx).def_id))\n-                .collect();\n-            tcx.sess\n-                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                .span_note(spans, &format!(\"{} used multiple times\", descr))\n-                .emit();\n-            return false;\n-        }\n-    }\n-    true\n-}"}, {"sha": "238c6d9999075780d2fc29ba567f68514570b43d", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -82,6 +82,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         ));\n         debug!(?definition_ty);\n \n+        if !check_opaque_type_parameter_valid(\n+            self.tcx,\n+            opaque_type_key,\n+            origin,\n+            instantiated_ty.span,\n+        ) {\n+            return self.tcx.ty_error();\n+        }\n+\n         // Only check this for TAIT. RPIT already supports `src/test/ui/impl-trait/nested-return-type2.rs`\n         // on stable and we'd break that.\n         if let OpaqueTyOrigin::TyAlias = origin {\n@@ -148,6 +157,98 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     }\n }\n \n+fn check_opaque_type_parameter_valid(\n+    tcx: TyCtxt<'_>,\n+    opaque_type_key: OpaqueTypeKey<'_>,\n+    origin: OpaqueTyOrigin,\n+    span: Span,\n+) -> bool {\n+    match origin {\n+        // No need to check return position impl trait (RPIT)\n+        // because for type and const parameters they are correct\n+        // by construction: we convert\n+        //\n+        // fn foo<P0..Pn>() -> impl Trait\n+        //\n+        // into\n+        //\n+        // type Foo<P0...Pn>\n+        // fn foo<P0..Pn>() -> Foo<P0...Pn>.\n+        //\n+        // For lifetime parameters we convert\n+        //\n+        // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n+        //\n+        // into\n+        //\n+        // type foo::<'p0..'pn>::Foo<'q0..'qm>\n+        // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n+        //\n+        // which would error here on all of the `'static` args.\n+        OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return true,\n+        // Check these\n+        OpaqueTyOrigin::TyAlias => {}\n+    }\n+    let opaque_generics = tcx.generics_of(opaque_type_key.def_id);\n+    let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n+    for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n+        let arg_is_param = match arg.unpack() {\n+            GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n+            GenericArgKind::Lifetime(lt) if lt.is_static() => {\n+                tcx.sess\n+                    .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                    .span_label(\n+                        tcx.def_span(opaque_generics.param_at(i, tcx).def_id),\n+                        \"cannot use static lifetime; use a bound lifetime \\\n+                                    instead or remove the lifetime parameter from the \\\n+                                    opaque type\",\n+                    )\n+                    .emit();\n+                return false;\n+            }\n+            GenericArgKind::Lifetime(lt) => {\n+                matches!(*lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n+            }\n+            GenericArgKind::Const(ct) => matches!(ct.val(), ty::ConstKind::Param(_)),\n+        };\n+\n+        if arg_is_param {\n+            seen_params.entry(arg).or_default().push(i);\n+        } else {\n+            // Prevent `fn foo() -> Foo<u32>` from being defining.\n+            let opaque_param = opaque_generics.param_at(i, tcx);\n+            tcx.sess\n+                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                .span_note(\n+                    tcx.def_span(opaque_param.def_id),\n+                    &format!(\n+                        \"used non-generic {} `{}` for generic parameter\",\n+                        opaque_param.kind.descr(),\n+                        arg,\n+                    ),\n+                )\n+                .emit();\n+            return false;\n+        }\n+    }\n+\n+    for (_, indices) in seen_params {\n+        if indices.len() > 1 {\n+            let descr = opaque_generics.param_at(indices[0], tcx).kind.descr();\n+            let spans: Vec<_> = indices\n+                .into_iter()\n+                .map(|i| tcx.def_span(opaque_generics.param_at(i, tcx).def_id))\n+                .collect();\n+            tcx.sess\n+                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                .span_note(spans, &format!(\"{} used multiple times\", descr))\n+                .emit();\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n struct ReverseMapper<'tcx> {\n     tcx: TyCtxt<'tcx>,\n "}, {"sha": "ca40c3452e25b710a2e46353a4a778b2a6ec8d11", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -575,7 +575,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     // generators don't take arguments.\n                 }\n \n-                ty::Closure(_, substs) => {\n+                ty::Closure(did, substs) => {\n                     // Only check the upvar types for WF, not the rest\n                     // of the types within. This is needed because we\n                     // capture the signature and it may not be WF\n@@ -596,18 +596,26 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     // probably always be WF, because it should be\n                     // shorthand for something like `where(T: 'a) {\n                     // fn(&'a T) }`, as discussed in #25860.\n-                    //\n-                    // Note that we are also skipping the generic\n-                    // types. This is consistent with the `outlives`\n-                    // code, but anyway doesn't matter: within the fn\n+                    walker.skip_current_subtree(); // subtree handled below\n+                    // FIXME(eddyb) add the type to `walker` instead of recursing.\n+                    self.compute(substs.as_closure().tupled_upvars_ty().into());\n+                    // Note that we cannot skip the generic types\n+                    // types. Normally, within the fn\n                     // body where they are created, the generics will\n                     // always be WF, and outside of that fn body we\n                     // are not directly inspecting closure types\n                     // anyway, except via auto trait matching (which\n                     // only inspects the upvar types).\n-                    walker.skip_current_subtree(); // subtree handled below\n-                    // FIXME(eddyb) add the type to `walker` instead of recursing.\n-                    self.compute(substs.as_closure().tupled_upvars_ty().into());\n+                    // But when a closure is part of a type-alias-impl-trait\n+                    // then the function that created the defining site may\n+                    // have had more bounds available than the type alias\n+                    // specifies. This may cause us to have a closure in the\n+                    // hidden type that is not actually well formed and\n+                    // can cause compiler crashes when the user abuses unsafe\n+                    // code to procure such a closure.\n+                    // See src/test/ui/type-alias-impl-trait/wf_check_closures.rs\n+                    let obligations = self.nominal_obligations(did, substs);\n+                    self.out.extend(obligations);\n                 }\n \n                 ty::FnPtr(_) => {"}, {"sha": "1ea310d063b82a6db2fe30bfd88d429e21d9efbd", "filename": "src/test/ui/const-generics/generic_const_exprs/closures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.rs?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -1,6 +1,6 @@\n #![feature(generic_const_exprs)]\n #![allow(incomplete_features)]\n fn test<const N: usize>() -> [u8; N + (|| 42)()] {}\n-//~^ ERROR overly complex generic constant\n+//~^ ERROR cycle detected when building an abstract representation\n \n fn main() {}"}, {"sha": "a15dd2016e9e4cc2138de513fd443af4ba9883a7", "filename": "src/test/ui/const-generics/generic_const_exprs/closures.stderr", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -1,13 +1,26 @@\n-error: overly complex generic constant\n+error[E0391]: cycle detected when building an abstract representation for test::{constant#0}\n   --> $DIR/closures.rs:3:35\n    |\n LL | fn test<const N: usize>() -> [u8; N + (|| 42)()] {}\n-   |                                   ^^^^-------^^\n-   |                                       |\n-   |                                       borrowing is not supported in generic constants\n+   |                                   ^^^^^^^^^^^^^\n    |\n-   = help: consider moving this anonymous constant into a `const` function\n-   = note: this operation may be supported in the future\n+note: ...which requires building THIR for `test::{constant#0}`...\n+  --> $DIR/closures.rs:3:35\n+   |\n+LL | fn test<const N: usize>() -> [u8; N + (|| 42)()] {}\n+   |                                   ^^^^^^^^^^^^^\n+note: ...which requires type-checking `test::{constant#0}`...\n+  --> $DIR/closures.rs:3:35\n+   |\n+LL | fn test<const N: usize>() -> [u8; N + (|| 42)()] {}\n+   |                                   ^^^^^^^^^^^^^\n+   = note: ...which again requires building an abstract representation for test::{constant#0}, completing the cycle\n+note: cycle used when checking that `test` is well-formed\n+  --> $DIR/closures.rs:3:1\n+   |\n+LL | fn test<const N: usize>() -> [u8; N + (|| 42)()] {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "15e83ab5a347dfa72ed6971a59661b101fa7e97c", "filename": "src/test/ui/higher-rank-trait-bounds/issue-59311.nll.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.nll.stderr?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -0,0 +1,18 @@\n+error: higher-ranked lifetime error\n+  --> $DIR/issue-59311.rs:17:5\n+   |\n+LL |     v.t(|| {});\n+   |     ^^^^^^^^^^\n+   |\n+   = note: could not prove [closure@$DIR/issue-59311.rs:17:9: 17:14] well-formed\n+\n+error: higher-ranked lifetime error\n+  --> $DIR/issue-59311.rs:17:9\n+   |\n+LL |     v.t(|| {});\n+   |         ^^^^^\n+   |\n+   = note: could not prove for<'a> &'a V: 'static\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "69708577285607ca9573267e414387446d124757", "filename": "src/test/ui/higher-rank-trait-bounds/issue-59311.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.rs?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -14,7 +14,7 @@ pub fn crash<V>(v: &V)\n where\n     for<'a> &'a V: T + 'static,\n {\n-    v.t(|| {}); //~ ERROR: higher-ranked lifetime error\n+    v.t(|| {}); //~ ERROR: `&'a V` does not fulfill the required lifetime\n }\n \n fn main() {}"}, {"sha": "3dd05bba5c0a1b3b00a2fd1bebb84f1e0b163e4f", "filename": "src/test/ui/higher-rank-trait-bounds/issue-59311.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.stderr?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -1,10 +1,15 @@\n-error: higher-ranked lifetime error\n-  --> $DIR/issue-59311.rs:17:9\n+error[E0477]: the type `&'a V` does not fulfill the required lifetime\n+  --> $DIR/issue-59311.rs:17:5\n    |\n LL |     v.t(|| {});\n-   |         ^^^^^\n+   |     ^^^^^^^^^^\n    |\n-   = note: could not prove for<'a> &'a V: 'static\n+note: type must satisfy the static lifetime as required by this binding\n+  --> $DIR/issue-59311.rs:15:24\n+   |\n+LL |     for<'a> &'a V: T + 'static,\n+   |                        ^^^^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0477`."}, {"sha": "093c1c231861f1893fb4c0e68d35a21546575ddc", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -15,7 +15,6 @@ type TwoConsts<const X: usize, const Y: usize> = impl Debug;\n fn one_ty<T: Debug>(t: T) -> TwoTys<T, T> {\n     t\n     //~^ ERROR non-defining opaque type use in defining scope\n-    //~| ERROR `U` doesn't implement `Debug`\n }\n \n fn one_lifetime<'a>(t: &'a u32) -> TwoLifetimes<'a, 'a> {"}, {"sha": "b2edcc5526a4abf329785fae9802006c1e3c3a76", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use.stderr", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -1,14 +1,3 @@\n-error[E0277]: `U` doesn't implement `Debug`\n-  --> $DIR/generic_duplicate_param_use.rs:16:5\n-   |\n-LL |     t\n-   |     ^ `U` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n-   |\n-help: consider restricting type parameter `U`\n-   |\n-LL | type TwoTys<T, U: std::fmt::Debug> = impl Debug;\n-   |                 +++++++++++++++++\n-\n error: non-defining opaque type use in defining scope\n   --> $DIR/generic_duplicate_param_use.rs:16:5\n    |\n@@ -22,7 +11,7 @@ LL | type TwoTys<T, U> = impl Debug;\n    |             ^  ^\n \n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use.rs:22:5\n+  --> $DIR/generic_duplicate_param_use.rs:21:5\n    |\n LL |     t\n    |     ^\n@@ -34,7 +23,7 @@ LL | type TwoLifetimes<'a, 'b> = impl Debug;\n    |                   ^^  ^^\n \n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use.rs:27:5\n+  --> $DIR/generic_duplicate_param_use.rs:26:5\n    |\n LL |     t\n    |     ^\n@@ -45,6 +34,5 @@ note: constant used multiple times\n LL | type TwoConsts<const X: usize, const Y: usize> = impl Debug;\n    |                ^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "45792ba97a7a09482a65f4cb35e4d05e5c42d3a7", "filename": "src/test/ui/type-alias-impl-trait/issue-53092.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53092.rs?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -0,0 +1,14 @@\n+#![feature(type_alias_impl_trait)]\n+#![allow(dead_code)]\n+\n+type Bug<T, U> = impl Fn(T) -> U + Copy;\n+\n+const CONST_BUG: Bug<u8, ()> = unsafe { std::mem::transmute(|_: u8| ()) };\n+\n+fn make_bug<T, U: From<T>>() -> Bug<T, U> {\n+    |x| x.into() //~ ERROR the trait bound `U: From<T>` is not satisfied\n+}\n+\n+fn main() {\n+    CONST_BUG(0);\n+}"}, {"sha": "2d423a0c0dff50c7d8bd6d0cdd7373e4960e5e9a", "filename": "src/test/ui/type-alias-impl-trait/issue-53092.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53092.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53092.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53092.stderr?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `U: From<T>` is not satisfied\n+  --> $DIR/issue-53092.rs:9:5\n+   |\n+LL |     |x| x.into()\n+   |     ^^^^^^^^^^^^ the trait `From<T>` is not implemented for `U`\n+   |\n+note: required by a bound in `make_bug`\n+  --> $DIR/issue-53092.rs:8:19\n+   |\n+LL | fn make_bug<T, U: From<T>>() -> Bug<T, U> {\n+   |                   ^^^^^^^ required by this bound in `make_bug`\n+help: consider restricting type parameter `U`\n+   |\n+LL | type Bug<T, U: std::convert::From<T>> = impl Fn(T) -> U + Copy;\n+   |              +++++++++++++++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "38accc8241cb50bfd6c2f6fc036232914a577bbf", "filename": "src/test/ui/type-alias-impl-trait/issue-60564-working.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564-working.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564-working.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564-working.rs?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -0,0 +1,24 @@\n+#![feature(type_alias_impl_trait)]\n+\n+// check-pass\n+\n+trait IterBits {\n+    type BitsIter: Iterator<Item = u8>;\n+    fn iter_bits(self, n: u8) -> Self::BitsIter;\n+}\n+\n+impl<T: Copy, E> IterBits for T\n+where\n+    T: std::ops::Shr<Output = T>\n+        + std::ops::BitAnd<T, Output = T>\n+        + std::convert::From<u8>\n+        + std::convert::TryInto<u8, Error = E>,\n+    E: std::fmt::Debug,\n+{\n+    type BitsIter = impl std::iter::Iterator<Item = u8>;\n+    fn iter_bits(self, n: u8) -> Self::BitsIter {\n+        (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4fc7679311a2e55b031dd0cf0c460c979476212b", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -19,7 +19,6 @@ where\n     fn iter_bits(self, n: u8) -> Self::BitsIter {\n         (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n         //~^ ERROR non-defining opaque type use in defining scope\n-        //~| ERROR type mismatch resolving\n     }\n }\n "}, {"sha": "bbc93657be32f27501c851460adbfb0554ee0826", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.stderr", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -1,16 +1,3 @@\n-error[E0271]: type mismatch resolving `<[closure@$DIR/issue-60564.rs:20:28: 20:100] as FnOnce<(u8,)>>::Output == I`\n-  --> $DIR/issue-60564.rs:20:9\n-   |\n-LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n-   |                         - this type parameter\n-...\n-LL |         (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u8`, found type parameter `I`\n-   |\n-   = note:        expected type `u8`\n-           found type parameter `I`\n-   = note: required because of the requirements on the impl of `Iterator` for `Map<Rev<std::ops::Range<u8>>, [closure@$DIR/issue-60564.rs:20:28: 20:100]>`\n-\n error: non-defining opaque type use in defining scope\n   --> $DIR/issue-60564.rs:20:9\n    |\n@@ -23,6 +10,5 @@ note: used non-generic type `u8` for generic parameter\n LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n    |                         ^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0271`."}, {"sha": "b50462bf237bb9509f9d090097ef9675af48b8b8", "filename": "src/test/ui/type-alias-impl-trait/issue-68368-non-defining-use.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.rs?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -8,7 +8,6 @@ type Alias<'a, U> = impl Trait<U>;\n \n fn f<'a>() -> Alias<'a, ()> {}\n //~^ ERROR non-defining opaque type use in defining scope\n-//~| ERROR the trait bound `(): Trait<U>` is not satisfied\n \n fn main() {}\n "}, {"sha": "8059621b61a096bc84ed17714d7130d44e864d72", "filename": "src/test/ui/type-alias-impl-trait/issue-68368-non-defining-use.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.stderr?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -1,14 +1,3 @@\n-error[E0277]: the trait bound `(): Trait<U>` is not satisfied\n-  --> $DIR/issue-68368-non-defining-use.rs:9:29\n-   |\n-LL | fn f<'a>() -> Alias<'a, ()> {}\n-   |                             ^^ the trait `Trait<U>` is not implemented for `()`\n-   |\n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n-   |\n-LL | type Alias<'a, U> = impl Trait<U> where (): Trait<U>;\n-   |                                   ++++++++++++++++++\n-\n error: non-defining opaque type use in defining scope\n   --> $DIR/issue-68368-non-defining-use.rs:9:29\n    |\n@@ -21,6 +10,5 @@ note: used non-generic type `()` for generic parameter\n LL | type Alias<'a, U> = impl Trait<U>;\n    |                ^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "428454bc04844d836b75c3a7fbde6796a1e84b53", "filename": "src/test/ui/type-alias-impl-trait/issue-69136-inner-lifetime-resolve-error.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.rs?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -19,6 +19,5 @@ type Return<A> = impl WithAssoc<A, AssocType = impl SomeTrait + 'a>;\n \n fn my_fun() -> Return<()> {}\n //~^ ERROR non-defining opaque type use in defining scope\n-//~| ERROR non-defining opaque type use in defining scope\n \n fn main() {}"}, {"sha": "7b50c8af26e5fe98d74a704b12ff57060e2f612b", "filename": "src/test/ui/type-alias-impl-trait/issue-69136-inner-lifetime-resolve-error.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.stderr?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -26,18 +26,6 @@ note: used non-generic type `()` for generic parameter\n LL | type Return<A> = impl WithAssoc<A, AssocType = impl SomeTrait + 'a>;\n    |             ^\n \n-error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-69136-inner-lifetime-resolve-error.rs:20:27\n-   |\n-LL | fn my_fun() -> Return<()> {}\n-   |                           ^^\n-   |\n-note: used non-generic type `()` for generic parameter\n-  --> $DIR/issue-69136-inner-lifetime-resolve-error.rs:17:13\n-   |\n-LL | type Return<A> = impl WithAssoc<A, AssocType = impl SomeTrait + 'a>;\n-   |             ^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0261`."}, {"sha": "449e9fbd0d847de4308a03af9e764bcb4e224dd0", "filename": "src/test/ui/type-alias-impl-trait/wf-check-fn-def.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fwf-check-fn-def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fwf-check-fn-def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fwf-check-fn-def.rs?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -0,0 +1,18 @@\n+#![feature(type_alias_impl_trait)]\n+\n+trait Bar {\n+    fn bar(&self);\n+}\n+\n+type FooFn<B> = impl FnOnce(B);\n+\n+fn foo<B: Bar>() -> FooFn<B> {\n+    fn mop<B: Bar>(bar: B) { bar.bar() }\n+    mop // NOTE: no function pointer, but function zst item\n+    //~^ ERROR the trait bound `B: Bar` is not satisfied\n+}\n+\n+fn main() {\n+    let boom: FooFn<u32> = unsafe { core::mem::zeroed() };\n+    boom(42);\n+}"}, {"sha": "e0005489d1e7c0bdb59b5ad7e31fa252084fc02d", "filename": "src/test/ui/type-alias-impl-trait/wf-check-fn-def.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fwf-check-fn-def.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fwf-check-fn-def.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fwf-check-fn-def.stderr?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `B: Bar` is not satisfied\n+  --> $DIR/wf-check-fn-def.rs:11:5\n+   |\n+LL |     mop // NOTE: no function pointer, but function zst item\n+   |     ^^^ the trait `Bar` is not implemented for `B`\n+   |\n+note: required by a bound in `mop`\n+  --> $DIR/wf-check-fn-def.rs:10:15\n+   |\n+LL |     fn mop<B: Bar>(bar: B) { bar.bar() }\n+   |               ^^^ required by this bound in `mop`\n+help: consider restricting type parameter `B`\n+   |\n+LL | type FooFn<B: Bar> = impl FnOnce(B);\n+   |             +++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "3b8470e4ae6287db591179cf1ad10c9046f13a62", "filename": "src/test/ui/type-alias-impl-trait/wf-check-fn-ptrs.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fwf-check-fn-ptrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fwf-check-fn-ptrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fwf-check-fn-ptrs.rs?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -0,0 +1,23 @@\n+#![feature(type_alias_impl_trait)]\n+\n+// build-pass\n+\n+trait Bar {\n+    fn bar(&self);\n+}\n+\n+type FooFn<B> = impl FnOnce(B);\n+\n+fn foo<B: Bar>() -> FooFn<B> {\n+    fn mop<B: Bar>(bar: B) { bar.bar() }\n+    mop as fn(B)\n+    // function pointers don't have any obligations on them,\n+    // thus the above compiles. It's obviously unsound to just\n+    // procure a `FooFn` from the ether without making sure that\n+    // the pointer is actually legal for all `B`\n+}\n+\n+fn main() {\n+    let boom: FooFn<u32> = unsafe { core::mem::zeroed() };\n+    boom(42);\n+}"}, {"sha": "2c70696ffcf48e59938f44cdd41c3ea56d7f32b1", "filename": "src/test/ui/type-alias-impl-trait/wf_check_closures.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fwf_check_closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fwf_check_closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fwf_check_closures.rs?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -0,0 +1,17 @@\n+#![feature(type_alias_impl_trait)]\n+\n+trait Bar {\n+    fn bar(&self);\n+}\n+\n+type FooFn<B> = impl FnOnce();\n+\n+fn foo<B: Bar>(bar: B) -> FooFn<B> {\n+    move || { bar.bar() }\n+    //~^ ERROR the trait bound `B: Bar` is not satisfied\n+}\n+\n+fn main() {\n+    let boom: FooFn<u32> = unsafe { core::mem::zeroed() };\n+    boom();\n+}"}, {"sha": "58ae8617b9bd97d0a284f35a87d3f2a27491bcfc", "filename": "src/test/ui/type-alias-impl-trait/wf_check_closures.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fwf_check_closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a7d6408b05912396618dfdcc9cc713d3ace2aa9a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fwf_check_closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fwf_check_closures.stderr?ref=a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `B: Bar` is not satisfied\n+  --> $DIR/wf_check_closures.rs:10:5\n+   |\n+LL |     move || { bar.bar() }\n+   |     ^^^^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `B`\n+   |\n+note: required by a bound in `foo`\n+  --> $DIR/wf_check_closures.rs:9:11\n+   |\n+LL | fn foo<B: Bar>(bar: B) -> FooFn<B> {\n+   |           ^^^ required by this bound in `foo`\n+help: consider restricting type parameter `B`\n+   |\n+LL | type FooFn<B: Bar> = impl FnOnce();\n+   |             +++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}