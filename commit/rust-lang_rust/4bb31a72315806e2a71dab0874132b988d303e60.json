{"sha": "4bb31a72315806e2a71dab0874132b988d303e60", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiYjMxYTcyMzE1ODA2ZTJhNzFkYWIwODc0MTMyYjk4OGQzMDNlNjA=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-03-20T22:23:59Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-03-21T20:25:26Z"}, "message": "Block indenting for struct lit patterns\n\nNow follows struct_lit_style (and most other struct_lit_ options).\n\nRequired a fair bit of refactoring and bug fixes.\n\nFixes #1311", "tree": {"sha": "e1ac001dba268abe6957ad8ae11b695321764d56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1ac001dba268abe6957ad8ae11b695321764d56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bb31a72315806e2a71dab0874132b988d303e60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bb31a72315806e2a71dab0874132b988d303e60", "html_url": "https://github.com/rust-lang/rust/commit/4bb31a72315806e2a71dab0874132b988d303e60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bb31a72315806e2a71dab0874132b988d303e60/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfb1c277a8e5b836b7b2a413bce6b8a056b70d43", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfb1c277a8e5b836b7b2a413bce6b8a056b70d43", "html_url": "https://github.com/rust-lang/rust/commit/bfb1c277a8e5b836b7b2a413bce6b8a056b70d43"}], "stats": {"total": 399, "additions": 244, "deletions": 155}, "files": [{"sha": "a46692917b8984fff6cc3061fd401648942591af", "filename": "rfc-rustfmt.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bb31a72315806e2a71dab0874132b988d303e60/rfc-rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4bb31a72315806e2a71dab0874132b988d303e60/rfc-rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rfc-rustfmt.toml?ref=4bb31a72315806e2a71dab0874132b988d303e60", "patch": "@@ -1,4 +1,4 @@\n fn_args_layout = \"Block\"\n array_layout = \"Block\"\n where_style = \"Rfc\"\n-generics_indent = \"Tabbed\"\n+generics_indent = \"Block\""}, {"sha": "92a5aa7611ed46b7e0255e879c4d5c89ae274ea7", "filename": "src/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bb31a72315806e2a71dab0874132b988d303e60/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb31a72315806e2a71dab0874132b988d303e60/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=4bb31a72315806e2a71dab0874132b988d303e60", "patch": "@@ -320,7 +320,7 @@ create_config! {\n     tab_spaces: usize, 4, \"Number of spaces per tab\";\n     fn_call_width: usize, 60,\n         \"Maximum width of the args of a function call before falling back to vertical formatting\";\n-    struct_lit_width: usize, 16,\n+    struct_lit_width: usize, 18,\n         \"Maximum width in the body of a struct lit before falling back to vertical formatting\";\n     struct_variant_width: usize, 35,\n         \"Maximum width in the body of a struct variant before falling back to vertical formatting\";\n@@ -380,7 +380,7 @@ create_config! {\n     wrap_match_arms: bool, true, \"Wrap multiline match arms in blocks\";\n     match_block_trailing_comma: bool, false,\n         \"Put a trailing comma after a block based match arm (non-block arms are not affected)\";\n-    closure_block_indent_threshold: isize, 5, \"How many lines a closure must have before it is \\\n+    closure_block_indent_threshold: isize, 7, \"How many lines a closure must have before it is \\\n                                                block indented. -1 means never use block indent.\";\n     space_before_type_annotation: bool, false,\n         \"Leave a space before the colon in a type annotation\";"}, {"sha": "aa4988740dc8657252a5418f74db04fc52cd64de", "filename": "src/expr.rs", "status": "modified", "additions": 60, "deletions": 100, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/4bb31a72315806e2a71dab0874132b988d303e60/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb31a72315806e2a71dab0874132b988d303e60/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=4bb31a72315806e2a71dab0874132b988d303e60", "patch": "@@ -19,7 +19,8 @@ use {Indent, Shape, Spanned};\n use codemap::SpanUtils;\n use rewrite::{Rewrite, RewriteContext};\n use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic,\n-            DefinitiveListTactic, definitive_tactic, ListItem, format_item_list};\n+            DefinitiveListTactic, definitive_tactic, ListItem, format_item_list,\n+            struct_lit_shape, struct_lit_tactic, shape_for_tactic, struct_lit_formatting};\n use string::{StringFormat, rewrite_string};\n use utils::{extra_offset, last_line_width, wrap_str, binary_search, first_line_width,\n             semicolon_for_stmt, trimmed_last_line_width, left_most_sub_expr, stmt_expr};\n@@ -658,8 +659,7 @@ impl Rewrite for ast::Stmt {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         let result = match self.node {\n             ast::StmtKind::Local(ref local) => {\n-                local.rewrite(context,\n-                              Shape::legacy(context.config.max_width, shape.indent))\n+                local.rewrite(context, shape)\n             }\n             ast::StmtKind::Expr(ref ex) |\n             ast::StmtKind::Semi(ref ex) => {\n@@ -893,7 +893,6 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             block_width\n         };\n \n-        // TODO this .block() - not what we want if we are actually visually indented\n         let block_shape = Shape { width: block_width, ..shape };\n         let block_str = try_opt!(self.block.rewrite(context, block_shape));\n \n@@ -1120,8 +1119,9 @@ fn rewrite_match(context: &RewriteContext,\n     }\n \n     // `match `cond` {`\n-    let cond_budget = try_opt!(shape.width.checked_sub(8));\n-    let cond_str = try_opt!(cond.rewrite(context, Shape::legacy(cond_budget, shape.indent + 6)));\n+    let cond_shape = try_opt!(shape.shrink_left(6));\n+    let cond_shape = try_opt!(cond_shape.sub_width(2));\n+    let cond_str = try_opt!(cond.rewrite(context, cond_shape));\n     let alt_block_sep = String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n     let block_sep = match context.config.control_brace_style {\n         ControlBraceStyle::AlwaysSameLine => \" \",\n@@ -1563,7 +1563,11 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n     let callee = callee.borrow();\n     // FIXME using byte lens instead of char lens (and probably all over the\n     // place too)\n-    let callee_str = match callee.rewrite(context, Shape { width: max_callee_width, ..shape }) {\n+    let callee_str = match callee.rewrite(context,\n+                                          Shape {\n+                                              width: max_callee_width,\n+                                              ..shape\n+                                          }) {\n         Some(string) => {\n             if !string.contains('\\n') && string.len() > max_callee_width {\n                 panic!(\"{:?} {}\", string, max_callee_width);\n@@ -1731,115 +1735,71 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n     let path_shape = try_opt!(shape.sub_width(2));\n     let path_str = try_opt!(rewrite_path(context, PathContext::Expr, None, path, path_shape));\n \n-    // Foo { a: Foo } - indent is +3, width is -5.\n-    let h_shape = shape.sub_width(path_str.len() + 5);\n-    let v_shape = match context.config.struct_lit_style {\n-        IndentStyle::Visual => {\n-            try_opt!(try_opt!(shape.shrink_left(path_str.len() + 3)).sub_width(2))\n-        }\n-        IndentStyle::Block => {\n-            let shape = shape.block_indent(context.config.tab_spaces);\n-            Shape {\n-                width: try_opt!(context.config.max_width.checked_sub(shape.indent.width())),\n-                ..shape\n-            }\n-        }\n-    };\n+    if fields.len() == 0 && base.is_none() {\n+        return Some(format!(\"{} {{}}\", path_str));\n+    }\n \n     let field_iter = fields.into_iter()\n         .map(StructLitField::Regular)\n         .chain(base.into_iter().map(StructLitField::Base));\n \n+    // Foo { a: Foo } - indent is +3, width is -5.\n+    let (h_shape, v_shape) = try_opt!(struct_lit_shape(shape, context, path_str.len() + 3, 2));\n+\n+    let span_lo = |item: &StructLitField| match *item {\n+        StructLitField::Regular(field) => field.span.lo,\n+        StructLitField::Base(expr) => {\n+            let last_field_hi = fields.last().map_or(span.lo, |field| field.span.hi);\n+            let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo));\n+            let pos = snippet.find_uncommented(\"..\").unwrap();\n+            last_field_hi + BytePos(pos as u32)\n+        }\n+    };\n+    let span_hi = |item: &StructLitField| match *item {\n+        StructLitField::Regular(field) => field.span.hi,\n+        StructLitField::Base(expr) => expr.span.hi,\n+    };\n+    let rewrite = |item: &StructLitField| match *item {\n+        StructLitField::Regular(field) => {\n+            // The 1 taken from the v_budget is for the comma.\n+            rewrite_field(context, field, try_opt!(v_shape.sub_width(1)))\n+        }\n+        StructLitField::Base(expr) => {\n+            // 2 = ..\n+            expr.rewrite(context, try_opt!(v_shape.shrink_left(2))).map(|s| format!(\"..{}\", s))\n+        }\n+    };\n+\n     let items = itemize_list(context.codemap,\n                              field_iter,\n                              \"}\",\n-                             |item| match *item {\n-                                 StructLitField::Regular(field) => field.span.lo,\n-                                 StructLitField::Base(expr) => {\n-        let last_field_hi = fields.last().map_or(span.lo, |field| field.span.hi);\n-        let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo));\n-        let pos = snippet.find_uncommented(\"..\").unwrap();\n-        last_field_hi + BytePos(pos as u32)\n-    }\n-                             },\n-                             |item| match *item {\n-                                 StructLitField::Regular(field) => field.span.hi,\n-                                 StructLitField::Base(expr) => expr.span.hi,\n-                             },\n-                             |item| {\n-        match *item {\n-            StructLitField::Regular(field) => {\n-                // The 1 taken from the v_budget is for the comma.\n-                rewrite_field(context, field, try_opt!(v_shape.sub_width(1)))\n-            }\n-            StructLitField::Base(expr) => {\n-                // 2 = ..\n-                expr.rewrite(context, try_opt!(v_shape.shrink_left(2))).map(|s| format!(\"..{}\", s))\n-            }\n-        }\n-    },\n+                             span_lo,\n+                             span_hi,\n+                             rewrite,\n                              context.codemap.span_after(span, \"{\"),\n                              span.hi);\n     let item_vec = items.collect::<Vec<_>>();\n \n-    let tactic = if let Some(h_shape) = h_shape {\n-        let mut prelim_tactic = match (context.config.struct_lit_style, fields.len()) {\n-            (IndentStyle::Visual, 1) => ListTactic::HorizontalVertical,\n-            _ => context.config.struct_lit_multiline_style.to_list_tactic(),\n-        };\n-\n-        if prelim_tactic == ListTactic::HorizontalVertical && fields.len() > 1 {\n-            prelim_tactic = ListTactic::LimitedHorizontalVertical(context.config.struct_lit_width);\n-        }\n+    let tactic = struct_lit_tactic(h_shape, context, &item_vec);\n+    let nested_shape = shape_for_tactic(tactic, h_shape, v_shape);\n+    let fmt = struct_lit_formatting(nested_shape, tactic, context, base.is_some());\n \n-        definitive_tactic(&item_vec, prelim_tactic, h_shape.width)\n+    let fields_str = try_opt!(write_list(&item_vec, &fmt));\n+    let fields_str = if context.config.struct_lit_style == IndentStyle::Block &&\n+                        (fields_str.contains('\\n') ||\n+                         context.config.struct_lit_multiline_style == MultilineStyle::ForceMulti ||\n+                         fields_str.len() > h_shape.map(|s| s.width).unwrap_or(0)) {\n+        format!(\"\\n{}{}\\n{}\",\n+                v_shape.indent.to_string(context.config),\n+                fields_str,\n+                shape.indent.to_string(context.config))\n     } else {\n-        DefinitiveListTactic::Vertical\n-    };\n-\n-    let nested_shape = match tactic {\n-        DefinitiveListTactic::Horizontal => h_shape.unwrap(),\n-        _ => v_shape,\n-    };\n-\n-    let ends_with_newline = context.config.struct_lit_style != IndentStyle::Visual &&\n-                            tactic == DefinitiveListTactic::Vertical;\n-\n-    let fmt = ListFormatting {\n-        tactic: tactic,\n-        separator: \",\",\n-        trailing_separator: if base.is_some() {\n-            SeparatorTactic::Never\n-        } else {\n-            context.config.trailing_comma\n-        },\n-        shape: nested_shape,\n-        ends_with_newline: ends_with_newline,\n-        config: context.config,\n+        // One liner or visual indent.\n+        format!(\" {} \", fields_str)\n     };\n-    let fields_str = try_opt!(write_list(&item_vec, &fmt));\n \n-    // Empty struct.\n-    if fields_str.is_empty() {\n-        return Some(format!(\"{} {{}}\", path_str));\n-    }\n-\n-    // One liner or visual indent.\n-    if context.config.struct_lit_style == IndentStyle::Visual ||\n-       (context.config.struct_lit_multiline_style != MultilineStyle::ForceMulti &&\n-        !fields_str.contains('\\n') &&\n-        fields_str.len() <= h_shape.map(|s| s.width).unwrap_or(0)) {\n-        return Some(format!(\"{} {{ {} }}\", path_str, fields_str));\n-    }\n+    Some(format!(\"{} {{{}}}\", path_str, fields_str))\n \n-    // Multiple lines.\n-    let inner_indent = v_shape.indent.to_string(context.config);\n-    let outer_indent = shape.indent.to_string(context.config);\n-    Some(format!(\"{} {{\\n{}{}\\n{}}}\",\n-                 path_str,\n-                 inner_indent,\n-                 fields_str,\n-                 outer_indent))\n     // FIXME if context.config.struct_lit_style == Visual, but we run out\n     // of space, we should fall back to BlockIndent.\n }\n@@ -1996,7 +1956,7 @@ pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n     let max_width = try_opt!(shape.width.checked_sub(last_line_width + 1));\n     let rhs = ex.rewrite(context,\n                          Shape::offset(max_width,\n-                                       shape.indent.block_only(),\n+                                       shape.indent,\n                                        shape.indent.alignment + last_line_width + 1));\n \n     fn count_line_breaks(src: &str) -> usize {"}, {"sha": "06c5552121ff0677f208fe4add25de934c66c64c", "filename": "src/items.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bb31a72315806e2a71dab0874132b988d303e60/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb31a72315806e2a71dab0874132b988d303e60/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=4bb31a72315806e2a71dab0874132b988d303e60", "patch": "@@ -37,12 +37,11 @@ impl Rewrite for ast::Local {\n                shape.width,\n                shape.indent);\n         let mut result = \"let \".to_owned();\n-        let pattern_offset = shape.indent + result.len();\n-        // 1 = ;\n-        let pattern_width = try_opt!(shape.width.checked_sub(pattern_offset.width() + 1));\n \n-        let pat_str = try_opt!(self.pat.rewrite(&context,\n-                                                Shape::legacy(pattern_width, pattern_offset)));\n+        let pat_shape = try_opt!(shape.offset_left(result.len()));\n+        // 1 = ;\n+        let pat_shape = try_opt!(pat_shape.sub_width(1));\n+        let pat_str = try_opt!(self.pat.rewrite(&context, pat_shape));\n         result.push_str(&pat_str);\n \n         // String that is placed within the assignment pattern and expression.\n@@ -71,12 +70,13 @@ impl Rewrite for ast::Local {\n \n         if let Some(ref ex) = self.init {\n             // 1 = trailing semicolon;\n-            let budget = try_opt!(shape.width.checked_sub(shape.indent.block_only().width() + 1));\n+            //let budget = try_opt!(shape.width.checked_sub(shape.indent.block_only().width() + 1));\n+            let nested_shape = try_opt!(shape.sub_width(1));\n \n             result = try_opt!(rewrite_assign_rhs(&context,\n                                                  result,\n                                                  ex,\n-                                                 Shape::legacy(budget, shape.indent.block_only())));\n+                                                 nested_shape));\n         }\n \n         result.push(';');"}, {"sha": "aa93061602e1c18839daa1b6a8641867840fbdff", "filename": "src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bb31a72315806e2a71dab0874132b988d303e60/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb31a72315806e2a71dab0874132b988d303e60/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4bb31a72315806e2a71dab0874132b988d303e60", "patch": "@@ -330,6 +330,14 @@ impl Shape {\n              })\n     }\n \n+    pub fn offset_left(&self, width: usize) -> Option<Shape> {\n+        Some(Shape {\n+                 width: try_opt!(self.width.checked_sub(width)),\n+                 indent: self.indent,\n+                 offset: self.offset + width,\n+             })\n+    }\n+\n     pub fn used_width(&self) -> usize {\n         self.indent.block_indent + self.offset\n     }"}, {"sha": "2bdb9cee695a1069e53650c4567561548a22c966", "filename": "src/lists.rs", "status": "modified", "additions": 80, "deletions": 1, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/4bb31a72315806e2a71dab0874132b988d303e60/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb31a72315806e2a71dab0874132b988d303e60/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=4bb31a72315806e2a71dab0874132b988d303e60", "patch": "@@ -15,7 +15,8 @@ use syntax::codemap::{self, CodeMap, BytePos};\n \n use {Indent, Shape};\n use comment::{FindUncommented, rewrite_comment, find_comment_end};\n-use config::Config;\n+use config::{Config, IndentStyle};\n+use rewrite::RewriteContext;\n \n #[derive(Eq, PartialEq, Debug, Copy, Clone)]\n /// Formatting tactic for lists. This will be cast down to a\n@@ -502,3 +503,81 @@ fn comment_len(comment: Option<&str>) -> usize {\n         None => 0,\n     }\n }\n+\n+// Compute horizontal and vertical shapes for a struct-lit-like thing.\n+pub fn struct_lit_shape(shape: Shape,\n+                        context: &RewriteContext,\n+                        prefix_width: usize,\n+                        suffix_width: usize)\n+                        -> Option<(Option<Shape>, Shape)> {\n+    let v_shape = match context.config.struct_lit_style {\n+        IndentStyle::Visual => {\n+            try_opt!(try_opt!(shape.shrink_left(prefix_width)).sub_width(suffix_width))\n+        }\n+        IndentStyle::Block => {\n+            let shape = shape.block_indent(context.config.tab_spaces);\n+            Shape {\n+                width: try_opt!(context.config.max_width.checked_sub(shape.indent.width())),\n+                ..shape\n+            }\n+        }\n+    };\n+    let h_shape = shape.sub_width(prefix_width + suffix_width);\n+    Some((h_shape, v_shape))\n+}\n+\n+// Compute the tactic for the internals of a struct-lit-like thing.\n+pub fn struct_lit_tactic(h_shape: Option<Shape>,\n+                         context: &RewriteContext,\n+                         items: &[ListItem])\n+                         -> DefinitiveListTactic {\n+    if let Some(h_shape) = h_shape {\n+        let mut prelim_tactic = match (context.config.struct_lit_style, items.len()) {\n+            (IndentStyle::Visual, 1) => ListTactic::HorizontalVertical,\n+            _ => context.config.struct_lit_multiline_style.to_list_tactic(),\n+        };\n+\n+        if prelim_tactic == ListTactic::HorizontalVertical && items.len() > 1 {\n+            prelim_tactic = ListTactic::LimitedHorizontalVertical(context.config.struct_lit_width);\n+        }\n+\n+        definitive_tactic(items, prelim_tactic, h_shape.width)\n+    } else {\n+        DefinitiveListTactic::Vertical\n+    }\n+}\n+\n+// Given a tactic and possible shapes for horizontal and vertical layout,\n+// come up with the actual shape to use.\n+pub fn shape_for_tactic(tactic: DefinitiveListTactic,\n+                        h_shape: Option<Shape>,\n+                        v_shape: Shape)\n+                        -> Shape {\n+    match tactic {\n+        DefinitiveListTactic::Horizontal => h_shape.unwrap(),\n+        _ => v_shape,\n+    }\n+}\n+\n+// Create a ListFormatting object for formatting the internals of a\n+// struct-lit-like thing, that is a series of fields.\n+pub fn struct_lit_formatting<'a>(shape: Shape,\n+                                 tactic: DefinitiveListTactic,\n+                                 context: &'a RewriteContext,\n+                                 force_no_trailing_comma: bool)\n+                                 -> ListFormatting<'a> {\n+    let ends_with_newline = context.config.struct_lit_style != IndentStyle::Visual &&\n+                            tactic == DefinitiveListTactic::Vertical;\n+    ListFormatting {\n+        tactic: tactic,\n+        separator: \",\",\n+        trailing_separator: if force_no_trailing_comma {\n+            SeparatorTactic::Never\n+        } else {\n+            context.config.trailing_comma\n+        },\n+        shape: shape,\n+        ends_with_newline: ends_with_newline,\n+        config: context.config,\n+    }\n+}"}, {"sha": "18def6bfb64ab3b7d0cea76b89a5225dc9472676", "filename": "src/patterns.rs", "status": "modified", "additions": 70, "deletions": 44, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/4bb31a72315806e2a71dab0874132b988d303e60/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb31a72315806e2a71dab0874132b988d303e60/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=4bb31a72315806e2a71dab0874132b988d303e60", "patch": "@@ -10,9 +10,11 @@\n \n use Shape;\n use codemap::SpanUtils;\n+use config::{IndentStyle, MultilineStyle};\n use rewrite::{Rewrite, RewriteContext};\n use utils::{wrap_str, format_mutability};\n-use lists::{format_item_list, itemize_list, ListItem};\n+use lists::{format_item_list, itemize_list, ListItem, struct_lit_shape, struct_lit_tactic,\n+            shape_for_tactic, struct_lit_formatting, write_list};\n use expr::{rewrite_unary_prefix, rewrite_pair};\n use types::{rewrite_path, PathContext};\n use super::Spanned;\n@@ -112,48 +114,7 @@ impl Rewrite for Pat {\n                 wrap_str(result, context.config.max_width, shape)\n             }\n             PatKind::Struct(ref path, ref fields, elipses) => {\n-                let path = try_opt!(rewrite_path(context, PathContext::Expr, None, path, shape));\n-\n-                let (elipses_str, terminator) = if elipses { (\", ..\", \"..\") } else { (\"\", \"}\") };\n-\n-                // 5 = `{` plus space before and after plus `}` plus space before.\n-                let budget = try_opt!(shape.width.checked_sub(path.len() + 5 + elipses_str.len()));\n-                // FIXME Using visual indenting, should use block or visual to match\n-                // struct lit preference (however, in practice I think it is rare\n-                // for struct patterns to be multi-line).\n-                // 3 = `{` plus space before and after.\n-                let offset = shape.indent + path.len() + 3;\n-\n-                let items =\n-                    itemize_list(context.codemap,\n-                                 fields.iter(),\n-                                 terminator,\n-                                 |f| f.span.lo,\n-                                 |f| f.span.hi,\n-                                 |f| f.node.rewrite(context, Shape::legacy(budget, offset)),\n-                                 context.codemap.span_after(self.span, \"{\"),\n-                                 self.span.hi);\n-                let mut field_string = try_opt!(format_item_list(items,\n-                                                                 Shape::legacy(budget, offset),\n-                                                                 context.config));\n-                if elipses {\n-                    if field_string.contains('\\n') {\n-                        field_string.push_str(\",\\n\");\n-                        field_string.push_str(&offset.to_string(context.config));\n-                        field_string.push_str(\"..\");\n-                    } else {\n-                        if !field_string.is_empty() {\n-                            field_string.push_str(\", \");\n-                        }\n-                        field_string.push_str(\"..\");\n-                    }\n-                }\n-\n-                if field_string.is_empty() {\n-                    Some(format!(\"{} {{}}\", path))\n-                } else {\n-                    Some(format!(\"{} {{ {} }}\", path, field_string))\n-                }\n+                rewrite_struct_pat(path, fields, elipses, self.span, context, shape)\n             }\n             // FIXME(#819) format pattern macros.\n             PatKind::Mac(..) => {\n@@ -163,6 +124,72 @@ impl Rewrite for Pat {\n     }\n }\n \n+fn rewrite_struct_pat(path: &ast::Path,\n+                      fields: &[codemap::Spanned<ast::FieldPat>],\n+                      elipses: bool,\n+                      span: Span,\n+                      context: &RewriteContext,\n+                      shape: Shape)\n+                      -> Option<String> {\n+    let path_shape = try_opt!(shape.sub_width(2));\n+    let path_str = try_opt!(rewrite_path(context, PathContext::Expr, None, path, path_shape));\n+\n+    if fields.len() == 0 && !elipses {\n+        return Some(format!(\"{} {{}}\", path_str));\n+    }\n+\n+    let (elipses_str, terminator) = if elipses { (\", ..\", \"..\") } else { (\"\", \"}\") };\n+\n+    // 3 = ` { `, 2 = ` }`.\n+    let (h_shape, v_shape) =\n+        try_opt!(struct_lit_shape(shape, context, path_str.len() + 3, elipses_str.len() + 2));\n+\n+    let items = itemize_list(context.codemap,\n+                             fields.iter(),\n+                             terminator,\n+                             |f| f.span.lo,\n+                             |f| f.span.hi,\n+                             |f| f.node.rewrite(context, v_shape),\n+                             context.codemap.span_after(span, \"{\"),\n+                             span.hi);\n+    let item_vec = items.collect::<Vec<_>>();\n+\n+    let tactic = struct_lit_tactic(h_shape, context, &item_vec);\n+    let nested_shape = shape_for_tactic(tactic, h_shape, v_shape);\n+    let fmt = struct_lit_formatting(nested_shape, tactic, context, false);\n+\n+    let mut fields_str = try_opt!(write_list(&item_vec, &fmt));\n+\n+    if elipses {\n+        if fields_str.contains('\\n') {\n+            fields_str.push_str(\"\\n\");\n+            fields_str.push_str(&nested_shape.indent.to_string(context.config));\n+            fields_str.push_str(\"..\");\n+        } else {\n+            if !fields_str.is_empty() {\n+                fields_str.push_str(\", \");\n+            }\n+            fields_str.push_str(\"..\");\n+        }\n+    }\n+\n+\n+    let fields_str = if context.config.struct_lit_style == IndentStyle::Block &&\n+                        (fields_str.contains('\\n') ||\n+                         context.config.struct_lit_multiline_style == MultilineStyle::ForceMulti ||\n+                         fields_str.len() > h_shape.map(|s| s.width).unwrap_or(0)) {\n+        format!(\"\\n{}{}\\n{}\",\n+                v_shape.indent.to_string(context.config),\n+                fields_str,\n+                shape.indent.to_string(context.config))\n+    } else {\n+        // One liner or visual indent.\n+        format!(\" {} \", fields_str)\n+    };\n+\n+    Some(format!(\"{} {{{}}}\", path_str, fields_str))\n+}\n+\n impl Rewrite for FieldPat {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         let pat = self.pat.rewrite(context, shape);\n@@ -176,7 +203,6 @@ impl Rewrite for FieldPat {\n     }\n }\n \n-\n enum TuplePatField<'a> {\n     Pat(&'a ptr::P<ast::Pat>),\n     Dotdot(Span),"}, {"sha": "c9968a996f4c2b92d1258e1731ffd792d548c060", "filename": "tests/source/closure.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bb31a72315806e2a71dab0874132b988d303e60/tests%2Fsource%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb31a72315806e2a71dab0874132b988d303e60/tests%2Fsource%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fclosure.rs?ref=4bb31a72315806e2a71dab0874132b988d303e60", "patch": "@@ -81,3 +81,11 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n }\n+\n+fn foo() {\n+    lifetimes_iter___map(|lasdfasfd| {\n+        let hi = if l.bounds.is_empty() {\n+            l.lifetime.span.hi\n+        };\n+    });\n+}"}, {"sha": "ad6b48aeac9b93cfc7b7da549d74f0552ec33797", "filename": "tests/target/closure.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bb31a72315806e2a71dab0874132b988d303e60/tests%2Ftarget%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb31a72315806e2a71dab0874132b988d303e60/tests%2Ftarget%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fclosure.rs?ref=4bb31a72315806e2a71dab0874132b988d303e60", "patch": "@@ -98,3 +98,11 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n }\n+\n+fn foo() {\n+    lifetimes_iter___map(|lasdfasfd| {\n+                             let hi = if l.bounds.is_empty() {\n+                                 l.lifetime.span.hi\n+                             };\n+                         });\n+}"}]}