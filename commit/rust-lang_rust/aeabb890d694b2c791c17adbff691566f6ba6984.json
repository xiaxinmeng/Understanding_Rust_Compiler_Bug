{"sha": "aeabb890d694b2c791c17adbff691566f6ba6984", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlYWJiODkwZDY5NGIyYzc5MWMxN2FkYmZmNjkxNTY2ZjZiYTY5ODQ=", "commit": {"author": {"name": "Konrad Borowski", "email": "konrad@borowski.pw", "date": "2018-12-29T16:34:56Z"}, "committer": {"name": "Konrad Borowski", "email": "konrad@borowski.pw", "date": "2018-12-29T16:38:15Z"}, "message": "Use match ergonomics for booleans lint", "tree": {"sha": "8820d7dac4b66a916dd3e36169ecc4e3ae412d29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8820d7dac4b66a916dd3e36169ecc4e3ae412d29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aeabb890d694b2c791c17adbff691566f6ba6984", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aeabb890d694b2c791c17adbff691566f6ba6984", "html_url": "https://github.com/rust-lang/rust/commit/aeabb890d694b2c791c17adbff691566f6ba6984", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aeabb890d694b2c791c17adbff691566f6ba6984/comments", "author": {"login": "xfix", "id": 1297598, "node_id": "MDQ6VXNlcjEyOTc1OTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1297598?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xfix", "html_url": "https://github.com/xfix", "followers_url": "https://api.github.com/users/xfix/followers", "following_url": "https://api.github.com/users/xfix/following{/other_user}", "gists_url": "https://api.github.com/users/xfix/gists{/gist_id}", "starred_url": "https://api.github.com/users/xfix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xfix/subscriptions", "organizations_url": "https://api.github.com/users/xfix/orgs", "repos_url": "https://api.github.com/users/xfix/repos", "events_url": "https://api.github.com/users/xfix/events{/privacy}", "received_events_url": "https://api.github.com/users/xfix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xfix", "id": 1297598, "node_id": "MDQ6VXNlcjEyOTc1OTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1297598?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xfix", "html_url": "https://github.com/xfix", "followers_url": "https://api.github.com/users/xfix/followers", "following_url": "https://api.github.com/users/xfix/following{/other_user}", "gists_url": "https://api.github.com/users/xfix/gists{/gist_id}", "starred_url": "https://api.github.com/users/xfix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xfix/subscriptions", "organizations_url": "https://api.github.com/users/xfix/orgs", "repos_url": "https://api.github.com/users/xfix/repos", "events_url": "https://api.github.com/users/xfix/events{/privacy}", "received_events_url": "https://api.github.com/users/xfix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13c857b74509a7f1cd80e69f4b7938a21e848ae3", "url": "https://api.github.com/repos/rust-lang/rust/commits/13c857b74509a7f1cd80e69f4b7938a21e848ae3", "html_url": "https://github.com/rust-lang/rust/commit/13c857b74509a7f1cd80e69f4b7938a21e848ae3"}], "stats": {"total": 42, "additions": 21, "deletions": 21}, "files": [{"sha": "236266c1c4004a4daea099c33f6a54fd0486b6ff", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/aeabb890d694b2c791c17adbff691566f6ba6984/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeabb890d694b2c791c17adbff691566f6ba6984/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=aeabb890d694b2c791c17adbff691566f6ba6984", "patch": "@@ -96,7 +96,7 @@ struct Hir2Qmm<'a, 'tcx: 'a, 'v> {\n impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n     fn extract(&mut self, op: BinOpKind, a: &[&'v Expr], mut v: Vec<Bool>) -> Result<Vec<Bool>, String> {\n         for a in a {\n-            if let ExprKind::Binary(binop, ref lhs, ref rhs) = a.node {\n+            if let ExprKind::Binary(binop, lhs, rhs) = &a.node {\n                 if binop.node == op {\n                     v = self.extract(op, &[lhs, rhs], v)?;\n                     continue;\n@@ -110,14 +110,14 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n     fn run(&mut self, e: &'v Expr) -> Result<Bool, String> {\n         // prevent folding of `cfg!` macros and the like\n         if !in_macro(e.span) {\n-            match e.node {\n-                ExprKind::Unary(UnNot, ref inner) => return Ok(Bool::Not(box self.run(inner)?)),\n-                ExprKind::Binary(binop, ref lhs, ref rhs) => match binop.node {\n+            match &e.node {\n+                ExprKind::Unary(UnNot, inner) => return Ok(Bool::Not(box self.run(inner)?)),\n+                ExprKind::Binary(binop, lhs, rhs) => match &binop.node {\n                     BinOpKind::Or => return Ok(Bool::Or(self.extract(BinOpKind::Or, &[lhs, rhs], Vec::new())?)),\n                     BinOpKind::And => return Ok(Bool::And(self.extract(BinOpKind::And, &[lhs, rhs], Vec::new())?)),\n                     _ => (),\n                 },\n-                ExprKind::Lit(ref lit) => match lit.node {\n+                ExprKind::Lit(lit) => match lit.node {\n                     LitKind::Bool(true) => return Ok(Bool::True),\n                     LitKind::Bool(false) => return Ok(Bool::False),\n                     _ => (),\n@@ -130,8 +130,8 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                 #[allow(clippy::cast_possible_truncation)]\n                 return Ok(Bool::Term(n as u8));\n             }\n-            let negated = match e.node {\n-                ExprKind::Binary(binop, ref lhs, ref rhs) => {\n+            let negated = match &e.node {\n+                ExprKind::Binary(binop, lhs, rhs) => {\n                     if !implements_ord(self.cx, lhs) {\n                         continue;\n                     }\n@@ -184,8 +184,8 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n     }\n \n     fn simplify_not(&self, expr: &Expr) -> Option<String> {\n-        match expr.node {\n-            ExprKind::Binary(binop, ref lhs, ref rhs) => {\n+        match &expr.node {\n+            ExprKind::Binary(binop, lhs, rhs) => {\n                 if !implements_ord(self.cx, lhs) {\n                     return None;\n                 }\n@@ -201,7 +201,7 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n                 }\n                 .and_then(|op| Some(format!(\"{}{}{}\", self.snip(lhs)?, op, self.snip(rhs)?)))\n             },\n-            ExprKind::MethodCall(ref path, _, ref args) if args.len() == 1 => {\n+            ExprKind::MethodCall(path, _, args) if args.len() == 1 => {\n                 let type_of_receiver = self.cx.tables.expr_ty(&args[0]);\n                 if !match_type(self.cx, type_of_receiver, &paths::OPTION)\n                     && !match_type(self.cx, type_of_receiver, &paths::RESULT)\n@@ -221,14 +221,14 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n \n     fn recurse(&mut self, suggestion: &Bool) -> Option<()> {\n         use quine_mc_cluskey::Bool::*;\n-        match *suggestion {\n+        match suggestion {\n             True => {\n                 self.output.push_str(\"true\");\n             },\n             False => {\n                 self.output.push_str(\"false\");\n             },\n-            Not(ref inner) => match **inner {\n+            Not(inner) => match **inner {\n                 And(_) | Or(_) => {\n                     self.output.push('!');\n                     self.output.push('(');\n@@ -251,7 +251,7 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n                     self.recurse(inner)?;\n                 },\n             },\n-            And(ref v) => {\n+            And(v) => {\n                 for (index, inner) in v.iter().enumerate() {\n                     if index > 0 {\n                         self.output.push_str(\" && \");\n@@ -265,15 +265,15 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n                     }\n                 }\n             },\n-            Or(ref v) => {\n+            Or(v) => {\n                 for (index, inner) in v.iter().enumerate() {\n                     if index > 0 {\n                         self.output.push_str(\" || \");\n                     }\n                     self.recurse(inner);\n                 }\n             },\n-            Term(n) => {\n+            &Term(n) => {\n                 let snip = self.snip(self.terminals[n as usize])?;\n                 self.output.push_str(&snip);\n             },\n@@ -325,22 +325,22 @@ struct Stats {\n \n fn terminal_stats(b: &Bool) -> Stats {\n     fn recurse(b: &Bool, stats: &mut Stats) {\n-        match *b {\n+        match b {\n             True | False => stats.ops += 1,\n-            Not(ref inner) => {\n+            Not(inner) => {\n                 match **inner {\n                     And(_) | Or(_) => stats.ops += 1, // brackets are also operations\n                     _ => stats.negations += 1,\n                 }\n                 recurse(inner, stats);\n             },\n-            And(ref v) | Or(ref v) => {\n+            And(v) | Or(v) => {\n                 stats.ops += v.len() - 1;\n                 for inner in v {\n                     recurse(inner, stats);\n                 }\n             },\n-            Term(n) => stats.terminals[n as usize] += 1,\n+            &Term(n) => stats.terminals[n as usize] += 1,\n         }\n     }\n     use quine_mc_cluskey::Bool::*;\n@@ -461,11 +461,11 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n         if in_macro(e.span) {\n             return;\n         }\n-        match e.node {\n+        match &e.node {\n             ExprKind::Binary(binop, _, _) if binop.node == BinOpKind::Or || binop.node == BinOpKind::And => {\n                 self.bool_expr(e)\n             },\n-            ExprKind::Unary(UnNot, ref inner) => {\n+            ExprKind::Unary(UnNot, inner) => {\n                 if self.cx.tables.node_types()[inner.hir_id].is_bool() {\n                     self.bool_expr(e);\n                 } else {"}]}