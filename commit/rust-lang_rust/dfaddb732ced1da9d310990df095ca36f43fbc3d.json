{"sha": "dfaddb732ced1da9d310990df095ca36f43fbc3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmYWRkYjczMmNlZDFkYTlkMzEwOTkwZGYwOTVjYTM2ZjQzZmJjM2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-11T08:32:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-11T08:32:46Z"}, "message": "Auto merge of #27807 - pczarn:arena-internals, r=bluss\n\nFixes #18037 \"TypedArena cannot handle zero-sized types\".\nCloses #17931 \"improve chunk allocation scheme used by Arena / TypedArena\".\nCloses #22847 \"TypedArena should implement Send\". - N.B. Arena cannot implement Send, since it may contain non-Send values.\nCloses #18471 \"`Arena::alloc_copy_inner` (at least) should be renamed and made public.\" - Added `Arena::alloc_bytes`.\nCloses #18261 \"support clearing TypedArena with the chunks preserved\". - Only the largest chunk is preserved.", "tree": {"sha": "9e98b2263c2a9e33ed4d22ecabc9afd228d89f54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e98b2263c2a9e33ed4d22ecabc9afd228d89f54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfaddb732ced1da9d310990df095ca36f43fbc3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfaddb732ced1da9d310990df095ca36f43fbc3d", "html_url": "https://github.com/rust-lang/rust/commit/dfaddb732ced1da9d310990df095ca36f43fbc3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfaddb732ced1da9d310990df095ca36f43fbc3d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69e1f57dfbd32a1a342d696a3e79624da97ebe1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/69e1f57dfbd32a1a342d696a3e79624da97ebe1b", "html_url": "https://github.com/rust-lang/rust/commit/69e1f57dfbd32a1a342d696a3e79624da97ebe1b"}, {"sha": "e2ccc4f744b93f89666fe4c8828905297bb76178", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2ccc4f744b93f89666fe4c8828905297bb76178", "html_url": "https://github.com/rust-lang/rust/commit/e2ccc4f744b93f89666fe4c8828905297bb76178"}], "stats": {"total": 804, "additions": 577, "deletions": 227}, "files": [{"sha": "52bd62f7a660a8da2e5b9a4ab857d32ea8f08fff", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 107, "deletions": 11, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/dfaddb732ced1da9d310990df095ca36f43fbc3d/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfaddb732ced1da9d310990df095ca36f43fbc3d/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=dfaddb732ced1da9d310990df095ca36f43fbc3d", "patch": "@@ -240,6 +240,47 @@ impl<T> RawVec<T> {\n         }\n     }\n \n+    /// Attempts to double the size of the type's backing allocation in place. This is common\n+    /// enough to want to do that it's easiest to just have a dedicated method. Slightly\n+    /// more efficient logic can be provided for this than the general case.\n+    ///\n+    /// Returns true if the reallocation attempt has succeeded, or false otherwise.\n+    ///\n+    /// # Panics\n+    ///\n+    /// * Panics if T is zero-sized on the assumption that you managed to exhaust\n+    ///   all `usize::MAX` slots in your imaginary buffer.\n+    /// * Panics on 32-bit platforms if the requested capacity exceeds\n+    ///   `isize::MAX` bytes.\n+    #[inline(never)]\n+    #[cold]\n+    pub fn double_in_place(&mut self) -> bool {\n+        unsafe {\n+            let elem_size = mem::size_of::<T>();\n+            let align = mem::align_of::<T>();\n+\n+            // since we set the capacity to usize::MAX when elem_size is\n+            // 0, getting to here necessarily means the RawVec is overfull.\n+            assert!(elem_size != 0, \"capacity overflow\");\n+\n+            // Since we guarantee that we never allocate more than isize::MAX bytes,\n+            // `elem_size * self.cap <= isize::MAX` as a precondition, so this can't overflow\n+            let new_cap = 2 * self.cap;\n+            let new_alloc_size = new_cap * elem_size;\n+\n+            alloc_guard(new_alloc_size);\n+            let size = heap::reallocate_inplace(self.ptr() as *mut _,\n+                                                self.cap * elem_size,\n+                                                new_alloc_size,\n+                                                align);\n+            if size >= new_alloc_size {\n+                // We can't directly divide `size`.\n+                self.cap = new_cap;\n+            }\n+            size >= new_alloc_size\n+        }\n+    }\n+\n     /// Ensures that the buffer contains at least enough space to hold\n     /// `used_cap + needed_extra_cap` elements. If it doesn't already,\n     /// will reallocate the minimum possible amount of memory necessary.\n@@ -300,6 +341,22 @@ impl<T> RawVec<T> {\n         }\n     }\n \n+    /// Calculates the buffer's new size given that it'll hold `used_cap +\n+    /// needed_extra_cap` elements. This logic is used in amortized reserve methods.\n+    /// Returns `(new_capacity, new_alloc_size)`.\n+    fn amortized_new_size(&self, used_cap: usize, needed_extra_cap: usize) -> (usize, usize) {\n+        let elem_size = mem::size_of::<T>();\n+        // Nothing we can really do about these checks :(\n+        let required_cap = used_cap.checked_add(needed_extra_cap)\n+                                   .expect(\"capacity overflow\");\n+        // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n+        let double_cap = self.cap * 2;\n+        // `double_cap` guarantees exponential growth.\n+        let new_cap = cmp::max(double_cap, required_cap);\n+        let new_alloc_size = new_cap.checked_mul(elem_size).expect(\"capacity overflow\");\n+        (new_cap, new_alloc_size)\n+    }\n+\n     /// Ensures that the buffer contains at least enough space to hold\n     /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n     /// enough capacity, will reallocate enough space plus comfortable slack\n@@ -360,17 +417,7 @@ impl<T> RawVec<T> {\n                 return;\n             }\n \n-            // Nothing we can really do about these checks :(\n-            let required_cap = used_cap.checked_add(needed_extra_cap)\n-                                       .expect(\"capacity overflow\");\n-\n-            // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n-            let double_cap = self.cap * 2;\n-\n-            // `double_cap` guarantees exponential growth.\n-            let new_cap = cmp::max(double_cap, required_cap);\n-\n-            let new_alloc_size = new_cap.checked_mul(elem_size).expect(\"capacity overflow\");\n+            let (new_cap, new_alloc_size) = self.amortized_new_size(used_cap, needed_extra_cap);\n             // FIXME: may crash and burn on over-reserve\n             alloc_guard(new_alloc_size);\n \n@@ -393,6 +440,55 @@ impl<T> RawVec<T> {\n         }\n     }\n \n+    /// Attempts to ensure that the buffer contains at least enough space to hold\n+    /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n+    /// enough capacity, will reallocate in place enough space plus comfortable slack\n+    /// space to get amortized `O(1)` behaviour. Will limit this behaviour\n+    /// if it would needlessly cause itself to panic.\n+    ///\n+    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n+    /// the requested space. This is not really unsafe, but the unsafe\n+    /// code *you* write that relies on the behaviour of this function may break.\n+    ///\n+    /// Returns true if the reallocation attempt has succeeded, or false otherwise.\n+    ///\n+    /// # Panics\n+    ///\n+    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n+    /// * Panics on 32-bit platforms if the requested capacity exceeds\n+    ///   `isize::MAX` bytes.\n+    pub fn reserve_in_place(&mut self, used_cap: usize, needed_extra_cap: usize) -> bool {\n+        unsafe {\n+            let elem_size = mem::size_of::<T>();\n+            let align = mem::align_of::<T>();\n+\n+            // NOTE: we don't early branch on ZSTs here because we want this\n+            // to actually catch \"asking for more than usize::MAX\" in that case.\n+            // If we make it past the first branch then we are guaranteed to\n+            // panic.\n+\n+            // Don't actually need any more capacity. If the current `cap` is 0, we can't\n+            // reallocate in place.\n+            // Wrapping in case they give a bad `used_cap`\n+            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap || self.cap == 0 {\n+                return false;\n+            }\n+\n+            let (_, new_alloc_size) = self.amortized_new_size(used_cap, needed_extra_cap);\n+            // FIXME: may crash and burn on over-reserve\n+            alloc_guard(new_alloc_size);\n+\n+            let size = heap::reallocate_inplace(self.ptr() as *mut _,\n+                                                self.cap * elem_size,\n+                                                new_alloc_size,\n+                                                align);\n+            if size >= new_alloc_size {\n+                self.cap = new_alloc_size / elem_size;\n+            }\n+            size >= new_alloc_size\n+        }\n+    }\n+\n     /// Shrinks the allocation down to the specified amount. If the given amount\n     /// is 0, actually completely deallocates.\n     ///"}, {"sha": "cd2093984e618ef785f7ee748351f5a06f3c5aed", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 470, "deletions": 216, "changes": 686, "blob_url": "https://github.com/rust-lang/rust/blob/dfaddb732ced1da9d310990df095ca36f43fbc3d/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfaddb732ced1da9d310990df095ca36f43fbc3d/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=dfaddb732ced1da9d310990df095ca36f43fbc3d", "patch": "@@ -29,52 +29,85 @@\n        test(no_crate_inject, attr(deny(warnings))))]\n \n #![feature(alloc)]\n-#![feature(box_syntax)]\n #![feature(core_intrinsics)]\n+#![feature(drop_in_place)]\n #![feature(heap_api)]\n-#![feature(oom)]\n-#![feature(ptr_as_ref)]\n #![feature(raw)]\n+#![feature(heap_api)]\n #![feature(staged_api)]\n #![feature(dropck_parametricity)]\n #![cfg_attr(test, feature(test))]\n \n+#![allow(deprecated)]\n+\n extern crate alloc;\n \n use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::intrinsics;\n-use std::marker;\n+use std::marker::{PhantomData, Send};\n use std::mem;\n use std::ptr;\n-use std::rc::Rc;\n+use std::slice;\n \n-use alloc::heap::{allocate, deallocate};\n+use alloc::heap;\n+use alloc::raw_vec::RawVec;\n \n-// The way arena uses arrays is really deeply awful. The arrays are\n-// allocated, and have capacities reserved, but the fill for the array\n-// will always stay at 0.\n-#[derive(Clone, PartialEq)]\n struct Chunk {\n-    data: Rc<RefCell<Vec<u8>>>,\n+    data: RawVec<u8>,\n+    /// Index of the first unused byte.\n     fill: Cell<usize>,\n+    /// Indicates whether objects with destructors are stored in this chunk.\n     is_copy: Cell<bool>,\n }\n \n impl Chunk {\n+    fn new(size: usize, is_copy: bool) -> Chunk {\n+        Chunk {\n+            data: RawVec::with_capacity(size),\n+            fill: Cell::new(0),\n+            is_copy: Cell::new(is_copy),\n+        }\n+    }\n+\n     fn capacity(&self) -> usize {\n-        self.data.borrow().capacity()\n+        self.data.cap()\n     }\n \n     unsafe fn as_ptr(&self) -> *const u8 {\n-        self.data.borrow().as_ptr()\n+        self.data.ptr()\n+    }\n+\n+    // Walk down a chunk, running the destructors for any objects stored\n+    // in it.\n+    unsafe fn destroy(&self) {\n+        let mut idx = 0;\n+        let buf = self.as_ptr();\n+        let fill = self.fill.get();\n+\n+        while idx < fill {\n+            let tydesc_data = buf.offset(idx as isize) as *const usize;\n+            let (tydesc, is_done) = un_bitpack_tydesc_ptr(*tydesc_data);\n+            let (size, align) = ((*tydesc).size, (*tydesc).align);\n+\n+            let after_tydesc = idx + mem::size_of::<*const TyDesc>();\n+\n+            let start = round_up(after_tydesc, align);\n+\n+            if is_done {\n+                ((*tydesc).drop_glue)(buf.offset(start as isize) as *const i8);\n+            }\n+\n+            // Find where the next tydesc lives\n+            idx = round_up(start + size, mem::align_of::<*const TyDesc>());\n+        }\n     }\n }\n \n /// A slower reflection-based arena that can allocate objects of any type.\n ///\n-/// This arena uses `Vec<u8>` as a backing store to allocate objects from. For\n-/// each allocated object, the arena stores a pointer to the type descriptor\n+/// This arena uses `RawVec<u8>` as a backing store to allocate objects from.\n+/// For each allocated object, the arena stores a pointer to the type descriptor\n /// followed by the object (potentially with alignment padding after each\n /// element). When the arena is destroyed, it iterates through all of its\n /// chunks, and uses the tydesc information to trace through the objects,\n@@ -91,14 +124,17 @@ impl Chunk {\n /// than objects without destructors. This reduces overhead when initializing\n /// plain-old-data (`Copy` types) and means we don't need to waste time running\n /// their destructors.\n+#[unstable(feature = \"rustc_private\",\n+           reason = \"Private to rustc\", issue = \"0\")]\n+#[rustc_deprecated(since = \"1.6.0-dev\", reason =\n+\"The reflection-based arena is superseded by the any-arena crate\")]\n pub struct Arena<'longer_than_self> {\n-    // The head is separated out from the list as a unbenchmarked\n-    // microoptimization, to avoid needing to case on the list to access the\n-    // head.\n+    // The heads are separated out from the list as a unbenchmarked\n+    // microoptimization, to avoid needing to case on the list to access a head.\n     head: RefCell<Chunk>,\n     copy_head: RefCell<Chunk>,\n     chunks: RefCell<Vec<Chunk>>,\n-    _marker: marker::PhantomData<*mut &'longer_than_self ()>,\n+    _marker: PhantomData<*mut &'longer_than_self ()>,\n }\n \n impl<'a> Arena<'a> {\n@@ -110,29 +146,21 @@ impl<'a> Arena<'a> {\n     /// Allocates a new Arena with `initial_size` bytes preallocated.\n     pub fn new_with_size(initial_size: usize) -> Arena<'a> {\n         Arena {\n-            head: RefCell::new(chunk(initial_size, false)),\n-            copy_head: RefCell::new(chunk(initial_size, true)),\n+            head: RefCell::new(Chunk::new(initial_size, false)),\n+            copy_head: RefCell::new(Chunk::new(initial_size, true)),\n             chunks: RefCell::new(Vec::new()),\n-            _marker: marker::PhantomData,\n+            _marker: PhantomData,\n         }\n     }\n }\n \n-fn chunk(size: usize, is_copy: bool) -> Chunk {\n-    Chunk {\n-        data: Rc::new(RefCell::new(Vec::with_capacity(size))),\n-        fill: Cell::new(0),\n-        is_copy: Cell::new(is_copy),\n-    }\n-}\n-\n impl<'longer_than_self> Drop for Arena<'longer_than_self> {\n     fn drop(&mut self) {\n         unsafe {\n-            destroy_chunk(&*self.head.borrow());\n+            self.head.borrow().destroy();\n             for chunk in self.chunks.borrow().iter() {\n                 if !chunk.is_copy.get() {\n-                    destroy_chunk(chunk);\n+                    chunk.destroy();\n                 }\n             }\n         }\n@@ -144,33 +172,6 @@ fn round_up(base: usize, align: usize) -> usize {\n     (base.checked_add(align - 1)).unwrap() & !(align - 1)\n }\n \n-// Walk down a chunk, running the destructors for any objects stored\n-// in it.\n-unsafe fn destroy_chunk(chunk: &Chunk) {\n-    let mut idx = 0;\n-    let buf = chunk.as_ptr();\n-    let fill = chunk.fill.get();\n-\n-    while idx < fill {\n-        let tydesc_data = buf.offset(idx as isize) as *const usize;\n-        let (tydesc, is_done) = un_bitpack_tydesc_ptr(*tydesc_data);\n-        let (size, align) = ((*tydesc).size, (*tydesc).align);\n-\n-        let after_tydesc = idx + mem::size_of::<*const TyDesc>();\n-\n-        let start = round_up(after_tydesc, align);\n-\n-        // debug!(\"freeing object: idx = {}, size = {}, align = {}, done = {}\",\n-        //        start, size, align, is_done);\n-        if is_done {\n-            ((*tydesc).drop_glue)(buf.offset(start as isize) as *const i8);\n-        }\n-\n-        // Find where the next tydesc lives\n-        idx = round_up(start + size, mem::align_of::<*const TyDesc>());\n-    }\n-}\n-\n // We encode whether the object a tydesc describes has been\n // initialized in the arena in the low bit of the tydesc pointer. This\n // is necessary in order to properly do cleanup if a panic occurs\n@@ -187,6 +188,9 @@ fn un_bitpack_tydesc_ptr(p: usize) -> (*const TyDesc, bool) {\n // HACK(eddyb) TyDesc replacement using a trait object vtable.\n // This could be replaced in the future with a custom DST layout,\n // or `&'static (drop_glue, size, align)` created by a `const fn`.\n+// Requirements:\n+// * rvalue promotion (issue #1056)\n+// * mem::{size_of, align_of} must be const fns\n struct TyDesc {\n     drop_glue: fn(*const i8),\n     size: usize,\n@@ -202,39 +206,52 @@ impl<T: ?Sized> AllTypes for T {}\n unsafe fn get_tydesc<T>() -> *const TyDesc {\n     use std::raw::TraitObject;\n \n-    let ptr = &*(1 as *const T);\n+    let ptr = &*(heap::EMPTY as *const T);\n \n     // Can use any trait that is implemented for all types.\n     let obj = mem::transmute::<&AllTypes, TraitObject>(ptr);\n     obj.vtable as *const TyDesc\n }\n \n impl<'longer_than_self> Arena<'longer_than_self> {\n-    fn chunk_size(&self) -> usize {\n-        self.copy_head.borrow().capacity()\n+    // Grows a given chunk and returns `false`, or replaces it with a bigger\n+    // chunk and returns `true`.\n+    // This method is shared by both parts of the arena.\n+    #[cold]\n+    fn alloc_grow(&self, head: &mut Chunk, used_cap: usize, n_bytes: usize) -> bool {\n+        if head.data.reserve_in_place(used_cap, n_bytes) {\n+            // In-place reallocation succeeded.\n+            false\n+        } else {\n+            // Allocate a new chunk.\n+            let new_min_chunk_size = cmp::max(n_bytes, head.capacity());\n+            let new_chunk = Chunk::new((new_min_chunk_size + 1).next_power_of_two(), false);\n+            let old_chunk = mem::replace(head, new_chunk);\n+            if old_chunk.fill.get() != 0 {\n+                self.chunks.borrow_mut().push(old_chunk);\n+            }\n+            true\n+        }\n     }\n \n-    // Functions for the POD part of the arena\n-    fn alloc_copy_grow(&self, n_bytes: usize, align: usize) -> *const u8 {\n-        // Allocate a new chunk.\n-        let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n-        self.chunks.borrow_mut().push(self.copy_head.borrow().clone());\n-\n-        *self.copy_head.borrow_mut() = chunk((new_min_chunk_size + 1).next_power_of_two(), true);\n-\n-        self.alloc_copy_inner(n_bytes, align)\n-    }\n+    // Functions for the copyable part of the arena.\n \n     #[inline]\n     fn alloc_copy_inner(&self, n_bytes: usize, align: usize) -> *const u8 {\n-        let start = round_up(self.copy_head.borrow().fill.get(), align);\n-\n-        let end = start + n_bytes;\n-        if end > self.chunk_size() {\n-            return self.alloc_copy_grow(n_bytes, align);\n+        let mut copy_head = self.copy_head.borrow_mut();\n+        let fill = copy_head.fill.get();\n+        let mut start = round_up(fill, align);\n+        let mut end = start + n_bytes;\n+\n+        if end > copy_head.capacity() {\n+            if self.alloc_grow(&mut *copy_head, fill, end - fill) {\n+                // Continuing with a newly allocated chunk\n+                start = 0;\n+                end = n_bytes;\n+                copy_head.is_copy.set(true);\n+            }\n         }\n \n-        let copy_head = self.copy_head.borrow();\n         copy_head.fill.set(end);\n \n         unsafe { copy_head.as_ptr().offset(start as isize) }\n@@ -252,39 +269,28 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n         }\n     }\n \n-    // Functions for the non-POD part of the arena\n-    fn alloc_noncopy_grow(&self, n_bytes: usize, align: usize) -> (*const u8, *const u8) {\n-        // Allocate a new chunk.\n-        let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n-        self.chunks.borrow_mut().push(self.head.borrow().clone());\n-\n-        *self.head.borrow_mut() = chunk((new_min_chunk_size + 1).next_power_of_two(), false);\n-\n-        self.alloc_noncopy_inner(n_bytes, align)\n-    }\n+    // Functions for the non-copyable part of the arena.\n \n     #[inline]\n     fn alloc_noncopy_inner(&self, n_bytes: usize, align: usize) -> (*const u8, *const u8) {\n-        // Be careful to not maintain any `head` borrows active, because\n-        // `alloc_noncopy_grow` borrows it mutably.\n-        let (start, end, tydesc_start, head_capacity) = {\n-            let head = self.head.borrow();\n-            let fill = head.fill.get();\n-\n-            let tydesc_start = fill;\n-            let after_tydesc = fill + mem::size_of::<*const TyDesc>();\n-            let start = round_up(after_tydesc, align);\n-            let end = start + n_bytes;\n-\n-            (start, end, tydesc_start, head.capacity())\n-        };\n-\n-        if end > head_capacity {\n-            return self.alloc_noncopy_grow(n_bytes, align);\n+        let mut head = self.head.borrow_mut();\n+        let fill = head.fill.get();\n+\n+        let mut tydesc_start = fill;\n+        let after_tydesc = fill + mem::size_of::<*const TyDesc>();\n+        let mut start = round_up(after_tydesc, align);\n+        let mut end = round_up(start + n_bytes, mem::align_of::<*const TyDesc>());\n+\n+        if end > head.capacity() {\n+            if self.alloc_grow(&mut *head, tydesc_start, end - tydesc_start) {\n+                // Continuing with a newly allocated chunk\n+                tydesc_start = 0;\n+                start = round_up(mem::size_of::<*const TyDesc>(), align);\n+                end = round_up(start + n_bytes, mem::align_of::<*const TyDesc>());\n+            }\n         }\n \n-        let head = self.head.borrow();\n-        head.fill.set(round_up(end, mem::align_of::<*const TyDesc>()));\n+        head.fill.set(end);\n \n         unsafe {\n             let buf = head.as_ptr();\n@@ -329,153 +335,124 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n             }\n         }\n     }\n-}\n \n-#[test]\n-fn test_arena_destructors() {\n-    let arena = Arena::new();\n-    for i in 0..10 {\n-        // Arena allocate something with drop glue to make sure it\n-        // doesn't leak.\n-        arena.alloc(|| Rc::new(i));\n-        // Allocate something with funny size and alignment, to keep\n-        // things interesting.\n-        arena.alloc(|| [0u8, 1u8, 2u8]);\n+    /// Allocates a slice of bytes of requested length. The bytes are not guaranteed to be zero\n+    /// if the arena has previously been cleared.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the requested length is too large and causes overflow.\n+    pub fn alloc_bytes(&self, len: usize) -> &mut [u8] {\n+        unsafe {\n+            // Check for overflow.\n+            self.copy_head.borrow().fill.get().checked_add(len).expect(\"length overflow\");\n+            let ptr = self.alloc_copy_inner(len, 1);\n+            intrinsics::assume(!ptr.is_null());\n+            slice::from_raw_parts_mut(ptr as *mut _, len)\n+        }\n     }\n-}\n \n-#[test]\n-#[should_panic]\n-fn test_arena_destructors_fail() {\n-    let arena = Arena::new();\n-    // Put some stuff in the arena.\n-    for i in 0..10 {\n-        // Arena allocate something with drop glue to make sure it\n-        // doesn't leak.\n-        arena.alloc(|| Rc::new(i));\n-        // Allocate something with funny size and alignment, to keep\n-        // things interesting.\n-        arena.alloc(|| [0u8, 1, 2]);\n-    }\n-    // Now, panic while allocating\n-    arena.alloc::<Rc<i32>, _>(|| {\n-        panic!();\n-    });\n+    /// Clears the arena. Deallocates all but the longest chunk which may be reused.\n+    pub fn clear(&mut self) {\n+        unsafe {\n+            self.head.borrow().destroy();\n+            self.head.borrow().fill.set(0);\n+            self.copy_head.borrow().fill.set(0);\n+            for chunk in self.chunks.borrow().iter() {\n+                if !chunk.is_copy.get() {\n+                    chunk.destroy();\n+                }\n+            }\n+            self.chunks.borrow_mut().clear();\n+        }\n+    }\n }\n \n /// A faster arena that can hold objects of only one type.\n pub struct TypedArena<T> {\n     /// A pointer to the next object to be allocated.\n-    ptr: Cell<*const T>,\n+    ptr: Cell<*mut T>,\n \n     /// A pointer to the end of the allocated area. When this pointer is\n     /// reached, a new chunk is allocated.\n-    end: Cell<*const T>,\n+    end: Cell<*mut T>,\n \n-    /// A pointer to the first arena segment.\n-    first: RefCell<*mut TypedArenaChunk<T>>,\n+    /// A vector arena segments.\n+    chunks: RefCell<Vec<TypedArenaChunk<T>>>,\n \n     /// Marker indicating that dropping the arena causes its owned\n     /// instances of `T` to be dropped.\n-    _own: marker::PhantomData<T>,\n+    _own: PhantomData<T>,\n }\n \n struct TypedArenaChunk<T> {\n-    marker: marker::PhantomData<T>,\n-\n     /// Pointer to the next arena segment.\n-    next: *mut TypedArenaChunk<T>,\n-\n-    /// The number of elements that this chunk can hold.\n-    capacity: usize,\n-\n-    // Objects follow here, suitably aligned.\n-}\n-\n-fn calculate_size<T>(capacity: usize) -> usize {\n-    let mut size = mem::size_of::<TypedArenaChunk<T>>();\n-    size = round_up(size, mem::align_of::<T>());\n-    let elem_size = mem::size_of::<T>();\n-    let elems_size = elem_size.checked_mul(capacity).unwrap();\n-    size = size.checked_add(elems_size).unwrap();\n-    size\n+    storage: RawVec<T>,\n }\n \n impl<T> TypedArenaChunk<T> {\n     #[inline]\n-    unsafe fn new(next: *mut TypedArenaChunk<T>, capacity: usize) -> *mut TypedArenaChunk<T> {\n-        let size = calculate_size::<T>(capacity);\n-        let chunk =\n-            allocate(size, mem::align_of::<TypedArenaChunk<T>>()) as *mut TypedArenaChunk<T>;\n-        if chunk.is_null() {\n-            alloc::oom()\n-        }\n-        (*chunk).next = next;\n-        (*chunk).capacity = capacity;\n-        chunk\n+    unsafe fn new(capacity: usize) -> TypedArenaChunk<T> {\n+        TypedArenaChunk { storage: RawVec::with_capacity(capacity) }\n     }\n \n-    /// Destroys this arena chunk. If the type descriptor is supplied, the\n-    /// drop glue is called; otherwise, drop glue is not called.\n+    /// Destroys this arena chunk.\n     #[inline]\n     unsafe fn destroy(&mut self, len: usize) {\n-        // Destroy all the allocated objects.\n+        // The branch on needs_drop() is an -O1 performance optimization.\n+        // Without the branch, dropping TypedArena<u8> takes linear time.\n         if intrinsics::needs_drop::<T>() {\n             let mut start = self.start();\n+            // Destroy all allocated objects.\n             for _ in 0..len {\n-                ptr::read(start as *const T); // run the destructor on the pointer\n-                start = start.offset(mem::size_of::<T>() as isize)\n+                ptr::drop_in_place(start);\n+                start = start.offset(1);\n             }\n         }\n-\n-        // Destroy the next chunk.\n-        let next = self.next;\n-        let size = calculate_size::<T>(self.capacity);\n-        let self_ptr: *mut TypedArenaChunk<T> = self;\n-        deallocate(self_ptr as *mut u8,\n-                   size,\n-                   mem::align_of::<TypedArenaChunk<T>>());\n-        if !next.is_null() {\n-            let capacity = (*next).capacity;\n-            (*next).destroy(capacity);\n-        }\n     }\n \n     // Returns a pointer to the first allocated object.\n     #[inline]\n-    fn start(&self) -> *const u8 {\n-        let this: *const TypedArenaChunk<T> = self;\n-        unsafe { round_up(this.offset(1) as usize, mem::align_of::<T>()) as *const u8 }\n+    fn start(&self) -> *mut T {\n+        self.storage.ptr()\n     }\n \n     // Returns a pointer to the end of the allocated space.\n     #[inline]\n-    fn end(&self) -> *const u8 {\n+    fn end(&self) -> *mut T {\n         unsafe {\n-            let size = mem::size_of::<T>().checked_mul(self.capacity).unwrap();\n-            self.start().offset(size as isize)\n+            if mem::size_of::<T>() == 0 {\n+                // A pointer as large as possible for zero-sized elements.\n+                !0 as *mut T\n+            } else {\n+                self.start().offset(self.storage.cap() as isize)\n+            }\n         }\n     }\n }\n \n+const PAGE: usize = 4096;\n+\n impl<T> TypedArena<T> {\n-    /// Creates a new `TypedArena` with preallocated space for eight objects.\n+    /// Creates a new `TypedArena` with preallocated space for many objects.\n     #[inline]\n     pub fn new() -> TypedArena<T> {\n-        TypedArena::with_capacity(8)\n+        // Reserve at least one page.\n+        let elem_size = cmp::max(1, mem::size_of::<T>());\n+        TypedArena::with_capacity(PAGE / elem_size)\n     }\n \n     /// Creates a new `TypedArena` with preallocated space for the given number of\n     /// objects.\n     #[inline]\n     pub fn with_capacity(capacity: usize) -> TypedArena<T> {\n         unsafe {\n-            let chunk = TypedArenaChunk::<T>::new(ptr::null_mut(), capacity);\n+            let chunk = TypedArenaChunk::<T>::new(cmp::max(1, capacity));\n             TypedArena {\n-                ptr: Cell::new((*chunk).start() as *const T),\n-                end: Cell::new((*chunk).end() as *const T),\n-                first: RefCell::new(chunk),\n-                _own: marker::PhantomData,\n+                ptr: Cell::new(chunk.start()),\n+                end: Cell::new(chunk.end()),\n+                chunks: RefCell::new(vec![chunk]),\n+                _own: PhantomData,\n             }\n         }\n     }\n@@ -488,24 +465,79 @@ impl<T> TypedArena<T> {\n         }\n \n         unsafe {\n-            let ptr: &mut T = &mut *(self.ptr.get() as *mut T);\n-            ptr::write(ptr, object);\n-            self.ptr.set(self.ptr.get().offset(1));\n-            ptr\n+            if mem::size_of::<T>() == 0 {\n+                self.ptr.set(intrinsics::arith_offset(self.ptr.get() as *mut u8, 1) as *mut T);\n+                let ptr = heap::EMPTY as *mut T;\n+                // Don't drop the object. This `write` is equivalent to `forget`.\n+                ptr::write(ptr, object);\n+                &mut *ptr\n+            } else {\n+                let ptr = self.ptr.get();\n+                // Advance the pointer.\n+                self.ptr.set(self.ptr.get().offset(1));\n+                // Write into uninitialized memory.\n+                ptr::write(ptr, object);\n+                &mut *ptr\n+            }\n         }\n     }\n \n     /// Grows the arena.\n     #[inline(never)]\n+    #[cold]\n     fn grow(&self) {\n         unsafe {\n-            let chunk = *self.first.borrow_mut();\n-            let new_capacity = (*chunk).capacity.checked_mul(2).unwrap();\n-            let chunk = TypedArenaChunk::<T>::new(chunk, new_capacity);\n-            self.ptr.set((*chunk).start() as *const T);\n-            self.end.set((*chunk).end() as *const T);\n-            *self.first.borrow_mut() = chunk\n+            let mut chunks = self.chunks.borrow_mut();\n+            let prev_capacity = chunks.last().unwrap().storage.cap();\n+            let new_capacity = prev_capacity.checked_mul(2).unwrap();\n+            if chunks.last_mut().unwrap().storage.double_in_place() {\n+                self.end.set(chunks.last().unwrap().end());\n+            } else {\n+                let chunk = TypedArenaChunk::<T>::new(new_capacity);\n+                self.ptr.set(chunk.start());\n+                self.end.set(chunk.end());\n+                chunks.push(chunk);\n+            }\n+        }\n+    }\n+    /// Clears the arena. Deallocates all but the longest chunk which may be reused.\n+    pub fn clear(&mut self) {\n+        unsafe {\n+            // Clear the last chunk, which is partially filled.\n+            let mut chunks_borrow = self.chunks.borrow_mut();\n+            let last_idx = chunks_borrow.len() - 1;\n+            self.clear_last_chunk(&mut chunks_borrow[last_idx]);\n+            // If `T` is ZST, code below has no effect.\n+            for mut chunk in chunks_borrow.drain(..last_idx) {\n+                let cap = chunk.storage.cap();\n+                chunk.destroy(cap);\n+            }\n+        }\n+    }\n+\n+    // Drops the contents of the last chunk. The last chunk is partially empty, unlike all other\n+    // chunks.\n+    fn clear_last_chunk(&self, last_chunk: &mut TypedArenaChunk<T>) {\n+        // Determine how much was filled.\n+        let start = last_chunk.start() as usize;\n+        // We obtain the value of the pointer to the first uninitialized element.\n+        let end = self.ptr.get() as usize;\n+        // We then calculate the number of elements to be dropped in the last chunk,\n+        // which is the filled area's length.\n+        let diff = if mem::size_of::<T>() == 0 {\n+            // `T` is ZST. It can't have a drop flag, so the value here doesn't matter. We get\n+            // the number of zero-sized values in the last and only chunk, just out of caution.\n+            // Recall that `end` was incremented for each allocated value.\n+            end - start\n+        } else {\n+            (end - start) / mem::size_of::<T>()\n+        };\n+        // Pass that to the `destroy` method.\n+        unsafe {\n+            last_chunk.destroy(diff);\n         }\n+        // Reset the chunk.\n+        self.ptr.set(last_chunk.start());\n     }\n }\n \n@@ -514,23 +546,32 @@ impl<T> Drop for TypedArena<T> {\n     fn drop(&mut self) {\n         unsafe {\n             // Determine how much was filled.\n-            let start = self.first.borrow().as_ref().unwrap().start() as usize;\n-            let end = self.ptr.get() as usize;\n-            let diff = (end - start) / mem::size_of::<T>();\n-\n-            // Pass that to the `destroy` method.\n-            (**self.first.borrow_mut()).destroy(diff)\n+            let mut chunks_borrow = self.chunks.borrow_mut();\n+            let mut last_chunk = chunks_borrow.pop().unwrap();\n+            // Drop the contents of the last chunk.\n+            self.clear_last_chunk(&mut last_chunk);\n+            // The last chunk will be dropped. Destroy all other chunks.\n+            for chunk in chunks_borrow.iter_mut() {\n+                let cap = chunk.storage.cap();\n+                chunk.destroy(cap);\n+            }\n+            // RawVec handles deallocation of `last_chunk` and `self.chunks`.\n         }\n     }\n }\n \n+unsafe impl<T: Send> Send for TypedArena<T> {}\n+\n #[cfg(test)]\n mod tests {\n     extern crate test;\n     use self::test::Bencher;\n     use super::{Arena, TypedArena};\n+    use std::cell::Cell;\n+    use std::rc::Rc;\n \n     #[allow(dead_code)]\n+    #[derive(Debug, Eq, PartialEq)]\n     struct Point {\n         x: i32,\n         y: i32,\n@@ -597,7 +638,7 @@ mod tests {\n     #[bench]\n     pub fn bench_copy_nonarena(b: &mut Bencher) {\n         b.iter(|| {\n-            let _: Box<_> = box Point { x: 1, y: 2, z: 3 };\n+            let _: Box<_> = Box::new(Point { x: 1, y: 2, z: 3 });\n         })\n     }\n \n@@ -624,6 +665,219 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    pub fn test_typed_arena_zero_sized() {\n+        let arena = TypedArena::new();\n+        for _ in 0..100000 {\n+            arena.alloc(());\n+        }\n+    }\n+\n+    #[test]\n+    pub fn test_arena_zero_sized() {\n+        let arena = Arena::new();\n+        let mut points = vec![];\n+        for _ in 0..1000 {\n+            for _ in 0..100 {\n+                arena.alloc(|| ());\n+            }\n+            let point = arena.alloc(|| Point { x: 1, y: 2, z: 3 });\n+            points.push(point);\n+        }\n+        for point in &points {\n+            assert_eq!(**point, Point { x: 1, y: 2, z: 3 });\n+        }\n+    }\n+\n+    #[test]\n+    pub fn test_typed_arena_clear() {\n+        let mut arena = TypedArena::new();\n+        for _ in 0..10 {\n+            arena.clear();\n+            for _ in 0..10000 {\n+                arena.alloc(Point { x: 1, y: 2, z: 3 });\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    pub fn test_arena_clear() {\n+        let mut arena = Arena::new();\n+        for _ in 0..10 {\n+            arena.clear();\n+            for _ in 0..10000 {\n+                arena.alloc(|| Point { x: 1, y: 2, z: 3 });\n+                arena.alloc(|| {\n+                    Noncopy {\n+                        string: \"hello world\".to_string(),\n+                        array: vec![],\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    pub fn test_arena_alloc_bytes() {\n+        let arena = Arena::new();\n+        for i in 0..10000 {\n+            arena.alloc(|| Point { x: 1, y: 2, z: 3 });\n+            for byte in arena.alloc_bytes(i % 42).iter_mut() {\n+                *byte = i as u8;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_arena_destructors() {\n+        let arena = Arena::new();\n+        for i in 0..10 {\n+            // Arena allocate something with drop glue to make sure it\n+            // doesn't leak.\n+            arena.alloc(|| Rc::new(i));\n+            // Allocate something with funny size and alignment, to keep\n+            // things interesting.\n+            arena.alloc(|| [0u8, 1u8, 2u8]);\n+        }\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_arena_destructors_fail() {\n+        let arena = Arena::new();\n+        // Put some stuff in the arena.\n+        for i in 0..10 {\n+            // Arena allocate something with drop glue to make sure it\n+            // doesn't leak.\n+            arena.alloc(|| Rc::new(i));\n+            // Allocate something with funny size and alignment, to keep\n+            // things interesting.\n+            arena.alloc(|| [0u8, 1, 2]);\n+        }\n+        // Now, panic while allocating\n+        arena.alloc::<Rc<i32>, _>(|| {\n+            panic!();\n+        });\n+    }\n+\n+    // Drop tests\n+\n+    struct DropCounter<'a> {\n+        count: &'a Cell<u32>,\n+    }\n+\n+    impl<'a> Drop for DropCounter<'a> {\n+        fn drop(&mut self) {\n+            self.count.set(self.count.get() + 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_arena_drop_count() {\n+        let counter = Cell::new(0);\n+        {\n+            let arena = Arena::new();\n+            for _ in 0..100 {\n+                // Allocate something with drop glue to make sure it doesn't leak.\n+                arena.alloc(|| DropCounter { count: &counter });\n+                // Allocate something with funny size and alignment, to keep\n+                // things interesting.\n+                arena.alloc(|| [0u8, 1u8, 2u8]);\n+            }\n+            // dropping\n+        };\n+        assert_eq!(counter.get(), 100);\n+    }\n+\n+    #[test]\n+    fn test_arena_drop_on_clear() {\n+        let counter = Cell::new(0);\n+        for i in 0..10 {\n+            let mut arena = Arena::new();\n+            for _ in 0..100 {\n+                // Allocate something with drop glue to make sure it doesn't leak.\n+                arena.alloc(|| DropCounter { count: &counter });\n+                // Allocate something with funny size and alignment, to keep\n+                // things interesting.\n+                arena.alloc(|| [0u8, 1u8, 2u8]);\n+            }\n+            arena.clear();\n+            assert_eq!(counter.get(), i * 100 + 100);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_typed_arena_drop_count() {\n+        let counter = Cell::new(0);\n+        {\n+            let arena: TypedArena<DropCounter> = TypedArena::new();\n+            for _ in 0..100 {\n+                // Allocate something with drop glue to make sure it doesn't leak.\n+                arena.alloc(DropCounter { count: &counter });\n+            }\n+        };\n+        assert_eq!(counter.get(), 100);\n+    }\n+\n+    #[test]\n+    fn test_typed_arena_drop_on_clear() {\n+        let counter = Cell::new(0);\n+        let mut arena: TypedArena<DropCounter> = TypedArena::new();\n+        for i in 0..10 {\n+            for _ in 0..100 {\n+                // Allocate something with drop glue to make sure it doesn't leak.\n+                arena.alloc(DropCounter { count: &counter });\n+            }\n+            arena.clear();\n+            assert_eq!(counter.get(), i * 100 + 100);\n+        }\n+    }\n+\n+    thread_local! {\n+        static DROP_COUNTER: Cell<u32> = Cell::new(0)\n+    }\n+\n+    struct SmallDroppable;\n+\n+    impl Drop for SmallDroppable {\n+        fn drop(&mut self) {\n+            DROP_COUNTER.with(|c| c.set(c.get() + 1));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_arena_drop_small_count() {\n+        DROP_COUNTER.with(|c| c.set(0));\n+        {\n+            let arena = Arena::new();\n+            for _ in 0..10 {\n+                for _ in 0..10 {\n+                    // Allocate something with drop glue to make sure it doesn't leak.\n+                    arena.alloc(|| SmallDroppable);\n+                }\n+                // Allocate something with funny size and alignment, to keep\n+                // things interesting.\n+                arena.alloc(|| [0u8, 1u8, 2u8]);\n+            }\n+            // dropping\n+        };\n+        assert_eq!(DROP_COUNTER.with(|c| c.get()), 100);\n+    }\n+\n+    #[test]\n+    fn test_typed_arena_drop_small_count() {\n+        DROP_COUNTER.with(|c| c.set(0));\n+        {\n+            let arena: TypedArena<SmallDroppable> = TypedArena::new();\n+            for _ in 0..100 {\n+                // Allocate something with drop glue to make sure it doesn't leak.\n+                arena.alloc(SmallDroppable);\n+            }\n+            // dropping\n+        };\n+        assert_eq!(DROP_COUNTER.with(|c| c.get()), 100);\n+    }\n+\n     #[bench]\n     pub fn bench_noncopy(b: &mut Bencher) {\n         let arena = TypedArena::new();\n@@ -638,10 +892,10 @@ mod tests {\n     #[bench]\n     pub fn bench_noncopy_nonarena(b: &mut Bencher) {\n         b.iter(|| {\n-            let _: Box<_> = box Noncopy {\n+            let _: Box<_> = Box::new(Noncopy {\n                 string: \"hello world\".to_string(),\n                 array: vec![1, 2, 3, 4, 5],\n-            };\n+            });\n         })\n     }\n "}]}