{"sha": "64c1aef5c846d2daea924bbe99469ef7a3850d98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0YzFhZWY1Yzg0NmQyZGFlYTkyNGJiZTk5NDY5ZWY3YTM4NTBkOTg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-18T03:12:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-18T03:12:23Z"}, "message": "Rollup merge of #35751 - nagisa:mir-scope-fix-again, r=eddyb\n\nFix the invalidation of the MIR early exit cache\n\n~~The #34307 introduced a cache for early exits in order to help with O(n*m) explosion of cleanup blocks but the cache is invalidated incorrectly and I can\u2019t seem to figure out why (caching is hard!)~~\n\n~~Remove the cache for now to fix the immediate correctness issue and worry about the performance later.~~\n\nCache invalidation got fixed.\n\nFixes #35737\n\nr? @nikomatsakis", "tree": {"sha": "466f66eafe5e3fb96c92581bcb36ced3196cfb56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/466f66eafe5e3fb96c92581bcb36ced3196cfb56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64c1aef5c846d2daea924bbe99469ef7a3850d98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64c1aef5c846d2daea924bbe99469ef7a3850d98", "html_url": "https://github.com/rust-lang/rust/commit/64c1aef5c846d2daea924bbe99469ef7a3850d98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64c1aef5c846d2daea924bbe99469ef7a3850d98/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e13de810fce5798671168249f2bac175a62bc64", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e13de810fce5798671168249f2bac175a62bc64", "html_url": "https://github.com/rust-lang/rust/commit/1e13de810fce5798671168249f2bac175a62bc64"}, {"sha": "2c3250adfa4676467f9ab31201a26187a66cbe0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c3250adfa4676467f9ab31201a26187a66cbe0b", "html_url": "https://github.com/rust-lang/rust/commit/2c3250adfa4676467f9ab31201a26187a66cbe0b"}], "stats": {"total": 116, "additions": 96, "deletions": 20}, "files": [{"sha": "2f83c0ef1bebbc4bcadb36afa537eeed1c483c79", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 59, "deletions": 20, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/64c1aef5c846d2daea924bbe99469ef7a3850d98/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c1aef5c846d2daea924bbe99469ef7a3850d98/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=64c1aef5c846d2daea924bbe99469ef7a3850d98", "patch": "@@ -198,8 +198,11 @@ impl<'tcx> Scope<'tcx> {\n     ///\n     /// Should always be run for all inner scopes when a drop is pushed into some scope enclosing a\n     /// larger extent of code.\n-    fn invalidate_cache(&mut self) {\n-        self.cached_exits = FnvHashMap();\n+    ///\n+    /// `unwind` controls whether caches for the unwind branch are also invalidated.\n+    fn invalidate_cache(&mut self, unwind: bool) {\n+        self.cached_exits.clear();\n+        if !unwind { return; }\n         for dropdata in &mut self.drops {\n             if let DropKind::Value { ref mut cached_block } = dropdata.kind {\n                 *cached_block = None;\n@@ -455,25 +458,65 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n \n         for scope in self.scopes.iter_mut().rev() {\n-            if scope.extent == extent {\n+            let this_scope = scope.extent == extent;\n+            // When building drops, we try to cache chains of drops in such a way so these drops\n+            // could be reused by the drops which would branch into the cached (already built)\n+            // blocks.  This, however, means that whenever we add a drop into a scope which already\n+            // had some blocks built (and thus, cached) for it, we must invalidate all caches which\n+            // might branch into the scope which had a drop just added to it. This is necessary,\n+            // because otherwise some other code might use the cache to branch into already built\n+            // chain of drops, essentially ignoring the newly added drop.\n+            //\n+            // For example consider there\u2019s two scopes with a drop in each. These are built and\n+            // thus the caches are filled:\n+            //\n+            // +--------------------------------------------------------+\n+            // | +---------------------------------+                    |\n+            // | | +--------+     +-------------+  |  +---------------+ |\n+            // | | | return | <-+ | drop(outer) | <-+ |  drop(middle) | |\n+            // | | +--------+     +-------------+  |  +---------------+ |\n+            // | +------------|outer_scope cache|--+                    |\n+            // +------------------------------|middle_scope cache|------+\n+            //\n+            // Now, a new, inner-most scope is added along with a new drop into both inner-most and\n+            // outer-most scopes:\n+            //\n+            // +------------------------------------------------------------+\n+            // | +----------------------------------+                       |\n+            // | | +--------+      +-------------+  |   +---------------+   | +-------------+\n+            // | | | return | <+   | drop(new)   | <-+  |  drop(middle) | <--+| drop(inner) |\n+            // | | +--------+  |   | drop(outer) |  |   +---------------+   | +-------------+\n+            // | |             +-+ +-------------+  |                       |\n+            // | +---|invalid outer_scope cache|----+                       |\n+            // +----=----------------|invalid middle_scope cache|-----------+\n+            //\n+            // If, when adding `drop(new)` we do not invalidate the cached blocks for both\n+            // outer_scope and middle_scope, then, when building drops for the inner (right-most)\n+            // scope, the old, cached blocks, without `drop(new)` will get used, producing the\n+            // wrong results.\n+            //\n+            // The cache and its invalidation for unwind branch is somewhat special. The cache is\n+            // per-drop, rather than per scope, which has a several different implications. Adding\n+            // a new drop into a scope will not invalidate cached blocks of the prior drops in the\n+            // scope. That is true, because none of the already existing drops will have an edge\n+            // into a block with the newly added drop.\n+            //\n+            // Note that this code iterates scopes from the inner-most to the outer-most,\n+            // invalidating caches of each scope visited. This way bare minimum of the\n+            // caches gets invalidated. i.e. if a new drop is added into the middle scope, the\n+            // cache of outer scpoe stays intact.\n+            let invalidate_unwind = needs_drop && !this_scope;\n+            scope.invalidate_cache(invalidate_unwind);\n+            if this_scope {\n                 if let DropKind::Value { .. } = drop_kind {\n                     scope.needs_cleanup = true;\n                 }\n-\n-                // No need to invalidate any caches here. The just-scheduled drop will branch into\n-                // the drop that comes before it in the vector.\n                 scope.drops.push(DropData {\n                     span: span,\n                     location: lvalue.clone(),\n                     kind: drop_kind\n                 });\n                 return;\n-            } else {\n-                // We must invalidate all the cached_blocks leading up to the scope we\u2019re\n-                // looking for, because all of the blocks in the chain will become incorrect.\n-                if let DropKind::Value { .. } = drop_kind {\n-                    scope.invalidate_cache()\n-                }\n             }\n         }\n         span_bug!(span, \"extent {:?} not in scope to drop {:?}\", extent, lvalue);\n@@ -490,11 +533,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                              value: &Lvalue<'tcx>,\n                              item_ty: Ty<'tcx>) {\n         for scope in self.scopes.iter_mut().rev() {\n+            // See the comment in schedule_drop above. The primary difference is that we invalidate\n+            // the unwind blocks unconditionally. That\u2019s because the box free may be considered\n+            // outer-most cleanup within the scope.\n+            scope.invalidate_cache(true);\n             if scope.extent == extent {\n                 assert!(scope.free.is_none(), \"scope already has a scheduled free!\");\n-                // We also must invalidate the caches in the scope for which the free is scheduled\n-                // because the drops must branch into the free we schedule here.\n-                scope.invalidate_cache();\n                 scope.needs_cleanup = true;\n                 scope.free = Some(FreeData {\n                     span: span,\n@@ -503,11 +547,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     cached_block: None\n                 });\n                 return;\n-            } else {\n-                // We must invalidate all the cached_blocks leading up to the scope we\u2019re looking\n-                // for, because otherwise some/most of the blocks in the chain will become\n-                // incorrect.\n-                scope.invalidate_cache();\n             }\n         }\n         span_bug!(span, \"extent {:?} not in scope to free {:?}\", extent, value);"}, {"sha": "c27e57358b09b848c18bfbcd974b2bbcf2cd3486", "filename": "src/test/run-pass/mir_early_return_scope.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/64c1aef5c846d2daea924bbe99469ef7a3850d98/src%2Ftest%2Frun-pass%2Fmir_early_return_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c1aef5c846d2daea924bbe99469ef7a3850d98/src%2Ftest%2Frun-pass%2Fmir_early_return_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_early_return_scope.rs?ref=64c1aef5c846d2daea924bbe99469ef7a3850d98", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static mut DROP: bool = false;\n+\n+struct ConnWrap(Conn);\n+impl ::std::ops::Deref for ConnWrap {\n+    type Target=Conn;\n+    fn deref(&self) -> &Conn { &self.0 }\n+}\n+\n+struct Conn;\n+impl Drop for  Conn {\n+    fn drop(&mut self) { unsafe { DROP = true; } }\n+}\n+\n+fn inner() {\n+    let conn = &*match Some(ConnWrap(Conn)) {\n+        Some(val) => val,\n+        None => return,\n+    };\n+    return;\n+}\n+\n+fn main() {\n+    inner();\n+    unsafe {\n+        assert_eq!(DROP, true);\n+    }\n+}"}]}