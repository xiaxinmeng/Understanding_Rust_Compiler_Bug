{"sha": "bf7dbff9210497ca3db0b19b5ca0c6daed47e64e", "node_id": "C_kwDOAAsO6NoAKGJmN2RiZmY5MjEwNDk3Y2EzZGIwYjE5YjVjYTBjNmRhZWQ0N2U2NGU", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-01-17T09:21:30Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-01-18T07:11:13Z"}, "message": "instantiate canonical vars eagerly", "tree": {"sha": "71b70b935d2d46a74c062849a2596a1a65059eee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71b70b935d2d46a74c062849a2596a1a65059eee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e", "html_url": "https://github.com/rust-lang/rust/commit/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b738b0616093dbe6ce14bd640d44cf4252981d56", "url": "https://api.github.com/repos/rust-lang/rust/commits/b738b0616093dbe6ce14bd640d44cf4252981d56", "html_url": "https://github.com/rust-lang/rust/commit/b738b0616093dbe6ce14bd640d44cf4252981d56"}], "stats": {"total": 1005, "additions": 509, "deletions": 496}, "files": [{"sha": "4166f79c96c8234dea5c41fe0a8194c574f2e55f", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=bf7dbff9210497ca3db0b19b5ca0c6daed47e64e", "patch": "@@ -1106,17 +1106,6 @@ impl<'tcx, T> Binder<'tcx, T> {\n         if self.0.has_escaping_bound_vars() { None } else { Some(self.skip_binder()) }\n     }\n \n-    pub fn no_bound_vars_ignoring_escaping(self, tcx: TyCtxt<'tcx>) -> Option<T>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        if !self.0.has_escaping_bound_vars() {\n-            Some(self.skip_binder())\n-        } else {\n-            self.0.try_fold_with(&mut SkipBindersAt { index: ty::INNERMOST, tcx }).ok()\n-        }\n-    }\n-\n     /// Splits the contents into two things that share the same binder\n     /// level as the original, returning two distinct binders.\n     ///"}, {"sha": "da6bb844a0fbeb010e572cbdc4db60ecc954beb2", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 27, "deletions": 51, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=bf7dbff9210497ca3db0b19b5ca0c6daed47e64e", "patch": "@@ -1,20 +1,11 @@\n //! Code shared by trait and projection goals for candidate assembly.\n \n use super::infcx_ext::InferCtxtExt;\n-use super::{\n-    instantiate_canonical_query_response, CanonicalGoal, CanonicalResponse, Certainty, EvalCtxt,\n-    Goal,\n-};\n+use super::{CanonicalResponse, Certainty, EvalCtxt, Goal};\n use rustc_hir::def_id::DefId;\n-use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::infer::{\n-    canonical::{CanonicalVarValues, OriginalQueryValues},\n-    InferCtxt,\n-};\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_span::DUMMY_SP;\n use std::fmt::Debug;\n \n /// A candidate is a possible way to prove a goal.\n@@ -40,7 +31,7 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy {\n     fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId;\n \n     fn consider_impl_candidate(\n-        acx: &mut AssemblyCtxt<'_, 'tcx, Self>,\n+        acx: &mut AssemblyCtxt<'_, '_, 'tcx, Self>,\n         goal: Goal<'tcx, Self>,\n         impl_def_id: DefId,\n     );\n@@ -49,21 +40,17 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy {\n /// An abstraction which correctly deals with the canonical results for candidates.\n ///\n /// It also deduplicates the behavior between trait and projection predicates.\n-pub(super) struct AssemblyCtxt<'a, 'tcx, G: GoalKind<'tcx>> {\n-    pub(super) cx: &'a mut EvalCtxt<'tcx>,\n-    pub(super) infcx: &'a InferCtxt<'tcx>,\n-    var_values: CanonicalVarValues<'tcx>,\n+pub(super) struct AssemblyCtxt<'a, 'b, 'tcx, G: GoalKind<'tcx>> {\n+    pub(super) cx: &'a mut EvalCtxt<'b, 'tcx>,\n     candidates: Vec<Candidate<'tcx, G>>,\n }\n \n-impl<'a, 'tcx, G: GoalKind<'tcx>> AssemblyCtxt<'a, 'tcx, G> {\n+impl<'a, 'b, 'tcx, G: GoalKind<'tcx>> AssemblyCtxt<'a, 'b, 'tcx, G> {\n     pub(super) fn assemble_and_evaluate_candidates(\n-        cx: &'a mut EvalCtxt<'tcx>,\n-        goal: CanonicalGoal<'tcx, G>,\n+        cx: &'a mut EvalCtxt<'b, 'tcx>,\n+        goal: Goal<'tcx, G>,\n     ) -> Vec<Candidate<'tcx, G>> {\n-        let (ref infcx, goal, var_values) =\n-            cx.tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &goal);\n-        let mut acx = AssemblyCtxt { cx, infcx, var_values, candidates: Vec::new() };\n+        let mut acx = AssemblyCtxt { cx, candidates: Vec::new() };\n \n         acx.assemble_candidates_after_normalizing_self_ty(goal);\n \n@@ -77,7 +64,7 @@ impl<'a, 'tcx, G: GoalKind<'tcx>> AssemblyCtxt<'a, 'tcx, G> {\n         source: G::CandidateSource,\n         certainty: Certainty,\n     ) {\n-        match self.infcx.make_canonical_response(self.var_values.clone(), certainty) {\n+        match self.cx.make_canonical_response(certainty) {\n             Ok(result) => self.candidates.push(Candidate { source, result }),\n             Err(NoSolution) => debug!(?source, ?certainty, \"failed leakcheck\"),\n         }\n@@ -89,57 +76,46 @@ impl<'a, 'tcx, G: GoalKind<'tcx>> AssemblyCtxt<'a, 'tcx, G> {\n     /// self type to the list of candidates in case that succeeds. Note that we can't just eagerly return in\n     /// this case as projections as self types add `\n     fn assemble_candidates_after_normalizing_self_ty(&mut self, goal: Goal<'tcx, G>) {\n-        let tcx = self.cx.tcx;\n+        let tcx = self.cx.tcx();\n+        let infcx = self.cx.infcx;\n         // FIXME: We also have to normalize opaque types, not sure where to best fit that in.\n         let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.self_ty().kind() else {\n             return\n         };\n-        self.infcx.probe(|_| {\n-            let normalized_ty = self.infcx.next_ty_infer();\n+        infcx.probe(|_| {\n+            let normalized_ty = infcx.next_ty_infer();\n             let normalizes_to_goal = goal.with(\n                 tcx,\n                 ty::Binder::dummy(ty::ProjectionPredicate {\n                     projection_ty,\n                     term: normalized_ty.into(),\n                 }),\n             );\n-            let normalization_certainty =\n-                match self.cx.evaluate_goal(&self.infcx, normalizes_to_goal) {\n-                    Ok((_, certainty)) => certainty,\n-                    Err(NoSolution) => return,\n-                };\n+            let normalization_certainty = match self.cx.evaluate_goal(normalizes_to_goal) {\n+                Ok((_, certainty)) => certainty,\n+                Err(NoSolution) => return,\n+            };\n \n             // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n             // This doesn't work as long as we use `CandidateSource` in both winnowing and to resolve associated items.\n             let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n-            let mut orig_values = OriginalQueryValues::default();\n-            let goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n             let normalized_candidates =\n                 AssemblyCtxt::assemble_and_evaluate_candidates(self.cx, goal);\n-\n-            // Map each candidate from being canonical wrt the current inference context to being\n-            // canonical wrt the caller.\n-            for Candidate { source, result } in normalized_candidates {\n-                self.infcx.probe(|_| {\n-                    let candidate_certainty =\n-                        instantiate_canonical_query_response(&self.infcx, &orig_values, result);\n-\n-                    // FIXME: This is a bit scary if the `normalizes_to_goal` overflows.\n-                    //\n-                    // If we have an ambiguous candidate it hides that normalization\n-                    // caused an overflow which may cause issues.\n-                    self.try_insert_candidate(\n-                        source,\n-                        normalization_certainty.unify_and(candidate_certainty),\n-                    )\n-                })\n+            for mut normalized_candidate in normalized_candidates {\n+                normalized_candidate.result =\n+                    normalized_candidate.result.unchecked_map(|mut response| {\n+                        response.certainty = response.certainty.unify_and(normalization_certainty);\n+                        response\n+                    });\n+                self.candidates.push(normalized_candidate);\n             }\n         })\n     }\n \n     fn assemble_impl_candidates(&mut self, goal: Goal<'tcx, G>) {\n-        self.cx.tcx.for_each_relevant_impl(\n-            goal.predicate.trait_def_id(self.cx.tcx),\n+        let tcx = self.cx.tcx();\n+        tcx.for_each_relevant_impl(\n+            goal.predicate.trait_def_id(tcx),\n             goal.predicate.self_ty(),\n             |impl_def_id| G::consider_impl_candidate(self, goal, impl_def_id),\n         );"}, {"sha": "9ac629980eb725b8e2b9420f3324a627e75d5f23", "filename": "compiler/rustc_trait_selection/src/solve/cache.rs", "status": "removed", "additions": 0, "deletions": 267, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/b738b0616093dbe6ce14bd640d44cf4252981d56/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b738b0616093dbe6ce14bd640d44cf4252981d56/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs?ref=b738b0616093dbe6ce14bd640d44cf4252981d56", "patch": "@@ -1,267 +0,0 @@\n-//! This module both handles the global cache which stores \"finished\" goals,\n-//! and the provisional cache which contains partially computed goals.\n-//!\n-//! The provisional cache is necessary when dealing with coinductive cycles.\n-//!\n-//! For more information about the provisional cache and coinduction in general,\n-//! check out the relevant section of the rustc-dev-guide.\n-//!\n-//! FIXME(@lcnr): Write that section, feel free to ping me if you need help here\n-//! before then or if I still haven't done that before January 2023.\n-use super::overflow::OverflowData;\n-use super::{CanonicalGoal, Certainty, MaybeCause, Response};\n-use super::{EvalCtxt, QueryResult};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::canonical::{Canonical, CanonicalVarKind, CanonicalVarValues};\n-use rustc_middle::ty::{self, TyCtxt};\n-use std::collections::hash_map::Entry;\n-\n-rustc_index::newtype_index! {\n-    pub struct StackDepth {}\n-}\n-rustc_index::newtype_index! {\n-    pub struct EntryIndex {}\n-}\n-\n-#[derive(Debug, Clone)]\n-struct ProvisionalEntry<'tcx> {\n-    // In case we have a coinductive cycle, this is the\n-    // the currently least restrictive result of this goal.\n-    response: QueryResult<'tcx>,\n-    // In case of a cycle, the depth of lowest stack entry involved\n-    // in that cycle. This is monotonically decreasing in the stack as all\n-    // elements between the current stack element in the lowest stack entry\n-    // involved have to also be involved in that cycle.\n-    //\n-    // We can only move entries to the global cache once we're complete done\n-    // with the cycle. If this entry has not been involved in a cycle,\n-    // this is just its own depth.\n-    depth: StackDepth,\n-\n-    // The goal for this entry. Should always be equal to the corresponding goal\n-    // in the lookup table.\n-    goal: CanonicalGoal<'tcx>,\n-}\n-\n-struct StackElem<'tcx> {\n-    goal: CanonicalGoal<'tcx>,\n-    has_been_used: bool,\n-}\n-\n-pub(super) struct ProvisionalCache<'tcx> {\n-    stack: IndexVec<StackDepth, StackElem<'tcx>>,\n-    entries: IndexVec<EntryIndex, ProvisionalEntry<'tcx>>,\n-    // FIXME: This is only used to quickly check whether a given goal\n-    // is in the cache. We should experiment with using something like\n-    // `SsoHashSet` here because in most cases there are only a few entries.\n-    lookup_table: FxHashMap<CanonicalGoal<'tcx>, EntryIndex>,\n-}\n-\n-impl<'tcx> ProvisionalCache<'tcx> {\n-    pub(super) fn empty() -> ProvisionalCache<'tcx> {\n-        ProvisionalCache {\n-            stack: Default::default(),\n-            entries: Default::default(),\n-            lookup_table: Default::default(),\n-        }\n-    }\n-\n-    pub(super) fn current_depth(&self) -> usize {\n-        self.stack.len()\n-    }\n-}\n-\n-impl<'tcx> EvalCtxt<'tcx> {\n-    /// Tries putting the new goal on the stack, returning an error if it is already cached.\n-    ///\n-    /// This correctly updates the provisional cache if there is a cycle.\n-    pub(super) fn try_push_stack(\n-        &mut self,\n-        goal: CanonicalGoal<'tcx>,\n-    ) -> Result<(), QueryResult<'tcx>> {\n-        // FIXME: start by checking the global cache\n-\n-        // Look at the provisional cache to check for cycles.\n-        let cache = &mut self.provisional_cache;\n-        match cache.lookup_table.entry(goal) {\n-            // No entry, simply push this goal on the stack after dealing with overflow.\n-            Entry::Vacant(v) => {\n-                if self.overflow_data.has_overflow(cache.stack.len()) {\n-                    return Err(self.deal_with_overflow(goal));\n-                }\n-\n-                let depth = cache.stack.push(StackElem { goal, has_been_used: false });\n-                let response = response_no_constraints(self.tcx, goal, Certainty::Yes);\n-                let entry_index = cache.entries.push(ProvisionalEntry { response, depth, goal });\n-                v.insert(entry_index);\n-                Ok(())\n-            }\n-            // We have a nested goal which relies on a goal `root` deeper in the stack.\n-            //\n-            // We first store that we may have to rerun `evaluate_goal` for `root` in case the\n-            // provisional response is not equal to the final response. We also update the depth\n-            // of all goals which recursively depend on our current goal to depend on `root`\n-            // instead.\n-            //\n-            // Finally we can return either the provisional response for that goal if we have a\n-            // coinductive cycle or an ambiguous result if the cycle is inductive.\n-            Entry::Occupied(entry_index) => {\n-                let entry_index = *entry_index.get();\n-                // FIXME `ProvisionalEntry` should be `Copy`.\n-                let entry = cache.entries.get(entry_index).unwrap().clone();\n-                cache.stack[entry.depth].has_been_used = true;\n-                for provisional_entry in cache.entries.iter_mut().skip(entry_index.index()) {\n-                    provisional_entry.depth = provisional_entry.depth.min(entry.depth);\n-                }\n-\n-                // NOTE: The goals on the stack aren't the only goals involved in this cycle.\n-                // We can also depend on goals which aren't part of the stack but coinductively\n-                // depend on the stack themselves. We already checked whether all the goals\n-                // between these goals and their root on the stack. This means that as long as\n-                // each goal in a cycle is checked for coinductivity by itself, simply checking\n-                // the stack is enough.\n-                if cache.stack.raw[entry.depth.index()..]\n-                    .iter()\n-                    .all(|g| g.goal.value.predicate.is_coinductive(self.tcx))\n-                {\n-                    Err(entry.response)\n-                } else {\n-                    Err(response_no_constraints(\n-                        self.tcx,\n-                        goal,\n-                        Certainty::Maybe(MaybeCause::Overflow),\n-                    ))\n-                }\n-            }\n-        }\n-    }\n-\n-    /// We cannot simply store the result of [EvalCtxt::compute_goal] as we have to deal with\n-    /// coinductive cycles.\n-    ///\n-    /// When we encounter a coinductive cycle, we have to prove the final result of that cycle\n-    /// while we are still computing that result. Because of this we continously recompute the\n-    /// cycle until the result of the previous iteration is equal to the final result, at which\n-    /// point we are done.\n-    ///\n-    /// This function returns `true` if we were able to finalize the goal and `false` if it has\n-    /// updated the provisional cache and we have to recompute the current goal.\n-    ///\n-    /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n-    pub(super) fn try_finalize_goal(\n-        &mut self,\n-        actual_goal: CanonicalGoal<'tcx>,\n-        response: QueryResult<'tcx>,\n-    ) -> bool {\n-        let cache = &mut self.provisional_cache;\n-        let StackElem { goal, has_been_used } = cache.stack.pop().unwrap();\n-        assert_eq!(goal, actual_goal);\n-\n-        let provisional_entry_index = *cache.lookup_table.get(&goal).unwrap();\n-        let provisional_entry = &mut cache.entries[provisional_entry_index];\n-        // Was the current goal the root of a cycle and was the provisional response\n-        // different from the final one.\n-        if has_been_used && provisional_entry.response != response {\n-            // If so, update the provisional reponse for this goal...\n-            provisional_entry.response = response;\n-            // ...remove all entries whose result depends on this goal\n-            // from the provisional cache...\n-            //\n-            // That's not completely correct, as a nested goal can also\n-            // depend on a goal which is lower in the stack so it doesn't\n-            // actually depend on the current goal. This should be fairly\n-            // rare and is hopefully not relevant for performance.\n-            #[allow(rustc::potential_query_instability)]\n-            cache.lookup_table.retain(|_key, index| *index <= provisional_entry_index);\n-            cache.entries.truncate(provisional_entry_index.index() + 1);\n-\n-            // ...and finally push our goal back on the stack and reevaluate it.\n-            cache.stack.push(StackElem { goal, has_been_used: false });\n-            false\n-        } else {\n-            // If not, we're done with this goal.\n-            //\n-            // Check whether that this goal doesn't depend on a goal deeper on the stack\n-            // and if so, move it and all nested goals to the global cache.\n-            //\n-            // Note that if any nested goal were to depend on something deeper on the stack,\n-            // this would have also updated the depth of this goal.\n-            if provisional_entry.depth == cache.stack.next_index() {\n-                for (i, entry) in cache.entries.drain_enumerated(provisional_entry_index.index()..)\n-                {\n-                    let actual_index = cache.lookup_table.remove(&entry.goal);\n-                    debug_assert_eq!(Some(i), actual_index);\n-                    Self::try_move_finished_goal_to_global_cache(\n-                        self.tcx,\n-                        &mut self.overflow_data,\n-                        &cache.stack,\n-                        entry.goal,\n-                        entry.response,\n-                    );\n-                }\n-            }\n-            true\n-        }\n-    }\n-\n-    fn try_move_finished_goal_to_global_cache(\n-        tcx: TyCtxt<'tcx>,\n-        overflow_data: &mut OverflowData,\n-        stack: &IndexVec<StackDepth, StackElem<'tcx>>,\n-        goal: CanonicalGoal<'tcx>,\n-        response: QueryResult<'tcx>,\n-    ) {\n-        // We move goals to the global cache if we either did not hit an overflow or if it's\n-        // the root goal as that will now always hit the same overflow limit.\n-        //\n-        // NOTE: We cannot move any non-root goals to the global cache even if their final result\n-        // isn't impacted by the overflow as that goal still has unstable query dependencies\n-        // because it didn't go its full depth.\n-        //\n-        // FIXME(@lcnr): We could still cache subtrees which are not impacted by overflow though.\n-        // Tracking that info correctly isn't trivial, so I haven't implemented it for now.\n-        let should_cache_globally = !overflow_data.did_overflow() || stack.is_empty();\n-        if should_cache_globally {\n-            // FIXME: move the provisional entry to the global cache.\n-            let _ = (tcx, goal, response);\n-        }\n-    }\n-}\n-\n-pub(super) fn response_no_constraints<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    goal: Canonical<'tcx, impl Sized>,\n-    certainty: Certainty,\n-) -> QueryResult<'tcx> {\n-    let var_values = goal\n-        .variables\n-        .iter()\n-        .enumerate()\n-        .map(|(i, info)| match info.kind {\n-            CanonicalVarKind::Ty(_) | CanonicalVarKind::PlaceholderTy(_) => {\n-                tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i).into())).into()\n-            }\n-            CanonicalVarKind::Region(_) | CanonicalVarKind::PlaceholderRegion(_) => {\n-                let br = ty::BoundRegion {\n-                    var: ty::BoundVar::from_usize(i),\n-                    kind: ty::BrAnon(i as u32, None),\n-                };\n-                tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n-            }\n-            CanonicalVarKind::Const(_, ty) | CanonicalVarKind::PlaceholderConst(_, ty) => tcx\n-                .mk_const(ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i)), ty)\n-                .into(),\n-        })\n-        .collect();\n-\n-    Ok(Canonical {\n-        max_universe: goal.max_universe,\n-        variables: goal.variables,\n-        value: Response {\n-            var_values: CanonicalVarValues { var_values },\n-            external_constraints: Default::default(),\n-            certainty,\n-        },\n-    })\n-}"}, {"sha": "3146f468f7d81602fea3dd8b908ce43dea4fbcba", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=bf7dbff9210497ca3db0b19b5ca0c6daed47e64e", "patch": "@@ -2,7 +2,7 @@ use std::mem;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_infer::{\n-    infer::InferCtxt,\n+    infer::{canonical::OriginalQueryValues, InferCtxt},\n     traits::{\n         query::NoSolution, FulfillmentError, FulfillmentErrorCode, PredicateObligation,\n         SelectionError, TraitEngine,\n@@ -67,10 +67,26 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n \n             let mut has_changed = false;\n             for obligation in mem::take(&mut self.obligations) {\n-                let mut cx = EvalCtxt::new(infcx.tcx);\n-                let (changed, certainty) = match cx.evaluate_goal(infcx, obligation.clone().into())\n-                {\n-                    Ok(result) => result,\n+                let goal = obligation.clone().into();\n+\n+                // FIXME: Add a better API for that '^^\n+                let mut orig_values = OriginalQueryValues::default();\n+                let canonical_goal = infcx.canonicalize_query(goal, &mut orig_values);\n+                let (changed, certainty) = match EvalCtxt::evaluate_canonical_goal(\n+                    infcx.tcx,\n+                    &mut super::search_graph::SearchGraph::new(infcx.tcx),\n+                    canonical_goal,\n+                ) {\n+                    Ok(canonical_response) => {\n+                        (\n+                            true, // FIXME: check whether `var_values` are an identity substitution.\n+                            super::instantiate_canonical_query_response(\n+                                infcx,\n+                                &orig_values,\n+                                canonical_response,\n+                            ),\n+                        )\n+                    }\n                     Err(NoSolution) => {\n                         errors.push(FulfillmentError {\n                             obligation: obligation.clone(),"}, {"sha": "8a8c3091d549fd61aee174c6e3c5b3221dfc4c63", "filename": "compiler/rustc_trait_selection/src/solve/infcx_ext.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs?ref=bf7dbff9210497ca3db0b19b5ca0c6daed47e64e", "patch": "@@ -1,23 +1,11 @@\n-use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::InferCtxt;\n-use rustc_infer::traits::query::NoSolution;\n use rustc_middle::ty::Ty;\n use rustc_span::DUMMY_SP;\n \n-use crate::solve::ExternalConstraints;\n-\n-use super::{Certainty, QueryResult, Response};\n-\n /// Methods used inside of the canonical queries of the solver.\n pub(super) trait InferCtxtExt<'tcx> {\n     fn next_ty_infer(&self) -> Ty<'tcx>;\n-\n-    fn make_canonical_response(\n-        &self,\n-        var_values: CanonicalVarValues<'tcx>,\n-        certainty: Certainty,\n-    ) -> QueryResult<'tcx>;\n }\n \n impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n@@ -27,29 +15,4 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             span: DUMMY_SP,\n         })\n     }\n-\n-    fn make_canonical_response(\n-        &self,\n-        var_values: CanonicalVarValues<'tcx>,\n-        certainty: Certainty,\n-    ) -> QueryResult<'tcx> {\n-        let external_constraints = take_external_constraints(self)?;\n-\n-        Ok(self.canonicalize_response(Response { var_values, external_constraints, certainty }))\n-    }\n-}\n-\n-#[instrument(level = \"debug\", skip(infcx), ret)]\n-fn take_external_constraints<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n-    let region_obligations = infcx.take_registered_region_obligations();\n-    let opaque_types = infcx.take_opaque_types_for_query_response();\n-    Ok(ExternalConstraints {\n-        // FIXME: Now that's definitely wrong :)\n-        //\n-        // Should also do the leak check here I think\n-        regions: drop(region_obligations),\n-        opaque_types,\n-    })\n }"}, {"sha": "0e629664b2b1a9d13ca3037f2c29f6cad7852cf4", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 128, "deletions": 84, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=bf7dbff9210497ca3db0b19b5ca0c6daed47e64e", "patch": "@@ -19,27 +19,23 @@\n \n use std::mem;\n \n+use rustc_infer::infer::canonical::{Canonical, CanonicalVarKind, CanonicalVarValues};\n use rustc_infer::infer::canonical::{OriginalQueryValues, QueryRegionConstraints, QueryResponse};\n use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::Obligation;\n use rustc_middle::infer::canonical::Certainty as OldCertainty;\n-use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{RegionOutlivesPredicate, ToPredicate, TypeOutlivesPredicate};\n use rustc_span::DUMMY_SP;\n \n use crate::traits::ObligationCause;\n \n-use self::cache::response_no_constraints;\n-use self::infcx_ext::InferCtxtExt;\n-\n mod assembly;\n-mod cache;\n mod fulfill;\n mod infcx_ext;\n-mod overflow;\n mod project_goals;\n+mod search_graph;\n mod trait_goals;\n \n pub use fulfill::FulfillmentCtxt;\n@@ -146,45 +142,25 @@ pub trait TyCtxtExt<'tcx> {\n \n impl<'tcx> TyCtxtExt<'tcx> for TyCtxt<'tcx> {\n     fn evaluate_goal(self, goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx> {\n-        let mut cx = EvalCtxt::new(self);\n-        cx.evaluate_canonical_goal(goal)\n+        let mut search_graph = search_graph::SearchGraph::new(self);\n+        EvalCtxt::evaluate_canonical_goal(self, &mut search_graph, goal)\n     }\n }\n \n-struct EvalCtxt<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+struct EvalCtxt<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'tcx>,\n+    var_values: CanonicalVarValues<'tcx>,\n \n-    provisional_cache: cache::ProvisionalCache<'tcx>,\n-    overflow_data: overflow::OverflowData,\n+    search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n }\n \n-impl<'tcx> EvalCtxt<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> EvalCtxt<'tcx> {\n-        EvalCtxt {\n-            tcx,\n-            provisional_cache: cache::ProvisionalCache::empty(),\n-            overflow_data: overflow::OverflowData::new(tcx),\n-        }\n-    }\n-\n-    /// Recursively evaluates `goal`, returning whether any inference vars have\n-    /// been constrained and the certainty of the result.\n-    fn evaluate_goal(\n-        &mut self,\n-        infcx: &InferCtxt<'tcx>,\n-        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution> {\n-        let mut orig_values = OriginalQueryValues::default();\n-        let canonical_goal = infcx.canonicalize_query(goal, &mut orig_values);\n-        let canonical_response = self.evaluate_canonical_goal(canonical_goal)?;\n-        Ok((\n-            !canonical_response.value.var_values.is_identity(),\n-            instantiate_canonical_query_response(infcx, &orig_values, canonical_response),\n-        ))\n-    }\n-\n-    fn evaluate_canonical_goal(&mut self, goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx> {\n-        match self.try_push_stack(goal) {\n+impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n+    fn evaluate_canonical_goal(\n+        tcx: TyCtxt<'tcx>,\n+        search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n+        canonical_goal: CanonicalGoal<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        match search_graph.try_push_stack(tcx, canonical_goal) {\n             Ok(()) => {}\n             // Our goal is already on the stack, eager return.\n             Err(response) => return response,\n@@ -195,41 +171,65 @@ impl<'tcx> EvalCtxt<'tcx> {\n         //\n         // FIXME: Similar to `evaluate_all`, this has to check for overflow.\n         loop {\n-            let result = self.compute_goal(goal);\n+            let (ref infcx, goal, var_values) =\n+                tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n+            let mut ecx = EvalCtxt { infcx, var_values, search_graph };\n+            let result = ecx.compute_goal(goal);\n \n             // FIXME: `Response` should be `Copy`\n-            if self.try_finalize_goal(goal, result.clone()) {\n+            if search_graph.try_finalize_goal(tcx, canonical_goal, result.clone()) {\n                 return result;\n             }\n         }\n     }\n \n-    fn compute_goal(&mut self, canonical_goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx> {\n-        // WARNING: We're looking at a canonical value without instantiating it here.\n-        //\n-        // We have to be incredibly careful to not change the order of bound variables or\n-        // remove any. As we go from `Goal<'tcx, Predicate>` to `Goal` with the variants\n-        // of `PredicateKind` this is the case and it is and faster than instantiating and\n-        // recanonicalizing.\n-        let Goal { param_env, predicate } = canonical_goal.value;\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn make_canonical_response(&self, certainty: Certainty) -> QueryResult<'tcx> {\n+        let external_constraints = take_external_constraints(self.infcx)?;\n+\n+        Ok(self.infcx.canonicalize_response(Response {\n+            var_values: self.var_values.clone(),\n+            external_constraints,\n+            certainty,\n+        }))\n+    }\n+\n+    /// Recursively evaluates `goal`, returning whether any inference vars have\n+    /// been constrained and the certainty of the result.\n+    fn evaluate_goal(\n+        &mut self,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution> {\n+        let mut orig_values = OriginalQueryValues::default();\n+        let canonical_goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n+        let canonical_response =\n+            EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n+        Ok((\n+            !canonical_response.value.var_values.is_identity(),\n+            instantiate_canonical_query_response(self.infcx, &orig_values, canonical_response),\n+        ))\n+    }\n \n-        if let Some(kind) = predicate.kind().no_bound_vars_ignoring_escaping(self.tcx) {\n+    fn compute_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) -> QueryResult<'tcx> {\n+        let Goal { param_env, predicate } = goal;\n+        let kind = predicate.kind();\n+        if let Some(kind) = kind.no_bound_vars() {\n             match kind {\n-                ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => self.compute_trait_goal(\n-                    canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n-                ),\n-                ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => self\n-                    .compute_projection_goal(\n-                        canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n-                    ),\n-                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => self\n-                    .compute_type_outlives_goal(\n-                        canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n-                    ),\n-                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => self\n-                    .compute_region_outlives_goal(\n-                        canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n-                    ),\n+                ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => {\n+                    self.compute_trait_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => {\n+                    self.compute_projection_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => {\n+                    self.compute_type_outlives_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => {\n+                    self.compute_region_outlives_goal(Goal { param_env, predicate })\n+                }\n                 // FIXME: implement these predicates :)\n                 ty::PredicateKind::WellFormed(_)\n                 | ty::PredicateKind::ObjectSafe(_)\n@@ -239,49 +239,41 @@ impl<'tcx> EvalCtxt<'tcx> {\n                 | ty::PredicateKind::ConstEvaluatable(_)\n                 | ty::PredicateKind::ConstEquate(_, _)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(_)\n-                | ty::PredicateKind::Ambiguous => {\n-                    // FIXME\n-                    response_no_constraints(self.tcx, canonical_goal, Certainty::Yes)\n-                }\n+                | ty::PredicateKind::Ambiguous => self.make_canonical_response(Certainty::Yes),\n             }\n         } else {\n-            let (infcx, goal, var_values) =\n-                self.tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n-            let kind = infcx.replace_bound_vars_with_placeholders(goal.predicate.kind());\n-            let goal = goal.with(self.tcx, ty::Binder::dummy(kind));\n-            let (_, certainty) = self.evaluate_goal(&infcx, goal)?;\n-            infcx.make_canonical_response(var_values, certainty)\n+            let kind = self.infcx.replace_bound_vars_with_placeholders(kind);\n+            let goal = goal.with(self.tcx(), ty::Binder::dummy(kind));\n+            let (_, certainty) = self.evaluate_goal(goal)?;\n+            self.make_canonical_response(certainty)\n         }\n     }\n \n     fn compute_type_outlives_goal(\n         &mut self,\n-        goal: CanonicalGoal<'tcx, TypeOutlivesPredicate<'tcx>>,\n+        _goal: Goal<'tcx, TypeOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        // FIXME\n-        response_no_constraints(self.tcx, goal, Certainty::Yes)\n+        self.make_canonical_response(Certainty::Yes)\n     }\n \n     fn compute_region_outlives_goal(\n         &mut self,\n-        goal: CanonicalGoal<'tcx, RegionOutlivesPredicate<'tcx>>,\n+        _goal: Goal<'tcx, RegionOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        // FIXME\n-        response_no_constraints(self.tcx, goal, Certainty::Yes)\n+        self.make_canonical_response(Certainty::Yes)\n     }\n }\n \n-impl<'tcx> EvalCtxt<'tcx> {\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n     fn evaluate_all(\n         &mut self,\n-        infcx: &InferCtxt<'tcx>,\n         mut goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n     ) -> Result<Certainty, NoSolution> {\n         let mut new_goals = Vec::new();\n         self.repeat_while_none(|this| {\n             let mut has_changed = Err(Certainty::Yes);\n             for goal in goals.drain(..) {\n-                let (changed, certainty) = match this.evaluate_goal(infcx, goal) {\n+                let (changed, certainty) = match this.evaluate_goal(goal) {\n                     Ok(result) => result,\n                     Err(NoSolution) => return Some(Err(NoSolution)),\n                 };\n@@ -310,6 +302,21 @@ impl<'tcx> EvalCtxt<'tcx> {\n     }\n }\n \n+#[instrument(level = \"debug\", skip(infcx), ret)]\n+fn take_external_constraints<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n+    let region_obligations = infcx.take_registered_region_obligations();\n+    let opaque_types = infcx.take_opaque_types_for_query_response();\n+    Ok(ExternalConstraints {\n+        // FIXME: Now that's definitely wrong :)\n+        //\n+        // Should also do the leak check here I think\n+        regions: drop(region_obligations),\n+        opaque_types,\n+    })\n+}\n+\n fn instantiate_canonical_query_response<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     original_values: &OriginalQueryValues<'tcx>,\n@@ -334,3 +341,40 @@ fn instantiate_canonical_query_response<'tcx>(\n     assert!(obligations.is_empty());\n     value\n }\n+\n+pub(super) fn response_no_constraints<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    goal: Canonical<'tcx, impl Sized>,\n+    certainty: Certainty,\n+) -> QueryResult<'tcx> {\n+    let var_values = goal\n+        .variables\n+        .iter()\n+        .enumerate()\n+        .map(|(i, info)| match info.kind {\n+            CanonicalVarKind::Ty(_) | CanonicalVarKind::PlaceholderTy(_) => {\n+                tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i).into())).into()\n+            }\n+            CanonicalVarKind::Region(_) | CanonicalVarKind::PlaceholderRegion(_) => {\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_usize(i),\n+                    kind: ty::BrAnon(i as u32, None),\n+                };\n+                tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n+            }\n+            CanonicalVarKind::Const(_, ty) | CanonicalVarKind::PlaceholderConst(_, ty) => tcx\n+                .mk_const(ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i)), ty)\n+                .into(),\n+        })\n+        .collect();\n+\n+    Ok(Canonical {\n+        max_universe: goal.max_universe,\n+        variables: goal.variables,\n+        value: Response {\n+            var_values: CanonicalVarValues { var_values },\n+            external_constraints: Default::default(),\n+            certainty,\n+        },\n+    })\n+}"}, {"sha": "1120dfb8098628ca751ec77984c71929f1a2d94f", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=bf7dbff9210497ca3db0b19b5ca0c6daed47e64e", "patch": "@@ -1,7 +1,7 @@\n use crate::traits::{specialization_graph, translate_substs};\n \n use super::assembly::{self, AssemblyCtxt};\n-use super::{CanonicalGoal, EvalCtxt, Goal, QueryResult};\n+use super::{EvalCtxt, Goal, QueryResult};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n@@ -26,10 +26,10 @@ pub(super) enum CandidateSource {\n \n type Candidate<'tcx> = assembly::Candidate<'tcx, ProjectionPredicate<'tcx>>;\n \n-impl<'tcx> EvalCtxt<'tcx> {\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn compute_projection_goal(\n         &mut self,\n-        goal: CanonicalGoal<'tcx, ProjectionPredicate<'tcx>>,\n+        goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         let candidates = AssemblyCtxt::assemble_and_evaluate_candidates(self, goal);\n         self.merge_project_candidates(candidates)\n@@ -104,11 +104,13 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n     }\n \n     fn consider_impl_candidate(\n-        acx: &mut AssemblyCtxt<'_, 'tcx, ProjectionPredicate<'tcx>>,\n+        acx: &mut AssemblyCtxt<'_, '_, 'tcx, ProjectionPredicate<'tcx>>,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n         impl_def_id: DefId,\n     ) {\n-        let tcx = acx.cx.tcx;\n+        let tcx = acx.cx.tcx();\n+        let infcx = acx.cx.infcx;\n+\n         let goal_trait_ref = goal.predicate.projection_ty.trait_ref(tcx);\n         let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n@@ -118,12 +120,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             return;\n         }\n \n-        acx.infcx.probe(|_| {\n-            let impl_substs = acx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+        infcx.probe(|_| {\n+            let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let Ok(InferOk { obligations, .. }) = acx\n-                .infcx\n+            let Ok(InferOk { obligations, .. }) = infcx\n                 .at(&ObligationCause::dummy(), goal.param_env)\n                 .define_opaque_types(false)\n                 .eq(goal_trait_ref, impl_trait_ref)\n@@ -138,11 +139,12 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 .into_iter()\n                 .map(|pred| goal.with(tcx, pred));\n \n-            let nested_goals = obligations.into_iter().map(|o| o.into()).chain(where_clause_bounds).collect();\n-            let Ok(trait_ref_certainty) = acx.cx.evaluate_all(acx.infcx, nested_goals) else { return };\n+            let nested_goals =\n+                obligations.into_iter().map(|o| o.into()).chain(where_clause_bounds).collect();\n+            let Ok(trait_ref_certainty) = acx.cx.evaluate_all(nested_goals) else { return };\n \n             let Some(assoc_def) = fetch_eligible_assoc_item_def(\n-                acx.infcx,\n+                infcx,\n                 goal.param_env,\n                 goal_trait_ref,\n                 goal.predicate.def_id(),\n@@ -174,7 +176,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 impl_substs,\n             );\n             let substs = translate_substs(\n-                acx.infcx,\n+                infcx,\n                 goal.param_env,\n                 impl_def_id,\n                 impl_substs_with_gat,\n@@ -185,7 +187,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             let is_const = matches!(tcx.def_kind(assoc_def.item.def_id), DefKind::AssocConst);\n             let ty = tcx.bound_type_of(assoc_def.item.def_id);\n             let term: ty::EarlyBinder<ty::Term<'tcx>> = if is_const {\n-                let identity_substs = ty::InternalSubsts::identity_for_item(tcx, assoc_def.item.def_id);\n+                let identity_substs =\n+                    ty::InternalSubsts::identity_for_item(tcx, assoc_def.item.def_id);\n                 let did = ty::WithOptConstParam::unknown(assoc_def.item.def_id);\n                 let kind =\n                     ty::ConstKind::Unevaluated(ty::UnevaluatedConst::new(did, identity_substs));\n@@ -194,8 +197,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ty.map_bound(|ty| ty.into())\n             };\n \n-            let Ok(InferOk { obligations, .. }) = acx\n-                .infcx\n+            let Ok(InferOk { obligations, .. }) = infcx\n                 .at(&ObligationCause::dummy(), goal.param_env)\n                 .define_opaque_types(false)\n                 .eq(goal.predicate.term,  term.subst(tcx, substs))\n@@ -205,7 +207,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             };\n \n             let nested_goals = obligations.into_iter().map(|o| o.into()).collect();\n-            let Ok(rhs_certainty) = acx.cx.evaluate_all(acx.infcx, nested_goals) else { return };\n+            let Ok(rhs_certainty) = acx.cx.evaluate_all(nested_goals) else { return };\n \n             let certainty = trait_ref_certainty.unify_and(rhs_certainty);\n             acx.try_insert_candidate(CandidateSource::Impl(impl_def_id), certainty);"}, {"sha": "435e46f211a04bd7a1d06790c690d1da4f90ba82", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/cache.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs?ref=bf7dbff9210497ca3db0b19b5ca0c6daed47e64e", "patch": "@@ -0,0 +1,115 @@\n+//! This module both handles the global cache which stores \"finished\" goals,\n+//! and the provisional cache which contains partially computed goals.\n+//!\n+//! The provisional cache is necessary when dealing with coinductive cycles.\n+//!\n+//! For more information about the provisional cache and coinduction in general,\n+//! check out the relevant section of the rustc-dev-guide.\n+//!\n+//! FIXME(@lcnr): Write that section, feel free to ping me if you need help here\n+//! before then or if I still haven't done that before January 2023.\n+use super::overflow::OverflowData;\n+use super::StackDepth;\n+use crate::solve::{CanonicalGoal, QueryResult};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::TyCtxt;\n+\n+rustc_index::newtype_index! {\n+    pub struct EntryIndex {}\n+}\n+\n+#[derive(Debug, Clone)]\n+pub(super) struct ProvisionalEntry<'tcx> {\n+    // In case we have a coinductive cycle, this is the\n+    // the currently least restrictive result of this goal.\n+    pub(super) response: QueryResult<'tcx>,\n+    // In case of a cycle, the position of deepest stack entry involved\n+    // in that cycle. This is monotonically decreasing in the stack as all\n+    // elements between the current stack element in the deepest stack entry\n+    // involved have to also be involved in that cycle.\n+    //\n+    // We can only move entries to the global cache once we're complete done\n+    // with the cycle. If this entry has not been involved in a cycle,\n+    // this is just its own depth.\n+    pub(super) depth: StackDepth,\n+\n+    // The goal for this entry. Should always be equal to the corresponding goal\n+    // in the lookup table.\n+    pub(super) goal: CanonicalGoal<'tcx>,\n+}\n+\n+pub(super) struct ProvisionalCache<'tcx> {\n+    pub(super) entries: IndexVec<EntryIndex, ProvisionalEntry<'tcx>>,\n+    // FIXME: This is only used to quickly check whether a given goal\n+    // is in the cache. We should experiment with using something like\n+    // `SsoHashSet` here because in most cases there are only a few entries.\n+    pub(super) lookup_table: FxHashMap<CanonicalGoal<'tcx>, EntryIndex>,\n+}\n+\n+impl<'tcx> ProvisionalCache<'tcx> {\n+    pub(super) fn empty() -> ProvisionalCache<'tcx> {\n+        ProvisionalCache { entries: Default::default(), lookup_table: Default::default() }\n+    }\n+\n+    /// Adds a dependency from the current leaf to `target` in the cache\n+    /// to prevent us from moving any goals which depend on the current leaf\n+    /// to the global cache while we're still computing `target`.\n+    pub(super) fn add_dependency_of_leaf_on(&mut self, target: EntryIndex) {\n+        let depth = self.entries[target].depth;\n+        for provisional_entry in &mut self.entries.raw[target.index()..] {\n+            // The depth of `target` is the position of the deepest goal in the stack\n+            // on which `target` depends. That goal is the `root` of this cycle.\n+            //\n+            // Any entry which was added after `target` is either on the stack itself\n+            // at which point its depth is definitely at least as high as the depth of\n+            // `root`. If it's not on the stack itself it has to depend on a goal\n+            // between `root` and `leaf`. If it were to depend on a goal deeper in the\n+            // stack than `root`, then `root` would also depend on that goal, at which\n+            // point `root` wouldn't be the root anymore.\n+            debug_assert!(provisional_entry.depth >= depth);\n+            provisional_entry.depth = depth;\n+        }\n+\n+        // We only update entries which were added after `target` as no other\n+        // entry should have a higher depth.\n+        //\n+        // Any entry which previously had a higher depth than target has to\n+        // be between `target` and `root`. Because of this we would have updated\n+        // its depth when calling `add_dependency_of_leaf_on(root)` for `target`.\n+        if cfg!(debug_assertions) {\n+            self.entries.iter().all(|e| e.depth <= depth);\n+        }\n+    }\n+\n+    pub(super) fn depth(&self, entry_index: EntryIndex) -> StackDepth {\n+        self.entries[entry_index].depth\n+    }\n+\n+    pub(super) fn provisional_result(&self, entry_index: EntryIndex) -> QueryResult<'tcx> {\n+        self.entries[entry_index].response.clone()\n+    }\n+}\n+\n+pub(super) fn try_move_finished_goal_to_global_cache<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    overflow_data: &mut OverflowData,\n+    stack: &IndexVec<super::StackDepth, super::StackElem<'tcx>>,\n+    goal: CanonicalGoal<'tcx>,\n+    response: QueryResult<'tcx>,\n+) {\n+    // We move goals to the global cache if we either did not hit an overflow or if it's\n+    // the root goal as that will now always hit the same overflow limit.\n+    //\n+    // NOTE: We cannot move any non-root goals to the global cache even if their final result\n+    // isn't impacted by the overflow as that goal still has unstable query dependencies\n+    // because it didn't go its full depth.\n+    //\n+    // FIXME(@lcnr): We could still cache subtrees which are not impacted by overflow though.\n+    // Tracking that info correctly isn't trivial, so I haven't implemented it for now.\n+    let should_cache_globally = !overflow_data.did_overflow() || stack.is_empty();\n+    if should_cache_globally {\n+        // FIXME: move the provisional entry to the global cache.\n+        let _ = (tcx, goal, response);\n+    }\n+}"}, {"sha": "8d2a3a9cd818e05588454d76cf0d58950e335685", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=bf7dbff9210497ca3db0b19b5ca0c6daed47e64e", "patch": "@@ -0,0 +1,172 @@\n+mod cache;\n+mod overflow;\n+\n+use self::cache::ProvisionalEntry;\n+use super::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n+use cache::ProvisionalCache;\n+use overflow::OverflowData;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::TyCtxt;\n+use std::collections::hash_map::Entry;\n+\n+rustc_index::newtype_index! {\n+    pub struct StackDepth {}\n+}\n+\n+struct StackElem<'tcx> {\n+    goal: CanonicalGoal<'tcx>,\n+    has_been_used: bool,\n+}\n+\n+pub(super) struct SearchGraph<'tcx> {\n+    /// The stack of goals currently being computed.\n+    ///\n+    /// An element is *deeper* in the stack if its index is *lower*.\n+    stack: IndexVec<StackDepth, StackElem<'tcx>>,\n+    overflow_data: OverflowData,\n+    provisional_cache: ProvisionalCache<'tcx>,\n+}\n+\n+impl<'tcx> SearchGraph<'tcx> {\n+    pub(super) fn new(tcx: TyCtxt<'tcx>) -> SearchGraph<'tcx> {\n+        Self {\n+            stack: Default::default(),\n+            overflow_data: OverflowData::new(tcx),\n+            provisional_cache: ProvisionalCache::empty(),\n+        }\n+    }\n+\n+    /// Tries putting the new goal on the stack, returning an error if it is already cached.\n+    ///\n+    /// This correctly updates the provisional cache if there is a cycle.\n+    pub(super) fn try_push_stack(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        goal: CanonicalGoal<'tcx>,\n+    ) -> Result<(), QueryResult<'tcx>> {\n+        // FIXME: start by checking the global cache\n+\n+        // Look at the provisional cache to check for cycles.\n+        let cache = &mut self.provisional_cache;\n+        match cache.lookup_table.entry(goal) {\n+            // No entry, simply push this goal on the stack after dealing with overflow.\n+            Entry::Vacant(v) => {\n+                if self.overflow_data.has_overflow(self.stack.len()) {\n+                    return Err(self.deal_with_overflow(tcx, goal));\n+                }\n+\n+                let depth = self.stack.push(StackElem { goal, has_been_used: false });\n+                let response = super::response_no_constraints(tcx, goal, Certainty::Yes);\n+                let entry_index = cache.entries.push(ProvisionalEntry { response, depth, goal });\n+                v.insert(entry_index);\n+                Ok(())\n+            }\n+            // We have a nested goal which relies on a goal `root` deeper in the stack.\n+            //\n+            // We first store that we may have to rerun `evaluate_goal` for `root` in case the\n+            // provisional response is not equal to the final response. We also update the depth\n+            // of all goals which recursively depend on our current goal to depend on `root`\n+            // instead.\n+            //\n+            // Finally we can return either the provisional response for that goal if we have a\n+            // coinductive cycle or an ambiguous result if the cycle is inductive.\n+            Entry::Occupied(entry_index) => {\n+                let entry_index = *entry_index.get();\n+\n+                cache.add_dependency_of_leaf_on(entry_index);\n+                let stack_depth = cache.depth(entry_index);\n+\n+                self.stack[stack_depth].has_been_used = true;\n+                // NOTE: The goals on the stack aren't the only goals involved in this cycle.\n+                // We can also depend on goals which aren't part of the stack but coinductively\n+                // depend on the stack themselves. We already checked whether all the goals\n+                // between these goals and their root on the stack. This means that as long as\n+                // each goal in a cycle is checked for coinductivity by itself, simply checking\n+                // the stack is enough.\n+                if self.stack.raw[stack_depth.index()..]\n+                    .iter()\n+                    .all(|g| g.goal.value.predicate.is_coinductive(tcx))\n+                {\n+                    Err(cache.provisional_result(entry_index))\n+                } else {\n+                    Err(super::response_no_constraints(\n+                        tcx,\n+                        goal,\n+                        Certainty::Maybe(MaybeCause::Overflow),\n+                    ))\n+                }\n+            }\n+        }\n+    }\n+\n+    /// We cannot simply store the result of [EvalCtxt::compute_goal] as we have to deal with\n+    /// coinductive cycles.\n+    ///\n+    /// When we encounter a coinductive cycle, we have to prove the final result of that cycle\n+    /// while we are still computing that result. Because of this we continously recompute the\n+    /// cycle until the result of the previous iteration is equal to the final result, at which\n+    /// point we are done.\n+    ///\n+    /// This function returns `true` if we were able to finalize the goal and `false` if it has\n+    /// updated the provisional cache and we have to recompute the current goal.\n+    ///\n+    /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n+    pub(super) fn try_finalize_goal(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        actual_goal: CanonicalGoal<'tcx>,\n+        response: QueryResult<'tcx>,\n+    ) -> bool {\n+        let StackElem { goal, has_been_used } = self.stack.pop().unwrap();\n+        assert_eq!(goal, actual_goal);\n+\n+        let cache = &mut self.provisional_cache;\n+        let provisional_entry_index = *cache.lookup_table.get(&goal).unwrap();\n+        let provisional_entry = &mut cache.entries[provisional_entry_index];\n+        let depth = provisional_entry.depth;\n+        // Was the current goal the root of a cycle and was the provisional response\n+        // different from the final one.\n+        if has_been_used && provisional_entry.response != response {\n+            // If so, update the provisional reponse for this goal...\n+            provisional_entry.response = response;\n+            // ...remove all entries whose result depends on this goal\n+            // from the provisional cache...\n+            //\n+            // That's not completely correct, as a nested goal can also\n+            // depend on a goal which is lower in the stack so it doesn't\n+            // actually depend on the current goal. This should be fairly\n+            // rare and is hopefully not relevant for performance.\n+            #[allow(rustc::potential_query_instability)]\n+            cache.lookup_table.retain(|_key, index| *index <= provisional_entry_index);\n+            cache.entries.truncate(provisional_entry_index.index() + 1);\n+\n+            // ...and finally push our goal back on the stack and reevaluate it.\n+            self.stack.push(StackElem { goal, has_been_used: false });\n+            false\n+        } else {\n+            // If not, we're done with this goal.\n+            //\n+            // Check whether that this goal doesn't depend on a goal deeper on the stack\n+            // and if so, move it and all nested goals to the global cache.\n+            //\n+            // Note that if any nested goal were to depend on something deeper on the stack,\n+            // this would have also updated the depth of the current goal.\n+            if depth == self.stack.next_index() {\n+                for (i, entry) in cache.entries.drain_enumerated(provisional_entry_index.index()..)\n+                {\n+                    let actual_index = cache.lookup_table.remove(&entry.goal);\n+                    debug_assert_eq!(Some(i), actual_index);\n+                    debug_assert!(entry.depth == depth);\n+                    cache::try_move_finished_goal_to_global_cache(\n+                        tcx,\n+                        &mut self.overflow_data,\n+                        &self.stack,\n+                        entry.goal,\n+                        entry.response,\n+                    );\n+                }\n+            }\n+            true\n+        }\n+    }\n+}"}, {"sha": "1dd3894c91adc009c9c9e8fbaa1103fed4beeca2", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/overflow.rs", "status": "renamed", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs?ref=bf7dbff9210497ca3db0b19b5ca0c6daed47e64e", "patch": "@@ -3,8 +3,8 @@ use rustc_infer::traits::query::NoSolution;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Limit;\n \n-use super::cache::response_no_constraints;\n-use super::{Certainty, EvalCtxt, MaybeCause, QueryResult};\n+use super::SearchGraph;\n+use crate::solve::{response_no_constraints, Certainty, EvalCtxt, MaybeCause, QueryResult};\n \n /// When detecting a solver overflow, we return ambiguity. Overflow can be\n /// *hidden* by either a fatal error in an **AND** or a trivial success in an **OR**.\n@@ -50,32 +50,35 @@ impl OverflowData {\n     }\n }\n \n-impl<'tcx> EvalCtxt<'tcx> {\n-    pub(super) fn deal_with_overflow(\n+impl<'tcx> SearchGraph<'tcx> {\n+    pub fn deal_with_overflow(\n         &mut self,\n+        tcx: TyCtxt<'tcx>,\n         goal: Canonical<'tcx, impl Sized>,\n     ) -> QueryResult<'tcx> {\n         self.overflow_data.deal_with_overflow();\n-        response_no_constraints(self.tcx, goal, Certainty::Maybe(MaybeCause::Overflow))\n+        response_no_constraints(tcx, goal, Certainty::Maybe(MaybeCause::Overflow))\n     }\n+}\n \n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n     /// A `while`-loop which tracks overflow.\n-    pub(super) fn repeat_while_none(\n+    pub fn repeat_while_none(\n         &mut self,\n         mut loop_body: impl FnMut(&mut Self) -> Option<Result<Certainty, NoSolution>>,\n     ) -> Result<Certainty, NoSolution> {\n-        let start_depth = self.overflow_data.additional_depth;\n-        let depth = self.provisional_cache.current_depth();\n-        while !self.overflow_data.has_overflow(depth) {\n+        let start_depth = self.search_graph.overflow_data.additional_depth;\n+        let depth = self.search_graph.stack.len();\n+        while !self.search_graph.overflow_data.has_overflow(depth) {\n             if let Some(result) = loop_body(self) {\n-                self.overflow_data.additional_depth = start_depth;\n+                self.search_graph.overflow_data.additional_depth = start_depth;\n                 return result;\n             }\n \n-            self.overflow_data.additional_depth += 1;\n+            self.search_graph.overflow_data.additional_depth += 1;\n         }\n-        self.overflow_data.additional_depth = start_depth;\n-        self.overflow_data.deal_with_overflow();\n+        self.search_graph.overflow_data.additional_depth = start_depth;\n+        self.search_graph.overflow_data.deal_with_overflow();\n         Ok(Certainty::Maybe(MaybeCause::Overflow))\n     }\n }", "previous_filename": "compiler/rustc_trait_selection/src/solve/overflow.rs"}, {"sha": "cc68cfeea1d07fd40868759ce9cbef85ee4989d9", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=bf7dbff9210497ca3db0b19b5ca0c6daed47e64e", "patch": "@@ -3,7 +3,7 @@\n use std::iter;\n \n use super::assembly::{self, AssemblyCtxt};\n-use super::{CanonicalGoal, EvalCtxt, Goal, QueryResult};\n+use super::{EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::InferOk;\n use rustc_infer::traits::query::NoSolution;\n@@ -67,11 +67,12 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     }\n \n     fn consider_impl_candidate(\n-        acx: &mut AssemblyCtxt<'_, 'tcx, Self>,\n+        acx: &mut AssemblyCtxt<'_, '_, 'tcx, Self>,\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n         impl_def_id: DefId,\n     ) {\n-        let tcx = acx.cx.tcx;\n+        let tcx = acx.cx.tcx();\n+        let infcx = acx.cx.infcx;\n \n         let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n@@ -81,12 +82,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             return;\n         }\n \n-        acx.infcx.probe(|_| {\n-            let impl_substs = acx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+        infcx.probe(|_| {\n+            let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let Ok(InferOk { obligations, .. }) = acx\n-                .infcx\n+            let Ok(InferOk { obligations, .. }) = infcx\n                 .at(&ObligationCause::dummy(), goal.param_env)\n                 .define_opaque_types(false)\n                 .eq(goal.predicate.trait_ref, impl_trait_ref)\n@@ -104,16 +104,16 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             let nested_goals =\n                 obligations.into_iter().map(|o| o.into()).chain(where_clause_bounds).collect();\n \n-            let Ok(certainty) = acx.cx.evaluate_all(acx.infcx, nested_goals) else { return };\n+            let Ok(certainty) = acx.cx.evaluate_all(nested_goals) else { return };\n             acx.try_insert_candidate(CandidateSource::Impl(impl_def_id), certainty);\n         })\n     }\n }\n \n-impl<'tcx> EvalCtxt<'tcx> {\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn compute_trait_goal(\n         &mut self,\n-        goal: CanonicalGoal<'tcx, TraitPredicate<'tcx>>,\n+        goal: Goal<'tcx, TraitPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         let candidates = AssemblyCtxt::assemble_and_evaluate_candidates(self, goal);\n         self.merge_trait_candidates_discard_reservation_impls(candidates)\n@@ -176,7 +176,7 @@ impl<'tcx> EvalCtxt<'tcx> {\n \n     fn discard_reservation_impl(&self, candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n         if let CandidateSource::Impl(def_id) = candidate.source {\n-            if let ty::ImplPolarity::Reservation = self.tcx.impl_polarity(def_id) {\n+            if let ty::ImplPolarity::Reservation = self.tcx().impl_polarity(def_id) {\n                 debug!(\"Selected reservation impl\");\n                 // FIXME: reduce candidate to ambiguous\n                 // FIXME: replace `var_values` with identity, yeet external constraints."}]}