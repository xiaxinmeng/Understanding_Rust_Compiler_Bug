{"sha": "faf45c5dadc04e2ee2f2b772402321e621899641", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZjQ1YzVkYWRjMDRlMmVlMmYyYjc3MjQwMjMyMWU2MjE4OTk2NDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-15T16:28:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-15T16:28:06Z"}, "message": "Auto merge of #67603 - oli-obk:no_mut_static_ref_from_const, r=RalfJung\n\nPromoteds can contain raw pointers, but these must still only point to immutable allocations\n\nfixes #67601\n\nr? @RalfJung\n\ncc @wesleywiser in order to not change behaviour in this PR, const prop uses the constant rules for interning, but at least there's an explicit mode for it now that we can think about this in the future", "tree": {"sha": "4caa014e52b4dc5531790aab1c823274e1336939", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4caa014e52b4dc5531790aab1c823274e1336939"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/faf45c5dadc04e2ee2f2b772402321e621899641", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/faf45c5dadc04e2ee2f2b772402321e621899641", "html_url": "https://github.com/rust-lang/rust/commit/faf45c5dadc04e2ee2f2b772402321e621899641", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/faf45c5dadc04e2ee2f2b772402321e621899641/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d0bb91bcba33a70fae4b0c663fb4403ed78f071", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d0bb91bcba33a70fae4b0c663fb4403ed78f071", "html_url": "https://github.com/rust-lang/rust/commit/6d0bb91bcba33a70fae4b0c663fb4403ed78f071"}, {"sha": "69ffe7bb1314ccfdbde419d242cf636413dfd5f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/69ffe7bb1314ccfdbde419d242cf636413dfd5f6", "html_url": "https://github.com/rust-lang/rust/commit/69ffe7bb1314ccfdbde419d242cf636413dfd5f6"}], "stats": {"total": 76, "additions": 55, "deletions": 21}, "files": [{"sha": "aad0e1629359a8523895b2e7f2e9a67c9df8d674", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/faf45c5dadc04e2ee2f2b772402321e621899641/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faf45c5dadc04e2ee2f2b772402321e621899641/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=faf45c5dadc04e2ee2f2b772402321e621899641", "patch": "@@ -5,7 +5,7 @@ use rustc::ty::layout::VariantIdx;\n use rustc::ty::{self, TyCtxt};\n use rustc_span::{source_map::DUMMY_SP, symbol::Symbol};\n \n-use crate::interpret::{intern_const_alloc_recursive, ConstValue, InterpCx};\n+use crate::interpret::{intern_const_alloc_recursive, ConstValue, InternKind, InterpCx};\n \n mod error;\n mod eval_queries;\n@@ -52,7 +52,7 @@ pub(crate) fn const_caller_location<'tcx>(\n \n     let loc_ty = tcx.caller_location_ty();\n     let loc_place = ecx.alloc_caller_location(file, line, col);\n-    intern_const_alloc_recursive(&mut ecx, None, loc_place, false).unwrap();\n+    intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place, false).unwrap();\n     let loc_const = ty::Const {\n         ty: loc_ty,\n         val: ty::ConstKind::Value(ConstValue::Scalar(loc_place.ptr.into())),"}, {"sha": "442baf85f2bafea116b28a1f05b6207722f21b04", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/faf45c5dadc04e2ee2f2b772402321e621899641/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faf45c5dadc04e2ee2f2b772402321e621899641/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=faf45c5dadc04e2ee2f2b772402321e621899641", "patch": "@@ -1,9 +1,9 @@\n use super::{error_to_const_error, CompileTimeEvalContext, CompileTimeInterpreter, MemoryExtra};\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n-    intern_const_alloc_recursive, Allocation, ConstValue, GlobalId, ImmTy, Immediate, InterpCx,\n-    InterpResult, MPlaceTy, MemoryKind, OpTy, RawConst, RefTracking, Scalar, ScalarMaybeUndef,\n-    StackPopCleanup,\n+    intern_const_alloc_recursive, Allocation, ConstValue, GlobalId, ImmTy, Immediate, InternKind,\n+    InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RawConst, RefTracking, Scalar,\n+    ScalarMaybeUndef, StackPopCleanup,\n };\n use rustc::mir;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n@@ -56,9 +56,14 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx.run()?;\n \n     // Intern the result\n+    let intern_kind = match tcx.static_mutability(cid.instance.def_id()) {\n+        Some(m) => InternKind::Static(m),\n+        None if cid.promoted.is_some() => InternKind::Promoted,\n+        _ => InternKind::Constant,\n+    };\n     intern_const_alloc_recursive(\n         ecx,\n-        tcx.static_mutability(cid.instance.def_id()),\n+        intern_kind,\n         ret,\n         body.ignore_interior_mut_in_const_validation,\n     )?;"}, {"sha": "0c65b77a38240af17f80298d32103b3ba226d327", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/faf45c5dadc04e2ee2f2b772402321e621899641/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faf45c5dadc04e2ee2f2b772402321e621899641/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=faf45c5dadc04e2ee2f2b772402321e621899641", "patch": "@@ -268,19 +268,27 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx\n     }\n }\n \n+pub enum InternKind {\n+    /// The `mutability` of the static, ignoring the type which may have interior mutability.\n+    Static(hir::Mutability),\n+    Constant,\n+    Promoted,\n+    ConstProp,\n+}\n+\n pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     ecx: &mut InterpCx<'mir, 'tcx, M>,\n-    // The `mutability` of the place, ignoring the type.\n-    place_mut: Option<hir::Mutability>,\n+    intern_kind: InternKind,\n     ret: MPlaceTy<'tcx>,\n     ignore_interior_mut_in_const_validation: bool,\n ) -> InterpResult<'tcx> {\n     let tcx = ecx.tcx;\n-    let (base_mutability, base_intern_mode) = match place_mut {\n+    let (base_mutability, base_intern_mode) = match intern_kind {\n         // `static mut` doesn't care about interior mutability, it's mutable anyway\n-        Some(mutbl) => (mutbl, InternMode::Static),\n-        // consts, promoteds. FIXME: what about array lengths, array initializers?\n-        None => (Mutability::Not, InternMode::ConstBase),\n+        InternKind::Static(mutbl) => (mutbl, InternMode::Static),\n+        // FIXME: what about array lengths, array initializers?\n+        InternKind::Constant | InternKind::ConstProp => (Mutability::Not, InternMode::ConstBase),\n+        InternKind::Promoted => (Mutability::Not, InternMode::ConstBase),\n     };\n \n     // Type based interning.\n@@ -338,10 +346,24 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             // We can't call the `intern_shallow` method here, as its logic is tailored to safe\n             // references and a `leftover_allocations` set (where we only have a todo-list here).\n             // So we hand-roll the interning logic here again.\n-            match base_intern_mode {\n-                InternMode::Static => {}\n-                InternMode::Const | InternMode::ConstBase => {\n-                    // If it's not a static, it *must* be immutable.\n+            match intern_kind {\n+                // Statics may contain mutable allocations even behind relocations.\n+                // Even for immutable statics it would be ok to have mutable allocations behind\n+                // raw pointers, e.g. for `static FOO: *const AtomicUsize = &AtomicUsize::new(42)`.\n+                InternKind::Static(_) => {}\n+                // Raw pointers in promoteds may only point to immutable things so we mark\n+                // everything as immutable.\n+                // It is UB to mutate through a raw pointer obtained via an immutable reference.\n+                // Since all references and pointers inside a promoted must by their very definition\n+                // be created from an immutable reference (and promotion also excludes interior\n+                // mutability), mutating through them would be UB.\n+                // There's no way we can check whether the user is using raw pointers correctly,\n+                // so all we can do is mark this as immutable here.\n+                InternKind::Promoted => {\n+                    alloc.mutability = Mutability::Not;\n+                }\n+                InternKind::Constant | InternKind::ConstProp => {\n+                    // If it's a constant, it *must* be immutable.\n                     // We cannot have mutable memory inside a constant.\n                     // We use `delay_span_bug` here, because this can be reached in the presence\n                     // of fancy transmutes.\n@@ -364,6 +386,8 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             // dangling pointer\n             throw_unsup!(ValidationFailure(\"encountered dangling pointer in final constant\".into()))\n         } else if ecx.tcx.alloc_map.lock().get(alloc_id).is_none() {\n+            // We have hit an `AllocId` that is neither in local or global memory and isn't marked\n+            // as dangling by local memory.\n             span_bug!(ecx.tcx.span, \"encountered unknown alloc id {:?}\", alloc_id);\n         }\n     }"}, {"sha": "a519f38e712087dc9215a0aa79a71a77c9dc09f6", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/faf45c5dadc04e2ee2f2b772402321e621899641/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faf45c5dadc04e2ee2f2b772402321e621899641/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=faf45c5dadc04e2ee2f2b772402321e621899641", "patch": "@@ -32,6 +32,6 @@ pub use self::visitor::{MutValueVisitor, ValueVisitor};\n \n pub use self::validity::RefTracking;\n \n-pub use self::intern::intern_const_alloc_recursive;\n+pub use self::intern::{intern_const_alloc_recursive, InternKind};\n \n crate use self::intrinsics::eval_nullary_intrinsic;"}, {"sha": "9d5dbe3564ee0c4ee1e9a5495e1f0eafb30a155f", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/faf45c5dadc04e2ee2f2b772402321e621899641/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faf45c5dadc04e2ee2f2b772402321e621899641/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=faf45c5dadc04e2ee2f2b772402321e621899641", "patch": "@@ -30,9 +30,9 @@ use syntax::ast::Mutability;\n \n use crate::const_eval::error_to_const_error;\n use crate::interpret::{\n-    self, intern_const_alloc_recursive, AllocId, Allocation, Frame, ImmTy, Immediate, InterpCx,\n-    LocalState, LocalValue, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer,\n-    ScalarMaybeUndef, StackPopCleanup,\n+    self, intern_const_alloc_recursive, AllocId, Allocation, Frame, ImmTy, Immediate, InternKind,\n+    InterpCx, LocalState, LocalValue, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy,\n+    Pointer, ScalarMaybeUndef, StackPopCleanup,\n };\n use crate::transform::{MirPass, MirSource};\n \n@@ -767,7 +767,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             )) => l.is_bits() && r.is_bits(),\n             interpret::Operand::Indirect(_) if mir_opt_level >= 2 => {\n                 let mplace = op.assert_mem_place(&self.ecx);\n-                intern_const_alloc_recursive(&mut self.ecx, None, mplace, false)\n+                intern_const_alloc_recursive(&mut self.ecx, InternKind::ConstProp, mplace, false)\n                     .expect(\"failed to intern alloc\");\n                 true\n             }"}, {"sha": "4c62ad444a5129e779b675b9f0aabc9e2e50baf4", "filename": "src/test/ui/consts/raw_pointer_promoted.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/faf45c5dadc04e2ee2f2b772402321e621899641/src%2Ftest%2Fui%2Fconsts%2Fraw_pointer_promoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faf45c5dadc04e2ee2f2b772402321e621899641/src%2Ftest%2Fui%2Fconsts%2Fraw_pointer_promoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fraw_pointer_promoted.rs?ref=faf45c5dadc04e2ee2f2b772402321e621899641", "patch": "@@ -0,0 +1,5 @@\n+// check-pass\n+\n+pub const FOO: &'static *const i32 = &(&0 as _);\n+\n+fn main() {}"}]}