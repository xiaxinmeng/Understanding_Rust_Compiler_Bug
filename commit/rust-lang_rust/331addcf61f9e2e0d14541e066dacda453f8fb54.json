{"sha": "331addcf61f9e2e0d14541e066dacda453f8fb54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzMWFkZGNmNjFmOWUyZTBkMTQ1NDFlMDY2ZGFjZGE0NTNmOGZiNTQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T11:47:22Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T11:47:22Z"}, "message": "Canonicalize actor API", "tree": {"sha": "44d476d918436ca6ecd92b67ae9141d2208b0d51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44d476d918436ca6ecd92b67ae9141d2208b0d51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/331addcf61f9e2e0d14541e066dacda453f8fb54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/331addcf61f9e2e0d14541e066dacda453f8fb54", "html_url": "https://github.com/rust-lang/rust/commit/331addcf61f9e2e0d14541e066dacda453f8fb54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/331addcf61f9e2e0d14541e066dacda453f8fb54/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "193ea7cf9af8c501035445b42847b6e80b33751a", "url": "https://api.github.com/repos/rust-lang/rust/commits/193ea7cf9af8c501035445b42847b6e80b33751a", "html_url": "https://github.com/rust-lang/rust/commit/193ea7cf9af8c501035445b42847b6e80b33751a"}], "stats": {"total": 128, "additions": 57, "deletions": 71}, "files": [{"sha": "9e8205ae790df5d625a9ebfcde9cf555ec77bbdd", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 55, "deletions": 69, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/331addcf61f9e2e0d14541e066dacda453f8fb54/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/331addcf61f9e2e0d14541e066dacda453f8fb54/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=331addcf61f9e2e0d14541e066dacda453f8fb54", "patch": "@@ -10,7 +10,7 @@ use std::{\n     time::Instant,\n };\n \n-use crossbeam_channel::{never, select, unbounded, Receiver, RecvError, Sender};\n+use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n \n pub use cargo_metadata::diagnostic::{\n     Applicability, Diagnostic, DiagnosticLevel, DiagnosticSpan, DiagnosticSpanMacroExpansion,\n@@ -61,7 +61,7 @@ impl FlycheckHandle {\n     ) -> FlycheckHandle {\n         let (cmd_send, cmd_recv) = unbounded::<Restart>();\n         let handle = jod_thread::spawn(move || {\n-            FlycheckActor::new(sender, config, workspace_root).run(&cmd_recv);\n+            FlycheckActor::new(sender, config, workspace_root).run(cmd_recv);\n         });\n         FlycheckHandle { cmd_send, handle }\n     }\n@@ -98,14 +98,18 @@ struct FlycheckActor {\n     config: FlycheckConfig,\n     workspace_root: PathBuf,\n     last_update_req: Option<Instant>,\n-    // XXX: drop order is significant\n-    message_recv: Receiver<CheckEvent>,\n     /// WatchThread exists to wrap around the communication needed to be able to\n     /// run `cargo check` without blocking. Currently the Rust standard library\n     /// doesn't provide a way to read sub-process output without blocking, so we\n     /// have to wrap sub-processes output handling in a thread and pass messages\n     /// back over a channel.\n-    check_process: Option<jod_thread::JoinHandle>,\n+    // XXX: drop order is significant\n+    check_process: Option<(Receiver<CheckEvent>, jod_thread::JoinHandle)>,\n+}\n+\n+enum Event {\n+    Restart(Restart),\n+    CheckEvent(Option<CheckEvent>),\n }\n \n impl FlycheckActor {\n@@ -114,40 +118,48 @@ impl FlycheckActor {\n         config: FlycheckConfig,\n         workspace_root: PathBuf,\n     ) -> FlycheckActor {\n-        FlycheckActor {\n-            sender,\n-            config,\n-            workspace_root,\n-            last_update_req: None,\n-            message_recv: never(),\n-            check_process: None,\n-        }\n+        FlycheckActor { sender, config, workspace_root, last_update_req: None, check_process: None }\n     }\n \n-    fn run(&mut self, cmd_recv: &Receiver<Restart>) {\n+    fn run(&mut self, inbox: Receiver<Restart>) {\n         // If we rerun the thread, we need to discard the previous check results first\n-        self.clean_previous_results();\n-\n-        loop {\n-            select! {\n-                recv(&cmd_recv) -> cmd => match cmd {\n-                    Ok(Restart) => self.last_update_req = Some(Instant::now()),\n-                    Err(RecvError) => {\n-                        // Command channel has closed, so shut down\n-                        break;\n-                    },\n-                },\n-                recv(self.message_recv) -> msg => match msg {\n-                    Ok(msg) => self.handle_message(msg),\n-                    Err(RecvError) => {\n-                        // Watcher finished, replace it with a never channel to\n-                        // avoid busy-waiting.\n-                        self.message_recv = never();\n-                        self.check_process = None;\n-                    },\n+        self.send(Message::ClearDiagnostics);\n+        self.send(Message::Progress(Progress::End));\n+\n+        while let Some(event) = self.next_event(&inbox) {\n+            match event {\n+                Event::Restart(Restart) => self.last_update_req = Some(Instant::now()),\n+                Event::CheckEvent(None) => {\n+                    // Watcher finished, replace it with a never channel to\n+                    // avoid busy-waiting.\n+                    self.check_process = None;\n                 }\n-            };\n+                Event::CheckEvent(Some(event)) => match event {\n+                    CheckEvent::Begin => {\n+                        self.send(Message::Progress(Progress::Being));\n+                    }\n+\n+                    CheckEvent::End => {\n+                        self.send(Message::Progress(Progress::End));\n+                    }\n+\n+                    CheckEvent::Msg(cargo_metadata::Message::CompilerArtifact(msg)) => {\n+                        self.send(Message::Progress(Progress::DidCheckCrate(msg.target.name)));\n+                    }\n+\n+                    CheckEvent::Msg(cargo_metadata::Message::CompilerMessage(msg)) => {\n+                        self.send(Message::AddDiagnostic {\n+                            workspace_root: self.workspace_root.clone(),\n+                            diagnostic: msg.message,\n+                        });\n+                    }\n \n+                    CheckEvent::Msg(cargo_metadata::Message::BuildScriptExecuted(_))\n+                    | CheckEvent::Msg(cargo_metadata::Message::BuildFinished(_))\n+                    | CheckEvent::Msg(cargo_metadata::Message::TextLine(_))\n+                    | CheckEvent::Msg(cargo_metadata::Message::Unknown) => {}\n+                },\n+            }\n             if self.should_recheck() {\n                 self.last_update_req = None;\n                 self.send(Message::ClearDiagnostics);\n@@ -156,9 +168,12 @@ impl FlycheckActor {\n         }\n     }\n \n-    fn clean_previous_results(&self) {\n-        self.send(Message::ClearDiagnostics);\n-        self.send(Message::Progress(Progress::End));\n+    fn next_event(&self, inbox: &Receiver<Restart>) -> Option<Event> {\n+        let check_chan = self.check_process.as_ref().map(|(chan, _thread)| chan);\n+        select! {\n+            recv(inbox) -> msg => msg.ok().map(Event::Restart),\n+            recv(check_chan.unwrap_or(&never())) -> msg => Some(Event::CheckEvent(msg.ok())),\n+        }\n     }\n \n     fn should_recheck(&mut self) -> bool {\n@@ -171,37 +186,8 @@ impl FlycheckActor {\n         false\n     }\n \n-    fn handle_message(&self, msg: CheckEvent) {\n-        match msg {\n-            CheckEvent::Begin => {\n-                self.send(Message::Progress(Progress::Being));\n-            }\n-\n-            CheckEvent::End => {\n-                self.send(Message::Progress(Progress::End));\n-            }\n-\n-            CheckEvent::Msg(cargo_metadata::Message::CompilerArtifact(msg)) => {\n-                self.send(Message::Progress(Progress::DidCheckCrate(msg.target.name)));\n-            }\n-\n-            CheckEvent::Msg(cargo_metadata::Message::CompilerMessage(msg)) => {\n-                self.send(Message::AddDiagnostic {\n-                    workspace_root: self.workspace_root.clone(),\n-                    diagnostic: msg.message,\n-                });\n-            }\n-\n-            CheckEvent::Msg(cargo_metadata::Message::BuildScriptExecuted(_))\n-            | CheckEvent::Msg(cargo_metadata::Message::BuildFinished(_))\n-            | CheckEvent::Msg(cargo_metadata::Message::TextLine(_))\n-            | CheckEvent::Msg(cargo_metadata::Message::Unknown) => {}\n-        }\n-    }\n-\n     fn restart_check_process(&mut self) {\n         // First, clear and cancel the old thread\n-        self.message_recv = never();\n         self.check_process = None;\n \n         let mut cmd = match &self.config {\n@@ -237,8 +223,7 @@ impl FlycheckActor {\n         cmd.current_dir(&self.workspace_root);\n \n         let (message_send, message_recv) = unbounded();\n-        self.message_recv = message_recv;\n-        self.check_process = Some(jod_thread::spawn(move || {\n+        let thread = jod_thread::spawn(move || {\n             // If we trigger an error here, we will do so in the loop instead,\n             // which will break out of the loop, and continue the shutdown\n             let _ = message_send.send(CheckEvent::Begin);\n@@ -267,7 +252,8 @@ impl FlycheckActor {\n             // We can ignore any error here, as we are already in the progress\n             // of shutting down.\n             let _ = message_send.send(CheckEvent::End);\n-        }))\n+        });\n+        self.check_process = Some((message_recv, thread))\n     }\n \n     fn send(&self, check_task: Message) {"}, {"sha": "68fdb8cb09cbbd50a1b43fa8ff69d53570dadef5", "filename": "crates/vfs-notify/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/331addcf61f9e2e0d14541e066dacda453f8fb54/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/331addcf61f9e2e0d14541e066dacda453f8fb54/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2Fsrc%2Flib.rs?ref=331addcf61f9e2e0d14541e066dacda453f8fb54", "patch": "@@ -83,8 +83,8 @@ impl NotifyActor {\n         }\n     }\n \n-    fn run(mut self, receiver: Receiver<Message>) {\n-        while let Some(event) = self.next_event(&receiver) {\n+    fn run(mut self, inbox: Receiver<Message>) {\n+        while let Some(event) = self.next_event(&inbox) {\n             log::debug!(\"vfs-notify event: {:?}\", event);\n             match event {\n                 Event::Message(msg) => match msg {"}]}