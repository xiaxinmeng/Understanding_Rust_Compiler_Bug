{"sha": "1aff8af213d76d746a4a86bf1b1c44af9d3d5691", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhZmY4YWYyMTNkNzZkNzQ2YTRhODZiZjFiMWM0NGFmOWQzZDU2OTE=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-06-24T16:42:21Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-06-29T13:10:15Z"}, "message": "Replace pretty-printer Box<dyn Write> with &mut String", "tree": {"sha": "5199e3afad5dd7f1909593e636d12f55934d4ad4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5199e3afad5dd7f1909593e636d12f55934d4ad4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1aff8af213d76d746a4a86bf1b1c44af9d3d5691", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1aff8af213d76d746a4a86bf1b1c44af9d3d5691", "html_url": "https://github.com/rust-lang/rust/commit/1aff8af213d76d746a4a86bf1b1c44af9d3d5691", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1aff8af213d76d746a4a86bf1b1c44af9d3d5691/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "209bde16c58b5145c210b949188315c5fdaf25d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/209bde16c58b5145c210b949188315c5fdaf25d0", "html_url": "https://github.com/rust-lang/rust/commit/209bde16c58b5145c210b949188315c5fdaf25d0"}], "stats": {"total": 107, "additions": 47, "deletions": 60}, "files": [{"sha": "eb80667bbe1c0955dba03ccb6b715addd02d13a3", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1aff8af213d76d746a4a86bf1b1c44af9d3d5691/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aff8af213d76d746a4a86bf1b1c44af9d3d5691/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=1aff8af213d76d746a4a86bf1b1c44af9d3d5691", "patch": "@@ -17,7 +17,7 @@ use crate::hir::{GenericParam, GenericParamKind, GenericArg};\n \n use std::borrow::Cow;\n use std::cell::Cell;\n-use std::io::{self, Write, Read};\n+use std::io::{self, Read};\n use std::vec;\n \n pub enum AnnNode<'a> {\n@@ -101,18 +101,14 @@ impl<'a> PrintState<'a> for State<'a> {\n #[allow(non_upper_case_globals)]\n pub const indent_unit: usize = 4;\n \n-#[allow(non_upper_case_globals)]\n-pub const default_columns: usize = 78;\n-\n-\n /// Requires you to pass an input filename and reader so that\n /// it can scan the input text for comments to copy forward.\n pub fn print_crate<'a>(cm: &'a SourceMap,\n                        sess: &ParseSess,\n                        krate: &hir::Crate,\n                        filename: FileName,\n                        input: &mut dyn Read,\n-                       out: Box<dyn Write + 'a>,\n+                       out: &'a mut String,\n                        ann: &'a dyn PpAnn)\n                        -> io::Result<()> {\n     let mut s = State::new_from_input(cm, sess, filename, input, out, ann);\n@@ -130,20 +126,20 @@ impl<'a> State<'a> {\n                           sess: &ParseSess,\n                           filename: FileName,\n                           input: &mut dyn Read,\n-                          out: Box<dyn Write + 'a>,\n+                          out: &'a mut String,\n                           ann: &'a dyn PpAnn)\n                           -> State<'a> {\n         let comments = comments::gather_comments(sess, filename, input);\n         State::new(cm, out, ann, Some(comments))\n     }\n \n     pub fn new(cm: &'a SourceMap,\n-               out: Box<dyn Write + 'a>,\n+               out: &'a mut String,\n                ann: &'a dyn PpAnn,\n                comments: Option<Vec<comments::Comment>>)\n                -> State<'a> {\n         State {\n-            s: pp::mk_printer(out, default_columns),\n+            s: pp::mk_printer(out),\n             cm: Some(cm),\n             comments,\n             cur_cmnt: 0,\n@@ -156,10 +152,10 @@ impl<'a> State<'a> {\n pub fn to_string<F>(ann: &dyn PpAnn, f: F) -> String\n     where F: FnOnce(&mut State<'_>) -> io::Result<()>\n {\n-    let mut wr = Vec::new();\n+    let mut wr = String::new();\n     {\n         let mut printer = State {\n-            s: pp::mk_printer(Box::new(&mut wr), default_columns),\n+            s: pp::mk_printer(&mut wr),\n             cm: None,\n             comments: None,\n             cur_cmnt: 0,\n@@ -169,7 +165,7 @@ pub fn to_string<F>(ann: &dyn PpAnn, f: F) -> String\n         f(&mut printer).unwrap();\n         printer.s.eof().unwrap();\n     }\n-    String::from_utf8(wr).unwrap()\n+    wr\n }\n \n pub fn visibility_qualified<S: Into<Cow<'static, str>>>(vis: &hir::Visibility, w: S) -> String {"}, {"sha": "f3bbf307b97ab9d4fee86fef1b4c15347546a672", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1aff8af213d76d746a4a86bf1b1c44af9d3d5691/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aff8af213d76d746a4a86bf1b1c44af9d3d5691/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=1aff8af213d76d746a4a86bf1b1c44af9d3d5691", "patch": "@@ -728,11 +728,11 @@ pub fn print_after_parsing(sess: &Session,\n     let (src, src_name) = get_source(input, sess);\n \n     let mut rdr = &*src;\n-    let mut out = Vec::new();\n+    let mut out = String::new();\n \n     if let PpmSource(s) = ppm {\n         // Silently ignores an identified node.\n-        let out: &mut dyn Write = &mut out;\n+        let out = &mut out;\n         s.call_with_pp_support(sess, None, move |annotation| {\n             debug!(\"pretty printing source code {:?}\", s);\n             let sess = annotation.sess();\n@@ -741,15 +741,15 @@ pub fn print_after_parsing(sess: &Session,\n                                 krate,\n                                 src_name,\n                                 &mut rdr,\n-                                box out,\n+                                out,\n                                 annotation.pp_ann(),\n                                 false)\n         }).unwrap()\n     } else {\n         unreachable!();\n     };\n \n-    write_output(out, ofile);\n+    write_output(out.into_bytes(), ofile);\n }\n \n pub fn print_after_hir_lowering<'tcx>(\n@@ -773,12 +773,12 @@ pub fn print_after_hir_lowering<'tcx>(\n     let (src, src_name) = get_source(input, tcx.sess);\n \n     let mut rdr = &src[..];\n-    let mut out = Vec::new();\n+    let mut out = String::new();\n \n     match (ppm, opt_uii) {\n             (PpmSource(s), _) => {\n                 // Silently ignores an identified node.\n-                let out: &mut dyn Write = &mut out;\n+                let out = &mut out;\n                 s.call_with_pp_support(tcx.sess, Some(tcx), move |annotation| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n@@ -787,14 +787,14 @@ pub fn print_after_hir_lowering<'tcx>(\n                                         krate,\n                                         src_name,\n                                         &mut rdr,\n-                                        box out,\n+                                        out,\n                                         annotation.pp_ann(),\n                                         true)\n                 })\n             }\n \n             (PpmHir(s), None) => {\n-                let out: &mut dyn Write = &mut out;\n+                let out = &mut out;\n                 s.call_with_pp_support_hir(tcx, move |annotation, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n@@ -803,21 +803,21 @@ pub fn print_after_hir_lowering<'tcx>(\n                                             krate,\n                                             src_name,\n                                             &mut rdr,\n-                                            box out,\n+                                            out,\n                                             annotation.pp_ann())\n                 })\n             }\n \n             (PpmHirTree(s), None) => {\n-                let out: &mut dyn Write = &mut out;\n+                let out = &mut out;\n                 s.call_with_pp_support_hir(tcx, move |_annotation, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n-                    write!(out, \"{:#?}\", krate)\n-                })\n+                    *out = format!(\"{:#?}\", krate);\n+                });\n             }\n \n             (PpmHir(s), Some(uii)) => {\n-                let out: &mut dyn Write = &mut out;\n+                let out = &mut out;\n                 s.call_with_pp_support_hir(tcx, move |annotation, _| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n@@ -826,7 +826,7 @@ pub fn print_after_hir_lowering<'tcx>(\n                                                                          &sess.parse_sess,\n                                                                          src_name,\n                                                                          &mut rdr,\n-                                                                         box out,\n+                                                                         out,\n                                                                          annotation.pp_ann());\n                     for node_id in uii.all_matching_node_ids(hir_map) {\n                         let hir_id = tcx.hir().node_to_hir_id(node_id);\n@@ -843,13 +843,13 @@ pub fn print_after_hir_lowering<'tcx>(\n             }\n \n             (PpmHirTree(s), Some(uii)) => {\n-                let out: &mut dyn Write = &mut out;\n+                let out = &mut out;\n                 s.call_with_pp_support_hir(tcx, move |_annotation, _krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     for node_id in uii.all_matching_node_ids(tcx.hir()) {\n                         let hir_id = tcx.hir().node_to_hir_id(node_id);\n                         let node = tcx.hir().get(hir_id);\n-                        write!(out, \"{:#?}\", node)?;\n+                        out.push_str(&format!(\"{:#?}\", node));\n                     }\n                     Ok(())\n                 })\n@@ -859,7 +859,7 @@ pub fn print_after_hir_lowering<'tcx>(\n         }\n         .unwrap();\n \n-    write_output(out, ofile);\n+    write_output(out.into_bytes(), ofile);\n }\n \n // In an ideal world, this would be a public function called by the driver after"}, {"sha": "4f721e9f92fbb4a8c6b8a1746c6d6af0b2402088", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1aff8af213d76d746a4a86bf1b1c44af9d3d5691/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aff8af213d76d746a4a86bf1b1c44af9d3d5691/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=1aff8af213d76d746a4a86bf1b1c44af9d3d5691", "patch": "@@ -236,7 +236,8 @@ crate struct PrintStackElem {\n \n const SIZE_INFINITY: isize = 0xffff;\n \n-pub fn mk_printer<'a>(out: Box<dyn io::Write+'a>, linewidth: usize) -> Printer<'a> {\n+pub fn mk_printer(out: &mut String) -> Printer<'_> {\n+    let linewidth = 78;\n     // Yes 55, it makes the ring buffers big enough to never fall behind.\n     let n: usize = 55 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n@@ -259,7 +260,7 @@ pub fn mk_printer<'a>(out: Box<dyn io::Write+'a>, linewidth: usize) -> Printer<'\n }\n \n pub struct Printer<'a> {\n-    out: Box<dyn io::Write+'a>,\n+    out: &'a mut String,\n     buf_max_len: usize,\n     /// Width of lines we're constrained to\n     margin: isize,\n@@ -300,8 +301,6 @@ impl Default for BufEntry {\n     }\n }\n \n-const SPACES: [u8; 128] = [b' '; 128];\n-\n impl<'a> Printer<'a> {\n     pub fn last_token(&mut self) -> Token {\n         self.buf[self.right].token.clone()\n@@ -497,10 +496,10 @@ impl<'a> Printer<'a> {\n \n     crate fn print_newline(&mut self, amount: isize) -> io::Result<()> {\n         debug!(\"NEWLINE {}\", amount);\n-        let ret = writeln!(self.out);\n+        self.out.push('\\n');\n         self.pending_indentation = 0;\n         self.indent(amount);\n-        ret\n+        Ok(())\n     }\n \n     crate fn indent(&mut self, amount: isize) {\n@@ -587,20 +586,14 @@ impl<'a> Printer<'a> {\n         //\n         //   write!(self.out, \"{: >n$}\", \"\", n = self.pending_indentation as usize)?;\n         //\n-        // But that is significantly slower than using `SPACES`. This code is\n-        // sufficiently hot, and indents can get sufficiently large, that the\n-        // difference is significant on some workloads.\n-        let spaces_len = SPACES.len() as isize;\n-        while self.pending_indentation >= spaces_len {\n-            self.out.write_all(&SPACES)?;\n-            self.pending_indentation -= spaces_len;\n-        }\n-        if self.pending_indentation > 0 {\n-            self.out.write_all(&SPACES[0..self.pending_indentation as usize])?;\n-            self.pending_indentation = 0;\n-        }\n+        // But that is significantly slower. This code is sufficiently hot, and indents can get\n+        // sufficiently large, that the difference is significant on some workloads.\n+        self.out.reserve(self.pending_indentation as usize);\n+        self.out.extend(std::iter::repeat(' ').take(self.pending_indentation as usize));\n+        self.pending_indentation = 0;\n+        self.out.push_str(&s);\n \n-        write!(self.out, \"{}\", s)\n+        Ok(())\n     }\n \n     crate fn print(&mut self, token: Token, l: isize) -> io::Result<()> {"}, {"sha": "b3bb9123a48e104cbdea32da415160aa8d4ff973", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1aff8af213d76d746a4a86bf1b1c44af9d3d5691/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aff8af213d76d746a4a86bf1b1c44af9d3d5691/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=1aff8af213d76d746a4a86bf1b1c44af9d3d5691", "patch": "@@ -21,7 +21,7 @@ use syntax_pos::{self, BytePos};\n use syntax_pos::{DUMMY_SP, FileName};\n \n use std::borrow::Cow;\n-use std::io::{self, Write, Read};\n+use std::io::{self, Read};\n use std::vec;\n \n pub enum AnnNode<'a> {\n@@ -54,9 +54,9 @@ pub struct State<'a> {\n     is_expanded: bool\n }\n \n-fn rust_printer<'a>(writer: Box<dyn Write+'a>, ann: &'a dyn PpAnn) -> State<'a> {\n+fn rust_printer<'a>(writer: &'a mut String, ann: &'a dyn PpAnn) -> State<'a> {\n     State {\n-        s: pp::mk_printer(writer, DEFAULT_COLUMNS),\n+        s: pp::mk_printer(writer),\n         cm: None,\n         comments: None,\n         cur_cmnt: 0,\n@@ -68,16 +68,14 @@ fn rust_printer<'a>(writer: Box<dyn Write+'a>, ann: &'a dyn PpAnn) -> State<'a>\n \n crate const INDENT_UNIT: usize = 4;\n \n-crate const DEFAULT_COLUMNS: usize = 78;\n-\n /// Requires you to pass an input filename and reader so that\n /// it can scan the input text for comments to copy forward.\n pub fn print_crate<'a>(cm: &'a SourceMap,\n                        sess: &ParseSess,\n                        krate: &ast::Crate,\n                        filename: FileName,\n                        input: &mut dyn Read,\n-                       out: Box<dyn Write+'a>,\n+                       out: &mut String,\n                        ann: &'a dyn PpAnn,\n                        is_expanded: bool) -> io::Result<()> {\n     let mut s = State::new_from_input(cm, sess, filename, input, out, ann, is_expanded);\n@@ -111,20 +109,20 @@ impl<'a> State<'a> {\n                           sess: &ParseSess,\n                           filename: FileName,\n                           input: &mut dyn Read,\n-                          out: Box<dyn Write+'a>,\n+                          out: &'a mut String,\n                           ann: &'a dyn PpAnn,\n                           is_expanded: bool) -> State<'a> {\n         let comments = comments::gather_comments(sess, filename, input);\n         State::new(cm, out, ann, Some(comments), is_expanded)\n     }\n \n     pub fn new(cm: &'a SourceMap,\n-               out: Box<dyn Write+'a>,\n+               out: &'a mut String,\n                ann: &'a dyn PpAnn,\n                comments: Option<Vec<comments::Comment>>,\n                is_expanded: bool) -> State<'a> {\n         State {\n-            s: pp::mk_printer(out, DEFAULT_COLUMNS),\n+            s: pp::mk_printer(out),\n             cm: Some(cm),\n             comments,\n             cur_cmnt: 0,\n@@ -138,14 +136,14 @@ impl<'a> State<'a> {\n pub fn to_string<F>(f: F) -> String where\n     F: FnOnce(&mut State<'_>) -> io::Result<()>,\n {\n-    let mut wr = Vec::new();\n+    let mut wr = String::new();\n     {\n         let ann = NoAnn;\n-        let mut printer = rust_printer(Box::new(&mut wr), &ann);\n+        let mut printer = rust_printer(&mut wr, &ann);\n         f(&mut printer).unwrap();\n         printer.s.eof().unwrap();\n     }\n-    String::from_utf8(wr).unwrap()\n+    wr\n }\n \n fn binop_to_string(op: BinOpToken) -> &'static str {"}]}