{"sha": "f5efb68a24b66a21b7eca055b9e8867eeaf61366", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1ZWZiNjhhMjRiNjZhMjFiN2VjYTA1NWI5ZTg4NjdlZWFmNjEzNjY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-08T17:52:30Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-11T18:42:07Z"}, "message": "miri: categorize errors into \"unsupported\" and \"UB\"\n\nAlso slightly refactor pointer bounds checks to avoid creating unnecessary temporary Errors", "tree": {"sha": "6079a2a3e64ddaa1910232c441dcfc729a70c6d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6079a2a3e64ddaa1910232c441dcfc729a70c6d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5efb68a24b66a21b7eca055b9e8867eeaf61366", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5efb68a24b66a21b7eca055b9e8867eeaf61366", "html_url": "https://github.com/rust-lang/rust/commit/f5efb68a24b66a21b7eca055b9e8867eeaf61366", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5efb68a24b66a21b7eca055b9e8867eeaf61366/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "url": "https://api.github.com/repos/rust-lang/rust/commits/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "html_url": "https://github.com/rust-lang/rust/commit/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be"}], "stats": {"total": 657, "additions": 293, "deletions": 364}, "files": [{"sha": "48b26cfd83cd4cd06d6b78437746934e604f2b05", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=f5efb68a24b66a21b7eca055b9e8867eeaf61366", "patch": "@@ -314,7 +314,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n                 &self.get_bytes(cx, ptr, size_with_null)?[..size]\n             }\n             // This includes the case where `offset` is out-of-bounds to begin with.\n-            None => throw_unsup!(UnterminatedCString(ptr.erase_tag())),\n+            None => throw_ub!(UnterminatedCString(ptr.erase_tag())),\n         })\n     }\n \n@@ -573,7 +573,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     fn check_defined(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n         self.undef_mask\n             .is_range_defined(ptr.offset, ptr.offset + size)\n-            .or_else(|idx| throw_unsup!(ReadUndefBytes(idx)))\n+            .or_else(|idx| throw_ub!(InvalidUndefBytes(Some(Pointer::new(ptr.alloc_id, idx)))))\n     }\n \n     pub fn mark_definedness(&mut self, ptr: Pointer<Tag>, size: Size, new_state: bool) {"}, {"sha": "ff0e9f2771f4917f5889b7452e020673527c5519", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 113, "deletions": 182, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=f5efb68a24b66a21b7eca055b9e8867eeaf61366", "patch": "@@ -1,7 +1,6 @@\n-use super::{CheckInAllocMsg, Pointer, RawConst, ScalarMaybeUndef};\n+use super::{AllocId, CheckInAllocMsg, Pointer, RawConst, ScalarMaybeUndef};\n \n use crate::hir::map::definitions::DefPathData;\n-use crate::mir;\n use crate::mir::interpret::ConstValue;\n use crate::ty::layout::{Align, LayoutError, Size};\n use crate::ty::query::TyCtxtAt;\n@@ -14,9 +13,8 @@ use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_macros::HashStable;\n use rustc_session::CtfeBacktrace;\n-use rustc_span::{Pos, Span};\n-use rustc_target::spec::abi::Abi;\n-use std::{any::Any, fmt};\n+use rustc_span::{Pos, Span, def_id::DefId};\n+use std::{any::Any, env, fmt};\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable)]\n pub enum ErrorHandled {\n@@ -296,6 +294,8 @@ pub enum InvalidProgramInfo<'tcx> {\n     TypeckError,\n     /// An error occurred during layout computation.\n     Layout(layout::LayoutError<'tcx>),\n+    /// An invalid transmute happened.\n+    TransmuteSizeDiff(Ty<'tcx>, Ty<'tcx>),\n }\n \n impl fmt::Debug for InvalidProgramInfo<'_> {\n@@ -306,6 +306,11 @@ impl fmt::Debug for InvalidProgramInfo<'_> {\n             ReferencedConstant => write!(f, \"referenced constant has errors\"),\n             TypeckError => write!(f, \"encountered constants with type errors, stopping evaluation\"),\n             Layout(ref err) => write!(f, \"{}\", err),\n+            TransmuteSizeDiff(from_ty, to_ty) => write!(\n+                f,\n+                \"tried to transmute from {:?} to {:?}, but their sizes differed\",\n+                from_ty, to_ty\n+            ),\n         }\n     }\n }\n@@ -330,6 +335,43 @@ pub enum UndefinedBehaviorInfo {\n     PointerArithOverflow,\n     /// Invalid metadata in a wide pointer (using `str` to avoid allocations).\n     InvalidMeta(&'static str),\n+    /// Reading a C string that does not end within its allocation.\n+    UnterminatedCString(Pointer),\n+    /// Dereferencing a dangling pointer after it got freed.\n+    PointerUseAfterFree(AllocId),\n+    /// Using a NULL pointer in the wrong way.\n+    InvalidNullPointerUsage,\n+    /// Used a pointer outside the bounds it is valid for.\n+    PointerOutOfBounds {\n+        ptr: Pointer,\n+        msg: CheckInAllocMsg,\n+        allocation_size: Size,\n+    },\n+    /// Used a pointer with bad alignment.\n+    AlignmentCheckFailed {\n+        required: Align,\n+        has: Align,\n+    },\n+    /// Writing to read-only memory.\n+    WriteToReadOnly(AllocId),\n+    /// Using a pointer-not-to-a-function as function pointer.\n+    InvalidFunctionPointer(Pointer),\n+    // Trying to access the data behind a function pointer.\n+    DerefFunctionPointer(AllocId),\n+    /// The value validity check found a problem.\n+    /// Should only be thrown by `validity.rs` and always point out which part of the value\n+    /// is the problem.\n+    ValidationFailure(String),\n+    /// Using a non-boolean `u8` as bool.\n+    InvalidBool(u8),\n+    /// Using a non-character `u32` as character.\n+    InvalidChar(u32),\n+    /// Using uninitialized data where it is not allowed.\n+    InvalidUndefBytes(Option<Pointer>),\n+    /// Working with a local that is not currently live.\n+    DeadLocal,\n+    /// Trying to read from the return place of a function.\n+    ReadFromReturnPlace,\n }\n \n impl fmt::Debug for UndefinedBehaviorInfo {\n@@ -348,6 +390,44 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n             RemainderByZero => write!(f, \"calculating the remainder with a divisor of zero\"),\n             PointerArithOverflow => write!(f, \"overflowing in-bounds pointer arithmetic\"),\n             InvalidMeta(msg) => write!(f, \"invalid metadata in wide pointer: {}\", msg),\n+            UnterminatedCString(p) => write!(\n+                f,\n+                \"reading a null-terminated string starting at {:?} with no null found before end of allocation\",\n+                p,\n+            ),\n+            PointerUseAfterFree(a) => write!(\n+                f,\n+                \"pointer to allocation {:?} was dereferenced after allocation got freed\",\n+                a\n+            ),\n+            InvalidNullPointerUsage => write!(f, \"invalid use of NULL pointer\"),\n+            PointerOutOfBounds { ptr, msg, allocation_size } => write!(\n+                f,\n+                \"{} failed: pointer must be in-bounds at offset {}, \\\n+                           but is outside bounds of allocation {} which has size {}\",\n+                msg,\n+                ptr.offset.bytes(),\n+                ptr.alloc_id,\n+                allocation_size.bytes()\n+            ),\n+            AlignmentCheckFailed { required, has } => write!(\n+                f,\n+                \"accessing memory with alignment {}, but alignment {} is required\",\n+                has.bytes(),\n+                required.bytes()\n+            ),\n+            WriteToReadOnly(a) => write!(f, \"writing to read-only allocation {:?}\", a),\n+            InvalidFunctionPointer(p) => {\n+                write!(f, \"using {:?} as function pointer but it does not point to a function\", p)\n+            }\n+            DerefFunctionPointer(a) => write!(f, \"accessing data behind function pointer allocation {:?}\", a),\n+            ValidationFailure(ref err) => write!(f, \"type validation failed: {}\", err),\n+            InvalidBool(b) => write!(f, \"interpreting an invalid 8-bit value as a bool: {}\", b),\n+            InvalidChar(c) => write!(f, \"interpreting an invalid 32-bit value as a char: {}\", c),\n+            InvalidUndefBytes(Some(p)) => write!(f, \"reading uninitialized memory at {:?}, but this operation requires initialized memory\", p),\n+            InvalidUndefBytes(None) => write!(f, \"using uninitialized data, but this operation requires initialized memory\"),\n+            DeadLocal => write!(f, \"accessing a dead local variable\"),\n+            ReadFromReturnPlace => write!(f, \"tried to read from the return place\"),\n         }\n     }\n }\n@@ -359,202 +439,53 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n ///\n /// Currently, we also use this as fall-back error kind for errors that have not been\n /// categorized yet.\n-pub enum UnsupportedOpInfo<'tcx> {\n+pub enum UnsupportedOpInfo {\n     /// Free-form case. Only for errors that are never caught!\n     Unsupported(String),\n \n     /// When const-prop encounters a situation it does not support, it raises this error.\n     /// This must not allocate for performance reasons (hence `str`, not `String`).\n     ConstPropUnsupported(&'static str),\n \n-    // -- Everything below is not categorized yet --\n-    FunctionAbiMismatch(Abi, Abi),\n-    FunctionArgMismatch(Ty<'tcx>, Ty<'tcx>),\n-    FunctionRetMismatch(Ty<'tcx>, Ty<'tcx>),\n-    FunctionArgCountMismatch,\n-    UnterminatedCString(Pointer),\n-    DanglingPointerDeref,\n-    DoubleFree,\n-    InvalidMemoryAccess,\n-    InvalidFunctionPointer,\n-    InvalidBool,\n-    PointerOutOfBounds {\n-        ptr: Pointer,\n-        msg: CheckInAllocMsg,\n-        allocation_size: Size,\n-    },\n-    InvalidNullPointerUsage,\n+    /// Accessing an unsupported foreign static.\n+    ReadForeignStatic(DefId),\n+\n+    /// Could not find MIR for a function.\n+    NoMirFor(DefId),\n+\n+    /// Modified a static during const-eval.\n+    /// FIXME: move this to `ConstEvalErrKind` through a machine hook.\n+    ModifiedStatic,\n+\n+    /// Encountered a pointer where we needed raw bytes.\n     ReadPointerAsBytes,\n+\n+    /// Encountered raw bytes where we needed a pointer.\n     ReadBytesAsPointer,\n-    ReadForeignStatic,\n-    InvalidPointerMath,\n-    ReadUndefBytes(Size),\n-    DeadLocal,\n-    InvalidBoolOp(mir::BinOp),\n-    UnimplementedTraitSelection,\n-    CalledClosureAsFunction,\n-    NoMirFor(String),\n-    DerefFunctionPointer,\n-    ExecuteMemory,\n-    InvalidChar(u128),\n-    OutOfTls,\n-    TlsOutOfBounds,\n-    AlignmentCheckFailed {\n-        required: Align,\n-        has: Align,\n-    },\n-    ValidationFailure(String),\n-    VtableForArgumentlessMethod,\n-    ModifiedConstantMemory,\n-    ModifiedStatic,\n-    TypeNotPrimitive(Ty<'tcx>),\n-    ReallocatedWrongMemoryKind(String, String),\n-    DeallocatedWrongMemoryKind(String, String),\n-    ReallocateNonBasePtr,\n-    DeallocateNonBasePtr,\n-    IncorrectAllocationInformation(Size, Size, Align, Align),\n-    HeapAllocZeroBytes,\n-    HeapAllocNonPowerOfTwoAlignment(u64),\n-    ReadFromReturnPointer,\n-    PathNotFound(Vec<String>),\n-    TransmuteSizeDiff(Ty<'tcx>, Ty<'tcx>),\n }\n \n-impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n+impl fmt::Debug for UnsupportedOpInfo {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use UnsupportedOpInfo::*;\n         match self {\n-            PointerOutOfBounds { ptr, msg, allocation_size } => write!(\n-                f,\n-                \"{} failed: pointer must be in-bounds at offset {}, \\\n-                           but is outside bounds of allocation {} which has size {}\",\n-                msg,\n-                ptr.offset.bytes(),\n-                ptr.alloc_id,\n-                allocation_size.bytes()\n-            ),\n-            ValidationFailure(ref err) => write!(f, \"type validation failed: {}\", err),\n-            NoMirFor(ref func) => write!(f, \"no MIR for `{}`\", func),\n-            FunctionAbiMismatch(caller_abi, callee_abi) => write!(\n-                f,\n-                \"tried to call a function with ABI {:?} using caller ABI {:?}\",\n-                callee_abi, caller_abi\n-            ),\n-            FunctionArgMismatch(caller_ty, callee_ty) => write!(\n-                f,\n-                \"tried to call a function with argument of type {:?} \\\n-                           passing data of type {:?}\",\n-                callee_ty, caller_ty\n-            ),\n-            TransmuteSizeDiff(from_ty, to_ty) => write!(\n-                f,\n-                \"tried to transmute from {:?} to {:?}, but their sizes differed\",\n-                from_ty, to_ty\n-            ),\n-            FunctionRetMismatch(caller_ty, callee_ty) => write!(\n-                f,\n-                \"tried to call a function with return type {:?} \\\n-                           passing return place of type {:?}\",\n-                callee_ty, caller_ty\n-            ),\n-            FunctionArgCountMismatch => {\n-                write!(f, \"tried to call a function with incorrect number of arguments\")\n-            }\n-            ReallocatedWrongMemoryKind(ref old, ref new) => {\n-                write!(f, \"tried to reallocate memory from `{}` to `{}`\", old, new)\n-            }\n-            DeallocatedWrongMemoryKind(ref old, ref new) => {\n-                write!(f, \"tried to deallocate `{}` memory but gave `{}` as the kind\", old, new)\n-            }\n-            InvalidChar(c) => {\n-                write!(f, \"tried to interpret an invalid 32-bit value as a char: {}\", c)\n-            }\n-            AlignmentCheckFailed { required, has } => write!(\n-                f,\n-                \"tried to access memory with alignment {}, but alignment {} is required\",\n-                has.bytes(),\n-                required.bytes()\n-            ),\n-            TypeNotPrimitive(ty) => write!(f, \"expected primitive type, got {}\", ty),\n-            PathNotFound(ref path) => write!(f, \"cannot find path {:?}\", path),\n-            IncorrectAllocationInformation(size, size2, align, align2) => write!(\n-                f,\n-                \"incorrect alloc info: expected size {} and align {}, \\\n-                           got size {} and align {}\",\n-                size.bytes(),\n-                align.bytes(),\n-                size2.bytes(),\n-                align2.bytes()\n-            ),\n-            InvalidMemoryAccess => write!(f, \"tried to access memory through an invalid pointer\"),\n-            DanglingPointerDeref => write!(f, \"dangling pointer was dereferenced\"),\n-            DoubleFree => write!(f, \"tried to deallocate dangling pointer\"),\n-            InvalidFunctionPointer => {\n-                write!(f, \"tried to use a function pointer after offsetting it\")\n-            }\n-            InvalidBool => write!(f, \"invalid boolean value read\"),\n-            InvalidNullPointerUsage => write!(f, \"invalid use of NULL pointer\"),\n-            ReadPointerAsBytes => write!(\n-                f,\n-                \"a raw memory access tried to access part of a pointer value as raw \\\n-                    bytes\"\n-            ),\n-            ReadBytesAsPointer => {\n-                write!(f, \"a memory access tried to interpret some bytes as a pointer\")\n-            }\n-            ReadForeignStatic => write!(f, \"tried to read from foreign (extern) static\"),\n-            InvalidPointerMath => write!(\n-                f,\n-                \"attempted to do invalid arithmetic on pointers that would leak base \\\n-                    addresses, e.g., comparing pointers into different allocations\"\n-            ),\n-            DeadLocal => write!(f, \"tried to access a dead local variable\"),\n-            DerefFunctionPointer => write!(f, \"tried to dereference a function pointer\"),\n-            ExecuteMemory => write!(f, \"tried to treat a memory pointer as a function pointer\"),\n-            OutOfTls => write!(f, \"reached the maximum number of representable TLS keys\"),\n-            TlsOutOfBounds => write!(f, \"accessed an invalid (unallocated) TLS key\"),\n-            CalledClosureAsFunction => {\n-                write!(f, \"tried to call a closure through a function pointer\")\n-            }\n-            VtableForArgumentlessMethod => {\n-                write!(f, \"tried to call a vtable function without arguments\")\n+            Unsupported(ref msg) => write!(f, \"{}\", msg),\n+            ConstPropUnsupported(ref msg) => {\n+                write!(f, \"Constant propagation encountered an unsupported situation: {}\", msg)\n             }\n-            ModifiedConstantMemory => write!(f, \"tried to modify constant memory\"),\n+            ReadForeignStatic(did) => write!(f, \"tried to read from foreign (extern) static {:?}\", did),\n+            NoMirFor(did) => write!(f, \"could not load MIR for {:?}\", did),\n             ModifiedStatic => write!(\n                 f,\n                 \"tried to modify a static's initial value from another static's \\\n                     initializer\"\n             ),\n-            ReallocateNonBasePtr => write!(\n-                f,\n-                \"tried to reallocate with a pointer not to the beginning of an \\\n-                    existing object\"\n-            ),\n-            DeallocateNonBasePtr => write!(\n-                f,\n-                \"tried to deallocate with a pointer not to the beginning of an \\\n-                    existing object\"\n-            ),\n-            HeapAllocZeroBytes => write!(f, \"tried to re-, de- or allocate zero bytes on the heap\"),\n-            ReadFromReturnPointer => write!(f, \"tried to read from the return pointer\"),\n-            UnimplementedTraitSelection => {\n-                write!(f, \"there were unresolved type arguments during trait selection\")\n-            }\n-            InvalidBoolOp(_) => write!(f, \"invalid boolean operation\"),\n-            UnterminatedCString(_) => write!(\n-                f,\n-                \"attempted to get length of a null-terminated string, but no null \\\n-                    found before end of allocation\"\n-            ),\n-            ReadUndefBytes(_) => write!(f, \"attempted to read undefined bytes\"),\n-            HeapAllocNonPowerOfTwoAlignment(_) => write!(\n+\n+            ReadPointerAsBytes => write!(\n                 f,\n-                \"tried to re-, de-, or allocate heap memory with alignment that is \\\n-                    not a power of two\"\n+                \"unable to turn this pointer into raw bytes\",\n             ),\n-            Unsupported(ref msg) => write!(f, \"{}\", msg),\n-            ConstPropUnsupported(ref msg) => {\n-                write!(f, \"Constant propagation encountered an unsupported situation: {}\", msg)\n+            ReadBytesAsPointer => {\n+                write!(f, \"unable to turn these bytes into a pointer\")\n             }\n         }\n     }\n@@ -590,7 +521,7 @@ pub enum InterpError<'tcx> {\n     UndefinedBehavior(UndefinedBehaviorInfo),\n     /// The program did something the interpreter does not support (some of these *might* be UB\n     /// but the interpreter is not sure).\n-    Unsupported(UnsupportedOpInfo<'tcx>),\n+    Unsupported(UnsupportedOpInfo),\n     /// The program was invalid (ill-typed, bad MIR, not sufficiently monomorphized, ...).\n     InvalidProgram(InvalidProgramInfo<'tcx>),\n     /// The program exhausted the interpreter's resources (stack/heap too big,\n@@ -606,7 +537,7 @@ pub type InterpResult<'tcx, T = ()> = Result<T, InterpErrorInfo<'tcx>>;\n impl fmt::Display for InterpError<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // Forward `Display` to `Debug`.\n-        write!(f, \"{:?}\", self)\n+        fmt::Debug::fmt(self, f)\n     }\n }\n \n@@ -631,7 +562,7 @@ impl InterpError<'_> {\n         match self {\n             InterpError::MachineStop(_)\n             | InterpError::Unsupported(UnsupportedOpInfo::Unsupported(_))\n-            | InterpError::Unsupported(UnsupportedOpInfo::ValidationFailure(_))\n+            | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::ValidationFailure(_))\n             | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::Ub(_))\n             | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::UbExperimental(_)) => true,\n             _ => false,"}, {"sha": "0b5bb7f3c03faf01bfdb98dac9816587460418c1", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=f5efb68a24b66a21b7eca055b9e8867eeaf61366", "patch": "@@ -161,7 +161,13 @@ pub struct AllocId(pub u64);\n \n impl fmt::Debug for AllocId {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(fmt, \"alloc{}\", self.0)\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+impl fmt::Display for AllocId {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"alloc{}\", self.0)\n     }\n }\n \n@@ -351,12 +357,6 @@ impl<'s> AllocDecodingSession<'s> {\n     }\n }\n \n-impl fmt::Display for AllocId {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}\", self.0)\n-    }\n-}\n-\n /// An allocation in the global (tcx-managed) memory can be either a function pointer,\n /// a static, or a \"real\" allocation with some data in it.\n #[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable, HashStable)]"}, {"sha": "2cbe25f9674261e899319d537f8480ead7eda068", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=f5efb68a24b66a21b7eca055b9e8867eeaf61366", "patch": "@@ -213,20 +213,4 @@ impl<'tcx, Tag> Pointer<Tag> {\n     pub fn erase_tag(self) -> Pointer {\n         Pointer { alloc_id: self.alloc_id, offset: self.offset, tag: () }\n     }\n-\n-    /// Test if the pointer is \"inbounds\" of an allocation of the given size.\n-    /// A pointer is \"inbounds\" even if its offset is equal to the size; this is\n-    /// a \"one-past-the-end\" pointer.\n-    #[inline(always)]\n-    pub fn check_inbounds_alloc(\n-        self,\n-        allocation_size: Size,\n-        msg: CheckInAllocMsg,\n-    ) -> InterpResult<'tcx, ()> {\n-        if self.offset > allocation_size {\n-            throw_unsup!(PointerOutOfBounds { ptr: self.erase_tag(), msg, allocation_size })\n-        } else {\n-            Ok(())\n-        }\n-    }\n }"}, {"sha": "854f3e0146d239bc63be37ad56dd6b2d5f16c8bd", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=f5efb68a24b66a21b7eca055b9e8867eeaf61366", "patch": "@@ -429,18 +429,19 @@ impl<'tcx, Tag> Scalar<Tag> {\n     }\n \n     pub fn to_bool(self) -> InterpResult<'tcx, bool> {\n-        match self {\n-            Scalar::Raw { data: 0, size: 1 } => Ok(false),\n-            Scalar::Raw { data: 1, size: 1 } => Ok(true),\n-            _ => throw_unsup!(InvalidBool),\n+        let val = self.to_u8()?;\n+        match val {\n+            0 => Ok(false),\n+            1 => Ok(true),\n+            _ => throw_ub!(InvalidBool(val)),\n         }\n     }\n \n     pub fn to_char(self) -> InterpResult<'tcx, char> {\n         let val = self.to_u32()?;\n         match ::std::char::from_u32(val) {\n             Some(c) => Ok(c),\n-            None => throw_unsup!(InvalidChar(val as u128)),\n+            None => throw_ub!(InvalidChar(val)),\n         }\n     }\n \n@@ -583,7 +584,7 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     pub fn not_undef(self) -> InterpResult<'static, Scalar<Tag>> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n-            ScalarMaybeUndef::Undef => throw_unsup!(ReadUndefBytes(Size::ZERO)),\n+            ScalarMaybeUndef::Undef => throw_ub!(InvalidUndefBytes(None)),\n         }\n     }\n "}, {"sha": "28889486c383b55150ced9e80d4c73fc60b31f21", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=f5efb68a24b66a21b7eca055b9e8867eeaf61366", "patch": "@@ -240,7 +240,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         Ok(Some(match ecx.load_mir(instance.def, None) {\n             Ok(body) => *body,\n             Err(err) => {\n-                if let err_unsup!(NoMirFor(ref path)) = err.kind {\n+                if let err_unsup!(NoMirFor(did)) = err.kind {\n+                    let path = ecx.tcx.def_path_str(did);\n                     return Err(ConstEvalErrKind::NeedsRfc(format!(\n                         \"calling extern function `{}`\",\n                         path"}, {"sha": "b7888d85f38cbba7cf9cad77c214035d2823ee93", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=f5efb68a24b66a21b7eca055b9e8867eeaf61366", "patch": "@@ -138,7 +138,7 @@ pub enum LocalValue<Tag = (), Id = AllocId> {\n impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n     pub fn access(&self) -> InterpResult<'tcx, Operand<Tag>> {\n         match self.value {\n-            LocalValue::Dead => throw_unsup!(DeadLocal),\n+            LocalValue::Dead => throw_ub!(DeadLocal),\n             LocalValue::Uninitialized => {\n                 bug!(\"The type checker should prevent reading from a never-written local\")\n             }\n@@ -152,7 +152,7 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n         &mut self,\n     ) -> InterpResult<'tcx, Result<&mut LocalValue<Tag>, MemPlace<Tag>>> {\n         match self.value {\n-            LocalValue::Dead => throw_unsup!(DeadLocal),\n+            LocalValue::Dead => throw_ub!(DeadLocal),\n             LocalValue::Live(Operand::Indirect(mplace)) => Ok(Err(mplace)),\n             ref mut local @ LocalValue::Live(Operand::Immediate(_))\n             | ref mut local @ LocalValue::Uninitialized => Ok(Ok(local)),\n@@ -326,7 +326,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 if self.tcx.is_mir_available(did) {\n                     Ok(self.tcx.optimized_mir(did).unwrap_read_only())\n                 } else {\n-                    throw_unsup!(NoMirFor(self.tcx.def_path_str(def_id)))\n+                    throw_unsup!(NoMirFor(def_id))\n                 }\n             }\n             _ => Ok(self.tcx.instance_mir(instance)),"}, {"sha": "90b8a4932991e2b44499c2a4105a257c4ecb1dba", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=f5efb68a24b66a21b7eca055b9e8867eeaf61366", "patch": "@@ -327,7 +327,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n         if let Err(error) = interned {\n             // This can happen when e.g. the tag of an enum is not a valid discriminant. We do have\n             // to read enum discriminants in order to find references in enum variant fields.\n-            if let err_unsup!(ValidationFailure(_)) = error.kind {\n+            if let err_ub!(ValidationFailure(_)) = error.kind {\n                 let err = crate::const_eval::error_to_const_error(&ecx, error);\n                 match err.struct_error(\n                     ecx.tcx,\n@@ -390,7 +390,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             }\n         } else if ecx.memory.dead_alloc_map.contains_key(&alloc_id) {\n             // dangling pointer\n-            throw_unsup!(ValidationFailure(\"encountered dangling pointer in final constant\".into()))\n+            throw_ub_format!(\"encountered dangling pointer in final constant\")\n         } else if ecx.tcx.alloc_map.lock().get(alloc_id).is_none() {\n             // We have hit an `AllocId` that is neither in local or global memory and isn't marked\n             // as dangling by local memory."}, {"sha": "75d936600b6b67a58b12b91c5e57f193ee9c578b", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=f5efb68a24b66a21b7eca055b9e8867eeaf61366", "patch": "@@ -134,7 +134,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let bits = self.force_bits(val, layout_of.size)?;\n                 let kind = match layout_of.abi {\n                     ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n-                    _ => throw_unsup!(TypeNotPrimitive(ty)),\n+                    _ => bug!(\"{} called on invalid type {:?}\", intrinsic_name, ty),\n                 };\n                 let (nonzero, intrinsic_name) = match intrinsic_name {\n                     sym::cttz_nonzero => (true, sym::cttz),"}, {"sha": "d86ea026ad0dafe5901c4b45903e998227331a4d", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=f5efb68a24b66a21b7eca055b9e8867eeaf61366", "patch": "@@ -281,7 +281,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         int: u64,\n     ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n         Err((if int == 0 {\n-            err_unsup!(InvalidNullPointerUsage)\n+            err_ub!(InvalidNullPointerUsage)\n         } else {\n             err_unsup!(ReadBytesAsPointer)\n         })"}, {"sha": "24147bdd44ff39cc25141e1a3852ef1c8ddad1ec", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=f5efb68a24b66a21b7eca055b9e8867eeaf61366", "patch": "@@ -215,7 +215,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n         if ptr.offset.bytes() != 0 {\n-            throw_unsup!(ReallocateNonBasePtr)\n+            throw_ub_format!(\"reallocating {:?} which does not point to the beginning of an object\", ptr);\n         }\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\".\n@@ -251,37 +251,32 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         trace!(\"deallocating: {}\", ptr.alloc_id);\n \n         if ptr.offset.bytes() != 0 {\n-            throw_unsup!(DeallocateNonBasePtr)\n+            throw_ub_format!(\"deallocating {:?} which does not point to the beginning of an object\", ptr);\n         }\n \n         let (alloc_kind, mut alloc) = match self.alloc_map.remove(&ptr.alloc_id) {\n             Some(alloc) => alloc,\n             None => {\n                 // Deallocating static memory -- always an error\n                 return Err(match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n-                    Some(GlobalAlloc::Function(..)) => err_unsup!(DeallocatedWrongMemoryKind(\n-                        \"function\".to_string(),\n-                        format!(\"{:?}\", kind),\n-                    )),\n-                    Some(GlobalAlloc::Static(..)) | Some(GlobalAlloc::Memory(..)) => err_unsup!(\n-                        DeallocatedWrongMemoryKind(\"static\".to_string(), format!(\"{:?}\", kind))\n-                    ),\n-                    None => err_unsup!(DoubleFree),\n+                    Some(GlobalAlloc::Function(..)) => err_ub_format!(\"deallocating a function\"),\n+                    Some(GlobalAlloc::Static(..)) | Some(GlobalAlloc::Memory(..)) =>\n+                        err_ub_format!(\"deallocating static memory\"),\n+                    None => err_ub!(PointerUseAfterFree(ptr.alloc_id)),\n                 }\n                 .into());\n             }\n         };\n \n         if alloc_kind != kind {\n-            throw_unsup!(DeallocatedWrongMemoryKind(\n-                format!(\"{:?}\", alloc_kind),\n-                format!(\"{:?}\", kind),\n-            ))\n+            throw_ub_format!(\"deallocating `{:?}` memory using `{:?}` deallocation operation\", alloc_kind, kind);\n         }\n         if let Some((size, align)) = old_size_and_align {\n             if size != alloc.size || align != alloc.align {\n-                let bytes = alloc.size;\n-                throw_unsup!(IncorrectAllocationInformation(size, bytes, align, alloc.align))\n+                throw_ub_format!(\n+                    \"incorrect layout on deallocation: allocation has size {} and alignment {}, but gave size {} and alignment {}\",\n+                    alloc.size.bytes(), alloc.align.bytes(), size.bytes(), align.bytes(),\n+                )\n             }\n         }\n \n@@ -338,7 +333,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             } else {\n                 // The biggest power of two through which `offset` is divisible.\n                 let offset_pow2 = 1 << offset.trailing_zeros();\n-                throw_unsup!(AlignmentCheckFailed {\n+                throw_ub!(AlignmentCheckFailed {\n                     has: Align::from_bytes(offset_pow2).unwrap(),\n                     required: align,\n                 })\n@@ -360,7 +355,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 assert!(size.bytes() == 0);\n                 // Must be non-NULL.\n                 if bits == 0 {\n-                    throw_unsup!(InvalidNullPointerUsage)\n+                    throw_ub!(InvalidNullPointerUsage)\n                 }\n                 // Must be aligned.\n                 if let Some(align) = align {\n@@ -375,7 +370,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // It is sufficient to check this for the end pointer. The addition\n                 // checks for overflow.\n                 let end_ptr = ptr.offset(size, self)?;\n-                end_ptr.check_inbounds_alloc(allocation_size, msg)?;\n+                if end_ptr.offset > allocation_size { // equal is okay!\n+                    throw_ub!(PointerOutOfBounds { ptr: end_ptr.erase_tag(), msg, allocation_size })\n+                }\n                 // Test align. Check this last; if both bounds and alignment are violated\n                 // we want the error to be about the bounds.\n                 if let Some(align) = align {\n@@ -385,7 +382,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                         // got picked we might be aligned even if this check fails.\n                         // We instead have to fall back to converting to an integer and checking\n                         // the \"real\" alignment.\n-                        throw_unsup!(AlignmentCheckFailed { has: alloc_align, required: align });\n+                        throw_ub!(AlignmentCheckFailed { has: alloc_align, required: align });\n                     }\n                     check_offset_align(ptr.offset.bytes(), align)?;\n                 }\n@@ -402,7 +399,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let (size, _align) = self\n             .get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)\n             .expect(\"alloc info with MaybeDead cannot fail\");\n-        ptr.check_inbounds_alloc(size, CheckInAllocMsg::NullPointerTest).is_err()\n+        // An inbounds pointer is never null!  And \"inbounds\" includes one-past-the-end.\n+        let inbounds = ptr.offset <= size;\n+        !inbounds\n     }\n }\n \n@@ -432,13 +431,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let alloc = tcx.alloc_map.lock().get(id);\n         let alloc = match alloc {\n             Some(GlobalAlloc::Memory(mem)) => Cow::Borrowed(mem),\n-            Some(GlobalAlloc::Function(..)) => throw_unsup!(DerefFunctionPointer),\n-            None => throw_unsup!(DanglingPointerDeref),\n+            Some(GlobalAlloc::Function(..)) => throw_ub!(DerefFunctionPointer(id)),\n+            None => throw_ub!(PointerUseAfterFree(id)),\n             Some(GlobalAlloc::Static(def_id)) => {\n                 // We got a \"lazy\" static that has not been computed yet.\n                 if tcx.is_foreign_item(def_id) {\n                     trace!(\"get_static_alloc: foreign item {:?}\", def_id);\n-                    throw_unsup!(ReadForeignStatic)\n+                    throw_unsup!(ReadForeignStatic(def_id))\n                 }\n                 trace!(\"get_static_alloc: Need to compute {:?}\", def_id);\n                 let instance = Instance::mono(tcx.tcx, def_id);\n@@ -524,7 +523,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // to give us a cheap reference.\n             let alloc = Self::get_static_alloc(memory_extra, tcx, id)?;\n             if alloc.mutability == Mutability::Not {\n-                throw_unsup!(ModifiedConstantMemory)\n+                throw_ub!(WriteToReadOnly(id))\n             }\n             match M::STATIC_KIND {\n                 Some(kind) => Ok((MemoryKind::Machine(kind), alloc.into_owned())),\n@@ -538,7 +537,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Ok(a) => {\n                 let a = &mut a.1;\n                 if a.mutability == Mutability::Not {\n-                    throw_unsup!(ModifiedConstantMemory)\n+                    throw_ub!(WriteToReadOnly(id))\n                 }\n                 Ok(a)\n             }\n@@ -568,7 +567,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         if self.get_fn_alloc(id).is_some() {\n             return if let AllocCheck::Dereferenceable = liveness {\n                 // The caller requested no function pointers.\n-                throw_unsup!(DerefFunctionPointer)\n+                throw_ub!(DerefFunctionPointer(id))\n             } else {\n                 Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n             };\n@@ -596,12 +595,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 if let AllocCheck::MaybeDead = liveness {\n                     // Deallocated pointers are allowed, we should be able to find\n                     // them in the map.\n-                    Ok(*self.dead_alloc_map.get(&id).expect(\n-                        \"deallocated pointers should all be recorded in \\\n-                            `dead_alloc_map`\",\n-                    ))\n+                    Ok(*self\n+                        .dead_alloc_map\n+                        .get(&id)\n+                        .expect(\"deallocated pointers should all be recorded in `dead_alloc_map`\"))\n                 } else {\n-                    throw_unsup!(DanglingPointerDeref)\n+                    throw_ub!(PointerUseAfterFree(id))\n                 }\n             }\n         }\n@@ -626,10 +625,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         let ptr = self.force_ptr(ptr)?; // We definitely need a pointer value.\n         if ptr.offset.bytes() != 0 {\n-            throw_unsup!(InvalidFunctionPointer)\n+            throw_ub!(InvalidFunctionPointer(ptr.erase_tag()))\n         }\n         let id = M::canonical_alloc_id(self, ptr.alloc_id);\n-        self.get_fn_alloc(id).ok_or_else(|| err_unsup!(ExecuteMemory).into())\n+        self.get_fn_alloc(id).ok_or_else(|| err_ub!(InvalidFunctionPointer(ptr.erase_tag())).into())\n     }\n \n     pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {"}, {"sha": "227ba540e6b9df2eb18c37a023765b160e92d834", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=f5efb68a24b66a21b7eca055b9e8867eeaf61366", "patch": "@@ -344,7 +344,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let len = mplace.len(self)?;\n         let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len as u64))?;\n         let str = ::std::str::from_utf8(bytes)\n-            .map_err(|err| err_unsup!(ValidationFailure(err.to_string())))?;\n+            .map_err(|err| err_ub_format!(\"this string is not valid UTF-8: {}\", err))?;\n         Ok(str)\n     }\n \n@@ -458,7 +458,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         layout: Option<TyLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let base_op = match place.local {\n-            mir::RETURN_PLACE => throw_unsup!(ReadFromReturnPointer),\n+            mir::RETURN_PLACE => throw_ub!(ReadFromReturnPlace),\n             local => {\n                 // Do not use the layout passed in as argument if the base we are looking at\n                 // here is not the entire place."}, {"sha": "107cfee5aceb50f6b3ecb21887ee8e82de138a8b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=f5efb68a24b66a21b7eca055b9e8867eeaf61366", "patch": "@@ -926,7 +926,7 @@ where\n             // most likey we *are* running `typeck` right now. Investigate whether we can bail out\n             // on `typeck_tables().has_errors` at all const eval entry points.\n             debug!(\"Size mismatch when transmuting!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n-            throw_unsup!(TransmuteSizeDiff(src.layout.ty, dest.layout.ty));\n+            throw_inval!(TransmuteSizeDiff(src.layout.ty, dest.layout.ty));\n         }\n         // Unsized copies rely on interpreting `src.meta` with `dest.layout`, we want\n         // to avoid that here."}, {"sha": "51a557851fce280c3382057869f3344570b2cd0e", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 111, "deletions": 98, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=f5efb68a24b66a21b7eca055b9e8867eeaf61366", "patch": "@@ -170,13 +170,19 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             trace!(\"Skipping callee ZST\");\n             return Ok(());\n         }\n-        let caller_arg = caller_arg.next().ok_or_else(|| err_unsup!(FunctionArgCountMismatch))?;\n+        let caller_arg = caller_arg.next().ok_or_else(|| {\n+            err_ub_format!(\"calling a function passing fewer arguments than it requires\")\n+        })?;\n         if rust_abi {\n             assert!(!caller_arg.layout.is_zst(), \"ZSTs must have been already filtered out\");\n         }\n         // Now, check\n         if !Self::check_argument_compat(rust_abi, caller_arg.layout, callee_arg.layout) {\n-            throw_unsup!(FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty))\n+            throw_ub_format!(\n+                \"calling a function with argument of type {:?} passing data of type {:?}\",\n+                callee_arg.layout.ty,\n+                caller_arg.layout.ty\n+            )\n         }\n         // We allow some transmutes here\n         self.copy_op_transmute(caller_arg, callee_arg)\n@@ -221,7 +227,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 abi => abi,\n             };\n             if normalize_abi(caller_abi) != normalize_abi(callee_abi) {\n-                throw_unsup!(FunctionAbiMismatch(caller_abi, callee_abi))\n+                throw_ub_format!(\n+                    \"calling a function with ABI {:?} using caller ABI {:?}\",\n+                    callee_abi,\n+                    caller_abi\n+                )\n             }\n         }\n \n@@ -254,107 +264,110 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // We want to pop this frame again in case there was an error, to put\n                 // the blame in the right location.  Until the 2018 edition is used in\n                 // the compiler, we have to do this with an immediately invoked function.\n-                let res =\n-                    (|| {\n-                        trace!(\n-                            \"caller ABI: {:?}, args: {:#?}\",\n-                            caller_abi,\n-                            args.iter()\n-                                .map(|arg| (arg.layout.ty, format!(\"{:?}\", **arg)))\n-                                .collect::<Vec<_>>()\n-                        );\n-                        trace!(\n-                            \"spread_arg: {:?}, locals: {:#?}\",\n-                            body.spread_arg,\n-                            body.args_iter()\n-                                .map(|local| (\n-                                    local,\n-                                    self.layout_of_local(self.frame(), local, None).unwrap().ty\n-                                ))\n-                                .collect::<Vec<_>>()\n-                        );\n-\n-                        // Figure out how to pass which arguments.\n-                        // The Rust ABI is special: ZST get skipped.\n-                        let rust_abi = match caller_abi {\n-                            Abi::Rust | Abi::RustCall => true,\n-                            _ => false,\n+                let res = (|| {\n+                    trace!(\n+                        \"caller ABI: {:?}, args: {:#?}\",\n+                        caller_abi,\n+                        args.iter()\n+                            .map(|arg| (arg.layout.ty, format!(\"{:?}\", **arg)))\n+                            .collect::<Vec<_>>()\n+                    );\n+                    trace!(\n+                        \"spread_arg: {:?}, locals: {:#?}\",\n+                        body.spread_arg,\n+                        body.args_iter()\n+                            .map(|local| (\n+                                local,\n+                                self.layout_of_local(self.frame(), local, None).unwrap().ty\n+                            ))\n+                            .collect::<Vec<_>>()\n+                    );\n+\n+                    // Figure out how to pass which arguments.\n+                    // The Rust ABI is special: ZST get skipped.\n+                    let rust_abi = match caller_abi {\n+                        Abi::Rust | Abi::RustCall => true,\n+                        _ => false,\n+                    };\n+                    // We have two iterators: Where the arguments come from,\n+                    // and where they go to.\n+\n+                    // For where they come from: If the ABI is RustCall, we untuple the\n+                    // last incoming argument.  These two iterators do not have the same type,\n+                    // so to keep the code paths uniform we accept an allocation\n+                    // (for RustCall ABI only).\n+                    let caller_args: Cow<'_, [OpTy<'tcx, M::PointerTag>]> =\n+                        if caller_abi == Abi::RustCall && !args.is_empty() {\n+                            // Untuple\n+                            let (&untuple_arg, args) = args.split_last().unwrap();\n+                            trace!(\"eval_fn_call: Will pass last argument by untupling\");\n+                            Cow::from(\n+                                args.iter()\n+                                    .map(|&a| Ok(a))\n+                                    .chain(\n+                                        (0..untuple_arg.layout.fields.count())\n+                                            .map(|i| self.operand_field(untuple_arg, i as u64)),\n+                                    )\n+                                    .collect::<InterpResult<'_, Vec<OpTy<'tcx, M::PointerTag>>>>(\n+                                    )?,\n+                            )\n+                        } else {\n+                            // Plain arg passing\n+                            Cow::from(args)\n                         };\n-                        // We have two iterators: Where the arguments come from,\n-                        // and where they go to.\n-\n-                        // For where they come from: If the ABI is RustCall, we untuple the\n-                        // last incoming argument.  These two iterators do not have the same type,\n-                        // so to keep the code paths uniform we accept an allocation\n-                        // (for RustCall ABI only).\n-                        let caller_args: Cow<'_, [OpTy<'tcx, M::PointerTag>]> =\n-                            if caller_abi == Abi::RustCall && !args.is_empty() {\n-                                // Untuple\n-                                let (&untuple_arg, args) = args.split_last().unwrap();\n-                                trace!(\"eval_fn_call: Will pass last argument by untupling\");\n-                                Cow::from(args.iter().map(|&a| Ok(a))\n-                                .chain((0..untuple_arg.layout.fields.count())\n-                                    .map(|i| self.operand_field(untuple_arg, i as u64))\n-                                )\n-                                .collect::<InterpResult<'_, Vec<OpTy<'tcx, M::PointerTag>>>>()?)\n-                            } else {\n-                                // Plain arg passing\n-                                Cow::from(args)\n-                            };\n-                        // Skip ZSTs\n-                        let mut caller_iter = caller_args\n-                            .iter()\n-                            .filter(|op| !rust_abi || !op.layout.is_zst())\n-                            .copied();\n-\n-                        // Now we have to spread them out across the callee's locals,\n-                        // taking into account the `spread_arg`.  If we could write\n-                        // this is a single iterator (that handles `spread_arg`), then\n-                        // `pass_argument` would be the loop body. It takes care to\n-                        // not advance `caller_iter` for ZSTs\n-                        for local in body.args_iter() {\n-                            let dest = self.eval_place(&mir::Place::from(local))?;\n-                            if Some(local) == body.spread_arg {\n-                                // Must be a tuple\n-                                for i in 0..dest.layout.fields.count() {\n-                                    let dest = self.place_field(dest, i as u64)?;\n-                                    self.pass_argument(rust_abi, &mut caller_iter, dest)?;\n-                                }\n-                            } else {\n-                                // Normal argument\n+                    // Skip ZSTs\n+                    let mut caller_iter =\n+                        caller_args.iter().filter(|op| !rust_abi || !op.layout.is_zst()).copied();\n+\n+                    // Now we have to spread them out across the callee's locals,\n+                    // taking into account the `spread_arg`.  If we could write\n+                    // this is a single iterator (that handles `spread_arg`), then\n+                    // `pass_argument` would be the loop body. It takes care to\n+                    // not advance `caller_iter` for ZSTs.\n+                    let mut locals_iter = body.args_iter();\n+                    while let Some(local) = locals_iter.next() {\n+                        let dest = self.eval_place(&mir::Place::from(local))?;\n+                        if Some(local) == body.spread_arg {\n+                            // Must be a tuple\n+                            for i in 0..dest.layout.fields.count() {\n+                                let dest = self.place_field(dest, i as u64)?;\n                                 self.pass_argument(rust_abi, &mut caller_iter, dest)?;\n                             }\n+                        } else {\n+                            // Normal argument\n+                            self.pass_argument(rust_abi, &mut caller_iter, dest)?;\n                         }\n-                        // Now we should have no more caller args\n-                        if caller_iter.next().is_some() {\n-                            trace!(\"Caller has passed too many args\");\n-                            throw_unsup!(FunctionArgCountMismatch)\n+                    }\n+                    // Now we should have no more caller args\n+                    if caller_iter.next().is_some() {\n+                        throw_ub_format!(\n+                            \"calling a function passing more arguments than it expected\"\n+                        )\n+                    }\n+                    // Don't forget to check the return type!\n+                    if let Some((caller_ret, _)) = ret {\n+                        let callee_ret = self.eval_place(&mir::Place::return_place())?;\n+                        if !Self::check_argument_compat(\n+                            rust_abi,\n+                            caller_ret.layout,\n+                            callee_ret.layout,\n+                        ) {\n+                            throw_ub_format!(\n+                                \"calling a function with return type {:?} passing \\\n+                                     return place of type {:?}\",\n+                                callee_ret.layout.ty,\n+                                caller_ret.layout.ty\n+                            )\n                         }\n-                        // Don't forget to check the return type!\n-                        if let Some((caller_ret, _)) = ret {\n-                            let callee_ret = self.eval_place(&mir::Place::return_place())?;\n-                            if !Self::check_argument_compat(\n-                                rust_abi,\n-                                caller_ret.layout,\n-                                callee_ret.layout,\n-                            ) {\n-                                throw_unsup!(FunctionRetMismatch(\n-                                    caller_ret.layout.ty,\n-                                    callee_ret.layout.ty\n-                                ))\n-                            }\n-                        } else {\n-                            let local = mir::RETURN_PLACE;\n-                            let callee_layout = self.layout_of_local(self.frame(), local, None)?;\n-                            if !callee_layout.abi.is_uninhabited() {\n-                                throw_unsup!(FunctionRetMismatch(\n-                                    self.tcx.types.never,\n-                                    callee_layout.ty\n-                                ))\n-                            }\n+                    } else {\n+                        let local = mir::RETURN_PLACE;\n+                        let callee_layout = self.layout_of_local(self.frame(), local, None)?;\n+                        if !callee_layout.abi.is_uninhabited() {\n+                            throw_ub_format!(\"calling a returning function without a return place\")\n                         }\n-                        Ok(())\n-                    })();\n+                    }\n+                    Ok(())\n+                })();\n                 match res {\n                     Err(err) => {\n                         self.stack.pop();"}, {"sha": "b3a09cb81ba0feb27f086a9dd89dcc4a4a7589ce", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5efb68a24b66a21b7eca055b9e8867eeaf61366/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=f5efb68a24b66a21b7eca055b9e8867eeaf61366", "patch": "@@ -29,7 +29,7 @@ macro_rules! throw_validation_failure {\n             write_path(&mut msg, where_);\n         }\n         write!(&mut msg, \", but expected {}\", $details).unwrap();\n-        throw_unsup!(ValidationFailure(msg))\n+        throw_ub!(ValidationFailure(msg))\n     }};\n     ($what:expr, $where:expr) => {{\n         let mut msg = format!(\"encountered {}\", $what);\n@@ -38,7 +38,7 @@ macro_rules! throw_validation_failure {\n             msg.push_str(\" at \");\n             write_path(&mut msg, where_);\n         }\n-        throw_unsup!(ValidationFailure(msg))\n+        throw_ub!(ValidationFailure(msg))\n     }};\n }\n \n@@ -353,10 +353,10 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                     place.ptr, size, align\n                 );\n                 match err.kind {\n-                    err_unsup!(InvalidNullPointerUsage) => {\n+                    err_ub!(InvalidNullPointerUsage) => {\n                         throw_validation_failure!(format_args!(\"a NULL {}\", kind), self.path)\n                     }\n-                    err_unsup!(AlignmentCheckFailed { required, has }) => {\n+                    err_ub!(AlignmentCheckFailed { required, has }) => {\n                         throw_validation_failure!(\n                             format_args!(\n                                 \"an unaligned {} \\\n@@ -372,7 +372,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                         format_args!(\"a dangling {} (created from integer)\", kind),\n                         self.path\n                     ),\n-                    err_unsup!(PointerOutOfBounds { .. }) | err_unsup!(DanglingPointerDeref) => {\n+                    err_ub!(PointerOutOfBounds { .. }) | err_ub!(PointerUseAfterFree(_)) => {\n                         throw_validation_failure!(\n                             format_args!(\"a dangling {} (not entirely in bounds)\", kind),\n                             self.path\n@@ -765,11 +765,11 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     Err(err) => {\n                         // For some errors we might be able to provide extra information\n                         match err.kind {\n-                            err_unsup!(ReadUndefBytes(offset)) => {\n+                            err_ub!(InvalidUndefBytes(Some(ptr))) => {\n                                 // Some byte was undefined, determine which\n                                 // element that byte belongs to so we can\n                                 // provide an index.\n-                                let i = (offset.bytes() / layout.size.bytes()) as usize;\n+                                let i = (ptr.offset.bytes() / layout.size.bytes()) as usize;\n                                 self.path.push(PathElem::ArrayElem(i));\n \n                                 throw_validation_failure!(\"undefined bytes\", self.path)\n@@ -817,7 +817,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Run it.\n         match visitor.visit_value(op) {\n             Ok(()) => Ok(()),\n-            Err(err) if matches!(err.kind, err_unsup!(ValidationFailure { .. })) => Err(err),\n+            Err(err) if matches!(err.kind, err_ub!(ValidationFailure { .. })) => Err(err),\n             Err(err) if cfg!(debug_assertions) => {\n                 bug!(\"Unexpected error during validation: {}\", err)\n             }"}]}