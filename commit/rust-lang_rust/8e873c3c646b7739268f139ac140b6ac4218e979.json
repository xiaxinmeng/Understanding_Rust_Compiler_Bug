{"sha": "8e873c3c646b7739268f139ac140b6ac4218e979", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlODczYzNjNjQ2Yjc3MzkyNjhmMTM5YWMxNDBiNmFjNDIxOGU5Nzk=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-19T13:13:31Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-26T08:25:35Z"}, "message": "Make librustc_query_system compile.", "tree": {"sha": "380929d7a6f3e53baed2588b9e6f4f53e01ac195", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/380929d7a6f3e53baed2588b9e6f4f53e01ac195"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e873c3c646b7739268f139ac140b6ac4218e979", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e873c3c646b7739268f139ac140b6ac4218e979", "html_url": "https://github.com/rust-lang/rust/commit/8e873c3c646b7739268f139ac140b6ac4218e979", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e873c3c646b7739268f139ac140b6ac4218e979/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b8dac3c39a5f5551e995e7a6f44b4ed72c4923d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b8dac3c39a5f5551e995e7a6f44b4ed72c4923d", "html_url": "https://github.com/rust-lang/rust/commit/5b8dac3c39a5f5551e995e7a6f44b4ed72c4923d"}], "stats": {"total": 842, "additions": 57, "deletions": 785}, "files": [{"sha": "6d70ab32c9d82f37a69ecb9fe3d4425196bf73f0", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8e873c3c646b7739268f139ac140b6ac4218e979/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8e873c3c646b7739268f139ac140b6ac4218e979/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8e873c3c646b7739268f139ac140b6ac4218e979", "patch": "@@ -4042,12 +4042,15 @@ version = \"0.0.0\"\n dependencies = [\n  \"log\",\n  \"parking_lot 0.9.0\",\n+ \"rustc-rayon-core\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_macros\",\n+ \"rustc_session\",\n+ \"rustc_span\",\n  \"serialize\",\n  \"smallvec 1.0.0\",\n ]"}, {"sha": "065c54bb85a8a54dfa63553aa2f6eb4a75c6c900", "filename": "src/librustc_query_system/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8e873c3c646b7739268f139ac140b6ac4218e979/src%2Flibrustc_query_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8e873c3c646b7739268f139ac140b6ac4218e979/src%2Flibrustc_query_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2FCargo.toml?ref=8e873c3c646b7739268f139ac140b6ac4218e979", "patch": "@@ -11,12 +11,15 @@ doctest = false\n \n [dependencies]\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n+rustc-rayon-core = \"0.3.0\"\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_session = { path = \"../librustc_session\" }\n+rustc_span = { path = \"../librustc_span\" }\n parking_lot = \"0.9\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "5750d8e8c3518d863e7b8d9fdd28831ffaf6cac5", "filename": "src/librustc_query_system/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e873c3c646b7739268f139ac140b6ac4218e979/src%2Flibrustc_query_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e873c3c646b7739268f139ac140b6ac4218e979/src%2Flibrustc_query_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Flib.rs?ref=8e873c3c646b7739268f139ac140b6ac4218e979", "patch": "@@ -1,14 +1,20 @@\n+#![feature(bool_to_option)]\n #![feature(const_fn)]\n #![feature(const_if_match)]\n #![feature(const_panic)]\n #![feature(core_intrinsics)]\n+#![feature(hash_raw_entry)]\n #![feature(specialization)]\n #![feature(stmt_expr_attributes)]\n+#![feature(vec_remove_item)]\n \n #[macro_use]\n extern crate log;\n+#[macro_use]\n+extern crate rustc_data_structures;\n \n pub mod dep_graph;\n+pub mod query;\n \n pub trait HashStableContext {\n     fn debug_dep_tasks(&self) -> bool;"}, {"sha": "efde51c4db6f0f7ef02ec2bd179fd58f918faf63", "filename": "src/librustc_query_system/query/caches.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e873c3c646b7739268f139ac140b6ac4218e979/src%2Flibrustc_query_system%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e873c3c646b7739268f139ac140b6ac4218e979/src%2Flibrustc_query_system%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fcaches.rs?ref=8e873c3c646b7739268f139ac140b6ac4218e979", "patch": "@@ -1,18 +1,18 @@\n use crate::dep_graph::DepNodeIndex;\n-use crate::ty::query::config::QueryContext;\n-use crate::ty::query::plumbing::{QueryLookup, QueryState, QueryStateShard};\n+use crate::query::config::QueryContext;\n+use crate::query::plumbing::{QueryLookup, QueryState, QueryStateShard};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sharded::Sharded;\n use std::default::Default;\n use std::hash::Hash;\n use std::marker::PhantomData;\n \n-pub(crate) trait CacheSelector<CTX: QueryContext, K, V> {\n+pub trait CacheSelector<CTX: QueryContext, K, V> {\n     type Cache: QueryCache<CTX, Key = K, Value = V>;\n }\n \n-pub(crate) trait QueryCache<CTX: QueryContext>: Default {\n+pub trait QueryCache<CTX: QueryContext>: Default {\n     type Key;\n     type Value;\n     type Sharded: Default;"}, {"sha": "53adcbdeea7d3be0fc17c3296b6ebc33c6013c49", "filename": "src/librustc_query_system/query/config.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8e873c3c646b7739268f139ac140b6ac4218e979/src%2Flibrustc_query_system%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e873c3c646b7739268f139ac140b6ac4218e979/src%2Flibrustc_query_system%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fconfig.rs?ref=8e873c3c646b7739268f139ac140b6ac4218e979", "patch": "@@ -1,10 +1,11 @@\n //! Query configuration and description traits.\n \n use crate::dep_graph::SerializedDepNodeIndex;\n-use crate::ty::query::caches::QueryCache;\n-use crate::ty::query::job::{QueryJobId, QueryJobInfo};\n-use crate::ty::query::plumbing::CycleError;\n-use crate::ty::query::QueryState;\n+use crate::dep_graph::{DepContext, DepGraph, DepNode};\n+use crate::query::caches::QueryCache;\n+use crate::query::job::{QueryJobId, QueryJobInfo};\n+use crate::query::plumbing::CycleError;\n+use crate::query::QueryState;\n use rustc_data_structures::profiling::ProfileCategory;\n use rustc_hir::def_id::DefId;\n \n@@ -14,7 +15,6 @@ use rustc_data_structures::stable_hasher::HashStable;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n-use rustc_query_system::dep_graph::{DepContext, DepGraph, DepNode};\n use rustc_session::Session;\n use std::borrow::Cow;\n use std::fmt::Debug;\n@@ -58,7 +58,7 @@ pub trait QueryContext: DepContext {\n     ) -> R;\n }\n \n-pub(crate) trait QueryAccessors<CTX: QueryContext>: QueryConfig<CTX> {\n+pub trait QueryAccessors<CTX: QueryContext>: QueryConfig<CTX> {\n     const ANON: bool;\n     const EVAL_ALWAYS: bool;\n     const DEP_KIND: CTX::DepKind;\n@@ -81,7 +81,7 @@ pub(crate) trait QueryAccessors<CTX: QueryContext>: QueryConfig<CTX> {\n     fn handle_cycle_error(tcx: CTX, error: CycleError<CTX::Query>) -> Self::Value;\n }\n \n-pub(crate) trait QueryDescription<CTX: QueryContext>: QueryAccessors<CTX> {\n+pub trait QueryDescription<CTX: QueryContext>: QueryAccessors<CTX> {\n     fn describe(tcx: CTX, key: Self::Key) -> Cow<'static, str>;\n \n     #[inline]\n@@ -90,7 +90,7 @@ pub(crate) trait QueryDescription<CTX: QueryContext>: QueryAccessors<CTX> {\n     }\n \n     fn try_load_from_disk(_: CTX, _: SerializedDepNodeIndex) -> Option<Self::Value> {\n-        bug!(\"QueryDescription::load_from_disk() called for an unsupported query.\")\n+        panic!(\"QueryDescription::load_from_disk() called for an unsupported query.\")\n     }\n }\n \n@@ -112,6 +112,6 @@ where\n     }\n \n     default fn try_load_from_disk(_: CTX, _: SerializedDepNodeIndex) -> Option<Self::Value> {\n-        bug!(\"QueryDescription::load_from_disk() called for an unsupported query.\")\n+        panic!(\"QueryDescription::load_from_disk() called for an unsupported query.\")\n     }\n }"}, {"sha": "9068760d323cef3e094ad6dbac4e877ab1aab4af", "filename": "src/librustc_query_system/query/job.rs", "status": "modified", "additions": 6, "deletions": 33, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8e873c3c646b7739268f139ac140b6ac4218e979/src%2Flibrustc_query_system%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e873c3c646b7739268f139ac140b6ac4218e979/src%2Flibrustc_query_system%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fjob.rs?ref=8e873c3c646b7739268f139ac140b6ac4218e979", "patch": "@@ -1,10 +1,8 @@\n-use crate::ty::query::config::QueryContext;\n-use crate::ty::query::plumbing::CycleError;\n-#[cfg(parallel_compiler)]\n-use crate::ty::tls;\n+use crate::dep_graph::{DepKind, DepContext};\n+use crate::query::config::QueryContext;\n+use crate::query::plumbing::CycleError;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_query_system::dep_graph::DepContext;\n use rustc_span::Span;\n \n use std::convert::TryFrom;\n@@ -22,7 +20,7 @@ use {\n     rustc_rayon_core as rayon_core,\n     rustc_span::DUMMY_SP,\n     std::iter::FromIterator,\n-    std::{mem, process, thread},\n+    std::{mem, process},\n };\n \n /// Represents a span and a query key.\n@@ -52,7 +50,7 @@ pub struct QueryJobId<K> {\n     pub kind: K,\n }\n \n-impl<K: rustc_query_system::dep_graph::DepKind> QueryJobId<K> {\n+impl<K: DepKind> QueryJobId<K> {\n     pub fn new(job: QueryShardJobId, shard: usize, kind: K) -> Self {\n         QueryJobId { job, shard: u16::try_from(shard).unwrap(), kind }\n     }\n@@ -529,38 +527,13 @@ fn remove_cycle<CTX: QueryContext>(\n     }\n }\n \n-/// Creates a new thread and forwards information in thread locals to it.\n-/// The new thread runs the deadlock handler.\n-/// Must only be called when a deadlock is about to happen.\n-#[cfg(parallel_compiler)]\n-pub unsafe fn handle_deadlock() {\n-    let registry = rayon_core::Registry::current();\n-\n-    let gcx_ptr = tls::GCX_PTR.with(|gcx_ptr| gcx_ptr as *const _);\n-    let gcx_ptr = &*gcx_ptr;\n-\n-    let rustc_span_globals =\n-        rustc_span::GLOBALS.with(|rustc_span_globals| rustc_span_globals as *const _);\n-    let rustc_span_globals = &*rustc_span_globals;\n-    let syntax_globals = rustc_ast::attr::GLOBALS.with(|syntax_globals| syntax_globals as *const _);\n-    let syntax_globals = &*syntax_globals;\n-    thread::spawn(move || {\n-        tls::GCX_PTR.set(gcx_ptr, || {\n-            rustc_ast::attr::GLOBALS.set(syntax_globals, || {\n-                rustc_span::GLOBALS\n-                    .set(rustc_span_globals, || tls::with_global(|tcx| deadlock(tcx, &registry)))\n-            });\n-        })\n-    });\n-}\n-\n /// Detects query cycles by using depth first search over all active query jobs.\n /// If a query cycle is found it will break the cycle by finding an edge which\n /// uses a query latch and then resuming that waiter.\n /// There may be multiple cycles involved in a deadlock, so this searches\n /// all active queries for cycles before finally resuming all the waiters at once.\n #[cfg(parallel_compiler)]\n-fn deadlock<CTX: QueryContext>(tcx: CTX, registry: &rayon_core::Registry) {\n+pub fn deadlock<CTX: QueryContext>(tcx: CTX, registry: &rayon_core::Registry) {\n     let on_panic = OnDrop(|| {\n         eprintln!(\"deadlock handler panicked, aborting process\");\n         process::abort();"}, {"sha": "0b8ad5c16a59333fd8e11e7b951de39282b683ed", "filename": "src/librustc_query_system/query/mod.rs", "status": "modified", "additions": 5, "deletions": 187, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/8e873c3c646b7739268f139ac140b6ac4218e979/src%2Flibrustc_query_system%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e873c3c646b7739268f139ac140b6ac4218e979/src%2Flibrustc_query_system%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fmod.rs?ref=8e873c3c646b7739268f139ac140b6ac4218e979", "patch": "@@ -1,195 +1,13 @@\n-use crate::dep_graph::{self, DepConstructor, DepNode, DepNodeParams};\n-use crate::hir::exports::Export;\n-use crate::hir::map;\n-use crate::infer::canonical::{self, Canonical};\n-use crate::lint::LintLevelMap;\n-use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n-use crate::middle::cstore::{CrateSource, DepKind, NativeLibraryKind};\n-use crate::middle::cstore::{ExternCrate, ForeignModule, LinkagePreference, NativeLibrary};\n-use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n-use crate::middle::lang_items::{LangItem, LanguageItems};\n-use crate::middle::lib_features::LibFeatures;\n-use crate::middle::privacy::AccessLevels;\n-use crate::middle::region;\n-use crate::middle::resolve_lifetime::{ObjectLifetimeDefault, Region, ResolveLifetimes};\n-use crate::middle::stability::{self, DeprecationEntry};\n-use crate::mir;\n-use crate::mir::interpret::GlobalId;\n-use crate::mir::interpret::{ConstEvalRawResult, ConstEvalResult, ConstValue};\n-use crate::mir::interpret::{LitToConstError, LitToConstInput};\n-use crate::mir::mono::CodegenUnit;\n-use crate::traits::query::{\n-    CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n-    CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,\n-    CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal, NoSolution,\n-};\n-use crate::traits::query::{\n-    DropckOutlivesResult, DtorckConstraint, MethodAutoderefStepsResult, NormalizationResult,\n-    OutlivesBound,\n-};\n-use crate::traits::specialization_graph;\n-use crate::traits::Clauses;\n-use crate::traits::{self, Vtable};\n-use crate::ty::steal::Steal;\n-use crate::ty::subst::{GenericArg, SubstsRef};\n-use crate::ty::util::AlwaysRequiresDrop;\n-use crate::ty::{self, AdtSizedConstraint, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n-use crate::util::common::ErrorReported;\n-use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n-use rustc_data_structures::profiling::ProfileCategory::*;\n-use rustc_data_structures::stable_hasher::StableVec;\n-use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::Lrc;\n-use rustc_hir as hir;\n-use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId};\n-use rustc_hir::{Crate, HirIdSet, ItemLocalId, TraitCandidate};\n-use rustc_index::vec::IndexVec;\n-use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n-use rustc_session::CrateDisambiguator;\n-use rustc_target::spec::PanicStrategy;\n-\n-use rustc_ast::ast;\n-use rustc_attr as attr;\n-use rustc_span::symbol::Symbol;\n-use rustc_span::{Span, DUMMY_SP};\n-use std::borrow::Cow;\n-use std::collections::BTreeMap;\n-use std::ops::Deref;\n-use std::sync::Arc;\n-\n-#[macro_use]\n mod plumbing;\n-pub(crate) use self::plumbing::CycleError;\n-use self::plumbing::*;\n-\n-mod stats;\n-pub use self::stats::print_stats;\n+pub use self::plumbing::*;\n \n mod job;\n+pub use self::job::{QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n #[cfg(parallel_compiler)]\n-pub use self::job::handle_deadlock;\n-use self::job::QueryJobInfo;\n-pub use self::job::{QueryInfo, QueryJob, QueryJobId};\n-\n-mod keys;\n-use self::keys::Key;\n-\n-mod values;\n-use self::values::Value;\n+pub use self::job::deadlock;\n \n mod caches;\n-use self::caches::CacheSelector;\n+pub use self::caches::{CacheSelector, DefaultCacheSelector, QueryCache};\n \n mod config;\n-use self::config::QueryAccessors;\n-pub use self::config::QueryConfig;\n-pub(crate) use self::config::QueryDescription;\n-\n-mod on_disk_cache;\n-pub use self::on_disk_cache::OnDiskCache;\n-\n-mod profiling_support;\n-pub use self::profiling_support::{IntoSelfProfilingString, QueryKeyStringBuilder};\n-\n-// Each of these queries corresponds to a function pointer field in the\n-// `Providers` struct for requesting a value of that type, and a method\n-// on `tcx: TyCtxt` (and `tcx.at(span)`) for doing that request in a way\n-// which memoizes and does dep-graph tracking, wrapping around the actual\n-// `Providers` that the driver creates (using several `rustc_*` crates).\n-//\n-// The result type of each query must implement `Clone`, and additionally\n-// `ty::query::values::Value`, which produces an appropriate placeholder\n-// (error) value if the query resulted in a query cycle.\n-// Queries marked with `fatal_cycle` do not need the latter implementation,\n-// as they will raise an fatal error on query cycles instead.\n-\n-rustc_query_append! { [define_queries!][<'tcx>] }\n-\n-/// The red/green evaluation system will try to mark a specific DepNode in the\n-/// dependency graph as green by recursively trying to mark the dependencies of\n-/// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n-/// where we don't know if it is red or green and we therefore actually have\n-/// to recompute its value in order to find out. Since the only piece of\n-/// information that we have at that point is the `DepNode` we are trying to\n-/// re-evaluate, we need some way to re-run a query from just that. This is what\n-/// `force_from_dep_node()` implements.\n-///\n-/// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n-/// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n-/// is usually constructed by computing a stable hash of the query-key that the\n-/// `DepNode` corresponds to. Consequently, it is not in general possible to go\n-/// back from hash to query-key (since hash functions are not reversible). For\n-/// this reason `force_from_dep_node()` is expected to fail from time to time\n-/// because we just cannot find out, from the `DepNode` alone, what the\n-/// corresponding query-key is and therefore cannot re-run the query.\n-///\n-/// The system deals with this case letting `try_mark_green` fail which forces\n-/// the root query to be re-evaluated.\n-///\n-/// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n-/// Fortunately, we can use some contextual information that will allow us to\n-/// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n-/// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n-/// valid `DefPathHash`. Since we also always build a huge table that maps every\n-/// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n-/// everything we need to re-run the query.\n-///\n-/// Take the `mir_validated` query as an example. Like many other queries, it\n-/// just has a single parameter: the `DefId` of the item it will compute the\n-/// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n-/// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n-/// is actually a `DefPathHash`, and can therefore just look up the corresponding\n-/// `DefId` in `tcx.def_path_hash_to_def_id`.\n-///\n-/// When you implement a new query, it will likely have a corresponding new\n-/// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n-/// a rule of thumb, if your query takes a `DefId` or `LocalDefId` as sole parameter,\n-/// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n-/// add it to the \"We don't have enough information to reconstruct...\" group in\n-/// the match below.\n-pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool {\n-    // We must avoid ever having to call `force_from_dep_node()` for a\n-    // `DepNode::codegen_unit`:\n-    // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n-    // would always end up having to evaluate the first caller of the\n-    // `codegen_unit` query that *is* reconstructible. This might very well be\n-    // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n-    // to re-trigger calling the `codegen_unit` query with the right key. At\n-    // that point we would already have re-done all the work we are trying to\n-    // avoid doing in the first place.\n-    // The solution is simple: Just explicitly call the `codegen_unit` query for\n-    // each CGU, right after partitioning. This way `try_mark_green` will always\n-    // hit the cache instead of having to go through `force_from_dep_node`.\n-    // This assertion makes sure, we actually keep applying the solution above.\n-    debug_assert!(\n-        dep_node.kind != crate::dep_graph::DepKind::codegen_unit,\n-        \"calling force_from_dep_node() on DepKind::codegen_unit\"\n-    );\n-\n-    if !dep_node.kind.can_reconstruct_query_key() {\n-        return false;\n-    }\n-\n-    rustc_dep_node_force!([dep_node, tcx]\n-        // These are inputs that are expected to be pre-allocated and that\n-        // should therefore always be red or green already.\n-        crate::dep_graph::DepKind::CrateMetadata |\n-\n-        // These are anonymous nodes.\n-        crate::dep_graph::DepKind::TraitSelect |\n-\n-        // We don't have enough information to reconstruct the query key of\n-        // these.\n-        crate::dep_graph::DepKind::CompileCodegenUnit => {\n-            bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n-        }\n-    );\n-\n-    false\n-}\n-\n-pub(crate) fn try_load_from_on_disk_cache<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) {\n-    rustc_dep_node_try_load_from_on_disk_cache!(dep_node, tcx)\n-}\n+pub use self::config::{QueryAccessors, QueryConfig, QueryContext, QueryDescription};"}, {"sha": "0bae613fcfbea400ae1ee9f46ef864863d309868", "filename": "src/librustc_query_system/query/plumbing.rs", "status": "modified", "additions": 21, "deletions": 552, "changes": 573, "blob_url": "https://github.com/rust-lang/rust/blob/8e873c3c646b7739268f139ac140b6ac4218e979/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e873c3c646b7739268f139ac140b6ac4218e979/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs?ref=8e873c3c646b7739268f139ac140b6ac4218e979", "patch": "@@ -2,25 +2,21 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n+use crate::dep_graph::{DepKind, DepContext, DepNode};\n use crate::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n-use crate::ty::query::caches::QueryCache;\n-use crate::ty::query::config::{QueryContext, QueryDescription};\n-use crate::ty::query::job::{QueryInfo, QueryJob, QueryJobId, QueryJobInfo, QueryShardJobId};\n-use crate::ty::query::Query;\n-use crate::ty::tls::{self, ImplicitCtxt};\n-use crate::ty::{self, TyCtxt};\n+use crate::query::caches::QueryCache;\n+use crate::query::config::{QueryContext, QueryDescription};\n+use crate::query::job::{QueryInfo, QueryJob, QueryJobId, QueryJobInfo, QueryShardJobId};\n+use crate::HashStableContextProvider;\n \n #[cfg(not(parallel_compiler))]\n use rustc_data_structures::cold_path;\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHasher};\n use rustc_data_structures::sharded::Sharded;\n use rustc_data_structures::sync::{Lock, LockGuard};\n use rustc_data_structures::thin_vec::ThinVec;\n-use rustc_errors::{struct_span_err, Diagnostic, DiagnosticBuilder, FatalError, Handler, Level};\n-use rustc_query_system::dep_graph::{DepContext, DepGraph, DepKind, DepNode};\n-use rustc_query_system::HashStableContextProvider;\n-use rustc_session::Session;\n-use rustc_span::def_id::DefId;\n+use rustc_errors::{Diagnostic, FatalError};\n use rustc_span::source_map::DUMMY_SP;\n use rustc_span::Span;\n use std::collections::hash_map::Entry;\n@@ -33,7 +29,7 @@ use std::ptr;\n #[cfg(debug_assertions)]\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n-pub(crate) struct QueryStateShard<CTX: QueryContext, K, C> {\n+pub struct QueryStateShard<CTX: QueryContext, K, C> {\n     cache: C,\n     active: FxHashMap<K, QueryResult<CTX>>,\n \n@@ -53,15 +49,15 @@ impl<CTX: QueryContext, K, C: Default> Default for QueryStateShard<CTX, K, C> {\n     }\n }\n \n-pub(crate) struct QueryState<CTX: QueryContext, C: QueryCache<CTX>> {\n+pub struct QueryState<CTX: QueryContext, C: QueryCache<CTX>> {\n     cache: C,\n     shards: Sharded<QueryStateShard<CTX, C::Key, C::Sharded>>,\n     #[cfg(debug_assertions)]\n-    pub(super) cache_hits: AtomicUsize,\n+    pub cache_hits: AtomicUsize,\n }\n \n impl<CTX: QueryContext, C: QueryCache<CTX>> QueryState<CTX, C> {\n-    pub(super) fn get_lookup<K2: Hash>(\n+    pub(super) fn get_lookup<'tcx, K2: Hash>(\n         &'tcx self,\n         key: &K2,\n     ) -> QueryLookup<'tcx, CTX, C::Key, C::Sharded> {\n@@ -89,20 +85,21 @@ enum QueryResult<CTX: QueryContext> {\n }\n \n impl<CTX: QueryContext, C: QueryCache<CTX>> QueryState<CTX, C> {\n-    pub(super) fn iter_results<R>(\n+    pub fn iter_results<R>(\n         &self,\n         f: impl for<'a> FnOnce(\n             Box<dyn Iterator<Item = (&'a C::Key, &'a C::Value, DepNodeIndex)> + 'a>,\n         ) -> R,\n     ) -> R {\n         self.cache.iter(&self.shards, |shard| &mut shard.cache, f)\n     }\n-    pub(super) fn all_inactive(&self) -> bool {\n+\n+    pub fn all_inactive(&self) -> bool {\n         let shards = self.shards.lock_shards();\n         shards.iter().all(|shard| shard.active.is_empty())\n     }\n \n-    pub(super) fn try_collect_active_jobs(\n+    pub fn try_collect_active_jobs(\n         &self,\n         kind: CTX::DepKind,\n         make_query: fn(C::Key) -> CTX::Query,\n@@ -144,7 +141,7 @@ impl<CTX: QueryContext, C: QueryCache<CTX>> Default for QueryState<CTX, C> {\n }\n \n /// Values used when checking a query cache which can be reused on a cache-miss to execute the query.\n-pub(crate) struct QueryLookup<'tcx, CTX: QueryContext, K, C> {\n+pub struct QueryLookup<'tcx, CTX: QueryContext, K, C> {\n     pub(super) key_hash: u64,\n     shard: usize,\n     pub(super) lock: LockGuard<'tcx, QueryStateShard<CTX, K, C>>,\n@@ -329,10 +326,10 @@ where\n }\n \n #[derive(Clone)]\n-pub(crate) struct CycleError<Q> {\n+pub struct CycleError<Q> {\n     /// The query and related span that uses the cycle.\n-    pub(super) usage: Option<(Span, Q)>,\n-    pub(super) cycle: Vec<QueryInfo<Q>>,\n+    pub usage: Option<(Span, Q)>,\n+    pub cycle: Vec<QueryInfo<Q>>,\n }\n \n /// The result of `try_start`.\n@@ -354,152 +351,6 @@ where\n     Cycle(C::Value),\n }\n \n-impl QueryContext for TyCtxt<'tcx> {\n-    type Query = Query<'tcx>;\n-\n-    fn session(&self) -> &Session {\n-        &self.sess\n-    }\n-\n-    fn def_path_str(&self, def_id: DefId) -> String {\n-        TyCtxt::def_path_str(*self, def_id)\n-    }\n-\n-    fn dep_graph(&self) -> &DepGraph<Self::DepKind> {\n-        &self.dep_graph\n-    }\n-\n-    fn read_query_job<R>(&self, op: impl FnOnce(Option<QueryJobId<Self::DepKind>>) -> R) -> R {\n-        tls::with_related_context(*self, move |icx| op(icx.query))\n-    }\n-\n-    fn try_collect_active_jobs(\n-        &self,\n-    ) -> Option<FxHashMap<QueryJobId<Self::DepKind>, QueryJobInfo<Self>>> {\n-        self.queries.try_collect_active_jobs()\n-    }\n-\n-    /// Executes a job by changing the `ImplicitCtxt` to point to the\n-    /// new query job while it executes. It returns the diagnostics\n-    /// captured during execution and the actual result.\n-    #[inline(always)]\n-    fn start_query<R>(\n-        &self,\n-        token: QueryJobId<Self::DepKind>,\n-        diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n-        compute: impl FnOnce(Self) -> R,\n-    ) -> R {\n-        // The `TyCtxt` stored in TLS has the same global interner lifetime\n-        // as `self`, so we use `with_related_context` to relate the 'tcx lifetimes\n-        // when accessing the `ImplicitCtxt`.\n-        tls::with_related_context(*self, move |current_icx| {\n-            // Update the `ImplicitCtxt` to point to our new query job.\n-            let new_icx = ImplicitCtxt {\n-                tcx: *self,\n-                query: Some(token),\n-                diagnostics,\n-                layout_depth: current_icx.layout_depth,\n-                task_deps: current_icx.task_deps,\n-            };\n-\n-            // Use the `ImplicitCtxt` while we execute the query.\n-            tls::enter_context(&new_icx, |_| compute(*self))\n-        })\n-    }\n-}\n-\n-impl<'tcx> TyCtxt<'tcx> {\n-    #[inline(never)]\n-    #[cold]\n-    pub(super) fn report_cycle(\n-        self,\n-        CycleError { usage, cycle: stack }: CycleError<Query<'tcx>>,\n-    ) -> DiagnosticBuilder<'tcx> {\n-        assert!(!stack.is_empty());\n-\n-        let fix_span = |span: Span, query: &Query<'tcx>| {\n-            self.sess.source_map().guess_head_span(query.default_span(self, span))\n-        };\n-\n-        // Disable naming impls with types in this path, since that\n-        // sometimes cycles itself, leading to extra cycle errors.\n-        // (And cycle errors around impls tend to occur during the\n-        // collect/coherence phases anyhow.)\n-        ty::print::with_forced_impl_filename_line(|| {\n-            let span = fix_span(stack[1 % stack.len()].span, &stack[0].query);\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                span,\n-                E0391,\n-                \"cycle detected when {}\",\n-                stack[0].query.describe(self)\n-            );\n-\n-            for i in 1..stack.len() {\n-                let query = &stack[i].query;\n-                let span = fix_span(stack[(i + 1) % stack.len()].span, query);\n-                err.span_note(span, &format!(\"...which requires {}...\", query.describe(self)));\n-            }\n-\n-            err.note(&format!(\n-                \"...which again requires {}, completing the cycle\",\n-                stack[0].query.describe(self)\n-            ));\n-\n-            if let Some((span, query)) = usage {\n-                err.span_note(\n-                    fix_span(span, &query),\n-                    &format!(\"cycle used when {}\", query.describe(self)),\n-                );\n-            }\n-\n-            err\n-        })\n-    }\n-\n-    pub fn try_print_query_stack(handler: &Handler) {\n-        eprintln!(\"query stack during panic:\");\n-\n-        // Be careful reyling on global state here: this code is called from\n-        // a panic hook, which means that the global `Handler` may be in a weird\n-        // state if it was responsible for triggering the panic.\n-        tls::with_context_opt(|icx| {\n-            if let Some(icx) = icx {\n-                let query_map = icx.tcx.queries.try_collect_active_jobs();\n-\n-                let mut current_query = icx.query;\n-                let mut i = 0;\n-\n-                while let Some(query) = current_query {\n-                    let query_info =\n-                        if let Some(info) = query_map.as_ref().and_then(|map| map.get(&query)) {\n-                            info\n-                        } else {\n-                            break;\n-                        };\n-                    let mut diag = Diagnostic::new(\n-                        Level::FailureNote,\n-                        &format!(\n-                            \"#{} [{}] {}\",\n-                            i,\n-                            query_info.info.query.name(),\n-                            query_info.info.query.describe(icx.tcx)\n-                        ),\n-                    );\n-                    diag.span =\n-                        icx.tcx.sess.source_map().guess_head_span(query_info.info.span).into();\n-                    handler.force_print_diagnostic(diag);\n-\n-                    current_query = query_info.job.parent;\n-                    i += 1;\n-                }\n-            }\n-        });\n-\n-        eprintln!(\"end of query stack\");\n-    }\n-}\n-\n     /// Checks if the query is already computed and in the cache.\n     /// It returns the shard index and a lock guard to the shard,\n     /// which will be used if the query is not in the cache and we need\n@@ -697,8 +548,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         CTX: QueryContext,\n         Q: QueryDescription<CTX>,\n     {\n-        use rustc_data_structures::fingerprint::Fingerprint;\n-\n         assert!(\n             Some(tcx.dep_graph().fingerprint_of(dep_node_index))\n                 == tcx.dep_graph().prev_fingerprint_of(dep_node),\n@@ -721,7 +570,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     fn force_query_with_job<Q, CTX, K>(\n         tcx: CTX,\n         key: Q::Key,\n-        job: JobOwner<'tcx, CTX, Q::Cache>,\n+        job: JobOwner<'_, CTX, Q::Cache>,\n         dep_node: DepNode<CTX::DepKind>,\n     ) -> (Q::Value, DepNodeIndex)\n     where\n@@ -775,7 +624,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         (result, dep_node_index)\n     }\n \n-pub(super) trait QueryGetter: QueryContext {\n+pub trait QueryGetter: QueryContext {\n     fn get_query<Q: QueryDescription<Self>>(\n         self,\n         span: Span,\n@@ -887,383 +736,3 @@ where\n         );\n     }\n }\n-\n-macro_rules! handle_cycle_error {\n-    ([][$tcx: expr, $error:expr]) => {{\n-        $tcx.report_cycle($error).emit();\n-        Value::from_cycle_error($tcx)\n-    }};\n-    ([fatal_cycle $($rest:tt)*][$tcx:expr, $error:expr]) => {{\n-        $tcx.report_cycle($error).emit();\n-        $tcx.sess.abort_if_errors();\n-        unreachable!()\n-    }};\n-    ([cycle_delay_bug $($rest:tt)*][$tcx:expr, $error:expr]) => {{\n-        $tcx.report_cycle($error).delay_as_bug();\n-        Value::from_cycle_error($tcx)\n-    }};\n-    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*][$($args:tt)*]) => {\n-        handle_cycle_error!([$($($modifiers)*)*][$($args)*])\n-    };\n-}\n-\n-macro_rules! is_anon {\n-    ([]) => {{\n-        false\n-    }};\n-    ([anon $($rest:tt)*]) => {{\n-        true\n-    }};\n-    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*]) => {\n-        is_anon!([$($($modifiers)*)*])\n-    };\n-}\n-\n-macro_rules! is_eval_always {\n-    ([]) => {{\n-        false\n-    }};\n-    ([eval_always $($rest:tt)*]) => {{\n-        true\n-    }};\n-    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*]) => {\n-        is_eval_always!([$($($modifiers)*)*])\n-    };\n-}\n-\n-macro_rules! query_storage {\n-    (<$tcx:tt>[][$K:ty, $V:ty]) => {\n-        <<$K as Key>::CacheSelector as CacheSelector<TyCtxt<$tcx>, $K, $V>>::Cache\n-    };\n-    (<$tcx:tt>[storage($ty:ty) $($rest:tt)*][$K:ty, $V:ty]) => {\n-        $ty\n-    };\n-    (<$tcx:tt>[$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*][$($args:tt)*]) => {\n-        query_storage!(<$tcx>[$($($modifiers)*)*][$($args)*])\n-    };\n-}\n-\n-macro_rules! hash_result {\n-    ([][$hcx:expr, $result:expr]) => {{\n-        dep_graph::hash_result($hcx, &$result)\n-    }};\n-    ([no_hash $($rest:tt)*][$hcx:expr, $result:expr]) => {{\n-        None\n-    }};\n-    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*][$($args:tt)*]) => {\n-        hash_result!([$($($modifiers)*)*][$($args)*])\n-    };\n-}\n-\n-macro_rules! define_queries {\n-    (<$tcx:tt> $($category:tt {\n-        $($(#[$attr:meta])* [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*\n-    },)*) => {\n-        define_queries_inner! { <$tcx>\n-            $($( $(#[$attr])* category<$category> [$($modifiers)*] fn $name: $node($K) -> $V,)*)*\n-        }\n-    }\n-}\n-\n-macro_rules! define_queries_inner {\n-    (<$tcx:tt>\n-     $($(#[$attr:meta])* category<$category:tt>\n-        [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n-\n-        use std::mem;\n-        use crate::{\n-            rustc_data_structures::stable_hasher::HashStable,\n-            rustc_data_structures::stable_hasher::StableHasher,\n-            ich::StableHashingContext\n-        };\n-        use rustc_data_structures::profiling::ProfileCategory;\n-\n-        define_queries_struct! {\n-            tcx: $tcx,\n-            input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n-        }\n-\n-        #[allow(nonstandard_style)]\n-        #[derive(Clone, Debug)]\n-        pub enum Query<$tcx> {\n-            $($(#[$attr])* $name($K)),*\n-        }\n-\n-        impl<$tcx> Query<$tcx> {\n-            pub fn name(&self) -> &'static str {\n-                match *self {\n-                    $(Query::$name(_) => stringify!($name),)*\n-                }\n-            }\n-\n-            pub fn describe(&self, tcx: TyCtxt<$tcx>) -> Cow<'static, str> {\n-                let (r, name) = match *self {\n-                    $(Query::$name(key) => {\n-                        (queries::$name::describe(tcx, key), stringify!($name))\n-                    })*\n-                };\n-                if tcx.sess.verbose() {\n-                    format!(\"{} [{}]\", r, name).into()\n-                } else {\n-                    r\n-                }\n-            }\n-\n-            // FIXME(eddyb) Get more valid `Span`s on queries.\n-            pub fn default_span(&self, tcx: TyCtxt<$tcx>, span: Span) -> Span {\n-                if !span.is_dummy() {\n-                    return span;\n-                }\n-                // The `def_span` query is used to calculate `default_span`,\n-                // so exit to avoid infinite recursion.\n-                if let Query::def_span(..) = *self {\n-                    return span\n-                }\n-                match *self {\n-                    $(Query::$name(key) => key.default_span(tcx),)*\n-                }\n-            }\n-        }\n-\n-        impl<'a, $tcx> HashStable<StableHashingContext<'a>> for Query<$tcx> {\n-            fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-                mem::discriminant(self).hash_stable(hcx, hasher);\n-                match *self {\n-                    $(Query::$name(key) => key.hash_stable(hcx, hasher),)*\n-                }\n-            }\n-        }\n-\n-        pub mod queries {\n-            use std::marker::PhantomData;\n-\n-            $(#[allow(nonstandard_style)]\n-            pub struct $name<$tcx> {\n-                data: PhantomData<&$tcx ()>\n-            })*\n-        }\n-\n-        $(impl<$tcx> QueryConfig<TyCtxt<$tcx>> for queries::$name<$tcx> {\n-            type Key = $K;\n-            type Value = $V;\n-            const NAME: &'static str = stringify!($name);\n-            const CATEGORY: ProfileCategory = $category;\n-        }\n-\n-        impl<$tcx> QueryAccessors<TyCtxt<$tcx>> for queries::$name<$tcx> {\n-            const ANON: bool = is_anon!([$($modifiers)*]);\n-            const EVAL_ALWAYS: bool = is_eval_always!([$($modifiers)*]);\n-            const DEP_KIND: dep_graph::DepKind = dep_graph::DepKind::$node;\n-\n-            type Cache = query_storage!(<$tcx>[$($modifiers)*][$K, $V]);\n-\n-            #[inline(always)]\n-            fn query_state<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryState<TyCtxt<$tcx>, Self::Cache> {\n-                &tcx.queries.$name\n-            }\n-\n-            #[allow(unused)]\n-            #[inline(always)]\n-            fn to_dep_node(tcx: TyCtxt<$tcx>, key: &Self::Key) -> DepNode {\n-                DepConstructor::$node(tcx, *key)\n-            }\n-\n-            #[inline]\n-            fn compute(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n-                let provider = tcx.queries.providers.get(key.query_crate())\n-                    // HACK(eddyb) it's possible crates may be loaded after\n-                    // the query engine is created, and because crate loading\n-                    // is not yet integrated with the query engine, such crates\n-                    // would be missing appropriate entries in `providers`.\n-                    .unwrap_or(&tcx.queries.fallback_extern_providers)\n-                    .$name;\n-                provider(tcx, key)\n-            }\n-\n-            fn hash_result(\n-                _hcx: &mut StableHashingContext<'_>,\n-                _result: &Self::Value\n-            ) -> Option<Fingerprint> {\n-                hash_result!([$($modifiers)*][_hcx, _result])\n-            }\n-\n-            fn handle_cycle_error(\n-                tcx: TyCtxt<'tcx>,\n-                error: CycleError<Query<'tcx>>\n-            ) -> Self::Value {\n-                handle_cycle_error!([$($modifiers)*][tcx, error])\n-            }\n-        })*\n-\n-        #[derive(Copy, Clone)]\n-        pub struct TyCtxtEnsure<'tcx> {\n-            pub tcx: TyCtxt<'tcx>,\n-        }\n-\n-        impl TyCtxtEnsure<$tcx> {\n-            $($(#[$attr])*\n-            #[inline(always)]\n-            pub fn $name(self, key: $K) {\n-                self.tcx.ensure_query::<queries::$name<'_>>(key)\n-            })*\n-        }\n-\n-        #[derive(Copy, Clone)]\n-        pub struct TyCtxtAt<'tcx> {\n-            pub tcx: TyCtxt<'tcx>,\n-            pub span: Span,\n-        }\n-\n-        impl Deref for TyCtxtAt<'tcx> {\n-            type Target = TyCtxt<'tcx>;\n-            #[inline(always)]\n-            fn deref(&self) -> &Self::Target {\n-                &self.tcx\n-            }\n-        }\n-\n-        impl TyCtxt<$tcx> {\n-            /// Returns a transparent wrapper for `TyCtxt`, which ensures queries\n-            /// are executed instead of just returning their results.\n-            #[inline(always)]\n-            pub fn ensure(self) -> TyCtxtEnsure<$tcx> {\n-                TyCtxtEnsure {\n-                    tcx: self,\n-                }\n-            }\n-\n-            /// Returns a transparent wrapper for `TyCtxt` which uses\n-            /// `span` as the location of queries performed through it.\n-            #[inline(always)]\n-            pub fn at(self, span: Span) -> TyCtxtAt<$tcx> {\n-                TyCtxtAt {\n-                    tcx: self,\n-                    span\n-                }\n-            }\n-\n-            $($(#[$attr])*\n-            #[inline(always)]\n-            pub fn $name(self, key: $K) -> $V {\n-                self.at(DUMMY_SP).$name(key)\n-            })*\n-\n-            /// All self-profiling events generated by the query engine use\n-            /// virtual `StringId`s for their `event_id`. This method makes all\n-            /// those virtual `StringId`s point to actual strings.\n-            ///\n-            /// If we are recording only summary data, the ids will point to\n-            /// just the query names. If we are recording query keys too, we\n-            /// allocate the corresponding strings here.\n-            pub fn alloc_self_profile_query_strings(self) {\n-                use crate::ty::query::profiling_support::{\n-                    alloc_self_profile_query_strings_for_query_cache,\n-                    QueryKeyStringCache,\n-                };\n-\n-                if !self.prof.enabled() {\n-                    return;\n-                }\n-\n-                let mut string_cache = QueryKeyStringCache::new();\n-\n-                $({\n-                    alloc_self_profile_query_strings_for_query_cache(\n-                        self,\n-                        stringify!($name),\n-                        &self.queries.$name,\n-                        &mut string_cache,\n-                    );\n-                })*\n-            }\n-        }\n-\n-        impl TyCtxtAt<$tcx> {\n-            $($(#[$attr])*\n-            #[inline(always)]\n-            pub fn $name(self, key: $K) -> $V {\n-                self.tcx.get_query::<queries::$name<'_>>(self.span, key)\n-            })*\n-        }\n-\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            input: ($(([$($modifiers)*] [$name] [$K] [$V]))*)\n-        }\n-\n-        impl<$tcx> Copy for Providers<$tcx> {}\n-        impl<$tcx> Clone for Providers<$tcx> {\n-            fn clone(&self) -> Self { *self }\n-        }\n-    }\n-}\n-\n-macro_rules! define_queries_struct {\n-    (tcx: $tcx:tt,\n-     input: ($(([$($modifiers:tt)*] [$($attr:tt)*] [$name:ident]))*)) => {\n-        pub struct Queries<$tcx> {\n-            /// This provides access to the incrimental comilation on-disk cache for query results.\n-            /// Do not access this directly. It is only meant to be used by\n-            /// `DepGraph::try_mark_green()` and the query infrastructure.\n-            pub(crate) on_disk_cache: OnDiskCache<'tcx>,\n-\n-            providers: IndexVec<CrateNum, Providers<$tcx>>,\n-            fallback_extern_providers: Box<Providers<$tcx>>,\n-\n-            $($(#[$attr])*  $name: QueryState<\n-                TyCtxt<$tcx>,\n-                <queries::$name<$tcx> as QueryAccessors<TyCtxt<'tcx>>>::Cache,\n-            >,)*\n-        }\n-\n-        impl<$tcx> Queries<$tcx> {\n-            pub(crate) fn new(\n-                providers: IndexVec<CrateNum, Providers<$tcx>>,\n-                fallback_extern_providers: Providers<$tcx>,\n-                on_disk_cache: OnDiskCache<'tcx>,\n-            ) -> Self {\n-                Queries {\n-                    providers,\n-                    fallback_extern_providers: Box::new(fallback_extern_providers),\n-                    on_disk_cache,\n-                    $($name: Default::default()),*\n-                }\n-            }\n-\n-            pub(crate) fn try_collect_active_jobs(\n-                &self\n-            ) -> Option<FxHashMap<QueryJobId<crate::dep_graph::DepKind>, QueryJobInfo<TyCtxt<'tcx>>>> {\n-                let mut jobs = FxHashMap::default();\n-\n-                $(\n-                    self.$name.try_collect_active_jobs(\n-                        <queries::$name<'tcx> as QueryAccessors<TyCtxt<'tcx>>>::DEP_KIND,\n-                        Query::$name,\n-                        &mut jobs,\n-                    )?;\n-                )*\n-\n-                Some(jobs)\n-            }\n-        }\n-    };\n-}\n-\n-macro_rules! define_provider_struct {\n-    (tcx: $tcx:tt,\n-     input: ($(([$($modifiers:tt)*] [$name:ident] [$K:ty] [$R:ty]))*)) => {\n-        pub struct Providers<$tcx> {\n-            $(pub $name: fn(TyCtxt<$tcx>, $K) -> $R,)*\n-        }\n-\n-        impl<$tcx> Default for Providers<$tcx> {\n-            fn default() -> Self {\n-                $(fn $name<$tcx>(_: TyCtxt<$tcx>, key: $K) -> $R {\n-                    bug!(\"`tcx.{}({:?})` unsupported by its crate\",\n-                         stringify!($name), key);\n-                })*\n-                Providers { $($name),* }\n-            }\n-        }\n-    };\n-}"}]}