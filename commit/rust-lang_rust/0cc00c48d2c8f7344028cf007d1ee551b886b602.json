{"sha": "0cc00c48d2c8f7344028cf007d1ee551b886b602", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjYzAwYzQ4ZDJjOGY3MzQ0MDI4Y2YwMDdkMWVlNTUxYjg4NmI2MDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-16T16:36:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-16T16:36:46Z"}, "message": "Auto merge of #83416 - alexcrichton:const-thread-local, r=sfackler\n\nstd: Add a variant of thread locals with const init\n\nThis commit adds a variant of the `thread_local!` macro as a new\n`thread_local_const_init!` macro which requires that the initialization\nexpression is constant (e.g. could be stuck into a `const` if so\ndesired). This form of thread local allows for a more efficient\nimplementation of `LocalKey::with` both if the value has a destructor\nand if it doesn't. If the value doesn't have a destructor then `with`\nshould desugar to exactly as-if you use `#[thread_local]` given\nsufficient inlining.\n\nThe purpose of this new form of thread locals is to precisely be\nequivalent to `#[thread_local]` on platforms where possible for values\nwhich fit the bill (those without destructors). This should help close\nthe gap in performance between `thread_local!`, which is safe, relative\nto `#[thread_local]`, which is not easy to use in a portable fashion.", "tree": {"sha": "3cc34021312b1737f3ac1fb268a9e09dad757093", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cc34021312b1737f3ac1fb268a9e09dad757093"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cc00c48d2c8f7344028cf007d1ee551b886b602", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cc00c48d2c8f7344028cf007d1ee551b886b602", "html_url": "https://github.com/rust-lang/rust/commit/0cc00c48d2c8f7344028cf007d1ee551b886b602", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cc00c48d2c8f7344028cf007d1ee551b886b602/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2faef12b656d40522ca3b4a53b36299b4364e717", "url": "https://api.github.com/repos/rust-lang/rust/commits/2faef12b656d40522ca3b4a53b36299b4364e717", "html_url": "https://github.com/rust-lang/rust/commit/2faef12b656d40522ca3b4a53b36299b4364e717"}, {"sha": "c6eea222a9cafeeeedfa1767232328710b350447", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6eea222a9cafeeeedfa1767232328710b350447", "html_url": "https://github.com/rust-lang/rust/commit/c6eea222a9cafeeeedfa1767232328710b350447"}], "stats": {"total": 293, "additions": 244, "deletions": 49}, "files": [{"sha": "84f74ef94072764eb2d8d9bb2bac1ff21c805eeb", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0cc00c48d2c8f7344028cf007d1ee551b886b602/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cc00c48d2c8f7344028cf007d1ee551b886b602/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=0cc00c48d2c8f7344028cf007d1ee551b886b602", "patch": "@@ -208,7 +208,10 @@\n // std may use features in a platform-specific way\n #![allow(unused_features)]\n #![feature(rustc_allow_const_fn_unstable)]\n-#![cfg_attr(test, feature(internal_output_capture, print_internals, update_panic_count))]\n+#![cfg_attr(\n+    test,\n+    feature(internal_output_capture, print_internals, update_panic_count, thread_local_const_init)\n+)]\n #![cfg_attr(\n     all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n     feature(slice_index_methods, coerce_unsized, sgx_platform)"}, {"sha": "37525e50604ddee3321d71713d54ec0fd3e0dafd", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 115, "deletions": 2, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/0cc00c48d2c8f7344028cf007d1ee551b886b602/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cc00c48d2c8f7344028cf007d1ee551b886b602/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=0cc00c48d2c8f7344028cf007d1ee551b886b602", "patch": "@@ -133,6 +133,15 @@ macro_rules! thread_local {\n     // empty (base case for the recursion)\n     () => {};\n \n+    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = const { $init:expr }; $($rest:tt)*) => (\n+        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, const $init);\n+        $crate::thread_local!($($rest)*);\n+    );\n+\n+    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = const { $init:expr }) => (\n+        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, const $init);\n+    );\n+\n     // process multiple declarations\n     ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr; $($rest:tt)*) => (\n         $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, $init);\n@@ -151,6 +160,101 @@ macro_rules! thread_local {\n #[allow_internal_unstable(thread_local_internals, cfg_target_thread_local, thread_local)]\n #[allow_internal_unsafe]\n macro_rules! __thread_local_inner {\n+    // used to generate the `LocalKey` value for const-initialized thread locals\n+    (@key $t:ty, const $init:expr) => {{\n+        unsafe fn __getit() -> $crate::option::Option<&'static $t> {\n+            const _REQUIRE_UNSTABLE: () = $crate::thread::require_unstable_const_init_thread_local();\n+\n+            // wasm without atomics maps directly to `static mut`, and dtors\n+            // aren't implemented because thread dtors aren't really a thing\n+            // on wasm right now\n+            //\n+            // FIXME(#84224) this should come after the `target_thread_local`\n+            // block.\n+            #[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\n+            {\n+                static mut VAL: $t = $init;\n+                Some(&VAL)\n+            }\n+\n+            // If the platform has support for `#[thread_local]`, use it.\n+            #[cfg(all(\n+                target_thread_local,\n+                not(all(target_arch = \"wasm32\", not(target_feature = \"atomics\"))),\n+            ))]\n+            {\n+                // If a dtor isn't needed we can do something \"very raw\" and\n+                // just get going.\n+                if !$crate::mem::needs_drop::<$t>() {\n+                    #[thread_local]\n+                    static mut VAL: $t = $init;\n+                    unsafe {\n+                        return Some(&VAL)\n+                    }\n+                }\n+\n+                #[thread_local]\n+                static mut VAL: $t = $init;\n+                // 0 == dtor not registered\n+                // 1 == dtor registered, dtor not run\n+                // 2 == dtor registered and is running or has run\n+                #[thread_local]\n+                static mut STATE: u8 = 0;\n+\n+                unsafe extern \"C\" fn destroy(ptr: *mut u8) {\n+                    let ptr = ptr as *mut $t;\n+\n+                    unsafe {\n+                        debug_assert_eq!(STATE, 1);\n+                        STATE = 2;\n+                        $crate::ptr::drop_in_place(ptr);\n+                    }\n+                }\n+\n+                unsafe {\n+                    match STATE {\n+                        // 0 == we haven't registered a destructor, so do\n+                        //   so now.\n+                        0 => {\n+                            $crate::thread::__FastLocalKeyInner::<$t>::register_dtor(\n+                                &VAL as *const _ as *mut u8,\n+                                destroy,\n+                            );\n+                            STATE = 1;\n+                            Some(&VAL)\n+                        }\n+                        // 1 == the destructor is registered and the value\n+                        //   is valid, so return the pointer.\n+                        1 => Some(&VAL),\n+                        // otherwise the destructor has already run, so we\n+                        // can't give access.\n+                        _ => None,\n+                    }\n+                }\n+            }\n+\n+            // On platforms without `#[thread_local]` we fall back to the\n+            // same implementation as below for os thread locals.\n+            #[cfg(all(\n+                not(target_thread_local),\n+                not(all(target_arch = \"wasm32\", not(target_feature = \"atomics\"))),\n+            ))]\n+            {\n+                #[inline]\n+                const fn __init() -> $t { $init }\n+                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n+                    $crate::thread::__OsLocalKeyInner::new();\n+                #[allow(unused_unsafe)]\n+                unsafe { __KEY.get(__init) }\n+            }\n+        }\n+\n+        unsafe {\n+            $crate::thread::LocalKey::new(__getit)\n+        }\n+    }};\n+\n+    // used to generate the `LocalKey` value for `thread_local!`\n     (@key $t:ty, $init:expr) => {\n         {\n             #[inline]\n@@ -188,9 +292,9 @@ macro_rules! __thread_local_inner {\n             }\n         }\n     };\n-    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $init:expr) => {\n+    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n         $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n-            $crate::__thread_local_inner!(@key $t, $init);\n+            $crate::__thread_local_inner!(@key $t, $($init)*);\n     }\n }\n \n@@ -442,6 +546,15 @@ pub mod fast {\n             Key { inner: LazyKeyInner::new(), dtor_state: Cell::new(DtorState::Unregistered) }\n         }\n \n+        // note that this is just a publically-callable function only for the\n+        // const-initialized form of thread locals, basically a way to call the\n+        // free `register_dtor` function defined elsewhere in libstd.\n+        pub unsafe fn register_dtor(a: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n+            unsafe {\n+                register_dtor(a, dtor);\n+            }\n+        }\n+\n         pub unsafe fn get<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n             // SAFETY: See the definitions of `LazyKeyInner::get` and\n             // `try_initialize` for more informations."}, {"sha": "80e6798d847b1d2faed5b2bbbb1493357d60e835", "filename": "library/std/src/thread/local/tests.rs", "status": "modified", "additions": 101, "deletions": 46, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/0cc00c48d2c8f7344028cf007d1ee551b886b602/library%2Fstd%2Fsrc%2Fthread%2Flocal%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cc00c48d2c8f7344028cf007d1ee551b886b602/library%2Fstd%2Fsrc%2Fthread%2Flocal%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal%2Ftests.rs?ref=0cc00c48d2c8f7344028cf007d1ee551b886b602", "patch": "@@ -1,6 +1,6 @@\n use crate::cell::{Cell, UnsafeCell};\n use crate::sync::mpsc::{channel, Sender};\n-use crate::thread;\n+use crate::thread::{self, LocalKey};\n use crate::thread_local;\n \n struct Foo(Sender<()>);\n@@ -15,74 +15,90 @@ impl Drop for Foo {\n #[test]\n fn smoke_no_dtor() {\n     thread_local!(static FOO: Cell<i32> = Cell::new(1));\n+    run(&FOO);\n+    thread_local!(static FOO2: Cell<i32> = const { Cell::new(1) });\n+    run(&FOO2);\n \n-    FOO.with(|f| {\n-        assert_eq!(f.get(), 1);\n-        f.set(2);\n-    });\n-    let (tx, rx) = channel();\n-    let _t = thread::spawn(move || {\n-        FOO.with(|f| {\n+    fn run(key: &'static LocalKey<Cell<i32>>) {\n+        key.with(|f| {\n             assert_eq!(f.get(), 1);\n+            f.set(2);\n         });\n-        tx.send(()).unwrap();\n-    });\n-    rx.recv().unwrap();\n+        let t = thread::spawn(move || {\n+            key.with(|f| {\n+                assert_eq!(f.get(), 1);\n+            });\n+        });\n+        t.join().unwrap();\n \n-    FOO.with(|f| {\n-        assert_eq!(f.get(), 2);\n-    });\n+        key.with(|f| {\n+            assert_eq!(f.get(), 2);\n+        });\n+    }\n }\n \n #[test]\n fn states() {\n-    struct Foo;\n+    struct Foo(&'static LocalKey<Foo>);\n     impl Drop for Foo {\n         fn drop(&mut self) {\n-            assert!(FOO.try_with(|_| ()).is_err());\n+            assert!(self.0.try_with(|_| ()).is_err());\n         }\n     }\n-    thread_local!(static FOO: Foo = Foo);\n \n-    thread::spawn(|| {\n-        assert!(FOO.try_with(|_| ()).is_ok());\n-    })\n-    .join()\n-    .ok()\n-    .expect(\"thread panicked\");\n+    thread_local!(static FOO: Foo = Foo(&FOO));\n+    run(&FOO);\n+    thread_local!(static FOO2: Foo = const { Foo(&FOO2) });\n+    run(&FOO2);\n+\n+    fn run(foo: &'static LocalKey<Foo>) {\n+        thread::spawn(move || {\n+            assert!(foo.try_with(|_| ()).is_ok());\n+        })\n+        .join()\n+        .unwrap();\n+    }\n }\n \n #[test]\n fn smoke_dtor() {\n     thread_local!(static FOO: UnsafeCell<Option<Foo>> = UnsafeCell::new(None));\n-\n-    let (tx, rx) = channel();\n-    let _t = thread::spawn(move || unsafe {\n-        let mut tx = Some(tx);\n-        FOO.with(|f| {\n-            *f.get() = Some(Foo(tx.take().unwrap()));\n+    run(&FOO);\n+    thread_local!(static FOO2: UnsafeCell<Option<Foo>> = const { UnsafeCell::new(None) });\n+    run(&FOO2);\n+\n+    fn run(key: &'static LocalKey<UnsafeCell<Option<Foo>>>) {\n+        let (tx, rx) = channel();\n+        let t = thread::spawn(move || unsafe {\n+            let mut tx = Some(tx);\n+            key.with(|f| {\n+                *f.get() = Some(Foo(tx.take().unwrap()));\n+            });\n         });\n-    });\n-    rx.recv().unwrap();\n+        rx.recv().unwrap();\n+        t.join().unwrap();\n+    }\n }\n \n #[test]\n fn circular() {\n-    struct S1;\n-    struct S2;\n+    struct S1(&'static LocalKey<UnsafeCell<Option<S1>>>, &'static LocalKey<UnsafeCell<Option<S2>>>);\n+    struct S2(&'static LocalKey<UnsafeCell<Option<S1>>>, &'static LocalKey<UnsafeCell<Option<S2>>>);\n     thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n     thread_local!(static K2: UnsafeCell<Option<S2>> = UnsafeCell::new(None));\n-    static mut HITS: u32 = 0;\n+    thread_local!(static K3: UnsafeCell<Option<S1>> = const { UnsafeCell::new(None) });\n+    thread_local!(static K4: UnsafeCell<Option<S2>> = const { UnsafeCell::new(None) });\n+    static mut HITS: usize = 0;\n \n     impl Drop for S1 {\n         fn drop(&mut self) {\n             unsafe {\n                 HITS += 1;\n-                if K2.try_with(|_| ()).is_err() {\n+                if self.1.try_with(|_| ()).is_err() {\n                     assert_eq!(HITS, 3);\n                 } else {\n                     if HITS == 1 {\n-                        K2.with(|s| *s.get() = Some(S2));\n+                        self.1.with(|s| *s.get() = Some(S2(self.0, self.1)));\n                     } else {\n                         assert_eq!(HITS, 3);\n                     }\n@@ -94,38 +110,54 @@ fn circular() {\n         fn drop(&mut self) {\n             unsafe {\n                 HITS += 1;\n-                assert!(K1.try_with(|_| ()).is_ok());\n+                assert!(self.0.try_with(|_| ()).is_ok());\n                 assert_eq!(HITS, 2);\n-                K1.with(|s| *s.get() = Some(S1));\n+                self.0.with(|s| *s.get() = Some(S1(self.0, self.1)));\n             }\n         }\n     }\n \n     thread::spawn(move || {\n-        drop(S1);\n+        drop(S1(&K1, &K2));\n+    })\n+    .join()\n+    .unwrap();\n+\n+    unsafe {\n+        HITS = 0;\n+    }\n+\n+    thread::spawn(move || {\n+        drop(S1(&K3, &K4));\n     })\n     .join()\n-    .ok()\n-    .expect(\"thread panicked\");\n+    .unwrap();\n }\n \n #[test]\n fn self_referential() {\n-    struct S1;\n+    struct S1(&'static LocalKey<UnsafeCell<Option<S1>>>);\n+\n     thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n+    thread_local!(static K2: UnsafeCell<Option<S1>> = const { UnsafeCell::new(None) });\n \n     impl Drop for S1 {\n         fn drop(&mut self) {\n-            assert!(K1.try_with(|_| ()).is_err());\n+            assert!(self.0.try_with(|_| ()).is_err());\n         }\n     }\n \n     thread::spawn(move || unsafe {\n-        K1.with(|s| *s.get() = Some(S1));\n+        K1.with(|s| *s.get() = Some(S1(&K1)));\n     })\n     .join()\n-    .ok()\n-    .expect(\"thread panicked\");\n+    .unwrap();\n+\n+    thread::spawn(move || unsafe {\n+        K2.with(|s| *s.get() = Some(S1(&K2)));\n+    })\n+    .join()\n+    .unwrap();\n }\n \n // Note that this test will deadlock if TLS destructors aren't run (this\n@@ -152,3 +184,26 @@ fn dtors_in_dtors_in_dtors() {\n     });\n     rx.recv().unwrap();\n }\n+\n+#[test]\n+fn dtors_in_dtors_in_dtors_const_init() {\n+    struct S1(Sender<()>);\n+    thread_local!(static K1: UnsafeCell<Option<S1>> = const { UnsafeCell::new(None) });\n+    thread_local!(static K2: UnsafeCell<Option<Foo>> = const { UnsafeCell::new(None) });\n+\n+    impl Drop for S1 {\n+        fn drop(&mut self) {\n+            let S1(ref tx) = *self;\n+            unsafe {\n+                let _ = K2.try_with(|s| *s.get() = Some(Foo(tx.clone())));\n+            }\n+        }\n+    }\n+\n+    let (tx, rx) = channel();\n+    let _t = thread::spawn(move || unsafe {\n+        let mut tx = Some(tx);\n+        K1.with(|s| *s.get() = Some(S1(tx.take().unwrap())));\n+    });\n+    rx.recv().unwrap();\n+}"}, {"sha": "54e39f762741f0cd3fcd9faef4d7d69edc5531d3", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0cc00c48d2c8f7344028cf007d1ee551b886b602/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cc00c48d2c8f7344028cf007d1ee551b886b602/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=0cc00c48d2c8f7344028cf007d1ee551b886b602", "patch": "@@ -204,6 +204,13 @@ pub use self::local::os::Key as __OsLocalKeyInner;\n #[doc(hidden)]\n pub use self::local::statik::Key as __StaticLocalKeyInner;\n \n+// This is only used to make thread locals with `const { .. }` initialization\n+// expressions unstable. If and/or when that syntax is stabilized with thread\n+// locals this will simply be removed.\n+#[doc(hidden)]\n+#[unstable(feature = \"thread_local_const_init\", issue = \"84223\")]\n+pub const fn require_unstable_const_init_thread_local() {}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Builder\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "6584ffa7cf949f91833cdf9e69b55a851bd8ba74", "filename": "src/test/ui/feature-gates/thread-local-const-init.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cc00c48d2c8f7344028cf007d1ee551b886b602/src%2Ftest%2Fui%2Ffeature-gates%2Fthread-local-const-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cc00c48d2c8f7344028cf007d1ee551b886b602/src%2Ftest%2Fui%2Ffeature-gates%2Fthread-local-const-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fthread-local-const-init.rs?ref=0cc00c48d2c8f7344028cf007d1ee551b886b602", "patch": "@@ -0,0 +1,4 @@\n+thread_local!(static X: u32 = const { 0 });\n+//~^ ERROR: use of unstable library feature 'thread_local_const_init'\n+\n+fn main() {}"}, {"sha": "a35b18a9c290b89ac1490536dcf2aaeb9c405418", "filename": "src/test/ui/feature-gates/thread-local-const-init.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0cc00c48d2c8f7344028cf007d1ee551b886b602/src%2Ftest%2Fui%2Ffeature-gates%2Fthread-local-const-init.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0cc00c48d2c8f7344028cf007d1ee551b886b602/src%2Ftest%2Fui%2Ffeature-gates%2Fthread-local-const-init.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fthread-local-const-init.stderr?ref=0cc00c48d2c8f7344028cf007d1ee551b886b602", "patch": "@@ -0,0 +1,13 @@\n+error[E0658]: use of unstable library feature 'thread_local_const_init'\n+  --> $DIR/thread-local-const-init.rs:1:1\n+   |\n+LL | thread_local!(static X: u32 = const { 0 });\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #84223 <https://github.com/rust-lang/rust/issues/84223> for more information\n+   = help: add `#![feature(thread_local_const_init)]` to the crate attributes to enable\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}]}