{"sha": "326711e9bdee2e8f467ad716109b5a270b61478d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNjcxMWU5YmRlZTJlOGY0NjdhZDcxNjEwOWI1YTI3MGI2MTQ3OGQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-31T03:51:21Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-24T12:14:16Z"}, "message": "rustc_resolve: use DefAssociatedTy for TyQPath.", "tree": {"sha": "6fce6c90a09fffaff1f5de5b9f4a773e8f81a16e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fce6c90a09fffaff1f5de5b9f4a773e8f81a16e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/326711e9bdee2e8f467ad716109b5a270b61478d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/326711e9bdee2e8f467ad716109b5a270b61478d", "html_url": "https://github.com/rust-lang/rust/commit/326711e9bdee2e8f467ad716109b5a270b61478d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/326711e9bdee2e8f467ad716109b5a270b61478d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a69378e8b61473fbfa55f347286718ca4c5d399", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a69378e8b61473fbfa55f347286718ca4c5d399", "html_url": "https://github.com/rust-lang/rust/commit/9a69378e8b61473fbfa55f347286718ca4c5d399"}], "stats": {"total": 179, "additions": 95, "deletions": 84}, "files": [{"sha": "914663e75814e059bd2436a30954442f38537c50", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/326711e9bdee2e8f467ad716109b5a270b61478d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/326711e9bdee2e8f467ad716109b5a270b61478d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=326711e9bdee2e8f467ad716109b5a270b61478d", "patch": "@@ -3563,8 +3563,24 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match ty.node {\n             // Like path expressions, the interpretation of path types depends\n             // on whether the path has multiple elements in it or not.\n+            TyPath(_) | TyQPath(_) => {\n+                let mut path_from_qpath;\n+                let path = match ty.node {\n+                    TyPath(ref path) => path,\n+                    TyQPath(ref qpath) => {\n+                        self.resolve_type(&*qpath.self_type);\n+\n+                        // Just make sure the trait is valid, don't record a def.\n+                        self.resolve_trait_reference(ty.id, &qpath.trait_path, TraitQPath);\n+                        self.def_map.borrow_mut().remove(&ty.id);\n+\n+                        path_from_qpath = qpath.trait_path.clone();\n+                        path_from_qpath.segments.push(qpath.item_path.clone());\n+                        &path_from_qpath\n+                    }\n+                    _ => unreachable!()\n+                };\n \n-            TyPath(ref path) => {\n                 // This is a path in the type namespace. Walk through scopes\n                 // looking for it.\n                 let mut result_def = None;\n@@ -3609,7 +3625,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         self.record_def(ty.id, def);\n                     }\n                     None => {\n-                        let msg = format!(\"use of undeclared type name `{}`\",\n+                        let kind = match ty.node {\n+                            TyQPath(_) => \"associated type\",\n+                            _ => \"type name\"\n+                        };\n+                        let msg = format!(\"use of undeclared {} `{}`\", kind,\n                                           self.path_names_to_string(path));\n                         self.resolve_error(ty.span, &msg[..]);\n                     }\n@@ -3621,17 +3641,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 self.resolve_type_parameter_bounds(bound_vec, TraitBoundingTypeParameter);\n             }\n \n-            TyQPath(ref qpath) => {\n-                self.resolve_type(&*qpath.self_type);\n-                self.resolve_trait_reference(ty.id, &qpath.trait_path, TraitQPath);\n-                for ty in qpath.item_path.parameters.types() {\n-                    self.resolve_type(&**ty);\n-                }\n-                for binding in qpath.item_path.parameters.bindings() {\n-                    self.resolve_type(&*binding.ty);\n-                }\n-            }\n-\n             TyPolyTraitRef(ref bounds) => {\n                 self.resolve_type_parameter_bounds(bounds, TraitObject);\n                 visit::walk_ty(self, ty);"}, {"sha": "cf567f709f52a6f7dd0515336759b880f87c162c", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 63, "deletions": 50, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/326711e9bdee2e8f467ad716109b5a270b61478d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/326711e9bdee2e8f467ad716109b5a270b61478d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=326711e9bdee2e8f467ad716109b5a270b61478d", "patch": "@@ -606,9 +606,10 @@ pub fn instantiate_trait_ref<'tcx>(\n         def::DefTrait(trait_def_id) => {\n             let trait_ref = ast_path_to_trait_ref(this,\n                                                   rscope,\n+                                                  path.span,\n                                                   trait_def_id,\n                                                   self_ty,\n-                                                  path,\n+                                                  path.segments.last().unwrap(),\n                                                   projections);\n             if let Some(id) = impl_id {\n                 this.tcx().impl_trait_refs.borrow_mut().insert(id, trait_ref.clone());\n@@ -637,9 +638,10 @@ fn object_path_to_poly_trait_ref<'a,'tcx>(\n     let mut tmp = Vec::new();\n     let trait_ref = ty::Binder(ast_path_to_trait_ref(this,\n                                                      &shifted_rscope,\n+                                                     path.span,\n                                                      trait_def_id,\n                                                      None,\n-                                                     path,\n+                                                     path.segments.last().unwrap(),\n                                                      Some(&mut tmp)));\n     projections.extend(tmp.into_iter().map(ty::Binder));\n     trait_ref\n@@ -648,24 +650,25 @@ fn object_path_to_poly_trait_ref<'a,'tcx>(\n fn ast_path_to_trait_ref<'a,'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n+    span: Span,\n     trait_def_id: ast::DefId,\n     self_ty: Option<Ty<'tcx>>,\n-    path: &ast::Path,\n+    trait_segment: &ast::PathSegment,\n     mut projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n     -> Rc<ty::TraitRef<'tcx>>\n {\n-    debug!(\"ast_path_to_trait_ref {:?}\", path);\n+    debug!(\"ast_path_to_trait_ref {:?}\", trait_segment);\n     let trait_def = this.get_trait_def(trait_def_id);\n \n-    let (regions, types, assoc_bindings) = match path.segments.last().unwrap().parameters {\n+    let (regions, types, assoc_bindings) = match trait_segment.parameters {\n         ast::AngleBracketedParameters(ref data) => {\n             // For now, require that parenthetical notation be used\n             // only with `Fn()` etc.\n             if !this.tcx().sess.features.borrow().unboxed_closures && trait_def.paren_sugar {\n-                span_err!(this.tcx().sess, path.span, E0215,\n+                span_err!(this.tcx().sess, span, E0215,\n                                          \"angle-bracket notation is not stable when \\\n                                          used with the `Fn` family of traits, use parentheses\");\n-                span_help!(this.tcx().sess, path.span,\n+                span_help!(this.tcx().sess, span,\n                            \"add `#![feature(unboxed_closures)]` to \\\n                             the crate attributes to enable\");\n             }\n@@ -676,10 +679,10 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n             // For now, require that parenthetical notation be used\n             // only with `Fn()` etc.\n             if !this.tcx().sess.features.borrow().unboxed_closures && !trait_def.paren_sugar {\n-                span_err!(this.tcx().sess, path.span, E0216,\n+                span_err!(this.tcx().sess, span, E0216,\n                                          \"parenthetical notation is only stable when \\\n                                          used with the `Fn` family of traits\");\n-                span_help!(this.tcx().sess, path.span,\n+                span_help!(this.tcx().sess, span,\n                            \"add `#![feature(unboxed_closures)]` to \\\n                             the crate attributes to enable\");\n             }\n@@ -689,7 +692,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n     };\n \n     let substs = create_substs_for_ast_path(this,\n-                                            path.span,\n+                                            span,\n                                             &trait_def.generics,\n                                             self_ty,\n                                             types,\n@@ -1047,33 +1050,42 @@ fn trait_defines_associated_type_named(this: &AstConv,\n \n fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n                      rscope: &RegionScope,\n-                     ast_ty: &ast::Ty, // the TyQPath\n-                     qpath: &ast::QPath)\n+                     span: Span,\n+                     opt_self_ty: Option<&ast::Ty>,\n+                     trait_def_id: ast::DefId,\n+                     trait_segment: &ast::PathSegment,\n+                     item_segment: &ast::PathSegment)\n                      -> Ty<'tcx>\n {\n-    debug!(\"qpath_to_ty(ast_ty={})\",\n-           ast_ty.repr(this.tcx()));\n+    let tcx = this.tcx();\n \n-    let self_type = ast_ty_to_ty(this, rscope, &*qpath.self_type);\n+    let self_ty = if let Some(ty) = opt_self_ty {\n+        ast_ty_to_ty(this, rscope, ty)\n+    } else {\n+        let path_str = ty::item_path_str(tcx, trait_def_id);\n+        span_err!(tcx.sess, span, E0223,\n+                  \"ambiguous associated type; specify the type using the syntax \\\n+                   `<Type as {}>::{}`\",\n+                   path_str, &token::get_ident(item_segment.identifier));\n+        return tcx.types.err;\n+    };\n \n-    debug!(\"qpath_to_ty: self_type={}\", self_type.repr(this.tcx()));\n+    debug!(\"qpath_to_ty: self_type={}\", self_ty.repr(tcx));\n \n-    let trait_ref = instantiate_trait_ref(this,\n+    let trait_ref = ast_path_to_trait_ref(this,\n                                           rscope,\n-                                          &qpath.trait_path,\n-                                          ast_ty.id,\n-                                          None,\n-                                          Some(self_type),\n+                                          span,\n+                                          trait_def_id,\n+                                          Some(self_ty),\n+                                          trait_segment,\n                                           None);\n \n-    debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr(this.tcx()));\n+    debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr(tcx));\n \n     // `<T as Trait>::U<V>` shouldn't parse right now.\n-    assert!(qpath.item_path.parameters.is_empty());\n+    assert!(item_segment.parameters.is_empty());\n \n-    return this.projected_ty(ast_ty.span,\n-                             trait_ref,\n-                             qpath.item_path.identifier.name);\n+    this.projected_ty(span, trait_ref, item_segment.identifier.name)\n }\n \n /// Convert a type supplied as value for a type argument from AST into our\n@@ -1189,13 +1201,17 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n             ast::TyPolyTraitRef(ref bounds) => {\n                 conv_ty_poly_trait_ref(this, rscope, ast_ty.span, &bounds[..])\n             }\n-            ast::TyPath(ref path) => {\n+            ast::TyPath(_) | ast::TyQPath(_) => {\n+                let simple_path = |&:| match ast_ty.node {\n+                    ast::TyPath(ref path) => path,\n+                    _ => tcx.sess.span_bug(ast_ty.span, \"expected non-qualified path\")\n+                };\n                 let a_def = match tcx.def_map.borrow().get(&ast_ty.id) {\n                     None => {\n                         tcx.sess\n                            .span_bug(ast_ty.span,\n                                      &format!(\"unbound path {}\",\n-                                             path.repr(tcx)))\n+                                             ast_ty.repr(tcx)))\n                     }\n                     Some(&d) => d\n                 };\n@@ -1208,24 +1224,24 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                         let trait_ref = object_path_to_poly_trait_ref(this,\n                                                                       rscope,\n                                                                       trait_def_id,\n-                                                                      path,\n+                                                                      simple_path(),\n                                                                       &mut projection_bounds);\n \n-                        trait_ref_to_object_type(this, rscope, path.span,\n+                        trait_ref_to_object_type(this, rscope, ast_ty.span,\n                                                  trait_ref, projection_bounds, &[])\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n-                        ast_path_to_ty(this, rscope, did, path).ty\n+                        ast_path_to_ty(this, rscope, did, simple_path()).ty\n                     }\n                     def::DefTyParam(space, index, _, name) => {\n-                        check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                        check_path_args(tcx, simple_path(), NO_TPS | NO_REGIONS);\n                         ty::mk_param(tcx, space, index, name)\n                     }\n                     def::DefSelfTy(_) => {\n                         // n.b.: resolve guarantees that the this type only appears in a\n                         // trait, which we rely upon in various places when creating\n                         // substs\n-                        check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                        check_path_args(tcx, simple_path(), NO_TPS | NO_REGIONS);\n                         ty::mk_self_type(tcx)\n                     }\n                     def::DefMod(id) => {\n@@ -1236,20 +1252,20 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                     def::DefPrimTy(_) => {\n                         panic!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n                     }\n-                    def::DefAssociatedTy(trait_id, _) => {\n-                        let path_str = ty::item_path_str(tcx, trait_id);\n-                        span_err!(tcx.sess, ast_ty.span, E0223,\n-                                          \"ambiguous associated \\\n-                                                   type; specify the type \\\n-                                                   using the syntax `<Type \\\n-                                                   as {}>::{}`\",\n-                                                  path_str,\n-                                                  &token::get_ident(\n-                                                      path.segments\n-                                                          .last()\n-                                                          .unwrap()\n-                                                          .identifier));\n-                        this.tcx().types.err\n+                    def::DefAssociatedTy(trait_did, _) => {\n+                        let (opt_self_ty, trait_segment, item_segment) = match ast_ty.node {\n+                            ast::TyQPath(ref qpath) => {\n+                                (Some(&*qpath.self_type), qpath.trait_path.segments.last().unwrap(),\n+                                 &qpath.item_path)\n+                            }\n+                            ast::TyPath(ref path) => {\n+                                (None, &path.segments[path.segments.len()-2],\n+                                 path.segments.last().unwrap())\n+                            }\n+                            _ => unreachable!()\n+                        };\n+                        qpath_to_ty(this, rscope, ast_ty.span, opt_self_ty,\n+                                    trait_did, trait_segment, item_segment)\n                     }\n                     def::DefAssociatedPath(provenance, assoc_ident) => {\n                         associated_path_def_to_ty(this, ast_ty, provenance, assoc_ident.name)\n@@ -1262,9 +1278,6 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                     }\n                 }\n             }\n-            ast::TyQPath(ref qpath) => {\n-                qpath_to_ty(this, rscope, ast_ty, &**qpath)\n-            }\n             ast::TyFixedLengthVec(ref ty, ref e) => {\n                 match const_eval::eval_const_expr_partial(tcx, &**e, Some(tcx.types.uint)) {\n                     Ok(ref r) => {"}, {"sha": "aff15761ae7755081b9f7f7c67ccfc3c7cc5c532", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/326711e9bdee2e8f467ad716109b5a270b61478d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/326711e9bdee2e8f467ad716109b5a270b61478d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=326711e9bdee2e8f467ad716109b5a270b61478d", "patch": "@@ -1499,6 +1499,13 @@ impl Clean<Type> for ast::Ty {\n             TyPath(ref p) => {\n                 resolve_type(cx, p.clean(cx), self.id)\n             }\n+            TyQPath(ref qp) => {\n+                Type::QPath {\n+                    name: qp.item_path.identifier.clean(cx),\n+                    self_type: box qp.self_type.clean(cx),\n+                    trait_: box resolve_type(cx, qp.trait_path.clean(cx), self.id)\n+                }\n+            }\n             TyObjectSum(ref lhs, ref bounds) => {\n                 let lhs_ty = lhs.clean(cx);\n                 match lhs_ty {\n@@ -1512,7 +1519,6 @@ impl Clean<Type> for ast::Ty {\n             }\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n             TyParen(ref ty) => ty.clean(cx),\n-            TyQPath(ref qp) => qp.clean(cx),\n             TyPolyTraitRef(ref bounds) => {\n                 PolyTraitRef(bounds.clean(cx))\n             },\n@@ -1624,16 +1630,6 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n     }\n }\n \n-impl Clean<Type> for ast::QPath {\n-    fn clean(&self, cx: &DocContext) -> Type {\n-        Type::QPath {\n-            name: self.item_path.identifier.clean(cx),\n-            self_type: box self.self_type.clean(cx),\n-            trait_: box resolve_type(cx, self.trait_path.clean(cx), 0)\n-        }\n-    }\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum StructField {\n     HiddenStructField, // inserted later by strip passes"}, {"sha": "c6ff82364b3e7cd57c279b9e4772aab1d386c51f", "filename": "src/test/compile-fail/issue-19883.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/326711e9bdee2e8f467ad716109b5a270b61478d/src%2Ftest%2Fcompile-fail%2Fissue-19883.rs", "raw_url": "https://github.com/rust-lang/rust/raw/326711e9bdee2e8f467ad716109b5a270b61478d/src%2Ftest%2Fcompile-fail%2Fissue-19883.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19883.rs?ref=326711e9bdee2e8f467ad716109b5a270b61478d", "patch": "@@ -15,18 +15,11 @@ trait From<Src> {\n }\n \n trait To {\n-    // This is a typo, the return type should be `<Dst as From<Self>>::Output`\n-    fn to<Dst: From<Self>>(\n-        self\n-        //~^ error: the trait `core::marker::Sized` is not implemented\n-    ) ->\n+    fn to<Dst: From<Self>>(self) ->\n         <Dst as From<Self>>::Dst\n-        //~^ error: the trait `core::marker::Sized` is not implemented\n+        //~^ ERROR use of undeclared associated type `From::Dst`\n     {\n-        From::from(\n-            //~^ error: the trait `core::marker::Sized` is not implemented\n-            self\n-        )\n+        From::from(self)\n     }\n }\n "}]}