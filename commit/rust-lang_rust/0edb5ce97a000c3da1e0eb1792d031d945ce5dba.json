{"sha": "0edb5ce97a000c3da1e0eb1792d031d945ce5dba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlZGI1Y2U5N2EwMDBjM2RhMWUwZWIxNzkyZDAzMWQ5NDVjZTVkYmE=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-14T23:43:35Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-17T01:31:52Z"}, "message": "Bug fix and add more comments", "tree": {"sha": "9f770b9a871e341a6f3f330abc7165c0324f356d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f770b9a871e341a6f3f330abc7165c0324f356d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0edb5ce97a000c3da1e0eb1792d031d945ce5dba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0edb5ce97a000c3da1e0eb1792d031d945ce5dba", "html_url": "https://github.com/rust-lang/rust/commit/0edb5ce97a000c3da1e0eb1792d031d945ce5dba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0edb5ce97a000c3da1e0eb1792d031d945ce5dba/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "180655077a4d582d49d4aa14bed67b382f336cf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/180655077a4d582d49d4aa14bed67b382f336cf0", "html_url": "https://github.com/rust-lang/rust/commit/180655077a4d582d49d4aa14bed67b382f336cf0"}], "stats": {"total": 82, "additions": 60, "deletions": 22}, "files": [{"sha": "a3c4f1886d9840d3591e040824e0e4c142dcb64e", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 60, "deletions": 22, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/0edb5ce97a000c3da1e0eb1792d031d945ce5dba/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0edb5ce97a000c3da1e0eb1792d031d945ce5dba/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=0edb5ce97a000c3da1e0eb1792d031d945ce5dba", "patch": "@@ -469,16 +469,34 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     let typable: Option<TypableDef> = def.into();\n                     let typable = typable?;\n \n+                    // For example, this substs will take `Gen::make::*<u32>*`\n                     let mut substs =\n                         Ty::substs_from_path_segment(self.db, &self.resolver, segment, typable);\n \n                     if remaining_index > 0 {\n-                        substs = Ty::substs_from_path_segment(\n+                        // For example, this substs will take `Gen::*<u32>*::make`\n+                        let parent_substs = Ty::substs_from_path_segment(\n                             self.db,\n                             &self.resolver,\n                             &path.segments[remaining_index - 1],\n                             typable,\n                         );\n+\n+                        // merge parent and child substs\n+                        let max_len = std::cmp::max(substs.len(), parent_substs.len());\n+                        let mut merged = vec![];\n+                        for i in 0..max_len {\n+                            let s = match (substs.0.get(i), parent_substs.0.get(i)) {\n+                                (Some(s @ Ty::Apply(_)), _) => s,\n+                                (_, Some(s @ Ty::Apply(_))) => s,\n+                                (Some(s), _) => s,\n+                                (_, Some(s)) => s,\n+                                _ => unreachable!(),\n+                            };\n+                            merged.push(s.clone());\n+                        }\n+\n+                        substs = Substs(merged.into());\n                     }\n \n                     let ty = self.db.type_for_def(typable, Namespace::Types);\n@@ -549,32 +567,52 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let ty = self.insert_type_vars(ty);\n \n                 // plug the old parent_ty in\n-                if let Some(actual_def_ty) = actual_def_ty {\n+                let plug_self_types = || -> Option<()> {\n+                    let actual_def_ty = actual_def_ty?;\n+\n                     if let crate::ModuleDef::Function(func) = def {\n+                        // We only do the infer if parent has generic params\n                         let gen = func.generic_params(self.db);\n-                        if let Some(target_ty) = func.impl_block(self.db) {\n-                            let target_ty = target_ty.target_ty(self.db);\n-                            let old_params = target_ty.substs().unwrap().clone();\n-\n-                            let target_ty = target_ty.subst(&substs);\n-                            let target_ty = self.insert_type_vars(target_ty);\n-\n-                            if gen.count_parent_params() > 0 {\n-                                self.unify(&target_ty, &actual_def_ty);\n-\n-                                if let Ty::Apply(ty) = &ty {\n-                                    for (param, pty) in\n-                                        old_params.iter().zip(target_ty.substs().unwrap().iter())\n-                                    {\n-                                        if let Ty::Param { idx, .. } = param {\n-                                            self.unify(pty, &ty.parameters.0[*idx as usize]);\n-                                        }\n+                        if gen.count_parent_params() == 0 {\n+                            return None;\n+                        }\n+\n+                        let impl_block = func.impl_block(self.db)?;\n+                        let impl_block = impl_block.target_ty(self.db);\n+\n+                        // We save the impl block type params for later use\n+                        let old_params = impl_block.substs().unwrap().clone();\n+\n+                        // Turn the impl block generic params to unknown\n+                        let mut subst = vec![];\n+                        for _ in 0..impl_block.substs().map(|x| x.len()).unwrap_or(0) {\n+                            subst.push(Ty::Unknown);\n+                        }\n+                        let impl_block = impl_block.subst(&Substs(subst.into()));\n+                        let impl_block = self.insert_type_vars(impl_block);\n+\n+                        // Unify *self type* and impl_block\n+                        // e.g. Gen::<u32,u64> <=> Gen::<u64, T>\n+                        self.unify(&impl_block, &actual_def_ty);\n+\n+                        // The following code *link up* the function parent generic param\n+                        // and the impl_block generic param by unify them one by one\n+                        if let Ty::Apply(ty) = &ty {\n+                            old_params.iter().zip(impl_block.substs()?.iter()).for_each(\n+                                |(param, pty)| {\n+                                    if let Ty::Param { idx, .. } = param {\n+                                        self.unify(pty, &ty.parameters.0[*idx as usize]);\n                                     }\n-                                }\n-                            }\n+                                },\n+                            );\n                         }\n+\n+                        return Some(());\n                     }\n-                }\n+                    None\n+                };\n+\n+                plug_self_types();\n \n                 Some(ty)\n             }"}]}