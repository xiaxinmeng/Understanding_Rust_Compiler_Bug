{"sha": "3024c4e7396106eacedd7eb94d7b681b3e82f78a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwMjRjNGU3Mzk2MTA2ZWFjZWRkN2ViOTRkN2I2ODFiM2U4MmY3OGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-30T02:25:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-30T02:25:56Z"}, "message": "Auto merge of #68659 - Dylan-DPC:rollup-zo7zi9f, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #66648 (Implement clone_from for BTreeMap and BTreeSet)\n - #68468 (BTreeMap: tag and explain unsafe internal functions or assert preconditions)\n - #68626 (Use termize instead of term_size)\n - #68640 (Document remaining undocumented `From` implementations for IPs)\n - #68651 (Document `From` implementation for NonZero nums)\n - #68655 (Fix revision annotations in borrowck-feature-nll-overrides-migrate)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "b714bdf1ab25a8c68bdf5ba4a26ab93e792b1da0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b714bdf1ab25a8c68bdf5ba4a26ab93e792b1da0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3024c4e7396106eacedd7eb94d7b681b3e82f78a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3024c4e7396106eacedd7eb94d7b681b3e82f78a", "html_url": "https://github.com/rust-lang/rust/commit/3024c4e7396106eacedd7eb94d7b681b3e82f78a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3024c4e7396106eacedd7eb94d7b681b3e82f78a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc92dfc50725f21f775c059413e1d06d725daacf", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc92dfc50725f21f775c059413e1d06d725daacf", "html_url": "https://github.com/rust-lang/rust/commit/dc92dfc50725f21f775c059413e1d06d725daacf"}, {"sha": "9f497f93aa47f69626b9892747c6374349d5b989", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f497f93aa47f69626b9892747c6374349d5b989", "html_url": "https://github.com/rust-lang/rust/commit/9f497f93aa47f69626b9892747c6374349d5b989"}], "stats": {"total": 468, "additions": 332, "deletions": 136}, "files": [{"sha": "2c4063a5e565eb4f7d015f5dbdd9ff55d217af40", "filename": "Cargo.lock", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3024c4e7396106eacedd7eb94d7b681b3e82f78a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3024c4e7396106eacedd7eb94d7b681b3e82f78a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3024c4e7396106eacedd7eb94d7b681b3e82f78a", "patch": "@@ -3540,8 +3540,8 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_span\",\n  \"serialize\",\n- \"term_size\",\n  \"termcolor\",\n+ \"termize\",\n  \"unicode-width\",\n  \"winapi 0.3.8\",\n ]\n@@ -4580,6 +4580,16 @@ dependencies = [\n  \"redox_termios\",\n ]\n \n+[[package]]\n+name = \"termize\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1706be6b564323ce7092f5f7e6b118a14c8ef7ed0e69c8c5329c914a9f101295\"\n+dependencies = [\n+ \"libc\",\n+ \"winapi 0.3.8\",\n+]\n+\n [[package]]\n name = \"test\"\n version = \"0.0.0\""}, {"sha": "399df33d2b95a190c6331bd165db7bfeabdb75e6", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 81, "deletions": 10, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=3024c4e7396106eacedd7eb94d7b681b3e82f78a", "patch": "@@ -207,6 +207,60 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n             clone_subtree(self.root.as_ref())\n         }\n     }\n+\n+    fn clone_from(&mut self, other: &Self) {\n+        BTreeClone::clone_from(self, other);\n+    }\n+}\n+\n+trait BTreeClone {\n+    fn clone_from(&mut self, other: &Self);\n+}\n+\n+impl<K: Clone, V: Clone> BTreeClone for BTreeMap<K, V> {\n+    default fn clone_from(&mut self, other: &Self) {\n+        *self = other.clone();\n+    }\n+}\n+\n+impl<K: Clone + Ord, V: Clone> BTreeClone for BTreeMap<K, V> {\n+    fn clone_from(&mut self, other: &Self) {\n+        // This truncates `self` to `other.len()` by calling `split_off` on\n+        // the first key after `other.len()` elements if it exists\n+        let split_off_key = if self.len() > other.len() {\n+            let diff = self.len() - other.len();\n+            if diff <= other.len() {\n+                self.iter().nth_back(diff - 1).map(|pair| (*pair.0).clone())\n+            } else {\n+                self.iter().nth(other.len()).map(|pair| (*pair.0).clone())\n+            }\n+        } else {\n+            None\n+        };\n+        if let Some(key) = split_off_key {\n+            self.split_off(&key);\n+        }\n+\n+        let mut siter = self.range_mut(..);\n+        let mut oiter = other.iter();\n+        // After truncation, `self` is at most as long as `other` so this loop\n+        // replaces every key-value pair in `self`. Since `oiter` is in sorted\n+        // order and the structure of the `BTreeMap` stays the same,\n+        // the BTree invariants are maintained at the end of the loop\n+        while !siter.is_empty() {\n+            if let Some((ok, ov)) = oiter.next() {\n+                // SAFETY: This is safe because the `siter.front != siter.back` check\n+                // ensures that `siter` is nonempty\n+                let (sk, sv) = unsafe { siter.next_unchecked() };\n+                sk.clone_from(ok);\n+                sv.clone_from(ov);\n+            } else {\n+                break;\n+            }\n+        }\n+        // If `other` is longer than `self`, the remaining elements are inserted\n+        self.extend(oiter.map(|(k, v)| ((*k).clone(), (*v).clone())));\n+    }\n }\n \n impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n@@ -1357,7 +1411,10 @@ impl<'a, K: 'a, V: 'a> Iterator for IterMut<'a, K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            unsafe { Some(self.range.next_unchecked()) }\n+            unsafe {\n+                let (k, v) = self.range.next_unchecked();\n+                Some((k, v)) // coerce k from `&mut K` to `&K`\n+            }\n         }\n     }\n \n@@ -1736,7 +1793,14 @@ impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        if self.front == self.back { None } else { unsafe { Some(self.next_unchecked()) } }\n+        if self.is_empty() {\n+            None\n+        } else {\n+            unsafe {\n+                let (k, v) = self.next_unchecked();\n+                Some((k, v)) // coerce k from `&mut K` to `&K`\n+            }\n+        }\n     }\n \n     fn last(mut self) -> Option<(&'a K, &'a mut V)> {\n@@ -1745,16 +1809,19 @@ impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n }\n \n impl<'a, K, V> RangeMut<'a, K, V> {\n-    unsafe fn next_unchecked(&mut self) -> (&'a K, &'a mut V) {\n+    fn is_empty(&self) -> bool {\n+        self.front == self.back\n+    }\n+\n+    unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n         let handle = ptr::read(&self.front);\n \n         let mut cur_handle = match handle.right_kv() {\n             Ok(kv) => {\n                 self.front = ptr::read(&kv).right_edge();\n                 // Doing the descend invalidates the references returned by `into_kv_mut`,\n                 // so we have to do this last.\n-                let (k, v) = kv.into_kv_mut();\n-                return (k, v); // coerce k from `&mut K` to `&K`\n+                return kv.into_kv_mut();\n             }\n             Err(last_edge) => {\n                 let next_level = last_edge.into_node().ascend().ok();\n@@ -1768,8 +1835,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n                     self.front = first_leaf_edge(ptr::read(&kv).right_edge().descend());\n                     // Doing the descend invalidates the references returned by `into_kv_mut`,\n                     // so we have to do this last.\n-                    let (k, v) = kv.into_kv_mut();\n-                    return (k, v); // coerce k from `&mut K` to `&K`\n+                    return kv.into_kv_mut();\n                 }\n                 Err(last_edge) => {\n                     let next_level = last_edge.into_node().ascend().ok();\n@@ -1783,7 +1849,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        if self.front == self.back { None } else { unsafe { Some(self.next_back_unchecked()) } }\n+        if self.is_empty() { None } else { unsafe { Some(self.next_back_unchecked()) } }\n     }\n }\n \n@@ -2030,8 +2096,13 @@ where\n             }\n         }\n \n-        let front = Handle::new_edge(min_node, min_edge);\n-        let back = Handle::new_edge(max_node, max_edge);\n+        // Safety guarantee: `min_edge` is always in range for `min_node`, because\n+        // `min_edge` is unconditionally calculated for each iteration's value of `min_node`,\n+        // either (if not found) as the edge index returned by `search_linear`,\n+        // or (if found) as the KV index returned by `search_linear`, possibly + 1.\n+        // Likewise for `max_node` versus `max_edge`.\n+        let front = unsafe { Handle::new_edge(min_node, min_edge) };\n+        let back = unsafe { Handle::new_edge(max_node, max_edge) };\n         match (front.force(), back.force()) {\n             (Leaf(f), Leaf(b)) => {\n                 return (f, b);"}, {"sha": "d85a263b5d54773b47ac5c0d00f63fd323483f2a", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 123, "deletions": 115, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=3024c4e7396106eacedd7eb94d7b681b3e82f78a", "patch": "@@ -263,10 +263,10 @@ impl<K, V> Root<K, V> {\n \n     /// Removes the root node, using its first child as the new root. This cannot be called when\n     /// the tree consists only of a leaf node. As it is intended only to be called when the root\n-    /// has only one edge, no cleanup is done on any of the other children are elements of the root.\n+    /// has only one edge, no cleanup is done on any of the other children of the root.\n     /// This decreases the height by 1 and is the opposite of `push_level`.\n     pub fn pop_level(&mut self) {\n-        debug_assert!(self.height > 0);\n+        assert!(self.height > 0);\n \n         let top = self.node.ptr;\n \n@@ -344,6 +344,9 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Finds the length of the node. This is the number of keys or values. In an\n     /// internal node, the number of edges is `len() + 1`.\n+    /// For any node, the number of possible edge handles is also `len() + 1`.\n+    /// Note that, despite being safe, calling this function can have the side effect\n+    /// of invalidating mutable references that unsafe code has created.\n     pub fn len(&self) -> usize {\n         self.as_header().len as usize\n     }\n@@ -369,7 +372,8 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// If the node is a leaf, this function simply opens up its data.\n     /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n     /// (header, keys and values), and this function exposes that.\n-    /// See `NodeRef` on why the node may not be a shared root.\n+    /// Unsafe because the node must not be the shared root. For more information,\n+    /// see the `NodeRef` comments.\n     unsafe fn as_leaf(&self) -> &LeafNode<K, V> {\n         debug_assert!(!self.is_shared_root());\n         self.node.as_ref()\n@@ -385,14 +389,14 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n \n     /// Borrows a view into the keys stored in the node.\n-    /// The caller must ensure that the node is not the shared root.\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n     pub unsafe fn keys(&self) -> &[K] {\n         self.reborrow().into_key_slice()\n     }\n \n     /// Borrows a view into the values stored in the node.\n-    /// The caller must ensure that the node is not the shared root.\n-    fn vals(&self) -> &[V] {\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn vals(&self) -> &[V] {\n         self.reborrow().into_val_slice()\n     }\n \n@@ -424,25 +428,26 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n \n     pub fn first_edge(self) -> Handle<Self, marker::Edge> {\n-        Handle::new_edge(self, 0)\n+        unsafe { Handle::new_edge(self, 0) }\n     }\n \n     pub fn last_edge(self) -> Handle<Self, marker::Edge> {\n         let len = self.len();\n-        Handle::new_edge(self, len)\n+        unsafe { Handle::new_edge(self, len) }\n     }\n \n     /// Note that `self` must be nonempty.\n     pub fn first_kv(self) -> Handle<Self, marker::KV> {\n-        debug_assert!(self.len() > 0);\n-        Handle::new_kv(self, 0)\n+        let len = self.len();\n+        assert!(len > 0);\n+        unsafe { Handle::new_kv(self, 0) }\n     }\n \n     /// Note that `self` must be nonempty.\n     pub fn last_kv(self) -> Handle<Self, marker::KV> {\n         let len = self.len();\n-        debug_assert!(len > 0);\n-        Handle::new_kv(self, len - 1)\n+        assert!(len > 0);\n+        unsafe { Handle::new_kv(self, len - 1) }\n     }\n }\n \n@@ -453,7 +458,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n     pub unsafe fn deallocate_and_ascend(\n         self,\n     ) -> Option<Handle<NodeRef<marker::Owned, K, V, marker::Internal>, marker::Edge>> {\n-        debug_assert!(!self.is_shared_root());\n+        assert!(!self.is_shared_root());\n         let node = self.node;\n         let ret = self.ascend().ok();\n         Global.dealloc(node.cast(), Layout::new::<LeafNode<K, V>>());\n@@ -508,36 +513,36 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         self.node.as_ptr()\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn keys_mut(&mut self) -> &mut [K] {\n-        unsafe { self.reborrow_mut().into_key_slice_mut() }\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn keys_mut(&mut self) -> &mut [K] {\n+        self.reborrow_mut().into_key_slice_mut()\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn vals_mut(&mut self) -> &mut [V] {\n-        unsafe { self.reborrow_mut().into_val_slice_mut() }\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn vals_mut(&mut self) -> &mut [V] {\n+        self.reborrow_mut().into_val_slice_mut()\n     }\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n-    /// The caller must ensure that the node is not the shared root.\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n     unsafe fn into_key_slice(self) -> &'a [K] {\n         debug_assert!(!self.is_shared_root());\n         // We cannot be the shared root, so `as_leaf` is okay.\n         slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().keys), self.len())\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn into_val_slice(self) -> &'a [V] {\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_val_slice(self) -> &'a [V] {\n         debug_assert!(!self.is_shared_root());\n         // We cannot be the shared root, so `as_leaf` is okay.\n-        unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len()) }\n+        slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len())\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn into_slices(self) -> (&'a [K], &'a [V]) {\n-        let k = unsafe { ptr::read(&self) };\n-        (unsafe { k.into_key_slice() }, self.into_val_slice())\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_slices(self) -> (&'a [K], &'a [V]) {\n+        let k = ptr::read(&self);\n+        (k.into_key_slice(), self.into_val_slice())\n     }\n }\n \n@@ -548,54 +553,45 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         unsafe { &mut *(self.root as *mut Root<K, V>) }\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn into_key_slice_mut(mut self) -> &'a mut [K] {\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_key_slice_mut(mut self) -> &'a mut [K] {\n         debug_assert!(!self.is_shared_root());\n         // We cannot be the shared root, so `as_leaf_mut` is okay.\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).keys),\n-                self.len(),\n-            )\n-        }\n+        slice::from_raw_parts_mut(\n+            MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).keys),\n+            self.len(),\n+        )\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn into_val_slice_mut(mut self) -> &'a mut [V] {\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_val_slice_mut(mut self) -> &'a mut [V] {\n         debug_assert!(!self.is_shared_root());\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).vals),\n-                self.len(),\n-            )\n-        }\n+        slice::from_raw_parts_mut(\n+            MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).vals),\n+            self.len(),\n+        )\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n         debug_assert!(!self.is_shared_root());\n         // We cannot use the getters here, because calling the second one\n         // invalidates the reference returned by the first.\n         // More precisely, it is the call to `len` that is the culprit,\n         // because that creates a shared reference to the header, which *can*\n         // overlap with the keys (and even the values, for ZST keys).\n-        unsafe {\n-            let len = self.len();\n-            let leaf = self.as_leaf_mut();\n-            let keys =\n-                slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).keys), len);\n-            let vals =\n-                slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).vals), len);\n-            (keys, vals)\n-        }\n+        let len = self.len();\n+        let leaf = self.as_leaf_mut();\n+        let keys = slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).keys), len);\n+        let vals = slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).vals), len);\n+        (keys, vals)\n     }\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key/value pair the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(self.len() < CAPACITY);\n+        assert!(self.len() < CAPACITY);\n         debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n@@ -610,8 +606,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n \n     /// Adds a key/value pair to the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V) {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(self.len() < CAPACITY);\n+        assert!(self.len() < CAPACITY);\n         debug_assert!(!self.is_shared_root());\n \n         unsafe {\n@@ -627,9 +622,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     /// Adds a key/value pair and an edge to go to the right of that pair to\n     /// the end of the node.\n     pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(edge.height == self.height - 1);\n-        debug_assert!(self.len() < CAPACITY);\n+        assert!(edge.height == self.height - 1);\n+        assert!(self.len() < CAPACITY);\n         debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n@@ -645,23 +639,25 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         }\n     }\n \n-    fn correct_childrens_parent_links(&mut self, first: usize, after_last: usize) {\n+    // Unsafe because 'first' and 'after_last' must be in range\n+    unsafe fn correct_childrens_parent_links(&mut self, first: usize, after_last: usize) {\n+        debug_assert!(first <= self.len());\n+        debug_assert!(after_last <= self.len() + 1);\n         for i in first..after_last {\n-            Handle::new_edge(unsafe { self.reborrow_mut() }, i).correct_parent_link();\n+            Handle::new_edge(self.reborrow_mut(), i).correct_parent_link();\n         }\n     }\n \n     fn correct_all_childrens_parent_links(&mut self) {\n         let len = self.len();\n-        self.correct_childrens_parent_links(0, len + 1);\n+        unsafe { self.correct_childrens_parent_links(0, len + 1) };\n     }\n \n     /// Adds a key/value pair and an edge to go to the left of that pair to\n     /// the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(edge.height == self.height - 1);\n-        debug_assert!(self.len() < CAPACITY);\n+        assert!(edge.height == self.height - 1);\n+        assert!(self.len() < CAPACITY);\n         debug_assert!(!self.is_shared_root());\n \n         unsafe {\n@@ -687,8 +683,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     /// Removes a key/value pair from the end of this node. If this is an internal node,\n     /// also removes the edge that was to the right of that pair.\n     pub fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(self.len() > 0);\n+        assert!(self.len() > 0);\n \n         let idx = self.len() - 1;\n \n@@ -714,8 +709,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     /// Removes a key/value pair from the beginning of this node. If this is an internal node,\n     /// also removes the edge that was to the left of that pair.\n     pub fn pop_front(&mut self) -> (K, V, Option<Root<K, V>>) {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(self.len() > 0);\n+        assert!(self.len() > 0);\n \n         let old_len = self.len();\n \n@@ -750,8 +744,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         }\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n         (self.keys_mut().as_mut_ptr(), self.vals_mut().as_mut_ptr())\n     }\n }\n@@ -813,20 +807,20 @@ impl<Node, Type> Handle<Node, Type> {\n }\n \n impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV> {\n-    /// Creates a new handle to a key/value pair in `node`. `idx` must be less than `node.len()`.\n-    pub fn new_kv(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n-        // Necessary for correctness, but in a private module\n+    /// Creates a new handle to a key/value pair in `node`.\n+    /// Unsafe because the caller must ensure that `idx < node.len()`.\n+    pub unsafe fn new_kv(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n         debug_assert!(idx < node.len());\n \n         Handle { node, idx, _marker: PhantomData }\n     }\n \n     pub fn left_edge(self) -> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n-        Handle::new_edge(self.node, self.idx)\n+        unsafe { Handle::new_edge(self.node, self.idx) }\n     }\n \n     pub fn right_edge(self) -> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n-        Handle::new_edge(self.node, self.idx + 1)\n+        unsafe { Handle::new_edge(self.node, self.idx + 1) }\n     }\n }\n \n@@ -868,21 +862,28 @@ impl<'a, K, V, NodeType, HandleType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeT\n }\n \n impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n-    /// Creates a new handle to an edge in `node`. `idx` must be less than or equal to\n-    /// `node.len()`.\n-    pub fn new_edge(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n-        // Necessary for correctness, but in a private module\n+    /// Creates a new handle to an edge in `node`.\n+    /// Unsafe because the caller must ensure that `idx <= node.len()`.\n+    pub unsafe fn new_edge(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n         debug_assert!(idx <= node.len());\n \n         Handle { node, idx, _marker: PhantomData }\n     }\n \n     pub fn left_kv(self) -> Result<Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV>, Self> {\n-        if self.idx > 0 { Ok(Handle::new_kv(self.node, self.idx - 1)) } else { Err(self) }\n+        if self.idx > 0 {\n+            Ok(unsafe { Handle::new_kv(self.node, self.idx - 1) })\n+        } else {\n+            Err(self)\n+        }\n     }\n \n     pub fn right_kv(self) -> Result<Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV>, Self> {\n-        if self.idx < self.node.len() { Ok(Handle::new_kv(self.node, self.idx)) } else { Err(self) }\n+        if self.idx < self.node.len() {\n+            Ok(unsafe { Handle::new_kv(self.node, self.idx) })\n+        } else {\n+            Err(self)\n+        }\n     }\n }\n \n@@ -914,9 +915,10 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     pub fn insert(mut self, key: K, val: V) -> (InsertResult<'a, K, V, marker::Leaf>, *mut V) {\n         if self.node.len() < CAPACITY {\n             let ptr = self.insert_fit(key, val);\n-            (InsertResult::Fit(Handle::new_kv(self.node, self.idx)), ptr)\n+            let kv = unsafe { Handle::new_kv(self.node, self.idx) };\n+            (InsertResult::Fit(kv), ptr)\n         } else {\n-            let middle = Handle::new_kv(self.node, B);\n+            let middle = unsafe { Handle::new_kv(self.node, B) };\n             let (mut left, k, v, mut right) = middle.split();\n             let ptr = if self.idx <= B {\n                 unsafe { Handle::new_edge(left.reborrow_mut(), self.idx).insert_fit(key, val) }\n@@ -991,14 +993,14 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         val: V,\n         edge: Root<K, V>,\n     ) -> InsertResult<'a, K, V, marker::Internal> {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(edge.height == self.node.height - 1);\n+        assert!(edge.height == self.node.height - 1);\n \n         if self.node.len() < CAPACITY {\n             self.insert_fit(key, val, edge);\n-            InsertResult::Fit(Handle::new_kv(self.node, self.idx))\n+            let kv = unsafe { Handle::new_kv(self.node, self.idx) };\n+            InsertResult::Fit(kv)\n         } else {\n-            let middle = Handle::new_kv(self.node, B);\n+            let middle = unsafe { Handle::new_kv(self.node, B) };\n             let (mut left, k, v, mut right) = middle.split();\n             if self.idx <= B {\n                 unsafe {\n@@ -1037,15 +1039,19 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marke\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Immut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_kv(self) -> (&'a K, &'a V) {\n-        let (keys, vals) = self.node.into_slices();\n-        unsafe { (keys.get_unchecked(self.idx), vals.get_unchecked(self.idx)) }\n+        unsafe {\n+            let (keys, vals) = self.node.into_slices();\n+            (keys.get_unchecked(self.idx), vals.get_unchecked(self.idx))\n+        }\n     }\n }\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_kv_mut(self) -> (&'a mut K, &'a mut V) {\n-        let (keys, vals) = self.node.into_slices_mut();\n-        unsafe { (keys.get_unchecked_mut(self.idx), vals.get_unchecked_mut(self.idx)) }\n+        unsafe {\n+            let (keys, vals) = self.node.into_slices_mut();\n+            (keys.get_unchecked_mut(self.idx), vals.get_unchecked_mut(self.idx))\n+        }\n     }\n }\n \n@@ -1067,7 +1073,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     /// - All the key/value pairs to the right of this handle are put into a newly\n     ///   allocated node.\n     pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n-        debug_assert!(!self.node.is_shared_root());\n+        assert!(!self.node.is_shared_root());\n         unsafe {\n             let mut new_node = Box::new(LeafNode::new());\n \n@@ -1099,7 +1105,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     pub fn remove(\n         mut self,\n     ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n-        debug_assert!(!self.node.is_shared_root());\n+        assert!(!self.node.is_shared_root());\n         unsafe {\n             let k = slice_remove(self.node.keys_mut(), self.idx);\n             let v = slice_remove(self.node.vals_mut(), self.idx);\n@@ -1182,7 +1188,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         let right_len = right_node.len();\n \n         // necessary for correctness, but in a private module\n-        debug_assert!(left_len + right_len + 1 <= CAPACITY);\n+        assert!(left_len + right_len + 1 <= CAPACITY);\n \n         unsafe {\n             ptr::write(\n@@ -1281,8 +1287,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             let right_len = right_node.len();\n \n             // Make sure that we may steal safely.\n-            debug_assert!(right_len + count <= CAPACITY);\n-            debug_assert!(left_len >= count);\n+            assert!(right_len + count <= CAPACITY);\n+            assert!(left_len >= count);\n \n             let new_left_len = left_len - count;\n \n@@ -1338,8 +1344,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             let right_len = right_node.len();\n \n             // Make sure that we may steal safely.\n-            debug_assert!(left_len + count <= CAPACITY);\n-            debug_assert!(right_len >= count);\n+            assert!(left_len + count <= CAPACITY);\n+            assert!(right_len >= count);\n \n             let new_right_len = right_len - count;\n \n@@ -1447,24 +1453,26 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, ma\n             let right_new_len = left_node.len() - left_new_len;\n             let mut right_node = right.reborrow_mut();\n \n-            debug_assert!(right_node.len() == 0);\n-            debug_assert!(left_node.height == right_node.height);\n+            assert!(right_node.len() == 0);\n+            assert!(left_node.height == right_node.height);\n \n-            let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n-            let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n+            if right_new_len > 0 {\n+                let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n+                let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n \n-            move_kv(left_kv, left_new_len, right_kv, 0, right_new_len);\n+                move_kv(left_kv, left_new_len, right_kv, 0, right_new_len);\n \n-            (*left_node.reborrow_mut().as_leaf_mut()).len = left_new_len as u16;\n-            (*right_node.reborrow_mut().as_leaf_mut()).len = right_new_len as u16;\n+                (*left_node.reborrow_mut().as_leaf_mut()).len = left_new_len as u16;\n+                (*right_node.reborrow_mut().as_leaf_mut()).len = right_new_len as u16;\n \n-            match (left_node.force(), right_node.force()) {\n-                (ForceResult::Internal(left), ForceResult::Internal(right)) => {\n-                    move_edges(left, left_new_len + 1, right, 1, right_new_len);\n-                }\n-                (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n-                _ => {\n-                    unreachable!();\n+                match (left_node.force(), right_node.force()) {\n+                    (ForceResult::Internal(left), ForceResult::Internal(right)) => {\n+                        move_edges(left, left_new_len + 1, right, 1, right_new_len);\n+                    }\n+                    (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n+                    _ => {\n+                        unreachable!();\n+                    }\n                 }\n             }\n         }"}, {"sha": "e680e364147472ecfe5fdbf3f75dc83769ecbb48", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=3024c4e7396106eacedd7eb94d7b681b3e82f78a", "patch": "@@ -41,8 +41,8 @@ where\n     K: Borrow<Q>,\n {\n     match search_linear(&node, key) {\n-        (idx, true) => Found(Handle::new_kv(node, idx)),\n-        (idx, false) => SearchResult::GoDown(Handle::new_edge(node, idx)),\n+        (idx, true) => Found(unsafe { Handle::new_kv(node, idx) }),\n+        (idx, false) => SearchResult::GoDown(unsafe { Handle::new_edge(node, idx) }),\n     }\n }\n "}, {"sha": "b100ce754caad589b92089d51c9c89e087faba4c", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=3024c4e7396106eacedd7eb94d7b681b3e82f78a", "patch": "@@ -56,12 +56,23 @@ use crate::collections::btree_map::{self, BTreeMap, Keys};\n ///     println!(\"{}\", book);\n /// }\n /// ```\n-#[derive(Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n+#[derive(Hash, PartialEq, Eq, Ord, PartialOrd)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeSet<T> {\n     map: BTreeMap<T, ()>,\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Clone> Clone for BTreeSet<T> {\n+    fn clone(&self) -> Self {\n+        BTreeSet { map: self.map.clone() }\n+    }\n+\n+    fn clone_from(&mut self, other: &Self) {\n+        self.map.clone_from(&other.map);\n+    }\n+}\n+\n /// An iterator over the items of a `BTreeSet`.\n ///\n /// This `struct` is created by the [`iter`] method on [`BTreeSet`]."}, {"sha": "0d009507fc7aac1ba3202a2fe9df8980abb6be64", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=3024c4e7396106eacedd7eb94d7b681b3e82f78a", "patch": "@@ -785,6 +785,26 @@ fn test_clone() {\n     }\n }\n \n+#[test]\n+fn test_clone_from() {\n+    let mut map1 = BTreeMap::new();\n+    let size = 30;\n+\n+    for i in 0..size {\n+        let mut map2 = BTreeMap::new();\n+        for j in 0..i {\n+            let mut map1_copy = map2.clone();\n+            map1_copy.clone_from(&map1);\n+            assert_eq!(map1_copy, map1);\n+            let mut map2_copy = map1.clone();\n+            map2_copy.clone_from(&map2);\n+            assert_eq!(map2_copy, map2);\n+            map2.insert(100 * j + 1, 2 * j + 1);\n+        }\n+        map1.insert(i, 10 * i);\n+    }\n+}\n+\n #[test]\n #[allow(dead_code)]\n fn test_variance() {"}, {"sha": "5d2c1d0de2c9b3559fb5e3eb499ecc7a08d24506", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=3024c4e7396106eacedd7eb94d7b681b3e82f78a", "patch": "@@ -91,8 +91,12 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n \n             #[stable(feature = \"from_nonzero\", since = \"1.31.0\")]\n             impl From<$Ty> for $Int {\n-                fn from(nonzero: $Ty) -> Self {\n-                    nonzero.0\n+                doc_comment! {\n+                    concat!(\n+\"Converts a `\", stringify!($Ty), \"` into an `\", stringify!($Int), \"`\"),\n+                    fn from(nonzero: $Ty) -> Self {\n+                        nonzero.0\n+                    }\n                 }\n             }\n "}, {"sha": "b8340b1a1df6aff24c13cb6e8f44b3bcf511e9be", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=3024c4e7396106eacedd7eb94d7b681b3e82f78a", "patch": "@@ -18,7 +18,7 @@ unicode-width = \"0.1.4\"\n atty = \"0.2\"\n termcolor = \"1.0\"\n annotate-snippets = \"0.6.1\"\n-term_size = \"0.3.1\"\n+termize = \"0.1.1\"\n \n [target.'cfg(windows)'.dependencies]\n winapi = { version = \"0.3\", features = [\"handleapi\", \"synchapi\", \"winbase\"] }"}, {"sha": "1fcb36a2a30908408b9b43c5d05fcc0fd9fa661b", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=3024c4e7396106eacedd7eb94d7b681b3e82f78a", "patch": "@@ -1367,7 +1367,7 @@ impl EmitterWriter {\n                 } else if self.ui_testing {\n                     140\n                 } else {\n-                    term_size::dimensions()\n+                    termize::dimensions()\n                         .map(|(w, _)| w.saturating_sub(code_offset))\n                         .unwrap_or(std::usize::MAX)\n                 };"}, {"sha": "200b00b119595e7038e1890082d7e24a4b3ece19", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=3024c4e7396106eacedd7eb94d7b681b3e82f78a", "patch": "@@ -813,13 +813,41 @@ impl fmt::Display for IpAddr {\n \n #[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n impl From<Ipv4Addr> for IpAddr {\n+    /// Copies this address to a new `IpAddr::V4`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr};\n+    ///\n+    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n+    ///\n+    /// assert_eq!(\n+    ///     IpAddr::V4(addr),\n+    ///     IpAddr::from(addr)\n+    /// )\n+    /// ```\n     fn from(ipv4: Ipv4Addr) -> IpAddr {\n         IpAddr::V4(ipv4)\n     }\n }\n \n #[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n impl From<Ipv6Addr> for IpAddr {\n+    /// Copies this address to a new `IpAddr::V6`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv6Addr};\n+    ///\n+    /// let addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff);\n+    ///\n+    /// assert_eq!(\n+    ///     IpAddr::V6(addr),\n+    ///     IpAddr::from(addr)\n+    /// );\n+    /// ```\n     fn from(ipv6: Ipv6Addr) -> IpAddr {\n         IpAddr::V6(ipv6)\n     }\n@@ -975,6 +1003,8 @@ impl From<u32> for Ipv4Addr {\n \n #[stable(feature = \"from_slice_v4\", since = \"1.9.0\")]\n impl From<[u8; 4]> for Ipv4Addr {\n+    /// Creates an `Ipv4Addr` from a four element byte array.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1734,6 +1764,27 @@ impl From<u128> for Ipv6Addr {\n \n #[stable(feature = \"ipv6_from_octets\", since = \"1.9.0\")]\n impl From<[u8; 16]> for Ipv6Addr {\n+    /// Creates an `Ipv6Addr` from a sixteen element byte array.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let addr = Ipv6Addr::from([\n+    ///     25u8, 24u8, 23u8, 22u8, 21u8, 20u8, 19u8, 18u8,\n+    ///     17u8, 16u8, 15u8, 14u8, 13u8, 12u8, 11u8, 10u8,\n+    /// ]);\n+    /// assert_eq!(\n+    ///     Ipv6Addr::new(\n+    ///         0x1918, 0x1716,\n+    ///         0x1514, 0x1312,\n+    ///         0x1110, 0x0f0e,\n+    ///         0x0d0c, 0x0b0a\n+    ///     ),\n+    ///     addr\n+    /// );\n+    /// ```\n     fn from(octets: [u8; 16]) -> Ipv6Addr {\n         let inner = c::in6_addr { s6_addr: octets };\n         Ipv6Addr::from_inner(inner)\n@@ -1742,6 +1793,27 @@ impl From<[u8; 16]> for Ipv6Addr {\n \n #[stable(feature = \"ipv6_from_segments\", since = \"1.16.0\")]\n impl From<[u16; 8]> for Ipv6Addr {\n+    /// Creates an `Ipv6Addr` from an eight element 16-bit array.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let addr = Ipv6Addr::from([\n+    ///     525u16, 524u16, 523u16, 522u16,\n+    ///     521u16, 520u16, 519u16, 518u16,\n+    /// ]);\n+    /// assert_eq!(\n+    ///     Ipv6Addr::new(\n+    ///         0x20d, 0x20c,\n+    ///         0x20b, 0x20a,\n+    ///         0x209, 0x208,\n+    ///         0x207, 0x206\n+    ///     ),\n+    ///     addr\n+    /// );\n+    /// ```\n     fn from(segments: [u16; 8]) -> Ipv6Addr {\n         let [a, b, c, d, e, f, g, h] = segments;\n         Ipv6Addr::new(a, b, c, d, e, f, g, h)"}, {"sha": "51f2ff75da83145af5552242eac8ad38e6473b7e", "filename": "src/test/ui/borrowck/borrowck-feature-nll-overrides-migrate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-feature-nll-overrides-migrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-feature-nll-overrides-migrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-feature-nll-overrides-migrate.rs?ref=3024c4e7396106eacedd7eb94d7b681b3e82f78a", "patch": "@@ -9,8 +9,8 @@\n // borrowck=migrate`.\n \n // revisions: zflag edition\n-// [zflag]compile-flags: -Z borrowck=migrate\n-// [edition]edition:2018\n+//[zflag]compile-flags: -Z borrowck=migrate\n+//[edition]edition:2018\n \n #![feature(nll)]\n "}, {"sha": "ea92f7bee6b663081a2fe1e3fd199c14134d0f48", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c4e7396106eacedd7eb94d7b681b3e82f78a/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=3024c4e7396106eacedd7eb94d7b681b3e82f78a", "patch": "@@ -167,7 +167,7 @@ const WHITELIST: &[Crate<'_>] = &[\n     Crate(\"termcolor\"),\n     Crate(\"terminon\"),\n     Crate(\"termion\"),\n-    Crate(\"term_size\"),\n+    Crate(\"termize\"),\n     Crate(\"thread_local\"),\n     Crate(\"ucd-util\"),\n     Crate(\"unicode-normalization\"),"}]}