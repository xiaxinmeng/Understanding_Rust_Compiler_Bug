{"sha": "c301db20a40d63ee330956a97102c3e566475f75", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMDFkYjIwYTQwZDYzZWUzMzA5NTZhOTcxMDJjM2U1NjY0NzVmNzU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-15T18:06:31Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-08-25T00:08:14Z"}, "message": "native: Add some documentation for accept\n\nDocument the new code for how close_accept and timeouts are implemented.", "tree": {"sha": "dd45dcb51a7f073c2b5831d90838449002220056", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd45dcb51a7f073c2b5831d90838449002220056"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c301db20a40d63ee330956a97102c3e566475f75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c301db20a40d63ee330956a97102c3e566475f75", "html_url": "https://github.com/rust-lang/rust/commit/c301db20a40d63ee330956a97102c3e566475f75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c301db20a40d63ee330956a97102c3e566475f75/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7441d4f3f33b4cc21912ff9a3b495f62abc3362e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7441d4f3f33b4cc21912ff9a3b495f62abc3362e", "html_url": "https://github.com/rust-lang/rust/commit/7441d4f3f33b4cc21912ff9a3b495f62abc3362e"}], "stats": {"total": 34, "additions": 34, "deletions": 0}, "files": [{"sha": "bbfc8aff1b74175721c729cb43e2ce1e859a93e9", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c301db20a40d63ee330956a97102c3e566475f75/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c301db20a40d63ee330956a97102c3e566475f75/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=c301db20a40d63ee330956a97102c3e566475f75", "patch": "@@ -526,6 +526,20 @@ impl TcpAcceptor {\n \n     #[cfg(unix)]\n     pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n+        // In implementing accept, the two main concerns are dealing with\n+        // close_accept() and timeouts. The unix implementation is based on a\n+        // nonblocking accept plus a call to select(). Windows ends up having\n+        // an entirely separate implementation than unix, which is explained\n+        // below.\n+        //\n+        // To implement timeouts, all blocking is done via select() instead of\n+        // accept() by putting the socket in non-blocking mode. Because\n+        // select() takes a timeout argument, we just pass through the timeout\n+        // to select().\n+        //\n+        // To implement close_accept(), we have a self-pipe to ourselves which\n+        // is passed to select() along with the socket being accepted on. The\n+        // self-pipe is never written to unless close_accept() is called.\n         let deadline = if self.deadline == 0 {None} else {Some(self.deadline)};\n \n         while !self.inner.closed.load(atomics::SeqCst) {\n@@ -545,6 +559,26 @@ impl TcpAcceptor {\n \n     #[cfg(windows)]\n     pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n+        // Unlink unix, windows cannot invoke `select` on arbitrary file\n+        // descriptors like pipes, only sockets. Consequently, windows cannot\n+        // use the same implementation as unix for accept() when close_accept()\n+        // is considered.\n+        //\n+        // In order to implement close_accept() and timeouts, windows uses\n+        // event handles. An acceptor-specific abort event is created which\n+        // will only get set in close_accept(), and it will never be un-set.\n+        // Additionally, another acceptor-specific event is associated with the\n+        // FD_ACCEPT network event.\n+        //\n+        // These two events are then passed to WaitForMultipleEvents to see\n+        // which one triggers first, and the timeout passed to this function is\n+        // the local timeout for the acceptor.\n+        //\n+        // If the wait times out, then the accept timed out. If the wait\n+        // succeeds with the abort event, then we were closed, and if the wait\n+        // succeeds otherwise, then we do a nonblocking poll via `accept` to\n+        // see if we can accept a connection. The connection is candidate to be\n+        // stolen, so we do all of this in a loop as well.\n         let events = [self.inner.abort.handle(), self.inner.accept.handle()];\n \n         while !self.inner.closed.load(atomics::SeqCst) {"}]}