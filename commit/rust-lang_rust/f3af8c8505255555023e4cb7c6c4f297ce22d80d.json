{"sha": "f3af8c8505255555023e4cb7c6c4f297ce22d80d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzYWY4Yzg1MDUyNTU1NTUwMjNlNGNiN2M2YzRmMjk3Y2UyMmQ4MGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-12T08:39:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-12T08:39:50Z"}, "message": "Auto merge of #37730 - eddyb:rollup, r=eddyb\n\nRollup of 30 pull requests\n\n- Successful merges: #37190, #37368, #37481, #37503, #37527, #37535, #37551, #37584, #37600, #37613, #37615, #37659, #37662, #37669, #37682, #37688, #37690, #37692, #37693, #37694, #37695, #37696, #37698, #37699, #37705, #37708, #37709, #37716, #37724, #37727\n- Failed merges: #37640, #37689, #37717", "tree": {"sha": "8de381d2dcd293c89c04eecc28fbdb96cd2f6a87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8de381d2dcd293c89c04eecc28fbdb96cd2f6a87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3af8c8505255555023e4cb7c6c4f297ce22d80d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3af8c8505255555023e4cb7c6c4f297ce22d80d", "html_url": "https://github.com/rust-lang/rust/commit/f3af8c8505255555023e4cb7c6c4f297ce22d80d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3af8c8505255555023e4cb7c6c4f297ce22d80d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b33873f5411d4ad6a3bd5a4a18dffce8a960a316", "url": "https://api.github.com/repos/rust-lang/rust/commits/b33873f5411d4ad6a3bd5a4a18dffce8a960a316", "html_url": "https://github.com/rust-lang/rust/commit/b33873f5411d4ad6a3bd5a4a18dffce8a960a316"}, {"sha": "5dcf0e87c876e349d19d0516b0aabc9ae7c51751", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dcf0e87c876e349d19d0516b0aabc9ae7c51751", "html_url": "https://github.com/rust-lang/rust/commit/5dcf0e87c876e349d19d0516b0aabc9ae7c51751"}], "stats": {"total": 6005, "additions": 4927, "deletions": 1078}, "files": [{"sha": "e06444ddf6d0f06c763a27b198cf45287ef343ea", "filename": ".travis.yml", "status": "modified", "additions": 68, "deletions": 19, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -1,33 +1,82 @@\n-language: generic\n+language: rust\n sudo: required\n+dist: trusty\n services:\n   - docker\n \n-# LLVM takes awhile to check out and otherwise we'll manage the submodules in\n-# our configure script, so disable auto submodule management.\n git:\n-  submodules: false\n   depth: 1\n+  submodules: false\n \n-before_install:\n-  - docker build -t rust -f src/etc/Dockerfile src/etc\n+matrix:\n+  include:\n+    # Linux builders, all docker images\n+    - env: IMAGE=arm-android\n+    - env: IMAGE=cross\n+    - env: IMAGE=i686-gnu\n+    - env: IMAGE=i686-gnu-nopt\n+    - env: IMAGE=x86_64-freebsd\n+    - env: IMAGE=x86_64-gnu\n+    - env: IMAGE=x86_64-gnu-cargotest\n+    - env: IMAGE=x86_64-gnu-debug\n+    - env: IMAGE=x86_64-gnu-nopt\n+    - env: IMAGE=x86_64-gnu-rustbuild\n+    - env: IMAGE=x86_64-gnu-llvm-3.7 ALLOW_PR=1\n+    - env: IMAGE=x86_64-musl\n+\n+    # OSX builders\n+    - env: >\n+        RUST_CHECK_TARGET=check\n+        RUST_CONFIGURE_ARGS=--target=x86_64-apple-darwin\n+        SRC=.\n+      os: osx\n+      install: brew install ccache\n+    - env: >\n+        RUST_CHECK_TARGET=check\n+        RUST_CONFIGURE_ARGS=--target=i686-apple-darwin\n+        SRC=.\n+      os: osx\n+      install: brew install ccache\n+    - env: >\n+        RUST_CHECK_TARGET=check\n+        RUST_CONFIGURE_ARGS=--target=x86_64-apple-darwin --enable-rustbuild\n+        SRC=.\n+      os: osx\n+      install: brew install ccache\n+    - env: >\n+        RUST_CHECK_TARGET=\n+        RUST_CONFIGURE_ARGS=--target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios\n+        SRC=.\n+      os: osx\n+      install: brew install ccache\n \n script:\n-  - docker run -v `pwd`:/build rust\n-    sh -c \"\n-      ./configure --enable-vendor --enable-rustbuild --llvm-root=/usr/lib/llvm-3.7 --enable-quiet-tests &&\n-      make tidy &&\n-      make check -j4\n-    \"\n+  - if [ -z \"$ALLOW_PR\" ] && [ \"$TRAVIS_BRANCH\" != \"auto\" ]; then\n+        echo skipping, not a full build;\n+    elif [ -z \"$ENABLE_AUTO\" ] then\n+        echo skipping, not quite ready yet\n+    elif [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n+        git submodule update --init;\n+        src/ci/run.sh;\n+    else\n+        git submodule update --init;\n+        src/ci/docker/run.sh $IMAGE;\n+    fi\n \n-# Real testing happens on http://buildbot.rust-lang.org/\n-#\n-# See https://github.com/rust-lang/rust-buildbot\n-#     CONTRIBUTING.md#pull-requests\n+# Save tagged docker images we created and load them if they're available\n+before_cache:\n+  - docker history -q rust-ci |\n+    grep -v missing |\n+    xargs docker save |\n+    gzip -9 > $HOME/docker/rust-ci.tar.gz\n+before_install:\n+  - zcat $HOME/docker/rust-ci.tar.gz | docker load || true\n \n notifications:\n   email: false\n \n-branches:\n-  only:\n-    - master\n+cache:\n+  directories:\n+    - $HOME/docker\n+    - $HOME/.ccache\n+    - $HOME/.cargo"}, {"sha": "e468a86e7acc32762b5853aabe42301fb882e702", "filename": "RELEASES.md", "status": "modified", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -1,3 +1,260 @@\n+Version 1.13.0 (2016-11-10)\n+===========================\n+\n+Language\n+--------\n+\n+* [Stabilize the `?` operator][36995]. `?` is a simple way to propagate\n+  errors, like the `try!` macro, described in [RFC 0243].\n+* [Stabilize macros in type position][36014]. Described in [RFC 873].\n+* [Stabilize attributes on statements][36995]. Described in [RFC 0016].\n+* [Fix `#[derive]` for empty tuple structs/variants][35728]\n+* [Fix lifetime rules for 'if' conditions][36029]\n+* [Avoid loading and parsing unconfigured non-inline modules][36482]\n+\n+Compiler\n+--------\n+\n+* [Add the `-C link-arg` argument][36574]\n+* [Remove the old AST-based backend from rustc_trans][35764]\n+* [Don't enable NEON by default on armv7 Linux][35814]\n+* [Fix debug line number info for macro expansions][35238]\n+* [Do not emit \"class method\" debuginfo for types that are not\n+  DICompositeType][36008]\n+* [Warn about multiple conflicting #[repr] hints][34623]\n+* [When sizing DST, don't double-count nested struct prefixes][36351]\n+* [Default RUST_MIN_STACK to 16MiB for now][36505]\n+* [Improve rlib metadata format][36551]. Reduces rlib size significantly.\n+* [Reject macros with empty repetitions to avoid infinite loop][36721]\n+* [Expand macros without recursing to avoid stack overflows][36214]\n+\n+Diagnostics\n+-----------\n+\n+* [Replace macro backtraces with labeled local uses][35702]\n+* [Improve error message for missplaced doc comments][33922]\n+* [Buffer unix and lock windows to prevent message interleaving][35975]\n+* [Update lifetime errors to specifically note temporaries][36171]\n+* [Special case a few colors for Windows][36178]\n+* [Suggest `use self` when such an import resolves][36289]\n+* [Be more specific when type parameter shadows primitive type][36338]\n+* Many minor improvements\n+\n+Compile-time Optimizations\n+--------------------------\n+\n+* [Compute and cache HIR hashes at beginning][35854]\n+* [Don't hash types in loan paths][36004]\n+* [Cache projections in trans][35761]\n+* [Optimize the parser's last token handling][36527]\n+* [Only instantiate #[inline] functions in codegen units referencing\n+  them][36524]. This leads to big improvements in cases where crates export\n+  define many inline functions without using them directly.\n+* [Lazily allocate TypedArena's first chunk][36592]\n+* [Don't allocate during default HashSet creation][36734]\n+\n+Stabilized APIs\n+---------------\n+\n+* [`checked_abs`]\n+* [`wrapping_abs`]\n+* [`overflowing_abs`]\n+* [`RefCell::try_borrow`]\n+* [`RefCell::try_borrow_mut`]\n+\n+Libraries\n+---------\n+\n+* [Add `assert_ne!` and `debug_assert_ne!`][35074]\n+* [Make `vec_deque::Drain`, `hash_map::Drain`, and `hash_set::Drain`\n+  covariant][35354]\n+* [Implement `AsRef<[T]>` for `std::slice::Iter`][35559]\n+* [Implement `Debug` for `std::vec::IntoIter`][35707]\n+* [`CString`: avoid excessive growth just to 0-terminate][35871]\n+* [Implement `CoerceUnsized` for `{Cell, RefCell, UnsafeCell}`][35627]\n+* [Use arc4rand on FreeBSD][35884]\n+* [memrchr: Correct aligned offset computation][35969]\n+* [Improve Demangling of Rust Symbols][36059]\n+* [Use monotonic time in condition variables][35048]\n+* [Implement `Debug` for `std::path::{Components,Iter}`][36101]\n+* [Implement conversion traits for `char`][35755]\n+* [Fix illegal instruction caused by overflow in channel cloning][36104]\n+* [Zero first byte of CString on drop][36264]\n+* [Inherit overflow checks for sum and product][36372]\n+* [Add missing Eq implementations][36423]\n+* [Implement `Debug` for `DirEntry`][36631]\n+* [When `getaddrinfo` returns `EAI_SYSTEM` retrieve actual error from\n+  `errno`][36754]\n+* [`SipHasher`] is deprecated. Use [`DefaultHasher`].\n+* [Implement more traits for `std::io::ErrorKind`][35911]\n+* [Optimize BinaryHeap bounds checking][36072]\n+* [Work around pointer aliasing issue in `Vec::extend_from_slice`,\n+  `extend_with_element`][36355]\n+* [Fix overflow checking in unsigned pow()][34942]\n+\n+Cargo\n+-----\n+\n+* This release includes security fixes to both curl and OpenSSL.\n+* [Fix transitive doctests when panic=abort][cargo/3021]\n+* [Add --all-features flag to cargo][cargo/3038]\n+* [Reject path-based dependencies in `cargo package`][cargo/3060]\n+* [Don't parse the home directory more than once][cargo/3078]\n+* [Don't try to generate Cargo.lock on empty workspaces][cargo/3092]\n+* [Update OpenSSL to 1.0.2j][cargo/3121]\n+* [Add license and license_file to cargo metadata output][cargo/3110]\n+* [Make crates-io registry URL optional in config; ignore all changes to\n+  source.crates-io][cargo/3089]\n+* [Don't download dependencies from other platforms][cargo/3123]\n+* [Build transitive dev-dependencies when needed][cargo/3125]\n+* [Add support for per-target rustflags in .cargo/config][cargo/3157]\n+* [Avoid updating registry when adding existing deps][cargo/3144]\n+* [Warn about path overrides that won't work][cargo/3136]\n+* [Use workspaces during `cargo install`][cargo/3146]\n+* [Leak mspdbsrv.exe processes on Windows][cargo/3162]\n+* [Add --message-format flag][cargo/3000]\n+* [Pass target environment for rustdoc][cargo/3205]\n+* [Use `CommandExt::exec` for `cargo run` on Unix][cargo/2818]\n+* [Update curl and curl-sys][cargo/3241]\n+* [Call rustdoc test with the correct cfg flags of a package][cargo/3242]\n+\n+Tooling\n+-------\n+\n+* [rustdoc: Add the `--sysroot` argument][36586]\n+* [rustdoc: Fix a couple of issues with the search results][35655]\n+* [rustdoc: remove the `!` from macro URLs and titles][35234]\n+* [gdb: Fix pretty-printing special-cased Rust types][35585]\n+* [rustdoc: Filter more incorrect methods inherited through Deref][36266]\n+\n+Misc\n+----\n+\n+* [Remove unmaintained style guide][35124]\n+* [Add s390x support][36369]\n+* [Initial work at Haiku OS support][36727]\n+* [Add mips-uclibc targets][35734]\n+* [Crate-ify compiler-rt into compiler-builtins][35021]\n+* [Add rustc version info (git hash + date) to dist tarball][36213]\n+* Many documentation improvements\n+\n+Compatibility Notes\n+-------------------\n+\n+* [`SipHasher`] is deprecated. Use [`DefaultHasher`].\n+* [Deny (by default) transmuting from fn item types to pointer-sized\n+  types][34923]. Continuing the long transition to zero-sized fn items,\n+  per [RFC 401].\n+* [Fix `#[derive]` for empty tuple structs/variants][35728].\n+  Part of [RFC 1506].\n+* [Issue deprecation warnings for safe accesses to extern statics][36173]\n+* [Fix lifetime rules for 'if' conditions][36029].\n+* [Inherit overflow checks for sum and product][36372].\n+* [Forbid user-defined macros named \"macro_rules\"][36730].\n+\n+[33922]: https://github.com/rust-lang/rust/pull/33922\n+[34623]: https://github.com/rust-lang/rust/pull/34623\n+[34923]: https://github.com/rust-lang/rust/pull/34923\n+[34942]: https://github.com/rust-lang/rust/pull/34942\n+[34982]: https://github.com/rust-lang/rust/pull/34982\n+[35021]: https://github.com/rust-lang/rust/pull/35021\n+[35048]: https://github.com/rust-lang/rust/pull/35048\n+[35074]: https://github.com/rust-lang/rust/pull/35074\n+[35124]: https://github.com/rust-lang/rust/pull/35124\n+[35234]: https://github.com/rust-lang/rust/pull/35234\n+[35238]: https://github.com/rust-lang/rust/pull/35238\n+[35354]: https://github.com/rust-lang/rust/pull/35354\n+[35559]: https://github.com/rust-lang/rust/pull/35559\n+[35585]: https://github.com/rust-lang/rust/pull/35585\n+[35627]: https://github.com/rust-lang/rust/pull/35627\n+[35655]: https://github.com/rust-lang/rust/pull/35655\n+[35702]: https://github.com/rust-lang/rust/pull/35702\n+[35707]: https://github.com/rust-lang/rust/pull/35707\n+[35728]: https://github.com/rust-lang/rust/pull/35728\n+[35734]: https://github.com/rust-lang/rust/pull/35734\n+[35755]: https://github.com/rust-lang/rust/pull/35755\n+[35761]: https://github.com/rust-lang/rust/pull/35761\n+[35764]: https://github.com/rust-lang/rust/pull/35764\n+[35814]: https://github.com/rust-lang/rust/pull/35814\n+[35854]: https://github.com/rust-lang/rust/pull/35854\n+[35871]: https://github.com/rust-lang/rust/pull/35871\n+[35884]: https://github.com/rust-lang/rust/pull/35884\n+[35911]: https://github.com/rust-lang/rust/pull/35911\n+[35969]: https://github.com/rust-lang/rust/pull/35969\n+[35975]: https://github.com/rust-lang/rust/pull/35975\n+[36004]: https://github.com/rust-lang/rust/pull/36004\n+[36008]: https://github.com/rust-lang/rust/pull/36008\n+[36014]: https://github.com/rust-lang/rust/pull/36014\n+[36029]: https://github.com/rust-lang/rust/pull/36029\n+[36059]: https://github.com/rust-lang/rust/pull/36059\n+[36072]: https://github.com/rust-lang/rust/pull/36072\n+[36101]: https://github.com/rust-lang/rust/pull/36101\n+[36104]: https://github.com/rust-lang/rust/pull/36104\n+[36171]: https://github.com/rust-lang/rust/pull/36171\n+[36173]: https://github.com/rust-lang/rust/pull/36173\n+[36178]: https://github.com/rust-lang/rust/pull/36178\n+[36213]: https://github.com/rust-lang/rust/pull/36213\n+[36214]: https://github.com/rust-lang/rust/pull/36214\n+[36264]: https://github.com/rust-lang/rust/pull/36264\n+[36266]: https://github.com/rust-lang/rust/pull/36266\n+[36289]: https://github.com/rust-lang/rust/pull/36289\n+[36338]: https://github.com/rust-lang/rust/pull/36338\n+[36351]: https://github.com/rust-lang/rust/pull/36351\n+[36355]: https://github.com/rust-lang/rust/pull/36355\n+[36369]: https://github.com/rust-lang/rust/pull/36369\n+[36372]: https://github.com/rust-lang/rust/pull/36372\n+[36423]: https://github.com/rust-lang/rust/pull/36423\n+[36482]: https://github.com/rust-lang/rust/pull/36482\n+[36505]: https://github.com/rust-lang/rust/pull/36505\n+[36524]: https://github.com/rust-lang/rust/pull/36524\n+[36527]: https://github.com/rust-lang/rust/pull/36527\n+[36551]: https://github.com/rust-lang/rust/pull/36551\n+[36574]: https://github.com/rust-lang/rust/pull/36574\n+[36586]: https://github.com/rust-lang/rust/pull/36586\n+[36592]: https://github.com/rust-lang/rust/pull/36592\n+[36631]: https://github.com/rust-lang/rust/pull/36631\n+[36639]: https://github.com/rust-lang/rust/pull/36639\n+[36721]: https://github.com/rust-lang/rust/pull/36721\n+[36727]: https://github.com/rust-lang/rust/pull/36727\n+[36730]: https://github.com/rust-lang/rust/pull/36730\n+[36734]: https://github.com/rust-lang/rust/pull/36734\n+[36754]: https://github.com/rust-lang/rust/pull/36754\n+[36995]: https://github.com/rust-lang/rust/pull/36995\n+[RFC 0016]: https://github.com/rust-lang/rfcs/blob/master/text/0016-more-attributes.md\n+[RFC 0243]: https://github.com/rust-lang/rfcs/blob/master/text/0243-trait-based-exception-handling.md\n+[RFC 1506]: https://github.com/rust-lang/rfcs/blob/master/text/1506-adt-kinds.md\n+[RFC 401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n+[RFC 873]: https://github.com/rust-lang/rfcs/blob/master/text/0873-type-macros.md\n+[cargo/2818]: https://github.com/rust-lang/cargo/pull/2818\n+[cargo/3000]: https://github.com/rust-lang/cargo/pull/3000\n+[cargo/3021]: https://github.com/rust-lang/cargo/pull/3021\n+[cargo/3038]: https://github.com/rust-lang/cargo/pull/3038\n+[cargo/3060]: https://github.com/rust-lang/cargo/pull/3060\n+[cargo/3078]: https://github.com/rust-lang/cargo/pull/3078\n+[cargo/3089]: https://github.com/rust-lang/cargo/pull/3089\n+[cargo/3092]: https://github.com/rust-lang/cargo/pull/3092\n+[cargo/3110]: https://github.com/rust-lang/cargo/pull/3110\n+[cargo/3121]: https://github.com/rust-lang/cargo/pull/3121\n+[cargo/3123]: https://github.com/rust-lang/cargo/pull/3123\n+[cargo/3125]: https://github.com/rust-lang/cargo/pull/3125\n+[cargo/3136]: https://github.com/rust-lang/cargo/pull/3136\n+[cargo/3144]: https://github.com/rust-lang/cargo/pull/3144\n+[cargo/3146]: https://github.com/rust-lang/cargo/pull/3146\n+[cargo/3157]: https://github.com/rust-lang/cargo/pull/3157\n+[cargo/3162]: https://github.com/rust-lang/cargo/pull/3162\n+[cargo/3205]: https://github.com/rust-lang/cargo/pull/3205\n+[cargo/3241]: https://github.com/rust-lang/cargo/pull/3241\n+[cargo/3242]: https://github.com/rust-lang/cargo/pull/3242\n+[rustup]: https://www.rustup.rs\n+[`checked_abs`]: https://doc.rust-lang.org/std/primitive.i32.html#method.checked_abs\n+[`wrapping_abs`]: https://doc.rust-lang.org/std/primitive.i32.html#method.wrapping_abs\n+[`overflowing_abs`]: https://doc.rust-lang.org/std/primitive.i32.html#method.overflowing_abs\n+[`RefCell::try_borrow`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.try_borrow\n+[`RefCell::try_borrow_mut`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.try_borrow_mut\n+[`SipHasher`]: https://doc.rust-lang.org/std/hash/struct.SipHasher.html\n+[`DefaultHasher`]: https://doc.rust-lang.org/std/collections/hash_map/struct.DefaultHasher.html\n+\n+\n Version 1.12.1 (2016-10-20)\n ===========================\n "}, {"sha": "98567a03c28a9804edb13c6448918dde719ccd89", "filename": "mk/cfg/armv5te-unknown-linux-gnueabi.mk", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/mk%2Fcfg%2Farmv5te-unknown-linux-gnueabi.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/mk%2Fcfg%2Farmv5te-unknown-linux-gnueabi.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farmv5te-unknown-linux-gnueabi.mk?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,26 @@\n+# armv5-unknown-linux-gnueabi configuration\n+CROSS_PREFIX_armv5te-unknown-linux-gnueabi=arm-linux-gnueabi-\n+CC_armv5te-unknown-linux-gnueabi=gcc\n+CXX_armv5te-unknown-linux-gnueabi=g++\n+CPP_armv5te-unknown-linux-gnueabi=gcc -E\n+AR_armv5te-unknown-linux-gnueabi=ar\n+CFG_LIB_NAME_armv5te-unknown-linux-gnueabi=lib$(1).so\n+CFG_STATIC_LIB_NAME_armv5te-unknown-linux-gnueabi=lib$(1).a\n+CFG_LIB_GLOB_armv5te-unknown-linux-gnueabi=lib$(1)-*.so\n+CFG_LIB_DSYM_GLOB_armv5te-unknown-linux-gnueabi=lib$(1)-*.dylib.dSYM\n+CFG_JEMALLOC_CFLAGS_armv5te-unknown-linux-gnueabi := -D__arm__ -mfloat-abi=soft  $(CFLAGS) -march=armv5te -marm\n+CFG_GCCISH_CFLAGS_armv5te-unknown-linux-gnueabi := -Wall -g -fPIC -D__arm__ -mfloat-abi=soft $(CFLAGS) -march=armv5te -marm\n+CFG_GCCISH_CXXFLAGS_armv5te-unknown-linux-gnueabi := -fno-rtti $(CXXFLAGS)\n+CFG_GCCISH_LINK_FLAGS_armv5te-unknown-linux-gnueabi := -shared -fPIC -g\n+CFG_GCCISH_DEF_FLAG_armv5te-unknown-linux-gnueabi := -Wl,--export-dynamic,--dynamic-list=\n+CFG_LLC_FLAGS_armv5te-unknown-linux-gnueabi :=\n+CFG_INSTALL_NAME_ar,-unknown-linux-gnueabi =\n+CFG_EXE_SUFFIX_armv5te-unknown-linux-gnueabi :=\n+CFG_WINDOWSY_armv5te-unknown-linux-gnueabi :=\n+CFG_UNIXY_armv5te-unknown-linux-gnueabi := 1\n+CFG_LDPATH_armv5te-unknown-linux-gnueabi :=\n+CFG_RUN_armv5te-unknown-linux-gnueabi=$(2)\n+CFG_RUN_TARG_armv5te-unknown-linux-gnueabi=$(call CFG_RUN_armv5te-unknown-linux-gnueabi,,$(2))\n+RUSTC_FLAGS_armv5te-unknown-linux-gnueabi :=\n+RUSTC_CROSS_FLAGS_armv5te-unknown-linux-gnueabi :=\n+CFG_GNU_TRIPLE_armv5te-unknown-linux-gnueabi := armv5te-unknown-linux-gnueabi"}, {"sha": "7ae5846c54b9965b8f26d6db7eca6d26bd0d8cdf", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -100,7 +100,7 @@ DEPS_serialize := std log\n DEPS_term := std\n DEPS_test := std getopts term native:rust_test_helpers\n \n-DEPS_syntax := std term serialize log arena libc rustc_bitflags rustc_unicode rustc_errors syntax_pos\n+DEPS_syntax := std term serialize log arena libc rustc_bitflags rustc_unicode rustc_errors syntax_pos rustc_data_structures\n DEPS_syntax_ext := syntax syntax_pos rustc_errors fmt_macros proc_macro\n DEPS_syntax_pos := serialize\n DEPS_proc_macro_tokens := syntax syntax_pos log"}, {"sha": "07b52593781cf26f7983aa94a2518e9a847d0938", "filename": "mk/main.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -13,7 +13,7 @@\n ######################################################################\n \n # The version number\n-CFG_RELEASE_NUM=1.14.0\n+CFG_RELEASE_NUM=1.15.0\n \n # An optional number to put after the label, e.g. '.2' -> '-beta.2'\n # NB Make sure it starts with a dot to conform to semver pre-release"}, {"sha": "35ee7697a7a6974da5e9204d5a26933d0a5a2b35", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -697,6 +697,8 @@ CTEST_DEPS_ui_$(1)-T-$(2)-H-$(3) = $$(UI_TESTS)\n CTEST_DEPS_mir-opt_$(1)-T-$(2)-H-$(3) = $$(MIR_OPT_TESTS)\n CTEST_DEPS_rustdocck_$(1)-T-$(2)-H-$(3) = $$(RUSTDOCCK_TESTS) \\\n \t\t$$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3)) \\\n+\t\t$$(CSREQ$(1)_T_$(3)_H_$(3)) \\\n+\t\t$$(SREQ$(1)_T_$(3)_H_$(3)) \\\n \t\t$(S)src/etc/htmldocck.py\n \n endef"}, {"sha": "ee38a043b122cd5d78a7598c7e2a3d3afb59d7f1", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -621,6 +621,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"log 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax_pos 0.0.0\","}, {"sha": "a3fabbb3e80941dad383635d58c3dba09f4b2c32", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -226,13 +226,16 @@ def cargo(self):\n         config = self.get_toml('cargo')\n         if config:\n             return config\n+        config = self.get_mk('CFG_LOCAL_RUST_ROOT')\n+        if config:\n+            return config + '/bin/cargo' + self.exe_suffix()\n         return os.path.join(self.bin_root(), \"bin/cargo\" + self.exe_suffix())\n \n     def rustc(self):\n         config = self.get_toml('rustc')\n         if config:\n             return config\n-        config = self.get_mk('CFG_LOCAL_RUST')\n+        config = self.get_mk('CFG_LOCAL_RUST_ROOT')\n         if config:\n             return config + '/bin/rustc' + self.exe_suffix()\n         return os.path.join(self.bin_root(), \"bin/rustc\" + self.exe_suffix())"}, {"sha": "a630aaf8af48439165b8d0030c3c8513f6e36ba1", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -50,6 +50,7 @@ pub struct Config {\n     // llvm codegen options\n     pub llvm_assertions: bool,\n     pub llvm_optimize: bool,\n+    pub llvm_release_debuginfo: bool,\n     pub llvm_version_check: bool,\n     pub llvm_static_stdcpp: bool,\n \n@@ -137,6 +138,7 @@ struct Llvm {\n     ninja: Option<bool>,\n     assertions: Option<bool>,\n     optimize: Option<bool>,\n+    release_debuginfo: Option<bool>,\n     version_check: Option<bool>,\n     static_libstdcpp: Option<bool>,\n }\n@@ -243,6 +245,7 @@ impl Config {\n             set(&mut config.ninja, llvm.ninja);\n             set(&mut config.llvm_assertions, llvm.assertions);\n             set(&mut config.llvm_optimize, llvm.optimize);\n+            set(&mut config.llvm_release_debuginfo, llvm.release_debuginfo);\n             set(&mut config.llvm_version_check, llvm.version_check);\n             set(&mut config.llvm_static_stdcpp, llvm.static_libstdcpp);\n         }"}, {"sha": "1388dab303a44ee6755ebe495afc7ccf425ac135", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -17,6 +17,9 @@\n # Indicates whether the LLVM build is a Release or Debug build\n #optimize = true\n \n+# Indicates whether an LLVM Release build should include debug info\n+#release-debuginfo = false\n+\n # Indicates whether the LLVM assertions are enabled or not\n #assertions = false\n "}, {"sha": "1e73595ec998387d64014d21b08831bd77899399", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -57,6 +57,9 @@ else\n \t$(Q)$(BOOTSTRAP) dist --install $(BOOTSTRAP_ARGS)\n endif\n tidy:\n-\t$(Q)$(BOOTSTRAP) test src/tools/tidy $(BOOTSTRAP_ARGS)\n+\t$(Q)$(BOOTSTRAP) test src/tools/tidy $(BOOTSTRAP_ARGS) --stage 0\n+\n+check-stage2-android:\n+\t$(Q)$(BOOTSTRAP) --step check-target --target arm-linux-androideabi\n \n .PHONY: dist"}, {"sha": "358cfac74277778497d6476ee0f1e918d320fa17", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -67,10 +67,17 @@ pub fn llvm(build: &Build, target: &str) {\n     if build.config.ninja {\n         cfg.generator(\"Ninja\");\n     }\n+\n+    let profile = match (build.config.llvm_optimize, build.config.llvm_release_debuginfo) {\n+        (false, _) => \"Debug\",\n+        (true, false) => \"Release\",\n+        (true, true) => \"RelWithDebInfo\",\n+    };\n+\n     cfg.target(target)\n        .host(&build.config.build)\n        .out_dir(&dst)\n-       .profile(if build.config.llvm_optimize {\"Release\"} else {\"Debug\"})\n+       .profile(profile)\n        .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n        .define(\"LLVM_TARGETS_TO_BUILD\", \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend\")\n        .define(\"LLVM_INCLUDE_EXAMPLES\", \"OFF\")"}, {"sha": "c5b70c227c4080c5e2c7ab307f21668f75054eb5", "filename": "src/ci/docker/arm-android/Dockerfile", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2FDockerfile?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,46 @@\n+FROM ubuntu:16.04\n+\n+RUN dpkg --add-architecture i386 && \\\n+    apt-get update && \\\n+    apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  python-minimal \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  unzip \\\n+  expect \\\n+  openjdk-9-jre \\\n+  sudo \\\n+  libstdc++6:i386\n+\n+WORKDIR /android/\n+ENV PATH=$PATH:/android/ndk-arm-9/bin:/android/sdk/tools:/android/sdk/platform-tools\n+\n+COPY install-ndk.sh install-sdk.sh accept-licenses.sh /android/\n+RUN sh /android/install-ndk.sh\n+RUN sh /android/install-sdk.sh\n+\n+COPY start-emulator.sh /android/\n+ENTRYPOINT [\"/android/start-emulator.sh\"]\n+\n+ENV TARGETS=arm-linux-androideabi\n+ENV TARGETS=$TARGETS,i686-linux-android\n+ENV TARGETS=$TARGETS,aarch64-linux-android\n+ENV TARGETS=$TARGETS,armv7-linux-androideabi\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+      --target=$TARGETS \\\n+      --arm-linux-androideabi-ndk=/android/ndk-arm-9 \\\n+      --armv7-linux-androideabi-ndk=/android/ndk-arm-9 \\\n+      --i686-linux-android-ndk=/android/ndk-x86-9 \\\n+      --aarch64-linux-android-ndk=/android/ndk-aarch64 \\\n+      --enable-rustbuild\n+ENV RUST_CHECK_TARGET check-stage2-android\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "8d8f60a5ec2604606571cdb6a7d231d5754aa38f", "filename": "src/ci/docker/arm-android/accept-licenses.sh", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Farm-android%2Faccept-licenses.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Farm-android%2Faccept-licenses.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2Faccept-licenses.sh?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,15 @@\n+#!/usr/bin/expect -f\n+# ignore-license\n+\n+set timeout 1800\n+set cmd [lindex $argv 0]\n+set licenses [lindex $argv 1]\n+\n+spawn {*}$cmd\n+expect {\n+  \"Do you accept the license '*'*\" {\n+        exp_send \"y\\r\"\n+        exp_continue\n+  }\n+  eof\n+}"}, {"sha": "418ce69c5b1e5769e252034b918afa427dcfd2d6", "filename": "src/ci/docker/arm-android/install-ndk.sh", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Farm-android%2Finstall-ndk.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Farm-android%2Finstall-ndk.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2Finstall-ndk.sh?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,45 @@\n+#!/bin/sh\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+cpgdb() {\n+  cp android-ndk-r11c/prebuilt/linux-x86_64/bin/gdb /android/$1/bin/$2-gdb\n+  cp android-ndk-r11c/prebuilt/linux-x86_64/bin/gdb-orig /android/$1/bin/gdb-orig\n+  cp -r android-ndk-r11c/prebuilt/linux-x86_64/share /android/$1/share\n+}\n+\n+# Prep the Android NDK\n+#\n+# See https://github.com/servo/servo/wiki/Building-for-Android\n+curl -O https://dl.google.com/android/repository/android-ndk-r11c-linux-x86_64.zip\n+unzip -q android-ndk-r11c-linux-x86_64.zip\n+bash android-ndk-r11c/build/tools/make-standalone-toolchain.sh \\\n+        --platform=android-9 \\\n+        --toolchain=arm-linux-androideabi-4.9 \\\n+        --install-dir=/android/ndk-arm-9 \\\n+        --ndk-dir=/android/android-ndk-r11c \\\n+        --arch=arm\n+cpgdb ndk-arm-9 arm-linux-androideabi\n+bash android-ndk-r11c/build/tools/make-standalone-toolchain.sh \\\n+        --platform=android-21 \\\n+        --toolchain=aarch64-linux-android-4.9 \\\n+        --install-dir=/android/ndk-aarch64 \\\n+        --ndk-dir=/android/android-ndk-r11c \\\n+        --arch=arm64\n+bash android-ndk-r11c/build/tools/make-standalone-toolchain.sh \\\n+        --platform=android-9 \\\n+        --toolchain=x86-4.9 \\\n+        --install-dir=/android/ndk-x86-9 \\\n+        --ndk-dir=/android/android-ndk-r11c \\\n+        --arch=x86\n+\n+rm -rf ./android-ndk-r11c-linux-x86_64.zip ./android-ndk-r11c"}, {"sha": "2db1d46ba2273e89cfdb655ba59ef427ba0974ba", "filename": "src/ci/docker/arm-android/install-sdk.sh", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Farm-android%2Finstall-sdk.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Farm-android%2Finstall-sdk.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2Finstall-sdk.sh?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,33 @@\n+#!/bin/sh\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+# Prep the SDK and emulator\n+#\n+# Note that the update process requires that we accept a bunch of licenses, and\n+# we can't just pipe `yes` into it for some reason, so we take the same strategy\n+# located in https://github.com/appunite/docker by just wrapping it in a script\n+# which apparently magically accepts the licenses.\n+\n+mkdir sdk\n+curl https://dl.google.com/android/android-sdk_r24.4-linux.tgz | \\\n+    tar xzf - -C sdk --strip-components=1\n+\n+filter=\"platform-tools,android-18\"\n+filter=\"$filter,sys-img-armeabi-v7a-android-18\"\n+\n+./accept-licenses.sh \"android - update sdk -a --no-ui --filter $filter\"\n+\n+echo \"no\" | android create avd \\\n+                --name arm-18 \\\n+                --target android-18 \\\n+                --abi armeabi-v7a"}, {"sha": "93f20b28b8689e4d37ce95bc648f174f8558353d", "filename": "src/ci/docker/arm-android/start-emulator.sh", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Farm-android%2Fstart-emulator.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Farm-android%2Fstart-emulator.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2Fstart-emulator.sh?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,15 @@\n+#!/bin/sh\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+ANDROID_EMULATOR_FORCE_32BIT=true \\\n+  emulator @arm-18 -no-window -partition-size 2047 &\n+exec \"$@\""}, {"sha": "d8af878a95863f05dd32c5193f42ec3f37ef225b", "filename": "src/ci/docker/cross/Dockerfile", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross%2FDockerfile?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,66 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  python-minimal \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  sudo \\\n+  gcc-aarch64-linux-gnu libc6-dev-arm64-cross \\\n+  gcc-arm-linux-gnueabi libc6-dev-armel-cross \\\n+  gcc-arm-linux-gnueabihf libc6-dev-armhf-cross \\\n+  gcc-mips-linux-gnu libc6-dev-mips-cross \\\n+  gcc-mipsel-linux-gnu libc6-dev-mipsel-cross \\\n+  gcc-mips64-linux-gnuabi64 libc6-dev-mips64-cross \\\n+  gcc-mips64el-linux-gnuabi64 libc6-dev-mips64el-cross \\\n+  gcc-powerpc-linux-gnu libc6-dev-powerpc-cross \\\n+  gcc-powerpc64-linux-gnu libc6-dev-ppc64-cross \\\n+  gcc-powerpc64le-linux-gnu libc6-dev-ppc64el-cross \\\n+  gcc-s390x-linux-gnu libc6-dev-s390x-cross\n+\n+ENV TARGETS=aarch64-unknown-linux-gnu\n+ENV TARGETS=$TARGETS,arm-unknown-linux-gnueabi\n+ENV TARGETS=$TARGETS,arm-unknown-linux-gnueabihf\n+ENV TARGETS=$TARGETS,armv7-unknown-linux-gnueabihf\n+ENV TARGETS=$TARGETS,asmjs-unknown-emscripten\n+ENV TARGETS=$TARGETS,mips-unknown-linux-gnu\n+ENV TARGETS=$TARGETS,mips64-unknown-linux-gnuabi64\n+ENV TARGETS=$TARGETS,mips64el-unknown-linux-gnuabi64\n+ENV TARGETS=$TARGETS,mipsel-unknown-linux-gnu\n+ENV TARGETS=$TARGETS,powerpc-unknown-linux-gnu\n+ENV TARGETS=$TARGETS,powerpc64-unknown-linux-gnu\n+ENV TARGETS=$TARGETS,powerpc64le-unknown-linux-gnu\n+ENV TARGETS=$TARGETS,s390x-unknown-linux-gnu\n+ENV TARGETS=$TARGETS,wasm32-unknown-emscripten\n+\n+#ENV TARGETS=$TARGETS,mips-unknown-linux-musl\n+#ENV TARGETS=$TARGETS,arm-unknown-linux-musleabi\n+#ENV TARGETS=$TARGETS,arm-unknown-linux-musleabihf\n+#ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n+#ENV TARGETS=$TARGETS,x86_64-rumprun-netbsd\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+      --target=$TARGETS \\\n+      --enable-rustbuild\n+ENV RUST_CHECK_TARGET \"\"\n+\n+ENV AR_s390x_unknown_linux_gnu=s390x-linux-gnu-ar \\\n+    CC_s390x_unknown_linux_gnu=s390x-linux-gnu-gcc \\\n+    AR_mips64_unknown_linux_gnuabi64=mips64-linux-gnuabi64-ar \\\n+    CC_mips64_unknown_linux_gnuabi64=mips64-linux-gnuabi64-gcc \\\n+    AR_mips64el_unknown_linux_gnuabi64=mips64el-linux-gnuabi64-ar \\\n+    CC_mips64el_unknown_linux_gnuabi64=mips64el-linux-gnuabi64-gcc \\\n+    AR_powerpc64_unknown_linux_gnu=powerpc64-linux-gnu-ar \\\n+    CC_powerpc64_unknown_linux_gnu=powerpc64-linux-gnu-gcc\n+\n+# FIXME(rust-lang/rust#36150): powerpc unfortunately aborts right now\n+ENV NO_LLVM_ASSERTIONS=1\n+\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "a9ef29daaf1a18cd0bd46bc2666d5bc6462c5319", "filename": "src/ci/docker/i686-gnu-nopt/Dockerfile", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,19 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++-multilib \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  sudo \\\n+  gdb\n+\n+ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu --disable-optimize-tests\n+ENV RUST_CHECK_TARGET check\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "d0ddde95b447364f241f3f22caeff6be833ea087", "filename": "src/ci/docker/i686-gnu/Dockerfile", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,19 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++-multilib \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  sudo \\\n+  gdb\n+\n+ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu\n+ENV RUST_CHECK_TARGET check\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "c5b1d00fb7cc18420eddbd237b666d0f90ced724", "filename": "src/ci/docker/run.sh", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,42 @@\n+#!/bin/sh\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -e\n+\n+script=`cd $(dirname $0) && pwd`/`basename $0`\n+image=$1\n+\n+docker_dir=\"`dirname $script`\"\n+ci_dir=\"`dirname $docker_dir`\"\n+src_dir=\"`dirname $ci_dir`\"\n+root_dir=\"`dirname $src_dir`\"\n+\n+docker build \\\n+  --rm \\\n+  -t rust-ci \\\n+  \"`dirname \"$script\"`/$image\"\n+\n+mkdir -p $HOME/.ccache\n+mkdir -p $HOME/.cargo\n+\n+exec docker run \\\n+  --volume \"$root_dir:/checkout:ro\" \\\n+  --workdir /tmp/obj \\\n+  --env SRC=/checkout \\\n+  --env CCACHE_DIR=/ccache \\\n+  --volume \"$HOME/.ccache:/ccache\" \\\n+  --env CARGO_HOME=/cargo \\\n+  --env LOCAL_USER_ID=`id -u` \\\n+  --volume \"$HOME/.cargo:/cargo\" \\\n+  --interactive \\\n+  --tty \\\n+  rust-ci \\\n+  /checkout/src/ci/run.sh"}, {"sha": "dc16c39961c45e25af2d643f04e1831ce6ff05ae", "filename": "src/ci/docker/x86_64-freebsd/Dockerfile", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,29 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  python-minimal \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  sudo \\\n+  bzip2 \\\n+  xz-utils \\\n+  wget\n+\n+COPY build-toolchain.sh /tmp/\n+RUN sh /tmp/build-toolchain.sh\n+\n+ENV \\\n+    AR_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-ar \\\n+    CC_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-gcc\n+\n+ENV RUST_CONFIGURE_ARGS --target=x86_64-unknown-freebsd --enable-rustbuild\n+ENV RUST_CHECK_TARGET \"\"\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "d4bc886d50ea4952231782ff5835f634b9bebc6e", "filename": "src/ci/docker/x86_64-freebsd/build-toolchain.sh", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-freebsd%2Fbuild-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-freebsd%2Fbuild-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-freebsd%2Fbuild-toolchain.sh?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,96 @@\n+#!/bin/bash\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+ARCH=x86_64\n+BINUTILS=2.25.1\n+GCC=5.3.0\n+\n+mkdir binutils\n+cd binutils\n+\n+# First up, build binutils\n+curl https://ftp.gnu.org/gnu/binutils/binutils-$BINUTILS.tar.bz2 | tar xjf -\n+mkdir binutils-build\n+cd binutils-build\n+../binutils-$BINUTILS/configure \\\n+  --target=$ARCH-unknown-freebsd10\n+make -j10\n+make install\n+cd ../..\n+rm -rf binutils\n+\n+# Next, download the FreeBSD libc and relevant header files\n+\n+mkdir freebsd\n+case \"$ARCH\" in\n+    x86_64)\n+        URL=ftp://ftp.freebsd.org/pub/FreeBSD/releases/amd64/10.2-RELEASE/base.txz\n+        ;;\n+    i686)\n+        URL=ftp://ftp.freebsd.org/pub/FreeBSD/releases/i386/10.2-RELEASE/base.txz\n+        ;;\n+esac\n+curl $URL | tar xJf - -C freebsd ./usr/include ./usr/lib ./lib\n+\n+dst=/usr/local/$ARCH-unknown-freebsd10\n+\n+cp -r freebsd/usr/include $dst/\n+cp freebsd/usr/lib/crt1.o $dst/lib\n+cp freebsd/usr/lib/Scrt1.o $dst/lib\n+cp freebsd/usr/lib/crti.o $dst/lib\n+cp freebsd/usr/lib/crtn.o $dst/lib\n+cp freebsd/usr/lib/libc.a $dst/lib\n+cp freebsd/usr/lib/libutil.a $dst/lib\n+cp freebsd/usr/lib/libutil_p.a $dst/lib\n+cp freebsd/usr/lib/libm.a $dst/lib\n+cp freebsd/usr/lib/librt.so.1 $dst/lib\n+cp freebsd/usr/lib/libexecinfo.so.1 $dst/lib\n+cp freebsd/lib/libc.so.7 $dst/lib\n+cp freebsd/lib/libm.so.5 $dst/lib\n+cp freebsd/lib/libutil.so.9 $dst/lib\n+cp freebsd/lib/libthr.so.3 $dst/lib/libpthread.so\n+\n+ln -s libc.so.7 $dst/lib/libc.so\n+ln -s libm.so.5 $dst/lib/libm.so\n+ln -s librt.so.1 $dst/lib/librt.so\n+ln -s libutil.so.9 $dst/lib/libutil.so\n+ln -s libexecinfo.so.1 $dst/lib/libexecinfo.so\n+rm -rf freebsd\n+\n+# Finally, download and build gcc to target FreeBSD\n+mkdir gcc\n+cd gcc\n+curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.bz2 | tar xjf -\n+cd gcc-$GCC\n+./contrib/download_prerequisites\n+\n+mkdir ../gcc-build\n+cd ../gcc-build\n+../gcc-$GCC/configure                            \\\n+  --enable-languages=c                           \\\n+  --target=$ARCH-unknown-freebsd10               \\\n+  --disable-multilib                             \\\n+  --disable-nls                                  \\\n+  --disable-libgomp                              \\\n+  --disable-libquadmath                          \\\n+  --disable-libssp                               \\\n+  --disable-libvtv                               \\\n+  --disable-libcilkrts                           \\\n+  --disable-libada                               \\\n+  --disable-libsanitizer                         \\\n+  --disable-libquadmath-support                  \\\n+  --disable-lto\n+make -j10\n+make install\n+cd ../..\n+rm -rf gcc"}, {"sha": "1db01f2b48d4691f3faee775c64fc1d0c38e9b33", "filename": "src/ci/docker/x86_64-gnu-cargotest/Dockerfile", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,20 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  python-minimal \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  libssl-dev \\\n+  sudo\n+\n+ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --enable-rustbuild\n+ENV RUST_CHECK_TARGET check-cargotest\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "9e98215775e51719c37ca28901a0581c2975d48a", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,22 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  sudo \\\n+  gdb\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+      --build=x86_64-unknown-linux-gnu \\\n+      --enable-debug \\\n+      --enable-optimize\n+ENV RUST_CHECK_TARGET \"\"\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "ca06940ae5e2dc7c665b0f7b6ee779e84f868447", "filename": "src/ci/docker/x86_64-gnu-llvm-3.7/Dockerfile", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,26 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  python2.7-minimal \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  sudo \\\n+  gdb \\\n+  llvm-3.7-tools \\\n+  libedit-dev \\\n+  zlib1g-dev\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+      --build=x86_64-unknown-linux-gnu \\\n+      --enable-rustbuild \\\n+      --llvm-root=/usr/lib/llvm-3.7\n+ENV RUST_CHECK_TARGET check\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "73a3e2c726cee601bfb2c16ab1fed5cd272d27bb", "filename": "src/ci/docker/x86_64-gnu-nopt/Dockerfile", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,19 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  sudo \\\n+  gdb\n+\n+ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --disable-optimize-tests\n+ENV RUST_CHECK_TARGET check\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "d4d0492e2a26049f5f0bb57d475a1ba859643410", "filename": "src/ci/docker/x86_64-gnu-rustbuild/Dockerfile", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-gnu-rustbuild%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-gnu-rustbuild%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-rustbuild%2FDockerfile?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,20 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  python-minimal \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  sudo \\\n+  gdb\n+\n+ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --enable-rustbuild\n+ENV RUST_CHECK_TARGET check\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "f125693e7ae1a17468fa97e4e7a9eef1b0ae0c45", "filename": "src/ci/docker/x86_64-gnu/Dockerfile", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,19 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  sudo \\\n+  gdb\n+\n+ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n+ENV RUST_CHECK_TARGET check\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "1afaef2e056781fa1b530a045622bd9683fe1b84", "filename": "src/ci/docker/x86_64-musl/Dockerfile", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,27 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  xz-utils \\\n+  sudo \\\n+  gdb\n+\n+WORKDIR /build/\n+COPY build-musl.sh /build/\n+RUN sh /build/build-musl.sh && rm -rf /build\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+      --target=x86_64-unknown-linux-musl \\\n+      --musl-root=/musl-x86_64\n+ENV RUST_CHECK_TARGET check-stage2-T-x86_64-unknown-linux-musl-H-x86_64-unknown-linux-gnu\n+\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "2bfbd646b75c8e050d934bd8bb06ed291ee7f9c8", "filename": "src/ci/docker/x86_64-musl/build-musl.sh", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-musl%2Fbuild-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Fdocker%2Fx86_64-musl%2Fbuild-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-musl%2Fbuild-musl.sh?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,33 @@\n+#!/bin/sh\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+export CFLAGS=\"-fPIC\"\n+MUSL=musl-1.1.14\n+curl https://www.musl-libc.org/releases/$MUSL.tar.gz | tar xzf -\n+cd $MUSL\n+./configure --prefix=/musl-x86_64 --disable-shared\n+make -j10\n+make install\n+make clean\n+cd ..\n+\n+# To build MUSL we're going to need a libunwind lying around, so acquire that\n+# here and build it.\n+curl -L https://github.com/llvm-mirror/llvm/archive/release_37.tar.gz | tar xzf -\n+curl -L https://github.com/llvm-mirror/libunwind/archive/release_37.tar.gz | tar xzf -\n+mkdir libunwind-build\n+cd libunwind-build\n+cmake ../libunwind-release_37 -DLLVM_PATH=/build/llvm-release_37 \\\n+          -DLIBUNWIND_ENABLE_SHARED=0\n+make -j10\n+cp lib/libunwind.a /musl-x86_64/lib"}, {"sha": "da238dddecacb661e1f7f5426d2d91242c063e2c", "filename": "src/ci/run.sh", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,44 @@\n+#!/bin/sh\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -e\n+\n+if [ \"$LOCAL_USER_ID\" != \"\" ]; then\n+  useradd --shell /bin/bash -u $LOCAL_USER_ID -o -c \"\" -m user\n+  export HOME=/home/user\n+  export LOCAL_USER_ID=\n+  exec sudo -E -u user env PATH=$PATH \"$0\"\n+fi\n+\n+if [ \"$NO_LLVM_ASSERTIONS\" = \"\" ]; then\n+  LLVM_ASSERTIONS=--enable-llvm-assertions\n+fi\n+\n+set -ex\n+\n+$SRC/configure \\\n+  --disable-manage-submodules \\\n+  --enable-debug-assertions \\\n+  --enable-quiet-tests \\\n+  --enable-ccache \\\n+  --enable-vendor \\\n+  $LLVM_ASSERTIONS \\\n+  $RUST_CONFIGURE_ARGS\n+\n+if [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n+    ncpus=$(sysctl -n hw.ncpu)\n+else\n+    ncpus=$(nproc)\n+fi\n+\n+make -j $ncpus tidy\n+make -j $ncpus\n+exec make $RUST_CHECK_TARGET -j $ncpus"}, {"sha": "9fb130845fb166f8b4bc56d5375a1f51c935f607", "filename": "src/doc/book/lang-items.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fdoc%2Fbook%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fdoc%2Fbook%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flang-items.md?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -46,8 +46,8 @@ unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {\n }\n \n #[lang = \"box_free\"]\n-unsafe fn box_free<T>(ptr: *mut T) {\n-    deallocate(ptr as *mut u8, ::core::mem::size_of::<T>(), ::core::mem::align_of::<T>());\n+unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n+    deallocate(ptr as *mut u8, ::core::mem::size_of_val(&*ptr), ::core::mem::align_of_val(&*ptr));\n }\n \n #[start]"}, {"sha": "ed916fd798bb6475bdb74da514b9846a299210a3", "filename": "src/doc/book/testing.md", "status": "modified", "additions": 92, "deletions": 31, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fdoc%2Fbook%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fdoc%2Fbook%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftesting.md?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -23,7 +23,11 @@ $ cd adder\n Cargo will automatically generate a simple test when you make a new project.\n Here's the contents of `src/lib.rs`:\n \n-```rust\n+```rust,ignore\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n #[cfg(test)]\n mod tests {\n     #[test]\n@@ -32,17 +36,30 @@ mod tests {\n }\n ```\n \n+For now, let's remove the `mod` bit, and focus on just the function:\n+\n+```rust,ignore\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n+#[test]\n+fn it_works() {\n+}\n+```\n+\n Note the `#[test]`. This attribute indicates that this is a test function. It\n currently has no body. That's good enough to pass! We can run the tests with\n `cargo test`:\n \n ```bash\n $ cargo test\n    Compiling adder v0.1.0 (file:///home/you/projects/adder)\n-     Running target/debug/deps/adder-91b3e234d4ed382a\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.15 secs\n+     Running target/debug/deps/adder-941f01916ca4a642\n \n running 1 test\n-test tests::it_works ... ok\n+test it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n@@ -58,13 +75,15 @@ for the test we wrote, and another for documentation tests. We'll talk about\n those later. For now, see this line:\n \n ```text\n-test tests::it_works ... ok\n+test it_works ... ok\n ```\n \n Note the `it_works`. This comes from the name of our function:\n \n ```rust\n+# fn main() {\n fn it_works() {\n+}\n # }\n ```\n \n@@ -77,8 +96,11 @@ test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n So why does our do-nothing test pass? Any test which doesn't `panic!` passes,\n and any test that does `panic!` fails. Let's make our test fail:\n \n-```rust\n-# fn main() {}\n+```rust,ignore\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n #[test]\n fn it_works() {\n     assert!(false);\n@@ -92,19 +114,21 @@ run our tests again:\n ```bash\n $ cargo test\n    Compiling adder v0.1.0 (file:///home/you/projects/adder)\n-     Running target/debug/deps/adder-91b3e234d4ed382a\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.17 secs\n+     Running target/debug/deps/adder-941f01916ca4a642\n \n running 1 test\n-test tests::it_works ... FAILED\n+test it_works ... FAILED\n \n failures:\n \n----- test::it_works stdout ----\n-        thread 'tests::it_works' panicked at 'assertion failed: false', src/lib.rs:5\n+---- it_works stdout ----\n+        thread 'it_works' panicked at 'assertion failed: false', src/lib.rs:5\n+note: Run with `RUST_BACKTRACE=1` for a backtrace.\n \n \n failures:\n-    tests::it_works\n+    it_works\n \n test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n \n@@ -114,7 +138,7 @@ error: test failed\n Rust indicates that our test failed:\n \n ```text\n-test tests::it_works ... FAILED\n+test it_works ... FAILED\n ```\n \n And that's reflected in the summary line:\n@@ -147,8 +171,11 @@ This is useful if you want to integrate `cargo test` into other tooling.\n \n We can invert our test's failure with another attribute: `should_panic`:\n \n-```rust\n-# fn main() {}\n+```rust,ignore\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n #[test]\n #[should_panic]\n fn it_works() {\n@@ -161,10 +188,11 @@ This test will now succeed if we `panic!` and fail if we complete. Let's try it:\n ```bash\n $ cargo test\n    Compiling adder v0.1.0 (file:///home/you/projects/adder)\n-     Running target/debug/deps/adder-91b3e234d4ed382a\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.17 secs\n+     Running target/debug/deps/adder-941f01916ca4a642\n \n running 1 test\n-test tests::it_works ... ok\n+test it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n@@ -178,8 +206,11 @@ test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n Rust provides another macro, `assert_eq!`, that compares two arguments for\n equality:\n \n-```rust\n-# fn main() {}\n+```rust,ignore\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n #[test]\n #[should_panic]\n fn it_works() {\n@@ -193,10 +224,11 @@ passes:\n ```bash\n $ cargo test\n    Compiling adder v0.1.0 (file:///home/you/projects/adder)\n-     Running target/debug/deps/adder-91b3e234d4ed382a\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.21 secs\n+     Running target/debug/deps/adder-941f01916ca4a642\n \n running 1 test\n-test tests::it_works ... ok\n+test it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n@@ -213,8 +245,11 @@ parameter can be added to the `should_panic` attribute. The test harness will\n make sure that the failure message contains the provided text. A safer version\n of the example above would be:\n \n-```rust\n-# fn main() {}\n+```rust,ignore\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n #[test]\n #[should_panic(expected = \"assertion failed\")]\n fn it_works() {\n@@ -225,7 +260,10 @@ fn it_works() {\n That's all there is to the basics! Let's write one 'real' test:\n \n ```rust,ignore\n-# fn main() {}\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n pub fn add_two(a: i32) -> i32 {\n     a + 2\n }\n@@ -244,8 +282,15 @@ some known arguments and compare it to the expected output.\n Sometimes a few specific tests can be very time-consuming to execute. These\n can be disabled by default by using the `ignore` attribute:\n \n-```rust\n-# fn main() {}\n+```rust,ignore\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n+pub fn add_two(a: i32) -> i32 {\n+    a + 2\n+}\n+\n #[test]\n fn it_works() {\n     assert_eq!(4, add_two(2));\n@@ -264,7 +309,8 @@ not:\n ```bash\n $ cargo test\n    Compiling adder v0.1.0 (file:///home/you/projects/adder)\n-     Running target/debug/deps/adder-91b3e234d4ed382a\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.20 secs\n+     Running target/debug/deps/adder-941f01916ca4a642\n \n running 2 tests\n test expensive_test ... ignored\n@@ -283,7 +329,8 @@ The expensive tests can be run explicitly using `cargo test -- --ignored`:\n \n ```bash\n $ cargo test -- --ignored\n-     Running target/debug/deps/adder-91b3e234d4ed382a\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs\n+     Running target/debug/deps/adder-941f01916ca4a642\n \n running 1 test\n test expensive_test ... ok\n@@ -310,7 +357,10 @@ was missing from our last example. Let's explain what this does.\n The idiomatic way of writing our example looks like this:\n \n ```rust,ignore\n-# fn main() {}\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n pub fn add_two(a: i32) -> i32 {\n     a + 2\n }\n@@ -339,7 +389,10 @@ a large module, and so this is a common use of globs. Let's change our\n `src/lib.rs` to make use of it:\n \n ```rust,ignore\n-# fn main() {}\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n pub fn add_two(a: i32) -> i32 {\n     a + 2\n }\n@@ -389,9 +442,14 @@ To write an integration test, let's make a `tests` directory and\n put a `tests/integration_test.rs` file inside with this as its contents:\n \n ```rust,ignore\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n+# // Sadly, this code will not work in play.rust-lang.org, because we have no\n+# // crate adder to import. You'll need to try this part on your own machine.\n extern crate adder;\n \n-# fn main() {}\n #[test]\n fn it_works() {\n     assert_eq!(4, adder::add_two(2));\n@@ -452,7 +510,10 @@ running examples in your documentation (**note:** this only works in library\n crates, not binary crates). Here's a fleshed-out `src/lib.rs` with examples:\n \n ```rust,ignore\n-# fn main() {}\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n //! The `adder` crate provides functions that add numbers to other numbers.\n //!\n //! # Examples"}, {"sha": "d1166e686c7b647bf9d5a12bb646b14e6f84f240", "filename": "src/doc/book/traits.md", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fdoc%2Fbook%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fdoc%2Fbook%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftraits.md?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -243,28 +243,22 @@ to know more about [operator traits][operators-and-overloading].\n # Rules for implementing traits\n \n So far, we\u2019ve only added trait implementations to structs, but you can\n-implement a trait for any type. So technically, we _could_ implement `HasArea`\n-for `i32`:\n+implement a trait for any type such as `f32`:\n \n ```rust\n-trait HasArea {\n-    fn area(&self) -> f64;\n+trait ApproxEqual {\n+    fn approx_equal(&self, other: &Self) -> bool;\n }\n-\n-impl HasArea for i32 {\n-    fn area(&self) -> f64 {\n-        println!(\"this is silly\");\n-\n-        *self as f64\n+impl ApproxEqual for f32 {\n+    fn approx_equal(&self, other: &Self) -> bool {\n+        // Appropriate for `self` and `other` being close to 1.0.\n+        (self - other).abs() <= ::std::f32::EPSILON\n     }\n }\n \n-5.area();\n+println!(\"{}\", 1.0.approx_equal(&1.00000001));\n ```\n \n-It is considered poor style to implement methods on such primitive types, even\n-though it is possible.\n-\n This may seem like the Wild West, but there are two restrictions around\n implementing traits that prevent this from getting out of hand. The first is\n that if the trait isn\u2019t defined in your scope, it doesn\u2019t apply. Here\u2019s an"}, {"sha": "12809171b743899f909a67299c16102b1faa6116", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -17,7 +17,7 @@\n \n use core::{isize, usize};\n #[cfg(not(test))]\n-use core::intrinsics::{min_align_of, size_of};\n+use core::intrinsics::{min_align_of_val, size_of_val};\n \n #[allow(improper_ctypes)]\n extern \"C\" {\n@@ -152,11 +152,12 @@ unsafe fn exchange_free(ptr: *mut u8, old_size: usize, align: usize) {\n #[cfg(not(test))]\n #[lang = \"box_free\"]\n #[inline]\n-unsafe fn box_free<T>(ptr: *mut T) {\n-    let size = size_of::<T>();\n+unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n+    let size = size_of_val(&*ptr);\n+    let align = min_align_of_val(&*ptr);\n     // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n     if size != 0 {\n-        deallocate(ptr as *mut u8, size, min_align_of::<T>());\n+        deallocate(ptr as *mut u8, size, align);\n     }\n }\n "}, {"sha": "53b7ae0703bf4819e29f50a11ca3bbce6c7f99eb", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -1586,36 +1586,34 @@ impl<'a, T> IntoIterator for &'a mut Vec<T> {\n impl<T> Extend<T> for Vec<T> {\n     #[inline]\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n-        self.extend_desugared(iter.into_iter())\n+        self.spec_extend(iter.into_iter())\n     }\n }\n \n-trait IsTrustedLen : Iterator {\n-    fn trusted_len(&self) -> Option<usize> { None }\n+trait SpecExtend<I> {\n+    fn spec_extend(&mut self, iter: I);\n }\n-impl<I> IsTrustedLen for I where I: Iterator { }\n \n-impl<I> IsTrustedLen for I where I: TrustedLen\n+impl<I, T> SpecExtend<I> for Vec<T>\n+    where I: Iterator<Item=T>,\n {\n-    fn trusted_len(&self) -> Option<usize> {\n-        let (low, high) = self.size_hint();\n+    default fn spec_extend(&mut self, iter: I) {\n+        self.extend_desugared(iter)\n+    }\n+}\n+\n+impl<I, T> SpecExtend<I> for Vec<T>\n+    where I: TrustedLen<Item=T>,\n+{\n+    fn spec_extend(&mut self, iterator: I) {\n+        // This is the case for a TrustedLen iterator.\n+        let (low, high) = iterator.size_hint();\n         if let Some(high_value) = high {\n             debug_assert_eq!(low, high_value,\n                              \"TrustedLen iterator's size hint is not exact: {:?}\",\n                              (low, high));\n         }\n-        high\n-    }\n-}\n-\n-impl<T> Vec<T> {\n-    fn extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I) {\n-        // This function should be the moral equivalent of:\n-        //\n-        //      for item in iterator {\n-        //          self.push(item);\n-        //      }\n-        if let Some(additional) = iterator.trusted_len() {\n+        if let Some(additional) = high {\n             self.reserve(additional);\n             unsafe {\n                 let mut ptr = self.as_mut_ptr().offset(self.len() as isize);\n@@ -1628,17 +1626,30 @@ impl<T> Vec<T> {\n                 }\n             }\n         } else {\n-            while let Some(element) = iterator.next() {\n-                let len = self.len();\n-                if len == self.capacity() {\n-                    let (lower, _) = iterator.size_hint();\n-                    self.reserve(lower.saturating_add(1));\n-                }\n-                unsafe {\n-                    ptr::write(self.get_unchecked_mut(len), element);\n-                    // NB can't overflow since we would have had to alloc the address space\n-                    self.set_len(len + 1);\n-                }\n+            self.extend_desugared(iterator)\n+        }\n+    }\n+}\n+\n+impl<T> Vec<T> {\n+    fn extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I) {\n+        // This is the case for a general iterator.\n+        //\n+        // This function should be the moral equivalent of:\n+        //\n+        //      for item in iterator {\n+        //          self.push(item);\n+        //      }\n+        while let Some(element) = iterator.next() {\n+            let len = self.len();\n+            if len == self.capacity() {\n+                let (lower, _) = iterator.size_hint();\n+                self.reserve(lower.saturating_add(1));\n+            }\n+            unsafe {\n+                ptr::write(self.get_unchecked_mut(len), element);\n+                // NB can't overflow since we would have had to alloc the address space\n+                self.set_len(len + 1);\n             }\n         }\n     }"}, {"sha": "3726eee9a93c6d5b6e33a73d6ae7a0444edd80ec", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 418, "deletions": 0, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -51,76 +51,472 @@ extern \"rust-intrinsic\" {\n     // NB: These intrinsics take raw pointers because they mutate aliased\n     // memory, which is not valid for either `&` or `&mut`.\n \n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as both the `success` and `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n     pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as both the `success` and `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n     pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n     pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n     pub fn atomic_cxchg_acqrel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as both the `success` and `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n     pub fn atomic_cxchg_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n     pub fn atomic_cxchg_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n     pub fn atomic_cxchg_failacq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n     pub fn atomic_cxchg_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n     pub fn atomic_cxchg_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as both the `success` and `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange_weak`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n     pub fn atomic_cxchgweak<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as both the `success` and `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange_weak`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n     pub fn atomic_cxchgweak_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange_weak`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n     pub fn atomic_cxchgweak_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange_weak`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n     pub fn atomic_cxchgweak_acqrel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as both the `success` and `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange_weak`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n     pub fn atomic_cxchgweak_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange_weak`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n     pub fn atomic_cxchgweak_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange_weak`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n     pub fn atomic_cxchgweak_failacq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange_weak`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n     pub fn atomic_cxchgweak_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange_weak`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n     pub fn atomic_cxchgweak_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n+    /// Loads the current value of the pointer.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `load` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n     pub fn atomic_load<T>(src: *const T) -> T;\n+    /// Loads the current value of the pointer.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `load` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n     pub fn atomic_load_acq<T>(src: *const T) -> T;\n+    /// Loads the current value of the pointer.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `load` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n     pub fn atomic_load_relaxed<T>(src: *const T) -> T;\n     pub fn atomic_load_unordered<T>(src: *const T) -> T;\n \n+    /// Stores the value at the specified memory location.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `store` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n     pub fn atomic_store<T>(dst: *mut T, val: T);\n+    /// Stores the value at the specified memory location.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `store` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n     pub fn atomic_store_rel<T>(dst: *mut T, val: T);\n+    /// Stores the value at the specified memory location.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `store` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n     pub fn atomic_store_relaxed<T>(dst: *mut T, val: T);\n     pub fn atomic_store_unordered<T>(dst: *mut T, val: T);\n \n+    /// Stores the value at the specified memory location, returning the old value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `swap` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n     pub fn atomic_xchg<T>(dst: *mut T, src: T) -> T;\n+    /// Stores the value at the specified memory location, returning the old value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `swap` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n     pub fn atomic_xchg_acq<T>(dst: *mut T, src: T) -> T;\n+    /// Stores the value at the specified memory location, returning the old value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `swap` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n     pub fn atomic_xchg_rel<T>(dst: *mut T, src: T) -> T;\n+    /// Stores the value at the specified memory location, returning the old value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `swap` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n     pub fn atomic_xchg_acqrel<T>(dst: *mut T, src: T) -> T;\n+    /// Stores the value at the specified memory location, returning the old value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `swap` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n     pub fn atomic_xchg_relaxed<T>(dst: *mut T, src: T) -> T;\n \n+    /// Add to the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_add` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;\n+    /// Add to the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_add` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;\n+    /// Add to the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_add` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;\n+    /// Add to the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_add` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_acqrel<T>(dst: *mut T, src: T) -> T;\n+    /// Add to the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_add` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_relaxed<T>(dst: *mut T, src: T) -> T;\n \n+    /// Subtract from the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n     pub fn atomic_xsub<T>(dst: *mut T, src: T) -> T;\n+    /// Subtract from the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n     pub fn atomic_xsub_acq<T>(dst: *mut T, src: T) -> T;\n+    /// Subtract from the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n     pub fn atomic_xsub_rel<T>(dst: *mut T, src: T) -> T;\n+    /// Subtract from the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n     pub fn atomic_xsub_acqrel<T>(dst: *mut T, src: T) -> T;\n+    /// Subtract from the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n     pub fn atomic_xsub_relaxed<T>(dst: *mut T, src: T) -> T;\n \n+    /// Bitwise and with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_and` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n     pub fn atomic_and<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise and with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_and` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n     pub fn atomic_and_acq<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise and with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_and` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n     pub fn atomic_and_rel<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise and with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_and` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n     pub fn atomic_and_acqrel<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise and with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_and` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n     pub fn atomic_and_relaxed<T>(dst: *mut T, src: T) -> T;\n \n+    /// Bitwise nand with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n     pub fn atomic_nand<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise nand with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n     pub fn atomic_nand_acq<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise nand with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n     pub fn atomic_nand_rel<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise nand with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n     pub fn atomic_nand_acqrel<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise nand with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n     pub fn atomic_nand_relaxed<T>(dst: *mut T, src: T) -> T;\n \n+    /// Bitwise or with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_or` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n     pub fn atomic_or<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise or with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_or` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n     pub fn atomic_or_acq<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise or with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_or` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n     pub fn atomic_or_rel<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise or with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_or` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n     pub fn atomic_or_acqrel<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise or with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_or` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n     pub fn atomic_or_relaxed<T>(dst: *mut T, src: T) -> T;\n \n+    /// Bitwise xor with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n     pub fn atomic_xor<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise xor with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n     pub fn atomic_xor_acq<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise xor with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n     pub fn atomic_xor_rel<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise xor with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n     pub fn atomic_xor_acqrel<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise xor with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n     pub fn atomic_xor_relaxed<T>(dst: *mut T, src: T) -> T;\n \n     pub fn atomic_max<T>(dst: *mut T, src: T) -> T;\n@@ -631,8 +1027,12 @@ extern \"rust-intrinsic\" {\n     pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n     /// Perform a volatile load from the `src` pointer.\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::ptr::read_volatile`](../../std/ptr/fn.read_volatile.html).\n     pub fn volatile_load<T>(src: *const T) -> T;\n     /// Perform a volatile store to the `dst` pointer.\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::ptr::write_volatile`](../../std/ptr/fn.write_volatile.html).\n     pub fn volatile_store<T>(dst: *mut T, val: T);\n \n     /// Returns the square root of an `f32`\n@@ -766,12 +1166,21 @@ extern \"rust-intrinsic\" {\n     pub fn bswap<T>(x: T) -> T;\n \n     /// Performs checked integer addition.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `overflowing_add` method. For example,\n+    /// [`std::u32::overflowing_add`](../../std/primitive.u32.html#method.overflowing_add)\n     pub fn add_with_overflow<T>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer subtraction\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `overflowing_sub` method. For example,\n+    /// [`std::u32::overflowing_sub`](../../std/primitive.u32.html#method.overflowing_sub)\n     pub fn sub_with_overflow<T>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer multiplication\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `overflowing_mul` method. For example,\n+    /// [`std::u32::overflowing_mul`](../../std/primitive.u32.html#method.overflowing_mul)\n     pub fn mul_with_overflow<T>(x: T, y: T) -> (T, bool);\n \n     /// Performs an unchecked division, resulting in undefined behavior\n@@ -782,10 +1191,19 @@ extern \"rust-intrinsic\" {\n     pub fn unchecked_rem<T>(x: T, y: T) -> T;\n \n     /// Returns (a + b) mod 2^N, where N is the width of T in bits.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `wrapping_add` method. For example,\n+    /// [`std::u32::wrapping_add`](../../std/primitive.u32.html#method.wrapping_add)\n     pub fn overflowing_add<T>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2^N, where N is the width of T in bits.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `wrapping_sub` method. For example,\n+    /// [`std::u32::wrapping_sub`](../../std/primitive.u32.html#method.wrapping_sub)\n     pub fn overflowing_sub<T>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2^N, where N is the width of T in bits.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `wrapping_mul` method. For example,\n+    /// [`std::u32::wrapping_mul`](../../std/primitive.u32.html#method.wrapping_mul)\n     pub fn overflowing_mul<T>(a: T, b: T) -> T;\n \n     /// Returns the value of the discriminant for the variant in 'v',"}, {"sha": "e94582cda7c346e16d7aceb5d22c4a1faa381ab7", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -666,13 +666,17 @@ float_sum_product! { f32 f64 }\n /// An iterator that always continues to yield `None` when exhausted.\n ///\n /// Calling next on a fused iterator that has returned `None` once is guaranteed\n-/// to return `None` again. This trait is should be implemented by all iterators\n+/// to return [`None`] again. This trait is should be implemented by all iterators\n /// that behave this way because it allows for some significant optimizations.\n ///\n /// Note: In general, you should not use `FusedIterator` in generic bounds if\n-/// you need a fused iterator. Instead, you should just call `Iterator::fused()`\n-/// on the iterator. If the iterator is already fused, the additional `Fuse`\n+/// you need a fused iterator. Instead, you should just call [`Iterator::fuse()`]\n+/// on the iterator. If the iterator is already fused, the additional [`Fuse`]\n /// wrapper will be a no-op with no performance penalty.\n+///\n+/// [`None`]: ../../std/option/enum.Option.html#variant.None\n+/// [`Iterator::fuse()`]: ../../std/iter/trait.Iterator.html#method.fuse\n+/// [`Fuse`]: ../../std/iter/struct.Fuse.html\n #[unstable(feature = \"fused\", issue = \"35602\")]\n pub trait FusedIterator: Iterator {}\n \n@@ -682,16 +686,20 @@ impl<'a, I: FusedIterator + ?Sized> FusedIterator for &'a mut I {}\n /// An iterator that reports an accurate length using size_hint.\n ///\n /// The iterator reports a size hint where it is either exact\n-/// (lower bound is equal to upper bound), or the upper bound is `None`.\n-/// The upper bound must only be `None` if the actual iterator length is\n-/// larger than `usize::MAX`.\n+/// (lower bound is equal to upper bound), or the upper bound is [`None`].\n+/// The upper bound must only be [`None`] if the actual iterator length is\n+/// larger than [`usize::MAX`].\n ///\n /// The iterator must produce exactly the number of elements it reported.\n ///\n /// # Safety\n ///\n /// This trait must only be implemented when the contract is upheld.\n-/// Consumers of this trait must inspect `.size_hint()`\u2019s upper bound.\n+/// Consumers of this trait must inspect [`.size_hint()`]\u2019s upper bound.\n+///\n+/// [`None`]: ../../std/option/enum.Option.html#variant.None\n+/// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n+/// [`.size_hint()`]: ../../std/iter/trait.Iterator.html#method.size_hint\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n pub unsafe trait TrustedLen : Iterator {}\n "}, {"sha": "b3f5363f5b15a970557923e79bfb82c9d5a3955e", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -550,15 +550,15 @@ macro_rules! unimplemented {\n /// into libsyntax itself.\n ///\n /// For more information, see documentation for `std`'s macros.\n-#[cfg(dox)]\n-pub mod builtin {\n+mod builtin {\n     /// The core macro for formatted string creation & output.\n     ///\n     /// For more information, see the documentation for [`std::format_args!`].\n     ///\n     /// [`std::format_args!`]: ../std/macro.format_args.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! format_args { ($fmt:expr, $($args:tt)*) => ({\n         /* compiler built-in */\n     }) }\n@@ -570,6 +570,7 @@ pub mod builtin {\n     /// [`std::env!`]: ../std/macro.env.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! env { ($name:expr) => ({ /* compiler built-in */ }) }\n \n     /// Optionally inspect an environment variable at compile time.\n@@ -579,6 +580,7 @@ pub mod builtin {\n     /// [`std::option_env!`]: ../std/macro.option_env.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! option_env { ($name:expr) => ({ /* compiler built-in */ }) }\n \n     /// Concatenate identifiers into one identifier.\n@@ -588,6 +590,7 @@ pub mod builtin {\n     /// [`std::concat_idents!`]: ../std/macro.concat_idents.html\n     #[unstable(feature = \"concat_idents_macro\", issue = \"29599\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! concat_idents {\n         ($($e:ident),*) => ({ /* compiler built-in */ })\n     }\n@@ -599,6 +602,7 @@ pub mod builtin {\n     /// [`std::concat!`]: ../std/macro.concat.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! concat { ($($e:expr),*) => ({ /* compiler built-in */ }) }\n \n     /// A macro which expands to the line number on which it was invoked.\n@@ -608,6 +612,7 @@ pub mod builtin {\n     /// [`std::line!`]: ../std/macro.line.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! line { () => ({ /* compiler built-in */ }) }\n \n     /// A macro which expands to the column number on which it was invoked.\n@@ -617,6 +622,7 @@ pub mod builtin {\n     /// [`std::column!`]: ../std/macro.column.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! column { () => ({ /* compiler built-in */ }) }\n \n     /// A macro which expands to the file name from which it was invoked.\n@@ -626,6 +632,7 @@ pub mod builtin {\n     /// [`std::file!`]: ../std/macro.file.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! file { () => ({ /* compiler built-in */ }) }\n \n     /// A macro which stringifies its argument.\n@@ -635,6 +642,7 @@ pub mod builtin {\n     /// [`std::stringify!`]: ../std/macro.stringify.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! stringify { ($t:tt) => ({ /* compiler built-in */ }) }\n \n     /// Includes a utf8-encoded file as a string.\n@@ -644,6 +652,7 @@ pub mod builtin {\n     /// [`std::include_str!`]: ../std/macro.include_str.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! include_str { ($file:expr) => ({ /* compiler built-in */ }) }\n \n     /// Includes a file as a reference to a byte array.\n@@ -653,6 +662,7 @@ pub mod builtin {\n     /// [`std::include_bytes!`]: ../std/macro.include_bytes.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! include_bytes { ($file:expr) => ({ /* compiler built-in */ }) }\n \n     /// Expands to a string that represents the current module path.\n@@ -662,6 +672,7 @@ pub mod builtin {\n     /// [`std::module_path!`]: ../std/macro.module_path.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n \n     /// Boolean evaluation of configuration flags.\n@@ -671,6 +682,7 @@ pub mod builtin {\n     /// [`std::cfg!`]: ../std/macro.cfg.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! cfg { ($($cfg:tt)*) => ({ /* compiler built-in */ }) }\n \n     /// Parse a file as an expression or an item according to the context.\n@@ -680,5 +692,6 @@ pub mod builtin {\n     /// [`std::include!`]: ../std/macro.include.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! include { ($file:expr) => ({ /* compiler built-in */ }) }\n }"}, {"sha": "9af10966eda4bc8e9bc81a5ab96955918e679886", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -26,15 +26,15 @@ use hash::Hasher;\n /// appropriate.\n ///\n /// An example of a non-`Send` type is the reference-counting pointer\n-/// [`rc::Rc`][rc]. If two threads attempt to clone `Rc`s that point to the same\n+/// [`rc::Rc`][`Rc`]. If two threads attempt to clone [`Rc`]s that point to the same\n /// reference-counted value, they might try to update the reference count at the\n-/// same time, which is [undefined behavior][ub] because `Rc` doesn't use atomic\n+/// same time, which is [undefined behavior][ub] because [`Rc`] doesn't use atomic\n /// operations. Its cousin [`sync::Arc`][arc] does use atomic operations (incurring\n /// some overhead) and thus is `Send`.\n ///\n /// See [the Nomicon](../../nomicon/send-and-sync.html) for more details.\n ///\n-/// [rc]: ../../std/rc/struct.Rc.html\n+/// [`Rc`]: ../../std/rc/struct.Rc.html\n /// [arc]: ../../std/sync/struct.Arc.html\n /// [ub]: ../../reference.html#behavior-considered-undefined\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -183,20 +183,17 @@ pub trait Unsize<T: ?Sized> {\n /// Copies happen implicitly, for example as part of an assignment `y = x`. The behavior of\n /// `Copy` is not overloadable; it is always a simple bit-wise copy.\n ///\n-/// Cloning is an explicit action, `x.clone()`. The implementation of [`Clone`][clone] can\n+/// Cloning is an explicit action, `x.clone()`. The implementation of [`Clone`] can\n /// provide any type-specific behavior necessary to duplicate values safely. For example,\n-/// the implementation of `Clone` for [`String`][string] needs to copy the pointed-to string\n-/// buffer in the heap. A simple bitwise copy of `String` values would merely copy the\n-/// pointer, leading to a double free down the line. For this reason, `String` is `Clone`\n+/// the implementation of [`Clone`] for [`String`] needs to copy the pointed-to string\n+/// buffer in the heap. A simple bitwise copy of [`String`] values would merely copy the\n+/// pointer, leading to a double free down the line. For this reason, [`String`] is [`Clone`]\n /// but not `Copy`.\n ///\n-/// `Clone` is a supertrait of `Copy`, so everything which is `Copy` must also implement\n-/// `Clone`. If a type is `Copy` then its `Clone` implementation need only return `*self`\n+/// [`Clone`] is a supertrait of `Copy`, so everything which is `Copy` must also implement\n+/// [`Clone`]. If a type is `Copy` then its [`Clone`] implementation need only return `*self`\n /// (see the example above).\n ///\n-/// [clone]: ../clone/trait.Clone.html\n-/// [string]: ../../std/string/struct.String.html\n-///\n /// ## When can my type be `Copy`?\n ///\n /// A type can implement `Copy` if all of its components implement `Copy`. For example, this\n@@ -210,7 +207,7 @@ pub trait Unsize<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// A struct can be `Copy`, and `i32` is `Copy`, therefore `Point` is eligible to be `Copy`.\n+/// A struct can be `Copy`, and [`i32`] is `Copy`, therefore `Point` is eligible to be `Copy`.\n /// By contrast, consider\n ///\n /// ```\n@@ -231,8 +228,8 @@ pub trait Unsize<T: ?Sized> {\n /// ## When *can't* my type be `Copy`?\n ///\n /// Some types can't be copied safely. For example, copying `&mut T` would create an aliased\n-/// mutable reference. Copying [`String`] would duplicate responsibility for managing the `String`'s\n-/// buffer, leading to a double free.\n+/// mutable reference. Copying [`String`] would duplicate responsibility for managing the\n+/// [`String`]'s buffer, leading to a double free.\n ///\n /// Generalizing the latter case, any type implementing [`Drop`] can't be `Copy`, because it's\n /// managing some resource besides its own [`size_of::<T>()`] bytes.\n@@ -255,6 +252,9 @@ pub trait Unsize<T: ?Sized> {\n /// [`String`]: ../../std/string/struct.String.html\n /// [`Drop`]: ../../std/ops/trait.Drop.html\n /// [`size_of::<T>()`]: ../../std/mem/fn.size_of.html\n+/// [`Clone`]: ../clone/trait.Clone.html\n+/// [`String`]: ../../std/string/struct.String.html\n+/// [`i32`]: ../../std/primitive.i32.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"copy\"]\n pub trait Copy : Clone {\n@@ -290,20 +290,20 @@ pub trait Copy : Clone {\n /// mutability\" in a non-thread-safe form, such as [`cell::Cell`][cell]\n /// and [`cell::RefCell`][refcell]. These types allow for mutation of\n /// their contents even through an immutable, shared reference. For\n-/// example the `set` method on `Cell<T>` takes `&self`, so it requires\n-/// only a shared reference `&Cell<T>`. The method performs no\n-/// synchronization, thus `Cell` cannot be `Sync`.\n+/// example the `set` method on [`Cell<T>`][cell] takes `&self`, so it requires\n+/// only a shared reference [`&Cell<T>`][cell]. The method performs no\n+/// synchronization, thus [`Cell`][cell] cannot be `Sync`.\n ///\n /// Another example of a non-`Sync` type is the reference-counting\n-/// pointer [`rc::Rc`][rc]. Given any reference `&Rc<T>`, you can clone\n-/// a new `Rc<T>`, modifying the reference counts in a non-atomic way.\n+/// pointer [`rc::Rc`][rc]. Given any reference [`&Rc<T>`][rc], you can clone\n+/// a new [`Rc<T>`][rc], modifying the reference counts in a non-atomic way.\n ///\n /// For cases when one does need thread-safe interior mutability,\n /// Rust provides [atomic data types], as well as explicit locking via\n /// [`sync::Mutex`][mutex] and [`sync::RWLock`][rwlock]. These types\n /// ensure that any mutation cannot cause data races, hence the types\n /// are `Sync`. Likewise, [`sync::Arc`][arc] provides a thread-safe\n-/// analogue of `Rc`.\n+/// analogue of [`Rc`][rc].\n ///\n /// Any types with interior mutability must also use the\n /// [`cell::UnsafeCell`][unsafecell] wrapper around the value(s) which"}, {"sha": "209107ef92ceb824f67ae3dea053c3f2503b3922", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -337,7 +337,7 @@ pub unsafe fn zeroed<T>() -> T {\n /// Bypasses Rust's normal memory-initialization checks by pretending to\n /// produce a value of type `T`, while doing nothing at all.\n ///\n-/// **This is incredibly dangerous, and should not be done lightly. Deeply\n+/// **This is incredibly dangerous and should not be done lightly. Deeply\n /// consider initializing your memory with a default value instead.**\n ///\n /// This is useful for [FFI] functions and initializing arrays sometimes,\n@@ -352,24 +352,18 @@ pub unsafe fn zeroed<T>() -> T {\n /// a boolean, your program may take one, both, or neither of the branches.\n ///\n /// Writing to the uninitialized value is similarly dangerous. Rust believes the\n-/// value is initialized, and will therefore try to [`Drop`][drop] the uninitialized\n+/// value is initialized, and will therefore try to [`Drop`] the uninitialized\n /// value and its fields if you try to overwrite it in a normal manner. The only way\n /// to safely initialize an uninitialized value is with [`ptr::write`][write],\n /// [`ptr::copy`][copy], or [`ptr::copy_nonoverlapping`][copy_no].\n ///\n-/// If the value does implement `Drop`, it must be initialized before\n+/// If the value does implement [`Drop`], it must be initialized before\n /// it goes out of scope (and therefore would be dropped). Note that this\n /// includes a `panic` occurring and unwinding the stack suddenly.\n ///\n-/// [ub]: ../../reference.html#behavior-considered-undefined\n-/// [write]: ../ptr/fn.write.html\n-/// [copy]: ../intrinsics/fn.copy.html\n-/// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n-/// [drop]: ../ops/trait.Drop.html\n-///\n /// # Examples\n ///\n-/// Here's how to safely initialize an array of `Vec`s.\n+/// Here's how to safely initialize an array of [`Vec`]s.\n ///\n /// ```\n /// use std::mem;\n@@ -410,15 +404,24 @@ pub unsafe fn zeroed<T>() -> T {\n /// ```\n ///\n /// This example emphasizes exactly how delicate and dangerous using `mem::uninitialized`\n-/// can be. Note that the `vec!` macro *does* let you initialize every element with a\n-/// value that is only `Clone`, so the following is semantically equivalent and\n+/// can be. Note that the [`vec!`] macro *does* let you initialize every element with a\n+/// value that is only [`Clone`], so the following is semantically equivalent and\n /// vastly less dangerous, as long as you can live with an extra heap\n /// allocation:\n ///\n /// ```\n /// let data: Vec<Vec<u32>> = vec![Vec::new(); 1000];\n /// println!(\"{:?}\", &data[0]);\n /// ```\n+///\n+/// [`Vec`]: ../../std/vec/struct.Vec.html\n+/// [`vec!`]: ../../std/macro.vec.html\n+/// [`Clone`]: ../../std/clone/trait.Clone.html\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [write]: ../ptr/fn.write.html\n+/// [copy]: ../intrinsics/fn.copy.html\n+/// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n+/// [`Drop`]: ../ops/trait.Drop.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn uninitialized<T>() -> T {\n@@ -492,7 +495,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// }\n /// ```\n ///\n-/// Note that `T` does not necessarily implement `Clone`, so it can't even clone and reset\n+/// Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset\n /// `self.buf`. But `replace` can be used to disassociate the original value of `self.buf` from\n /// `self`, allowing it to be returned:\n ///\n@@ -507,6 +510,8 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n ///     }\n /// }\n /// ```\n+///\n+/// [`Clone`]: ../../std/clone/trait.Clone.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n@@ -571,8 +576,8 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// v.push(4); // no problems\n /// ```\n ///\n-/// Since `RefCell` enforces the borrow rules at runtime, `drop` can\n-/// release a `RefCell` borrow:\n+/// Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n+/// release a [`RefCell`] borrow:\n ///\n /// ```\n /// use std::cell::RefCell;\n@@ -588,7 +593,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// println!(\"{}\", *borrow);\n /// ```\n ///\n-/// Integers and other types implementing `Copy` are unaffected by `drop`.\n+/// Integers and other types implementing [`Copy`] are unaffected by `drop`.\n ///\n /// ```\n /// #[derive(Copy, Clone)]\n@@ -602,6 +607,8 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// println!(\"x: {}, y: {}\", x, y.0); // still available\n /// ```\n ///\n+/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn drop<T>(_x: T) { }"}, {"sha": "b179a16e55e5885b6bdb07caa70ef9b044ca2786", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -139,7 +139,7 @@ pub struct Parser<'a> {\n     input: &'a str,\n     cur: iter::Peekable<str::CharIndices<'a>>,\n     /// Error messages accumulated during parsing\n-    pub errors: Vec<string::String>,\n+    pub errors: Vec<(string::String, Option<string::String>)>,\n     /// Current position of implicit positional argument pointer\n     curarg: usize,\n }\n@@ -165,7 +165,9 @@ impl<'a> Iterator for Parser<'a> {\n                     if self.consume('}') {\n                         Some(String(self.string(pos + 1)))\n                     } else {\n-                        self.err(\"unmatched `}` found\");\n+                        self.err_with_note(\"unmatched `}` found\",\n+                                           \"if you intended to print `}`, \\\n+                                           you can escape it using `}}`\");\n                         None\n                     }\n                 }\n@@ -192,7 +194,14 @@ impl<'a> Parser<'a> {\n     /// String, but I think it does when this eventually uses conditions so it\n     /// might as well start using it now.\n     fn err(&mut self, msg: &str) {\n-        self.errors.push(msg.to_owned());\n+        self.errors.push((msg.to_owned(), None));\n+    }\n+\n+    /// Notifies of an error. The message doesn't actually need to be of type\n+    /// String, but I think it does when this eventually uses conditions so it\n+    /// might as well start using it now.\n+    fn err_with_note(&mut self, msg: &str, note: &str) {\n+        self.errors.push((msg.to_owned(), Some(note.to_owned())));\n     }\n \n     /// Optionally consumes the specified character. If the character is not at\n@@ -222,7 +231,13 @@ impl<'a> Parser<'a> {\n                 self.err(&format!(\"expected `{:?}`, found `{:?}`\", c, maybe));\n             }\n         } else {\n-            self.err(&format!(\"expected `{:?}` but string was terminated\", c));\n+            let msg = &format!(\"expected `{:?}` but string was terminated\", c);\n+            if c == '}' {\n+                self.err_with_note(msg,\n+                                   \"if you intended to print `{`, you can escape it using `{{`\");\n+            } else {\n+                self.err(msg);\n+            }\n         }\n     }\n "}, {"sha": "50dfe9d22f12fa110f3a22d5056016e1960e3913", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -112,15 +112,15 @@ impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n     /// switched to `Map(key)`. Therefore, if `op` makes use of any\n     /// HIR nodes or shared state accessed through its closure\n     /// environment, it must explicitly register a read of that\n-    /// state. As an example, see `type_scheme_of_item` in `collect`,\n+    /// state. As an example, see `type_of_item` in `collect`,\n     /// which looks something like this:\n     ///\n     /// ```\n-    /// fn type_scheme_of_item(..., item: &hir::Item) -> ty::TypeScheme<'tcx> {\n+    /// fn type_of_item(..., item: &hir::Item) -> Ty<'tcx> {\n     ///     let item_def_id = ccx.tcx.map.local_def_id(it.id);\n-    ///     ccx.tcx.tcache.memoized(item_def_id, || {\n+    ///     ccx.tcx.item_types.memoized(item_def_id, || {\n     ///         ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id)); // (*)\n-    ///         compute_type_scheme_of_item(ccx, item)\n+    ///         compute_type_of_item(ccx, item)\n     ///     });\n     /// }\n     /// ```"}, {"sha": "641273d2b7626df326fbaccac265def14c2af3de", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -184,7 +184,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n     {\n         // We use SmallVector here instead of Vec because this code is hot and\n         // it's rare that the stack length exceeds 1.\n-        let mut stack = SmallVector::zero();\n+        let mut stack = SmallVector::new();\n         stack.push((a_ty, dir, b_vid));\n         loop {\n             // For each turn of the loop, we extract a tuple"}, {"sha": "d8a7ce72f50d2f2b5eb353f62ebc1424bc6ffe1c", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -1052,21 +1052,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     match item.node {\n                         hir::ItemFn(ref fn_decl, unsafety, constness, _, ref gen, _) => {\n                             Some((fn_decl, gen, unsafety, constness, item.name, item.span))\n-                        },\n-                        _ => None\n+                        }\n+                        _ => None,\n                     }\n                 }\n                 ast_map::NodeImplItem(item) => {\n-                    match item.node {\n-                        hir::ImplItemKind::Method(ref sig, _) => {\n-                            Some((&sig.decl,\n-                                  &sig.generics,\n-                                  sig.unsafety,\n-                                  sig.constness,\n-                                  item.name,\n-                                  item.span))\n+                    let id = self.tcx.map.get_parent(item.id);\n+                    if let Some(ast_map::NodeItem(parent_scope)) = self.tcx.map.find(id) {\n+                        if let hir::ItemImpl(_, _, _, None, _, _) = parent_scope.node {\n+                            // this impl scope implements a trait, do not recomend\n+                            // using explicit lifetimes (#37363)\n+                            return;\n                         }\n-                        _ => None,\n+                    }\n+                    if let hir::ImplItemKind::Method(ref sig, _) = item.node {\n+                        Some((&sig.decl,\n+                              &sig.generics,\n+                              sig.unsafety,\n+                              sig.constness,\n+                              item.name,\n+                              item.span))\n+                    } else {\n+                        None\n                     }\n                 },\n                 ast_map::NodeTraitItem(item) => {\n@@ -1079,12 +1086,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                   item.name,\n                                   item.span))\n                         }\n-                        _ => None\n+                        _ => None,\n                     }\n                 }\n-                _ => None\n+                _ => None,\n             },\n-            None => None\n+            None => None,\n         };\n         let (fn_decl, generics, unsafety, constness, name, span)\n                                     = node_inner.expect(\"expect item fn\");\n@@ -1436,7 +1443,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                     match self.tcx.expect_def(cur_ty.id) {\n                         Def::Enum(did) | Def::TyAlias(did) |\n                         Def::Struct(did) | Def::Union(did) => {\n-                            let generics = self.tcx.lookup_generics(did);\n+                            let generics = self.tcx.item_generics(did);\n \n                             let expected =\n                                 generics.regions.len() as u32;"}, {"sha": "806b94486615fcd7d313796effbeeeab0ce3663f", "filename": "src/librustc/infer/fudge.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,137 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ty::{self, TyCtxt};\n+use ty::fold::{TypeFoldable, TypeFolder};\n+\n+use super::InferCtxt;\n+use super::RegionVariableOrigin;\n+\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    /// This rather funky routine is used while processing expected\n+    /// types. What happens here is that we want to propagate a\n+    /// coercion through the return type of a fn to its\n+    /// argument. Consider the type of `Option::Some`, which is\n+    /// basically `for<T> fn(T) -> Option<T>`. So if we have an\n+    /// expression `Some(&[1, 2, 3])`, and that has the expected type\n+    /// `Option<&[u32]>`, we would like to type check `&[1, 2, 3]`\n+    /// with the expectation of `&[u32]`. This will cause us to coerce\n+    /// from `&[u32; 3]` to `&[u32]` and make the users life more\n+    /// pleasant.\n+    ///\n+    /// The way we do this is using `fudge_regions_if_ok`. What the\n+    /// routine actually does is to start a snapshot and execute the\n+    /// closure `f`. In our example above, what this closure will do\n+    /// is to unify the expectation (`Option<&[u32]>`) with the actual\n+    /// return type (`Option<?T>`, where `?T` represents the variable\n+    /// instantiated for `T`).  This will cause `?T` to be unified\n+    /// with `&?a [u32]`, where `?a` is a fresh lifetime variable. The\n+    /// input type (`?T`) is then returned by `f()`.\n+    ///\n+    /// At this point, `fudge_regions_if_ok` will normalize all type\n+    /// variables, converting `?T` to `&?a [u32]` and end the\n+    /// snapshot.  The problem is that we can't just return this type\n+    /// out, because it references the region variable `?a`, and that\n+    /// region variable was popped when we popped the snapshot.\n+    ///\n+    /// So what we do is to keep a list (`region_vars`, in the code below)\n+    /// of region variables created during the snapshot (here, `?a`). We\n+    /// fold the return value and replace any such regions with a *new*\n+    /// region variable (e.g., `?b`) and return the result (`&?b [u32]`).\n+    /// This can then be used as the expectation for the fn argument.\n+    ///\n+    /// The important point here is that, for soundness purposes, the\n+    /// regions in question are not particularly important. We will\n+    /// use the expected types to guide coercions, but we will still\n+    /// type-check the resulting types from those coercions against\n+    /// the actual types (`?T`, `Option<?T`) -- and remember that\n+    /// after the snapshot is popped, the variable `?T` is no longer\n+    /// unified.\n+    ///\n+    /// Assumptions:\n+    /// - no new type variables are created during `f()` (asserted\n+    ///   below); this simplifies our logic since we don't have to\n+    ///   check for escaping type variables\n+    pub fn fudge_regions_if_ok<T, E, F>(&self,\n+                                        origin: &RegionVariableOrigin,\n+                                        f: F) -> Result<T, E> where\n+        F: FnOnce() -> Result<T, E>,\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let (region_vars, value) = self.probe(|snapshot| {\n+            let vars_at_start = self.type_variables.borrow().num_vars();\n+\n+            match f() {\n+                Ok(value) => {\n+                    let value = self.resolve_type_vars_if_possible(&value);\n+\n+                    // At this point, `value` could in principle refer\n+                    // to regions that have been created during the\n+                    // snapshot (we assert below that `f()` does not\n+                    // create any new type variables, so there\n+                    // shouldn't be any of those). Once we exit\n+                    // `probe()`, those are going to be popped, so we\n+                    // will have to eliminate any references to them.\n+\n+                    assert_eq!(self.type_variables.borrow().num_vars(), vars_at_start,\n+                               \"type variables were created during fudge_regions_if_ok\");\n+                    let region_vars =\n+                        self.region_vars.vars_created_since_snapshot(\n+                            &snapshot.region_vars_snapshot);\n+\n+                    Ok((region_vars, value))\n+                }\n+                Err(e) => Err(e),\n+            }\n+        })?;\n+\n+        // At this point, we need to replace any of the now-popped\n+        // region variables that appear in `value` with a fresh region\n+        // variable. We can't do this during the probe because they\n+        // would just get popped then too. =)\n+\n+        // Micro-optimization: if no variables have been created, then\n+        // `value` can't refer to any of them. =) So we can just return it.\n+        if region_vars.is_empty() {\n+            return Ok(value);\n+        }\n+\n+        let mut fudger = RegionFudger {\n+            infcx: self,\n+            region_vars: &region_vars,\n+            origin: origin\n+        };\n+\n+        Ok(value.fold_with(&mut fudger))\n+    }\n+}\n+\n+pub struct RegionFudger<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    region_vars: &'a Vec<ty::RegionVid>,\n+    origin: &'a RegionVariableOrigin,\n+}\n+\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFudger<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+        match *r {\n+            ty::ReVar(v) if self.region_vars.contains(&v) => {\n+                self.infcx.next_region_var(self.origin.clone())\n+            }\n+            _ => {\n+                r\n+            }\n+        }\n+    }\n+}"}, {"sha": "46074f6c1f3c820016641c1ecd89a157855a9859", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 43, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -50,6 +50,7 @@ mod bivariate;\n mod combine;\n mod equate;\n pub mod error_reporting;\n+mod fudge;\n mod glb;\n mod higher_ranked;\n pub mod lattice;\n@@ -985,49 +986,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         r\n     }\n \n-    /// Execute `f` and commit only the region bindings if successful.\n-    /// The function f must be very careful not to leak any non-region\n-    /// variables that get created.\n-    pub fn commit_regions_if_ok<T, E, F>(&self, f: F) -> Result<T, E> where\n-        F: FnOnce() -> Result<T, E>\n-    {\n-        debug!(\"commit_regions_if_ok()\");\n-        let CombinedSnapshot { projection_cache_snapshot,\n-                               type_snapshot,\n-                               int_snapshot,\n-                               float_snapshot,\n-                               region_vars_snapshot,\n-                               obligations_in_snapshot } = self.start_snapshot();\n-\n-        let r = self.commit_if_ok(|_| f());\n-\n-        debug!(\"commit_regions_if_ok: rolling back everything but regions\");\n-\n-        assert!(!self.obligations_in_snapshot.get());\n-        self.obligations_in_snapshot.set(obligations_in_snapshot);\n-\n-        // Roll back any non-region bindings - they should be resolved\n-        // inside `f`, with, e.g. `resolve_type_vars_if_possible`.\n-        self.projection_cache\n-            .borrow_mut()\n-            .rollback_to(projection_cache_snapshot);\n-        self.type_variables\n-            .borrow_mut()\n-            .rollback_to(type_snapshot);\n-        self.int_unification_table\n-            .borrow_mut()\n-            .rollback_to(int_snapshot);\n-        self.float_unification_table\n-            .borrow_mut()\n-            .rollback_to(float_snapshot);\n-\n-        // Commit region vars that may escape through resolved types.\n-        self.region_vars\n-            .commit(region_vars_snapshot);\n-\n-        r\n-    }\n-\n     /// Execute `f` then unroll any bindings it creates\n     pub fn probe<R, F>(&self, f: F) -> R where\n         F: FnOnce(&CombinedSnapshot) -> R,"}, {"sha": "804765ec8811e52171ce8e6e3207c9d291f44269", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -184,6 +184,10 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         v\n     }\n \n+    pub fn num_vars(&self) -> usize {\n+        self.values.len()\n+    }\n+\n     pub fn root_var(&mut self, vid: ty::TyVid) -> ty::TyVid {\n         self.eq_relations.find(vid)\n     }"}, {"sha": "94667b398b08068c7be5afaad0cd83a3e7440cef", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -433,7 +433,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n-        let field_type = self.tcx.tables().node_id_to_type(field.id);\n+        let field_type = self.tcx.item_type(self.tcx.map.local_def_id(field.id));\n         let is_marker_field = match field_type.ty_to_def_id() {\n             Some(def_id) => self.tcx.lang_items.items().iter().any(|item| *item == Some(def_id)),\n             _ => false"}, {"sha": "0f9748a16f46ca5f95561da08e2639b469fc3140", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -51,7 +51,7 @@ struct ExprVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n-        let intrinsic = match self.infcx.tcx.lookup_item_type(def_id).ty.sty {\n+        let intrinsic = match self.infcx.tcx.item_type(def_id).sty {\n             ty::TyFnDef(.., ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };"}, {"sha": "f472205b732d45a7b6609b4d68a24c5eb3c5ddca", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -112,7 +112,7 @@ use self::VarKind::*;\n use dep_graph::DepNode;\n use hir::def::*;\n use hir::pat_util;\n-use ty::{self, Ty, TyCtxt, ParameterEnvironment};\n+use ty::{self, TyCtxt, ParameterEnvironment};\n use traits::{self, Reveal};\n use ty::subst::Subst;\n use lint;\n@@ -1440,28 +1440,30 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn fn_ret(&self, id: NodeId) -> ty::Binder<Ty<'tcx>> {\n-        let fn_ty = self.ir.tcx.tables().node_id_to_type(id);\n-        match fn_ty.sty {\n-            ty::TyClosure(closure_def_id, substs) =>\n-                self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n-            _ => fn_ty.fn_ret()\n-        }\n-    }\n-\n     fn check_ret(&self,\n                  id: NodeId,\n                  sp: Span,\n-                 _fk: FnKind,\n+                 fk: FnKind,\n                  entry_ln: LiveNode,\n                  body: &hir::Expr)\n     {\n+        let fn_ty = if let FnKind::Closure(_) = fk {\n+            self.ir.tcx.tables().node_id_to_type(id)\n+        } else {\n+            self.ir.tcx.item_type(self.ir.tcx.map.local_def_id(id))\n+        };\n+        let fn_ret = match fn_ty.sty {\n+            ty::TyClosure(closure_def_id, substs) =>\n+                self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n+            _ => fn_ty.fn_ret()\n+        };\n+\n         // within the fn body, late-bound regions are liberated\n         // and must outlive the *call-site* of the function.\n         let fn_ret =\n             self.ir.tcx.liberate_late_bound_regions(\n                 self.ir.tcx.region_maps.call_site_extent(id, body.id),\n-                &self.fn_ret(id));\n+                &fn_ret);\n \n         if !fn_ret.is_never() && self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             let param_env = ParameterEnvironment::for_item(self.ir.tcx, id);"}, {"sha": "b3cec6ec8ff3fa2b39a0b78f609af910e6697078", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -923,7 +923,7 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n                     ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n                         write!(fmt, \"{:?}[-{:?} of {:?}]\", data.base, offset, min_length),\n                     ProjectionElem::Subslice { from, to } if to == 0 =>\n-                        write!(fmt, \"{:?}[{:?}:\", data.base, from),\n+                        write!(fmt, \"{:?}[{:?}:]\", data.base, from),\n                     ProjectionElem::Subslice { from, to } if from == 0 =>\n                         write!(fmt, \"{:?}[:-{:?}]\", data.base, to),\n                     ProjectionElem::Subslice { from, to } =>"}, {"sha": "73ea84e94aec50c323428cc63e07da23daa08603", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -125,7 +125,7 @@ impl<'tcx> Lvalue<'tcx> {\n             Lvalue::Local(index) =>\n                 LvalueTy::Ty { ty: mir.local_decls[index].ty },\n             Lvalue::Static(def_id) =>\n-                LvalueTy::Ty { ty: tcx.lookup_item_type(def_id).ty },\n+                LvalueTy::Ty { ty: tcx.item_type(def_id) },\n             Lvalue::Projection(ref proj) =>\n                 proj.base.ty(mir, tcx).projection_ty(tcx, &proj.elem),\n         }\n@@ -188,7 +188,7 @@ impl<'tcx> Rvalue<'tcx> {\n                         ))\n                     }\n                     AggregateKind::Adt(def, _, substs, _) => {\n-                        Some(tcx.lookup_item_type(def.did).ty.subst(tcx, substs))\n+                        Some(tcx.item_type(def.did).subst(tcx, substs))\n                     }\n                     AggregateKind::Closure(did, substs) => {\n                         Some(tcx.mk_closure_from_closure_substs(did, substs))"}, {"sha": "b4592a03bcd1f3c3b730a761d5ed6f045a4535ad", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -154,9 +154,13 @@ impl<'a, 'gcx, 'tcx> DeferredObligation<'tcx> {\n     pub fn try_select(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n                       -> Option<Vec<PredicateObligation<'tcx>>> {\n         if let ty::TyAnon(def_id, substs) = self.predicate.skip_binder().self_ty().sty {\n+            let ty = if def_id.is_local() {\n+                tcx.item_types.borrow().get(&def_id).cloned()\n+            } else {\n+                Some(tcx.item_type(def_id))\n+            };\n             // We can resolve the `impl Trait` to its concrete type.\n-            if let Some(ty_scheme) = tcx.opt_lookup_item_type(def_id) {\n-                let concrete_ty = ty_scheme.ty.subst(tcx, substs);\n+            if let Some(concrete_ty) = ty.subst(tcx, substs) {\n                 let predicate = ty::TraitRef {\n                     def_id: self.predicate.def_id(),\n                     substs: tcx.mk_substs_trait(concrete_ty, &[])"}, {"sha": "eba24bfd2c9e2ddad1848bb97edd3dac5a0ed4b9", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -603,7 +603,7 @@ pub fn get_vtable_methods<'a, 'tcx>(\n             // do not hold for this particular set of type parameters.\n             // Note that this method could then never be called, so we\n             // do not want to try and trans it, in that case (see #23435).\n-            let predicates = tcx.lookup_predicates(def_id).instantiate_own(tcx, substs);\n+            let predicates = tcx.item_predicates(def_id).instantiate_own(tcx, substs);\n             if !normalize_and_test_predicates(tcx, predicates.predicates) {\n                 debug!(\"get_vtable_methods: predicates do not hold\");\n                 return None;"}, {"sha": "0681be129b67e9cbd3983ad8202065c2365fa566", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -129,7 +129,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let trait_def = self.lookup_trait_def(trait_def_id);\n         let trait_ref = trait_def.trait_ref.clone();\n         let trait_ref = trait_ref.to_poly_trait_ref();\n-        let predicates = self.lookup_super_predicates(trait_def_id);\n+        let predicates = self.item_super_predicates(trait_def_id);\n         predicates\n             .predicates\n             .into_iter()\n@@ -166,7 +166,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // Search for a predicate like `Self : Sized` amongst the trait bounds.\n         let free_substs = self.construct_free_substs(def_id,\n             self.region_maps.node_extent(ast::DUMMY_NODE_ID));\n-        let predicates = self.lookup_predicates(def_id);\n+        let predicates = self.item_predicates(def_id);\n         let predicates = predicates.instantiate(self, free_substs).predicates;\n         elaborate_predicates(self, predicates)\n             .any(|predicate| {\n@@ -238,7 +238,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         // The `Self` type is erased, so it should not appear in list of\n         // arguments or return type apart from the receiver.\n-        let ref sig = self.lookup_item_type(method.def_id).ty.fn_sig();\n+        let ref sig = self.item_type(method.def_id).fn_sig();\n         for &input_ty in &sig.0.inputs[1..] {\n             if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n                 return Some(MethodViolationCode::ReferencesSelf);\n@@ -249,7 +249,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // We can't monomorphize things like `fn foo<A>(...)`.\n-        if !self.lookup_generics(method.def_id).types.is_empty() {\n+        if !self.item_generics(method.def_id).types.is_empty() {\n             return Some(MethodViolationCode::Generic);\n         }\n "}, {"sha": "f1b69feb545efd8e0b6111d56a56f421e6f7e8bc", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -311,7 +311,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n             ty::TyAnon(def_id, substs) if !substs.has_escaping_regions() => { // (*)\n                 // Only normalize `impl Trait` after type-checking, usually in trans.\n                 if self.selcx.projection_mode() == Reveal::All {\n-                    let generic_ty = self.tcx().lookup_item_type(def_id).ty;\n+                    let generic_ty = self.tcx().item_type(def_id);\n                     let concrete_ty = generic_ty.subst(self.tcx(), substs);\n                     self.fold_ty(concrete_ty)\n                 } else {\n@@ -809,7 +809,7 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n     };\n \n     // If so, extract what we know from the trait and try to come up with a good answer.\n-    let trait_predicates = selcx.tcx().lookup_predicates(def_id);\n+    let trait_predicates = selcx.tcx().item_predicates(def_id);\n     let bounds = trait_predicates.instantiate(selcx.tcx(), substs);\n     let bounds = elaborate_predicates(selcx.tcx(), bounds.predicates);\n     assemble_candidates_from_predicates(selcx,\n@@ -1313,7 +1313,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n                        obligation.predicate.trait_ref);\n                 tcx.types.err\n             } else {\n-                tcx.lookup_item_type(node_item.item.def_id).ty\n+                tcx.item_type(node_item.item.def_id)\n             };\n             let substs = translate_substs(selcx.infcx(), impl_def_id, substs, node_item.node);\n             Progress {"}, {"sha": "3944c7e09c0b89a303e73a622c531c7ee5e59b54", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -1200,7 +1200,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 def_id={:?}, substs={:?}\",\n                def_id, substs);\n \n-        let item_predicates = self.tcx().lookup_predicates(def_id);\n+        let item_predicates = self.tcx().item_predicates(def_id);\n         let bounds = item_predicates.instantiate(self.tcx(), substs);\n         debug!(\"match_projection_obligation_against_definition_bounds: \\\n                 bounds={:?}\",\n@@ -2884,7 +2884,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // obligation will normalize to `<$0 as Iterator>::Item = $1` and\n         // `$1: Copy`, so we must ensure the obligations are emitted in\n         // that order.\n-        let predicates = tcx.lookup_predicates(def_id);\n+        let predicates = tcx.item_predicates(def_id);\n         assert_eq!(predicates.parent, None);\n         let predicates = predicates.predicates.iter().flat_map(|predicate| {\n             let predicate = normalize_with_depth(self, cause.clone(), recursion_depth,"}, {"sha": "b94597d475927e61bc36adca97d867fea11da994", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -128,7 +128,7 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n         match *predicate {\n             ty::Predicate::Trait(ref data) => {\n                 // Predicates declared on the trait.\n-                let predicates = tcx.lookup_super_predicates(data.def_id());\n+                let predicates = tcx.item_super_predicates(data.def_id());\n \n                 let mut predicates: Vec<_> =\n                     predicates.predicates\n@@ -295,7 +295,7 @@ impl<'cx, 'gcx, 'tcx> Iterator for SupertraitDefIds<'cx, 'gcx, 'tcx> {\n             None => { return None; }\n         };\n \n-        let predicates = self.tcx.lookup_super_predicates(def_id);\n+        let predicates = self.tcx.item_super_predicates(def_id);\n         let visited = &mut self.visited;\n         self.stack.extend(\n             predicates.predicates\n@@ -362,7 +362,7 @@ pub fn impl_trait_ref_and_oblig<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a,\n     let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n         super::normalize(selcx, ObligationCause::dummy(), &impl_trait_ref);\n \n-    let predicates = selcx.tcx().lookup_predicates(impl_def_id);\n+    let predicates = selcx.tcx().item_predicates(impl_def_id);\n     let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n     let Normalized { value: predicates, obligations: normalization_obligations2 } =\n         super::normalize(selcx, ObligationCause::dummy(), &predicates);"}, {"sha": "ac1c4fc6a1911428e2f212348b3d49e4c7a86eea", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -444,7 +444,7 @@ pub struct GlobalCtxt<'tcx> {\n     pub maybe_unused_trait_imports: NodeSet,\n \n     // Records the type of every item.\n-    pub tcache: RefCell<DepTrackingMap<maps::Tcache<'tcx>>>,\n+    pub item_types: RefCell<DepTrackingMap<maps::Types<'tcx>>>,\n \n     // Internal cache for metadata decoding. No need to track deps on this.\n     pub rcache: RefCell<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n@@ -665,10 +665,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.ty_param_defs.borrow().get(&node_id).unwrap().clone()\n     }\n \n-    pub fn node_type_insert(self, id: NodeId, ty: Ty<'gcx>) {\n-        self.tables.borrow_mut().node_types.insert(id, ty);\n-    }\n-\n     pub fn alloc_generics(self, generics: ty::Generics<'gcx>)\n                           -> &'gcx ty::Generics<'gcx> {\n         self.global_interners.arenas.generics.alloc(generics)\n@@ -815,7 +811,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             mir_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             freevars: RefCell::new(freevars),\n             maybe_unused_trait_imports: maybe_unused_trait_imports,\n-            tcache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            item_types: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             rcache: RefCell::new(FxHashMap()),\n             tc_cache: RefCell::new(FxHashMap()),\n             associated_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),"}, {"sha": "8222583d9a7da8162e232ac5e269d05033fe3ce5", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -218,7 +218,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // users may find it useful. Currently, we omit the parent if\n         // the impl is either in the same module as the self-type or\n         // as the trait.\n-        let self_ty = self.lookup_item_type(impl_def_id).ty;\n+        let self_ty = self.item_type(impl_def_id);\n         let in_self_mod = match characteristic_def_id_of_type(self_ty) {\n             None => false,\n             Some(ty_def_id) => self.parent_def_id(ty_def_id) == Some(parent_def_id),"}, {"sha": "bf0445858794e3ec2f4fd0a09d3afc805d484af1", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -33,7 +33,7 @@ macro_rules! dep_map_ty {\n }\n \n dep_map_ty! { AssociatedItems: AssociatedItems(DefId) -> ty::AssociatedItem }\n-dep_map_ty! { Tcache: ItemSignature(DefId) -> Ty<'tcx> }\n+dep_map_ty! { Types: ItemSignature(DefId) -> Ty<'tcx> }\n dep_map_ty! { Generics: ItemSignature(DefId) -> &'tcx ty::Generics<'tcx> }\n dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }"}, {"sha": "3db705140411aa2fd40439875f9f663c8ecb82f4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 14, "deletions": 72, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -169,9 +169,9 @@ impl<'a, 'gcx, 'tcx> ImplHeader<'tcx> {\n \n         let header = ImplHeader {\n             impl_def_id: impl_def_id,\n-            self_ty: tcx.lookup_item_type(impl_def_id).ty,\n+            self_ty: tcx.item_type(impl_def_id),\n             trait_ref: tcx.impl_trait_ref(impl_def_id),\n-            predicates: tcx.lookup_predicates(impl_def_id).predicates\n+            predicates: tcx.item_predicates(impl_def_id).predicates\n         }.subst(tcx, impl_substs);\n \n         let traits::Normalized { value: mut header, obligations } =\n@@ -708,7 +708,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n                         instantiated: &mut InstantiatedPredicates<'tcx>,\n                         substs: &Substs<'tcx>) {\n         if let Some(def_id) = self.parent {\n-            tcx.lookup_predicates(def_id).instantiate_into(tcx, instantiated, substs);\n+            tcx.item_predicates(def_id).instantiate_into(tcx, instantiated, substs);\n         }\n         instantiated.predicates.extend(self.predicates.iter().map(|p| p.subst(tcx, substs)))\n     }\n@@ -1301,31 +1301,6 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n     }\n }\n \n-/// A \"type scheme\", in ML terminology, is a type combined with some\n-/// set of generic types that the type is, well, generic over. In Rust\n-/// terms, it is the \"type\" of a fn item or struct -- this type will\n-/// include various generic parameters that must be substituted when\n-/// the item/struct is referenced. That is called converting the type\n-/// scheme to a monotype.\n-///\n-/// - `generics`: the set of type parameters and their bounds\n-/// - `ty`: the base types, which may reference the parameters defined\n-///   in `generics`\n-///\n-/// Note that TypeSchemes are also sometimes called \"polytypes\" (and\n-/// in fact this struct used to carry that name, so you may find some\n-/// stray references in a comment or something). We try to reserve the\n-/// \"poly\" prefix to refer to higher-ranked things, as in\n-/// `PolyTraitRef`.\n-///\n-/// Note that each item also comes with predicates, see\n-/// `lookup_predicates`.\n-#[derive(Clone, Debug)]\n-pub struct TypeScheme<'tcx> {\n-    pub generics: &'tcx Generics<'tcx>,\n-    pub ty: Ty<'tcx>,\n-}\n-\n bitflags! {\n     flags AdtFlags: u32 {\n         const NO_ADT_FLAGS        = 0,\n@@ -1359,8 +1334,6 @@ pub struct VariantDefData<'tcx, 'container: 'tcx> {\n }\n \n pub struct FieldDefData<'tcx, 'container: 'tcx> {\n-    /// The field's DefId. NOTE: the fields of tuple-like enum variants\n-    /// are not real items, and don't have entries in tcache etc.\n     pub did: DefId,\n     pub name: Name,\n     pub vis: Visibility,\n@@ -1541,14 +1514,9 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n         &self.variants[0]\n     }\n \n-    #[inline]\n-    pub fn type_scheme(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> TypeScheme<'gcx> {\n-        tcx.lookup_item_type(self.did)\n-    }\n-\n     #[inline]\n     pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> GenericPredicates<'gcx> {\n-        tcx.lookup_predicates(self.did)\n+        tcx.item_predicates(self.did)\n     }\n \n     /// Returns an iterator over all fields contained\n@@ -1784,7 +1752,7 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n                     def_id: sized_trait,\n                     substs: tcx.mk_substs_trait(ty, &[])\n                 }).to_predicate();\n-                let predicates = tcx.lookup_predicates(self.did).predicates;\n+                let predicates = tcx.item_predicates(self.did).predicates;\n                 if predicates.into_iter().any(|p| p == sized_predicate) {\n                     vec![]\n                 } else {\n@@ -1963,7 +1931,7 @@ impl LvaluePreference {\n }\n \n /// Helper for looking things up in the various maps that are populated during\n-/// typeck::collect (e.g., `tcx.associated_items`, `tcx.tcache`, etc).  All of\n+/// typeck::collect (e.g., `tcx.associated_items`, `tcx.types`, etc).  All of\n /// these share the pattern that if the id is local, it should have been loaded\n /// into the map by the `typeck::collect` phase.  If the def-id is external,\n /// then we have to go consult the crate loading code (and cache the result for\n@@ -2351,38 +2319,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // Register a given item type\n-    pub fn register_item_type(self, did: DefId, scheme: TypeScheme<'gcx>) {\n-        self.tcache.borrow_mut().insert(did, scheme.ty);\n-        self.generics.borrow_mut().insert(did, scheme.generics);\n-    }\n-\n     // If the given item is in an external crate, looks up its type and adds it to\n     // the type cache. Returns the type parameters and type.\n-    pub fn lookup_item_type(self, did: DefId) -> TypeScheme<'gcx> {\n-        let ty = lookup_locally_or_in_crate_store(\n-            \"tcache\", did, &self.tcache,\n-            || self.sess.cstore.item_type(self.global_tcx(), did));\n-\n-        TypeScheme {\n-            ty: ty,\n-            generics: self.lookup_generics(did)\n-        }\n-    }\n-\n-    pub fn opt_lookup_item_type(self, did: DefId) -> Option<TypeScheme<'gcx>> {\n-        if did.krate != LOCAL_CRATE {\n-            return Some(self.lookup_item_type(did));\n-        }\n-\n-        if let Some(ty) = self.tcache.borrow().get(&did).cloned() {\n-            Some(TypeScheme {\n-                ty: ty,\n-                generics: self.lookup_generics(did)\n-            })\n-        } else {\n-            None\n-        }\n+    pub fn item_type(self, did: DefId) -> Ty<'gcx> {\n+        lookup_locally_or_in_crate_store(\n+            \"item_types\", did, &self.item_types,\n+            || self.sess.cstore.item_type(self.global_tcx(), did))\n     }\n \n     /// Given the did of a trait, returns its canonical trait ref.\n@@ -2411,21 +2353,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Given the did of an item, returns its generics.\n-    pub fn lookup_generics(self, did: DefId) -> &'gcx Generics<'gcx> {\n+    pub fn item_generics(self, did: DefId) -> &'gcx Generics<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"generics\", did, &self.generics,\n             || self.alloc_generics(self.sess.cstore.item_generics(self.global_tcx(), did)))\n     }\n \n     /// Given the did of an item, returns its full set of predicates.\n-    pub fn lookup_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n+    pub fn item_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"predicates\", did, &self.predicates,\n             || self.sess.cstore.item_predicates(self.global_tcx(), did))\n     }\n \n     /// Given the did of a trait, returns its superpredicates.\n-    pub fn lookup_super_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n+    pub fn item_super_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"super_predicates\", did, &self.super_predicates,\n             || self.sess.cstore.item_super_predicates(self.global_tcx(), did))\n@@ -2718,7 +2660,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         //\n \n         let tcx = self.global_tcx();\n-        let generic_predicates = tcx.lookup_predicates(def_id);\n+        let generic_predicates = tcx.item_predicates(def_id);\n         let bounds = generic_predicates.instantiate(tcx, free_substs);\n         let bounds = tcx.liberate_late_bound_regions(free_id_outlive, &ty::Binder(bounds));\n         let predicates = bounds.predicates;"}, {"sha": "282cb9f80f51e46a5672c17d880d1df050bc312c", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -482,7 +482,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyAnon(did, substs) => ty::TyAnon(did, substs.fold_with(folder)),\n             ty::TyBool | ty::TyChar | ty::TyStr | ty::TyInt(_) |\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyError | ty::TyInfer(_) |\n-            ty::TyParam(..) | ty::TyNever => self.sty.clone(),\n+            ty::TyParam(..) | ty::TyNever => return self\n         };\n         folder.tcx().mk_ty(sty)\n     }"}, {"sha": "7d209093ec77662700b54242be90340d5ba7cf86", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -164,7 +164,7 @@ pub enum TypeVariants<'tcx> {\n     /// Anonymized (`impl Trait`) type found in a return type.\n     /// The DefId comes from the `impl Trait` ast::Ty node, and the\n     /// substitutions are for the generics of the function in question.\n-    /// After typeck, the concrete type can be found in the `tcache` map.\n+    /// After typeck, the concrete type can be found in the `types` map.\n     TyAnon(DefId, &'tcx Substs<'tcx>),\n \n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n@@ -556,7 +556,7 @@ pub struct DebruijnIndex {\n ///\n /// These are regions that are stored behind a binder and must be substituted\n /// with some concrete region before being used. There are 2 kind of\n-/// bound regions: early-bound, which are bound in a TypeScheme/TraitDef,\n+/// bound regions: early-bound, which are bound in an item's Generics,\n /// and are substituted by a Substs,  and late-bound, which are part of\n /// higher-ranked types (e.g. `for<'a> fn(&'a ())`) and are substituted by\n /// the likes of `liberate_late_bound_regions`. The distinction exists"}, {"sha": "15f4437ed0aaf431cea713a03c353504bec5d7f1", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -177,7 +177,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                             -> &'tcx Substs<'tcx>\n     where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n           FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx> {\n-        let defs = tcx.lookup_generics(def_id);\n+        let defs = tcx.item_generics(def_id);\n         let mut substs = Vec::with_capacity(defs.count());\n         Substs::fill_item(&mut substs, tcx, defs, &mut mk_region, &mut mk_type);\n         tcx.intern_substs(&substs)\n@@ -192,7 +192,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n           FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx> {\n \n         if let Some(def_id) = defs.parent {\n-            let parent_defs = tcx.lookup_generics(def_id);\n+            let parent_defs = tcx.item_generics(def_id);\n             Substs::fill_item(substs, tcx, parent_defs, mk_region, mk_type);\n         }\n \n@@ -271,7 +271,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                        source_ancestor: DefId,\n                        target_substs: &Substs<'tcx>)\n                        -> &'tcx Substs<'tcx> {\n-        let defs = tcx.lookup_generics(source_ancestor);\n+        let defs = tcx.item_generics(source_ancestor);\n         tcx.mk_substs(target_substs.iter().chain(&self[defs.own_count()..]).cloned())\n     }\n }\n@@ -519,7 +519,7 @@ impl<'a, 'gcx, 'tcx> ty::TraitRef<'tcx> {\n                        trait_id: DefId,\n                        substs: &Substs<'tcx>)\n                        -> ty::TraitRef<'tcx> {\n-        let defs = tcx.lookup_generics(trait_id);\n+        let defs = tcx.item_generics(trait_id);\n \n         ty::TraitRef {\n             def_id: trait_id,"}, {"sha": "fd81065e61d499f3590272c152ac8f5ad7dbec44", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -18,7 +18,7 @@ use std::cell::{Cell, RefCell};\n use hir;\n use util::nodemap::FxHashMap;\n \n-/// As `TypeScheme` but for a trait ref.\n+/// A trait's definition with type information.\n pub struct TraitDef<'tcx> {\n     pub unsafety: hir::Unsafety,\n "}, {"sha": "74c6d7d334c357747c062e027a135683fc1b46d5", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -446,7 +446,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                            -> Vec<traits::PredicateObligation<'tcx>>\n     {\n         let predicates =\n-            self.infcx.tcx.lookup_predicates(def_id)\n+            self.infcx.tcx.item_predicates(def_id)\n                           .instantiate(self.infcx.tcx, substs);\n         let cause = self.cause(traits::ItemObligation(def_id));\n         predicates.predicates"}, {"sha": "3ed4580336aac0ad0970ed4fa29369268b14d229", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -105,7 +105,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n                 }\n             }\n         }\n-        let mut generics = tcx.lookup_generics(item_def_id);\n+        let mut generics = tcx.item_generics(item_def_id);\n         let mut path_def_id = did;\n         verbose = tcx.sess.verbose();\n         has_self = generics.has_self;\n@@ -115,7 +115,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n             // Methods.\n             assert!(is_value_path);\n             child_types = generics.types.len();\n-            generics = tcx.lookup_generics(def_id);\n+            generics = tcx.item_generics(def_id);\n             num_regions = generics.regions.len();\n             num_types = generics.types.len();\n \n@@ -865,7 +865,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyAdt(def, substs) => {\n                 ty::tls::with(|tcx| {\n                     if def.did.is_local() &&\n-                          !tcx.tcache.borrow().contains_key(&def.did) {\n+                          !tcx.item_types.borrow().contains_key(&def.did) {\n                         write!(f, \"{}<..>\", tcx.item_path_str(def.did))\n                     } else {\n                         parameterized(f, substs, def.did, &[])\n@@ -878,7 +878,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 ty::tls::with(|tcx| {\n                     // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                     // by looking up the projections associated with the def_id.\n-                    let item_predicates = tcx.lookup_predicates(def_id);\n+                    let item_predicates = tcx.item_predicates(def_id);\n                     let substs = tcx.lift(&substs).unwrap_or_else(|| {\n                         tcx.intern_substs(&[])\n                     });"}, {"sha": "37216e20762d4970754319718206dcb94899f2b1", "filename": "src/librustc_back/target/armv5te_unknown_linux_gnueabi.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_back%2Ftarget%2Farmv5te_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_back%2Ftarget%2Farmv5te_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv5te_unknown_linux_gnueabi.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::{Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let base = super::linux_base::opts();\n+    Ok(Target {\n+        llvm_target: \"armv5te-unknown-linux-gnueabi\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n+        arch: \"arm\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+\n+        options: TargetOptions {\n+            features: \"+soft-float\".to_string(),\n+            // No atomic instructions on ARMv5\n+            max_atomic_width: Some(0),\n+            abi_blacklist: super::arm_base::abi_blacklist(),\n+            .. base\n+        }\n+    })\n+}\n+"}, {"sha": "14fe02269d142890d130025a93d5cd69e53a1131", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -145,6 +145,7 @@ supported_targets! {\n     (\"arm-unknown-linux-gnueabihf\", arm_unknown_linux_gnueabihf),\n     (\"arm-unknown-linux-musleabi\", arm_unknown_linux_musleabi),\n     (\"arm-unknown-linux-musleabihf\", arm_unknown_linux_musleabihf),\n+    (\"armv5te-unknown-linux-gnueabi\", armv5te_unknown_linux_gnueabi),\n     (\"armv7-unknown-linux-gnueabihf\", armv7_unknown_linux_gnueabihf),\n     (\"armv7-unknown-linux-musleabihf\", armv7_unknown_linux_musleabihf),\n     (\"aarch64-unknown-linux-gnu\", aarch64_unknown_linux_gnu),"}, {"sha": "eced5d1eb1b8060e060c7028a5ac4a06ae621d93", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -858,7 +858,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n             .unwrap_or_else(|e| tcx.sess.fatal(&e));\n         let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n-        let fty = tcx.lookup_item_type(free_func).ty.subst(tcx, substs);\n+        let fty = tcx.item_type(free_func).subst(tcx, substs);\n \n         self.patch.new_block(BasicBlockData {\n             statements: statements,"}, {"sha": "937cb3f600746cc7ace32a3cce6c5546858fa489", "filename": "src/librustc_data_structures/accumulate_vec.rs", "status": "modified", "additions": 152, "deletions": 6, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Faccumulate_vec.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -11,22 +11,68 @@\n //! A vector type intended to be used for collecting from iterators onto the stack.\n //!\n //! Space for up to N elements is provided on the stack.  If more elements are collected, Vec is\n-//! used to store the values on the heap. This type does not support re-allocating onto the heap,\n-//! and there is no way to push more elements onto the existing storage.\n+//! used to store the values on the heap.\n //!\n //! The N above is determined by Array's implementor, by way of an associatated constant.\n \n-use std::ops::Deref;\n-use std::iter::{IntoIterator, FromIterator};\n+use std::ops::{Deref, DerefMut};\n+use std::iter::{self, IntoIterator, FromIterator};\n+use std::slice;\n+use std::vec;\n \n-use array_vec::{Array, ArrayVec};\n+use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n \n-#[derive(Debug)]\n+use array_vec::{self, Array, ArrayVec};\n+\n+#[derive(PartialEq, Eq, Hash, Debug)]\n pub enum AccumulateVec<A: Array> {\n     Array(ArrayVec<A>),\n     Heap(Vec<A::Element>)\n }\n \n+impl<A> Clone for AccumulateVec<A>\n+    where A: Array,\n+          A::Element: Clone {\n+    fn clone(&self) -> Self {\n+        match *self {\n+            AccumulateVec::Array(ref arr) => AccumulateVec::Array(arr.clone()),\n+            AccumulateVec::Heap(ref vec) => AccumulateVec::Heap(vec.clone()),\n+        }\n+    }\n+}\n+\n+impl<A: Array> AccumulateVec<A> {\n+    pub fn new() -> AccumulateVec<A> {\n+        AccumulateVec::Array(ArrayVec::new())\n+    }\n+\n+    pub fn one(el: A::Element) -> Self {\n+        iter::once(el).collect()\n+    }\n+\n+    pub fn many<I: IntoIterator<Item=A::Element>>(iter: I) -> Self {\n+        iter.into_iter().collect()\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        match *self {\n+            AccumulateVec::Array(ref arr) => arr.len(),\n+            AccumulateVec::Heap(ref vec) => vec.len(),\n+        }\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+\n+    pub fn pop(&mut self) -> Option<A::Element> {\n+        match *self {\n+            AccumulateVec::Array(ref mut arr) => arr.pop(),\n+            AccumulateVec::Heap(ref mut vec) => vec.pop(),\n+        }\n+    }\n+}\n+\n impl<A: Array> Deref for AccumulateVec<A> {\n     type Target = [A::Element];\n     fn deref(&self) -> &Self::Target {\n@@ -37,6 +83,15 @@ impl<A: Array> Deref for AccumulateVec<A> {\n     }\n }\n \n+impl<A: Array> DerefMut for AccumulateVec<A> {\n+    fn deref_mut(&mut self) -> &mut [A::Element] {\n+        match *self {\n+            AccumulateVec::Array(ref mut v) => &mut v[..],\n+            AccumulateVec::Heap(ref mut v) => &mut v[..],\n+        }\n+    }\n+}\n+\n impl<A: Array> FromIterator<A::Element> for AccumulateVec<A> {\n     fn from_iter<I>(iter: I) -> AccumulateVec<A> where I: IntoIterator<Item=A::Element> {\n         let iter = iter.into_iter();\n@@ -50,3 +105,94 @@ impl<A: Array> FromIterator<A::Element> for AccumulateVec<A> {\n     }\n }\n \n+pub struct IntoIter<A: Array> {\n+    repr: IntoIterRepr<A>,\n+}\n+\n+enum IntoIterRepr<A: Array> {\n+    Array(array_vec::Iter<A>),\n+    Heap(vec::IntoIter<A::Element>),\n+}\n+\n+impl<A: Array> Iterator for IntoIter<A> {\n+    type Item = A::Element;\n+\n+    fn next(&mut self) -> Option<A::Element> {\n+        match self.repr {\n+            IntoIterRepr::Array(ref mut arr) => arr.next(),\n+            IntoIterRepr::Heap(ref mut iter) => iter.next(),\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        match self.repr {\n+            IntoIterRepr::Array(ref iter) => iter.size_hint(),\n+            IntoIterRepr::Heap(ref iter) => iter.size_hint(),\n+        }\n+    }\n+}\n+\n+impl<A: Array> IntoIterator for AccumulateVec<A> {\n+    type Item = A::Element;\n+    type IntoIter = IntoIter<A>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        IntoIter {\n+            repr: match self {\n+                AccumulateVec::Array(arr) => IntoIterRepr::Array(arr.into_iter()),\n+                AccumulateVec::Heap(vec) => IntoIterRepr::Heap(vec.into_iter()),\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, A: Array> IntoIterator for &'a AccumulateVec<A> {\n+    type Item = &'a A::Element;\n+    type IntoIter = slice::Iter<'a, A::Element>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, A: Array> IntoIterator for &'a mut AccumulateVec<A> {\n+    type Item = &'a mut A::Element;\n+    type IntoIter = slice::IterMut<'a, A::Element>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.iter_mut()\n+    }\n+}\n+\n+impl<A: Array> From<Vec<A::Element>> for AccumulateVec<A> {\n+    fn from(v: Vec<A::Element>) -> AccumulateVec<A> {\n+        AccumulateVec::many(v)\n+    }\n+}\n+\n+impl<A: Array> Default for AccumulateVec<A> {\n+    fn default() -> AccumulateVec<A> {\n+        AccumulateVec::new()\n+    }\n+}\n+\n+impl<A> Encodable for AccumulateVec<A>\n+    where A: Array,\n+          A::Element: Encodable {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<A> Decodable for AccumulateVec<A>\n+    where A: Array,\n+          A::Element: Decodable {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<AccumulateVec<A>, D::Error> {\n+        d.read_seq(|d, len| {\n+            Ok(try!((0..len).map(|i| d.read_seq_elt(i, |d| Decodable::decode(d))).collect()))\n+        })\n+    }\n+}\n+"}, {"sha": "631cf2cfcf6db1fdc63a2d666f340af980ef0312", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 139, "deletions": 10, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -9,22 +9,28 @@\n // except according to those terms.\n \n //! A stack-allocated vector, allowing storage of N elements on the stack.\n-//!\n-//! Currently, only the N = 8 case is supported (due to Array only being impl-ed for [T; 8]).\n \n use std::marker::Unsize;\n use std::iter::Extend;\n-use std::ptr::drop_in_place;\n-use std::ops::{Deref, DerefMut};\n+use std::ptr::{self, drop_in_place};\n+use std::ops::{Deref, DerefMut, Range};\n+use std::hash::{Hash, Hasher};\n use std::slice;\n use std::fmt;\n+use std::mem;\n \n pub unsafe trait Array {\n     type Element;\n     type PartialStorage: Default + Unsize<[ManuallyDrop<Self::Element>]>;\n     const LEN: usize;\n }\n \n+unsafe impl<T> Array for [T; 1] {\n+    type Element = T;\n+    type PartialStorage = [ManuallyDrop<T>; 1];\n+    const LEN: usize = 1;\n+}\n+\n unsafe impl<T> Array for [T; 8] {\n     type Element = T;\n     type PartialStorage = [ManuallyDrop<T>; 8];\n@@ -36,13 +42,74 @@ pub struct ArrayVec<A: Array> {\n     values: A::PartialStorage\n }\n \n+impl<A> Hash for ArrayVec<A>\n+    where A: Array,\n+          A::Element: Hash {\n+    fn hash<H>(&self, state: &mut H) where H: Hasher {\n+        (&self[..]).hash(state);\n+    }\n+}\n+\n+impl<A: Array> PartialEq for ArrayVec<A> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self == other\n+    }\n+}\n+\n+impl<A: Array> Eq for ArrayVec<A> {}\n+\n+impl<A> Clone for ArrayVec<A>\n+    where A: Array,\n+          A::Element: Clone {\n+    fn clone(&self) -> Self {\n+        let mut v = ArrayVec::new();\n+        v.extend(self.iter().cloned());\n+        v\n+    }\n+}\n+\n impl<A: Array> ArrayVec<A> {\n     pub fn new() -> Self {\n         ArrayVec {\n             count: 0,\n             values: Default::default(),\n         }\n     }\n+\n+    pub fn len(&self) -> usize {\n+        self.count\n+    }\n+\n+    pub unsafe fn set_len(&mut self, len: usize) {\n+        self.count = len;\n+    }\n+\n+    /// Panics when the stack vector is full.\n+    pub fn push(&mut self, el: A::Element) {\n+        let arr = &mut self.values as &mut [ManuallyDrop<_>];\n+        arr[self.count] = ManuallyDrop { value: el };\n+        self.count += 1;\n+    }\n+\n+    pub fn pop(&mut self) -> Option<A::Element> {\n+        if self.count > 0 {\n+            let arr = &mut self.values as &mut [ManuallyDrop<_>];\n+            self.count -= 1;\n+            unsafe {\n+                let value = ptr::read(&arr[self.count]);\n+                Some(value.value)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<A> Default for ArrayVec<A>\n+    where A: Array {\n+    fn default() -> Self {\n+        ArrayVec::new()\n+    }\n }\n \n impl<A> fmt::Debug for ArrayVec<A>\n@@ -81,15 +148,69 @@ impl<A: Array> Drop for ArrayVec<A> {\n impl<A: Array> Extend<A::Element> for ArrayVec<A> {\n     fn extend<I>(&mut self, iter: I) where I: IntoIterator<Item=A::Element> {\n         for el in iter {\n-            unsafe {\n-                let arr = &mut self.values as &mut [ManuallyDrop<_>];\n-                arr[self.count].value = el;\n-            }\n-            self.count += 1;\n+            self.push(el);\n+        }\n+    }\n+}\n+\n+pub struct Iter<A: Array> {\n+    indices: Range<usize>,\n+    store: A::PartialStorage,\n+}\n+\n+impl<A: Array> Drop for Iter<A> {\n+    fn drop(&mut self) {\n+        for _ in self {}\n+    }\n+}\n+\n+impl<A: Array> Iterator for Iter<A> {\n+    type Item = A::Element;\n+\n+    fn next(&mut self) -> Option<A::Element> {\n+        let arr = &self.store as &[ManuallyDrop<_>];\n+        unsafe {\n+            self.indices.next().map(|i| ptr::read(&arr[i]).value)\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.indices.size_hint()\n+    }\n+}\n+\n+impl<A: Array> IntoIterator for ArrayVec<A> {\n+    type Item = A::Element;\n+    type IntoIter = Iter<A>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        let store = unsafe {\n+            ptr::read(&self.values)\n+        };\n+        let indices = 0..self.count;\n+        mem::forget(self);\n+        Iter {\n+            indices: indices,\n+            store: store,\n         }\n     }\n }\n \n+impl<'a, A: Array> IntoIterator for &'a ArrayVec<A> {\n+    type Item = &'a A::Element;\n+    type IntoIter = slice::Iter<'a, A::Element>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, A: Array> IntoIterator for &'a mut ArrayVec<A> {\n+    type Item = &'a mut A::Element;\n+    type IntoIter = slice::IterMut<'a, A::Element>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.iter_mut()\n+    }\n+}\n+\n // FIXME: This should use repr(transparent) from rust-lang/rfcs#1758.\n #[allow(unions_with_drop_fields)]\n pub union ManuallyDrop<T> {\n@@ -98,9 +219,17 @@ pub union ManuallyDrop<T> {\n     empty: (),\n }\n \n+impl<T> ManuallyDrop<T> {\n+    fn new() -> ManuallyDrop<T> {\n+        ManuallyDrop {\n+            empty: ()\n+        }\n+    }\n+}\n+\n impl<T> Default for ManuallyDrop<T> {\n     fn default() -> Self {\n-        ManuallyDrop { empty: () }\n+        ManuallyDrop::new()\n     }\n }\n "}, {"sha": "f94ed6b7209462dd0d7343492d2de705a9fc358a", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 84, "deletions": 15, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -231,18 +231,30 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n \n     // # Iterating over nodes, edges\n \n+    pub fn enumerated_nodes(&self) -> EnumeratedNodes<N> {\n+        EnumeratedNodes {\n+            iter: self.nodes.iter().enumerate()\n+        }\n+    }\n+\n+    pub fn enumerated_edges(&self) -> EnumeratedEdges<E> {\n+        EnumeratedEdges {\n+            iter: self.edges.iter().enumerate()\n+        }\n+    }\n+\n     pub fn each_node<'a, F>(&'a self, mut f: F) -> bool\n         where F: FnMut(NodeIndex, &'a Node<N>) -> bool\n     {\n         //! Iterates over all edges defined in the graph.\n-        self.nodes.iter().enumerate().all(|(i, node)| f(NodeIndex(i), node))\n+        self.enumerated_nodes().all(|(node_idx, node)| f(node_idx, node))\n     }\n \n     pub fn each_edge<'a, F>(&'a self, mut f: F) -> bool\n         where F: FnMut(EdgeIndex, &'a Edge<E>) -> bool\n     {\n         //! Iterates over all edges defined in the graph\n-        self.edges.iter().enumerate().all(|(i, edge)| f(EdgeIndex(i), edge))\n+        self.enumerated_edges().all(|(edge_idx, edge)| f(edge_idx, edge))\n     }\n \n     pub fn outgoing_edges(&self, source: NodeIndex) -> AdjacentEdges<N, E> {\n@@ -270,14 +282,11 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         self.incoming_edges(target).sources()\n     }\n \n-    // # Fixed-point iteration\n-    //\n-    // A common use for graphs in our compiler is to perform\n-    // fixed-point iteration. In this case, each edge represents a\n-    // constraint, and the nodes themselves are associated with\n-    // variables or other bitsets. This method facilitates such a\n-    // computation.\n-\n+    /// A common use for graphs in our compiler is to perform\n+    /// fixed-point iteration. In this case, each edge represents a\n+    /// constraint, and the nodes themselves are associated with\n+    /// variables or other bitsets. This method facilitates such a\n+    /// computation.\n     pub fn iterate_until_fixed_point<'a, F>(&'a self, mut op: F)\n         where F: FnMut(usize, EdgeIndex, &'a Edge<E>) -> bool\n     {\n@@ -286,8 +295,8 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         while changed {\n             changed = false;\n             iteration += 1;\n-            for (i, edge) in self.edges.iter().enumerate() {\n-                changed |= op(iteration, EdgeIndex(i), edge);\n+            for (edge_index, edge) in self.enumerated_edges() {\n+                changed |= op(iteration, edge_index, edge);\n             }\n         }\n     }\n@@ -298,10 +307,67 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n                               -> DepthFirstTraversal<'a, N, E> {\n         DepthFirstTraversal::with_start_node(self, start, direction)\n     }\n+\n+    /// Whether or not a node can be reached from itself.\n+    pub fn is_node_cyclic(&self, starting_node_index: NodeIndex) -> bool {\n+        // This is similar to depth traversal below, but we\n+        // can't use that, because depth traversal doesn't show\n+        // the starting node a second time.\n+        let mut visited = BitVector::new(self.len_nodes());\n+        let mut stack = vec![starting_node_index];\n+\n+        while let Some(current_node_index) = stack.pop() {\n+            visited.insert(current_node_index.0);\n+\n+            // Directionality doesn't change the answer,\n+            // so just use outgoing edges.\n+            for (_, edge) in self.outgoing_edges(current_node_index) {\n+                let target_node_index = edge.target();\n+\n+                if target_node_index == starting_node_index {\n+                    return true;\n+                }\n+\n+                if !visited.contains(target_node_index.0) {\n+                    stack.push(target_node_index);\n+                }\n+            }\n+        }\n+\n+        false\n+    }\n }\n \n // # Iterators\n \n+pub struct EnumeratedNodes<'g, N>\n+    where N: 'g,\n+{\n+    iter: ::std::iter::Enumerate<::std::slice::Iter<'g, Node<N>>>\n+}\n+\n+impl<'g, N: Debug> Iterator for EnumeratedNodes<'g, N> {\n+    type Item = (NodeIndex, &'g Node<N>);\n+\n+    fn next(&mut self) -> Option<(NodeIndex, &'g Node<N>)> {\n+        self.iter.next().map(|(idx, n)| (NodeIndex(idx), n))\n+    }\n+}\n+\n+pub struct EnumeratedEdges<'g, E>\n+    where E: 'g,\n+{\n+    iter: ::std::iter::Enumerate<::std::slice::Iter<'g, Edge<E>>>\n+}\n+\n+impl<'g, E: Debug> Iterator for EnumeratedEdges<'g, E> {\n+    type Item = (EdgeIndex, &'g Edge<E>);\n+\n+    fn next(&mut self) -> Option<(EdgeIndex, &'g Edge<E>)> {\n+        self.iter.next().map(|(idx, e)| (EdgeIndex(idx), e))\n+    }\n+}\n+\n pub struct AdjacentEdges<'g, N, E>\n     where N: 'g,\n           E: 'g\n@@ -336,7 +402,7 @@ impl<'g, N: Debug, E: Debug> Iterator for AdjacentEdges<'g, N, E> {\n     }\n }\n \n-pub struct AdjacentTargets<'g, N: 'g, E: 'g>\n+pub struct AdjacentTargets<'g, N, E>\n     where N: 'g,\n           E: 'g\n {\n@@ -351,7 +417,7 @@ impl<'g, N: Debug, E: Debug> Iterator for AdjacentTargets<'g, N, E> {\n     }\n }\n \n-pub struct AdjacentSources<'g, N: 'g, E: 'g>\n+pub struct AdjacentSources<'g, N, E>\n     where N: 'g,\n           E: 'g\n {\n@@ -366,7 +432,10 @@ impl<'g, N: Debug, E: Debug> Iterator for AdjacentSources<'g, N, E> {\n     }\n }\n \n-pub struct DepthFirstTraversal<'g, N: 'g, E: 'g> {\n+pub struct DepthFirstTraversal<'g, N, E>\n+    where N: 'g,\n+          E: 'g\n+{\n     graph: &'g Graph<N, E>,\n     stack: Vec<NodeIndex>,\n     visited: BitVector,"}, {"sha": "a87410e6e1c8ce398d1f56c6ea61d4f81ba9d22f", "filename": "src/librustc_data_structures/graph/tests.rs", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -20,10 +20,13 @@ fn create_graph() -> TestGraph {\n \n     // Create a simple graph\n     //\n-    //    A -+> B --> C\n-    //       |  |     ^\n-    //       |  v     |\n-    //       F  D --> E\n+    //          F\n+    //          |\n+    //          V\n+    //    A --> B --> C\n+    //          |     ^\n+    //          v     |\n+    //          D --> E\n \n     let a = graph.add_node(\"A\");\n     let b = graph.add_node(\"B\");\n@@ -42,6 +45,29 @@ fn create_graph() -> TestGraph {\n     return graph;\n }\n \n+fn create_graph_with_cycle() -> TestGraph {\n+    let mut graph = Graph::new();\n+\n+    // Create a graph with a cycle.\n+    //\n+    //    A --> B <-- +\n+    //          |     |\n+    //          v     |\n+    //          C --> D\n+\n+    let a = graph.add_node(\"A\");\n+    let b = graph.add_node(\"B\");\n+    let c = graph.add_node(\"C\");\n+    let d = graph.add_node(\"D\");\n+\n+    graph.add_edge(a, b, \"AB\");\n+    graph.add_edge(b, c, \"BC\");\n+    graph.add_edge(c, d, \"CD\");\n+    graph.add_edge(d, b, \"DB\");\n+\n+    return graph;\n+}\n+\n #[test]\n fn each_node() {\n     let graph = create_graph();\n@@ -139,3 +165,15 @@ fn each_adjacent_from_d() {\n     let graph = create_graph();\n     test_adjacent_edges(&graph, NodeIndex(3), \"D\", &[(\"BD\", \"B\")], &[(\"DE\", \"E\")]);\n }\n+\n+#[test]\n+fn is_node_cyclic_a() {\n+    let graph = create_graph_with_cycle();\n+    assert!(!graph.is_node_cyclic(NodeIndex(0)));\n+}\n+\n+#[test]\n+fn is_node_cyclic_b() {\n+    let graph = create_graph_with_cycle();\n+    assert!(graph.is_node_cyclic(NodeIndex(1)));\n+}"}, {"sha": "2e4206d2ee1ee48efdc0fd1add328a2824b313df", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -46,6 +46,7 @@ extern crate libc;\n \n pub mod array_vec;\n pub mod accumulate_vec;\n+pub mod small_vec;\n pub mod bitslice;\n pub mod blake2b;\n pub mod bitvec;"}, {"sha": "565a3c443a34ab0581c33bdb6cd1045c33c0d24f", "filename": "src/librustc_data_structures/small_vec.rs", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsmall_vec.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,203 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A vector type intended to be used for collecting from iterators onto the stack.\n+//!\n+//! Space for up to N elements is provided on the stack.  If more elements are collected, Vec is\n+//! used to store the values on the heap. SmallVec is similar to AccumulateVec, but adds\n+//! the ability to push elements.\n+//!\n+//! The N above is determined by Array's implementor, by way of an associatated constant.\n+\n+use std::ops::{Deref, DerefMut};\n+use std::iter::{IntoIterator, FromIterator};\n+use std::fmt::{self, Debug};\n+use std::mem;\n+use std::ptr;\n+\n+use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n+\n+use accumulate_vec::{IntoIter, AccumulateVec};\n+use array_vec::Array;\n+\n+pub struct SmallVec<A: Array>(AccumulateVec<A>);\n+\n+impl<A> Clone for SmallVec<A>\n+    where A: Array,\n+          A::Element: Clone {\n+    fn clone(&self) -> Self {\n+        SmallVec(self.0.clone())\n+    }\n+}\n+\n+impl<A> Debug for SmallVec<A>\n+    where A: Array + Debug,\n+          A::Element: Debug {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"SmallVec\").field(&self.0).finish()\n+    }\n+}\n+\n+impl<A: Array> SmallVec<A> {\n+    pub fn new() -> Self {\n+        SmallVec(AccumulateVec::new())\n+    }\n+\n+    pub fn with_capacity(cap: usize) -> Self {\n+        let mut vec = SmallVec::new();\n+        vec.reserve(cap);\n+        vec\n+    }\n+\n+    pub fn one(el: A::Element) -> Self {\n+        SmallVec(AccumulateVec::one(el))\n+    }\n+\n+    pub fn many<I: IntoIterator<Item=A::Element>>(els: I) -> Self {\n+        SmallVec(AccumulateVec::many(els))\n+    }\n+\n+    pub fn expect_one(self, err: &'static str) -> A::Element {\n+        assert!(self.len() == 1, err);\n+        match self.0 {\n+            AccumulateVec::Array(arr) => arr.into_iter().next().unwrap(),\n+            AccumulateVec::Heap(vec) => vec.into_iter().next().unwrap(),\n+        }\n+    }\n+\n+    /// Will reallocate onto the heap if needed.\n+    pub fn push(&mut self, el: A::Element) {\n+        self.reserve(1);\n+        match self.0 {\n+            AccumulateVec::Array(ref mut array) => array.push(el),\n+            AccumulateVec::Heap(ref mut vec) => vec.push(el),\n+        }\n+    }\n+\n+    pub fn reserve(&mut self, n: usize) {\n+        match self.0 {\n+            AccumulateVec::Array(_) => {\n+                if self.len() + n > A::LEN {\n+                    let len = self.len();\n+                    let array = mem::replace(&mut self.0,\n+                            AccumulateVec::Heap(Vec::with_capacity(len + n)));\n+                    if let AccumulateVec::Array(array) = array {\n+                        match self.0 {\n+                            AccumulateVec::Heap(ref mut vec) => vec.extend(array),\n+                            _ => unreachable!()\n+                        }\n+                    }\n+                }\n+            }\n+            AccumulateVec::Heap(ref mut vec) => vec.reserve(n)\n+        }\n+    }\n+\n+    pub unsafe fn set_len(&mut self, len: usize) {\n+        match self.0 {\n+            AccumulateVec::Array(ref mut arr) => arr.set_len(len),\n+            AccumulateVec::Heap(ref mut vec) => vec.set_len(len),\n+        }\n+    }\n+\n+    pub fn insert(&mut self, index: usize, element: A::Element) {\n+        let len = self.len();\n+\n+        // Reserve space for shifting elements to the right\n+        self.reserve(1);\n+\n+        assert!(index <= len);\n+\n+        unsafe {\n+            // infallible\n+            // The spot to put the new value\n+            {\n+                let p = self.as_mut_ptr().offset(index as isize);\n+                // Shift everything over to make space. (Duplicating the\n+                // `index`th element into two consecutive places.)\n+                ptr::copy(p, p.offset(1), len - index);\n+                // Write it in, overwriting the first copy of the `index`th\n+                // element.\n+                ptr::write(p, element);\n+            }\n+            self.set_len(len + 1);\n+        }\n+    }\n+}\n+\n+impl<A: Array> Deref for SmallVec<A> {\n+    type Target = AccumulateVec<A>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+impl<A: Array> DerefMut for SmallVec<A> {\n+    fn deref_mut(&mut self) -> &mut AccumulateVec<A> {\n+        &mut self.0\n+    }\n+}\n+\n+impl<A: Array> FromIterator<A::Element> for SmallVec<A> {\n+    fn from_iter<I>(iter: I) -> Self where I: IntoIterator<Item=A::Element> {\n+        SmallVec(iter.into_iter().collect())\n+    }\n+}\n+\n+impl<A: Array> Extend<A::Element> for SmallVec<A> {\n+    fn extend<I: IntoIterator<Item=A::Element>>(&mut self, iter: I) {\n+        let iter = iter.into_iter();\n+        self.reserve(iter.size_hint().0);\n+        for el in iter {\n+            self.push(el);\n+        }\n+    }\n+}\n+\n+impl<A: Array> IntoIterator for SmallVec<A> {\n+    type Item = A::Element;\n+    type IntoIter = IntoIter<A>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.0.into_iter()\n+    }\n+}\n+\n+impl<A: Array> Default for SmallVec<A> {\n+    fn default() -> SmallVec<A> {\n+        SmallVec::new()\n+    }\n+}\n+\n+impl<A> Encodable for SmallVec<A>\n+    where A: Array,\n+          A::Element: Encodable {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<A> Decodable for SmallVec<A>\n+    where A: Array,\n+          A::Element: Decodable {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<SmallVec<A>, D::Error> {\n+        d.read_seq(|d, len| {\n+            let mut vec = SmallVec::with_capacity(len);\n+            for i in 0..len {\n+                vec.push(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+            }\n+            Ok(vec)\n+        })\n+    }\n+}"}, {"sha": "f6b6c89b7cc21152625811cc6486338537c74940", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -118,19 +118,20 @@ impl LateLintPass for BoxPointers {\n             hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n             hir::ItemUnion(..) => {\n-                self.check_heap_type(cx, it.span, cx.tcx.tables().node_id_to_type(it.id))\n+                let def_id = cx.tcx.map.local_def_id(it.id);\n+                self.check_heap_type(cx, it.span, cx.tcx.item_type(def_id))\n             }\n-            _ => (),\n+            _ => ()\n         }\n \n         // If it's a struct, we also have to check the fields' types\n         match it.node {\n             hir::ItemStruct(ref struct_def, _) |\n             hir::ItemUnion(ref struct_def, _) => {\n                 for struct_field in struct_def.fields() {\n-                    self.check_heap_type(cx,\n-                                         struct_field.span,\n-                                         cx.tcx.tables().node_id_to_type(struct_field.id));\n+                    let def_id = cx.tcx.map.local_def_id(struct_field.id);\n+                    self.check_heap_type(cx, struct_field.span,\n+                                         cx.tcx.item_type(def_id));\n                 }\n             }\n             _ => (),\n@@ -585,11 +586,9 @@ impl LateLintPass for MissingDebugImplementations {\n             let debug_def = cx.tcx.lookup_trait_def(debug);\n             let mut impls = NodeSet();\n             debug_def.for_each_impl(cx.tcx, |d| {\n-                if let Some(n) = cx.tcx.map.as_local_node_id(d) {\n-                    if let Some(ty_def) = cx.tcx.tables().node_id_to_type(n).ty_to_def_id() {\n-                        if let Some(node_id) = cx.tcx.map.as_local_node_id(ty_def) {\n-                            impls.insert(node_id);\n-                        }\n+                if let Some(ty_def) = cx.tcx.item_type(d).ty_to_def_id() {\n+                    if let Some(node_id) = cx.tcx.map.as_local_node_id(ty_def) {\n+                        impls.insert(node_id);\n                     }\n                 }\n             });\n@@ -1225,7 +1224,7 @@ impl LateLintPass for MutableTransmutes {\n         }\n \n         fn def_id_is_transmute(cx: &LateContext, def_id: DefId) -> bool {\n-            match cx.tcx.lookup_item_type(def_id).ty.sty {\n+            match cx.tcx.item_type(def_id).sty {\n                 ty::TyFnDef(.., ref bfty) if bfty.abi == RustIntrinsic => (),\n                 _ => return false,\n             }\n@@ -1282,7 +1281,7 @@ impl LateLintPass for UnionsWithDropFields {\n         if let hir::ItemUnion(ref vdata, _) = item.node {\n             let param_env = &ty::ParameterEnvironment::for_item(ctx.tcx, item.id);\n             for field in vdata.fields() {\n-                let field_ty = ctx.tcx.tables().node_id_to_type(field.id);\n+                let field_ty = ctx.tcx.item_type(ctx.tcx.map.local_def_id(field.id));\n                 if ctx.tcx.type_needs_drop_given_env(field_ty, param_env) {\n                     ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n                                   field.span,"}, {"sha": "4155d3e67a26deef03b823810001c13df12d81d4", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -675,8 +675,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n     fn check_foreign_fn(&mut self, id: ast::NodeId, decl: &hir::FnDecl) {\n         let def_id = self.cx.tcx.map.local_def_id(id);\n-        let scheme = self.cx.tcx.lookup_item_type(def_id);\n-        let sig = scheme.ty.fn_sig();\n+        let sig = self.cx.tcx.item_type(def_id).fn_sig();\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n \n         for (&input_ty, input_hir) in sig.inputs.iter().zip(&decl.inputs) {\n@@ -693,8 +692,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n     fn check_foreign_static(&mut self, id: ast::NodeId, span: Span) {\n         let def_id = self.cx.tcx.map.local_def_id(id);\n-        let scheme = self.cx.tcx.lookup_item_type(def_id);\n-        self.check_type_for_ffi_and_report_errors(span, scheme.ty);\n+        let ty = self.cx.tcx.item_type(def_id);\n+        self.check_type_for_ffi_and_report_errors(span, ty);\n     }\n }\n \n@@ -740,11 +739,12 @@ impl LateLintPass for VariantSizeDifferences {\n         if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types\n-                let t = cx.tcx.tables().node_id_to_type(it.id);\n+                let t = cx.tcx.item_type(cx.tcx.map.local_def_id(it.id));\n                 let layout = cx.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n                     let ty = cx.tcx.erase_regions(&t);\n-                    ty.layout(&infcx)\n-                        .unwrap_or_else(|e| bug!(\"failed to get layout for `{}`: {}\", t, e))\n+                    ty.layout(&infcx).unwrap_or_else(|e| {\n+                        bug!(\"failed to get layout for `{}`: {}\", t, e)\n+                    })\n                 });\n \n                 if let Layout::General { ref variants, ref size, discr, .. } = *layout {"}, {"sha": "e2fa535bb44a0162d120def300be20e038f3c822", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -133,15 +133,18 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n         &InlinedItem::ImplItem(_, ref ii) => ii.id,\n     };\n     let inlined_did = tcx.map.local_def_id(item_node_id);\n-    tcx.register_item_type(inlined_did, tcx.lookup_item_type(orig_did));\n+    let ty = tcx.item_type(orig_did);\n+    let generics = tcx.item_generics(orig_did);\n+    tcx.item_types.borrow_mut().insert(inlined_did, ty);\n+    tcx.generics.borrow_mut().insert(inlined_did, generics);\n \n     for (id, entry) in ast.side_tables.decode((cdata, tcx, id_ranges)) {\n         match entry {\n             TableEntry::Def(def) => {\n                 tcx.def_map.borrow_mut().insert(id, def::PathResolution::new(def));\n             }\n             TableEntry::NodeType(ty) => {\n-                tcx.node_type_insert(id, ty);\n+                tcx.tables.borrow_mut().node_types.insert(id, ty);\n             }\n             TableEntry::ItemSubsts(item_substs) => {\n                 tcx.tables.borrow_mut().item_substs.insert(id, item_substs);"}, {"sha": "ba85544326f8f547f7c3712e7ece07724ecde05a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -527,7 +527,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n         ty::TraitDef::new(data.unsafety,\n                           data.paren_sugar,\n-                          tcx.lookup_generics(self.local_def_id(item_id)),\n+                          tcx.item_generics(self.local_def_id(item_id)),\n                           data.trait_ref.decode((self, tcx)),\n                           self.def_path(item_id).unwrap().deterministic_hash(tcx))\n     }"}, {"sha": "f169ad6648086febb38c37ce37aa9f0672be6606", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_item_type(&mut self, def_id: DefId) -> Lazy<Ty<'tcx>> {\n         let tcx = self.tcx;\n-        self.lazy(&tcx.lookup_item_type(def_id).ty)\n+        self.lazy(&tcx.item_type(def_id))\n     }\n \n     /// Encode data for the given variant of the given ADT. The\n@@ -444,12 +444,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_generics(&mut self, def_id: DefId) -> Lazy<ty::Generics<'tcx>> {\n         let tcx = self.tcx;\n-        self.lazy(tcx.lookup_generics(def_id))\n+        self.lazy(tcx.item_generics(def_id))\n     }\n \n     fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n         let tcx = self.tcx;\n-        self.lazy(&tcx.lookup_predicates(def_id))\n+        self.lazy(&tcx.item_predicates(def_id))\n     }\n \n     fn encode_info_for_trait_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n@@ -556,7 +556,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let (ast, mir) = if impl_item.kind == ty::AssociatedKind::Const {\n             (true, true)\n         } else if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n-            let generics = self.tcx.lookup_generics(def_id);\n+            let generics = self.tcx.item_generics(def_id);\n             let types = generics.parent_types as usize + generics.types.len();\n             let needs_inline = types > 0 || attr::requests_inline(&ast_item.attrs);\n             let is_const_fn = sig.constness == hir::Constness::Const;\n@@ -717,7 +717,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     paren_sugar: trait_def.paren_sugar,\n                     has_default_impl: tcx.trait_has_default_impl(def_id),\n                     trait_ref: self.lazy(&trait_def.trait_ref),\n-                    super_predicates: self.lazy(&tcx.lookup_super_predicates(def_id)),\n+                    super_predicates: self.lazy(&tcx.item_super_predicates(def_id)),\n                 };\n \n                 EntryKind::Trait(self.lazy(&data))"}, {"sha": "f43181d8a610f8c069411a325c8552e47f1e9429", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -155,6 +155,7 @@ macro_rules! unpack {\n pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        fn_id: ast::NodeId,\n                                        arguments: A,\n+                                       abi: Abi,\n                                        return_ty: Ty<'gcx>,\n                                        ast_body: &'gcx hir::Expr)\n                                        -> (Mir<'tcx>, ScopeAuxiliaryVec)\n@@ -191,12 +192,9 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     assert_eq!(block, builder.return_block());\n \n     let mut spread_arg = None;\n-    match tcx.tables().node_id_to_type(fn_id).sty {\n-        ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {\n-            // RustCall pseudo-ABI untuples the last argument.\n-            spread_arg = Some(Local::new(arguments.len()));\n-        }\n-        _ => {}\n+    if abi == Abi::RustCall {\n+        // RustCall pseudo-ABI untuples the last argument.\n+        spread_arg = Some(Local::new(arguments.len()));\n     }\n \n     // Gather the upvars of a closure, if any."}, {"sha": "4af87381c7042bb84ce464a0492cc6fa81f58838", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -806,7 +806,7 @@ fn build_free<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     TerminatorKind::Call {\n         func: Operand::Constant(Constant {\n             span: data.span,\n-            ty: tcx.lookup_item_type(free_func).ty.subst(tcx, substs),\n+            ty: tcx.item_type(free_func).subst(tcx, substs),\n             literal: Literal::Item {\n                 def_id: free_func,\n                 substs: substs"}, {"sha": "038300068fce1c6d402362f0da189d992e2083f1", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -149,8 +149,8 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n         for item in self.tcx.associated_items(trait_def_id) {\n             if item.kind == ty::AssociatedKind::Method && item.name == method_name {\n-                let method_ty = self.tcx.lookup_item_type(item.def_id);\n-                let method_ty = method_ty.ty.subst(self.tcx, substs);\n+                let method_ty = self.tcx.item_type(item.def_id);\n+                let method_ty = method_ty.subst(self.tcx, substs);\n                 return (method_ty, Literal::Item {\n                     def_id: item.def_id,\n                     substs: substs,"}, {"sha": "f22a2a7ac9c77445df5a631248394b5bbc008714", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -31,6 +31,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use rustc::hir;\n use rustc::hir::intravisit::{self, FnKind, Visitor};\n+use syntax::abi::Abi;\n use syntax::ast;\n use syntax_pos::Span;\n \n@@ -221,10 +222,11 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n             }\n         };\n \n-        let implicit_argument = if let FnKind::Closure(..) = fk {\n-            Some((closure_self_ty(self.tcx, id, body.id), None))\n+        let (abi, implicit_argument) = if let FnKind::Closure(..) = fk {\n+            (Abi::Rust, Some((closure_self_ty(self.tcx, id, body.id), None)))\n         } else {\n-            None\n+            let def_id = self.tcx.map.local_def_id(id);\n+            (self.tcx.item_type(def_id).fn_abi(), None)\n         };\n \n         let explicit_arguments =\n@@ -237,7 +239,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n \n         let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n         self.cx(MirSource::Fn(id)).build(|cx| {\n-            build::construct_fn(cx, id, arguments, fn_sig.output, body)\n+            build::construct_fn(cx, id, arguments, abi, fn_sig.output, body)\n         });\n \n         intravisit::walk_fn(self, fk, decl, body, span, id);"}, {"sha": "ad525d210694776f2ed846b46615848dfd34c123", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -127,7 +127,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         match *lvalue {\n             Lvalue::Local(index) => LvalueTy::Ty { ty: self.mir.local_decls[index].ty },\n             Lvalue::Static(def_id) =>\n-                LvalueTy::Ty { ty: self.tcx().lookup_item_type(def_id).ty },\n+                LvalueTy::Ty { ty: self.tcx().item_type(def_id) },\n             Lvalue::Projection(ref proj) => {\n                 let base_ty = self.sanitize_lvalue(&proj.base, location);\n                 if let LvalueTy::Ty { ty } = base_ty {"}, {"sha": "4fb11509a1c137da408d94309459bfb024466a39", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -286,7 +286,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                           scope: NodeId) -> Option<VariableData> {\n         if let Some(ident) = field.ident {\n             let qualname = format!(\"::{}::{}\", self.tcx.node_path_str(scope), ident);\n-            let typ = self.tcx.tables().node_types.get(&field.id).unwrap().to_string();\n+            let def_id = self.tcx.map.local_def_id(field.id);\n+            let typ = self.tcx.item_type(def_id).to_string();\n             let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n             filter!(self.span_utils, sub_span, field.span, None);\n             Some(VariableData {"}, {"sha": "0ad663f05b48b12c577810baff255a011bebeaf0", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -231,7 +231,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n             match key.disambiguated_data.data {\n                 DefPathData::TypeNs(_) |\n                 DefPathData::ValueNs(_) => {\n-                    instance_ty = scx.tcx().lookup_item_type(ty_def_id);\n+                    instance_ty = scx.tcx().item_type(ty_def_id);\n                     break;\n                 }\n                 _ => {\n@@ -248,7 +248,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n \n         // Erase regions because they may not be deterministic when hashed\n         // and should not matter anyhow.\n-        let instance_ty = scx.tcx().erase_regions(&instance_ty.ty);\n+        let instance_ty = scx.tcx().erase_regions(&instance_ty);\n \n         let hash = get_symbol_hash(scx, &def_path, instance_ty, Some(substs));\n "}, {"sha": "a990a7c507fd0ca2baa0bc22b852e349dd0d2afa", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -1045,7 +1045,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     debug!(\"trans_instance(instance={:?})\", instance);\n     let _icx = push_ctxt(\"trans_instance\");\n \n-    let fn_ty = ccx.tcx().lookup_item_type(instance.def).ty;\n+    let fn_ty = ccx.tcx().item_type(instance.def);\n     let fn_ty = ccx.tcx().erase_regions(&fn_ty);\n     let fn_ty = monomorphize::apply_param_substs(ccx.shared(), instance.substs, &fn_ty);\n \n@@ -1068,7 +1068,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     attributes::inline(llfndecl, attributes::InlineAttr::Hint);\n     attributes::set_frame_pointer_elimination(ccx, llfndecl);\n \n-    let ctor_ty = ccx.tcx().lookup_item_type(def_id).ty;\n+    let ctor_ty = ccx.tcx().item_type(def_id);\n     let ctor_ty = monomorphize::apply_param_substs(ccx.shared(), substs, &ctor_ty);\n \n     let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&ctor_ty.fn_sig());\n@@ -1514,7 +1514,7 @@ pub fn filter_reachable_ids(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n             hir_map::NodeImplItem(&hir::ImplItem {\n                 node: hir::ImplItemKind::Method(..), .. }) => {\n                 let def_id = tcx.map.local_def_id(id);\n-                let generics = tcx.lookup_generics(def_id);\n+                let generics = tcx.item_generics(def_id);\n                 let attributes = tcx.get_attrs(def_id);\n                 (generics.parent_types == 0 && generics.types.is_empty()) &&\n                 // Functions marked with #[inline] are only ever translated\n@@ -1719,7 +1719,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let applicable = match sess.cstore.describe_def(def_id) {\n                 Some(Def::Static(..)) => true,\n                 Some(Def::Fn(_)) => {\n-                    shared_ccx.tcx().lookup_generics(def_id).types.is_empty()\n+                    shared_ccx.tcx().item_generics(def_id).types.is_empty()\n                 }\n                 _ => false\n             };"}, {"sha": "f49d63b83764347acd52fc74b1237d33a12d3e0b", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -246,7 +246,7 @@ fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n                     def_id: DefId,\n                     substs: &'tcx Substs<'tcx>)\n                     -> Ty<'tcx> {\n-    let ty = shared.tcx().lookup_item_type(def_id).ty;\n+    let ty = shared.tcx().item_type(def_id);\n     monomorphize::apply_param_substs(shared, substs, &ty)\n }\n \n@@ -400,7 +400,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let substs = tcx.normalize_associated_type(&substs);\n     let instance = Instance::new(def_id, substs);\n-    let item_ty = ccx.tcx().lookup_item_type(def_id).ty;\n+    let item_ty = ccx.tcx().item_type(def_id);\n     let fn_ty = monomorphize::apply_param_substs(ccx.shared(), substs, &item_ty);\n \n     if let Some(&llfn) = ccx.instances().borrow().get(&instance) {"}, {"sha": "41071057274f12fb51f09c3de0dbc26629fa7f36", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -337,7 +337,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n         }\n         TransItem::Static(node_id) => {\n             let def_id = scx.tcx().map.local_def_id(node_id);\n-            let ty = scx.tcx().lookup_item_type(def_id).ty;\n+            let ty = scx.tcx().item_type(def_id);\n             let ty = glue::get_drop_glue_type(scx.tcx(), ty);\n             neighbors.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n \n@@ -618,7 +618,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         fn can_result_in_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                               def_id: DefId)\n                                               -> bool {\n-            match tcx.lookup_item_type(def_id).ty.sty {\n+            match tcx.item_type(def_id).sty {\n                 ty::TyFnDef(def_id, _, f) => {\n                     // Some constructors also have type TyFnDef but they are\n                     // always instantiated inline and don't result in\n@@ -1077,13 +1077,12 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemStruct(_, ref generics) |\n             hir::ItemUnion(_, ref generics) => {\n                 if !generics.is_parameterized() {\n-                    let ty = self.scx.tcx().tables().node_types[&item.id];\n-\n                     if self.mode == TransItemCollectionMode::Eager {\n+                        let def_id = self.scx.tcx().map.local_def_id(item.id);\n                         debug!(\"RootCollector: ADT drop-glue for {}\",\n-                               def_id_to_string(self.scx.tcx(),\n-                                                self.scx.tcx().map.local_def_id(item.id)));\n+                               def_id_to_string(self.scx.tcx(), def_id));\n \n+                        let ty = self.scx.tcx().item_type(def_id);\n                         let ty = glue::get_drop_glue_type(self.scx.tcx(), ty);\n                         self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n                     }\n@@ -1182,7 +1181,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                         continue;\n                     }\n \n-                    if !tcx.lookup_generics(method.def_id).types.is_empty() {\n+                    if !tcx.item_generics(method.def_id).types.is_empty() {\n                         continue;\n                     }\n \n@@ -1201,7 +1200,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                                                                callee_substs,\n                                                                &impl_data);\n \n-                    let predicates = tcx.lookup_predicates(def_id).predicates\n+                    let predicates = tcx.item_predicates(def_id).predicates\n                                         .subst(tcx, substs);\n                     if !traits::normalize_and_test_predicates(tcx, predicates) {\n                         continue;"}, {"sha": "670a84565fafbc31f442a58a28ef17ef5b8c3bcb", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -84,7 +84,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n         return g;\n     }\n \n-    let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+    let ty = ccx.tcx().item_type(def_id);\n     let g = if let Some(id) = ccx.tcx().map.as_local_node_id(def_id) {\n \n         let llty = type_of::type_of(ccx, ty);\n@@ -226,7 +226,7 @@ pub fn trans_static(ccx: &CrateContext,\n             v\n         };\n \n-        let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+        let ty = ccx.tcx().item_type(def_id);\n         let llty = type_of::type_of(ccx, ty);\n         let g = if val_llty == llty {\n             g"}, {"sha": "679e308c34542c151b2bfff741f9b43ba6538684", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -1765,7 +1765,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = tcx.erase_regions(&tcx.tables().node_id_to_type(node_id));\n+    let variable_type = tcx.erase_regions(&tcx.item_type(node_def_id));\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let var_name = tcx.item_name(node_def_id).to_string();\n     let linkage_name = mangled_name_of_item(cx, node_def_id, \"\");"}, {"sha": "45b8ec1dc80bb8cdc2ac30d89b1426573a04d15b", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -259,7 +259,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n-    let generics = cx.tcx().lookup_generics(fn_def_id);\n+    let generics = cx.tcx().item_generics(fn_def_id);\n     let template_parameters = get_template_parameters(cx,\n                                                       &generics,\n                                                       instance.substs,\n@@ -397,7 +397,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                           generics: &ty::Generics<'tcx>)\n                                           -> Vec<ast::Name> {\n         let mut names = generics.parent.map_or(vec![], |def_id| {\n-            get_type_parameter_names(cx, cx.tcx().lookup_generics(def_id))\n+            get_type_parameter_names(cx, cx.tcx().item_generics(def_id))\n         });\n         names.extend(generics.types.iter().map(|param| param.name));\n         names\n@@ -412,7 +412,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let self_type = cx.tcx().impl_of_method(instance.def).and_then(|impl_def_id| {\n             // If the method does *not* belong to a trait, proceed\n             if cx.tcx().trait_id_of_impl(impl_def_id).is_none() {\n-                let impl_self_ty = cx.tcx().lookup_item_type(impl_def_id).ty;\n+                let impl_self_ty = cx.tcx().item_type(impl_def_id);\n                 let impl_self_ty = cx.tcx().erase_regions(&impl_self_ty);\n                 let impl_self_ty = monomorphize::apply_param_substs(cx.shared(),\n                                                                     instance.substs,"}, {"sha": "09a1cbd319ac454455f037f6d99c95ecac6b31ed", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -495,7 +495,7 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n             if let Some(impl_def_id) = tcx.impl_of_method(instance.def) {\n                 // This is a method within an inherent impl, find out what the\n                 // self-type is:\n-                let impl_self_ty = tcx.lookup_item_type(impl_def_id).ty;\n+                let impl_self_ty = tcx.item_type(impl_def_id);\n                 let impl_self_ty = tcx.erase_regions(&impl_self_ty);\n                 let impl_self_ty = monomorphize::apply_param_substs(scx,\n                                                                     instance.substs,"}, {"sha": "93790cc27bcafad14d8d0b36191fc222aac9a235", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                         linkage: llvm::Linkage,\n                         symbol_name: &str) {\n         let def_id = ccx.tcx().map.local_def_id(node_id);\n-        let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+        let ty = ccx.tcx().item_type(def_id);\n         let llty = type_of::type_of(ccx, ty);\n \n         let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n@@ -153,7 +153,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         assert!(!instance.substs.needs_infer() &&\n                 !instance.substs.has_param_types());\n \n-        let item_ty = ccx.tcx().lookup_item_type(instance.def).ty;\n+        let item_ty = ccx.tcx().item_type(instance.def);\n         let item_ty = ccx.tcx().erase_regions(&item_ty);\n         let mono_ty = monomorphize::apply_param_substs(ccx.shared(), instance.substs, &item_ty);\n "}, {"sha": "9bde6b0c4d9953b85263998507ca9e3709217266", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -16,12 +16,12 @@\n //! somewhat differently during the collect and check phases,\n //! particularly with respect to looking up the types of top-level\n //! items.  In the collect phase, the crate context is used as the\n-//! `AstConv` instance; in this phase, the `get_item_type_scheme()`\n-//! function triggers a recursive call to `type_scheme_of_item()`\n+//! `AstConv` instance; in this phase, the `get_item_type()`\n+//! function triggers a recursive call to `type_of_item()`\n //! (note that `ast_ty_to_ty()` will detect recursive types and report\n //! an error).  In the check phase, when the FnCtxt is used as the\n-//! `AstConv`, `get_item_type_scheme()` just looks up the item type in\n-//! `tcx.tcache` (using `ty::lookup_item_type`).\n+//! `AstConv`, `get_item_type()` just looks up the item type in\n+//! `tcx.types` (using `TyCtxt::item_type`).\n //!\n //! The `RegionScope` trait controls what happens when the user does\n //! not specify a region in some location where a region is required\n@@ -85,11 +85,8 @@ pub trait AstConv<'gcx, 'tcx> {\n     fn get_generics(&self, span: Span, id: DefId)\n                     -> Result<&'tcx ty::Generics<'tcx>, ErrorReported>;\n \n-    /// Identify the type scheme for an item with a type, like a type\n-    /// alias, fn, or struct. This allows you to figure out the set of\n-    /// type parameters defined on the item.\n-    fn get_item_type_scheme(&self, span: Span, id: DefId)\n-                            -> Result<ty::TypeScheme<'tcx>, ErrorReported>;\n+    /// Identify the type for an item, like a type alias, fn, or struct.\n+    fn get_item_type(&self, span: Span, id: DefId) -> Result<Ty<'tcx>, ErrorReported>;\n \n     /// Returns the `TraitDef` for a given trait. This allows you to\n     /// figure out the set of type parameters defined on the trait.\n@@ -938,8 +935,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         -> Ty<'tcx>\n     {\n         let tcx = self.tcx();\n-        let decl_ty = match self.get_item_type_scheme(span, did) {\n-            Ok(type_scheme) => type_scheme.ty,\n+        let decl_ty = match self.get_item_type(span, did) {\n+            Ok(ty) => ty,\n             Err(ErrorReported) => {\n                 return tcx.types.err;\n             }\n@@ -1521,8 +1518,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // Self in impl (we know the concrete type).\n \n                 tcx.prohibit_type_params(base_segments);\n-                let impl_id = tcx.map.as_local_node_id(def_id).unwrap();\n-                let ty = tcx.tables().node_id_to_type(impl_id);\n+                let ty = tcx.item_type(def_id);\n                 if let Some(free_substs) = self.get_free_substs() {\n                     ty.subst(tcx, free_substs)\n                 } else {"}, {"sha": "54a0ef071ce4b778323f2c7c949139771308eac1", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -174,10 +174,10 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     debug!(\"compare_impl_method: trait_to_skol_substs={:?}\",\n            trait_to_skol_substs);\n \n-    let impl_m_generics = tcx.lookup_generics(impl_m.def_id);\n-    let trait_m_generics = tcx.lookup_generics(trait_m.def_id);\n-    let impl_m_predicates = tcx.lookup_predicates(impl_m.def_id);\n-    let trait_m_predicates = tcx.lookup_predicates(trait_m.def_id);\n+    let impl_m_generics = tcx.item_generics(impl_m.def_id);\n+    let trait_m_generics = tcx.item_generics(trait_m.def_id);\n+    let impl_m_predicates = tcx.item_predicates(impl_m.def_id);\n+    let trait_m_predicates = tcx.item_predicates(trait_m.def_id);\n \n     // Check region bounds.\n     check_region_bounds_on_impl_method(ccx,\n@@ -193,7 +193,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // environment. We can't just use `impl_env.caller_bounds`,\n     // however, because we want to replace all late-bound regions with\n     // region variables.\n-    let impl_predicates = tcx.lookup_predicates(impl_m_predicates.parent.unwrap());\n+    let impl_predicates = tcx.item_predicates(impl_m_predicates.parent.unwrap());\n     let mut hybrid_preds = impl_predicates.instantiate(tcx, impl_to_skol_substs);\n \n     debug!(\"compare_impl_method: impl_bounds={:?}\", hybrid_preds);\n@@ -269,7 +269,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let origin = TypeOrigin::MethodCompatCheck(impl_m_span);\n \n         let m_fty = |method: &ty::AssociatedItem| {\n-            match tcx.lookup_item_type(method.def_id).ty.sty {\n+            match tcx.item_type(method.def_id).sty {\n                 ty::TyFnDef(_, _, f) => f,\n                 _ => bug!()\n             }\n@@ -542,7 +542,7 @@ fn compare_self_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             ty::ImplContainer(_) => impl_trait_ref.self_ty(),\n             ty::TraitContainer(_) => tcx.mk_self_type()\n         };\n-        let method_ty = tcx.lookup_item_type(method.def_id).ty;\n+        let method_ty = tcx.item_type(method.def_id);\n         let self_arg_ty = *method_ty.fn_sig().input(0).skip_binder();\n         match ExplicitSelf::determine(untransformed_self_ty, self_arg_ty) {\n             ExplicitSelf::ByValue => \"self\".to_string(),\n@@ -601,8 +601,8 @@ fn compare_number_of_generics<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                         trait_item_span: Option<Span>)\n                                         -> Result<(), ErrorReported> {\n     let tcx = ccx.tcx;\n-    let impl_m_generics = tcx.lookup_generics(impl_m.def_id);\n-    let trait_m_generics = tcx.lookup_generics(trait_m.def_id);\n+    let impl_m_generics = tcx.item_generics(impl_m.def_id);\n+    let trait_m_generics = tcx.item_generics(trait_m.def_id);\n     let num_impl_m_type_params = impl_m_generics.types.len();\n     let num_trait_m_type_params = trait_m_generics.types.len();\n     if num_impl_m_type_params != num_trait_m_type_params {\n@@ -672,7 +672,7 @@ fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                 -> Result<(), ErrorReported> {\n     let tcx = ccx.tcx;\n     let m_fty = |method: &ty::AssociatedItem| {\n-        match tcx.lookup_item_type(method.def_id).ty.sty {\n+        match tcx.item_type(method.def_id).sty {\n             ty::TyFnDef(_, _, f) => f,\n             _ => bug!()\n         }\n@@ -785,8 +785,8 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                trait_to_skol_substs);\n \n         // Compute skolemized form of impl and trait const tys.\n-        let impl_ty = tcx.lookup_item_type(impl_c.def_id).ty.subst(tcx, impl_to_skol_substs);\n-        let trait_ty = tcx.lookup_item_type(trait_c.def_id).ty.subst(tcx, trait_to_skol_substs);\n+        let impl_ty = tcx.item_type(impl_c.def_id).subst(tcx, impl_to_skol_substs);\n+        let trait_ty = tcx.item_type(trait_c.def_id).subst(tcx, trait_to_skol_substs);\n         let mut origin = TypeOrigin::Misc(impl_c_span);\n \n         let err = infcx.commit_if_ok(|_| {"}, {"sha": "8657b30bf8ee1eceedfee8b50ce4bd2872ca5f05", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -41,8 +41,8 @@ use syntax_pos::{self, Span};\n ///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n ///\n pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()> {\n-    let dtor_self_type = ccx.tcx.lookup_item_type(drop_impl_did).ty;\n-    let dtor_predicates = ccx.tcx.lookup_predicates(drop_impl_did);\n+    let dtor_self_type = ccx.tcx.item_type(drop_impl_did);\n+    let dtor_predicates = ccx.tcx.item_predicates(drop_impl_did);\n     match dtor_self_type.sty {\n         ty::TyAdt(adt_def, self_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(ccx,\n@@ -85,7 +85,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         let tcx = infcx.tcx;\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n-        let named_type = tcx.lookup_item_type(self_type_did).ty;\n+        let named_type = tcx.item_type(self_type_did);\n         let named_type = named_type.subst(tcx, &infcx.parameter_environment.free_substs);\n \n         let drop_impl_span = tcx.map.def_id_span(drop_impl_did, syntax_pos::DUMMY_SP);\n@@ -177,7 +177,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n \n     // We can assume the predicates attached to struct/enum definition\n     // hold.\n-    let generic_assumptions = tcx.lookup_predicates(self_type_did);\n+    let generic_assumptions = tcx.item_predicates(self_type_did);\n \n     let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n     let assumptions_in_impl_context = assumptions_in_impl_context.predicates;\n@@ -570,30 +570,30 @@ fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n // Constructs new Ty just like the type defined by `adt_def` coupled\n // with `substs`, except each type and lifetime parameter marked as\n-// `#[may_dangle]` in the Drop impl (identified by `impl_id`) is\n+// `#[may_dangle]` in the Drop impl (identified by `impl_def_id`) is\n // respectively mapped to `()` or `'static`.\n //\n // For example: If the `adt_def` maps to:\n //\n //   enum Foo<'a, X, Y> { ... }\n //\n-// and the `impl_id` maps to:\n+// and the `impl_def_id` maps to:\n //\n //   impl<#[may_dangle] 'a, X, #[may_dangle] Y> Drop for Foo<'a, X, Y> { ... }\n //\n // then revises input: `Foo<'r,i64,&'r i64>` to: `Foo<'static,i64,()>`\n fn revise_self_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                   adt_def: ty::AdtDef<'tcx>,\n-                                  impl_id: DefId,\n+                                  impl_def_id: DefId,\n                                   substs: &Substs<'tcx>)\n                                   -> Ty<'tcx> {\n     // Get generics for `impl Drop` to query for `#[may_dangle]` attr.\n-    let impl_bindings = tcx.lookup_generics(impl_id);\n+    let impl_bindings = tcx.item_generics(impl_def_id);\n \n     // Get Substs attached to Self on `impl Drop`; process in parallel\n     // with `substs`, replacing dangling entries as appropriate.\n     let self_substs = {\n-        let impl_self_ty: Ty<'tcx> = tcx.lookup_item_type(impl_id).ty;\n+        let impl_self_ty: Ty<'tcx> = tcx.item_type(impl_def_id);\n         if let ty::TyAdt(self_adt_def, self_substs) = impl_self_ty.sty {\n             assert_eq!(adt_def, self_adt_def);\n             self_substs\n@@ -648,5 +648,5 @@ fn revise_self_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             t\n         });\n \n-    return tcx.mk_adt(adt_def, &substs);\n+    tcx.mk_adt(adt_def, &substs)\n }"}, {"sha": "ac6343cae1c8ef7d2bc5ddc03a9e87175e172359", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -34,7 +34,6 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    output: Ty<'tcx>) {\n     let tcx = ccx.tcx;\n     let def_id = tcx.map.local_def_id(it.id);\n-    let i_ty = tcx.lookup_item_type(def_id);\n \n     let substs = Substs::for_item(tcx, def_id,\n                                   |_, _| tcx.mk_region(ty::ReErased),\n@@ -49,7 +48,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             variadic: false,\n         }),\n     }));\n-    let i_n_tps = i_ty.generics.types.len();\n+    let i_n_tps = tcx.item_generics(def_id).types.len();\n     if i_n_tps != n_tps {\n         let span = match it.node {\n             hir::ForeignItemFn(_, ref generics) => generics.span,\n@@ -65,7 +64,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     } else {\n         require_same_types(ccx,\n                            TypeOrigin::IntrinsicType(it.span),\n-                           i_ty.ty,\n+                           tcx.item_type(def_id),\n                            fty);\n     }\n }\n@@ -330,8 +329,8 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n     };\n \n     let tcx = ccx.tcx;\n-    let i_ty = tcx.lookup_item_type(tcx.map.local_def_id(it.id));\n-    let i_n_tps = i_ty.generics.types.len();\n+    let def_id = tcx.map.local_def_id(it.id);\n+    let i_n_tps = tcx.item_generics(def_id).types.len();\n     let name = it.name.as_str();\n \n     let (n_tps, inputs, output) = match &*name {\n@@ -374,7 +373,8 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n \n                     let mut structural_to_nomimal = FxHashMap();\n \n-                    let sig = tcx.no_late_bound_regions(i_ty.ty.fn_sig()).unwrap();\n+                    let sig = tcx.item_type(def_id).fn_sig();\n+                    let sig = tcx.no_late_bound_regions(sig).unwrap();\n                     if intr.inputs.len() != sig.inputs.len() {\n                         span_err!(tcx.sess, it.span, E0444,\n                                   \"platform-specific intrinsic has invalid number of \\"}, {"sha": "0b6f7794e9fe14bbc8df949544180e0bdd28537e", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -276,7 +276,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n         let num_supplied_types = supplied_method_types.len();\n-        let method_generics = self.tcx.lookup_generics(pick.item.def_id);\n+        let method_generics = self.tcx.item_generics(pick.item.def_id);\n         let num_method_types = method_generics.types.len();\n \n         if num_supplied_types > 0 && num_supplied_types != num_method_types {\n@@ -359,14 +359,14 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // type/early-bound-regions substitutions performed. There can\n         // be no late-bound regions appearing here.\n         let def_id = pick.item.def_id;\n-        let method_predicates = self.tcx.lookup_predicates(def_id)\n+        let method_predicates = self.tcx.item_predicates(def_id)\n                                     .instantiate(self.tcx, all_substs);\n         let method_predicates = self.normalize_associated_types_in(self.span,\n                                                                    &method_predicates);\n \n         debug!(\"method_predicates after subst = {:?}\", method_predicates);\n \n-        let fty = match self.tcx.lookup_item_type(def_id).ty.sty {\n+        let fty = match self.tcx.item_type(def_id).sty {\n             ty::TyFnDef(_, _, f) => f,\n             _ => bug!()\n         };"}, {"sha": "66a532fd76acff445794decf6c7f29441e58e102", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -230,7 +230,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx;\n         let method_item = self.associated_item(trait_def_id, m_name).unwrap();\n         let def_id = method_item.def_id;\n-        let generics = tcx.lookup_generics(def_id);\n+        let generics = tcx.item_generics(def_id);\n         assert_eq!(generics.types.len(), 0);\n         assert_eq!(generics.regions.len(), 0);\n \n@@ -242,7 +242,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let original_method_ty = tcx.lookup_item_type(def_id).ty;\n+        let original_method_ty = tcx.item_type(def_id);\n         let fty = match original_method_ty.sty {\n             ty::TyFnDef(_, _, f) => f,\n             _ => bug!()"}, {"sha": "481923c25978701900f437ff33338692293679b9", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -672,9 +672,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        let impl_type = self.tcx.lookup_item_type(impl_def_id);\n+        let impl_type = self.tcx.item_type(impl_def_id);\n         let impl_simplified_type =\n-            match ty::fast_reject::simplify_type(self.tcx, impl_type.ty, false) {\n+            match ty::fast_reject::simplify_type(self.tcx, impl_type, false) {\n                 Some(simplified_type) => simplified_type,\n                 None => {\n                     return true;\n@@ -771,7 +771,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                    def_id,\n                    substs);\n \n-            let trait_predicates = self.tcx.lookup_predicates(def_id);\n+            let trait_predicates = self.tcx.item_predicates(def_id);\n             let bounds = trait_predicates.instantiate(self.tcx, substs);\n             let predicates = bounds.predicates;\n             debug!(\"assemble_projection_candidates: predicates={:?}\",\n@@ -1070,7 +1070,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n \n             // Check whether the impl imposes obligations we have to worry about.\n-            let impl_bounds = self.tcx.lookup_predicates(impl_def_id);\n+            let impl_bounds = self.tcx.item_predicates(impl_def_id);\n             let impl_bounds = impl_bounds.instantiate(self.tcx, substs);\n             let traits::Normalized { value: impl_bounds, obligations: norm_obligations } =\n                 traits::normalize(selcx, cause.clone(), &impl_bounds);\n@@ -1171,7 +1171,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                             impl_ty: Ty<'tcx>,\n                             substs: &Substs<'tcx>)\n                             -> Ty<'tcx> {\n-        let self_ty = self.tcx.lookup_item_type(method).ty.fn_sig().input(0);\n+        let self_ty = self.tcx.item_type(method).fn_sig().input(0);\n         debug!(\"xform_self_ty(impl_ty={:?}, self_ty={:?}, substs={:?})\",\n                impl_ty,\n                self_ty,\n@@ -1184,7 +1184,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // are given do not include type/lifetime parameters for the\n         // method yet. So create fresh variables here for those too,\n         // if there are any.\n-        let generics = self.tcx.lookup_generics(method);\n+        let generics = self.tcx.item_generics(method);\n         assert_eq!(substs.types().count(), generics.parent_types as usize);\n         assert_eq!(substs.regions().count(), generics.parent_regions as usize);\n \n@@ -1218,7 +1218,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     /// Get the type of an impl and generate substitutions with placeholders.\n     fn impl_ty_and_substs(&self, impl_def_id: DefId) -> (Ty<'tcx>, &'tcx Substs<'tcx>) {\n-        let impl_ty = self.tcx.lookup_item_type(impl_def_id).ty;\n+        let impl_ty = self.tcx.item_type(impl_def_id);\n \n         let substs = Substs::for_item(self.tcx,\n                                       impl_def_id,"}, {"sha": "a95b3f4a973bb316d59e6a5b13a58a080634a92c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -86,7 +86,8 @@ use fmt_macros::{Parser, Piece, Position};\n use hir::def::{Def, CtorKind, PathResolution};\n use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::pat_util;\n-use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n+use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin,\n+                   TypeOrigin, TypeTrace, type_variable};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, Reveal};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n@@ -597,7 +598,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            body: &'tcx hir::Expr,\n                            fn_id: ast::NodeId,\n                            span: Span) {\n-    let raw_fty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(fn_id)).ty;\n+    let raw_fty = ccx.tcx.item_type(ccx.tcx.map.local_def_id(fn_id));\n     let fn_ty = match raw_fty.sty {\n         ty::TyFnDef(.., f) => f,\n         _ => span_bug!(body.span, \"check_bare_fn: function type expected\")\n@@ -780,15 +781,16 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n }\n \n fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n-    check_representable(ccx.tcx, span, id);\n+    let def_id = ccx.tcx.map.local_def_id(id);\n+    check_representable(ccx.tcx, span, def_id);\n \n-    if ccx.tcx.lookup_simd(ccx.tcx.map.local_def_id(id)) {\n-        check_simd(ccx.tcx, span, id);\n+    if ccx.tcx.lookup_simd(def_id) {\n+        check_simd(ccx.tcx, span, def_id);\n     }\n }\n \n fn check_union(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n-    check_representable(ccx.tcx, span, id);\n+    check_representable(ccx.tcx, span, ccx.tcx.map.local_def_id(id));\n }\n \n pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n@@ -831,7 +833,8 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         check_union(ccx, it.id, it.span);\n       }\n       hir::ItemTy(_, ref generics) => {\n-        let pty_ty = ccx.tcx.tables().node_id_to_type(it.id);\n+        let def_id = ccx.tcx.map.local_def_id(it.id);\n+        let pty_ty = ccx.tcx.item_type(def_id);\n         check_bounds_are_used(ccx, generics, pty_ty);\n       }\n       hir::ItemForeignMod(ref m) => {\n@@ -847,8 +850,8 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n             }\n         } else {\n             for item in &m.items {\n-                let pty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(item.id));\n-                if !pty.generics.types.is_empty() {\n+                let generics = ccx.tcx.item_generics(ccx.tcx.map.local_def_id(item.id));\n+                if !generics.types.is_empty() {\n                     let mut err = struct_span_err!(ccx.tcx.sess, item.span, E0044,\n                         \"foreign items may not have type parameters\");\n                     span_help!(&mut err, item.span,\n@@ -917,7 +920,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     def_id: DefId,\n                                     item: &hir::Item) {\n-    let generics = ccx.tcx.lookup_generics(def_id);\n+    let generics = ccx.tcx.item_generics(def_id);\n     if let Some(ref attr) = item.attrs.iter().find(|a| {\n         a.check_name(\"rustc_on_unimplemented\")\n     }) {\n@@ -1143,12 +1146,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let signature = |item: &ty::AssociatedItem| {\n         match item.kind {\n             ty::AssociatedKind::Method => {\n-                format!(\"{}\", tcx.lookup_item_type(item.def_id).ty.fn_sig().0)\n+                format!(\"{}\", tcx.item_type(item.def_id).fn_sig().0)\n             }\n             ty::AssociatedKind::Type => format!(\"type {};\", item.name.to_string()),\n             ty::AssociatedKind::Const => {\n-                format!(\"const {}: {:?};\", item.name.to_string(),\n-                        tcx.lookup_item_type(item.def_id).ty)\n+                format!(\"const {}: {:?};\", item.name.to_string(), tcx.item_type(item.def_id))\n             }\n         }\n     };\n@@ -1218,7 +1220,7 @@ fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n fn check_const<'a, 'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                          expr: &'tcx hir::Expr,\n                          id: ast::NodeId) {\n-    let decl_ty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(id)).ty;\n+    let decl_ty = ccx.tcx.item_type(ccx.tcx.map.local_def_id(id));\n     check_const_with_type(ccx, expr, decl_ty, id);\n }\n \n@@ -1227,9 +1229,9 @@ fn check_const<'a, 'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n /// pointer, which would mean their size is unbounded.\n fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  sp: Span,\n-                                 item_id: ast::NodeId)\n+                                 item_def_id: DefId)\n                                  -> bool {\n-    let rty = tcx.tables().node_id_to_type(item_id);\n+    let rty = tcx.item_type(item_def_id);\n \n     // Check that it is possible to represent this type. This call identifies\n     // (1) types that contain themselves and (2) types that contain a different\n@@ -1238,7 +1240,6 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // caught by case 1.\n     match rty.is_representable(tcx, sp) {\n         Representability::SelfRecursive => {\n-            let item_def_id = tcx.map.local_def_id(item_id);\n             tcx.recursive_type_with_infinite_size_error(item_def_id).emit();\n             return false\n         }\n@@ -1247,8 +1248,8 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     return true\n }\n \n-pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, id: ast::NodeId) {\n-    let t = tcx.tables().node_id_to_type(id);\n+pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n+    let t = tcx.item_type(def_id);\n     match t.sty {\n         ty::TyAdt(def, substs) if def.is_struct() => {\n             let fields = &def.struct_variant().fields;\n@@ -1328,7 +1329,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         disr_vals.push(current_disr_val);\n     }\n \n-    check_representable(ccx.tcx, sp, id);\n+    check_representable(ccx.tcx, sp, def_id);\n }\n \n impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n@@ -1341,13 +1342,12 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     fn get_generics(&self, _: Span, id: DefId)\n                     -> Result<&'tcx ty::Generics<'tcx>, ErrorReported>\n     {\n-        Ok(self.tcx().lookup_generics(id))\n+        Ok(self.tcx().item_generics(id))\n     }\n \n-    fn get_item_type_scheme(&self, _: Span, id: DefId)\n-                            -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n+    fn get_item_type(&self, _: Span, id: DefId) -> Result<Ty<'tcx>, ErrorReported>\n     {\n-        Ok(self.tcx().lookup_item_type(id))\n+        Ok(self.tcx().item_type(id))\n     }\n \n     fn get_trait_def(&self, _: Span, id: DefId)\n@@ -1662,7 +1662,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// generic type scheme.\n     fn instantiate_bounds(&self, span: Span, def_id: DefId, substs: &Substs<'tcx>)\n                           -> ty::InstantiatedPredicates<'tcx> {\n-        let bounds = self.tcx.lookup_predicates(def_id);\n+        let bounds = self.tcx.item_predicates(def_id);\n         let result = bounds.instantiate(self.tcx, substs);\n         let result = self.normalize_associated_types_in(span, &result.predicates);\n         debug!(\"instantiate_bounds(bounds={:?}, substs={:?}) = {:?}\",\n@@ -1687,7 +1687,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let ty_var = self.next_ty_var();\n                 self.anon_types.borrow_mut().insert(def_id, ty_var);\n \n-                let item_predicates = self.tcx.lookup_predicates(def_id);\n+                let item_predicates = self.tcx.item_predicates(def_id);\n                 let bounds = item_predicates.instantiate(self.tcx, substs);\n \n                 let span = self.tcx.map.def_id_span(def_id, codemap::DUMMY_SP);\n@@ -2742,11 +2742,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         span: Span, // (potential) receiver for this impl\n                         did: DefId)\n                         -> TypeAndSubsts<'tcx> {\n-        let ity = self.tcx.lookup_item_type(did);\n+        let ity = self.tcx.item_type(did);\n         debug!(\"impl_self_ty: ity={:?}\", ity);\n \n         let substs = self.fresh_substs_for_item(span, did);\n-        let substd_ty = self.instantiate_type_scheme(span, &substs, &ity.ty);\n+        let substd_ty = self.instantiate_type_scheme(span, &substs, &ity);\n \n         TypeAndSubsts { substs: substs, ty: substd_ty }\n     }\n@@ -2760,7 +2760,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   formal_args: &[Ty<'tcx>])\n                                   -> Vec<Ty<'tcx>> {\n         let expected_args = expected_ret.only_has_type(self).and_then(|ret_ty| {\n-            self.commit_regions_if_ok(|| {\n+            self.fudge_regions_if_ok(&RegionVariableOrigin::Coercion(call_span), || {\n                 // Attempt to apply a subtyping relationship between the formal\n                 // return type (likely containing type variables if the function\n                 // is polymorphic) and the expected return type.\n@@ -4184,11 +4184,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::VariantCtor(def_id, ..) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n-                let mut generics = self.tcx.lookup_generics(def_id);\n+                let mut generics = self.tcx.item_generics(def_id);\n                 if let Some(def_id) = generics.parent {\n                     // Variant and struct constructors use the\n                     // generics of their parent type definition.\n-                    generics = self.tcx.lookup_generics(def_id);\n+                    generics = self.tcx.item_generics(def_id);\n                 }\n                 type_segment = Some((segments.last().unwrap(), generics));\n             }\n@@ -4198,7 +4198,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::Const(def_id) |\n             Def::Static(def_id, _) => {\n                 fn_segment = Some((segments.last().unwrap(),\n-                                   self.tcx.lookup_generics(def_id)));\n+                                   self.tcx.item_generics(def_id)));\n             }\n \n             // Case 3. Reference to a method or associated const.\n@@ -4212,9 +4212,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::ImplContainer(_) => {}\n                 }\n \n-                let generics = self.tcx.lookup_generics(def_id);\n+                let generics = self.tcx.item_generics(def_id);\n                 if segments.len() >= 2 {\n-                    let parent_generics = self.tcx.lookup_generics(generics.parent.unwrap());\n+                    let parent_generics = self.tcx.item_generics(generics.parent.unwrap());\n                     type_segment = Some((&segments[segments.len() - 2], parent_generics));\n                 } else {\n                     // `<T>::assoc` will end up here, and so can `T::assoc`.\n@@ -4344,9 +4344,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // The things we are substituting into the type should not contain\n         // escaping late-bound regions, and nor should the base type scheme.\n-        let scheme = self.tcx.lookup_item_type(def.def_id());\n+        let ty = self.tcx.item_type(def.def_id());\n         assert!(!substs.has_escaping_regions());\n-        assert!(!scheme.ty.has_escaping_regions());\n+        assert!(!ty.has_escaping_regions());\n \n         // Add all the obligations that are required, substituting and\n         // normalized appropriately.\n@@ -4357,16 +4357,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Substitute the values for the type parameters into the type of\n         // the referenced item.\n-        let ty_substituted = self.instantiate_type_scheme(span, &substs, &scheme.ty);\n+        let ty_substituted = self.instantiate_type_scheme(span, &substs, &ty);\n \n         if let Some((ty::ImplContainer(impl_def_id), self_ty)) = ufcs_associated {\n             // In the case of `Foo<T>::method` and `<Foo<T>>::method`, if `method`\n             // is inherent, there is no `Self` parameter, instead, the impl needs\n             // type parameters, which we can infer by unifying the provided `Self`\n             // with the substituted impl type.\n-            let impl_scheme = self.tcx.lookup_item_type(impl_def_id);\n+            let ty = self.tcx.item_type(impl_def_id);\n \n-            let impl_ty = self.instantiate_type_scheme(span, &substs, &impl_scheme.ty);\n+            let impl_ty = self.instantiate_type_scheme(span, &substs, &ty);\n             match self.sub_types(false, TypeOrigin::Misc(span), self_ty, impl_ty) {\n                 Ok(InferOk { obligations, .. }) => {\n                     // FIXME(#32730) propagate obligations"}, {"sha": "e019c4c761483d05adeed06f1b5a8d8a405420de", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -1149,7 +1149,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     autoderefs: usize,\n                     autoref: &adjustment::AutoBorrow<'tcx>)\n     {\n-        debug!(\"link_autoref(autoref={:?})\", autoref);\n+        debug!(\"link_autoref(autoderefs={}, autoref={:?})\", autoderefs, autoref);\n         let mc = mc::MemCategorizationContext::new(self);\n         let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n         debug!(\"expr_cmt={:?}\", expr_cmt);\n@@ -1729,7 +1729,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // ```\n         //\n         // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n-        let trait_predicates = self.tcx.lookup_predicates(projection_ty.trait_ref.def_id);\n+        let trait_predicates = self.tcx.item_predicates(projection_ty.trait_ref.def_id);\n         assert_eq!(trait_predicates.parent, None);\n         let predicates = trait_predicates.predicates.as_slice().to_vec();\n         traits::elaborate_predicates(self.tcx, predicates)"}, {"sha": "066b3d4be0881ce58e5f2f8d9ada1542ca8900ba", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -179,18 +179,18 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             let (mut implied_bounds, self_ty) = match item.container {\n                 ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n                 ty::ImplContainer(def_id) => (fcx.impl_implied_bounds(def_id, span),\n-                                              fcx.tcx.lookup_item_type(def_id).ty)\n+                                              fcx.tcx.item_type(def_id))\n             };\n \n             match item.kind {\n                 ty::AssociatedKind::Const => {\n-                    let ty = fcx.tcx.lookup_item_type(item.def_id).ty;\n+                    let ty = fcx.tcx.item_type(item.def_id);\n                     let ty = fcx.instantiate_type_scheme(span, free_substs, &ty);\n                     fcx.register_wf_obligation(ty, span, code.clone());\n                 }\n                 ty::AssociatedKind::Method => {\n                     reject_shadowing_type_parameters(fcx.tcx, span, item.def_id);\n-                    let method_ty = fcx.tcx.lookup_item_type(item.def_id).ty;\n+                    let method_ty = fcx.tcx.item_type(item.def_id);\n                     let method_ty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n                     let predicates = fcx.instantiate_bounds(span, item.def_id, free_substs);\n                     let fty = match method_ty.sty {\n@@ -205,7 +205,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                 }\n                 ty::AssociatedKind::Type => {\n                     if item.has_value {\n-                        let ty = fcx.tcx.lookup_item_type(item.def_id).ty;\n+                        let ty = fcx.tcx.item_type(item.def_id);\n                         let ty = fcx.instantiate_type_scheme(span, free_substs, &ty);\n                         fcx.register_wf_obligation(ty, span, code.clone());\n                     }\n@@ -276,7 +276,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         //\n         // 3) that the trait definition does not have any type parameters\n \n-        let predicates = self.tcx().lookup_predicates(trait_def_id);\n+        let predicates = self.tcx().item_predicates(trait_def_id);\n \n         // We must exclude the Self : Trait predicate contained by all\n         // traits.\n@@ -353,8 +353,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         self.for_item(item).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n             let def_id = fcx.tcx.map.local_def_id(item.id);\n-            let type_scheme = fcx.tcx.lookup_item_type(def_id);\n-            let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &type_scheme.ty);\n+            let ty = fcx.tcx.item_type(def_id);\n+            let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &ty);\n             let bare_fn_ty = match item_ty.sty {\n                 ty::TyFnDef(.., ref bare_fn_ty) => bare_fn_ty,\n                 _ => {\n@@ -378,11 +378,11 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         debug!(\"check_item_type: {:?}\", item);\n \n         self.for_item(item).with_fcx(|fcx, this| {\n-            let type_scheme = fcx.tcx.lookup_item_type(fcx.tcx.map.local_def_id(item.id));\n+            let ty = fcx.tcx.item_type(fcx.tcx.map.local_def_id(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n                                                       &fcx.parameter_environment\n                                                           .free_substs,\n-                                                      &type_scheme.ty);\n+                                                      &ty);\n \n             fcx.register_wf_obligation(item_ty, item.span, this.code.clone());\n \n@@ -417,7 +417,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                     }\n                 }\n                 None => {\n-                    let self_ty = fcx.tcx.tables().node_id_to_type(item.id);\n+                    let self_ty = fcx.tcx.item_type(item_def_id);\n                     let self_ty = fcx.instantiate_type_scheme(item.span, free_substs, &self_ty);\n                     fcx.register_wf_obligation(self_ty, ast_self_ty.span, this.code.clone());\n                 }\n@@ -426,7 +426,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             let predicates = fcx.instantiate_bounds(item.span, item_def_id, free_substs);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n-            fcx.impl_implied_bounds(fcx.tcx.map.local_def_id(item.id), item.span)\n+            fcx.impl_implied_bounds(item_def_id, item.span)\n         });\n     }\n \n@@ -492,7 +492,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         let span = method_sig.decl.inputs[0].pat.span;\n \n         let free_substs = &fcx.parameter_environment.free_substs;\n-        let method_ty = fcx.tcx.lookup_item_type(method.def_id).ty;\n+        let method_ty = fcx.tcx.item_type(method.def_id);\n         let fty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n         let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.fn_sig());\n \n@@ -523,13 +523,13 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                                      item: &hir::Item,\n                                      ast_generics: &hir::Generics)\n     {\n-        let ty = self.tcx().tables().node_id_to_type(item.id);\n+        let item_def_id = self.tcx().map.local_def_id(item.id);\n+        let ty = self.tcx().item_type(item_def_id);\n         if self.tcx().has_error_field(ty) {\n             return;\n         }\n \n-        let item_def_id = self.tcx().map.local_def_id(item.id);\n-        let ty_predicates = self.tcx().lookup_predicates(item_def_id);\n+        let ty_predicates = self.tcx().item_predicates(item_def_id);\n         assert_eq!(ty_predicates.parent, None);\n         let variances = self.tcx().item_variances(item_def_id);\n \n@@ -583,8 +583,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n }\n \n fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, def_id: DefId) {\n-    let generics = tcx.lookup_generics(def_id);\n-    let parent = tcx.lookup_generics(generics.parent.unwrap());\n+    let generics = tcx.item_generics(def_id);\n+    let parent = tcx.item_generics(generics.parent.unwrap());\n     let impl_params: FxHashMap<_, _> = parent.types\n                                        .iter()\n                                        .map(|tp| (tp.name, tp.def_id))\n@@ -654,7 +654,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let fields =\n             struct_def.fields().iter()\n             .map(|field| {\n-                let field_ty = self.tcx.tables().node_id_to_type(field.id);\n+                let field_ty = self.tcx.item_type(self.tcx.map.local_def_id(field.id));\n                 let field_ty = self.instantiate_type_scheme(field.span,\n                                                             &self.parameter_environment\n                                                                  .free_substs,\n@@ -683,7 +683,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             None => {\n                 // Inherent impl: take implied bounds from the self type.\n-                let self_ty = self.tcx.lookup_item_type(impl_def_id).ty;\n+                let self_ty = self.tcx.item_type(impl_def_id);\n                 let self_ty = self.instantiate_type_scheme(span, free_substs, &self_ty);\n                 vec![self_ty]\n             }"}, {"sha": "979ce82ff4ecd27524f9a3ed8a3801aabe994bf7", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -20,8 +20,6 @@ use rustc::ty::adjustment;\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n use rustc::infer::{InferCtxt, FixupError};\n use rustc::util::nodemap::DefIdMap;\n-use write_substs_to_tcx;\n-use write_ty_to_tcx;\n \n use std::cell::Cell;\n \n@@ -67,7 +65,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n-        wbcx.visit_anon_types(item_id);\n+        wbcx.visit_anon_types();\n         wbcx.visit_deferred_obligations(item_id);\n     }\n }\n@@ -133,6 +131,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         self.fcx.tcx\n     }\n \n+    fn write_ty_to_tcx(&self, node_id: ast::NodeId, ty: Ty<'gcx>) {\n+        debug!(\"write_ty_to_tcx({}, {:?})\", node_id,  ty);\n+        assert!(!ty.needs_infer());\n+        self.tcx().tables.borrow_mut().node_types.insert(node_id, ty);\n+    }\n+\n     // Hacky hack: During type-checking, we treat *all* operators\n     // as potentially overloaded. But then, during writeback, if\n     // we observe that something like `a+b` is (known to be)\n@@ -241,15 +245,15 @@ impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n         let var_ty = self.fcx.local_ty(l.span, l.id);\n         let var_ty = self.resolve(&var_ty, ResolvingLocal(l.span));\n-        write_ty_to_tcx(self.fcx.ccx, l.id, var_ty);\n+        self.write_ty_to_tcx(l.id, var_ty);\n         intravisit::walk_local(self, l);\n     }\n \n     fn visit_ty(&mut self, t: &hir::Ty) {\n         match t.node {\n             hir::TyArray(ref ty, ref count_expr) => {\n                 self.visit_ty(&ty);\n-                write_ty_to_tcx(self.fcx.ccx, count_expr.id, self.tcx().types.usize);\n+                self.write_ty_to_tcx(count_expr.id, self.tcx().types.usize);\n             }\n             hir::TyBareFn(ref function_declaration) => {\n                 intravisit::walk_fn_decl_nopat(self, &function_declaration.decl);\n@@ -302,13 +306,11 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_anon_types(&self, item_id: ast::NodeId) {\n+    fn visit_anon_types(&self) {\n         if self.fcx.writeback_errors.get() {\n             return\n         }\n \n-        let item_def_id = self.fcx.tcx.map.local_def_id(item_id);\n-\n         let gcx = self.tcx().global_tcx();\n         for (&def_id, &concrete_ty) in self.fcx.anon_types.borrow().iter() {\n             let reason = ResolvingAnonTy(def_id);\n@@ -349,10 +351,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 }\n             });\n \n-            gcx.register_item_type(def_id, ty::TypeScheme {\n-                ty: outside_ty,\n-                generics: gcx.lookup_generics(item_def_id)\n-            });\n+            gcx.item_types.borrow_mut().insert(def_id, outside_ty);\n         }\n     }\n \n@@ -363,13 +362,17 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         // Resolve the type of the node with id `id`\n         let n_ty = self.fcx.node_ty(id);\n         let n_ty = self.resolve(&n_ty, reason);\n-        write_ty_to_tcx(self.fcx.ccx, id, n_ty);\n+        self.write_ty_to_tcx(id, n_ty);\n         debug!(\"Node {} has type {:?}\", id, n_ty);\n \n         // Resolve any substitutions\n         self.fcx.opt_node_ty_substs(id, |item_substs| {\n-            write_substs_to_tcx(self.fcx.ccx, id,\n-                                self.resolve(item_substs, reason));\n+            let item_substs = self.resolve(item_substs, reason);\n+            if !item_substs.is_noop() {\n+                debug!(\"write_substs_to_tcx({}, {:?})\", id, item_substs);\n+                assert!(!item_substs.substs.needs_infer());\n+                self.tcx().tables.borrow_mut().item_substs.insert(id, item_substs);\n+            }\n         });\n     }\n "}, {"sha": "58633058264621549aa8ef41285b82f23a399184", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n     fn check_implementation(&self, item: &Item) {\n         let tcx = self.crate_context.tcx;\n         let impl_did = tcx.map.local_def_id(item.id);\n-        let self_type = tcx.lookup_item_type(impl_did);\n+        let self_type = tcx.item_type(impl_did);\n \n         // If there are no traits, then this implementation must have a\n         // base type.\n@@ -129,14 +129,14 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         } else {\n             // Skip inherent impls where the self type is an error\n             // type. This occurs with e.g. resolve failures (#30589).\n-            if self_type.ty.references_error() {\n+            if self_type.references_error() {\n                 return;\n             }\n \n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits.\n-            if let Some(base_def_id) = self.get_base_type_def_id(item.span, self_type.ty) {\n+            if let Some(base_def_id) = self.get_base_type_def_id(item.span, self_type) {\n                 self.add_inherent_impl(base_def_id, impl_did);\n             }\n         }\n@@ -175,8 +175,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             }\n             let method_def_id = items[0];\n \n-            let self_type = tcx.lookup_item_type(impl_did);\n-            match self_type.ty.sty {\n+            let self_type = tcx.item_type(impl_did);\n+            match self_type.sty {\n                 ty::TyAdt(type_def, _) => {\n                     type_def.set_destructor(method_def_id);\n                 }\n@@ -232,13 +232,13 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                 return;\n             };\n \n-            let self_type = tcx.lookup_item_type(impl_did);\n+            let self_type = tcx.item_type(impl_did);\n             debug!(\"check_implementations_of_copy: self_type={:?} (bound)\",\n                    self_type);\n \n             let span = tcx.map.span(impl_node_id);\n             let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n-            let self_type = self_type.ty.subst(tcx, &param_env.free_substs);\n+            let self_type = self_type.subst(tcx, &param_env.free_substs);\n             assert!(!self_type.has_escaping_regions());\n \n             debug!(\"check_implementations_of_copy: self_type={:?} (free)\",\n@@ -326,7 +326,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                 return;\n             };\n \n-            let source = tcx.lookup_item_type(impl_did).ty;\n+            let source = tcx.item_type(impl_did);\n             let trait_ref = self.crate_context.tcx.impl_trait_ref(impl_did).unwrap();\n             let target = trait_ref.substs.type_at(1);\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\","}, {"sha": "371c182030e244c684514996d1b0f4207b0b741f", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -81,7 +81,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 // defined in this crate.\n                 debug!(\"coherence2::orphan check: inherent impl {}\",\n                        self.tcx.map.node_to_string(item.id));\n-                let self_ty = self.tcx.lookup_item_type(def_id).ty;\n+                let self_ty = self.tcx.item_type(def_id);\n                 match self_ty.sty {\n                     ty::TyAdt(def, _) => {\n                         self.check_def_id(item, def.did);"}, {"sha": "968d5d73e7a8b892f07b10d93d224f2f3da189d9", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 84, "deletions": 93, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -13,7 +13,7 @@\n # Collect phase\n \n The collect phase of type check has the job of visiting all items,\n-determining their type, and writing that type into the `tcx.tcache`\n+determining their type, and writing that type into the `tcx.types`\n table.  Despite its name, this table does not really operate as a\n *cache*, at least not for the types of items defined within the\n current crate: we assume that after the collect phase, the types of\n@@ -22,8 +22,7 @@ all local items will be present in the table.\n Unlike most of the types that are present in Rust, the types computed\n for each item are in fact type schemes. This means that they are\n generic types that may have type parameters. TypeSchemes are\n-represented by an instance of `ty::TypeScheme`.  This combines the\n-core type along with a list of the bounds for each parameter. Type\n+represented by a pair of `Generics` and `Ty`.  Type\n parameters themselves are represented as `ty_param()` instances.\n \n The phasing of type conversion is somewhat complicated. There is no\n@@ -51,8 +50,8 @@ There are some shortcomings in this design:\n \n - Before walking the set of supertraits for a given trait, you must\n   call `ensure_super_predicates` on that trait def-id. Otherwise,\n-  `lookup_super_predicates` will result in ICEs.\n-- Because the type scheme includes defaults, cycles through type\n+  `item_super_predicates` will result in ICEs.\n+- Because the item generics include defaults, cycles through type\n   parameter defaults are illegal even if those defaults are never\n   employed. This is not necessarily a bug.\n \n@@ -67,13 +66,13 @@ use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::{eval_const_expr_partial, report_const_eval_err};\n use rustc::ty::subst::Substs;\n use rustc::ty::{ToPredicate, ImplContainer, AssociatedItemContainer, TraitContainer};\n-use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt, TypeScheme};\n+use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n use rscope::*;\n use rustc::dep_graph::DepNode;\n use util::common::{ErrorReported, MemoizationMap};\n use util::nodemap::{NodeMap, FxHashMap, FxHashSet};\n-use {CrateCtxt, write_ty_to_tcx};\n+use CrateCtxt;\n \n use rustc_const_math::ConstInt;\n \n@@ -132,6 +131,15 @@ struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         convert_item(self.ccx, item);\n+        intravisit::walk_item(self, item);\n+    }\n+\n+    fn visit_ty(&mut self, ty: &hir::Ty) {\n+        if let hir::TyImplTrait(..) = ty.node {\n+            let def_id = self.ccx.tcx.map.local_def_id(ty.id);\n+            generics_of_def_id(self.ccx, def_id);\n+        }\n+        intravisit::walk_ty(self, ty);\n     }\n }\n \n@@ -308,11 +316,9 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         })\n     }\n \n-    fn get_item_type_scheme(&self, span: Span, id: DefId)\n-                            -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n-    {\n+    fn get_item_type(&self, span: Span, id: DefId) -> Result<Ty<'tcx>, ErrorReported> {\n         self.ccx.cycle_check(span, AstConvRequest::GetItemTypeScheme(id), || {\n-            Ok(type_scheme_of_def_id(self.ccx, id))\n+            Ok(type_of_def_id(self.ccx, id))\n         })\n     }\n \n@@ -447,7 +453,7 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ty::GenericPredicates<'tcx> {\n         let def = astconv.tcx().type_parameter_def(node_id);\n \n         let mut results = self.parent.map_or(vec![], |def_id| {\n-            let parent = astconv.tcx().lookup_predicates(def_id);\n+            let parent = astconv.tcx().item_predicates(def_id);\n             parent.get_type_parameter_bounds(astconv, span, node_id)\n         });\n \n@@ -546,16 +552,11 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n {\n     let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &field.ty);\n     ty_f.fulfill_ty(tt);\n-    write_ty_to_tcx(ccx, field.id, tt);\n-\n-    /* add the field to the tcache */\n-    ccx.tcx.register_item_type(ccx.tcx.map.local_def_id(field.id),\n-                               ty::TypeScheme {\n-                                   generics: struct_generics,\n-                                   ty: tt\n-                               });\n-    ccx.tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(field.id),\n-                                           struct_predicates.clone());\n+\n+    let def_id = ccx.tcx.map.local_def_id(field.id);\n+    ccx.tcx.item_types.borrow_mut().insert(def_id, tt);\n+    ccx.tcx.generics.borrow_mut().insert(def_id, struct_generics);\n+    ccx.tcx.predicates.borrow_mut().insert(def_id, struct_predicates.clone());\n }\n \n fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -580,8 +581,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let substs = mk_item_substs(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n                                 ccx.tcx.map.span(id), def_id);\n     let fty = ccx.tcx.mk_fn_def(def_id, substs, fty);\n-    ccx.tcx.tcache.borrow_mut().insert(def_id, fty);\n-    write_ty_to_tcx(ccx, id, fty);\n+    ccx.tcx.item_types.borrow_mut().insert(def_id, fty);\n     ccx.tcx.predicates.borrow_mut().insert(def_id, ty_generic_predicates);\n }\n \n@@ -596,9 +596,7 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     };\n     let def_id = ccx.tcx.map.local_def_id(id);\n     ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n-    ccx.tcx.tcache.borrow_mut().insert(def_id, ty);\n-\n-    write_ty_to_tcx(ccx, id, ty);\n+    ccx.tcx.item_types.borrow_mut().insert(def_id, ty);\n }\n \n fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -614,8 +612,7 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n \n     if let Some(ty) = ty {\n-        ccx.tcx.tcache.borrow_mut().insert(def_id, ty);\n-        write_ty_to_tcx(ccx, id, ty);\n+        ccx.tcx.item_types.borrow_mut().insert(def_id, ty);\n     }\n }\n \n@@ -662,11 +659,13 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n         }\n         hir::ItemEnum(ref enum_definition, _) => {\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n-            let scheme = type_scheme_of_def_id(ccx, def_id);\n+            let ty = type_of_def_id(ccx, def_id);\n+            let generics = generics_of_def_id(ccx, def_id);\n             let predicates = predicates_of_item(ccx, it);\n             convert_enum_variant_types(ccx,\n                                        tcx.lookup_adt_def_master(ccx.tcx.map.local_def_id(it.id)),\n-                                       scheme,\n+                                       ty,\n+                                       generics,\n                                        predicates,\n                                        &enum_definition.variants);\n         },\n@@ -690,18 +689,15 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             // Create generics from the generics specified in the impl head.\n             debug!(\"convert: ast_generics={:?}\", generics);\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n-            let ty_generics = generics_of_def_id(ccx, def_id);\n+            generics_of_def_id(ccx, def_id);\n             let mut ty_predicates =\n                 ty_generic_predicates(ccx, generics, None, vec![], false);\n \n             debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n \n             let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &selfty);\n-            write_ty_to_tcx(ccx, it.id, selfty);\n+            tcx.item_types.borrow_mut().insert(def_id, selfty);\n \n-            tcx.register_item_type(def_id,\n-                                   TypeScheme { generics: ty_generics,\n-                                                ty: selfty });\n             let trait_ref = opt_trait_ref.as_ref().map(|ast_trait_ref| {\n                 AstConv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n                                                     &ExplicitRscope,\n@@ -742,14 +738,10 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n                 if let hir::ImplItemKind::Const(ref ty, _) = impl_item.node {\n                     let const_def_id = ccx.tcx.map.local_def_id(impl_item.id);\n-                    let ty_generics = generics_of_def_id(ccx, const_def_id);\n+                    generics_of_def_id(ccx, const_def_id);\n                     let ty = ccx.icx(&ty_predicates)\n                                 .to_ty(&ExplicitRscope, &ty);\n-                    tcx.register_item_type(const_def_id,\n-                                           TypeScheme {\n-                                               generics: ty_generics,\n-                                               ty: ty,\n-                                           });\n+                    tcx.item_types.borrow_mut().insert(const_def_id, ty);\n                     convert_associated_const(ccx, ImplContainer(def_id),\n                                              impl_item.id, ty);\n                 }\n@@ -788,7 +780,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             let _: Result<(), ErrorReported> = // any error is already reported, can ignore\n                 ccx.ensure_super_predicates(it.span, def_id);\n             convert_trait_predicates(ccx, it);\n-            let trait_predicates = tcx.lookup_predicates(def_id);\n+            let trait_predicates = tcx.item_predicates(def_id);\n \n             debug!(\"convert: trait_bounds={:?}\", trait_predicates);\n \n@@ -799,14 +791,10 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             for trait_item in trait_items {\n                 if let hir::ConstTraitItem(ref ty, _) = trait_item.node {\n                     let const_def_id = ccx.tcx.map.local_def_id(trait_item.id);\n-                    let ty_generics = generics_of_def_id(ccx, const_def_id);\n+                    generics_of_def_id(ccx, const_def_id);\n                     let ty = ccx.icx(&trait_predicates)\n                         .to_ty(&ExplicitRscope, ty);\n-                    tcx.register_item_type(const_def_id,\n-                                           TypeScheme {\n-                                               generics: ty_generics,\n-                                               ty: ty,\n-                                           });\n+                    tcx.item_types.borrow_mut().insert(const_def_id, ty);\n                     convert_associated_const(ccx, container, trait_item.id, ty)\n                 }\n             }\n@@ -840,28 +828,31 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n         hir::ItemStruct(ref struct_def, _) |\n         hir::ItemUnion(ref struct_def, _) => {\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n-            let scheme = type_scheme_of_def_id(ccx, def_id);\n+            let ty = type_of_def_id(ccx, def_id);\n+            let generics = generics_of_def_id(ccx, def_id);\n             let predicates = predicates_of_item(ccx, it);\n \n             let variant = tcx.lookup_adt_def_master(def_id).struct_variant();\n \n             for (f, ty_f) in struct_def.fields().iter().zip(variant.fields.iter()) {\n-                convert_field(ccx, &scheme.generics, &predicates, f, ty_f)\n+                convert_field(ccx, generics, &predicates, f, ty_f)\n             }\n \n             if !struct_def.is_struct() {\n-                convert_variant_ctor(ccx, struct_def.id(), variant, scheme, predicates);\n+                convert_variant_ctor(ccx, struct_def.id(), variant, ty, predicates);\n             }\n         },\n         hir::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n-            type_scheme_of_def_id(ccx, def_id);\n+            type_of_def_id(ccx, def_id);\n+            generics_of_def_id(ccx, def_id);\n             predicates_of_item(ccx, it);\n         },\n         _ => {\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n-            type_scheme_of_def_id(ccx, def_id);\n+            type_of_def_id(ccx, def_id);\n+            generics_of_def_id(ccx, def_id);\n             predicates_of_item(ccx, it);\n         },\n     }\n@@ -870,13 +861,13 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   ctor_id: ast::NodeId,\n                                   variant: ty::VariantDef<'tcx>,\n-                                  scheme: ty::TypeScheme<'tcx>,\n+                                  ty: Ty<'tcx>,\n                                   predicates: ty::GenericPredicates<'tcx>) {\n     let tcx = ccx.tcx;\n     let def_id = tcx.map.local_def_id(ctor_id);\n     generics_of_def_id(ccx, def_id);\n     let ctor_ty = match variant.ctor_kind {\n-        CtorKind::Fictive | CtorKind::Const => scheme.ty,\n+        CtorKind::Fictive | CtorKind::Const => ty,\n         CtorKind::Fn => {\n             let inputs: Vec<_> =\n                 variant.fields\n@@ -890,26 +881,26 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 abi: abi::Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: inputs,\n-                    output: scheme.ty,\n+                    output: ty,\n                     variadic: false\n                 })\n             }))\n         }\n     };\n-    write_ty_to_tcx(ccx, ctor_id, ctor_ty);\n-    tcx.tcache.borrow_mut().insert(def_id, ctor_ty);\n+    tcx.item_types.borrow_mut().insert(def_id, ctor_ty);\n     tcx.predicates.borrow_mut().insert(tcx.map.local_def_id(ctor_id), predicates);\n }\n \n fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                         def: ty::AdtDefMaster<'tcx>,\n-                                        scheme: ty::TypeScheme<'tcx>,\n+                                        ty: Ty<'tcx>,\n+                                        generics: &'tcx ty::Generics<'tcx>,\n                                         predicates: ty::GenericPredicates<'tcx>,\n                                         variants: &[hir::Variant]) {\n     // fill the field types\n     for (variant, ty_variant) in variants.iter().zip(def.variants.iter()) {\n         for (f, ty_f) in variant.node.data.fields().iter().zip(ty_variant.fields.iter()) {\n-            convert_field(ccx, &scheme.generics, &predicates, f, ty_f)\n+            convert_field(ccx, generics, &predicates, f, ty_f)\n         }\n \n         // Convert the ctor, if any. This also registers the variant as\n@@ -918,7 +909,7 @@ fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             ccx,\n             variant.node.data.id(),\n             ty_variant,\n-            scheme.clone(),\n+            ty,\n             predicates.clone()\n         );\n     }\n@@ -1216,7 +1207,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n         }\n     };\n \n-    let super_predicates = ccx.tcx.lookup_super_predicates(def_id);\n+    let super_predicates = ccx.tcx.item_super_predicates(def_id);\n \n     // `ty_generic_predicates` below will consider the bounds on the type\n     // parameters (including `Self`) and the explicit where-clauses,\n@@ -1283,7 +1274,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let node_id = if let Some(id) = tcx.map.as_local_node_id(def_id) {\n         id\n     } else {\n-        return tcx.lookup_generics(def_id);\n+        return tcx.item_generics(def_id);\n     };\n     tcx.generics.memoize(def_id, || {\n         use rustc::hir::map::*;\n@@ -1298,6 +1289,18 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 let parent_id = tcx.map.get_parent(node_id);\n                 Some(tcx.map.local_def_id(parent_id))\n             }\n+            NodeTy(&hir::Ty { node: hir::TyImplTrait(..), .. }) => {\n+                let mut parent_id = node_id;\n+                loop {\n+                    match tcx.map.get(parent_id) {\n+                        NodeItem(_) | NodeImplItem(_) | NodeTraitItem(_) => break,\n+                        _ => {\n+                            parent_id = tcx.map.get_parent_node(parent_id);\n+                        }\n+                    }\n+                }\n+                Some(tcx.map.local_def_id(parent_id))\n+            }\n             _ => None\n         };\n \n@@ -1377,13 +1380,11 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let mut own_start = has_self as u32;\n         let (parent_regions, parent_types) = parent_def_id.map_or((0, 0), |def_id| {\n             let generics = generics_of_def_id(ccx, def_id);\n-            assert_eq!(generics.parent, None);\n-            assert_eq!(generics.parent_regions, 0);\n-            assert_eq!(generics.parent_types, 0);\n             assert_eq!(has_self, false);\n             parent_has_self = generics.has_self;\n             own_start = generics.count() as u32;\n-            (generics.regions.len() as u32, generics.types.len() as u32)\n+            (generics.parent_regions + generics.regions.len() as u32,\n+             generics.parent_types + generics.types.len() as u32)\n         });\n \n         let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n@@ -1436,12 +1437,15 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let node_id = if let Some(id) = ccx.tcx.map.as_local_node_id(def_id) {\n         id\n     } else {\n-        return ccx.tcx.lookup_item_type(def_id).ty;\n+        return ccx.tcx.item_type(def_id);\n     };\n-    ccx.tcx.tcache.memoize(def_id, || {\n+    ccx.tcx.item_types.memoize(def_id, || {\n         use rustc::hir::map::*;\n         use rustc::hir::*;\n \n+        // Alway bring in generics, as computing the type needs them.\n+        generics_of_def_id(ccx, def_id);\n+\n         let ty = match ccx.tcx.map.get(node_id) {\n             NodeItem(item) => {\n                 match item.node {\n@@ -1505,24 +1509,10 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             }\n         };\n \n-        write_ty_to_tcx(ccx, node_id, ty);\n         ty\n     })\n }\n \n-fn type_scheme_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                   def_id: DefId)\n-                                   -> ty::TypeScheme<'tcx> {\n-    if def_id.is_local() {\n-        ty::TypeScheme {\n-            generics: generics_of_def_id(ccx, def_id),\n-            ty: type_of_def_id(ccx, def_id)\n-        }\n-    } else {\n-        ccx.tcx.lookup_item_type(def_id)\n-    }\n-}\n-\n fn predicates_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 it: &hir::Item)\n                                 -> ty::GenericPredicates<'tcx> {\n@@ -1554,7 +1544,8 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // moral failing, but at the moment it seems like the only\n     // convenient way to extract the ABI. - ndm\n     let def_id = ccx.tcx.map.local_def_id(it.id);\n-    type_scheme_of_def_id(ccx, def_id);\n+    type_of_def_id(ccx, def_id);\n+    generics_of_def_id(ccx, def_id);\n \n     let no_generics = hir::Generics::empty();\n     let generics = match it.node {\n@@ -1648,7 +1639,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let ref base_predicates = match parent {\n         Some(def_id) => {\n             assert_eq!(super_predicates, vec![]);\n-            tcx.lookup_predicates(def_id)\n+            tcx.item_predicates(def_id)\n         }\n         None => {\n             ty::GenericPredicates {\n@@ -2035,14 +2026,14 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                  impl_predicates: &mut ty::GenericPredicates<'tcx>,\n                                                  impl_def_id: DefId)\n {\n-    let impl_scheme = ccx.tcx.lookup_item_type(impl_def_id);\n+    let impl_ty = ccx.tcx.item_type(impl_def_id);\n     let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n \n     // The trait reference is an input, so find all type parameters\n     // reachable from there, to start (if this is an inherent impl,\n     // then just examine the self type).\n     let mut input_parameters: FxHashSet<_> =\n-        ctp::parameters_for(&impl_scheme.ty, false).into_iter().collect();\n+        ctp::parameters_for(&impl_ty, false).into_iter().collect();\n     if let Some(ref trait_ref) = impl_trait_ref {\n         input_parameters.extend(ctp::parameters_for(trait_ref, false));\n     }\n@@ -2066,12 +2057,12 @@ fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                     impl_items: &[hir::ImplItem])\n {\n     // Every lifetime used in an associated type must be constrained.\n-    let impl_scheme = ccx.tcx.lookup_item_type(impl_def_id);\n-    let impl_predicates = ccx.tcx.lookup_predicates(impl_def_id);\n+    let impl_ty = ccx.tcx.item_type(impl_def_id);\n+    let impl_predicates = ccx.tcx.item_predicates(impl_def_id);\n     let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n \n     let mut input_parameters: FxHashSet<_> =\n-        ctp::parameters_for(&impl_scheme.ty, false).into_iter().collect();\n+        ctp::parameters_for(&impl_ty, false).into_iter().collect();\n     if let Some(ref trait_ref) = impl_trait_ref {\n         input_parameters.extend(ctp::parameters_for(trait_ref, false));\n     }\n@@ -2085,10 +2076,10 @@ fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             item.kind == ty::AssociatedKind::Type && item.has_value\n         })\n         .flat_map(|def_id| {\n-            ctp::parameters_for(&ccx.tcx.lookup_item_type(def_id).ty, true)\n+            ctp::parameters_for(&ccx.tcx.item_type(def_id), true)\n         }).collect();\n \n-    for (ty_lifetime, lifetime) in impl_scheme.generics.regions.iter()\n+    for (ty_lifetime, lifetime) in ccx.tcx.item_generics(impl_def_id).regions.iter()\n         .zip(&ast_generics.lifetimes)\n     {\n         let param = ctp::Parameter::from(ty_lifetime.to_early_bound_region_data());"}, {"sha": "2c12959dbdde25b4d34df273e6fbdc31ee66e072", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 27, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -44,7 +44,7 @@ independently:\n   into the `ty` representation\n \n - collect: computes the types of each top-level item and enters them into\n-  the `cx.tcache` table for later use\n+  the `tcx.types` table for later use\n \n - coherence: enforces coherence rules, builds some tables\n \n@@ -108,7 +108,7 @@ use dep_graph::DepNode;\n use hir::map as hir_map;\n use rustc::infer::{InferOk, TypeOrigin};\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::{self, Reveal};\n use session::{config, CompileResult};\n use util::common::time;\n@@ -159,27 +159,6 @@ pub struct CrateCtxt<'a, 'tcx: 'a> {\n     pub deferred_obligations: RefCell<NodeMap<Vec<traits::DeferredObligation<'tcx>>>>,\n }\n \n-// Functions that write types into the node type table\n-fn write_ty_to_tcx<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, node_id: ast::NodeId, ty: Ty<'tcx>) {\n-    debug!(\"write_ty_to_tcx({}, {:?})\", node_id,  ty);\n-    assert!(!ty.needs_infer());\n-    ccx.tcx.node_type_insert(node_id, ty);\n-}\n-\n-fn write_substs_to_tcx<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                 node_id: ast::NodeId,\n-                                 item_substs: ty::ItemSubsts<'tcx>) {\n-    if !item_substs.is_noop() {\n-        debug!(\"write_substs_to_tcx({}, {:?})\",\n-               node_id,\n-               item_substs);\n-\n-        assert!(!item_substs.substs.needs_infer());\n-\n-        ccx.tcx.tables.borrow_mut().item_substs.insert(node_id, item_substs);\n-    }\n-}\n-\n fn require_c_abi_if_variadic(tcx: TyCtxt,\n                              decl: &hir::FnDecl,\n                              abi: Abi,\n@@ -216,7 +195,8 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                     main_id: ast::NodeId,\n                     main_span: Span) {\n     let tcx = ccx.tcx;\n-    let main_t = tcx.tables().node_id_to_type(main_id);\n+    let main_def_id = tcx.map.local_def_id(main_id);\n+    let main_t = tcx.item_type(main_def_id);\n     match main_t.sty {\n         ty::TyFnDef(..) => {\n             match tcx.map.find(main_id) {\n@@ -237,7 +217,6 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 }\n                 _ => ()\n             }\n-            let main_def_id = tcx.map.local_def_id(main_id);\n             let substs = tcx.intern_substs(&[]);\n             let se_ty = tcx.mk_fn_def(main_def_id, substs,\n                                       tcx.mk_bare_fn(ty::BareFnTy {\n@@ -268,7 +247,8 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                      start_id: ast::NodeId,\n                      start_span: Span) {\n     let tcx = ccx.tcx;\n-    let start_t = tcx.tables().node_id_to_type(start_id);\n+    let start_def_id = ccx.tcx.map.local_def_id(start_id);\n+    let start_t = tcx.item_type(start_def_id);\n     match start_t.sty {\n         ty::TyFnDef(..) => {\n             match tcx.map.find(start_id) {\n@@ -289,7 +269,6 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 _ => ()\n             }\n \n-            let start_def_id = ccx.tcx.map.local_def_id(start_id);\n             let substs = tcx.intern_substs(&[]);\n             let se_ty = tcx.mk_fn_def(start_def_id, substs,\n                                       tcx.mk_bare_fn(ty::BareFnTy {"}, {"sha": "10fca644ec16e37b71c5fb43dcbf00b88790f7c3", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -82,16 +82,16 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n             hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n             hir::ItemUnion(..) => {\n-                let scheme = tcx.lookup_item_type(did);\n+                let generics = tcx.item_generics(did);\n \n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n                 // in comment at top of module.\n                 //\n-                // self.add_constraints_from_generics(&scheme.generics);\n+                // self.add_constraints_from_generics(generics);\n \n                 for field in tcx.lookup_adt_def(did).all_fields() {\n-                    self.add_constraints_from_ty(&scheme.generics,\n+                    self.add_constraints_from_ty(generics,\n                                                  field.unsubst_ty(),\n                                                  self.covariant);\n                 }\n@@ -336,7 +336,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyAdt(def, substs) => {\n-                let item_type = self.tcx().lookup_item_type(def.did);\n+                let adt_generics = self.tcx().item_generics(def.did);\n \n                 // This edge is actually implied by the call to\n                 // `lookup_trait_def`, but I'm trying to be future-proof. See\n@@ -345,8 +345,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n                 self.add_constraints_from_substs(generics,\n                                                  def.did,\n-                                                 &item_type.generics.types,\n-                                                 &item_type.generics.regions,\n+                                                 &adt_generics.types,\n+                                                 &adt_generics.regions,\n                                                  substs,\n                                                  variance);\n             }"}, {"sha": "e8367bca2ef211e617d047e9f3a0f0fb7364e935", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -164,7 +164,7 @@ pub fn build_external_trait<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tc\n                                       did: DefId) -> clean::Trait {\n     let def = tcx.lookup_trait_def(did);\n     let trait_items = tcx.associated_items(did).map(|item| item.clean(cx)).collect();\n-    let predicates = tcx.lookup_predicates(did);\n+    let predicates = tcx.item_predicates(did);\n     let generics = (def.generics, &predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n@@ -178,8 +178,8 @@ pub fn build_external_trait<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tc\n \n fn build_external_function<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      did: DefId) -> clean::Function {\n-    let t = tcx.lookup_item_type(did);\n-    let (decl, style, abi) = match t.ty.sty {\n+    let ty = tcx.item_type(did);\n+    let (decl, style, abi) = match ty.sty {\n         ty::TyFnDef(.., ref f) => ((did, &f.sig).clean(cx), f.unsafety, f.abi),\n         _ => panic!(\"bad function\"),\n     };\n@@ -190,10 +190,10 @@ fn build_external_function<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx\n         hir::Constness::NotConst\n     };\n \n-    let predicates = tcx.lookup_predicates(did);\n+    let predicates = tcx.item_predicates(did);\n     clean::Function {\n         decl: decl,\n-        generics: (t.generics, &predicates).clean(cx),\n+        generics: (tcx.item_generics(did), &predicates).clean(cx),\n         unsafety: style,\n         constness: constness,\n         abi: abi,\n@@ -202,20 +202,18 @@ fn build_external_function<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx\n \n fn build_enum<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         did: DefId) -> clean::Enum {\n-    let t = tcx.lookup_item_type(did);\n-    let predicates = tcx.lookup_predicates(did);\n+    let predicates = tcx.item_predicates(did);\n \n     clean::Enum {\n-        generics: (t.generics, &predicates).clean(cx),\n+        generics: (tcx.item_generics(did), &predicates).clean(cx),\n         variants_stripped: false,\n         variants: tcx.lookup_adt_def(did).variants.clean(cx),\n     }\n }\n \n fn build_struct<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           did: DefId) -> clean::Struct {\n-    let t = tcx.lookup_item_type(did);\n-    let predicates = tcx.lookup_predicates(did);\n+    let predicates = tcx.item_predicates(did);\n     let variant = tcx.lookup_adt_def(did).struct_variant();\n \n     clean::Struct {\n@@ -224,34 +222,32 @@ fn build_struct<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             CtorKind::Fn => doctree::Tuple,\n             CtorKind::Const => doctree::Unit,\n         },\n-        generics: (t.generics, &predicates).clean(cx),\n+        generics: (tcx.item_generics(did), &predicates).clean(cx),\n         fields: variant.fields.clean(cx),\n         fields_stripped: false,\n     }\n }\n \n fn build_union<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           did: DefId) -> clean::Union {\n-    let t = tcx.lookup_item_type(did);\n-    let predicates = tcx.lookup_predicates(did);\n+    let predicates = tcx.item_predicates(did);\n     let variant = tcx.lookup_adt_def(did).struct_variant();\n \n     clean::Union {\n         struct_type: doctree::Plain,\n-        generics: (t.generics, &predicates).clean(cx),\n+        generics: (tcx.item_generics(did), &predicates).clean(cx),\n         fields: variant.fields.clean(cx),\n         fields_stripped: false,\n     }\n }\n \n fn build_type_alias<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               did: DefId) -> clean::Typedef {\n-    let t = tcx.lookup_item_type(did);\n-    let predicates = tcx.lookup_predicates(did);\n+    let predicates = tcx.item_predicates(did);\n \n     clean::Typedef {\n-        type_: t.ty.clean(cx),\n-        generics: (t.generics, &predicates).clean(cx),\n+        type_: tcx.item_type(did).clean(cx),\n+        generics: (tcx.item_generics(did), &predicates).clean(cx),\n     }\n }\n \n@@ -354,8 +350,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n         });\n     }\n \n-    let ty = tcx.lookup_item_type(did);\n-    let for_ = ty.ty.clean(cx);\n+    let for_ = tcx.item_type(did).clean(cx);\n \n     // Only inline impl if the implementing type is\n     // reachable in rustdoc generated documentation\n@@ -365,11 +360,10 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n         }\n     }\n \n-    let predicates = tcx.lookup_predicates(did);\n+    let predicates = tcx.item_predicates(did);\n     let trait_items = tcx.associated_items(did).filter_map(|item| {\n         match item.kind {\n             ty::AssociatedKind::Const => {\n-                let type_scheme = tcx.lookup_item_type(item.def_id);\n                 let default = if item.has_value {\n                     Some(pprust::expr_to_string(\n                         lookup_const_by_id(tcx, item.def_id, None).unwrap().0))\n@@ -379,7 +373,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n                 Some(clean::Item {\n                     name: Some(item.name.clean(cx)),\n                     inner: clean::AssociatedConstItem(\n-                        type_scheme.ty.clean(cx),\n+                        tcx.item_type(item.def_id).clean(cx),\n                         default,\n                     ),\n                     source: clean::Span::empty(),\n@@ -419,7 +413,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n             }\n             ty::AssociatedKind::Type => {\n                 let typedef = clean::Typedef {\n-                    type_: tcx.lookup_item_type(item.def_id).ty.clean(cx),\n+                    type_: tcx.item_type(item.def_id).clean(cx),\n                     generics: clean::Generics {\n                         lifetimes: vec![],\n                         type_params: vec![],\n@@ -463,7 +457,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n             provided_trait_methods: provided,\n             trait_: trait_,\n             for_: for_,\n-            generics: (ty.generics, &predicates).clean(cx),\n+            generics: (tcx.item_generics(did), &predicates).clean(cx),\n             items: trait_items,\n             polarity: Some(polarity.clean(cx)),\n         }),\n@@ -514,7 +508,7 @@ fn build_const<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"got snippet {}\", sn);\n \n     clean::Constant {\n-        type_: ty.map(|t| t.clean(cx)).unwrap_or_else(|| tcx.lookup_item_type(did).ty.clean(cx)),\n+        type_: ty.map(|t| t.clean(cx)).unwrap_or_else(|| tcx.item_type(did).clean(cx)),\n         expr: sn\n     }\n }\n@@ -523,7 +517,7 @@ fn build_static<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           did: DefId,\n                           mutable: bool) -> clean::Static {\n     clean::Static {\n-        type_: tcx.lookup_item_type(did).ty.clean(cx),\n+        type_: tcx.item_type(did).clean(cx),\n         mutability: if mutable {clean::Mutable} else {clean::Immutable},\n         expr: \"\\n\\n\\n\".to_string(), // trigger the \"[definition]\" links\n     }"}, {"sha": "f4df28a147630be8a320b31644204266c3732648", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -1342,13 +1342,13 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.kind {\n             ty::AssociatedKind::Const => {\n-                let ty = cx.tcx().lookup_item_type(self.def_id).ty;\n+                let ty = cx.tcx().item_type(self.def_id);\n                 AssociatedConstItem(ty.clean(cx), None)\n             }\n             ty::AssociatedKind::Method => {\n-                let generics = (cx.tcx().lookup_generics(self.def_id),\n-                                &cx.tcx().lookup_predicates(self.def_id)).clean(cx);\n-                let fty = match cx.tcx().lookup_item_type(self.def_id).ty.sty {\n+                let generics = (cx.tcx().item_generics(self.def_id),\n+                                &cx.tcx().item_predicates(self.def_id)).clean(cx);\n+                let fty = match cx.tcx().item_type(self.def_id).sty {\n                     ty::TyFnDef(_, _, f) => f,\n                     _ => unreachable!()\n                 };\n@@ -1357,7 +1357,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                 if self.method_has_self_argument {\n                     let self_ty = match self.container {\n                         ty::ImplContainer(def_id) => {\n-                            cx.tcx().lookup_item_type(def_id).ty\n+                            cx.tcx().item_type(def_id)\n                         }\n                         ty::TraitContainer(_) => cx.tcx().mk_self_type()\n                     };\n@@ -1405,7 +1405,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     // all of the generics from there and then look for bounds that are\n                     // applied to this associated type in question.\n                     let def = cx.tcx().lookup_trait_def(did);\n-                    let predicates = cx.tcx().lookup_predicates(did);\n+                    let predicates = cx.tcx().item_predicates(did);\n                     let generics = (def.generics, &predicates).clean(cx);\n                     generics.where_predicates.iter().filter_map(|pred| {\n                         let (name, self_type, trait_, bounds) = match *pred {\n@@ -1441,7 +1441,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                 }\n \n                 let ty = if self.has_value {\n-                    Some(cx.tcx().lookup_item_type(self.def_id).ty)\n+                    Some(cx.tcx().item_type(self.def_id))\n                 } else {\n                     None\n                 };\n@@ -1901,7 +1901,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             ty::TyAnon(def_id, substs) => {\n                 // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                 // by looking up the projections associated with the def_id.\n-                let item_predicates = cx.tcx().lookup_predicates(def_id);\n+                let item_predicates = cx.tcx().item_predicates(def_id);\n                 let substs = cx.tcx().lift(&substs).unwrap();\n                 let bounds = item_predicates.instantiate(cx.tcx(), substs);\n                 ImplTrait(bounds.predicates.into_iter().filter_map(|predicate| {"}, {"sha": "19e084905aa92a03f0804fc93a6a7b0aac1238e3", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -153,7 +153,7 @@ fn trait_is_same_or_supertrait(cx: &DocContext, child: DefId,\n     if child == trait_ {\n         return true\n     }\n-    let predicates = cx.tcx().lookup_super_predicates(child).predicates;\n+    let predicates = cx.tcx().item_super_predicates(child).predicates;\n     predicates.iter().filter_map(|pred| {\n         if let ty::Predicate::Trait(ref pred) = *pred {\n             if pred.0.trait_ref.self_ty().is_self() {"}, {"sha": "eef530081abe358b00ec2da39f707682f4fc76f1", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 61, "deletions": 23, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -42,15 +42,15 @@ pub struct UnsafetySpace(pub hir::Unsafety);\n #[derive(Copy, Clone)]\n pub struct ConstnessSpace(pub hir::Constness);\n /// Wrapper struct for properly emitting a method declaration.\n-pub struct Method<'a>(pub &'a clean::FnDecl, pub &'a str);\n+pub struct Method<'a>(pub &'a clean::FnDecl, pub usize);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct MutableSpace(pub clean::Mutability);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct RawMutableSpace(pub clean::Mutability);\n /// Wrapper struct for emitting a where clause from Generics.\n-pub struct WhereClause<'a>(pub &'a clean::Generics);\n+pub struct WhereClause<'a>(pub &'a clean::Generics, pub usize);\n /// Wrapper struct for emitting type parameter bounds.\n pub struct TyParamBounds<'a>(pub &'a [clean::TyParamBound]);\n /// Wrapper struct for emitting a comma-separated list of items\n@@ -157,52 +157,71 @@ impl fmt::Display for clean::Generics {\n \n impl<'a> fmt::Display for WhereClause<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let &WhereClause(gens) = self;\n+        let &WhereClause(gens, pad) = self;\n         if gens.where_predicates.is_empty() {\n             return Ok(());\n         }\n+        let mut clause = String::new();\n         if f.alternate() {\n-            f.write_str(\" \")?;\n+            clause.push_str(\" where \");\n         } else {\n-            f.write_str(\" <span class='where'>where \")?;\n+            clause.push_str(\" <span class='where'>where \");\n         }\n         for (i, pred) in gens.where_predicates.iter().enumerate() {\n             if i > 0 {\n-                f.write_str(\", \")?;\n+                if f.alternate() {\n+                    clause.push_str(\", \");\n+                } else {\n+                    clause.push_str(\",<br>\");\n+                }\n             }\n             match pred {\n                 &clean::WherePredicate::BoundPredicate { ref ty, ref bounds } => {\n                     let bounds = bounds;\n                     if f.alternate() {\n-                        write!(f, \"{:#}: {:#}\", ty, TyParamBounds(bounds))?;\n+                        clause.push_str(&format!(\"{:#}: {:#}\", ty, TyParamBounds(bounds)));\n                     } else {\n-                        write!(f, \"{}: {}\", ty, TyParamBounds(bounds))?;\n+                        clause.push_str(&format!(\"{}: {}\", ty, TyParamBounds(bounds)));\n                     }\n                 }\n                 &clean::WherePredicate::RegionPredicate { ref lifetime,\n                                                           ref bounds } => {\n-                    write!(f, \"{}: \", lifetime)?;\n+                    clause.push_str(&format!(\"{}: \", lifetime));\n                     for (i, lifetime) in bounds.iter().enumerate() {\n                         if i > 0 {\n-                            f.write_str(\" + \")?;\n+                            clause.push_str(\" + \");\n                         }\n \n-                        write!(f, \"{}\", lifetime)?;\n+                        clause.push_str(&format!(\"{}\", lifetime));\n                     }\n                 }\n                 &clean::WherePredicate::EqPredicate { ref lhs, ref rhs } => {\n                     if f.alternate() {\n-                        write!(f, \"{:#} == {:#}\", lhs, rhs)?;\n+                        clause.push_str(&format!(\"{:#} == {:#}\", lhs, rhs));\n                     } else {\n-                        write!(f, \"{} == {}\", lhs, rhs)?;\n+                        clause.push_str(&format!(\"{} == {}\", lhs, rhs));\n                     }\n                 }\n             }\n         }\n         if !f.alternate() {\n-            f.write_str(\"</span>\")?;\n+            clause.push_str(\"</span>\");\n+            let plain = format!(\"{:#}\", self);\n+            if plain.len() > 80 {\n+                //break it onto its own line regardless, but make sure method impls and trait\n+                //blocks keep their fixed padding (2 and 9, respectively)\n+                let padding = if pad > 10 {\n+                    clause = clause.replace(\"class='where'\", \"class='where fmt-newline'\");\n+                    repeat(\"&nbsp;\").take(8).collect::<String>()\n+                } else {\n+                    repeat(\"&nbsp;\").take(pad + 6).collect::<String>()\n+                };\n+                clause = clause.replace(\"<br>\", &format!(\"<br>{}\", padding));\n+            } else {\n+                clause = clause.replace(\"<br>\", \" \");\n+            }\n         }\n-        Ok(())\n+        write!(f, \"{}\", clause)\n     }\n }\n \n@@ -718,30 +737,43 @@ impl fmt::Display for clean::Type {\n }\n \n fn fmt_impl(i: &clean::Impl, f: &mut fmt::Formatter, link_trait: bool) -> fmt::Result {\n+    let mut plain = String::new();\n+\n     if f.alternate() {\n         write!(f, \"impl{:#} \", i.generics)?;\n     } else {\n         write!(f, \"impl{} \", i.generics)?;\n     }\n+    plain.push_str(&format!(\"impl{:#} \", i.generics));\n+\n     if let Some(ref ty) = i.trait_ {\n-        write!(f, \"{}\",\n-               if i.polarity == Some(clean::ImplPolarity::Negative) { \"!\" } else { \"\" })?;\n+        if i.polarity == Some(clean::ImplPolarity::Negative) {\n+            write!(f, \"!\")?;\n+            plain.push_str(\"!\");\n+        }\n+\n         if link_trait {\n             fmt::Display::fmt(ty, f)?;\n+            plain.push_str(&format!(\"{:#}\", ty));\n         } else {\n             match *ty {\n                 clean::ResolvedPath{ typarams: None, ref path, is_generic: false, .. } => {\n                     let last = path.segments.last().unwrap();\n                     fmt::Display::fmt(&last.name, f)?;\n                     fmt::Display::fmt(&last.params, f)?;\n+                    plain.push_str(&format!(\"{:#}{:#}\", last.name, last.params));\n                 }\n                 _ => unreachable!(),\n             }\n         }\n         write!(f, \" for \")?;\n+        plain.push_str(\" for \");\n     }\n+\n     fmt::Display::fmt(&i.for_, f)?;\n-    fmt::Display::fmt(&WhereClause(&i.generics), f)?;\n+    plain.push_str(&format!(\"{:#}\", i.for_));\n+\n+    fmt::Display::fmt(&WhereClause(&i.generics, plain.len() + 1), f)?;\n     Ok(())\n }\n \n@@ -870,24 +902,30 @@ impl<'a> fmt::Display for Method<'a> {\n \n         let mut output: String;\n         let plain: String;\n+        let pad = repeat(\" \").take(indent).collect::<String>();\n         if arrow.is_empty() {\n             output = format!(\"({})\", args);\n-            plain = format!(\"{}({})\", indent.replace(\"&nbsp;\", \" \"), args_plain);\n+            plain = format!(\"{}({})\", pad, args_plain);\n         } else {\n             output = format!(\"({args})<br>{arrow}\", args = args, arrow = arrow);\n-            plain = format!(\"{indent}({args}){arrow}\",\n-                            indent = indent.replace(\"&nbsp;\", \" \"),\n+            plain = format!(\"{pad}({args}){arrow}\",\n+                            pad = pad,\n                             args = args_plain,\n                             arrow = arrow_plain);\n         }\n \n         if plain.len() > 80 {\n-            let pad = format!(\"<br>{}\", indent);\n+            let pad = repeat(\"&nbsp;\").take(indent).collect::<String>();\n+            let pad = format!(\"<br>{}\", pad);\n             output = output.replace(\"<br>\", &pad);\n         } else {\n             output = output.replace(\"<br>\", \"\");\n         }\n-        write!(f, \"{}\", output)\n+        if f.alternate() {\n+            write!(f, \"{}\", output.replace(\"<br>\", \"\\n\"))\n+        } else {\n+            write!(f, \"{}\", output)\n+        }\n     }\n }\n "}, {"sha": "93827a01038f95011edac5232954ed6d9618228a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 66, "deletions": 27, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -1972,14 +1972,13 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         UnstableFeatures::Allow => f.constness,\n         _ => hir::Constness::NotConst\n     };\n-    let prefix = format!(\"{}{}{}{:#}fn {}{:#}\",\n+    let indent = format!(\"{}{}{}{:#}fn {}{:#}\",\n                          VisSpace(&it.visibility),\n                          ConstnessSpace(vis_constness),\n                          UnsafetySpace(f.unsafety),\n                          AbiSpace(f.abi),\n                          it.name.as_ref().unwrap(),\n-                         f.generics);\n-    let indent = repeat(\"&nbsp;\").take(prefix.len()).collect::<String>();\n+                         f.generics).len();\n     write!(w, \"<pre class='rust fn'>{vis}{constness}{unsafety}{abi}fn \\\n                {name}{generics}{decl}{where_clause}</pre>\",\n            vis = VisSpace(&it.visibility),\n@@ -1988,22 +1987,29 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n            abi = AbiSpace(f.abi),\n            name = it.name.as_ref().unwrap(),\n            generics = f.generics,\n-           where_clause = WhereClause(&f.generics),\n-           decl = Method(&f.decl, &indent))?;\n+           where_clause = WhereClause(&f.generics, 2),\n+           decl = Method(&f.decl, indent))?;\n     document(w, cx, it)\n }\n \n fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n               t: &clean::Trait) -> fmt::Result {\n     let mut bounds = String::new();\n+    let mut bounds_plain = String::new();\n     if !t.bounds.is_empty() {\n         if !bounds.is_empty() {\n             bounds.push(' ');\n+            bounds_plain.push(' ');\n         }\n         bounds.push_str(\": \");\n+        bounds_plain.push_str(\": \");\n         for (i, p) in t.bounds.iter().enumerate() {\n-            if i > 0 { bounds.push_str(\" + \"); }\n+            if i > 0 {\n+                bounds.push_str(\" + \");\n+                bounds_plain.push_str(\" + \");\n+            }\n             bounds.push_str(&format!(\"{}\", *p));\n+            bounds_plain.push_str(&format!(\"{:#}\", *p));\n         }\n     }\n \n@@ -2014,7 +2020,8 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n            it.name.as_ref().unwrap(),\n            t.generics,\n            bounds,\n-           WhereClause(&t.generics))?;\n+           // Where clauses in traits are indented nine spaces, per rustdoc.css\n+           WhereClause(&t.generics, 9))?;\n \n     let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n     let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n@@ -2028,31 +2035,31 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         write!(w, \"{{\\n\")?;\n         for t in &types {\n             write!(w, \"    \")?;\n-            render_assoc_item(w, t, AssocItemLink::Anchor(None))?;\n+            render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait)?;\n             write!(w, \";\\n\")?;\n         }\n         if !types.is_empty() && !consts.is_empty() {\n             w.write_str(\"\\n\")?;\n         }\n         for t in &consts {\n             write!(w, \"    \")?;\n-            render_assoc_item(w, t, AssocItemLink::Anchor(None))?;\n+            render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait)?;\n             write!(w, \";\\n\")?;\n         }\n         if !consts.is_empty() && !required.is_empty() {\n             w.write_str(\"\\n\")?;\n         }\n         for m in &required {\n             write!(w, \"    \")?;\n-            render_assoc_item(w, m, AssocItemLink::Anchor(None))?;\n+            render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait)?;\n             write!(w, \";\\n\")?;\n         }\n         if !required.is_empty() && !provided.is_empty() {\n             w.write_str(\"\\n\")?;\n         }\n         for m in &provided {\n             write!(w, \"    \")?;\n-            render_assoc_item(w, m, AssocItemLink::Anchor(None))?;\n+            render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait)?;\n             write!(w, \" {{ ... }}\\n\")?;\n         }\n         write!(w, \"}}\")?;\n@@ -2073,7 +2080,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                id = id,\n                stab = m.stability_class(),\n                ns_id = ns_id)?;\n-        render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)))?;\n+        render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl)?;\n         write!(w, \"</code>\")?;\n         render_stability_since(w, m, t)?;\n         write!(w, \"</span></h3>\")?;\n@@ -2227,15 +2234,17 @@ fn render_stability_since(w: &mut fmt::Formatter,\n \n fn render_assoc_item(w: &mut fmt::Formatter,\n                      item: &clean::Item,\n-                     link: AssocItemLink) -> fmt::Result {\n+                     link: AssocItemLink,\n+                     parent: ItemType) -> fmt::Result {\n     fn method(w: &mut fmt::Formatter,\n               meth: &clean::Item,\n               unsafety: hir::Unsafety,\n               constness: hir::Constness,\n               abi: abi::Abi,\n               g: &clean::Generics,\n               d: &clean::FnDecl,\n-              link: AssocItemLink)\n+              link: AssocItemLink,\n+              parent: ItemType)\n               -> fmt::Result {\n         let name = meth.name.as_ref().unwrap();\n         let anchor = format!(\"#{}.{}\", meth.type_(), name);\n@@ -2265,7 +2274,16 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                              AbiSpace(abi),\n                              name,\n                              *g);\n-        let indent = repeat(\"&nbsp;\").take(prefix.len()).collect::<String>();\n+        let mut indent = prefix.len();\n+        let where_indent = if parent == ItemType::Trait {\n+            indent += 4;\n+            8\n+        } else if parent == ItemType::Impl {\n+            2\n+        } else {\n+            let prefix = prefix + &format!(\"{:#}\", Method(d, indent));\n+            prefix.lines().last().unwrap().len() + 1\n+        };\n         write!(w, \"{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n                ConstnessSpace(vis_constness),\n@@ -2274,19 +2292,18 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                href = href,\n                name = name,\n                generics = *g,\n-               decl = Method(d, &indent),\n-               where_clause = WhereClause(g))\n+               decl = Method(d, indent),\n+               where_clause = WhereClause(g, where_indent))\n     }\n     match item.inner {\n         clean::StrippedItem(..) => Ok(()),\n         clean::TyMethodItem(ref m) => {\n             method(w, item, m.unsafety, hir::Constness::NotConst,\n-                   m.abi, &m.generics, &m.decl, link)\n+                   m.abi, &m.generics, &m.decl, link, parent)\n         }\n         clean::MethodItem(ref m) => {\n             method(w, item, m.unsafety, m.constness,\n-                   m.abi, &m.generics, &m.decl,\n-                   link)\n+                   m.abi, &m.generics, &m.decl, link, parent)\n         }\n         clean::AssociatedConstItem(ref ty, ref default) => {\n             assoc_const(w, item, ty, default.as_ref(), link)\n@@ -2383,11 +2400,15 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n              e: &clean::Enum) -> fmt::Result {\n     write!(w, \"<pre class='rust enum'>\")?;\n     render_attributes(w, it)?;\n+    let padding = format!(\"{}enum {}{:#} \",\n+                          VisSpace(&it.visibility),\n+                          it.name.as_ref().unwrap(),\n+                          e.generics).len();\n     write!(w, \"{}enum {}{}{}\",\n            VisSpace(&it.visibility),\n            it.name.as_ref().unwrap(),\n            e.generics,\n-           WhereClause(&e.generics))?;\n+           WhereClause(&e.generics, padding))?;\n     if e.variants.is_empty() && !e.variants_stripped {\n         write!(w, \" {{}}\")?;\n     } else {\n@@ -2559,17 +2580,23 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                  fields: &[clean::Item],\n                  tab: &str,\n                  structhead: bool) -> fmt::Result {\n+    let mut plain = String::new();\n     write!(w, \"{}{}{}\",\n            VisSpace(&it.visibility),\n            if structhead {\"struct \"} else {\"\"},\n            it.name.as_ref().unwrap())?;\n+    plain.push_str(&format!(\"{}{}{}\",\n+                            VisSpace(&it.visibility),\n+                            if structhead {\"struct \"} else {\"\"},\n+                            it.name.as_ref().unwrap()));\n     if let Some(g) = g {\n+        plain.push_str(&format!(\"{:#}\", g));\n         write!(w, \"{}\", g)?\n     }\n     match ty {\n         doctree::Plain => {\n             if let Some(g) = g {\n-                write!(w, \"{}\", WhereClause(g))?\n+                write!(w, \"{}\", WhereClause(g, plain.len() + 1))?\n             }\n             let mut has_visible_fields = false;\n             write!(w, \" {{\")?;\n@@ -2598,30 +2625,35 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n         }\n         doctree::Tuple => {\n             write!(w, \"(\")?;\n+            plain.push_str(\"(\");\n             for (i, field) in fields.iter().enumerate() {\n                 if i > 0 {\n                     write!(w, \", \")?;\n+                    plain.push_str(\", \");\n                 }\n                 match field.inner {\n                     clean::StrippedItem(box clean::StructFieldItem(..)) => {\n+                        plain.push_str(\"_\");\n                         write!(w, \"_\")?\n                     }\n                     clean::StructFieldItem(ref ty) => {\n+                        plain.push_str(&format!(\"{}{:#}\", VisSpace(&field.visibility), *ty));\n                         write!(w, \"{}{}\", VisSpace(&field.visibility), *ty)?\n                     }\n                     _ => unreachable!()\n                 }\n             }\n             write!(w, \")\")?;\n+            plain.push_str(\")\");\n             if let Some(g) = g {\n-                write!(w, \"{}\", WhereClause(g))?\n+                write!(w, \"{}\", WhereClause(g, plain.len() + 1))?\n             }\n             write!(w, \";\")?;\n         }\n         doctree::Unit => {\n             // Needed for PhantomData.\n             if let Some(g) = g {\n-                write!(w, \"{}\", WhereClause(g))?\n+                write!(w, \"{}\", WhereClause(g, plain.len() + 1))?\n             }\n             write!(w, \";\")?;\n         }\n@@ -2634,13 +2666,19 @@ fn render_union(w: &mut fmt::Formatter, it: &clean::Item,\n                 fields: &[clean::Item],\n                 tab: &str,\n                 structhead: bool) -> fmt::Result {\n+    let mut plain = String::new();\n     write!(w, \"{}{}{}\",\n            VisSpace(&it.visibility),\n            if structhead {\"union \"} else {\"\"},\n            it.name.as_ref().unwrap())?;\n+    plain.push_str(&format!(\"{}{}{}\",\n+                            VisSpace(&it.visibility),\n+                            if structhead {\"union \"} else {\"\"},\n+                            it.name.as_ref().unwrap()));\n     if let Some(g) = g {\n         write!(w, \"{}\", g)?;\n-        write!(w, \"{}\", WhereClause(g))?;\n+        plain.push_str(&format!(\"{:#}\", g));\n+        write!(w, \"{}\", WhereClause(g, plain.len() + 1))?;\n     }\n \n     write!(w, \" {{\\n{}\", tab)?;\n@@ -2831,7 +2869,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                     write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n                     write!(w, \"<span id='{}' class='invisible'>\", ns_id)?;\n                     write!(w, \"<code>\")?;\n-                    render_assoc_item(w, item, link.anchor(&id))?;\n+                    render_assoc_item(w, item, link.anchor(&id), ItemType::Impl)?;\n                     write!(w, \"</code>\")?;\n                     render_stability_since_raw(w, item.stable_since(), outer_version)?;\n                     write!(w, \"</span></h4>\\n\")?;\n@@ -2941,10 +2979,11 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n \n fn item_typedef(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 t: &clean::Typedef) -> fmt::Result {\n+    let indent = format!(\"type {}{:#} \", it.name.as_ref().unwrap(), t.generics).len();\n     write!(w, \"<pre class='rust typedef'>type {}{}{where_clause} = {type_};</pre>\",\n            it.name.as_ref().unwrap(),\n            t.generics,\n-           where_clause = WhereClause(&t.generics),\n+           where_clause = WhereClause(&t.generics, indent),\n            type_ = t.type_)?;\n \n     document(w, cx, it)"}, {"sha": "917b5f4fadc07a75dd1e1445c47298a922a9d270", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -361,9 +361,17 @@ h4 > code, h3 > code, .invisible > code {\n \tposition: relative;\n }\n /* Shift \"where ...\" part of method or fn definition down a line */\n-.content .method .where, .content .fn .where { display: block; }\n+.content .method .where,\n+.content .fn .where,\n+.content .where.fmt-newline {\n+    display: block;\n+}\n /* Bit of whitespace to indent it */\n-.content .method .where::before, .content .fn .where::before { content: '  '; }\n+.content .method .where::before,\n+.content .fn .where::before,\n+.content .where.fmt-newline::before {\n+    content: '  ';\n+}\n \n .content .methods > div { margin-left: 40px; }\n "}, {"sha": "cd7a50d07e268e4ec03d5e882b2b7f846ccc8542", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -187,7 +187,10 @@ impl<R: Read> BufRead for BufReader<R> {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> {\n         // If we've reached the end of our internal buffer then we need to fetch\n         // some more data from the underlying reader.\n-        if self.pos == self.cap {\n+        // Branch using `>=` instead of the more correct `==`\n+        // to tell the compiler that the pos..cap slice is always valid.\n+        if self.pos >= self.cap {\n+            debug_assert!(self.pos == self.cap);\n             self.cap = self.inner.read(&mut self.buf)?;\n             self.pos = 0;\n         }"}, {"sha": "2773629c7d7d4e63e911e0723a172d8e43deb98a", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -1267,6 +1267,38 @@ impl error::Error for TryRecvError {\n     }\n }\n \n+#[stable(feature = \"mpsc_recv_timeout_error\", since = \"1.14.0\")]\n+impl fmt::Display for RecvTimeoutError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            RecvTimeoutError::Timeout => {\n+                \"timed out waiting on channel\".fmt(f)\n+            }\n+            RecvTimeoutError::Disconnected => {\n+                \"channel is empty and sending half is closed\".fmt(f)\n+            }\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"mpsc_recv_timeout_error\", since = \"1.14.0\")]\n+impl error::Error for RecvTimeoutError {\n+    fn description(&self) -> &str {\n+        match *self {\n+            RecvTimeoutError::Timeout => {\n+                \"timed out waiting on channel\"\n+            }\n+            RecvTimeoutError::Disconnected => {\n+                \"channel is empty and sending half is closed\"\n+            }\n+        }\n+    }\n+\n+    fn cause(&self) -> Option<&error::Error> {\n+        None\n+    }\n+}\n+\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n     use env;"}, {"sha": "41d675b6f88fc4f7be2819536c8da5c1d9670a21", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -39,7 +39,7 @@ const MILLIS_PER_SEC: u64 = 1_000;\n /// let ten_millis = Duration::from_millis(10);\n /// ```\n #[stable(feature = \"duration\", since = \"1.3.0\")]\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash, Default)]\n pub struct Duration {\n     secs: u64,\n     nanos: u32, // Always 0 <= nanos < NANOS_PER_SEC"}, {"sha": "0b38f5450b63faf09251971ad20926318130c2ff", "filename": "src/libsyntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2FCargo.toml?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -14,3 +14,4 @@ log = { path = \"../liblog\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_errors = { path = \"../librustc_errors\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "02429f02738fdcfe5c7bc77845d993443b3458e8", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -277,7 +277,7 @@ impl<'a> fold::Folder for StripUnconfigured<'a> {\n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n         match self.configure_stmt(stmt) {\n             Some(stmt) => fold::noop_fold_stmt(stmt, self),\n-            None => return SmallVector::zero(),\n+            None => return SmallVector::new(),\n         }\n     }\n "}, {"sha": "b4ac576f57a534b20010da304d3c276f9470203a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -440,23 +440,23 @@ impl MacResult for DummyResult {\n         if self.expr_only {\n             None\n         } else {\n-            Some(SmallVector::zero())\n+            Some(SmallVector::new())\n         }\n     }\n \n     fn make_impl_items(self: Box<DummyResult>) -> Option<SmallVector<ast::ImplItem>> {\n         if self.expr_only {\n             None\n         } else {\n-            Some(SmallVector::zero())\n+            Some(SmallVector::new())\n         }\n     }\n \n     fn make_trait_items(self: Box<DummyResult>) -> Option<SmallVector<ast::TraitItem>> {\n         if self.expr_only {\n             None\n         } else {\n-            Some(SmallVector::zero())\n+            Some(SmallVector::new())\n         }\n     }\n "}, {"sha": "877b312539f92d63e5f1d3cbbe0b5157dbad9b70", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -89,7 +89,7 @@ macro_rules! expansions {\n                     Expansion::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n                     Expansion::OptExpr(None) => {}\n                     $($( Expansion::$kind(ref ast) => visitor.$visit(ast), )*)*\n-                    $($( Expansion::$kind(ref ast) => for ast in ast.as_slice() {\n+                    $($( Expansion::$kind(ref ast) => for ast in &ast[..] {\n                         visitor.$visit_elt(ast);\n                     }, )*)*\n                 }\n@@ -511,28 +511,28 @@ impl<'a> Parser<'a> {\n                            -> PResult<'a, Expansion> {\n         Ok(match kind {\n             ExpansionKind::Items => {\n-                let mut items = SmallVector::zero();\n+                let mut items = SmallVector::new();\n                 while let Some(item) = self.parse_item()? {\n                     items.push(item);\n                 }\n                 Expansion::Items(items)\n             }\n             ExpansionKind::TraitItems => {\n-                let mut items = SmallVector::zero();\n+                let mut items = SmallVector::new();\n                 while self.token != token::Eof {\n                     items.push(self.parse_trait_item()?);\n                 }\n                 Expansion::TraitItems(items)\n             }\n             ExpansionKind::ImplItems => {\n-                let mut items = SmallVector::zero();\n+                let mut items = SmallVector::new();\n                 while self.token != token::Eof {\n                     items.push(self.parse_impl_item()?);\n                 }\n                 Expansion::ImplItems(items)\n             }\n             ExpansionKind::Stmts => {\n-                let mut stmts = SmallVector::zero();\n+                let mut stmts = SmallVector::new();\n                 while self.token != token::Eof &&\n                       // won't make progress on a `}`\n                       self.token != token::CloseDelim(token::Brace) {\n@@ -573,7 +573,7 @@ macro_rules! fully_configure {\n     ($this:ident, $node:ident, $noop_fold:ident) => {\n         match $noop_fold($node, &mut $this.cfg).pop() {\n             Some(node) => node,\n-            None => return SmallVector::zero(),\n+            None => return SmallVector::new(),\n         }\n     }\n }\n@@ -689,7 +689,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n         let stmt = match self.cfg.configure_stmt(stmt) {\n             Some(stmt) => stmt,\n-            None => return SmallVector::zero(),\n+            None => return SmallVector::new(),\n         };\n \n         let (mac, style, attrs) = if let StmtKind::Mac(mac) = stmt.node {"}, {"sha": "bda84cdaf39eb6d568e98ff900c1551b97ad964b", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -104,7 +104,7 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::T\n         }\n         fn make_items(mut self: Box<ExpandResult<'a>>)\n                       -> Option<SmallVector<P<ast::Item>>> {\n-            let mut ret = SmallVector::zero();\n+            let mut ret = SmallVector::new();\n             while self.p.token != token::Eof {\n                 match panictry!(self.p.parse_item()) {\n                     Some(item) => ret.push(item),"}, {"sha": "34280812421a131f74ca0db319e67365f452f38c", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -45,6 +45,7 @@ extern crate libc;\n extern crate rustc_unicode;\n pub extern crate rustc_errors as errors;\n extern crate syntax_pos;\n+extern crate rustc_data_structures;\n \n extern crate serialize as rustc_serialize; // used by deriving\n "}, {"sha": "fe05e2958b3a851dd1e6828a99560cf07b3e082a", "filename": "src/libsyntax/util/move_map.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax%2Futil%2Fmove_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax%2Futil%2Fmove_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fmove_map.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -10,6 +10,8 @@\n \n use std::ptr;\n \n+use util::small_vector::SmallVector;\n+\n pub trait MoveMap<T>: Sized {\n     fn move_map<F>(self, mut f: F) -> Self where F: FnMut(T) -> T {\n         self.move_flat_map(|e| Some(f(e)))\n@@ -75,3 +77,50 @@ impl<T> MoveMap<T> for ::ptr::P<[T]> {\n         ::ptr::P::from_vec(self.into_vec().move_flat_map(f))\n     }\n }\n+\n+impl<T> MoveMap<T> for SmallVector<T> {\n+    fn move_flat_map<F, I>(mut self, mut f: F) -> Self\n+        where F: FnMut(T) -> I,\n+              I: IntoIterator<Item=T>\n+    {\n+        let mut read_i = 0;\n+        let mut write_i = 0;\n+        unsafe {\n+            let mut old_len = self.len();\n+            self.set_len(0); // make sure we just leak elements in case of panic\n+\n+            while read_i < old_len {\n+                // move the read_i'th item out of the vector and map it\n+                // to an iterator\n+                let e = ptr::read(self.get_unchecked(read_i));\n+                let mut iter = f(e).into_iter();\n+                read_i += 1;\n+\n+                while let Some(e) = iter.next() {\n+                    if write_i < read_i {\n+                        ptr::write(self.get_unchecked_mut(write_i), e);\n+                        write_i += 1;\n+                    } else {\n+                        // If this is reached we ran out of space\n+                        // in the middle of the vector.\n+                        // However, the vector is in a valid state here,\n+                        // so we just do a somewhat inefficient insert.\n+                        self.set_len(old_len);\n+                        self.insert(write_i, e);\n+\n+                        old_len = self.len();\n+                        self.set_len(0);\n+\n+                        read_i += 1;\n+                        write_i += 1;\n+                    }\n+                }\n+            }\n+\n+            // write_i tracks the number of actually written new items.\n+            self.set_len(write_i);\n+        }\n+\n+        self\n+    }\n+}"}, {"sha": "31e675836fc72b9e876c97eef8e137a739d3120a", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 12, "deletions": 256, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -8,261 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::SmallVectorRepr::*;\n-use self::IntoIterRepr::*;\n+use rustc_data_structures::small_vec::SmallVec;\n \n-use core::ops;\n-use std::iter::{IntoIterator, FromIterator};\n-use std::mem;\n-use std::slice;\n-use std::vec;\n-\n-use util::move_map::MoveMap;\n-\n-/// A vector type optimized for cases where the size is almost always 0 or 1\n-#[derive(Clone)]\n-pub struct SmallVector<T> {\n-    repr: SmallVectorRepr<T>,\n-}\n-\n-#[derive(Clone)]\n-enum SmallVectorRepr<T> {\n-    Zero,\n-    One(T),\n-    Many(Vec<T>),\n-}\n-\n-impl<T> Default for SmallVector<T> {\n-    fn default() -> Self {\n-        SmallVector { repr: Zero }\n-    }\n-}\n-\n-impl<T> Into<Vec<T>> for SmallVector<T> {\n-    fn into(self) -> Vec<T> {\n-        match self.repr {\n-            Zero => Vec::new(),\n-            One(t) => vec![t],\n-            Many(vec) => vec,\n-        }\n-    }\n-}\n-\n-impl<T> FromIterator<T> for SmallVector<T> {\n-    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> SmallVector<T> {\n-        let mut v = SmallVector::zero();\n-        v.extend(iter);\n-        v\n-    }\n-}\n-\n-impl<T> Extend<T> for SmallVector<T> {\n-    fn extend<I: IntoIterator<Item=T>>(&mut self, iter: I) {\n-        for val in iter {\n-            self.push(val);\n-        }\n-    }\n-}\n-\n-impl<T> SmallVector<T> {\n-    pub fn zero() -> SmallVector<T> {\n-        SmallVector { repr: Zero }\n-    }\n-\n-    pub fn one(v: T) -> SmallVector<T> {\n-        SmallVector { repr: One(v) }\n-    }\n-\n-    pub fn many(vs: Vec<T>) -> SmallVector<T> {\n-        SmallVector { repr: Many(vs) }\n-    }\n-\n-    pub fn as_slice(&self) -> &[T] {\n-        self\n-    }\n-\n-    pub fn as_mut_slice(&mut self) -> &mut [T] {\n-        self\n-    }\n-\n-    pub fn pop(&mut self) -> Option<T> {\n-        match self.repr {\n-            Zero => None,\n-            One(..) => {\n-                let one = mem::replace(&mut self.repr, Zero);\n-                match one {\n-                    One(v1) => Some(v1),\n-                    _ => unreachable!()\n-                }\n-            }\n-            Many(ref mut vs) => vs.pop(),\n-        }\n-    }\n-\n-    pub fn push(&mut self, v: T) {\n-        match self.repr {\n-            Zero => self.repr = One(v),\n-            One(..) => {\n-                let one = mem::replace(&mut self.repr, Zero);\n-                match one {\n-                    One(v1) => mem::replace(&mut self.repr, Many(vec![v1, v])),\n-                    _ => unreachable!()\n-                };\n-            }\n-            Many(ref mut vs) => vs.push(v)\n-        }\n-    }\n-\n-    pub fn push_all(&mut self, other: SmallVector<T>) {\n-        for v in other.into_iter() {\n-            self.push(v);\n-        }\n-    }\n-\n-    pub fn get(&self, idx: usize) -> &T {\n-        match self.repr {\n-            One(ref v) if idx == 0 => v,\n-            Many(ref vs) => &vs[idx],\n-            _ => panic!(\"out of bounds access\")\n-        }\n-    }\n-\n-    pub fn expect_one(self, err: &'static str) -> T {\n-        match self.repr {\n-            One(v) => v,\n-            Many(v) => {\n-                if v.len() == 1 {\n-                    v.into_iter().next().unwrap()\n-                } else {\n-                    panic!(err)\n-                }\n-            }\n-            _ => panic!(err)\n-        }\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        match self.repr {\n-            Zero => 0,\n-            One(..) => 1,\n-            Many(ref vals) => vals.len()\n-        }\n-    }\n-\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-\n-    pub fn map<U, F: FnMut(T) -> U>(self, mut f: F) -> SmallVector<U> {\n-        let repr = match self.repr {\n-            Zero => Zero,\n-            One(t) => One(f(t)),\n-            Many(vec) => Many(vec.into_iter().map(f).collect()),\n-        };\n-        SmallVector { repr: repr }\n-    }\n-}\n-\n-impl<T> ops::Deref for SmallVector<T> {\n-    type Target = [T];\n-\n-    fn deref(&self) -> &[T] {\n-        match self.repr {\n-            Zero => {\n-                let result: &[T] = &[];\n-                result\n-            }\n-            One(ref v) => {\n-                unsafe { slice::from_raw_parts(v, 1) }\n-            }\n-            Many(ref vs) => vs\n-        }\n-    }\n-}\n-\n-impl<T> ops::DerefMut for SmallVector<T> {\n-    fn deref_mut(&mut self) -> &mut [T] {\n-        match self.repr {\n-            Zero => {\n-                let result: &mut [T] = &mut [];\n-                result\n-            }\n-            One(ref mut v) => {\n-                unsafe { slice::from_raw_parts_mut(v, 1) }\n-            }\n-            Many(ref mut vs) => vs\n-        }\n-    }\n-}\n-\n-impl<T> IntoIterator for SmallVector<T> {\n-    type Item = T;\n-    type IntoIter = IntoIter<T>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        let repr = match self.repr {\n-            Zero => ZeroIterator,\n-            One(v) => OneIterator(v),\n-            Many(vs) => ManyIterator(vs.into_iter())\n-        };\n-        IntoIter { repr: repr }\n-    }\n-}\n-\n-pub struct IntoIter<T> {\n-    repr: IntoIterRepr<T>,\n-}\n-\n-enum IntoIterRepr<T> {\n-    ZeroIterator,\n-    OneIterator(T),\n-    ManyIterator(vec::IntoIter<T>),\n-}\n-\n-impl<T> Iterator for IntoIter<T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        match self.repr {\n-            ZeroIterator => None,\n-            OneIterator(..) => {\n-                let mut replacement = ZeroIterator;\n-                mem::swap(&mut self.repr, &mut replacement);\n-                match replacement {\n-                    OneIterator(v) => Some(v),\n-                    _ => unreachable!()\n-                }\n-            }\n-            ManyIterator(ref mut inner) => inner.next()\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        match self.repr {\n-            ZeroIterator => (0, Some(0)),\n-            OneIterator(..) => (1, Some(1)),\n-            ManyIterator(ref inner) => inner.size_hint()\n-        }\n-    }\n-}\n-\n-impl<T> MoveMap<T> for SmallVector<T> {\n-    fn move_flat_map<F, I>(self, mut f: F) -> Self\n-        where F: FnMut(T) -> I,\n-              I: IntoIterator<Item=T>\n-    {\n-        match self.repr {\n-            Zero => Self::zero(),\n-            One(v) => f(v).into_iter().collect(),\n-            Many(vs) => SmallVector { repr: Many(vs.move_flat_map(f)) },\n-        }\n-    }\n-}\n+pub type SmallVector<T> = SmallVec<[T; 1]>;\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n \n     #[test]\n     fn test_len() {\n-        let v: SmallVector<isize> = SmallVector::zero();\n+        let v: SmallVector<isize> = SmallVector::new();\n         assert_eq!(0, v.len());\n \n         assert_eq!(1, SmallVector::one(1).len());\n@@ -271,30 +27,30 @@ mod tests {\n \n     #[test]\n     fn test_push_get() {\n-        let mut v = SmallVector::zero();\n+        let mut v = SmallVector::new();\n         v.push(1);\n         assert_eq!(1, v.len());\n-        assert_eq!(&1, v.get(0));\n+        assert_eq!(1, v[0]);\n         v.push(2);\n         assert_eq!(2, v.len());\n-        assert_eq!(&2, v.get(1));\n+        assert_eq!(2, v[1]);\n         v.push(3);\n         assert_eq!(3, v.len());\n-        assert_eq!(&3, v.get(2));\n+        assert_eq!(3, v[2]);\n     }\n \n     #[test]\n     fn test_from_iter() {\n         let v: SmallVector<isize> = (vec![1, 2, 3]).into_iter().collect();\n         assert_eq!(3, v.len());\n-        assert_eq!(&1, v.get(0));\n-        assert_eq!(&2, v.get(1));\n-        assert_eq!(&3, v.get(2));\n+        assert_eq!(1, v[0]);\n+        assert_eq!(2, v[1]);\n+        assert_eq!(3, v[2]);\n     }\n \n     #[test]\n     fn test_move_iter() {\n-        let v = SmallVector::zero();\n+        let v = SmallVector::new();\n         let v: Vec<isize> = v.into_iter().collect();\n         assert_eq!(v, Vec::new());\n \n@@ -308,7 +64,7 @@ mod tests {\n     #[test]\n     #[should_panic]\n     fn test_expect_one_zero() {\n-        let _: isize = SmallVector::zero().expect_one(\"\");\n+        let _: isize = SmallVector::new().expect_one(\"\");\n     }\n \n     #[test]"}, {"sha": "6eba8baf5b82496b002284fff2d59ef14f46bc2f", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 80, "deletions": 4, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -22,7 +22,7 @@ use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::tokenstream;\n \n-use std::collections::HashMap;\n+use std::collections::{HashMap, HashSet};\n use std::collections::hash_map::Entry;\n \n #[derive(PartialEq)]\n@@ -756,8 +756,12 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n     }\n \n     if !parser.errors.is_empty() {\n-        cx.ecx.span_err(cx.fmtsp,\n-                        &format!(\"invalid format string: {}\", parser.errors.remove(0)));\n+        let (err, note) = parser.errors.remove(0);\n+        let mut e = cx.ecx.struct_span_err(cx.fmtsp, &format!(\"invalid format string: {}\", err));\n+        if let Some(note) = note {\n+            e.note(&note);\n+        }\n+        e.emit();\n         return DummyResult::raw_expr(sp);\n     }\n     if !cx.literal.is_empty() {\n@@ -767,6 +771,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n \n     // Make sure that all arguments were used and all arguments have types.\n     let num_pos_args = cx.args.len() - cx.names.len();\n+    let mut errs = vec![];\n     for (i, ty) in cx.arg_types.iter().enumerate() {\n         if ty.len() == 0 {\n             if cx.count_positions.contains_key(&i) {\n@@ -779,8 +784,79 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n                 // positional argument\n                 \"argument never used\"\n             };\n-            cx.ecx.span_err(cx.args[i].span, msg);\n+            errs.push((cx.args[i].span, msg));\n+        }\n+    }\n+    if errs.len() > 0 {\n+        let args_used = cx.arg_types.len() - errs.len();\n+        let args_unused = errs.len();\n+\n+        let mut diag = {\n+            if errs.len() == 1 {\n+                let (sp, msg) = errs.into_iter().next().unwrap();\n+                cx.ecx.struct_span_err(sp, msg)\n+            } else {\n+                let mut diag = cx.ecx.struct_span_err(cx.fmtsp,\n+                    \"multiple unused formatting arguments\");\n+                for (sp, msg) in errs {\n+                    diag.span_note(sp, msg);\n+                }\n+                diag\n+            }\n+        };\n+\n+        // Decide if we want to look for foreign formatting directives.\n+        if args_used < args_unused {\n+            use super::format_foreign as foreign;\n+            let fmt_str = &fmt.node.0[..];\n+\n+            // The set of foreign substitutions we've explained.  This prevents spamming the user\n+            // with `%d should be written as {}` over and over again.\n+            let mut explained = HashSet::new();\n+\n+            // Used to ensure we only report translations for *one* kind of foreign format.\n+            let mut found_foreign = false;\n+\n+            macro_rules! check_foreign {\n+                ($kind:ident) => {{\n+                    let mut show_doc_note = false;\n+\n+                    for sub in foreign::$kind::iter_subs(fmt_str) {\n+                        let trn = match sub.translate() {\n+                            Some(trn) => trn,\n+\n+                            // If it has no translation, don't call it out specifically.\n+                            None => continue,\n+                        };\n+\n+                        let sub = String::from(sub.as_str());\n+                        if explained.contains(&sub) {\n+                            continue;\n+                        }\n+                        explained.insert(sub.clone());\n+\n+                        if !found_foreign {\n+                            found_foreign = true;\n+                            show_doc_note = true;\n+                        }\n+\n+                        diag.help(&format!(\"`{}` should be written as `{}`\", sub, trn));\n+                    }\n+\n+                    if show_doc_note {\n+                        diag.note(concat!(stringify!($kind), \" formatting not supported; see \\\n+                                the documentation for `std::fmt`\"));\n+                    }\n+                }};\n+            }\n+\n+            check_foreign!(printf);\n+            if !found_foreign {\n+                check_foreign!(shell);\n+            }\n         }\n+\n+        diag.emit();\n     }\n \n     cx.into_expr()"}, {"sha": "3c802e8334dafd8c96197823f535bf3998647f47", "filename": "src/libsyntax_ext/format_foreign.rs", "status": "added", "additions": 1013, "deletions": 0, "changes": 1013, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax_ext%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax_ext%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat_foreign.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,1013 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! try_opt {\n+    ($e:expr) => {\n+        match $e {\n+            Some(v) => v,\n+            None => return None,\n+        }\n+    };\n+}\n+\n+pub mod printf {\n+    use super::strcursor::StrCursor as Cur;\n+\n+    /// Represents a single `printf`-style substitution.\n+    #[derive(Clone, Eq, PartialEq, Debug)]\n+    pub enum Substitution<'a> {\n+        /// A formatted output substitution.\n+        Format(Format<'a>),\n+        /// A literal `%%` escape.\n+        Escape,\n+    }\n+\n+    impl<'a> Substitution<'a> {\n+        pub fn as_str(&self) -> &str {\n+            match *self {\n+                Substitution::Format(ref fmt) => fmt.span,\n+                Substitution::Escape => \"%%\",\n+            }\n+        }\n+\n+        /// Translate this substitution into an equivalent Rust formatting directive.\n+        ///\n+        /// This ignores cases where the substitution does not have an exact equivalent, or where\n+        /// the substitution would be unnecessary.\n+        pub fn translate(&self) -> Option<String> {\n+            match *self {\n+                Substitution::Format(ref fmt) => fmt.translate(),\n+                Substitution::Escape => None,\n+            }\n+        }\n+    }\n+\n+    #[derive(Clone, Eq, PartialEq, Debug)]\n+    /// A single `printf`-style formatting directive.\n+    pub struct Format<'a> {\n+        /// The entire original formatting directive.\n+        pub span: &'a str,\n+        /// The (1-based) parameter to be converted.\n+        pub parameter: Option<u16>,\n+        /// Formatting flags.\n+        pub flags: &'a str,\n+        /// Minimum width of the output.\n+        pub width: Option<Num>,\n+        /// Precision of the conversion.\n+        pub precision: Option<Num>,\n+        /// Length modifier for the conversion.\n+        pub length: Option<&'a str>,\n+        /// Type of parameter being converted.\n+        pub type_: &'a str,\n+    }\n+\n+    impl<'a> Format<'a> {\n+        /// Translate this directive into an equivalent Rust formatting directive.\n+        ///\n+        /// Returns `None` in cases where the `printf` directive does not have an exact Rust\n+        /// equivalent, rather than guessing.\n+        pub fn translate(&self) -> Option<String> {\n+            use std::fmt::Write;\n+\n+            let (c_alt, c_zero, c_left, c_plus) = {\n+                let mut c_alt = false;\n+                let mut c_zero = false;\n+                let mut c_left = false;\n+                let mut c_plus = false;\n+                for c in self.flags.chars() {\n+                    match c {\n+                        '#' => c_alt = true,\n+                        '0' => c_zero = true,\n+                        '-' => c_left = true,\n+                        '+' => c_plus = true,\n+                        _ => return None\n+                    }\n+                }\n+                (c_alt, c_zero, c_left, c_plus)\n+            };\n+\n+            // Has a special form in Rust for numbers.\n+            let fill = if c_zero { Some(\"0\") } else { None };\n+\n+            let align = if c_left { Some(\"<\") } else { None };\n+\n+            // Rust doesn't have an equivalent to the `' '` flag.\n+            let sign = if c_plus { Some(\"+\") } else { None };\n+\n+            // Not *quite* the same, depending on the type...\n+            let alt = c_alt;\n+\n+            let width = match self.width {\n+                Some(Num::Next) => {\n+                    // NOTE: Rust doesn't support this.\n+                    return None;\n+                }\n+                w @ Some(Num::Arg(_)) => w,\n+                w @ Some(Num::Num(_)) => w,\n+                None => None,\n+            };\n+\n+            let precision = self.precision;\n+\n+            // NOTE: although length *can* have an effect, we can't duplicate the effect in Rust, so\n+            // we just ignore it.\n+\n+            let (type_, use_zero_fill, is_int) = match self.type_ {\n+                \"d\" | \"i\" | \"u\" => (None, true, true),\n+                \"f\" | \"F\" => (None, false, false),\n+                \"s\" | \"c\" => (None, false, false),\n+                \"e\" | \"E\" => (Some(self.type_), true, false),\n+                \"x\" | \"X\" | \"o\" => (Some(self.type_), true, true),\n+                \"p\" => (Some(self.type_), false, true),\n+                \"g\" => (Some(\"e\"), true, false),\n+                \"G\" => (Some(\"E\"), true, false),\n+                _ => return None,\n+            };\n+\n+            let (fill, width, precision) = match (is_int, width, precision) {\n+                (true, Some(_), Some(_)) => {\n+                    // Rust can't duplicate this insanity.\n+                    return None;\n+                },\n+                (true, None, Some(p)) => (Some(\"0\"), Some(p), None),\n+                (true, w, None) => (fill, w, None),\n+                (false, w, p) => (fill, w, p),\n+            };\n+\n+            let align = match (self.type_, width.is_some(), align.is_some()) {\n+                (\"s\", true, false) => Some(\">\"),\n+                _ => align,\n+            };\n+\n+            let (fill, zero_fill) = match (fill, use_zero_fill) {\n+                (Some(\"0\"), true) => (None, true),\n+                (fill, _) => (fill, false),\n+            };\n+\n+            let alt = match type_ {\n+                Some(\"x\") | Some(\"X\") => alt,\n+                _ => false,\n+            };\n+\n+            let has_options = fill.is_some()\n+                || align.is_some()\n+                || sign.is_some()\n+                || alt\n+                || zero_fill\n+                || width.is_some()\n+                || precision.is_some()\n+                || type_.is_some()\n+                ;\n+\n+            // Initialise with a rough guess.\n+            let cap = self.span.len() + if has_options { 2 } else { 0 };\n+            let mut s = String::with_capacity(cap);\n+\n+            s.push_str(\"{\");\n+\n+            if let Some(arg) = self.parameter {\n+                try_opt!(write!(s, \"{}\", try_opt!(arg.checked_sub(1))).ok());\n+            }\n+\n+            if has_options {\n+                s.push_str(\":\");\n+\n+                let align = if let Some(fill) = fill {\n+                    s.push_str(fill);\n+                    align.or(Some(\">\"))\n+                } else {\n+                    align\n+                };\n+\n+                if let Some(align) = align {\n+                    s.push_str(align);\n+                }\n+\n+                if let Some(sign) = sign {\n+                    s.push_str(sign);\n+                }\n+\n+                if alt {\n+                    s.push_str(\"#\");\n+                }\n+\n+                if zero_fill {\n+                    s.push_str(\"0\");\n+                }\n+\n+                if let Some(width) = width {\n+                    try_opt!(width.translate(&mut s).ok());\n+                }\n+\n+                if let Some(precision) = precision {\n+                    s.push_str(\".\");\n+                    try_opt!(precision.translate(&mut s).ok());\n+                }\n+\n+                if let Some(type_) = type_ {\n+                    s.push_str(type_);\n+                }\n+            }\n+\n+            s.push_str(\"}\");\n+            Some(s)\n+        }\n+    }\n+\n+    /// A general number used in a `printf` formatting directive.\n+    #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+    pub enum Num {\n+        // The range of these values is technically bounded by `NL_ARGMAX`... but, at least for GNU\n+        // libc, it apparently has no real fixed limit.  A `u16` is used here on the basis that it\n+        // is *vanishingly* unlikely that *anyone* is going to try formatting something wider, or\n+        // with more precision, than 32 thousand positions which is so wide it couldn't possibly fit\n+        // on a screen.\n+\n+        /// A specific, fixed value.\n+        Num(u16),\n+        /// The value is derived from a positional argument.\n+        Arg(u16),\n+        /// The value is derived from the \"next\" unconverted argument.\n+        Next,\n+    }\n+\n+    impl Num {\n+        fn from_str(s: &str, arg: Option<&str>) -> Self {\n+            if let Some(arg) = arg {\n+                Num::Arg(arg.parse().expect(&format!(\"invalid format arg `{:?}`\", arg)))\n+            } else if s == \"*\" {\n+                Num::Next\n+            } else {\n+                Num::Num(s.parse().expect(&format!(\"invalid format num `{:?}`\", s)))\n+            }\n+        }\n+\n+        fn translate(&self, s: &mut String) -> ::std::fmt::Result {\n+            use std::fmt::Write;\n+            match *self {\n+                Num::Num(n) => write!(s, \"{}\", n),\n+                Num::Arg(n) => {\n+                    let n = try!(n.checked_sub(1).ok_or(::std::fmt::Error));\n+                    write!(s, \"{}$\", n)\n+                },\n+                Num::Next => write!(s, \"*\"),\n+            }\n+        }\n+    }\n+\n+    /// Returns an iterator over all substitutions in a given string.\n+    pub fn iter_subs(s: &str) -> Substitutions {\n+        Substitutions {\n+            s: s,\n+        }\n+    }\n+\n+    /// Iterator over substitutions in a string.\n+    pub struct Substitutions<'a> {\n+        s: &'a str,\n+    }\n+\n+    impl<'a> Iterator for Substitutions<'a> {\n+        type Item = Substitution<'a>;\n+        fn next(&mut self) -> Option<Self::Item> {\n+            match parse_next_substitution(self.s) {\n+                Some((sub, tail)) => {\n+                    self.s = tail;\n+                    Some(sub)\n+                },\n+                None => None,\n+            }\n+        }\n+    }\n+\n+    enum State {\n+        Start,\n+        Flags,\n+        Width,\n+        WidthArg,\n+        Prec,\n+        PrecInner,\n+        Length,\n+        Type,\n+    }\n+\n+    /// Parse the next substitution from the input string.\n+    pub fn parse_next_substitution(s: &str) -> Option<(Substitution, &str)> {\n+        use self::State::*;\n+\n+        let at = {\n+            let start = try_opt!(s.find('%'));\n+            match s[start+1..].chars().next() {\n+                Some('%') => return Some((Substitution::Escape, &s[start+2..])),\n+                Some(_) => {/* fall-through */},\n+                None => return None,\n+            }\n+\n+            Cur::new_at_start(&s[start..])\n+        };\n+\n+        // This is meant to be a translation of the following regex:\n+        //\n+        // ```regex\n+        // (?x)\n+        // ^ %\n+        // (?: (?P<parameter> \\d+) \\$ )?\n+        // (?P<flags> [-+ 0\\#']* )\n+        // (?P<width> \\d+ | \\* (?: (?P<widtha> \\d+) \\$ )? )?\n+        // (?: \\. (?P<precision> \\d+ | \\* (?: (?P<precisiona> \\d+) \\$ )? ) )?\n+        // (?P<length>\n+        //     # Standard\n+        //     hh | h | ll | l | L | z | j | t\n+        //\n+        //     # Other\n+        //     | I32 | I64 | I | q\n+        // )?\n+        // (?P<type> . )\n+        // ```\n+\n+        // Used to establish the full span at the end.\n+        let start = at;\n+        // The current position within the string.\n+        let mut at = try_opt!(at.at_next_cp());\n+        // `c` is the next codepoint, `next` is a cursor after it.\n+        let (mut c, mut next) = try_opt!(at.next_cp());\n+\n+        // Update `at`, `c`, and `next`, exiting if we're out of input.\n+        macro_rules! move_to {\n+            ($cur:expr) => {\n+                {\n+                    at = $cur;\n+                    let (c_, next_) = try_opt!(at.next_cp());\n+                    c = c_;\n+                    next = next_;\n+                }\n+            };\n+        }\n+\n+        // Constructs a result when parsing fails.\n+        //\n+        // Note: `move` used to capture copies of the cursors as they are *now*.\n+        let fallback = move || {\n+            return Some((\n+                Substitution::Format(Format {\n+                    span: start.slice_between(next).unwrap(),\n+                    parameter: None,\n+                    flags: \"\",\n+                    width: None,\n+                    precision: None,\n+                    length: None,\n+                    type_: at.slice_between(next).unwrap(),\n+                }),\n+                next.slice_after()\n+            ));\n+        };\n+\n+        // Next parsing state.\n+        let mut state = Start;\n+\n+        // Sadly, Rust isn't *quite* smart enough to know these *must* be initialised by the end.\n+        let mut parameter: Option<u16> = None;\n+        let mut flags: &str = \"\";\n+        let mut width: Option<Num> = None;\n+        let mut precision: Option<Num> = None;\n+        let mut length: Option<&str> = None;\n+        let mut type_: &str = \"\";\n+        let end: Cur;\n+\n+        if let Start = state {\n+            match c {\n+                '1'...'9' => {\n+                    let end = at_next_cp_while(next, is_digit);\n+                    match end.next_cp() {\n+                        // Yes, this *is* the parameter.\n+                        Some(('$', end2)) => {\n+                            state = Flags;\n+                            parameter = Some(at.slice_between(end).unwrap().parse().unwrap());\n+                            move_to!(end2);\n+                        },\n+                        // Wait, no, actually, it's the width.\n+                        Some(_) => {\n+                            state = Prec;\n+                            parameter = None;\n+                            flags = \"\";\n+                            width = Some(Num::from_str(at.slice_between(end).unwrap(), None));\n+                            move_to!(end);\n+                        },\n+                        // It's invalid, is what it is.\n+                        None => return fallback(),\n+                    }\n+                },\n+                _ => {\n+                    state = Flags;\n+                    parameter = None;\n+                    move_to!(at);\n+                }\n+            }\n+        }\n+\n+        if let Flags = state {\n+            let end = at_next_cp_while(at, is_flag);\n+            state = Width;\n+            flags = at.slice_between(end).unwrap();\n+            move_to!(end);\n+        }\n+\n+        if let Width = state {\n+            match c {\n+                '*' => {\n+                    state = WidthArg;\n+                    move_to!(next);\n+                },\n+                '1' ... '9' => {\n+                    let end = at_next_cp_while(next, is_digit);\n+                    state = Prec;\n+                    width = Some(Num::from_str(at.slice_between(end).unwrap(), None));\n+                    move_to!(end);\n+                },\n+                _ => {\n+                    state = Prec;\n+                    width = None;\n+                    move_to!(at);\n+                }\n+            }\n+        }\n+\n+        if let WidthArg = state {\n+            let end = at_next_cp_while(at, is_digit);\n+            match end.next_cp() {\n+                Some(('$', end2)) => {\n+                    state = Prec;\n+                    width = Some(Num::from_str(\"\", Some(at.slice_between(end).unwrap())));\n+                    move_to!(end2);\n+                },\n+                _ => {\n+                    state = Prec;\n+                    width = Some(Num::Next);\n+                    move_to!(end);\n+                }\n+            }\n+        }\n+\n+        if let Prec = state {\n+            match c {\n+                '.' => {\n+                    state = PrecInner;\n+                    move_to!(next);\n+                },\n+                _ => {\n+                    state = Length;\n+                    precision = None;\n+                    move_to!(at);\n+                }\n+            }\n+        }\n+\n+        if let PrecInner = state {\n+            match c {\n+                '*' => {\n+                    let end = at_next_cp_while(next, is_digit);\n+                    match end.next_cp() {\n+                        Some(('$', end2)) => {\n+                            state = Length;\n+                            precision = Some(Num::from_str(\"*\", next.slice_between(end)));\n+                            move_to!(end2);\n+                        },\n+                        _ => {\n+                            state = Length;\n+                            precision = Some(Num::Next);\n+                            move_to!(end);\n+                        }\n+                    }\n+                },\n+                '0' ... '9' => {\n+                    let end = at_next_cp_while(next, is_digit);\n+                    state = Length;\n+                    precision = Some(Num::from_str(at.slice_between(end).unwrap(), None));\n+                    move_to!(end);\n+                },\n+                _ => return fallback(),\n+            }\n+        }\n+\n+        if let Length = state {\n+            let c1_next1 = next.next_cp();\n+            match (c, c1_next1) {\n+                ('h', Some(('h', next1)))\n+                | ('l', Some(('l', next1)))\n+                => {\n+                    state = Type;\n+                    length = Some(at.slice_between(next1).unwrap());\n+                    move_to!(next1);\n+                },\n+\n+                ('h', _) | ('l', _) | ('L', _)\n+                | ('z', _) | ('j', _) | ('t', _)\n+                | ('q', _)\n+                => {\n+                    state = Type;\n+                    length = Some(at.slice_between(next).unwrap());\n+                    move_to!(next);\n+                },\n+\n+                ('I', _) => {\n+                    let end = next.at_next_cp()\n+                        .and_then(|end| end.at_next_cp())\n+                        .map(|end| (next.slice_between(end).unwrap(), end));\n+                    let end = match end {\n+                        Some((\"32\", end)) => end,\n+                        Some((\"64\", end)) => end,\n+                        _ => next\n+                    };\n+                    state = Type;\n+                    length = Some(at.slice_between(end).unwrap());\n+                    move_to!(end);\n+                },\n+\n+                _ => {\n+                    state = Type;\n+                    length = None;\n+                    move_to!(at);\n+                }\n+            }\n+        }\n+\n+        if let Type = state {\n+            drop(c);\n+            type_ = at.slice_between(next).unwrap();\n+\n+            // Don't use `move_to!` here, as we *can* be at the end of the input.\n+            at = next;\n+        }\n+\n+        drop(c);\n+        drop(next);\n+\n+        end = at;\n+\n+        let f = Format {\n+            span: start.slice_between(end).unwrap(),\n+            parameter: parameter,\n+            flags: flags,\n+            width: width,\n+            precision: precision,\n+            length: length,\n+            type_: type_,\n+        };\n+        Some((Substitution::Format(f), end.slice_after()))\n+    }\n+\n+    fn at_next_cp_while<F>(mut cur: Cur, mut pred: F) -> Cur\n+    where F: FnMut(char) -> bool {\n+        loop {\n+            match cur.next_cp() {\n+                Some((c, next)) => if pred(c) {\n+                    cur = next;\n+                } else {\n+                    return cur;\n+                },\n+                None => return cur,\n+            }\n+        }\n+    }\n+\n+    fn is_digit(c: char) -> bool {\n+        match c {\n+            '0' ... '9' => true,\n+            _ => false\n+        }\n+    }\n+\n+    fn is_flag(c: char) -> bool {\n+        match c {\n+            '0' | '-' | '+' | ' ' | '#' | '\\'' => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+        use super::{\n+            Format as F,\n+            Num as N,\n+            Substitution as S,\n+            iter_subs,\n+            parse_next_substitution as pns,\n+        };\n+\n+        macro_rules! assert_eq_pnsat {\n+            ($lhs:expr, $rhs:expr) => {\n+                assert_eq!(\n+                    pns($lhs).and_then(|(s, _)| s.translate()),\n+                    $rhs.map(<String as From<&str>>::from)\n+                )\n+            };\n+        }\n+\n+        #[test]\n+        fn test_escape() {\n+            assert_eq!(pns(\"has no escapes\"), None);\n+            assert_eq!(pns(\"has no escapes, either %\"), None);\n+            assert_eq!(pns(\"*so* has a %% escape\"), Some((S::Escape,\" escape\")));\n+            assert_eq!(pns(\"%% leading escape\"), Some((S::Escape, \" leading escape\")));\n+            assert_eq!(pns(\"trailing escape %%\"), Some((S::Escape, \"\")));\n+        }\n+\n+        #[test]\n+        fn test_parse() {\n+            macro_rules! assert_pns_eq_sub {\n+                ($in_:expr, {\n+                    $param:expr, $flags:expr,\n+                    $width:expr, $prec:expr, $len:expr, $type_:expr,\n+                }) => {\n+                    assert_eq!(\n+                        pns(concat!($in_, \"!\")),\n+                        Some((\n+                            S::Format(F {\n+                                span: $in_,\n+                                parameter: $param,\n+                                flags: $flags,\n+                                width: $width,\n+                                precision: $prec,\n+                                length: $len,\n+                                type_: $type_,\n+                            }),\n+                            \"!\"\n+                        ))\n+                    )\n+                };\n+            }\n+\n+            assert_pns_eq_sub!(\"%!\",\n+                { None, \"\", None, None, None, \"!\", });\n+            assert_pns_eq_sub!(\"%c\",\n+                { None, \"\", None, None, None, \"c\", });\n+            assert_pns_eq_sub!(\"%s\",\n+                { None, \"\", None, None, None, \"s\", });\n+            assert_pns_eq_sub!(\"%06d\",\n+                { None, \"0\", Some(N::Num(6)), None, None, \"d\", });\n+            assert_pns_eq_sub!(\"%4.2f\",\n+                { None, \"\", Some(N::Num(4)), Some(N::Num(2)), None, \"f\", });\n+            assert_pns_eq_sub!(\"%#x\",\n+                { None, \"#\", None, None, None, \"x\", });\n+            assert_pns_eq_sub!(\"%-10s\",\n+                { None, \"-\", Some(N::Num(10)), None, None, \"s\", });\n+            assert_pns_eq_sub!(\"%*s\",\n+                { None, \"\", Some(N::Next), None, None, \"s\", });\n+            assert_pns_eq_sub!(\"%-10.*s\",\n+                { None, \"-\", Some(N::Num(10)), Some(N::Next), None, \"s\", });\n+            assert_pns_eq_sub!(\"%-*.*s\",\n+                { None, \"-\", Some(N::Next), Some(N::Next), None, \"s\", });\n+            assert_pns_eq_sub!(\"%.6i\",\n+                { None, \"\", None, Some(N::Num(6)), None, \"i\", });\n+            assert_pns_eq_sub!(\"%+i\",\n+                { None, \"+\", None, None, None, \"i\", });\n+            assert_pns_eq_sub!(\"%08X\",\n+                { None, \"0\", Some(N::Num(8)), None, None, \"X\", });\n+            assert_pns_eq_sub!(\"%lu\",\n+                { None, \"\", None, None, Some(\"l\"), \"u\", });\n+            assert_pns_eq_sub!(\"%Iu\",\n+                { None, \"\", None, None, Some(\"I\"), \"u\", });\n+            assert_pns_eq_sub!(\"%I32u\",\n+                { None, \"\", None, None, Some(\"I32\"), \"u\", });\n+            assert_pns_eq_sub!(\"%I64u\",\n+                { None, \"\", None, None, Some(\"I64\"), \"u\", });\n+            assert_pns_eq_sub!(\"%'d\",\n+                { None, \"'\", None, None, None, \"d\", });\n+            assert_pns_eq_sub!(\"%10s\",\n+                { None, \"\", Some(N::Num(10)), None, None, \"s\", });\n+            assert_pns_eq_sub!(\"%-10.10s\",\n+                { None, \"-\", Some(N::Num(10)), Some(N::Num(10)), None, \"s\", });\n+            assert_pns_eq_sub!(\"%1$d\",\n+                { Some(1), \"\", None, None, None, \"d\", });\n+            assert_pns_eq_sub!(\"%2$.*3$d\",\n+                { Some(2), \"\", None, Some(N::Arg(3)), None, \"d\", });\n+            assert_pns_eq_sub!(\"%1$*2$.*3$d\",\n+                { Some(1), \"\", Some(N::Arg(2)), Some(N::Arg(3)), None, \"d\", });\n+            assert_pns_eq_sub!(\"%-8ld\",\n+                { None, \"-\", Some(N::Num(8)), None, Some(\"l\"), \"d\", });\n+        }\n+\n+        #[test]\n+        fn test_iter() {\n+            let s = \"The %d'th word %% is: `%.*s` %!\\n\";\n+            let subs: Vec<_> = iter_subs(s).map(|sub| sub.translate()).collect();\n+            assert_eq!(\n+                subs.iter().map(|ms| ms.as_ref().map(|s| &s[..])).collect::<Vec<_>>(),\n+                vec![Some(\"{}\"), None, Some(\"{:.*}\"), None]\n+            );\n+        }\n+\n+        /// Check that the translations are what we expect.\n+        #[test]\n+        fn test_trans() {\n+            assert_eq_pnsat!(\"%c\", Some(\"{}\"));\n+            assert_eq_pnsat!(\"%d\", Some(\"{}\"));\n+            assert_eq_pnsat!(\"%u\", Some(\"{}\"));\n+            assert_eq_pnsat!(\"%x\", Some(\"{:x}\"));\n+            assert_eq_pnsat!(\"%X\", Some(\"{:X}\"));\n+            assert_eq_pnsat!(\"%e\", Some(\"{:e}\"));\n+            assert_eq_pnsat!(\"%E\", Some(\"{:E}\"));\n+            assert_eq_pnsat!(\"%f\", Some(\"{}\"));\n+            assert_eq_pnsat!(\"%g\", Some(\"{:e}\"));\n+            assert_eq_pnsat!(\"%G\", Some(\"{:E}\"));\n+            assert_eq_pnsat!(\"%s\", Some(\"{}\"));\n+            assert_eq_pnsat!(\"%p\", Some(\"{:p}\"));\n+\n+            assert_eq_pnsat!(\"%06d\",        Some(\"{:06}\"));\n+            assert_eq_pnsat!(\"%4.2f\",       Some(\"{:4.2}\"));\n+            assert_eq_pnsat!(\"%#x\",         Some(\"{:#x}\"));\n+            assert_eq_pnsat!(\"%-10s\",       Some(\"{:<10}\"));\n+            assert_eq_pnsat!(\"%*s\",         None);\n+            assert_eq_pnsat!(\"%-10.*s\",     Some(\"{:<10.*}\"));\n+            assert_eq_pnsat!(\"%-*.*s\",      None);\n+            assert_eq_pnsat!(\"%.6i\",        Some(\"{:06}\"));\n+            assert_eq_pnsat!(\"%+i\",         Some(\"{:+}\"));\n+            assert_eq_pnsat!(\"%08X\",        Some(\"{:08X}\"));\n+            assert_eq_pnsat!(\"%lu\",         Some(\"{}\"));\n+            assert_eq_pnsat!(\"%Iu\",         Some(\"{}\"));\n+            assert_eq_pnsat!(\"%I32u\",       Some(\"{}\"));\n+            assert_eq_pnsat!(\"%I64u\",       Some(\"{}\"));\n+            assert_eq_pnsat!(\"%'d\",         None);\n+            assert_eq_pnsat!(\"%10s\",        Some(\"{:>10}\"));\n+            assert_eq_pnsat!(\"%-10.10s\",    Some(\"{:<10.10}\"));\n+            assert_eq_pnsat!(\"%1$d\",        Some(\"{0}\"));\n+            assert_eq_pnsat!(\"%2$.*3$d\",    Some(\"{1:02$}\"));\n+            assert_eq_pnsat!(\"%1$*2$.*3$s\", Some(\"{0:>1$.2$}\"));\n+            assert_eq_pnsat!(\"%-8ld\",       Some(\"{:<8}\"));\n+        }\n+    }\n+}\n+\n+pub mod shell {\n+    use super::strcursor::StrCursor as Cur;\n+\n+    #[derive(Clone, Eq, PartialEq, Debug)]\n+    pub enum Substitution<'a> {\n+        Ordinal(u8),\n+        Name(&'a str),\n+        Escape,\n+    }\n+\n+    impl<'a> Substitution<'a> {\n+        pub fn as_str(&self) -> String {\n+            match *self {\n+                Substitution::Ordinal(n) => format!(\"${}\", n),\n+                Substitution::Name(n) => format!(\"${}\", n),\n+                Substitution::Escape => \"$$\".into(),\n+            }\n+        }\n+\n+        pub fn translate(&self) -> Option<String> {\n+            match *self {\n+                Substitution::Ordinal(n) => Some(format!(\"{{{}}}\", n)),\n+                Substitution::Name(n) => Some(format!(\"{{{}}}\", n)),\n+                Substitution::Escape => None,\n+            }\n+        }\n+    }\n+\n+    /// Returns an iterator over all substitutions in a given string.\n+    pub fn iter_subs(s: &str) -> Substitutions {\n+        Substitutions {\n+            s: s,\n+        }\n+    }\n+\n+    /// Iterator over substitutions in a string.\n+    pub struct Substitutions<'a> {\n+        s: &'a str,\n+    }\n+\n+    impl<'a> Iterator for Substitutions<'a> {\n+        type Item = Substitution<'a>;\n+        fn next(&mut self) -> Option<Self::Item> {\n+            match parse_next_substitution(self.s) {\n+                Some((sub, tail)) => {\n+                    self.s = tail;\n+                    Some(sub)\n+                },\n+                None => None,\n+            }\n+        }\n+    }\n+\n+    /// Parse the next substitution from the input string.\n+    pub fn parse_next_substitution(s: &str) -> Option<(Substitution, &str)> {\n+        let at = {\n+            let start = try_opt!(s.find('$'));\n+            match s[start+1..].chars().next() {\n+                Some('$') => return Some((Substitution::Escape, &s[start+2..])),\n+                Some(c @ '0' ... '9') => {\n+                    let n = (c as u8) - b'0';\n+                    return Some((Substitution::Ordinal(n), &s[start+2..]));\n+                },\n+                Some(_) => {/* fall-through */},\n+                None => return None,\n+            }\n+\n+            Cur::new_at_start(&s[start..])\n+        };\n+\n+        let at = try_opt!(at.at_next_cp());\n+        match at.next_cp() {\n+            Some((c, inner)) => {\n+                if !is_ident_head(c) {\n+                    None\n+                } else {\n+                    let end = at_next_cp_while(inner, is_ident_tail);\n+                    Some((Substitution::Name(at.slice_between(end).unwrap()), end.slice_after()))\n+                }\n+            },\n+            _ => None\n+        }\n+    }\n+\n+    fn at_next_cp_while<F>(mut cur: Cur, mut pred: F) -> Cur\n+    where F: FnMut(char) -> bool {\n+        loop {\n+            match cur.next_cp() {\n+                Some((c, next)) => if pred(c) {\n+                    cur = next;\n+                } else {\n+                    return cur;\n+                },\n+                None => return cur,\n+            }\n+        }\n+    }\n+\n+    fn is_ident_head(c: char) -> bool {\n+        match c {\n+            'a' ... 'z' | 'A' ... 'Z' | '_' => true,\n+            _ => false\n+        }\n+    }\n+\n+    fn is_ident_tail(c: char) -> bool {\n+        match c {\n+            '0' ... '9' => true,\n+            c => is_ident_head(c)\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+        use super::{\n+            Substitution as S,\n+            parse_next_substitution as pns,\n+        };\n+\n+        macro_rules! assert_eq_pnsat {\n+            ($lhs:expr, $rhs:expr) => {\n+                assert_eq!(\n+                    pns($lhs).and_then(|(f, _)| f.translate()),\n+                    $rhs.map(<String as From<&str>>::from)\n+                )\n+            };\n+        }\n+\n+        #[test]\n+        fn test_escape() {\n+            assert_eq!(pns(\"has no escapes\"), None);\n+            assert_eq!(pns(\"has no escapes, either $\"), None);\n+            assert_eq!(pns(\"*so* has a $$ escape\"), Some((S::Escape, \" escape\")));\n+            assert_eq!(pns(\"$$ leading escape\"), Some((S::Escape, \" leading escape\")));\n+            assert_eq!(pns(\"trailing escape $$\"), Some((S::Escape, \"\")));\n+        }\n+\n+        #[test]\n+        fn test_parse() {\n+            macro_rules! assert_pns_eq_sub {\n+                ($in_:expr, $kind:ident($arg:expr)) => {\n+                    assert_eq!(pns(concat!($in_, \"!\")), Some((S::$kind($arg.into()), \"!\")))\n+                };\n+            }\n+\n+            assert_pns_eq_sub!(\"$0\", Ordinal(0));\n+            assert_pns_eq_sub!(\"$1\", Ordinal(1));\n+            assert_pns_eq_sub!(\"$9\", Ordinal(9));\n+            assert_pns_eq_sub!(\"$N\", Name(\"N\"));\n+            assert_pns_eq_sub!(\"$NAME\", Name(\"NAME\"));\n+        }\n+\n+        #[test]\n+        fn test_iter() {\n+            use super::iter_subs;\n+            let s = \"The $0'th word $$ is: `$WORD` $!\\n\";\n+            let subs: Vec<_> = iter_subs(s).map(|sub| sub.translate()).collect();\n+            assert_eq!(\n+                subs.iter().map(|ms| ms.as_ref().map(|s| &s[..])).collect::<Vec<_>>(),\n+                vec![Some(\"{0}\"), None, Some(\"{WORD}\")]\n+            );\n+        }\n+\n+        #[test]\n+        fn test_trans() {\n+            assert_eq_pnsat!(\"$0\", Some(\"{0}\"));\n+            assert_eq_pnsat!(\"$9\", Some(\"{9}\"));\n+            assert_eq_pnsat!(\"$1\", Some(\"{1}\"));\n+            assert_eq_pnsat!(\"$10\", Some(\"{1}\"));\n+            assert_eq_pnsat!(\"$stuff\", Some(\"{stuff}\"));\n+            assert_eq_pnsat!(\"$NAME\", Some(\"{NAME}\"));\n+            assert_eq_pnsat!(\"$PREFIX/bin\", Some(\"{PREFIX}\"));\n+        }\n+\n+    }\n+}\n+\n+mod strcursor {\n+    use std;\n+\n+    pub struct StrCursor<'a> {\n+        s: &'a str,\n+        at: usize,\n+    }\n+\n+    impl<'a> StrCursor<'a> {\n+        pub fn new_at_start(s: &'a str) -> StrCursor<'a> {\n+            StrCursor {\n+                s: s,\n+                at: 0,\n+            }\n+        }\n+\n+        pub fn at_next_cp(mut self) -> Option<StrCursor<'a>> {\n+            match self.try_seek_right_cp() {\n+                true => Some(self),\n+                false => None\n+            }\n+        }\n+\n+        pub fn next_cp(mut self) -> Option<(char, StrCursor<'a>)> {\n+            let cp = match self.cp_after() {\n+                Some(cp) => cp,\n+                None => return None,\n+            };\n+            self.seek_right(cp.len_utf8());\n+            Some((cp, self))\n+        }\n+\n+        fn slice_before(&self) -> &'a str {\n+            &self.s[0..self.at]\n+        }\n+\n+        pub fn slice_after(&self) -> &'a str {\n+            &self.s[self.at..]\n+        }\n+\n+        pub fn slice_between(&self, until: StrCursor<'a>) -> Option<&'a str> {\n+            if !str_eq_literal(self.s, until.s) {\n+                None\n+            } else {\n+                use std::cmp::{max, min};\n+                let beg = min(self.at, until.at);\n+                let end = max(self.at, until.at);\n+                Some(&self.s[beg..end])\n+            }\n+        }\n+\n+        fn cp_after(&self) -> Option<char> {\n+            self.slice_after().chars().next()\n+        }\n+\n+        fn try_seek_right_cp(&mut self) -> bool {\n+            match self.slice_after().chars().next() {\n+                Some(c) => {\n+                    self.at += c.len_utf8();\n+                    true\n+                },\n+                None => false,\n+            }\n+        }\n+\n+        fn seek_right(&mut self, bytes: usize) {\n+            self.at += bytes;\n+        }\n+    }\n+\n+    impl<'a> Copy for StrCursor<'a> {}\n+\n+    impl<'a> Clone for StrCursor<'a> {\n+        fn clone(&self) -> StrCursor<'a> {\n+            *self\n+        }\n+    }\n+\n+    impl<'a> std::fmt::Debug for StrCursor<'a> {\n+        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {\n+            write!(fmt, \"StrCursor({:?} | {:?})\", self.slice_before(), self.slice_after())\n+        }\n+    }\n+\n+    fn str_eq_literal(a: &str, b: &str) -> bool {\n+        a.as_bytes().as_ptr() == b.as_bytes().as_ptr()\n+            && a.len() == b.len()\n+    }\n+}"}, {"sha": "1ebac19b4f029ddab1bddc2199fb90e67371f263", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -40,6 +40,7 @@ mod concat;\n mod concat_idents;\n mod env;\n mod format;\n+mod format_foreign;\n mod log_syntax;\n mod trace_macros;\n "}, {"sha": "a23b4b077410c20dcdd0c45e3a36cf03cfbae29b", "filename": "src/test/compile-fail/ifmt-bad-arg.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -17,6 +17,7 @@ fn main() {\n                             //~^ ERROR: argument never used\n     format!(\"{foo}\");         //~ ERROR: no argument named `foo`\n \n+    format!(\"\", 1, 2);                 //~ ERROR: multiple unused formatting arguments\n     format!(\"{}\", 1, 2);               //~ ERROR: argument never used\n     format!(\"{1}\", 1, 2);              //~ ERROR: argument never used\n     format!(\"{}\", 1, foo=2);           //~ ERROR: named argument never used\n@@ -53,4 +54,6 @@ fn main() {\n \n     format!(\"foo } bar\"); //~ ERROR: unmatched `}` found\n     format!(\"foo }\"); //~ ERROR: unmatched `}` found\n+\n+    format!(\"foo %s baz\", \"bar\"); //~ ERROR: argument never used\n }"}, {"sha": "4323929e2e37a7cc07827fa3cccbde3cb06d72dd", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -49,8 +49,6 @@ struct Baz<'x> {\n \n impl<'a> Baz<'a> {\n     fn baz2<'b>(&self, x: &isize) -> (&'b isize, &'b isize) {\n-        //~^ HELP consider using an explicit lifetime parameter as shown: fn baz2<'b>(&self, x: &'\n-        // FIXME #35038: The above suggestion is different on Linux and Mac.\n         (self.bar, x) //~ ERROR E0312\n         //~^ ERROR E0312\n     }"}, {"sha": "d321df8431b88866ca1382af9ec279d95f7e8fc2", "filename": "src/test/debuginfo/vec-slices.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -21,21 +21,21 @@\n \n // gdb-command:print singleton.length\n // gdb-check:$2 = 1\n-// gdbg-command:print *((int64_t[1]*)(singleton.data_ptr))\n+// gdbg-command:print *((i64[1]*)(singleton.data_ptr))\n // gdbr-command:print *(singleton.data_ptr as &[i64; 1])\n // gdbg-check:$3 = {1}\n // gdbr-check:$3 = [1]\n \n // gdb-command:print multiple.length\n // gdb-check:$4 = 4\n-// gdbg-command:print *((int64_t[4]*)(multiple.data_ptr))\n+// gdbg-command:print *((i64[4]*)(multiple.data_ptr))\n // gdbr-command:print *(multiple.data_ptr as &[i64; 4])\n // gdbg-check:$5 = {2, 3, 4, 5}\n // gdbr-check:$5 = [2, 3, 4, 5]\n \n // gdb-command:print slice_of_slice.length\n // gdb-check:$6 = 2\n-// gdbg-command:print *((int64_t[2]*)(slice_of_slice.data_ptr))\n+// gdbg-command:print *((i64[2]*)(slice_of_slice.data_ptr))\n // gdbr-command:print *(slice_of_slice.data_ptr as &[i64; 2])\n // gdbg-check:$7 = {3, 4}\n // gdbr-check:$7 = [3, 4]\n@@ -61,14 +61,14 @@\n // gdbg-command:print 'vec_slices::MUT_VECT_SLICE'.length\n // gdbr-command:print MUT_VECT_SLICE.length\n // gdb-check:$14 = 2\n-// gdbg-command:print *((int64_t[2]*)('vec_slices::MUT_VECT_SLICE'.data_ptr))\n+// gdbg-command:print *((i64[2]*)('vec_slices::MUT_VECT_SLICE'.data_ptr))\n // gdbr-command:print *(MUT_VECT_SLICE.data_ptr as &[i64; 2])\n // gdbg-check:$15 = {64, 65}\n // gdbr-check:$15 = [64, 65]\n \n //gdb-command:print mut_slice.length\n //gdb-check:$16 = 5\n-//gdbg-command:print *((int64_t[5]*)(mut_slice.data_ptr))\n+//gdbg-command:print *((i64[5]*)(mut_slice.data_ptr))\n //gdbr-command:print *(mut_slice.data_ptr as &[i64; 5])\n //gdbg-check:$17 = {1, 2, 3, 4, 5}\n //gdbr-check:$17 = [1, 2, 3, 4, 5]"}, {"sha": "d2030d935546272b1b8281e5468bf760ef4ac828", "filename": "src/test/incremental/hashes/call_expressions.rs", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,203 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for function and method call expressions.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+fn callee1(_x: u32, _y: i64) {}\n+fn callee2(_x: u32, _y: i64) {}\n+\n+\n+// Change Callee (Function) ----------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_callee_function() {\n+    callee1(1, 2)\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_callee_function() {\n+    callee2(1, 2)\n+}\n+\n+\n+\n+// Change Argument (Function) --------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_argument_function() {\n+    callee1(1, 2)\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_argument_function() {\n+    callee1(1, 3)\n+}\n+\n+\n+\n+// Change Callee Indirectly (Function) -----------------------------------------\n+mod change_callee_indirectly_function {\n+    #[cfg(cfail1)]\n+    use super::callee1 as callee;\n+    #[cfg(not(cfail1))]\n+    use super::callee2 as callee;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn change_callee_indirectly_function() {\n+        callee(1, 2)\n+    }\n+}\n+\n+\n+struct Struct;\n+impl Struct {\n+    fn method1(&self, _x: char, _y: bool) {}\n+    fn method2(&self, _x: char, _y: bool) {}\n+}\n+\n+// Change Callee (Method) ------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_callee_method() {\n+    let s = Struct;\n+    s.method1('x', true);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_callee_method() {\n+    let s = Struct;\n+    s.method2('x', true);\n+}\n+\n+\n+\n+// Change Argument (Method) ----------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_argument_method() {\n+    let s = Struct;\n+    s.method1('x', true);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_argument_method() {\n+    let s = Struct;\n+    s.method1('y', true);\n+}\n+\n+\n+\n+// Change Callee (Method, UFCS) ------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_ufcs_callee_method() {\n+    let s = Struct;\n+    Struct::method1(&s, 'x', true);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_ufcs_callee_method() {\n+    let s = Struct;\n+    Struct::method2(&s, 'x', true);\n+}\n+\n+\n+\n+// Change Argument (Method, UFCS) ----------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_argument_method_ufcs() {\n+    let s = Struct;\n+    Struct::method1(&s, 'x', true);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_argument_method_ufcs() {\n+    let s = Struct;\n+    Struct::method1(&s, 'x', false);\n+}\n+\n+\n+\n+// Change To UFCS --------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_to_ufcs() {\n+    let s = Struct;\n+    s.method1('x', true);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_to_ufcs() {\n+    let s = Struct;\n+    Struct::method1(&s, 'x', true);\n+}\n+\n+\n+struct Struct2;\n+impl Struct2 {\n+    fn method1(&self, _x: char, _y: bool) {}\n+}\n+\n+// Change UFCS Callee Indirectly -----------------------------------------------\n+mod change_ufcs_callee_indirectly {\n+    #[cfg(cfail1)]\n+    use super::Struct as Struct;\n+    #[cfg(not(cfail1))]\n+    use super::Struct2 as Struct;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn change_ufcs_callee_indirectly() {\n+        let s = Struct;\n+        Struct::method1(&s, 'q', false)\n+    }\n+}"}, {"sha": "ba6289f754edef95404680a3fa27ad4717b63cef", "filename": "src/test/incremental/hashes/if_expressions.rs", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,232 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for if expressions.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+// Change condition (if) -------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_condition(x: bool) -> u32 {\n+    if x {\n+        return 1\n+    }\n+\n+    return 0\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_condition(x: bool) -> u32 {\n+    if !x {\n+        return 1\n+    }\n+\n+    return 0\n+}\n+\n+// Change then branch (if) -----------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_then_branch(x: bool) -> u32 {\n+    if x {\n+        return 1\n+    }\n+\n+    return 0\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_then_branch(x: bool) -> u32 {\n+    if x {\n+        return 2\n+    }\n+\n+    return 0\n+}\n+\n+\n+\n+// Change else branch (if) -----------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_else_branch(x: bool) -> u32 {\n+    if x {\n+        1\n+    } else {\n+        2\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_else_branch(x: bool) -> u32 {\n+    if x {\n+        1\n+    } else {\n+        3\n+    }\n+}\n+\n+\n+\n+// Add else branch (if) --------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn add_else_branch(x: bool) -> u32 {\n+    let mut ret = 1;\n+\n+    if x {\n+        ret += 1;\n+    }\n+\n+    ret\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn add_else_branch(x: bool) -> u32 {\n+    let mut ret = 1;\n+\n+    if x {\n+        ret += 1;\n+    } else {\n+    }\n+\n+    ret\n+}\n+\n+\n+\n+// Change condition (if let) ---------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_condition_if_let(x: Option<u32>) -> u32 {\n+    if let Some(_x) = x {\n+        return 1\n+    }\n+\n+    0\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_condition_if_let(x: Option<u32>) -> u32 {\n+    if let Some(_) = x {\n+        return 1\n+    }\n+\n+    0\n+}\n+\n+\n+\n+// Change then branch (if let) -------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_then_branch_if_let(x: Option<u32>) -> u32 {\n+    if let Some(x) = x {\n+        return x\n+    }\n+\n+    0\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_then_branch_if_let(x: Option<u32>) -> u32 {\n+    if let Some(x) = x {\n+        return x + 1\n+    }\n+\n+    0\n+}\n+\n+\n+\n+// Change else branch (if let) -------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_else_branch_if_let(x: Option<u32>) -> u32 {\n+    if let Some(x) = x {\n+        x\n+    } else {\n+        1\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_else_branch_if_let(x: Option<u32>) -> u32 {\n+    if let Some(x) = x {\n+        x\n+    } else {\n+        2\n+    }\n+}\n+\n+\n+\n+// Add else branch (if let) ----------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn add_else_branch_if_let(x: Option<u32>) -> u32 {\n+    let mut ret = 1;\n+\n+    if let Some(x) = x {\n+        ret += x;\n+    }\n+\n+    ret\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn add_else_branch_if_let(x: Option<u32>) -> u32 {\n+    let mut ret = 1;\n+\n+    if let Some(x) = x {\n+        ret += x;\n+    } else {\n+    }\n+\n+    ret\n+}"}, {"sha": "d229bcacc501ab3631741a21ed3dae65b27a0fc7", "filename": "src/test/run-pass/issue-37655.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Frun-pass%2Fissue-37655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Frun-pass%2Fissue-37655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-37655.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #37655. The problem was a false edge created by\n+// coercion that wound up requiring that `'a` (in `split()`) outlive\n+// `'b`, which shouldn't be necessary.\n+\n+#![allow(warnings)]\n+\n+trait SliceExt<T> {\n+    type Item;\n+\n+    fn get_me<I>(&self, index: I) -> &I::Output\n+        where I: SliceIndex<Self::Item>;\n+}\n+\n+impl<T> SliceExt<T> for [T] {\n+    type Item = T;\n+\n+    fn get_me<I>(&self, index: I) -> &I::Output\n+        where I: SliceIndex<T>\n+    {\n+        panic!()\n+    }\n+}\n+\n+pub trait SliceIndex<T> {\n+    type Output: ?Sized;\n+}\n+\n+impl<T> SliceIndex<T> for usize {\n+    type Output = T;\n+}\n+\n+fn foo<'a, 'b>(split: &'b [&'a [u8]]) -> &'a [u8] {\n+    split.get_me(0)\n+}\n+\n+fn main() { }"}, {"sha": "a1eabb515a5ce28cd9c7214fe4943fcf8a2d7d2e", "filename": "src/test/rustdoc/line-breaks.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Frustdoc%2Fline-breaks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Frustdoc%2Fline-breaks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fline-breaks.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -10,6 +10,9 @@\n \n #![crate_name = \"foo\"]\n \n+use std::ops::Add;\n+use std::fmt::Display;\n+\n //@count foo/fn.function_with_a_really_long_name.html //pre/br 2\n pub fn function_with_a_really_long_name(parameter_one: i32,\n                                         parameter_two: i32)\n@@ -19,3 +22,19 @@ pub fn function_with_a_really_long_name(parameter_one: i32,\n \n //@count foo/fn.short_name.html //pre/br 0\n pub fn short_name(param: i32) -> i32 { param + 1 }\n+\n+//@count foo/fn.where_clause.html //pre/br 4\n+pub fn where_clause<T, U>(param_one: T,\n+                          param_two: U)\n+    where T: Add<U> + Display + Copy,\n+          U: Add<T> + Display + Copy,\n+          T::Output: Display + Add<U::Output> + Copy,\n+          <T::Output as Add<U::Output>>::Output: Display,\n+          U::Output: Display + Copy\n+{\n+    let x = param_one + param_two;\n+    println!(\"{} + {} = {}\", param_one, param_two, x);\n+    let y = param_two + param_one;\n+    println!(\"{} + {} = {}\", param_two, param_one, y);\n+    println!(\"{} + {} = {}\", x, y, x + y);\n+}"}, {"sha": "ec715b3f0ba62f9e618ead0a00b5a00ebdd00e3d", "filename": "src/test/ui/fmt/format-string-error.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    println!(\"{\");\n+    println!(\"{{}}\");\n+    println!(\"}\");\n+}\n+"}, {"sha": "58b392f0b8d658fc1df9896a3568b05b9338bf23", "filename": "src/test/ui/fmt/format-string-error.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.stderr?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,20 @@\n+error: invalid format string: expected `'}'` but string was terminated\n+  --> $DIR/format-string-error.rs:12:5\n+   |\n+12 |     println!(\"{\");\n+   |     ^^^^^^^^^^^^^^\n+   |\n+   = note: if you intended to print `{`, you can escape it using `{{`\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: invalid format string: unmatched `}` found\n+  --> $DIR/format-string-error.rs:14:5\n+   |\n+14 |     println!(\"}\");\n+   |     ^^^^^^^^^^^^^^\n+   |\n+   = note: if you intended to print `}`, you can escape it using `}}`\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "603f55af465f47f8c6b23f6592659a79b02a2c15", "filename": "src/test/ui/lifetimes/consider-using-explicit-lifetime.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fui%2Flifetimes%2Fconsider-using-explicit-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fui%2Flifetimes%2Fconsider-using-explicit-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fconsider-using-explicit-lifetime.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::str::FromStr;\n+\n+pub struct Foo<'a> {\n+    field: &'a str,\n+}\n+\n+impl<'a> Foo<'a> {\n+    fn bar(path: &str) -> Result<Self, ()> {\n+        Ok(Foo { field: path })\n+    }\n+}\n+\n+impl<'a> FromStr for Foo<'a> {\n+    type Err = ();\n+    fn from_str(path: &str) -> Result<Self, ()> {\n+        Ok(Foo { field: path })\n+    }\n+}"}, {"sha": "353e251369a10092e3b54fb3895025f33927f847", "filename": "src/test/ui/lifetimes/consider-using-explicit-lifetime.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fui%2Flifetimes%2Fconsider-using-explicit-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fui%2Flifetimes%2Fconsider-using-explicit-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fconsider-using-explicit-lifetime.stderr?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,22 @@\n+error: main function not found\n+\n+error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n+  --> $DIR/consider-using-explicit-lifetime.rs:19:12\n+   |\n+19 |         Ok(Foo { field: path })\n+   |            ^^^\n+\n+error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n+  --> $DIR/consider-using-explicit-lifetime.rs:26:12\n+   |\n+26 |         Ok(Foo { field: path })\n+   |            ^^^\n+   |\n+help: consider using an explicit lifetime parameter as shown: fn from_str(path: &'a str) -> Result<Self, ()>\n+  --> $DIR/consider-using-explicit-lifetime.rs:25:5\n+   |\n+25 |     fn from_str(path: &str) -> Result<Self, ()> {\n+   |     ^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "cca45ca9ecdd9fe6a4f62005995269e93f0d116b", "filename": "src/test/ui/macros/format-foreign.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.rs?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    println!(\"%.*3$s %s!\\n\", \"Hello,\", \"World\", 4);\n+    println!(\"%1$*2$.*3$f\", 123.456);\n+\n+    // This should *not* produce hints, on the basis that there's equally as\n+    // many \"correct\" format specifiers.  It's *probably* just an actual typo.\n+    println!(\"{} %f\", \"one\", 2.0);\n+\n+    println!(\"Hi there, $NAME.\", NAME=\"Tim\");\n+}"}, {"sha": "0283052a89f53d19a128cd8cb4836f7dbae769c2", "filename": "src/test/ui/macros/format-foreign.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3af8c8505255555023e4cb7c6c4f297ce22d80d/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.stderr?ref=f3af8c8505255555023e4cb7c6c4f297ce22d80d", "patch": "@@ -0,0 +1,52 @@\n+error: multiple unused formatting arguments\n+  --> $DIR/format-foreign.rs:12:5\n+   |\n+12 |     println!(\"%.*3$s %s!/n\", \"Hello,\", \"World\", 4);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: argument never used\n+  --> $DIR/format-foreign.rs:12:30\n+   |\n+12 |     println!(\"%.*3$s %s!/n\", \"Hello,\", \"World\", 4);\n+   |                              ^^^^^^^^\n+note: argument never used\n+  --> $DIR/format-foreign.rs:12:40\n+   |\n+12 |     println!(\"%.*3$s %s!/n\", \"Hello,\", \"World\", 4);\n+   |                                        ^^^^^^^\n+note: argument never used\n+  --> $DIR/format-foreign.rs:12:49\n+   |\n+12 |     println!(\"%.*3$s %s!/n\", \"Hello,\", \"World\", 4);\n+   |                                                 ^\n+   = help: `%.*3$s` should be written as `{:.2$}`\n+   = help: `%s` should be written as `{}`\n+   = note: printf formatting not supported; see the documentation for `std::fmt`\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: argument never used\n+  --> $DIR/format-foreign.rs:13:29\n+   |\n+13 |     println!(\"%1$*2$.*3$f\", 123.456);\n+   |                             ^^^^^^^\n+   |\n+   = help: `%1$*2$.*3$f` should be written as `{0:1$.2$}`\n+   = note: printf formatting not supported; see the documentation for `std::fmt`\n+\n+error: argument never used\n+  --> $DIR/format-foreign.rs:17:30\n+   |\n+17 |     println!(\"{} %f\", \"one\", 2.0);\n+   |                              ^^^\n+\n+error: named argument never used\n+  --> $DIR/format-foreign.rs:19:39\n+   |\n+19 |     println!(\"Hi there, $NAME.\", NAME=\"Tim\");\n+   |                                       ^^^^^\n+   |\n+   = help: `$NAME` should be written as `{NAME}`\n+   = note: shell formatting not supported; see the documentation for `std::fmt`\n+\n+error: aborting due to 4 previous errors\n+"}]}