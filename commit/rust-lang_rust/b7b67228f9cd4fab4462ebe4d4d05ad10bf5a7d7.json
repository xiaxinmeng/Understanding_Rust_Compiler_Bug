{"sha": "b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7", "node_id": "C_kwDOAAsO6NoAKGI3YjY3MjI4ZjljZDRmYWI0NDYyZWJlNGQ0ZDA1YWQxMGJmNWE3ZDc", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-11-12T21:12:33Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-11-15T18:34:35Z"}, "message": "Only do parser recovery on retried macro matching\n\nThis prevents issues with eager parser recovery during macro matching.", "tree": {"sha": "11b3b6e74f943da09e0badaf729022b8cd6a3485", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11b3b6e74f943da09e0badaf729022b8cd6a3485"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN SSH SIGNATURE-----\nU1NIU0lHAAAAAQAAADMAAAALc3NoLWVkMjU1MTkAAAAgbSfWKRQb2tiqhuHtakDJeupmrF\nChDbM0msU+PXaBOk8AAAADZ2l0AAAAAAAAAAZzaGE1MTIAAABTAAAAC3NzaC1lZDI1NTE5\nAAAAQDuDUfzCAXTBg7JDfULYfO3GopesOdW76z1E9q+inrMnmaCGTmcWehZshiGYTv48Ns\nMjt01I7VzBV5LBgXoJswo=\n-----END SSH SIGNATURE-----", "payload": "tree 11b3b6e74f943da09e0badaf729022b8cd6a3485\nparent 6d651a295e0e0c331153288b10b78344a4ede20b\nauthor Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1668287553 +0100\ncommitter Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1668537275 +0100\n\nOnly do parser recovery on retried macro matching\n\nThis prevents issues with eager parser recovery during macro matching.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7", "html_url": "https://github.com/rust-lang/rust/commit/b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d651a295e0e0c331153288b10b78344a4ede20b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d651a295e0e0c331153288b10b78344a4ede20b", "html_url": "https://github.com/rust-lang/rust/commit/6d651a295e0e0c331153288b10b78344a4ede20b"}], "stats": {"total": 70, "additions": 60, "deletions": 10}, "files": [{"sha": "c02680b77fb152e5cd6bc9f2c5d15be21e9ada66", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7", "patch": "@@ -22,7 +22,7 @@ use rustc_lint_defs::builtin::{\n     RUST_2021_INCOMPATIBLE_OR_PATTERNS, SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n };\n use rustc_lint_defs::BuiltinLintDiagnostics;\n-use rustc_parse::parser::Parser;\n+use rustc_parse::parser::{Parser, Recovery};\n use rustc_session::parse::ParseSess;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n@@ -219,6 +219,8 @@ pub(super) trait Tracker<'matcher> {\n \n     /// For tracing.\n     fn description() -> &'static str;\n+\n+    fn recovery() -> Recovery;\n }\n \n /// A noop tracker that is used in the hot path of the expansion, has zero overhead thanks to monomorphization.\n@@ -230,6 +232,9 @@ impl<'matcher> Tracker<'matcher> for NoopTracker {\n     fn description() -> &'static str {\n         \"none\"\n     }\n+    fn recovery() -> Recovery {\n+        Recovery::Forbidden\n+    }\n }\n \n /// Expands the rules based macro defined by `lhses` and `rhses` for a given\n@@ -330,15 +335,20 @@ fn expand_macro<'cx>(\n     let mut tracker = CollectTrackerAndEmitter::new(cx, sp);\n \n     let try_success_result = try_match_macro(sess, name, &arg, lhses, &mut tracker);\n-    assert!(try_success_result.is_err(), \"Macro matching returned a success on the second try\");\n+\n+    if try_success_result.is_ok() {\n+        // Nonterminal parser recovery might turn failed matches into successful ones,\n+        // but for that it must have emitted an error already\n+        tracker.cx.sess.delay_span_bug(sp, \"Macro matching returned a success on the second try\");\n+    }\n \n     if let Some(result) = tracker.result {\n         // An irrecoverable error occurred and has been emitted.\n         return result;\n     }\n \n     let Some((token, label, remaining_matcher)) = tracker.best_failure else {\n-        return tracker.result.expect(\"must have encountered Error or ErrorReported\");\n+        return DummyResult::any(sp);\n     };\n \n     let span = token.span.substitute_dummy(sp);\n@@ -360,7 +370,7 @@ fn expand_macro<'cx>(\n     // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n     if let Some((arg, comma_span)) = arg.add_comma() {\n         for lhs in lhses {\n-            let parser = parser_from_cx(sess, arg.clone());\n+            let parser = parser_from_cx(sess, arg.clone(), Recovery::Allowed);\n             let mut tt_parser = TtParser::new(name);\n \n             if let Success(_) =\n@@ -406,7 +416,12 @@ impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx,\n     fn after_arm(&mut self, result: &NamedParseResult) {\n         match result {\n             Success(_) => {\n-                unreachable!(\"should not collect detailed info for successful macro match\");\n+                // Nonterminal parser recovery might turn failed matches into successful ones,\n+                // but for that it must have emitted an error already\n+                self.cx.sess.delay_span_bug(\n+                    self.root_span,\n+                    \"should not collect detailed info for successful macro match\",\n+                );\n             }\n             Failure(token, msg) => match self.best_failure {\n                 Some((ref best_token, _, _)) if best_token.span.lo() >= token.span.lo() => {}\n@@ -432,6 +447,10 @@ impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx,\n     fn description() -> &'static str {\n         \"detailed\"\n     }\n+\n+    fn recovery() -> Recovery {\n+        Recovery::Allowed\n+    }\n }\n \n impl<'a, 'cx> CollectTrackerAndEmitter<'a, 'cx, '_> {\n@@ -477,7 +496,7 @@ fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n     // 68836 suggests a more comprehensive but more complex change to deal with\n     // this situation.)\n     // FIXME(Nilstrieb): Stop recovery from happening on this parser and retry later with recovery if the macro failed to match.\n-    let parser = parser_from_cx(sess, arg.clone());\n+    let parser = parser_from_cx(sess, arg.clone(), T::recovery());\n     // Try each arm's matchers.\n     let mut tt_parser = TtParser::new(name);\n     for (i, lhs) in lhses.iter().enumerate() {\n@@ -1559,8 +1578,8 @@ fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     }\n }\n \n-fn parser_from_cx(sess: &ParseSess, tts: TokenStream) -> Parser<'_> {\n-    Parser::new(sess, tts, true, rustc_parse::MACRO_ARGUMENTS)\n+fn parser_from_cx(sess: &ParseSess, tts: TokenStream, recovery: Recovery) -> Parser<'_> {\n+    Parser::new(sess, tts, true, rustc_parse::MACRO_ARGUMENTS).recovery(recovery)\n }\n \n /// Generates an appropriate parsing failure message. For EOF, this is \"unexpected end...\". For"}, {"sha": "13a38a177350997163d239054901904eb73001b3", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7", "patch": "@@ -503,8 +503,8 @@ impl<'a> Parser<'a> {\n         parser\n     }\n \n-    pub fn forbid_recovery(mut self) -> Self {\n-        self.recovery = Recovery::Forbidden;\n+    pub fn recovery(mut self, recovery: Recovery) -> Self {\n+        self.recovery = recovery;\n         self\n     }\n "}, {"sha": "ebf65f1cc01e693a5bdad81efdc35da0aa24c6a1", "filename": "src/test/ui/macros/recovery-allowed.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7/src%2Ftest%2Fui%2Fmacros%2Frecovery-allowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7/src%2Ftest%2Fui%2Fmacros%2Frecovery-allowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frecovery-allowed.rs?ref=b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7", "patch": "@@ -0,0 +1,8 @@\n+macro_rules! please_recover {\n+    ($a:expr) => {};\n+}\n+\n+please_recover! { not 1 }\n+//~^ ERROR unexpected `1` after identifier\n+\n+fn main() {}"}, {"sha": "ec036e8b1e24bcfba928bc94c467c97a3b5d359f", "filename": "src/test/ui/macros/recovery-allowed.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7/src%2Ftest%2Fui%2Fmacros%2Frecovery-allowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7/src%2Ftest%2Fui%2Fmacros%2Frecovery-allowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frecovery-allowed.stderr?ref=b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7", "patch": "@@ -0,0 +1,10 @@\n+error: unexpected `1` after identifier\n+  --> $DIR/recovery-allowed.rs:5:23\n+   |\n+LL | please_recover! { not 1 }\n+   |                   ----^\n+   |                   |\n+   |                   help: use `!` to perform bitwise not\n+\n+error: aborting due to previous error\n+"}, {"sha": "5dd2619330c4afb9e2d943a3f9ac6d2f6ac3200e", "filename": "src/test/ui/macros/recovery-forbidden.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7/src%2Ftest%2Fui%2Fmacros%2Frecovery-forbidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7/src%2Ftest%2Fui%2Fmacros%2Frecovery-forbidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frecovery-forbidden.rs?ref=b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+macro_rules! dont_recover_here {\n+    ($e:expr) => {\n+        compile_error!(\"Must not recover to single !1 expr\");\n+    };\n+\n+    (not $a:literal) => {};\n+}\n+\n+dont_recover_here! { not 1 }\n+\n+fn main() {}"}]}