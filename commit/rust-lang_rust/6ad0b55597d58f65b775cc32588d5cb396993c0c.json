{"sha": "6ad0b55597d58f65b775cc32588d5cb396993c0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZDBiNTU1OTdkNThmNjViNzc1Y2MzMjU4OGQ1Y2IzOTY5OTNjMGM=", "commit": {"author": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2019-12-15T17:17:00Z"}, "committer": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2019-12-15T17:17:00Z"}, "message": "Remove now-redundant range check on u128 -> f32 casts\n\nThis code was added to avoid UB in LLVM 6 and earlier, but we no longer support those LLVM versions.\nSince https://reviews.llvm.org/D47807 (released in LLVM 7), uitofp does exactly what we need.\n\nCloses #51872", "tree": {"sha": "cfbd95786ba48a5169396390d4816b8094780286", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfbd95786ba48a5169396390d4816b8094780286"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ad0b55597d58f65b775cc32588d5cb396993c0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ad0b55597d58f65b775cc32588d5cb396993c0c", "html_url": "https://github.com/rust-lang/rust/commit/6ad0b55597d58f65b775cc32588d5cb396993c0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ad0b55597d58f65b775cc32588d5cb396993c0c/comments", "author": null, "committer": null, "parents": [{"sha": "a605441e049f0b6d5f7715b94b8ac4662fd7fcf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a605441e049f0b6d5f7715b94b8ac4662fd7fcf6", "html_url": "https://github.com/rust-lang/rust/commit/a605441e049f0b6d5f7715b94b8ac4662fd7fcf6"}], "stats": {"total": 43, "additions": 7, "deletions": 36}, "files": [{"sha": "55d63f18cd906a7711940d1005a1d581b40bdc91", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 7, "deletions": 36, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6ad0b55597d58f65b775cc32588d5cb396993c0c/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad0b55597d58f65b775cc32588d5cb396993c0c/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=6ad0b55597d58f65b775cc32588d5cb396993c0c", "patch": "@@ -341,6 +341,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     llval\n                                 }\n                             }\n+                            (CastTy::Int(_), CastTy::Float) => {\n+                                if signed {\n+                                    bx.sitofp(llval, ll_t_out)\n+                                } else {\n+                                    bx.uitofp(llval, ll_t_out)\n+                                }\n+                            }\n                             (CastTy::Ptr(_), CastTy::Ptr(_)) |\n                             (CastTy::FnPtr, CastTy::Ptr(_)) |\n                             (CastTy::RPtr(_), CastTy::Ptr(_)) =>\n@@ -352,8 +359,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 let usize_llval = bx.intcast(llval, bx.cx().type_isize(), signed);\n                                 bx.inttoptr(usize_llval, ll_t_out)\n                             }\n-                            (CastTy::Int(_), CastTy::Float) =>\n-                                cast_int_to_float(&mut bx, signed, llval, ll_t_in, ll_t_out),\n                             (CastTy::Float, CastTy::Int(IntTy::I)) =>\n                                 cast_float_to_int(&mut bx, true, llval, ll_t_in, ll_t_out),\n                             (CastTy::Float, CastTy::Int(_)) =>\n@@ -720,40 +725,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     }\n }\n \n-fn cast_int_to_float<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &mut Bx,\n-    signed: bool,\n-    x: Bx::Value,\n-    int_ty: Bx::Type,\n-    float_ty: Bx::Type\n-) -> Bx::Value {\n-    // Most integer types, even i128, fit into [-f32::MAX, f32::MAX] after rounding.\n-    // It's only u128 -> f32 that can cause overflows (i.e., should yield infinity).\n-    // LLVM's uitofp produces undef in those cases, so we manually check for that case.\n-    let is_u128_to_f32 = !signed &&\n-        bx.cx().int_width(int_ty) == 128 &&\n-        bx.cx().float_width(float_ty) == 32;\n-    if is_u128_to_f32 {\n-        // All inputs greater or equal to (f32::MAX + 0.5 ULP) are rounded to infinity,\n-        // and for everything else LLVM's uitofp works just fine.\n-        use rustc_apfloat::ieee::Single;\n-        const MAX_F32_PLUS_HALF_ULP: u128 = ((1 << (Single::PRECISION + 1)) - 1)\n-                                            << (Single::MAX_EXP - Single::PRECISION as i16);\n-        let max = bx.cx().const_uint_big(int_ty, MAX_F32_PLUS_HALF_ULP);\n-        let overflow = bx.icmp(IntPredicate::IntUGE, x, max);\n-        let infinity_bits = bx.cx().const_u32(ieee::Single::INFINITY.to_bits() as u32);\n-        let infinity = bx.bitcast(infinity_bits, float_ty);\n-        let fp = bx.uitofp(x, float_ty);\n-        bx.select(overflow, infinity, fp)\n-    } else {\n-        if signed {\n-            bx.sitofp(x, float_ty)\n-        } else {\n-            bx.uitofp(x, float_ty)\n-        }\n-    }\n-}\n-\n fn cast_float_to_int<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     signed: bool,"}]}