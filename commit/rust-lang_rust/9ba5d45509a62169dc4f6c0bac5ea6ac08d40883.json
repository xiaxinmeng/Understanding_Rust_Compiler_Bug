{"sha": "9ba5d45509a62169dc4f6c0bac5ea6ac08d40883", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYTVkNDU1MDlhNjIxNjlkYzRmNmMwYmFjNWVhNmFjMDhkNDA4ODM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-02-07T12:10:48Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-02-07T12:10:48Z"}, "message": "Merge branch 'pr-581'\n\nConflicts:\n\tREADME.md", "tree": {"sha": "130609ef5bcde5f1ff5872cb68355d46686793e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/130609ef5bcde5f1ff5872cb68355d46686793e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883", "html_url": "https://github.com/rust-lang/rust/commit/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5105f566782bf5149f9c3e28b55a1b05305d451", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5105f566782bf5149f9c3e28b55a1b05305d451", "html_url": "https://github.com/rust-lang/rust/commit/b5105f566782bf5149f9c3e28b55a1b05305d451"}, {"sha": "af07ccc16cbf9a736a5aba2759f296242636fecc", "url": "https://api.github.com/repos/rust-lang/rust/commits/af07ccc16cbf9a736a5aba2759f296242636fecc", "html_url": "https://github.com/rust-lang/rust/commit/af07ccc16cbf9a736a5aba2759f296242636fecc"}], "stats": {"total": 261, "additions": 157, "deletions": 104}, "files": [{"sha": "20aaa03c51c10294c582a96acd2a375b37380bf2", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=9ba5d45509a62169dc4f6c0bac5ea6ac08d40883", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 113 lints included in this crate:\n+There are 114 lints included in this crate:\n \n name                                                                                                           | default | meaning\n ---------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -34,6 +34,7 @@ name\n [drop_ref](https://github.com/Manishearth/rust-clippy/wiki#drop_ref)                                           | warn    | call to `std::mem::drop` with a reference instead of an owned value, which will not call the `Drop::drop` method on the underlying value\n [duplicate_underscore_argument](https://github.com/Manishearth/rust-clippy/wiki#duplicate_underscore_argument) | warn    | Function arguments having names which only differ by an underscore\n [empty_loop](https://github.com/Manishearth/rust-clippy/wiki#empty_loop)                                       | warn    | empty `loop {}` detected\n+[enum_glob_use](https://github.com/Manishearth/rust-clippy/wiki#enum_glob_use)                                 | allow   | finds use items that import all variants of an enum\n [enum_variant_names](https://github.com/Manishearth/rust-clippy/wiki#enum_variant_names)                       | warn    | finds enums where all variants share a prefix/postfix\n [eq_op](https://github.com/Manishearth/rust-clippy/wiki#eq_op)                                                 | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\n [expl_impl_clone_on_copy](https://github.com/Manishearth/rust-clippy/wiki#expl_impl_clone_on_copy)             | warn    | implementing `Clone` explicitly on `Copy` types"}, {"sha": "d18785ab81859cdd56f150ecf7afdd1ec099641c", "filename": "src/approx_const.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fapprox_const.rs?ref=9ba5d45509a62169dc4f6c0bac5ea6ac08d40883", "patch": "@@ -2,9 +2,7 @@ use rustc::lint::*;\n use rustc_front::hir::*;\n use std::f64::consts as f64;\n use utils::span_lint;\n-use syntax::ast::Lit_::*;\n-use syntax::ast::Lit;\n-use syntax::ast::FloatTy::*;\n+use syntax::ast::{Lit, Lit_, FloatTy};\n \n /// **What it does:** This lint checks for floating point literals that approximate constants which are defined in [`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants) or [`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants), respectively, suggesting to use the predefined constant.\n ///\n@@ -57,9 +55,9 @@ impl LateLintPass for ApproxConstant {\n \n fn check_lit(cx: &LateContext, lit: &Lit, e: &Expr) {\n     match lit.node {\n-        LitFloat(ref s, TyF32) => check_known_consts(cx, e, s, \"f32\"),\n-        LitFloat(ref s, TyF64) => check_known_consts(cx, e, s, \"f64\"),\n-        LitFloatUnsuffixed(ref s) => check_known_consts(cx, e, s, \"f{32, 64}\"),\n+        Lit_::LitFloat(ref s, FloatTy::TyF32) => check_known_consts(cx, e, s, \"f32\"),\n+        Lit_::LitFloat(ref s, FloatTy::TyF64) => check_known_consts(cx, e, s, \"f64\"),\n+        Lit_::LitFloatUnsuffixed(ref s) => check_known_consts(cx, e, s, \"f{32, 64}\"),\n         _ => (),\n     }\n }"}, {"sha": "6de00167571b37868bd3055a7930a39e299e8352", "filename": "src/bit_mask.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=9ba5d45509a62169dc4f6c0bac5ea6ac08d40883", "patch": "@@ -4,7 +4,7 @@ use rustc::middle::def::{Def, PathResolution};\n use rustc_front::hir::*;\n use rustc_front::util::is_comparison_binop;\n use syntax::codemap::Span;\n-use syntax::ast::Lit_::*;\n+use syntax::ast::Lit_;\n \n use utils::span_lint;\n \n@@ -254,7 +254,7 @@ fn check_ineffective_gt(cx: &LateContext, span: Span, m: u64, c: u64, op: &str)\n fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u64> {\n     match lit.node {\n         ExprLit(ref lit_ptr) => {\n-            if let LitInt(value, _) = lit_ptr.node {\n+            if let Lit_::LitInt(value, _) = lit_ptr.node {\n                 Some(value) //TODO: Handle sign\n             } else {\n                 None"}, {"sha": "5f40aff92cce5a40423568b16ce6400ba6dfe3c7", "filename": "src/consts.rs", "status": "modified", "additions": 42, "deletions": 68, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=9ba5d45509a62169dc4f6c0bac5ea6ac08d40883", "patch": "@@ -12,14 +12,10 @@ use std::cmp::Ordering::{self, Greater, Less, Equal};\n use std::rc::Rc;\n use std::ops::Deref;\n use std::fmt;\n-use self::FloatWidth::*;\n \n-use syntax::ast::Lit_::*;\n use syntax::ast::Lit_;\n-use syntax::ast::LitIntType::*;\n use syntax::ast::LitIntType;\n use syntax::ast::{UintTy, FloatTy, StrStyle};\n-use syntax::ast::FloatTy::*;\n use syntax::ast::Sign::{self, Plus, Minus};\n \n \n@@ -33,8 +29,8 @@ pub enum FloatWidth {\n impl From<FloatTy> for FloatWidth {\n     fn from(ty: FloatTy) -> FloatWidth {\n         match ty {\n-            TyF32 => Fw32,\n-            TyF64 => Fw64,\n+            FloatTy::TyF32 => FloatWidth::Fw32,\n+            FloatTy::TyF64 => FloatWidth::Fw64,\n         }\n     }\n }\n@@ -107,6 +103,7 @@ impl PartialEq for Constant {\n                 lv == rv && (is_negative(lty) & (lv != 0)) == (is_negative(rty) & (rv != 0))\n             }\n             (&Constant::Float(ref ls, lw), &Constant::Float(ref rs, rw)) => {\n+                use self::FloatWidth::*;\n                 if match (lw, rw) {\n                     (FwAny, _) | (_, FwAny) | (Fw32, Fw32) | (Fw64, Fw64) => true,\n                     _ => false,\n@@ -149,6 +146,7 @@ impl PartialOrd for Constant {\n                 })\n             }\n             (&Constant::Float(ref ls, lw), &Constant::Float(ref rs, rw)) => {\n+                use self::FloatWidth::*;\n                 if match (lw, rw) {\n                     (FwAny, _) | (_, FwAny) | (Fw32, Fw32) | (Fw64, Fw64) => true,\n                     _ => false,\n@@ -261,76 +259,51 @@ impl fmt::Display for Constant {\n \n fn lit_to_constant(lit: &Lit_) -> Constant {\n     match *lit {\n-        LitStr(ref is, style) => Constant::Str(is.to_string(), style),\n-        LitByte(b) => Constant::Byte(b),\n-        LitByteStr(ref s) => Constant::Binary(s.clone()),\n-        LitChar(c) => Constant::Char(c),\n-        LitInt(value, ty) => Constant::Int(value, ty),\n-        LitFloat(ref is, ty) => Constant::Float(is.to_string(), ty.into()),\n-        LitFloatUnsuffixed(ref is) => Constant::Float(is.to_string(), FwAny),\n-        LitBool(b) => Constant::Bool(b),\n+        Lit_::LitStr(ref is, style) => Constant::Str(is.to_string(), style),\n+        Lit_::LitByte(b) => Constant::Byte(b),\n+        Lit_::LitByteStr(ref s) => Constant::Binary(s.clone()),\n+        Lit_::LitChar(c) => Constant::Char(c),\n+        Lit_::LitInt(value, ty) => Constant::Int(value, ty),\n+        Lit_::LitFloat(ref is, ty) => Constant::Float(is.to_string(), ty.into()),\n+        Lit_::LitFloatUnsuffixed(ref is) => Constant::Float(is.to_string(), FloatWidth::FwAny),\n+        Lit_::LitBool(b) => Constant::Bool(b),\n     }\n }\n \n fn constant_not(o: Constant) -> Option<Constant> {\n-    Some(match o {\n-        Constant::Bool(b) => Constant::Bool(!b),\n-        Constant::Int(value, ty) => {\n-            let (nvalue, nty) = match ty {\n-                SignedIntLit(ity, Plus) => {\n-                    if value == ::std::u64::MAX {\n-                        return None;\n-                    }\n-                    (value + 1, SignedIntLit(ity, Minus))\n-                }\n-                SignedIntLit(ity, Minus) => {\n-                    if value == 0 {\n-                        (1, SignedIntLit(ity, Minus))\n-                    } else {\n-                        (value - 1, SignedIntLit(ity, Plus))\n-                    }\n-                }\n-                UnsignedIntLit(ity) => {\n-                    let mask = match ity {\n-                        UintTy::TyU8 => ::std::u8::MAX as u64,\n-                        UintTy::TyU16 => ::std::u16::MAX as u64,\n-                        UintTy::TyU32 => ::std::u32::MAX as u64,\n-                        UintTy::TyU64 => ::std::u64::MAX,\n-                        UintTy::TyUs => {\n-                            return None;\n-                        }  // refuse to guess\n-                    };\n-                    (!value & mask, UnsignedIntLit(ity))\n-                }\n-                UnsuffixedIntLit(_) => {\n+    use syntax::ast::LitIntType::*;\n+    use self::Constant::*;\n+    match o {\n+        Bool(b) => Some(Bool(!b)),\n+        Int(::std::u64::MAX, SignedIntLit(_, Plus)) => None,\n+        Int(value, SignedIntLit(ity, Plus)) => Some(Int(value + 1, SignedIntLit(ity, Minus))),\n+        Int(0, SignedIntLit(ity, Minus)) => Some(Int(1, SignedIntLit(ity, Minus))),\n+        Int(value, SignedIntLit(ity, Minus)) => Some(Int(value - 1, SignedIntLit(ity, Plus))),\n+        Int(value, UnsignedIntLit(ity)) => {\n+            let mask = match ity {\n+                UintTy::TyU8 => ::std::u8::MAX as u64,\n+                UintTy::TyU16 => ::std::u16::MAX as u64,\n+                UintTy::TyU32 => ::std::u32::MAX as u64,\n+                UintTy::TyU64 => ::std::u64::MAX,\n+                UintTy::TyUs => {\n                     return None;\n                 }  // refuse to guess\n             };\n-            Constant::Int(nvalue, nty)\n-        }\n-        _ => {\n-            return None;\n-        }\n-    })\n+            Some(Int(!value & mask, UnsignedIntLit(ity)))\n+        },\n+        _ => None,\n+    }\n }\n \n fn constant_negate(o: Constant) -> Option<Constant> {\n-    Some(match o {\n-        Constant::Int(value, ty) => {\n-            Constant::Int(value,\n-                        match ty {\n-                            SignedIntLit(ity, sign) => SignedIntLit(ity, neg_sign(sign)),\n-                            UnsuffixedIntLit(sign) => UnsuffixedIntLit(neg_sign(sign)),\n-                            _ => {\n-                                return None;\n-                            }\n-                        })\n-        }\n-        Constant::Float(is, ty) => Constant::Float(neg_float_str(is), ty),\n-        _ => {\n-            return None;\n-        }\n-    })\n+    use syntax::ast::LitIntType::*;\n+    use self::Constant::*;\n+    match o {\n+        Int(value, SignedIntLit(ity, sign)) => Some(Int(value, SignedIntLit(ity, neg_sign(sign)))),\n+        Int(value, UnsuffixedIntLit(sign)) => Some(Int(value, UnsuffixedIntLit(neg_sign(sign)))),\n+        Float(is, ty) => Some(Float(neg_float_str(is), ty)),\n+        _ => None,\n+    }\n }\n \n fn neg_sign(s: Sign) -> Sign {\n@@ -357,12 +330,13 @@ fn neg_float_str(s: String) -> String {\n /// ```\n pub fn is_negative(ty: LitIntType) -> bool {\n     match ty {\n-        SignedIntLit(_, sign) | UnsuffixedIntLit(sign) => sign == Minus,\n-        UnsignedIntLit(_) => false,\n+        LitIntType::SignedIntLit(_, sign) | LitIntType::UnsuffixedIntLit(sign) => sign == Minus,\n+        LitIntType::UnsignedIntLit(_) => false,\n     }\n }\n \n fn unify_int_type(l: LitIntType, r: LitIntType, s: Sign) -> Option<LitIntType> {\n+    use syntax::ast::LitIntType::*;\n     match (l, r) {\n         (SignedIntLit(lty, _), SignedIntLit(rty, _)) => {\n             if lty == rty {"}, {"sha": "d6df307fec2d7da24008e612582066c4cd6c2caf", "filename": "src/enum_glob_use.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fenum_glob_use.rs?ref=9ba5d45509a62169dc4f6c0bac5ea6ac08d40883", "patch": "@@ -0,0 +1,61 @@\n+//! lint on `use`ing all variants of an enum\n+\n+use rustc::lint::{LateLintPass, LintPass, LateContext, LintArray, LintContext};\n+use rustc_front::hir::*;\n+use rustc::front::map::Node::NodeItem;\n+use rustc::front::map::PathElem::PathName;\n+use rustc::middle::ty::TyEnum;\n+use utils::span_lint;\n+use syntax::codemap::Span;\n+use syntax::ast::NodeId;\n+\n+/// **What it does:** Warns when `use`ing all variants of an enum\n+///\n+/// **Why is this bad?** It is usually better style to use the prefixed name of an enum variant, rather than importing variants\n+///\n+/// **Known problems:** Old-style enums that prefix the variants are still around\n+///\n+/// **Example:** `use std::cmp::Ordering::*;`\n+declare_lint! { pub ENUM_GLOB_USE, Allow,\n+    \"finds use items that import all variants of an enum\" }\n+\n+pub struct EnumGlobUse;\n+\n+impl LintPass for EnumGlobUse {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(ENUM_GLOB_USE)\n+    }\n+}\n+\n+impl LateLintPass for EnumGlobUse {\n+    fn check_mod(&mut self, cx: &LateContext, m: &Mod, _: Span, _: NodeId) {\n+        // only check top level `use` statements\n+        for item in &m.item_ids {\n+            self.lint_item(cx, cx.krate.item(item.id));\n+        }\n+    }\n+}\n+\n+impl EnumGlobUse {\n+    fn lint_item(&self, cx: &LateContext, item: &Item) {\n+        if item.vis == Visibility::Public {\n+            return; // re-exports are fine\n+        }\n+        if let ItemUse(ref item_use) = item.node {\n+            if let ViewPath_::ViewPathGlob(_) = item_use.node {\n+                let def = cx.tcx.def_map.borrow()[&item.id];\n+                if let Some(NodeItem(it)) = cx.tcx.map.get_if_local(def.def_id()) {\n+                    if let ItemEnum(..) = it.node {\n+                        span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n+                    }\n+                } else {\n+                    if let Some(&PathName(_)) = cx.sess().cstore.item_path(def.def_id()).last() {\n+                        if let TyEnum(..) = cx.sess().cstore.item_type(&cx.tcx, def.def_id()).ty.sty {\n+                            span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "ea0c873cb5483dd768a447e9d008accc7c378a42", "filename": "src/len_zero.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=9ba5d45509a62169dc4f6c0bac5ea6ac08d40883", "patch": "@@ -6,8 +6,7 @@ use syntax::codemap::{Span, Spanned};\n use rustc::middle::def_id::DefId;\n use rustc::middle::ty::{self, MethodTraitItemId, ImplOrTraitItemId};\n \n-use syntax::ast::Lit_::*;\n-use syntax::ast::Lit;\n+use syntax::ast::{Lit, Lit_};\n \n use utils::{get_item_name, snippet, span_lint, walk_ptrs_ty};\n \n@@ -152,7 +151,7 @@ fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str)\n }\n \n fn check_len_zero(cx: &LateContext, span: Span, name: &Name, args: &[P<Expr>], lit: &Lit, op: &str) {\n-    if let Spanned{node: LitInt(0, _), ..} = *lit {\n+    if let Spanned{node: Lit_::LitInt(0, _), ..} = *lit {\n         if name.as_str() == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n             span_lint(cx,\n                       LEN_ZERO,"}, {"sha": "fa98beb8d7460f576678ea3e4c24fe9406e688ff", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=9ba5d45509a62169dc4f6c0bac5ea6ac08d40883", "patch": "@@ -40,6 +40,7 @@ pub mod utils;\n pub mod consts;\n pub mod types;\n pub mod misc;\n+pub mod enum_glob_use;\n pub mod eq_op;\n pub mod bit_mask;\n pub mod ptr_arg;\n@@ -99,6 +100,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box misc::CmpNan);\n     reg.register_late_lint_pass(box eq_op::EqOp);\n     reg.register_early_lint_pass(box enum_variants::EnumVariantNames);\n+    reg.register_late_lint_pass(box enum_glob_use::EnumGlobUse);\n     reg.register_late_lint_pass(box bit_mask::BitMask);\n     reg.register_late_lint_pass(box ptr_arg::PtrArg);\n     reg.register_late_lint_pass(box needless_bool::NeedlessBool);\n@@ -157,6 +159,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box regex::RegexPass);\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n+        enum_glob_use::ENUM_GLOB_USE,\n         matches::SINGLE_MATCH_ELSE,\n         methods::OPTION_UNWRAP_USED,\n         methods::RESULT_UNWRAP_USED,"}, {"sha": "03e2d0a4ec3de157f98a28098c91f2d2a95bbc2b", "filename": "src/minmax.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fminmax.rs?ref=9ba5d45509a62169dc4f6c0bac5ea6ac08d40883", "patch": "@@ -1,8 +1,7 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::ptr::P;\n-use std::cmp::PartialOrd;\n-use std::cmp::Ordering::*;\n+use std::cmp::{PartialOrd, Ordering};\n \n use consts::{Constant, constant_simple};\n use utils::{match_def_path, span_lint};\n@@ -37,7 +36,7 @@ impl LateLintPass for MinMaxPass {\n                     return;\n                 }\n                 match (outer_max, outer_c.partial_cmp(&inner_c)) {\n-                    (_, None) | (Max, Some(Less)) | (Min, Some(Greater)) => (),\n+                    (_, None) | (Max, Some(Ordering::Less)) | (Min, Some(Ordering::Greater)) => (),\n                     _ => {\n                         span_lint(cx, MIN_MAX, expr.span, \"this min/max combination leads to constant result\");\n                     }"}, {"sha": "bfd819edcb6743f954d0b9c8a383a16ad3e04249", "filename": "src/needless_bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=9ba5d45509a62169dc4f6c0bac5ea6ac08d40883", "patch": "@@ -5,7 +5,7 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n \n-use syntax::ast::Lit_::*;\n+use syntax::ast::Lit_;\n \n use utils::{span_lint, snippet};\n \n@@ -90,7 +90,7 @@ fn fetch_bool_expr(expr: &Expr) -> Option<bool> {\n     match expr.node {\n         ExprBlock(ref block) => fetch_bool_block(block),\n         ExprLit(ref lit_ptr) => {\n-            if let LitBool(value) = lit_ptr.node {\n+            if let Lit_::LitBool(value) = lit_ptr.node {\n                 Some(value)\n             } else {\n                 None"}, {"sha": "7034b0d2ddb578edb96720ecc1a7926208dd90d7", "filename": "src/types.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=9ba5d45509a62169dc4f6c0bac5ea6ac08d40883", "patch": "@@ -5,9 +5,7 @@ use rustc_front::util::{is_comparison_binop, binop_to_string};\n use syntax::codemap::Span;\n use rustc_front::intravisit::{FnKind, Visitor, walk_ty};\n use rustc::middle::ty;\n-use syntax::ast::IntTy::*;\n-use syntax::ast::UintTy::*;\n-use syntax::ast::FloatTy::*;\n+use syntax::ast::{IntTy, UintTy, FloatTy};\n \n use utils::*;\n \n@@ -236,7 +234,7 @@ fn int_ty_to_nbits(typ: &ty::TyS) -> usize {\n \n fn is_isize_or_usize(typ: &ty::TyS) -> bool {\n     match typ.sty {\n-        ty::TyInt(TyIs) | ty::TyUint(TyUs) => true,\n+        ty::TyInt(IntTy::TyIs) | ty::TyUint(UintTy::TyUs) => true,\n         _ => false,\n     }\n }\n@@ -361,7 +359,7 @@ impl LateLintPass for CastPass {\n                 match (cast_from.is_integral(), cast_to.is_integral()) {\n                     (true, false) => {\n                         let from_nbits = int_ty_to_nbits(cast_from);\n-                        let to_nbits = if let ty::TyFloat(TyF32) = cast_to.sty {\n+                        let to_nbits = if let ty::TyFloat(FloatTy::TyF32) = cast_to.sty {\n                             32\n                         } else {\n                             64\n@@ -392,7 +390,7 @@ impl LateLintPass for CastPass {\n                         check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n                     }\n                     (false, false) => {\n-                        if let (&ty::TyFloat(TyF64), &ty::TyFloat(TyF32)) = (&cast_from.sty, &cast_to.sty) {\n+                        if let (&ty::TyFloat(FloatTy::TyF64), &ty::TyFloat(FloatTy::TyF32)) = (&cast_from.sty, &cast_to.sty) {\n                             span_lint(cx,\n                                       CAST_POSSIBLE_TRUNCATION,\n                                       expr.span,"}, {"sha": "f363eace713dce6dd5032a303f90d19aeb3f76aa", "filename": "src/unicode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funicode.rs?ref=9ba5d45509a62169dc4f6c0bac5ea6ac08d40883", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Span;\n \n-use syntax::ast::Lit_::*;\n+use syntax::ast::Lit_;\n \n use unicode_normalization::UnicodeNormalization;\n \n@@ -59,7 +59,7 @@ impl LintPass for Unicode {\n impl LateLintPass for Unicode {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprLit(ref lit) = expr.node {\n-            if let LitStr(_, _) = lit.node {\n+            if let Lit_::LitStr(_, _) = lit.node {\n                 check_str(cx, lit.span)\n             }\n         }"}, {"sha": "74c1de6976f1c13cdce3867a541c89a232f681cc", "filename": "src/utils.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=9ba5d45509a62169dc4f6c0bac5ea6ac08d40883", "patch": "@@ -1,7 +1,7 @@\n use consts::constant;\n use reexport::*;\n-use rustc::front::map::Node::*;\n-use rustc::lint::*;\n+use rustc::front::map::Node;\n+use rustc::lint::{LintContext, LateContext, Level, Lint};\n use rustc::middle::def_id::DefId;\n use rustc::middle::{cstore, def, infer, ty, traits};\n use rustc::session::Session;\n@@ -10,7 +10,7 @@ use std::borrow::Cow;\n use std::mem;\n use std::ops::{Deref, DerefMut};\n use std::str::FromStr;\n-use syntax::ast::Lit_::*;\n+use syntax::ast::Lit_;\n use syntax::ast;\n use syntax::codemap::{ExpnInfo, Span, ExpnFormat};\n use syntax::errors::DiagnosticBuilder;\n@@ -296,9 +296,9 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.map.get_parent(expr.id);\n     match cx.tcx.map.find(parent_id) {\n-        Some(NodeItem(&Item{ ref name, .. })) |\n-        Some(NodeTraitItem(&TraitItem{ ref name, .. })) |\n-        Some(NodeImplItem(&ImplItem{ ref name, .. })) => Some(*name),\n+        Some(Node::NodeItem(&Item{ ref name, .. })) |\n+        Some(Node::NodeTraitItem(&TraitItem{ ref name, .. })) |\n+        Some(Node::NodeImplItem(&ImplItem{ ref name, .. })) => Some(*name),\n         _ => None,\n     }\n }\n@@ -408,7 +408,7 @@ pub fn get_parent_expr<'c>(cx: &'c LateContext, e: &Expr) -> Option<&'c Expr> {\n         return None;\n     }\n     map.find(parent_id).and_then(|node| {\n-        if let NodeExpr(parent) = node {\n+        if let Node::NodeExpr(parent) = node {\n             Some(parent)\n         } else {\n             None\n@@ -422,8 +422,8 @@ pub fn get_enclosing_block<'c>(cx: &'c LateContext, node: NodeId) -> Option<&'c\n                             .and_then(|enclosing_id| map.find(enclosing_id));\n     if let Some(node) = enclosing_node {\n         match node {\n-            NodeBlock(ref block) => Some(block),\n-            NodeItem(&Item{ node: ItemFn(_, _, _, _, _, ref block), .. }) => Some(block),\n+            Node::NodeBlock(ref block) => Some(block),\n+            Node::NodeItem(&Item{ node: ItemFn(_, _, _, _, _, ref block), .. }) => Some(block),\n             _ => None,\n         }\n     } else {\n@@ -529,7 +529,7 @@ pub fn walk_ptrs_ty_depth(ty: ty::Ty) -> (ty::Ty, usize) {\n pub fn is_integer_literal(expr: &Expr, value: u64) -> bool {\n     // FIXME: use constant folding\n     if let ExprLit(ref spanned) = expr.node {\n-        if let LitInt(v, _) = spanned.node {\n+        if let Lit_::LitInt(v, _) = spanned.node {\n             return v == value;\n         }\n     }\n@@ -575,7 +575,7 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n         }\n         if let ast::MetaNameValue(ref key, ref value) = attr.value.node {\n             if *key == name {\n-                if let LitStr(ref s, _) = value.node {\n+                if let Lit_::LitStr(ref s, _) = value.node {\n                     if let Ok(value) = FromStr::from_str(s) {\n                         f(value)\n                     } else {"}, {"sha": "fc5f531ba90d7ce417cc304f02006e6e17920a3a", "filename": "tests/compile-fail/enum_glob_use.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/tests%2Fcompile-fail%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba5d45509a62169dc4f6c0bac5ea6ac08d40883/tests%2Fcompile-fail%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fenum_glob_use.rs?ref=9ba5d45509a62169dc4f6c0bac5ea6ac08d40883", "patch": "@@ -0,0 +1,20 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![deny(clippy, clippy_pedantic)]\n+#![allow(unused_imports, dead_code)]\n+\n+use std::cmp::Ordering::*; //~ ERROR: don't use glob imports for enum variants\n+\n+enum Enum {}\n+\n+use self::Enum::*; //~ ERROR: don't use glob imports for enum variants\n+\n+fn blarg() {\n+    use self::Enum::*; // ok, just for a function\n+}\n+\n+mod blurg {\n+    pub use std::cmp::Ordering::*; // ok, re-export\n+}\n+\n+fn main() {}"}]}