{"sha": "cfc572cae2d1fc381cce476b5c787fd7221af98c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmYzU3MmNhZTJkMWZjMzgxY2NlNDc2YjVjNzg3ZmQ3MjIxYWY5OGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-30T20:57:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-30T20:57:54Z"}, "message": "Auto merge of #74957 - Manishearth:rollup-3wudwlg, r=Manishearth\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #74751 (Clean up E0730 explanation)\n - #74782 (Don't use \"weak count\" around Weak::from_raw_ptr)\n - #74835 (Clean up E0734 explanation)\n - #74871 (Enable docs on dist-x86_64-musl)\n - #74905 (Avoid bool-like naming)\n - #74907 (Clean up E0740 explanation)\n - #74915 (rustc: Ignore fs::canonicalize errors in metadata)\n - #74934 (Improve diagnostics when constant pattern is too generic)\n - #74951 (Cherry-pick the release notes for 1.45.1)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "0ad520d222d7c1987eefe87e4345d6d804f7bed1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ad520d222d7c1987eefe87e4345d6d804f7bed1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfc572cae2d1fc381cce476b5c787fd7221af98c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfc572cae2d1fc381cce476b5c787fd7221af98c", "html_url": "https://github.com/rust-lang/rust/commit/cfc572cae2d1fc381cce476b5c787fd7221af98c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfc572cae2d1fc381cce476b5c787fd7221af98c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "438c59f010016a8a3a11fbcc4c18ae555d7adf94", "url": "https://api.github.com/repos/rust-lang/rust/commits/438c59f010016a8a3a11fbcc4c18ae555d7adf94", "html_url": "https://github.com/rust-lang/rust/commit/438c59f010016a8a3a11fbcc4c18ae555d7adf94"}, {"sha": "9eb50260bd06fa005f7f146702565dfdc7c3b4de", "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb50260bd06fa005f7f146702565dfdc7c3b4de", "html_url": "https://github.com/rust-lang/rust/commit/9eb50260bd06fa005f7f146702565dfdc7c3b4de"}], "stats": {"total": 189, "additions": 108, "deletions": 81}, "files": [{"sha": "b47f64d2fafc9abbf412863f1067f9ebde0b7b17", "filename": "RELEASES.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cfc572cae2d1fc381cce476b5c787fd7221af98c/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/cfc572cae2d1fc381cce476b5c787fd7221af98c/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=cfc572cae2d1fc381cce476b5c787fd7221af98c", "patch": "@@ -1,3 +1,16 @@\n+Version 1.45.1 (2020-07-30)\n+==========================\n+\n+* [Fix const propagation with references.][73613]\n+* [rustfmt accepts rustfmt_skip in cfg_attr again.][73078]\n+* [Avoid spurious implicit region bound.][74509]\n+* [Install clippy on x.py install][74457]\n+\n+[73613]: https://github.com/rust-lang/rust/pull/73613\n+[73078]: https://github.com/rust-lang/rust/issues/73078\n+[74509]: https://github.com/rust-lang/rust/pull/74509\n+[74457]: https://github.com/rust-lang/rust/pull/74457\n+\n Version 1.45.0 (2020-07-16)\n ==========================\n "}, {"sha": "116df63f94b69d4e9df143042085c881589bfc91", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cfc572cae2d1fc381cce476b5c787fd7221af98c/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc572cae2d1fc381cce476b5c787fd7221af98c/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=cfc572cae2d1fc381cce476b5c787fd7221af98c", "patch": "@@ -1692,8 +1692,9 @@ impl<T> Weak<T> {\n \n     /// Consumes the `Weak<T>` and turns it into a raw pointer.\n     ///\n-    /// This converts the weak pointer into a raw pointer, preserving the original weak count. It\n-    /// can be turned back into the `Weak<T>` with [`from_raw`].\n+    /// This converts the weak pointer into a raw pointer, while still preserving the ownership of\n+    /// one weak reference (the weak count is not modified by this operation). It can be turned\n+    /// back into the `Weak<T>` with [`from_raw`].\n     ///\n     /// The same restrictions of accessing the target of the pointer as with\n     /// [`as_ptr`] apply.\n@@ -1728,17 +1729,18 @@ impl<T> Weak<T> {\n     /// This can be used to safely get a strong reference (by calling [`upgrade`]\n     /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n     ///\n-    /// It takes ownership of one weak count (with the exception of pointers created by [`new`],\n-    /// as these don't have any corresponding weak count).\n+    /// It takes ownership of one weak reference (with the exception of pointers created by [`new`],\n+    /// as these don't own anything; the method still works on them).\n     ///\n     /// # Safety\n     ///\n-    /// The pointer must have originated from the [`into_raw`]  and must still own its potential\n-    /// weak reference count.\n+    /// The pointer must have originated from the [`into_raw`] and must still own its potential\n+    /// weak reference.\n     ///\n-    /// It is allowed for the strong count to be 0 at the time of calling this, but the weak count\n-    /// must be non-zero or the pointer must have originated from a dangling `Weak<T>` (one created\n-    /// by [`new`]).\n+    /// It is allowed for the strong count to be 0 at the time of calling this. Nevertheless, this\n+    /// takes ownership of one weak reference currently represented as a raw pointer (the weak\n+    /// count is not modified by this operation) and therefore it must be paired with a previous\n+    /// call to [`into_raw`].\n     ///\n     /// # Examples\n     ///"}, {"sha": "58cab9c5c6388a6d6c335050f88e7c1be77e9175", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cfc572cae2d1fc381cce476b5c787fd7221af98c/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc572cae2d1fc381cce476b5c787fd7221af98c/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=cfc572cae2d1fc381cce476b5c787fd7221af98c", "patch": "@@ -1462,8 +1462,9 @@ impl<T> Weak<T> {\n \n     /// Consumes the `Weak<T>` and turns it into a raw pointer.\n     ///\n-    /// This converts the weak pointer into a raw pointer, preserving the original weak count. It\n-    /// can be turned back into the `Weak<T>` with [`from_raw`].\n+    /// This converts the weak pointer into a raw pointer, while still preserving the ownership of\n+    /// one weak reference (the weak count is not modified by this operation). It can be turned\n+    /// back into the `Weak<T>` with [`from_raw`].\n     ///\n     /// The same restrictions of accessing the target of the pointer as with\n     /// [`as_ptr`] apply.\n@@ -1493,24 +1494,23 @@ impl<T> Weak<T> {\n         result\n     }\n \n-    /// Converts a raw pointer previously created by [`into_raw`] back into\n-    /// `Weak<T>`.\n+    /// Converts a raw pointer previously created by [`into_raw`] back into `Weak<T>`.\n     ///\n     /// This can be used to safely get a strong reference (by calling [`upgrade`]\n     /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n     ///\n-    /// It takes ownership of one weak count (with the exception of pointers created by [`new`],\n-    /// as these don't have any corresponding weak count).\n+    /// It takes ownership of one weak reference (with the exception of pointers created by [`new`],\n+    /// as these don't own anything; the method still works on them).\n     ///\n     /// # Safety\n     ///\n     /// The pointer must have originated from the [`into_raw`] and must still own its potential\n-    /// weak reference count.\n-    ///\n-    /// It is allowed for the strong count to be 0 at the time of calling this, but the weak count\n-    /// must be non-zero or the pointer must have originated from a dangling `Weak<T>` (one created\n-    /// by [`new`]).\n+    /// weak reference.\n     ///\n+    /// It is allowed for the strong count to be 0 at the time of calling this. Nevertheless, this\n+    /// takes ownership of one weak reference currently represented as a raw pointer (the weak\n+    /// count is not modified by this operation) and therefore it must be paired with a previous\n+    /// call to [`into_raw`].\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "ab6515cd1fa955daf10a57117643ea9adf1eddfd", "filename": "src/ci/docker/host-x86_64/dist-x86_64-musl/Dockerfile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-musl%2FDockerfile?ref=cfc572cae2d1fc381cce476b5c787fd7221af98c", "patch": "@@ -33,7 +33,6 @@ ENV HOSTS=x86_64-unknown-linux-musl\n ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-x86_64=/usr/local/x86_64-linux-musl \\\n       --enable-extended \\\n-      --disable-docs \\\n       --enable-lld \\\n       --set target.x86_64-unknown-linux-musl.crt-static=false \\\n       --build $HOSTS"}, {"sha": "4d2902e986f5652861b0ed2942b52809f30b31d9", "filename": "src/etc/test-float-parse/runtests.py", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "raw_url": "https://github.com/rust-lang/rust/raw/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fruntests.py?ref=cfc572cae2d1fc381cce476b5c787fd7221af98c", "patch": "@@ -195,9 +195,8 @@ def main():\n     global MAILBOX\n     tests = [os.path.splitext(f)[0] for f in glob('*.rs')\n                                     if not f.startswith('_')]\n-    listed = sys.argv[1:]\n-    if listed:\n-        tests = [test for test in tests if test in listed]\n+    args = sys.argv[1:]\n+    tests = [test for test in tests if test in args]\n     if not tests:\n         print(\"Error: No tests to run\")\n         sys.exit(1)"}, {"sha": "016b3f38aa310598bba2365a47289709238af03a", "filename": "src/librustc_error_codes/error_codes/E0730.md", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0730.md", "raw_url": "https://github.com/rust-lang/rust/raw/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0730.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0730.md?ref=cfc572cae2d1fc381cce476b5c787fd7221af98c", "patch": "@@ -1,6 +1,6 @@\n An array without a fixed length was pattern-matched.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0730\n #![feature(const_generics)]\n@@ -14,14 +14,28 @@ fn is_123<const N: usize>(x: [u32; N]) -> bool {\n }\n ```\n \n-Ensure that the pattern is consistent with the size of the matched\n-array. Additional elements can be matched with `..`:\n+To fix this error, you have two solutions:\n+ 1. Use an array with a fixed length.\n+ 2. Use a slice.\n \n+Example with an array with a fixed length:\n+\n+```\n+fn is_123(x: [u32; 3]) -> bool { // We use an array with a fixed size\n+    match x {\n+        [1, 2, ..] => true, // ok!\n+        _ => false\n+    }\n+}\n ```\n-let r = &[1, 2, 3, 4];\n-match r {\n-    &[a, b, ..] => { // ok!\n-        println!(\"a={}, b={}\", a, b);\n+\n+Example with a slice:\n+\n+```\n+fn is_123(x: &[u32]) -> bool { // We use a slice\n+    match x {\n+        [1, 2, ..] => true, // ok!\n+        _ => false\n     }\n }\n ```"}, {"sha": "4b8e89a70604d0974f5630271e3632c709b3a066", "filename": "src/librustc_error_codes/error_codes/E0734.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0734.md", "raw_url": "https://github.com/rust-lang/rust/raw/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0734.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0734.md?ref=cfc572cae2d1fc381cce476b5c787fd7221af98c", "patch": "@@ -1,6 +1,6 @@\n A stability attribute has been used outside of the standard library.\n \n-Erroneous code examples:\n+Erroneous code example:\n \n ```compile_fail,E0734\n #[rustc_deprecated(since = \"b\", reason = \"text\")] // invalid"}, {"sha": "6240099a99f671b1e6934615e4a353908d2669f0", "filename": "src/librustc_error_codes/error_codes/E0740.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0740.md", "raw_url": "https://github.com/rust-lang/rust/raw/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0740.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0740.md?ref=cfc572cae2d1fc381cce476b5c787fd7221af98c", "patch": "@@ -1,4 +1,4 @@\n-A `union` cannot have fields with destructors.\n+A `union` was declared with fields with destructors.\n \n Erroneous code example:\n \n@@ -14,3 +14,5 @@ impl Drop for A {\n     fn drop(&mut self) { println!(\"A\"); }\n }\n ```\n+\n+A `union` cannot have fields with destructors."}, {"sha": "a4ccc8c74c8499721d75a09b124b2ab83bffdd16", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=cfc572cae2d1fc381cce476b5c787fd7221af98c", "patch": "@@ -248,9 +248,9 @@ impl<'a> CrateLoader<'a> {\n                 // Only use `--extern crate_name=path` here, not `--extern crate_name`.\n                 if let Some(mut files) = entry.files() {\n                     if files.any(|l| {\n-                        let l = fs::canonicalize(l).ok();\n-                        source.dylib.as_ref().map(|p| &p.0) == l.as_ref()\n-                            || source.rlib.as_ref().map(|p| &p.0) == l.as_ref()\n+                        let l = fs::canonicalize(l).unwrap_or(l.clone().into());\n+                        source.dylib.as_ref().map(|p| &p.0) == Some(&l)\n+                            || source.rlib.as_ref().map(|p| &p.0) == Some(&l)\n                     }) {\n                         ret = Some(cnum);\n                     }"}, {"sha": "8828b318d1ea6bb6d5fcac44707ee06f4b044391", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=cfc572cae2d1fc381cce476b5c787fd7221af98c", "patch": "@@ -426,20 +426,17 @@ impl<'a> CrateLocator<'a> {\n             info!(\"lib candidate: {}\", spf.path.display());\n \n             let (rlibs, rmetas, dylibs) = candidates.entry(hash.to_string()).or_default();\n-            fs::canonicalize(&spf.path)\n-                .map(|p| {\n-                    if seen_paths.contains(&p) {\n-                        return FileDoesntMatch;\n-                    };\n-                    seen_paths.insert(p.clone());\n-                    match found_kind {\n-                        CrateFlavor::Rlib => rlibs.insert(p, kind),\n-                        CrateFlavor::Rmeta => rmetas.insert(p, kind),\n-                        CrateFlavor::Dylib => dylibs.insert(p, kind),\n-                    };\n-                    FileMatches\n-                })\n-                .unwrap_or(FileDoesntMatch)\n+            let path = fs::canonicalize(&spf.path).unwrap_or_else(|_| spf.path.clone());\n+            if seen_paths.contains(&path) {\n+                return FileDoesntMatch;\n+            };\n+            seen_paths.insert(path.clone());\n+            match found_kind {\n+                CrateFlavor::Rlib => rlibs.insert(path, kind),\n+                CrateFlavor::Rmeta => rmetas.insert(path, kind),\n+                CrateFlavor::Dylib => dylibs.insert(path, kind),\n+            };\n+            FileMatches\n         });\n         self.rejected_via_kind.extend(staticlibs);\n \n@@ -688,12 +685,13 @@ impl<'a> CrateLocator<'a> {\n                     && file.ends_with(&self.target.options.dll_suffix)\n             {\n                 // Make sure there's at most one rlib and at most one dylib.\n+                let loc = fs::canonicalize(&loc).unwrap_or_else(|_| loc.clone());\n                 if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rlib\") {\n-                    rlibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n+                    rlibs.insert(loc, PathKind::ExternFlag);\n                 } else if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rmeta\") {\n-                    rmetas.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n+                    rmetas.insert(loc, PathKind::ExternFlag);\n                 } else {\n-                    dylibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n+                    dylibs.insert(loc, PathKind::ExternFlag);\n                 }\n             } else {\n                 self.rejected_via_filename"}, {"sha": "f813ba0c077cadb662d6aeed5e8bfdb2f0b0e562", "filename": "src/librustc_mir_build/hair/pattern/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs?ref=cfc572cae2d1fc381cce476b5c787fd7221af98c", "patch": "@@ -16,7 +16,7 @@ use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n use rustc_hir::RangeEnd;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{get_slice_bytes, sign_extend, ConstValue};\n-use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n+use rustc_middle::mir::interpret::{ErrorHandled, LitToConstError, LitToConstInput};\n use rustc_middle::mir::UserTypeProjection;\n use rustc_middle::mir::{BorrowKind, Field, Mutability};\n use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n@@ -834,6 +834,12 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                     pattern\n                 }\n             }\n+            Err(ErrorHandled::TooGeneric) => {\n+                // While `Reported | Linted` cases will have diagnostics emitted already\n+                // it is not true for TooGeneric case, so we need to give user more information.\n+                self.tcx.sess.span_err(span, \"constant pattern depends on a generic parameter\");\n+                pat_from_kind(PatKind::Wild)\n+            }\n             Err(_) => {\n                 self.tcx.sess.span_err(span, \"could not evaluate constant pattern\");\n                 pat_from_kind(PatKind::Wild)"}, {"sha": "504490d938cfa576d77287643df8fe06111a7ffb", "filename": "src/librustc_session/filesearch.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Flibrustc_session%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Flibrustc_session%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Ffilesearch.rs?ref=cfc572cae2d1fc381cce476b5c787fd7221af98c", "patch": "@@ -117,28 +117,22 @@ pub fn make_target_lib_path(sysroot: &Path, target_triple: &str) -> PathBuf {\n \n pub fn get_or_default_sysroot() -> PathBuf {\n     // Follow symlinks.  If the resolved path is relative, make it absolute.\n-    fn canonicalize(path: Option<PathBuf>) -> Option<PathBuf> {\n-        path.and_then(|path| {\n-            match fs::canonicalize(&path) {\n-                // See comments on this target function, but the gist is that\n-                // gcc chokes on verbatim paths which fs::canonicalize generates\n-                // so we try to avoid those kinds of paths.\n-                Ok(canon) => Some(fix_windows_verbatim_for_gcc(&canon)),\n-                Err(e) => panic!(\"failed to get realpath: {}\", e),\n-            }\n-        })\n+    fn canonicalize(path: PathBuf) -> PathBuf {\n+        let path = fs::canonicalize(&path).unwrap_or(path);\n+        // See comments on this target function, but the gist is that\n+        // gcc chokes on verbatim paths which fs::canonicalize generates\n+        // so we try to avoid those kinds of paths.\n+        fix_windows_verbatim_for_gcc(&path)\n     }\n \n     match env::current_exe() {\n-        Ok(exe) => match canonicalize(Some(exe)) {\n-            Some(mut p) => {\n-                p.pop();\n-                p.pop();\n-                p\n-            }\n-            None => panic!(\"can't determine value for sysroot\"),\n-        },\n-        Err(ref e) => panic!(format!(\"failed to get current_exe: {}\", e)),\n+        Ok(exe) => {\n+            let mut p = canonicalize(exe);\n+            p.pop();\n+            p.pop();\n+            p\n+        }\n+        Err(e) => panic!(\"failed to get current_exe: {}\", e),\n     }\n }\n "}, {"sha": "518036c9dbeecd8d899b7d59a88702e5809c5069", "filename": "src/test/ui/consts/issue-73976-polymorphic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Ftest%2Fui%2Fconsts%2Fissue-73976-polymorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Ftest%2Fui%2Fconsts%2Fissue-73976-polymorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-73976-polymorphic.rs?ref=cfc572cae2d1fc381cce476b5c787fd7221af98c", "patch": "@@ -17,8 +17,8 @@ impl<T: 'static> GetTypeId<T> {\n \n const fn check_type_id<T: 'static>() -> bool {\n     matches!(GetTypeId::<T>::VALUE, GetTypeId::<T>::VALUE)\n-    //~^ ERROR could not evaluate constant pattern\n-    //~| ERROR could not evaluate constant pattern\n+    //~^ ERROR constant pattern depends on a generic parameter\n+    //~| ERROR constant pattern depends on a generic parameter\n }\n \n pub struct GetTypeNameLen<T>(T);\n@@ -29,8 +29,8 @@ impl<T: 'static> GetTypeNameLen<T> {\n \n const fn check_type_name_len<T: 'static>() -> bool {\n     matches!(GetTypeNameLen::<T>::VALUE, GetTypeNameLen::<T>::VALUE)\n-    //~^ ERROR could not evaluate constant pattern\n-    //~| ERROR could not evaluate constant pattern\n+    //~^ ERROR constant pattern depends on a generic parameter\n+    //~| ERROR constant pattern depends on a generic parameter\n }\n \n fn main() {"}, {"sha": "250f1536d85fcf62a9479640264a935b43f28ce7", "filename": "src/test/ui/consts/issue-73976-polymorphic.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Ftest%2Fui%2Fconsts%2Fissue-73976-polymorphic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfc572cae2d1fc381cce476b5c787fd7221af98c/src%2Ftest%2Fui%2Fconsts%2Fissue-73976-polymorphic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-73976-polymorphic.stderr?ref=cfc572cae2d1fc381cce476b5c787fd7221af98c", "patch": "@@ -1,22 +1,22 @@\n-error: could not evaluate constant pattern\n+error: constant pattern depends on a generic parameter\n   --> $DIR/issue-73976-polymorphic.rs:19:37\n    |\n LL |     matches!(GetTypeId::<T>::VALUE, GetTypeId::<T>::VALUE)\n    |                                     ^^^^^^^^^^^^^^^^^^^^^\n \n-error: could not evaluate constant pattern\n+error: constant pattern depends on a generic parameter\n   --> $DIR/issue-73976-polymorphic.rs:31:42\n    |\n LL |     matches!(GetTypeNameLen::<T>::VALUE, GetTypeNameLen::<T>::VALUE)\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: could not evaluate constant pattern\n+error: constant pattern depends on a generic parameter\n   --> $DIR/issue-73976-polymorphic.rs:19:37\n    |\n LL |     matches!(GetTypeId::<T>::VALUE, GetTypeId::<T>::VALUE)\n    |                                     ^^^^^^^^^^^^^^^^^^^^^\n \n-error: could not evaluate constant pattern\n+error: constant pattern depends on a generic parameter\n   --> $DIR/issue-73976-polymorphic.rs:31:42\n    |\n LL |     matches!(GetTypeNameLen::<T>::VALUE, GetTypeNameLen::<T>::VALUE)"}]}