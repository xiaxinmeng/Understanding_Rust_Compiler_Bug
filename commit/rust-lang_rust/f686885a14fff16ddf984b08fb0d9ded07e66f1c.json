{"sha": "f686885a14fff16ddf984b08fb0d9ded07e66f1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ODY4ODVhMTRmZmYxNmRkZjk4NGIwOGZiMGQ5ZGVkMDdlNjZmMWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-18T00:45:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-18T00:45:57Z"}, "message": "Auto merge of #52342 - nnethercote:CanonicalVar, r=nikomatsakis\n\nAvoid most allocations in `Canonicalizer`.\n\nExtra allocations are a significant cost of NLL, and the most common\nones come from within `Canonicalizer`. In particular, `canonical_var()`\ncontains this code:\n\n    indices\n\t.entry(kind)\n\t.or_insert_with(|| {\n\t    let cvar1 = variables.push(info);\n\t    let cvar2 = var_values.push(kind);\n\t    assert_eq!(cvar1, cvar2);\n\t    cvar1\n\t})\n\t.clone()\n\n`variables` and `var_values` are `Vec`s. `indices` is a `HashMap` used\nto track what elements have been inserted into `var_values`. If `kind`\nhasn't been seen before, `indices`, `variables` and `var_values` all get\na new element. (The number of elements in each container is always the\nsame.) This results in lots of allocations.\n\nIn practice, most of the time these containers only end up holding a few\nelements. This PR changes them to avoid heap allocations in the common\ncase, by changing the `Vec`s to `SmallVec`s and only using `indices`\nonce enough elements are present. (When the number of elements is small,\na direct linear search of `var_values` is as good or better than a\nhashmap lookup.)\n\nThe changes to `variables` are straightforward and contained within\n`Canonicalizer`. The changes to `indices` are more complex but also\ncontained within `Canonicalizer`. The changes to `var_values` are more\nintrusive because they require defining a new type\n`SmallCanonicalVarValues` -- which is to `CanonicalVarValues` as\n`SmallVec` is to `Vec -- and passing stack-allocated values of that type\nin from outside.\n\nAll this speeds up a number of NLL \"check\" builds, the best by 2%.\n\nr? @nikomatsakis", "tree": {"sha": "6b436f0f01a76e9180849c7ad774b7d6e635772d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b436f0f01a76e9180849c7ad774b7d6e635772d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f686885a14fff16ddf984b08fb0d9ded07e66f1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f686885a14fff16ddf984b08fb0d9ded07e66f1c", "html_url": "https://github.com/rust-lang/rust/commit/f686885a14fff16ddf984b08fb0d9ded07e66f1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f686885a14fff16ddf984b08fb0d9ded07e66f1c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f3c7a472b77ba3f3afbc12d004b9d1bbcee7fe7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f3c7a472b77ba3f3afbc12d004b9d1bbcee7fe7", "html_url": "https://github.com/rust-lang/rust/commit/4f3c7a472b77ba3f3afbc12d004b9d1bbcee7fe7"}, {"sha": "7cc527770d1270921647a4324cb30d0d89467de6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cc527770d1270921647a4324cb30d0d89467de6", "html_url": "https://github.com/rust-lang/rust/commit/7cc527770d1270921647a4324cb30d0d89467de6"}], "stats": {"total": 184, "additions": 121, "deletions": 63}, "files": [{"sha": "c4de95c60bff5f624178305e29d14cc76c1424aa", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 68, "deletions": 32, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=f686885a14fff16ddf984b08fb0d9ded07e66f1c", "patch": "@@ -16,8 +16,8 @@\n //! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html\n \n use infer::canonical::{\n-    Canonical, CanonicalTyVarKind, CanonicalVarInfo, CanonicalVarKind, CanonicalVarValues,\n-    Canonicalized,\n+    Canonical, CanonicalTyVarKind, CanonicalVarInfo, CanonicalVarKind, Canonicalized,\n+    SmallCanonicalVarValues,\n };\n use infer::InferCtxt;\n use std::sync::atomic::Ordering;\n@@ -26,7 +26,8 @@ use ty::subst::Kind;\n use ty::{self, CanonicalVar, Lift, Slice, Ty, TyCtxt, TypeFlags};\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::small_vec::SmallVec;\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// Canonicalizes a query value `V`. When we canonicalize a query,\n@@ -47,7 +48,8 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     pub fn canonicalize_query<V>(\n         &self,\n         value: &V,\n-    ) -> (Canonicalized<'gcx, V>, CanonicalVarValues<'tcx>)\n+        var_values: &mut SmallCanonicalVarValues<'tcx>\n+    ) -> Canonicalized<'gcx, V>\n     where\n         V: TypeFoldable<'tcx> + Lift<'gcx>,\n     {\n@@ -65,6 +67,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 static_region: true,\n                 other_free_regions: true,\n             },\n+            var_values,\n         )\n     }\n \n@@ -96,10 +99,11 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     pub fn canonicalize_response<V>(\n         &self,\n         value: &V,\n-    ) -> (Canonicalized<'gcx, V>, CanonicalVarValues<'tcx>)\n+    ) -> Canonicalized<'gcx, V>\n     where\n         V: TypeFoldable<'tcx> + Lift<'gcx>,\n     {\n+        let mut var_values = SmallVec::new();\n         Canonicalizer::canonicalize(\n             value,\n             Some(self),\n@@ -108,6 +112,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 static_region: false,\n                 other_free_regions: false,\n             },\n+            &mut var_values\n         )\n     }\n \n@@ -123,7 +128,8 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     pub fn canonicalize_hr_query_hack<V>(\n         &self,\n         value: &V,\n-    ) -> (Canonicalized<'gcx, V>, CanonicalVarValues<'tcx>)\n+        var_values: &mut SmallCanonicalVarValues<'tcx>\n+    ) -> Canonicalized<'gcx, V>\n     where\n         V: TypeFoldable<'tcx> + Lift<'gcx>,\n     {\n@@ -141,6 +147,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 static_region: false,\n                 other_free_regions: true,\n             },\n+            var_values\n         )\n     }\n }\n@@ -163,9 +170,11 @@ impl CanonicalizeRegionMode {\n struct Canonicalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    variables: IndexVec<CanonicalVar, CanonicalVarInfo>,\n+    variables: SmallVec<[CanonicalVarInfo; 8]>,\n+    var_values: &'cx mut SmallCanonicalVarValues<'tcx>,\n+    // Note that indices is only used once `var_values` is big enough to be\n+    // heap-allocated.\n     indices: FxHashMap<Kind<'tcx>, CanonicalVar>,\n-    var_values: IndexVec<CanonicalVar, Kind<'tcx>>,\n     canonicalize_region_mode: CanonicalizeRegionMode,\n     needs_canonical_flags: TypeFlags,\n }\n@@ -295,7 +304,8 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n         infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n         tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n         canonicalize_region_mode: CanonicalizeRegionMode,\n-    ) -> (Canonicalized<'gcx, V>, CanonicalVarValues<'tcx>)\n+        var_values: &'cx mut SmallCanonicalVarValues<'tcx>\n+    ) -> Canonicalized<'gcx, V>\n     where\n         V: TypeFoldable<'tcx> + Lift<'gcx>,\n     {\n@@ -320,20 +330,17 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n                 variables: Slice::empty(),\n                 value: out_value,\n             };\n-            let values = CanonicalVarValues {\n-                var_values: IndexVec::default(),\n-            };\n-            return (canon_value, values);\n+            return canon_value;\n         }\n \n         let mut canonicalizer = Canonicalizer {\n             infcx,\n             tcx,\n             canonicalize_region_mode,\n             needs_canonical_flags,\n-            variables: IndexVec::default(),\n+            variables: SmallVec::new(),\n+            var_values,\n             indices: FxHashMap::default(),\n-            var_values: IndexVec::default(),\n         };\n         let out_value = value.fold_with(&mut canonicalizer);\n \n@@ -348,16 +355,12 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n             )\n         });\n \n-        let canonical_variables = tcx.intern_canonical_var_infos(&canonicalizer.variables.raw);\n+        let canonical_variables = tcx.intern_canonical_var_infos(&canonicalizer.variables);\n \n-        let canonical_value = Canonical {\n+        Canonical {\n             variables: canonical_variables,\n             value: out_value,\n-        };\n-        let canonical_var_values = CanonicalVarValues {\n-            var_values: canonicalizer.var_values,\n-        };\n-        (canonical_value, canonical_var_values)\n+        }\n     }\n \n     /// Creates a canonical variable replacing `kind` from the input,\n@@ -366,21 +369,54 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n     /// potentially a free region).\n     fn canonical_var(&mut self, info: CanonicalVarInfo, kind: Kind<'tcx>) -> CanonicalVar {\n         let Canonicalizer {\n-            indices,\n             variables,\n             var_values,\n+            indices,\n             ..\n         } = self;\n \n-        indices\n-            .entry(kind)\n-            .or_insert_with(|| {\n-                let cvar1 = variables.push(info);\n-                let cvar2 = var_values.push(kind);\n-                assert_eq!(cvar1, cvar2);\n-                cvar1\n-            })\n-            .clone()\n+        // This code is hot. `variables` and `var_values` are usually small\n+        // (fewer than 8 elements ~95% of the time). They are SmallVec's to\n+        // avoid allocations in those cases. We also don't use `indices` to\n+        // determine if a kind has been seen before until the limit of 8 has\n+        // been exceeded, to also avoid allocations for `indices`.\n+        if var_values.is_array() {\n+            // `var_values` is stack-allocated. `indices` isn't used yet. Do a\n+            // direct linear search of `var_values`.\n+            if let Some(idx) = var_values.iter().position(|&k| k == kind) {\n+                // `kind` is already present in `var_values`.\n+                CanonicalVar::new(idx)\n+            } else {\n+                // `kind` isn't present in `var_values`. Append it. Likewise\n+                // for `info` and `variables`.\n+                variables.push(info);\n+                var_values.push(kind);\n+                assert_eq!(variables.len(), var_values.len());\n+\n+                // If `var_values` has become big enough to be heap-allocated,\n+                // fill up `indices` to facilitate subsequent lookups.\n+                if !var_values.is_array() {\n+                    assert!(indices.is_empty());\n+                    *indices =\n+                        var_values.iter()\n+                            .enumerate()\n+                            .map(|(i, &kind)| (kind, CanonicalVar::new(i)))\n+                            .collect();\n+                }\n+                // The cv is the index of the appended element.\n+                CanonicalVar::new(var_values.len() - 1)\n+            }\n+        } else {\n+            // `var_values` is large. Do a hashmap search via `indices`.\n+            *indices\n+                .entry(kind)\n+                .or_insert_with(|| {\n+                    variables.push(info);\n+                    var_values.push(kind);\n+                    assert_eq!(variables.len(), var_values.len());\n+                    CanonicalVar::new(variables.len() - 1)\n+                })\n+        }\n     }\n \n     /// Given a type variable `ty_var` of the given kind, first check"}, {"sha": "958b3391060501c3b711399a47261651991045d2", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=f686885a14fff16ddf984b08fb0d9ded07e66f1c", "patch": "@@ -33,6 +33,7 @@\n \n use infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin};\n use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::small_vec::SmallVec;\n use rustc_data_structures::sync::Lrc;\n use serialize::UseSpecializedDecodable;\n use std::ops::Index;\n@@ -74,6 +75,10 @@ pub struct CanonicalVarValues<'tcx> {\n     pub var_values: IndexVec<CanonicalVar, Kind<'tcx>>,\n }\n \n+/// Like CanonicalVarValues, but for use in places where a SmallVec is\n+/// appropriate.\n+pub type SmallCanonicalVarValues<'tcx> = SmallVec<[Kind<'tcx>; 8]>;\n+\n /// Information about a canonical variable that is included with the\n /// canonical value. This is sufficient information for code to create\n /// a copy of the canonical value in some other inference context,\n@@ -281,10 +286,6 @@ BraceStructLiftImpl! {\n }\n \n impl<'tcx> CanonicalVarValues<'tcx> {\n-    fn iter<'a>(&'a self) -> impl Iterator<Item = Kind<'tcx>> + 'a {\n-        self.var_values.iter().cloned()\n-    }\n-\n     fn len(&self) -> usize {\n         self.var_values.len()\n     }"}, {"sha": "02684d962ba8ddb98f6eef97629836fb13278a27", "filename": "src/librustc/infer/canonical/query_result.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs?ref=f686885a14fff16ddf984b08fb0d9ded07e66f1c", "patch": "@@ -19,7 +19,7 @@\n \n use infer::canonical::substitute::substitute_value;\n use infer::canonical::{Canonical, CanonicalVarKind, CanonicalVarValues, CanonicalizedQueryResult,\n-                       Certainty, QueryRegionConstraint, QueryResult};\n+                       Certainty, QueryRegionConstraint, QueryResult, SmallCanonicalVarValues};\n use infer::region_constraints::{Constraint, RegionConstraintData};\n use infer::InferCtxtBuilder;\n use infer::{InferCtxt, InferOk, InferResult, RegionObligation};\n@@ -103,7 +103,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         T: Debug + Lift<'gcx> + TypeFoldable<'tcx>,\n     {\n         let query_result = self.make_query_result(inference_vars, answer, fulfill_cx)?;\n-        let (canonical_result, _) = self.canonicalize_response(&query_result);\n+        let canonical_result = self.canonicalize_response(&query_result);\n \n         debug!(\n             \"make_canonicalized_query_result: canonical_result = {:#?}\",\n@@ -186,7 +186,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        original_values: &CanonicalVarValues<'tcx>,\n+        original_values: &SmallCanonicalVarValues<'tcx>,\n         query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n     ) -> InferResult<'tcx, R>\n     where\n@@ -252,7 +252,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        original_values: &CanonicalVarValues<'tcx>,\n+        original_values: &SmallCanonicalVarValues<'tcx>,\n         query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n         output_query_region_constraints: &mut Vec<QueryRegionConstraint<'tcx>>,\n     ) -> InferResult<'tcx, R>\n@@ -274,10 +274,11 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         // variable...\n         let mut obligations = vec![];\n \n-        for (index, original_value) in original_values.var_values.iter_enumerated() {\n+        for (index, original_value) in original_values.iter().enumerate() {\n             // ...with the value `v_r` of that variable from the query.\n             let result_value = query_result\n-                .substitute_projected(self.tcx, &result_subst, |v| &v.var_values[index]);\n+                .substitute_projected(self.tcx, &result_subst,\n+                                      |v| &v.var_values[CanonicalVar::new(index)]);\n             match (original_value.unpack(), result_value.unpack()) {\n                 (UnpackedKind::Lifetime(ty::ReErased), UnpackedKind::Lifetime(ty::ReErased)) => {\n                     // no action needed\n@@ -341,7 +342,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        original_values: &CanonicalVarValues<'tcx>,\n+        original_values: &SmallCanonicalVarValues<'tcx>,\n         query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n     ) -> InferResult<'tcx, CanonicalVarValues<'tcx>>\n     where\n@@ -382,7 +383,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     fn query_result_substitution_guess<R>(\n         &self,\n         cause: &ObligationCause<'tcx>,\n-        original_values: &CanonicalVarValues<'tcx>,\n+        original_values: &SmallCanonicalVarValues<'tcx>,\n         query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n     ) -> CanonicalVarValues<'tcx>\n     where\n@@ -418,14 +419,14 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                     // e.g., here `result_value` might be `?0` in the example above...\n                     if let ty::TyInfer(ty::InferTy::CanonicalTy(index)) = result_value.sty {\n                         // in which case we would set `canonical_vars[0]` to `Some(?U)`.\n-                        opt_values[index] = Some(original_value);\n+                        opt_values[index] = Some(*original_value);\n                     }\n                 }\n                 UnpackedKind::Lifetime(result_value) => {\n                     // e.g., here `result_value` might be `'?1` in the example above...\n                     if let &ty::RegionKind::ReCanonical(index) = result_value {\n                         // in which case we would set `canonical_vars[0]` to `Some('static)`.\n-                        opt_values[index] = Some(original_value);\n+                        opt_values[index] = Some(*original_value);\n                     }\n                 }\n             }\n@@ -459,7 +460,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        original_values: &CanonicalVarValues<'tcx>,\n+        original_values: &SmallCanonicalVarValues<'tcx>,\n         result_subst: &CanonicalVarValues<'tcx>,\n         query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n     ) -> InferResult<'tcx, ()>\n@@ -522,13 +523,13 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        variables1: &CanonicalVarValues<'tcx>,\n+        variables1: &SmallCanonicalVarValues<'tcx>,\n         variables2: impl Fn(CanonicalVar) -> Kind<'tcx>,\n     ) -> InferResult<'tcx, ()> {\n         self.commit_if_ok(|_| {\n             let mut obligations = vec![];\n-            for (index, value1) in variables1.var_values.iter_enumerated() {\n-                let value2 = variables2(index);\n+            for (index, value1) in variables1.iter().enumerate() {\n+                let value2 = variables2(CanonicalVar::new(index));\n \n                 match (value1.unpack(), value2.unpack()) {\n                     (UnpackedKind::Type(v1), UnpackedKind::Type(v2)) => {"}, {"sha": "679829f43c529d6c64093f1973f0d7c00d8ad15c", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=f686885a14fff16ddf984b08fb0d9ded07e66f1c", "patch": "@@ -46,7 +46,7 @@ impl<'tcx, V> Canonical<'tcx, V> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        assert_eq!(self.variables.len(), var_values.var_values.len());\n+        assert_eq!(self.variables.len(), var_values.len());\n         let value = projection_fn(&self.value);\n         substitute_value(tcx, var_values, value)\n     }"}, {"sha": "73a9ff4e483b2756c54d70878882a32f7672df67", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=f686885a14fff16ddf984b08fb0d9ded07e66f1c", "patch": "@@ -10,6 +10,7 @@\n \n use infer::at::At;\n use infer::InferOk;\n+use rustc_data_structures::small_vec::SmallVec;\n use std::iter::FromIterator;\n use syntax::codemap::Span;\n use ty::subst::Kind;\n@@ -50,7 +51,8 @@ impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n         }\n \n         let gcx = tcx.global_tcx();\n-        let (c_ty, orig_values) = self.infcx.canonicalize_query(&self.param_env.and(ty));\n+        let mut orig_values = SmallVec::new();\n+        let c_ty = self.infcx.canonicalize_query(&self.param_env.and(ty), &mut orig_values);\n         let span = self.cause.span;\n         debug!(\"c_ty = {:?}\", c_ty);\n         match &gcx.dropck_outlives(c_ty) {"}, {"sha": "93fcadceb1655a7af6cd1166fc10d7f622d0f124", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=f686885a14fff16ddf984b08fb0d9ded07e66f1c", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use infer::InferCtxt;\n+use rustc_data_structures::small_vec::SmallVec;\n use traits::{EvaluationResult, PredicateObligation, SelectionContext,\n              TraitQueryMode, OverflowError};\n \n@@ -38,8 +39,9 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> EvaluationResult {\n-        let (c_pred, _) =\n-            self.canonicalize_query(&obligation.param_env.and(obligation.predicate));\n+        let mut _orig_values = SmallVec::new();\n+        let c_pred = self.canonicalize_query(&obligation.param_env.and(obligation.predicate),\n+                                             &mut _orig_values);\n         // Run canonical query. If overflow occurs, rerun from scratch but this time\n         // in standard trait query mode so that overflow is handled appropriately\n         // within `SelectionContext`."}, {"sha": "2203aefa31468be7b0343837158975bd5eccaec5", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=f686885a14fff16ddf984b08fb0d9ded07e66f1c", "patch": "@@ -15,6 +15,7 @@\n use infer::{InferCtxt, InferOk};\n use infer::at::At;\n use mir::interpret::{GlobalId, ConstValue};\n+use rustc_data_structures::small_vec::SmallVec;\n use traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n use traits::project::Normalized;\n use ty::{self, Ty, TyCtxt};\n@@ -147,8 +148,9 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n \n                 let gcx = self.infcx.tcx.global_tcx();\n \n-                let (c_data, orig_values) =\n-                    self.infcx.canonicalize_query(&self.param_env.and(*data));\n+                let mut orig_values = SmallVec::new();\n+                let c_data =\n+                    self.infcx.canonicalize_query(&self.param_env.and(*data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n                 debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n                 match gcx.normalize_projection_ty(c_data) {"}, {"sha": "be5e2838963ee2c906cd448b8f245ef8a8714a85", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=f686885a14fff16ddf984b08fb0d9ded07e66f1c", "patch": "@@ -11,6 +11,7 @@\n use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResult, QueryRegionConstraint,\n                        QueryResult};\n use infer::{InferCtxt, InferOk};\n+use rustc_data_structures::small_vec::SmallVec;\n use std::fmt;\n use std::rc::Rc;\n use traits::query::Fallible;\n@@ -103,7 +104,9 @@ pub trait QueryTypeOp<'gcx: 'tcx, 'tcx>:\n         // `canonicalize_hr_query_hack` here because of things\n         // like the subtype query, which go awry around\n         // `'static` otherwise.\n-        let (canonical_self, canonical_var_values) = infcx.canonicalize_hr_query_hack(&query_key);\n+        let mut canonical_var_values = SmallVec::new();\n+        let canonical_self =\n+            infcx.canonicalize_hr_query_hack(&query_key, &mut canonical_var_values);\n         let canonical_result = Self::perform_query(infcx.tcx, canonical_self)?;\n         let canonical_result = Self::shrink_to_tcx_lifetime(&canonical_result);\n "}, {"sha": "2e8cca3f4f9bda0e62bf4d8e7752138b7543b953", "filename": "src/librustc_data_structures/accumulate_vec.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Faccumulate_vec.rs?ref=f686885a14fff16ddf984b08fb0d9ded07e66f1c", "patch": "@@ -46,6 +46,13 @@ impl<A: Array> AccumulateVec<A> {\n         AccumulateVec::Array(ArrayVec::new())\n     }\n \n+    pub fn is_array(&self) -> bool {\n+        match self {\n+            AccumulateVec::Array(..) => true,\n+            AccumulateVec::Heap(..) => false,\n+        }\n+    }\n+\n     pub fn one(el: A::Element) -> Self {\n         iter::once(el).collect()\n     }"}, {"sha": "83eb54fade177faaf7d8eb852de19ea03f2587ec", "filename": "src/librustc_data_structures/small_vec.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsmall_vec.rs?ref=f686885a14fff16ddf984b08fb0d9ded07e66f1c", "patch": "@@ -50,6 +50,10 @@ impl<A: Array> SmallVec<A> {\n         SmallVec(AccumulateVec::new())\n     }\n \n+    pub fn is_array(&self) -> bool {\n+        self.0.is_array()\n+    }\n+\n     pub fn with_capacity(cap: usize) -> Self {\n         let mut vec = SmallVec::new();\n         vec.reserve(cap);"}, {"sha": "b0f0b105f3ecb92f3286cd0f9309be2612e59a37", "filename": "src/librustc_traits/chalk_context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc_traits%2Fchalk_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc_traits%2Fchalk_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context.rs?ref=f686885a14fff16ddf984b08fb0d9ded07e66f1c", "patch": "@@ -25,6 +25,7 @@ use rustc::traits::{\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::subst::Kind;\n use rustc::ty::{self, TyCtxt};\n+use rustc_data_structures::small_vec::SmallVec;\n \n use std::fmt::{self, Debug};\n use std::marker::PhantomData;\n@@ -388,24 +389,23 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         &mut self,\n         value: &ty::ParamEnvAnd<'tcx, Goal<'tcx>>,\n     ) -> Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>> {\n-        self.infcx.canonicalize_query(value).0\n+        let mut _orig_values = SmallVec::new();\n+        self.infcx.canonicalize_query(value, &mut _orig_values)\n     }\n \n     fn canonicalize_ex_clause(\n         &mut self,\n         value: &ChalkExClause<'tcx>,\n     ) -> Canonical<'gcx, ChalkExClause<'gcx>> {\n-        self.infcx.canonicalize_response(value).0\n+        self.infcx.canonicalize_response(value)\n     }\n \n     fn canonicalize_constrained_subst(\n         &mut self,\n         subst: CanonicalVarValues<'tcx>,\n         constraints: Vec<QueryRegionConstraint<'tcx>>,\n     ) -> Canonical<'gcx, ConstrainedSubst<'gcx>> {\n-        self.infcx\n-            .canonicalize_response(&ConstrainedSubst { subst, constraints })\n-            .0\n+        self.infcx.canonicalize_response(&ConstrainedSubst { subst, constraints })\n     }\n \n     fn u_canonicalize_goal("}, {"sha": "ebf16c5938d743fd7017414a78455636598b1c89", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f686885a14fff16ddf984b08fb0d9ded07e66f1c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f686885a14fff16ddf984b08fb0d9ded07e66f1c", "patch": "@@ -942,7 +942,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n             Some(ref ty) => {\n                 let o_ty = self.fcx.to_ty(&ty);\n \n-                let (c_ty, _orig_values) = self.fcx.inh.infcx.canonicalize_response(&o_ty);\n+                let c_ty = self.fcx.inh.infcx.canonicalize_response(&o_ty);\n                 debug!(\"visit_local: ty.hir_id={:?} o_ty={:?} c_ty={:?}\", ty.hir_id, o_ty, c_ty);\n                 self.fcx.tables.borrow_mut().user_provided_tys_mut().insert(ty.hir_id, c_ty);\n "}]}