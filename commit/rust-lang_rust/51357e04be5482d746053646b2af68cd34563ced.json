{"sha": "51357e04be5482d746053646b2af68cd34563ced", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxMzU3ZTA0YmU1NDgyZDc0NjA1MzY0NmIyYWY2OGNkMzQ1NjNjZWQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-08T01:33:41Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-08T01:33:41Z"}, "message": "rollup merge of #20665: nikomatsakis/assoc-types-method-dispatch-projection\n\nConflicts:\n\tsrc/librustc/middle/ty.rs", "tree": {"sha": "3b22879bd7a824ab8fc274d45047b12ec95fbbe3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b22879bd7a824ab8fc274d45047b12ec95fbbe3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51357e04be5482d746053646b2af68cd34563ced", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51357e04be5482d746053646b2af68cd34563ced", "html_url": "https://github.com/rust-lang/rust/commit/51357e04be5482d746053646b2af68cd34563ced", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51357e04be5482d746053646b2af68cd34563ced/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6afda64d0d2106d4afa8ebb8e0cbc504a62977be", "url": "https://api.github.com/repos/rust-lang/rust/commits/6afda64d0d2106d4afa8ebb8e0cbc504a62977be", "html_url": "https://github.com/rust-lang/rust/commit/6afda64d0d2106d4afa8ebb8e0cbc504a62977be"}, {"sha": "ab02f9e42a15f359bc3c732311deee678fe2485d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab02f9e42a15f359bc3c732311deee678fe2485d", "html_url": "https://github.com/rust-lang/rust/commit/ab02f9e42a15f359bc3c732311deee678fe2485d"}], "stats": {"total": 267, "additions": 226, "deletions": 41}, "files": [{"sha": "4a4328fa98bafbc059da8edf2e5223be23fdb986", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51357e04be5482d746053646b2af68cd34563ced/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51357e04be5482d746053646b2af68cd34563ced/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=51357e04be5482d746053646b2af68cd34563ced", "patch": "@@ -427,6 +427,16 @@ impl<'tcx> Combineable<'tcx> for ty::TraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> Combineable<'tcx> for Ty<'tcx> {\n+    fn combine<C:Combine<'tcx>>(combiner: &C,\n+                                a: &Ty<'tcx>,\n+                                b: &Ty<'tcx>)\n+                                -> cres<'tcx, Ty<'tcx>>\n+    {\n+        combiner.tys(*a, *b)\n+    }\n+}\n+\n impl<'tcx> Combineable<'tcx> for ty::ProjectionPredicate<'tcx> {\n     fn combine<C:Combine<'tcx>>(combiner: &C,\n                                 a: &ty::ProjectionPredicate<'tcx>,"}, {"sha": "57893ec97a2186fd673adc2e8526440005a41574", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/51357e04be5482d746053646b2af68cd34563ced/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51357e04be5482d746053646b2af68cd34563ced/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=51357e04be5482d746053646b2af68cd34563ced", "patch": "@@ -39,7 +39,7 @@ use util::ppaux::{ty_to_string};\n use util::ppaux::{Repr, UserString};\n \n use self::coercion::Coerce;\n-use self::combine::{Combine, CombineFields};\n+use self::combine::{Combine, Combineable, CombineFields};\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n use self::equate::Equate;\n use self::sub::Sub;\n@@ -360,17 +360,9 @@ pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n     })\n }\n \n-pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                             a: Ty<'tcx>, b: Ty<'tcx>)\n-                             -> ures<'tcx> {\n-    debug!(\"can_mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    cx.probe(|_| {\n-        let trace = TypeTrace {\n-            origin: Misc(codemap::DUMMY_SP),\n-            values: Types(expected_found(true, a, b))\n-        };\n-        cx.equate(true, trace).tys(a, b)\n-    }).to_ures()\n+pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> ures<'tcx>\n+{\n+    cx.can_equate(&a, &b)\n }\n \n pub fn mk_subr<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n@@ -1072,6 +1064,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         self.region_vars.verify_generic_bound(origin, kind, a, bs);\n     }\n+\n+    pub fn can_equate<T>(&self, a: &T, b: &T) -> ures<'tcx>\n+        where T : Combineable<'tcx> + Repr<'tcx>\n+    {\n+        debug!(\"can_equate({}, {})\", a.repr(self.tcx), b.repr(self.tcx));\n+        self.probe(|_| {\n+            // Gin up a dummy trace, since this won't be committed\n+            // anyhow. We should make this typetrace stuff more\n+            // generic so we don't have to do anything quite this\n+            // terrible.\n+            let e = self.tcx.types.err;\n+            let trace = TypeTrace { origin: Misc(codemap::DUMMY_SP),\n+                                    values: Types(expected_found(true, e, e)) };\n+            let eq = self.equate(true, trace);\n+            Combineable::combine(&eq, a, b)\n+        }).to_ures()\n+    }\n }\n \n impl<'tcx> TypeTrace<'tcx> {"}, {"sha": "5fbae6c359dc147661c70d544267c57b9263189c", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51357e04be5482d746053646b2af68cd34563ced/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51357e04be5482d746053646b2af68cd34563ced/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=51357e04be5482d746053646b2af68cd34563ced", "patch": "@@ -394,7 +394,7 @@ impl<T> VecPerParamSpace<T> {\n         self.content.as_slice()\n     }\n \n-    pub fn to_vec(self) -> Vec<T> {\n+    pub fn into_vec(self) -> Vec<T> {\n         self.content\n     }\n "}, {"sha": "aaf5df4ce4a56ab5dd69f50da09484953be556c3", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51357e04be5482d746053646b2af68cd34563ced/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51357e04be5482d746053646b2af68cd34563ced/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=51357e04be5482d746053646b2af68cd34563ced", "patch": "@@ -649,7 +649,7 @@ fn confirm_candidate<'cx,'tcx>(\n             }\n \n             match impl_ty {\n-                Some(ty) => (ty, impl_vtable.nested.to_vec()),\n+                Some(ty) => (ty, impl_vtable.nested.into_vec()),\n                 None => {\n                     // This means that the impl is missing a\n                     // definition for the associated type. This error"}, {"sha": "c5ed9adb1bc15685cdec6f833dccd3b3bc6b312c", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51357e04be5482d746053646b2af68cd34563ced/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51357e04be5482d746053646b2af68cd34563ced/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=51357e04be5482d746053646b2af68cd34563ced", "patch": "@@ -835,7 +835,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                bounds.repr(self.tcx()));\n \n         let matching_bound =\n-            util::elaborate_predicates(self.tcx(), bounds.predicates.to_vec())\n+            util::elaborate_predicates(self.tcx(), bounds.predicates.into_vec())\n             .filter_to_traits()\n             .find(\n                 |bound| self.infcx.probe("}, {"sha": "cc119e2fb4c34ad9ae5237d867c92b1da22b2e6a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/51357e04be5482d746053646b2af68cd34563ced/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51357e04be5482d746053646b2af68cd34563ced/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=51357e04be5482d746053646b2af68cd34563ced", "patch": "@@ -1498,10 +1498,12 @@ impl<'tcx> PolyTraitRef<'tcx> {\n     }\n \n     pub fn substs(&self) -> &'tcx Substs<'tcx> {\n+        // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n         self.0.substs\n     }\n \n     pub fn input_types(&self) -> &[Ty<'tcx>] {\n+        // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n         self.0.input_types()\n     }\n \n@@ -6977,6 +6979,13 @@ impl<'tcx> RegionEscape for Ty<'tcx> {\n     }\n }\n \n+impl<'tcx> RegionEscape for Substs<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.types.has_regions_escaping_depth(depth) ||\n+            self.regions.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n impl<'tcx,T:RegionEscape> RegionEscape for VecPerParamSpace<T> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.iter_enumerated().any(|(space, _, t)| {"}, {"sha": "dc4d6c9a826c9912d0b6fb6994016a6f56233d9a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 105, "deletions": 26, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/51357e04be5482d746053646b2af68cd34563ced/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51357e04be5482d746053646b2af68cd34563ced/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=51357e04be5482d746053646b2af68cd34563ced", "patch": "@@ -18,7 +18,7 @@ use middle::fast_reject;\n use middle::subst;\n use middle::subst::Subst;\n use middle::traits;\n-use middle::ty::{self, Ty, ToPolyTraitRef};\n+use middle::ty::{self, RegionEscape, Ty, ToPolyTraitRef};\n use middle::ty_fold::TypeFoldable;\n use middle::infer;\n use middle::infer::InferCtxt;\n@@ -62,6 +62,7 @@ enum CandidateKind<'tcx> {\n                            subst::Substs<'tcx>, MethodIndex),\n     UnboxedClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n     WhereClauseCandidate(ty::PolyTraitRef<'tcx>, MethodIndex),\n+    ProjectionCandidate(ast::DefId, MethodIndex),\n }\n \n pub struct Pick<'tcx> {\n@@ -309,18 +310,20 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // argument type like `&Trait`.\n         let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(), self_ty);\n         self.elaborate_bounds(&[trait_ref.clone()], false, |this, new_trait_ref, m, method_num| {\n+            let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n+\n             let vtable_index =\n                 traits::get_vtable_index_of_object_method(tcx,\n                                                           trait_ref.clone(),\n-                                                          new_trait_ref.def_id(),\n+                                                          new_trait_ref.def_id,\n                                                           method_num);\n \n-            let xform_self_ty = this.xform_self_ty(&m, new_trait_ref.substs());\n+            let xform_self_ty = this.xform_self_ty(&m, new_trait_ref.substs);\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 method_ty: m,\n-                kind: ObjectCandidate(new_trait_ref.def_id(), method_num, vtable_index)\n+                kind: ObjectCandidate(new_trait_ref.def_id, method_num, vtable_index)\n             });\n         });\n     }\n@@ -353,34 +356,37 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             })\n             .collect();\n \n-        self.elaborate_bounds(bounds.as_slice(), true, |this, trait_ref, m, method_num| {\n+        self.elaborate_bounds(bounds.as_slice(), true, |this, poly_trait_ref, m, method_num| {\n+            let trait_ref =\n+                this.erase_late_bound_regions(&poly_trait_ref);\n+\n             let xform_self_ty =\n-                this.xform_self_ty(&m, trait_ref.substs());\n+                this.xform_self_ty(&m, trait_ref.substs);\n \n             debug!(\"found match: trait_ref={} substs={} m={}\",\n                    trait_ref.repr(this.tcx()),\n-                   trait_ref.substs().repr(this.tcx()),\n+                   trait_ref.substs.repr(this.tcx()),\n                    m.repr(this.tcx()));\n             assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n-                       trait_ref.substs().types.get_slice(subst::TypeSpace).len());\n+                       trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n             assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n-                       trait_ref.substs().regions().get_slice(subst::TypeSpace).len());\n+                       trait_ref.substs.regions().get_slice(subst::TypeSpace).len());\n             assert_eq!(m.generics.types.get_slice(subst::SelfSpace).len(),\n-                       trait_ref.substs().types.get_slice(subst::SelfSpace).len());\n+                       trait_ref.substs.types.get_slice(subst::SelfSpace).len());\n             assert_eq!(m.generics.regions.get_slice(subst::SelfSpace).len(),\n-                       trait_ref.substs().regions().get_slice(subst::SelfSpace).len());\n+                       trait_ref.substs.regions().get_slice(subst::SelfSpace).len());\n \n             // Because this trait derives from a where-clause, it\n             // should not contain any inference variables or other\n             // artifacts. This means it is safe to put into the\n             // `WhereClauseCandidate` and (eventually) into the\n             // `WhereClausePick`.\n-            assert!(trait_ref.substs().types.iter().all(|&t| !ty::type_needs_infer(t)));\n+            assert!(trait_ref.substs.types.iter().all(|&t| !ty::type_needs_infer(t)));\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 method_ty: m,\n-                kind: WhereClauseCandidate(trait_ref, method_num)\n+                kind: WhereClauseCandidate(poly_trait_ref, method_num)\n             });\n         });\n     }\n@@ -474,6 +480,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                  method.clone(),\n                                                  matching_index);\n \n+        self.assemble_projection_candidates(trait_def_id,\n+                                            method.clone(),\n+                                            matching_index);\n+\n         self.assemble_where_clause_candidates(trait_def_id,\n                                               method,\n                                               matching_index);\n@@ -603,6 +613,64 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n     }\n \n+    fn assemble_projection_candidates(&mut self,\n+                                      trait_def_id: ast::DefId,\n+                                      method: Rc<ty::Method<'tcx>>,\n+                                      method_index: uint)\n+    {\n+        debug!(\"assemble_projection_candidates(\\\n+               trait_def_id={}, \\\n+               method={}, \\\n+               method_index={})\",\n+               trait_def_id.repr(self.tcx()),\n+               method.repr(self.tcx()),\n+               method_index);\n+\n+        for step in self.steps.iter() {\n+            debug!(\"assemble_projection_candidates: step={}\",\n+                   step.repr(self.tcx()));\n+\n+            let projection_trait_ref = match step.self_ty.sty {\n+                ty::ty_projection(ref data) => &data.trait_ref,\n+                _ => continue,\n+            };\n+\n+            debug!(\"assemble_projection_candidates: projection_trait_ref={}\",\n+                   projection_trait_ref.repr(self.tcx()));\n+\n+            let trait_def = ty::lookup_trait_def(self.tcx(), projection_trait_ref.def_id);\n+            let bounds = trait_def.generics.to_bounds(self.tcx(), projection_trait_ref.substs);\n+            let predicates = bounds.predicates.into_vec();\n+            debug!(\"assemble_projection_candidates: predicates={}\",\n+                   predicates.repr(self.tcx()));\n+            for poly_bound in\n+                traits::elaborate_predicates(self.tcx(), predicates)\n+                .filter_map(|p| p.to_opt_poly_trait_ref())\n+                .filter(|b| b.def_id() == trait_def_id)\n+            {\n+                let bound = self.erase_late_bound_regions(&poly_bound);\n+\n+                debug!(\"assemble_projection_candidates: projection_trait_ref={} bound={}\",\n+                       projection_trait_ref.repr(self.tcx()),\n+                       bound.repr(self.tcx()));\n+\n+                if self.infcx().can_equate(&step.self_ty, &bound.self_ty()).is_ok() {\n+                    let xform_self_ty = self.xform_self_ty(&method, bound.substs);\n+\n+                    debug!(\"assemble_projection_candidates: bound={} xform_self_ty={}\",\n+                           bound.repr(self.tcx()),\n+                           xform_self_ty.repr(self.tcx()));\n+\n+                    self.extension_candidates.push(Candidate {\n+                        xform_self_ty: xform_self_ty,\n+                        method_ty: method.clone(),\n+                        kind: ProjectionCandidate(trait_def_id, method_index)\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n     fn assemble_where_clause_candidates(&mut self,\n                                         trait_def_id: ast::DefId,\n                                         method_ty: Rc<ty::Method<'tcx>>,\n@@ -611,14 +679,14 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={})\",\n                trait_def_id.repr(self.tcx()));\n \n-        // Check whether there are any where-clauses pertaining to this trait.\n         let caller_predicates =\n             self.fcx.inh.param_env.caller_bounds.predicates.as_slice().to_vec();\n-        for bound in traits::elaborate_predicates(self.tcx(), caller_predicates)\n-                     .filter_map(|p| p.to_opt_poly_trait_ref())\n-                     .filter(|b| b.def_id() == trait_def_id)\n+        for poly_bound in traits::elaborate_predicates(self.tcx(), caller_predicates)\n+                          .filter_map(|p| p.to_opt_poly_trait_ref())\n+                          .filter(|b| b.def_id() == trait_def_id)\n         {\n-            let xform_self_ty = self.xform_self_ty(&method_ty, bound.substs());\n+            let bound = self.erase_late_bound_regions(&poly_bound);\n+            let xform_self_ty = self.xform_self_ty(&method_ty, bound.substs);\n \n             debug!(\"assemble_where_clause_candidates: bound={} xform_self_ty={}\",\n                    bound.repr(self.tcx()),\n@@ -627,7 +695,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 method_ty: method_ty.clone(),\n-                kind: WhereClauseCandidate(bound, method_index)\n+                kind: WhereClauseCandidate(poly_bound, method_index)\n             });\n         }\n     }\n@@ -829,6 +897,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                         norm_obligations.iter().all(|o| selcx.evaluate_obligation(o))\n                 }\n \n+                ProjectionCandidate(..) |\n                 ObjectCandidate(..) |\n                 UnboxedClosureCandidate(..) |\n                 WhereClauseCandidate(..) => {\n@@ -920,6 +989,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                method.fty.sig.0.inputs[0].repr(self.tcx()),\n                substs.repr(self.tcx()));\n \n+        assert!(!substs.has_escaping_regions());\n+\n         // It is possible for type parameters or early-bound lifetimes\n         // to appear in the signature of `self`. The substitutions we\n         // are given do not include type/lifetime parameters for the\n@@ -949,14 +1020,13 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             substs = &placeholder;\n         }\n \n-        // Replace early-bound regions and types.\n-        let xform_self_ty = method.fty.sig.0.inputs[0].subst(self.tcx(), substs);\n+        // Erase any late-bound regions from the method and substitute\n+        // in the values from the substitution.\n+        let xform_self_ty = method.fty.sig.input(0);\n+        let xform_self_ty = self.erase_late_bound_regions(&xform_self_ty);\n+        let xform_self_ty = xform_self_ty.subst(self.tcx(), substs);\n \n-        // Replace late-bound regions bound in the impl or\n-        // where-clause (2 levels of binding) and method (1 level of binding).\n-        self.erase_late_bound_regions(\n-            &self.erase_late_bound_regions(\n-                &ty::Binder(ty::Binder(xform_self_ty))))\n+        xform_self_ty\n     }\n \n     fn impl_substs(&self,\n@@ -1065,6 +1135,9 @@ impl<'tcx> Candidate<'tcx> {\n \n                     WhereClausePick((*trait_ref).clone(), index)\n                 }\n+                ProjectionCandidate(def_id, index) => {\n+                    TraitPick(def_id, index)\n+                }\n             }\n         }\n     }\n@@ -1076,6 +1149,7 @@ impl<'tcx> Candidate<'tcx> {\n             ExtensionImplCandidate(def_id, _, _, _) => ImplSource(def_id),\n             UnboxedClosureCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n             WhereClauseCandidate(ref trait_ref, _) => TraitSource(trait_ref.def_id()),\n+            ProjectionCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n         }\n     }\n \n@@ -1094,6 +1168,9 @@ impl<'tcx> Candidate<'tcx> {\n             WhereClauseCandidate(ref trait_ref, method_num) => {\n                 Some((trait_ref.def_id(), method_num))\n             }\n+            ProjectionCandidate(trait_def_id, method_num) => {\n+                Some((trait_def_id, method_num))\n+            }\n         }\n     }\n }\n@@ -1120,6 +1197,8 @@ impl<'tcx> Repr<'tcx> for CandidateKind<'tcx> {\n                 format!(\"UnboxedClosureCandidate({},{})\", a.repr(tcx), b),\n             WhereClauseCandidate(ref a, ref b) =>\n                 format!(\"WhereClauseCandidate({},{})\", a.repr(tcx), b),\n+            ProjectionCandidate(ref a, ref b) =>\n+                format!(\"ProjectionCandidate({},{})\", a.repr(tcx), b),\n         }\n     }\n }"}, {"sha": "6f72a163981c9d653e480ff4392c5089fa204a7e", "filename": "src/test/run-pass/method-projection.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/51357e04be5482d746053646b2af68cd34563ced/src%2Ftest%2Frun-pass%2Fmethod-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51357e04be5482d746053646b2af68cd34563ced/src%2Ftest%2Frun-pass%2Fmethod-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-projection.rs?ref=51357e04be5482d746053646b2af68cd34563ced", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can use method notation to call methods based on a\n+// projection bound from a trait. Issue #20469.\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+trait MakeString {\n+    fn make_string(&self) -> String;\n+}\n+\n+impl MakeString for int {\n+    fn make_string(&self) -> String {\n+        format!(\"{}\", *self)\n+    }\n+}\n+\n+impl MakeString for uint {\n+    fn make_string(&self) -> String {\n+        format!(\"{}\", *self)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+trait Foo {\n+    type F: MakeString;\n+\n+    fn get(&self) -> &Self::F;\n+}\n+\n+fn foo<F:Foo>(f: &F) -> String {\n+    f.get().make_string()\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+struct SomeStruct {\n+    field: int,\n+}\n+\n+impl Foo for SomeStruct {\n+    type F = int;\n+\n+    fn get(&self) -> &int {\n+        &self.field\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+struct SomeOtherStruct {\n+    field: uint,\n+}\n+\n+impl Foo for SomeOtherStruct {\n+    type F = uint;\n+\n+    fn get(&self) -> &uint {\n+        &self.field\n+    }\n+}\n+\n+fn main() {\n+    let x = SomeStruct { field: 22 };\n+    assert_eq!(foo(&x), format!(\"22\"));\n+\n+    let x = SomeOtherStruct { field: 44 };\n+    assert_eq!(foo(&x), format!(\"44\"));\n+}"}]}