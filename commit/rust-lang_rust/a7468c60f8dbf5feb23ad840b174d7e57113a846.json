{"sha": "a7468c60f8dbf5feb23ad840b174d7e57113a846", "node_id": "C_kwDOAAsO6NoAKGE3NDY4YzYwZjhkYmY1ZmViMjNhZDg0MGIxNzRkN2U1NzExM2E4NDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-20T16:56:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-20T16:56:31Z"}, "message": "Auto merge of #99472 - RalfJung:provenance, r=oli-obk\n\ninterpret: rename Tag/PointerTag to Prov/Provenance\n\nWe were pretty inconsistent with calling this the \"tag\" vs the \"provenance\" of the pointer; I think we should consistently call it \"provenance\".\n\nr? `@oli-obk`", "tree": {"sha": "e0441bd3dc1963d35c0cea39c951bbdee8718d3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0441bd3dc1963d35c0cea39c951bbdee8718d3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7468c60f8dbf5feb23ad840b174d7e57113a846", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7468c60f8dbf5feb23ad840b174d7e57113a846", "html_url": "https://github.com/rust-lang/rust/commit/a7468c60f8dbf5feb23ad840b174d7e57113a846", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7468c60f8dbf5feb23ad840b174d7e57113a846/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14dbfebfa25a0e626ad827526934381b2545cbb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/14dbfebfa25a0e626ad827526934381b2545cbb4", "html_url": "https://github.com/rust-lang/rust/commit/14dbfebfa25a0e626ad827526934381b2545cbb4"}, {"sha": "0ec3269db85938224bdde4834b3a80c0d85b770d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ec3269db85938224bdde4834b3a80c0d85b770d", "html_url": "https://github.com/rust-lang/rust/commit/0ec3269db85938224bdde4834b3a80c0d85b770d"}], "stats": {"total": 1209, "additions": 607, "deletions": 602}, "files": [{"sha": "cc20f05e55612e1661a3f331fc40f2bb89f84efc", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -309,7 +309,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n-        dest: &PlaceTy<'tcx, Self::PointerTag>,\n+        dest: &PlaceTy<'tcx, Self::Provenance>,\n         target: Option<mir::BasicBlock>,\n         _unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx> {\n@@ -470,14 +470,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     #[inline(always)]\n     fn stack<'a>(\n         ecx: &'a InterpCx<'mir, 'tcx, Self>,\n-    ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>] {\n+    ) -> &'a [Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>] {\n         &ecx.machine.stack\n     }\n \n     #[inline(always)]\n     fn stack_mut<'a>(\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n-    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>> {\n+    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>> {\n         &mut ecx.machine.stack\n     }\n "}, {"sha": "2e6cbb131ef3c1689411e4fe31053a561c5abab4", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -18,10 +18,10 @@ use super::{\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn cast(\n         &mut self,\n-        src: &OpTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::Provenance>,\n         cast_kind: CastKind,\n         cast_ty: Ty<'tcx>,\n-        dest: &PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx> {\n         use rustc_middle::mir::CastKind::*;\n         // FIXME: In which cases should we trigger UB when the source is uninit?\n@@ -114,9 +114,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     pub fn misc_cast(\n         &mut self,\n-        src: &ImmTy<'tcx, M::PointerTag>,\n+        src: &ImmTy<'tcx, M::Provenance>,\n         cast_ty: Ty<'tcx>,\n-    ) -> InterpResult<'tcx, Immediate<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n         use rustc_type_ir::sty::TyKind::*;\n         trace!(\"Casting {:?}: {:?} to {:?}\", *src, src.layout.ty, cast_ty);\n \n@@ -173,9 +173,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     pub fn pointer_expose_address_cast(\n         &mut self,\n-        src: &ImmTy<'tcx, M::PointerTag>,\n+        src: &ImmTy<'tcx, M::Provenance>,\n         cast_ty: Ty<'tcx>,\n-    ) -> InterpResult<'tcx, Immediate<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n         assert_matches!(src.layout.ty.kind(), ty::RawPtr(_) | ty::FnPtr(_));\n         assert!(cast_ty.is_integral());\n \n@@ -190,9 +190,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     pub fn pointer_from_exposed_address_cast(\n         &mut self,\n-        src: &ImmTy<'tcx, M::PointerTag>,\n+        src: &ImmTy<'tcx, M::Provenance>,\n         cast_ty: Ty<'tcx>,\n-    ) -> InterpResult<'tcx, Immediate<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n         assert!(src.layout.ty.is_integral());\n         assert_matches!(cast_ty.kind(), ty::RawPtr(_));\n \n@@ -208,10 +208,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     pub fn cast_from_int_like(\n         &self,\n-        scalar: Scalar<M::PointerTag>, // input value (there is no ScalarTy so we separate data+layout)\n+        scalar: Scalar<M::Provenance>, // input value (there is no ScalarTy so we separate data+layout)\n         src_layout: TyAndLayout<'tcx>,\n         cast_ty: Ty<'tcx>,\n-    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Scalar<M::Provenance>> {\n         // Let's make sure v is sign-extended *if* it has a signed type.\n         let signed = src_layout.abi.is_signed(); // Also asserts that abi is `Scalar`.\n \n@@ -245,9 +245,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         })\n     }\n \n-    fn cast_from_float<F>(&self, f: F, dest_ty: Ty<'tcx>) -> Scalar<M::PointerTag>\n+    fn cast_from_float<F>(&self, f: F, dest_ty: Ty<'tcx>) -> Scalar<M::Provenance>\n     where\n-        F: Float + Into<Scalar<M::PointerTag>> + FloatConvert<Single> + FloatConvert<Double>,\n+        F: Float + Into<Scalar<M::Provenance>> + FloatConvert<Single> + FloatConvert<Double>,\n     {\n         use rustc_type_ir::sty::TyKind::*;\n         match *dest_ty.kind() {\n@@ -279,8 +279,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn unsize_into_ptr(\n         &mut self,\n-        src: &OpTy<'tcx, M::PointerTag>,\n-        dest: &PlaceTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::Provenance>,\n+        dest: &PlaceTy<'tcx, M::Provenance>,\n         // The pointee types\n         source_ty: Ty<'tcx>,\n         cast_ty: Ty<'tcx>,\n@@ -335,9 +335,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn unsize_into(\n         &mut self,\n-        src: &OpTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::Provenance>,\n         cast_ty: TyAndLayout<'tcx>,\n-        dest: &PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"Unsizing {:?} of type {} into {:?}\", *src, src.layout.ty, cast_ty.ty);\n         match (&src.layout.ty.kind(), &cast_ty.ty.kind()) {"}, {"sha": "45928d7b02e36d6d5dc517cd93e959c53995381b", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -81,7 +81,7 @@ impl Drop for SpanGuard {\n }\n \n /// A stack frame.\n-pub struct Frame<'mir, 'tcx, Tag: Provenance = AllocId, Extra = ()> {\n+pub struct Frame<'mir, 'tcx, Prov: Provenance = AllocId, Extra = ()> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Function and callsite information\n     ////////////////////////////////////////////////////////////////////////////////\n@@ -102,7 +102,7 @@ pub struct Frame<'mir, 'tcx, Tag: Provenance = AllocId, Extra = ()> {\n \n     /// The location where the result of the current stack frame should be written to,\n     /// and its layout in the caller.\n-    pub return_place: PlaceTy<'tcx, Tag>,\n+    pub return_place: PlaceTy<'tcx, Prov>,\n \n     /// The list of locals for this stack frame, stored in order as\n     /// `[return_ptr, arguments..., variables..., temporaries...]`.\n@@ -111,7 +111,7 @@ pub struct Frame<'mir, 'tcx, Tag: Provenance = AllocId, Extra = ()> {\n     /// can either directly contain `Scalar` or refer to some part of an `Allocation`.\n     ///\n     /// Do *not* access this directly; always go through the machine hook!\n-    pub locals: IndexVec<mir::Local, LocalState<'tcx, Tag>>,\n+    pub locals: IndexVec<mir::Local, LocalState<'tcx, Prov>>,\n \n     /// The span of the `tracing` crate is stored here.\n     /// When the guard is dropped, the span is exited. This gives us\n@@ -166,32 +166,32 @@ pub enum StackPopCleanup {\n \n /// State of a local variable including a memoized layout\n #[derive(Clone, Debug)]\n-pub struct LocalState<'tcx, Tag: Provenance = AllocId> {\n-    pub value: LocalValue<Tag>,\n+pub struct LocalState<'tcx, Prov: Provenance = AllocId> {\n+    pub value: LocalValue<Prov>,\n     /// Don't modify if `Some`, this is only used to prevent computing the layout twice\n     pub layout: Cell<Option<TyAndLayout<'tcx>>>,\n }\n \n /// Current value of a local variable\n #[derive(Copy, Clone, Debug)] // Miri debug-prints these\n-pub enum LocalValue<Tag: Provenance = AllocId> {\n+pub enum LocalValue<Prov: Provenance = AllocId> {\n     /// This local is not currently alive, and cannot be used at all.\n     Dead,\n     /// A normal, live local.\n     /// Mostly for convenience, we re-use the `Operand` type here.\n     /// This is an optimization over just always having a pointer here;\n     /// we can thus avoid doing an allocation when the local just stores\n     /// immediate values *and* never has its address taken.\n-    Live(Operand<Tag>),\n+    Live(Operand<Prov>),\n }\n \n-impl<'tcx, Tag: Provenance + 'static> LocalState<'tcx, Tag> {\n+impl<'tcx, Prov: Provenance + 'static> LocalState<'tcx, Prov> {\n     /// Read the local's value or error if the local is not yet live or not live anymore.\n     ///\n     /// Note: This may only be invoked from the `Machine::access_local` hook and not from\n     /// anywhere else. You may be invalidating machine invariants if you do!\n     #[inline]\n-    pub fn access(&self) -> InterpResult<'tcx, &Operand<Tag>> {\n+    pub fn access(&self) -> InterpResult<'tcx, &Operand<Prov>> {\n         match &self.value {\n             LocalValue::Dead => throw_ub!(DeadLocal), // could even be \"invalid program\"?\n             LocalValue::Live(val) => Ok(val),\n@@ -204,16 +204,16 @@ impl<'tcx, Tag: Provenance + 'static> LocalState<'tcx, Tag> {\n     /// Note: This may only be invoked from the `Machine::access_local_mut` hook and not from\n     /// anywhere else. You may be invalidating machine invariants if you do!\n     #[inline]\n-    pub fn access_mut(&mut self) -> InterpResult<'tcx, &mut Operand<Tag>> {\n+    pub fn access_mut(&mut self) -> InterpResult<'tcx, &mut Operand<Prov>> {\n         match &mut self.value {\n             LocalValue::Dead => throw_ub!(DeadLocal), // could even be \"invalid program\"?\n             LocalValue::Live(val) => Ok(val),\n         }\n     }\n }\n \n-impl<'mir, 'tcx, Tag: Provenance> Frame<'mir, 'tcx, Tag> {\n-    pub fn with_extra<Extra>(self, extra: Extra) -> Frame<'mir, 'tcx, Tag, Extra> {\n+impl<'mir, 'tcx, Prov: Provenance> Frame<'mir, 'tcx, Prov> {\n+    pub fn with_extra<Extra>(self, extra: Extra) -> Frame<'mir, 'tcx, Prov, Extra> {\n         Frame {\n             body: self.body,\n             instance: self.instance,\n@@ -227,7 +227,7 @@ impl<'mir, 'tcx, Tag: Provenance> Frame<'mir, 'tcx, Tag> {\n     }\n }\n \n-impl<'mir, 'tcx, Tag: Provenance, Extra> Frame<'mir, 'tcx, Tag, Extra> {\n+impl<'mir, 'tcx, Prov: Provenance, Extra> Frame<'mir, 'tcx, Prov, Extra> {\n     /// Get the current location within the Frame.\n     ///\n     /// If this is `Err`, we are not currently executing any particular statement in\n@@ -422,14 +422,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     #[inline(always)]\n-    pub(crate) fn stack(&self) -> &[Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>] {\n+    pub(crate) fn stack(&self) -> &[Frame<'mir, 'tcx, M::Provenance, M::FrameExtra>] {\n         M::stack(self)\n     }\n \n     #[inline(always)]\n     pub(crate) fn stack_mut(\n         &mut self,\n-    ) -> &mut Vec<Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>> {\n+    ) -> &mut Vec<Frame<'mir, 'tcx, M::Provenance, M::FrameExtra>> {\n         M::stack_mut(self)\n     }\n \n@@ -441,12 +441,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     #[inline(always)]\n-    pub fn frame(&self) -> &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra> {\n+    pub fn frame(&self) -> &Frame<'mir, 'tcx, M::Provenance, M::FrameExtra> {\n         self.stack().last().expect(\"no call frames exist\")\n     }\n \n     #[inline(always)]\n-    pub fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra> {\n+    pub fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx, M::Provenance, M::FrameExtra> {\n         self.stack_mut().last_mut().expect(\"no call frames exist\")\n     }\n \n@@ -503,7 +503,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// stack frame), to bring it into the proper environment for this interpreter.\n     pub(super) fn subst_from_frame_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n         &self,\n-        frame: &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n+        frame: &Frame<'mir, 'tcx, M::Provenance, M::FrameExtra>,\n         value: T,\n     ) -> Result<T, InterpError<'tcx>> {\n         frame\n@@ -540,7 +540,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline(always)]\n     pub fn layout_of_local(\n         &self,\n-        frame: &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n+        frame: &Frame<'mir, 'tcx, M::Provenance, M::FrameExtra>,\n         local: mir::Local,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n@@ -569,7 +569,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// This can fail to provide an answer for extern types.\n     pub(super) fn size_and_align_of(\n         &self,\n-        metadata: &MemPlaceMeta<M::PointerTag>,\n+        metadata: &MemPlaceMeta<M::Provenance>,\n         layout: &TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx, Option<(Size, Align)>> {\n         if !layout.is_unsized() {\n@@ -655,7 +655,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline]\n     pub fn size_and_align_of_mplace(\n         &self,\n-        mplace: &MPlaceTy<'tcx, M::PointerTag>,\n+        mplace: &MPlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx, Option<(Size, Align)>> {\n         self.size_and_align_of(&mplace.meta, &mplace.layout)\n     }\n@@ -665,7 +665,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         body: &'mir mir::Body<'tcx>,\n-        return_place: &PlaceTy<'tcx, M::PointerTag>,\n+        return_place: &PlaceTy<'tcx, M::Provenance>,\n         return_to_block: StackPopCleanup,\n     ) -> InterpResult<'tcx> {\n         trace!(\"body: {:#?}\", body);\n@@ -891,7 +891,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    fn deallocate_local(&mut self, local: LocalValue<M::PointerTag>) -> InterpResult<'tcx> {\n+    fn deallocate_local(&mut self, local: LocalValue<M::Provenance>) -> InterpResult<'tcx> {\n         if let LocalValue::Live(Operand::Indirect(MemPlace { ptr, .. })) = local {\n             // All locals have a backing allocation, even if the allocation is empty\n             // due to the local having ZST type. Hence we can `unwrap`.\n@@ -909,7 +909,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn eval_to_allocation(\n         &self,\n         gid: GlobalId<'tcx>,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n         // For statics we pick `ParamEnv::reveal_all`, because statics don't have generics\n         // and thus don't care about the parameter environment. While we could just use\n         // `self.param_env`, that would mean we invoke the query to evaluate the static\n@@ -927,7 +927,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     #[must_use]\n-    pub fn dump_place(&self, place: Place<M::PointerTag>) -> PlacePrinter<'_, 'mir, 'tcx, M> {\n+    pub fn dump_place(&self, place: Place<M::Provenance>) -> PlacePrinter<'_, 'mir, 'tcx, M> {\n         PlacePrinter { ecx: self, place }\n     }\n \n@@ -956,7 +956,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n /// Helper struct for the `dump_place` function.\n pub struct PlacePrinter<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     ecx: &'a InterpCx<'mir, 'tcx, M>,\n-    place: Place<M::PointerTag>,\n+    place: Place<M::Provenance>,\n }\n \n impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug"}, {"sha": "2a977779e4267dfc2ac7468a6ba68e45d57b4628", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -33,7 +33,7 @@ pub trait CompileTimeMachine<'mir, 'tcx, T> = Machine<\n     'mir,\n     'tcx,\n     MemoryKind = T,\n-    PointerTag = AllocId,\n+    Provenance = AllocId,\n     ExtraFnVal = !,\n     FrameExtra = (),\n     AllocExtra = (),\n@@ -474,7 +474,7 @@ impl<'mir, 'tcx: 'mir, M: super::intern::CompileTimeMachine<'mir, 'tcx, !>>\n         layout: TyAndLayout<'tcx>,\n         f: impl FnOnce(\n             &mut InterpCx<'mir, 'tcx, M>,\n-            &PlaceTy<'tcx, M::PointerTag>,\n+            &PlaceTy<'tcx, M::Provenance>,\n         ) -> InterpResult<'tcx, ()>,\n     ) -> InterpResult<'tcx, ConstAllocation<'tcx>> {\n         let dest = self.allocate(layout, MemoryKind::Stack)?;"}, {"sha": "0f6eb2ecaa342899542ed2d77e418ec51da6a26d", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -25,7 +25,7 @@ use super::{\n mod caller_location;\n mod type_name;\n \n-fn numeric_intrinsic<Tag>(name: Symbol, bits: u128, kind: Primitive) -> Scalar<Tag> {\n+fn numeric_intrinsic<Prov>(name: Symbol, bits: u128, kind: Primitive) -> Scalar<Prov> {\n     let size = match kind {\n         Primitive::Int(integer, _) => integer.size(),\n         _ => bug!(\"invalid `{}` argument: {:?}\", name, bits),\n@@ -114,8 +114,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn emulate_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx, M::PointerTag>],\n-        dest: &PlaceTy<'tcx, M::PointerTag>,\n+        args: &[OpTy<'tcx, M::Provenance>],\n+        dest: &PlaceTy<'tcx, M::Provenance>,\n         ret: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx, bool> {\n         let substs = instance.substs;\n@@ -502,9 +502,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     pub fn exact_div(\n         &mut self,\n-        a: &ImmTy<'tcx, M::PointerTag>,\n-        b: &ImmTy<'tcx, M::PointerTag>,\n-        dest: &PlaceTy<'tcx, M::PointerTag>,\n+        a: &ImmTy<'tcx, M::Provenance>,\n+        b: &ImmTy<'tcx, M::Provenance>,\n+        dest: &PlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx> {\n         // Performs an exact division, resulting in undefined behavior where\n         // `x % y != 0` or `y == 0` or `x == T::MIN && y == -1`.\n@@ -521,9 +521,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn saturating_arith(\n         &self,\n         mir_op: BinOp,\n-        l: &ImmTy<'tcx, M::PointerTag>,\n-        r: &ImmTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+        l: &ImmTy<'tcx, M::Provenance>,\n+        r: &ImmTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<M::Provenance>> {\n         assert!(matches!(mir_op, BinOp::Add | BinOp::Sub));\n         let (val, overflowed, _ty) = self.overflowing_binary_op(mir_op, l, r)?;\n         Ok(if overflowed {\n@@ -566,10 +566,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// 0, so offset-by-0 (and only 0) is okay -- except that null cannot be offset by _any_ value.\n     pub fn ptr_offset_inbounds(\n         &self,\n-        ptr: Pointer<Option<M::PointerTag>>,\n+        ptr: Pointer<Option<M::Provenance>>,\n         pointee_ty: Ty<'tcx>,\n         offset_count: i64,\n-    ) -> InterpResult<'tcx, Pointer<Option<M::PointerTag>>> {\n+    ) -> InterpResult<'tcx, Pointer<Option<M::Provenance>>> {\n         // We cannot overflow i64 as a type's size must be <= isize::MAX.\n         let pointee_size = i64::try_from(self.layout_of(pointee_ty)?.size.bytes()).unwrap();\n         // The computed offset, in bytes, must not overflow an isize.\n@@ -597,9 +597,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Copy `count*size_of::<T>()` many bytes from `*src` to `*dst`.\n     pub(crate) fn copy_intrinsic(\n         &mut self,\n-        src: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::PointerTag>,\n-        dst: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::PointerTag>,\n-        count: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::PointerTag>,\n+        src: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::Provenance>,\n+        dst: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::Provenance>,\n+        count: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::Provenance>,\n         nonoverlapping: bool,\n     ) -> InterpResult<'tcx> {\n         let count = self.read_scalar(&count)?.to_machine_usize(self)?;\n@@ -622,9 +622,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     pub(crate) fn write_bytes_intrinsic(\n         &mut self,\n-        dst: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::PointerTag>,\n-        byte: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::PointerTag>,\n-        count: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::PointerTag>,\n+        dst: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::Provenance>,\n+        byte: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::Provenance>,\n+        count: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::Provenance>,\n     ) -> InterpResult<'tcx> {\n         let layout = self.layout_of(dst.layout.ty.builtin_deref(true).unwrap().ty)?;\n \n@@ -645,9 +645,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     pub(crate) fn raw_eq_intrinsic(\n         &mut self,\n-        lhs: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::PointerTag>,\n-        rhs: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::PointerTag>,\n-    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+        lhs: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::Provenance>,\n+        rhs: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<M::Provenance>> {\n         let layout = self.layout_of(lhs.layout.ty.builtin_deref(true).unwrap().ty)?;\n         assert!(!layout.is_unsized());\n "}, {"sha": "5864b921552877b265743e5e3f448e3bba69b541", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -79,7 +79,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         filename: Symbol,\n         line: u32,\n         col: u32,\n-    ) -> MPlaceTy<'tcx, M::PointerTag> {\n+    ) -> MPlaceTy<'tcx, M::Provenance> {\n         let loc_details = &self.tcx.sess.opts.unstable_opts.location_detail;\n         let file = if loc_details.file {\n             self.allocate_str(filename.as_str(), MemoryKind::CallerLocation, Mutability::Not)\n@@ -123,7 +123,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         )\n     }\n \n-    pub fn alloc_caller_location_for_span(&mut self, span: Span) -> MPlaceTy<'tcx, M::PointerTag> {\n+    pub fn alloc_caller_location_for_span(&mut self, span: Span) -> MPlaceTy<'tcx, M::Provenance> {\n         let (file, line, column) = self.location_triple_for_span(span);\n         self.alloc_caller_location(file, line, column)\n     }"}, {"sha": "a938a9248e0c4ed5a7aa854214e74c1c478bc575", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 53, "deletions": 54, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -85,11 +85,11 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     type MemoryKind: Debug + std::fmt::Display + MayLeak + Eq + 'static;\n \n     /// Pointers are \"tagged\" with provenance information; typically the `AllocId` they belong to.\n-    type PointerTag: Provenance + Eq + Hash + 'static;\n+    type Provenance: Provenance + Eq + Hash + 'static;\n \n-    /// When getting the AllocId of a pointer, some extra data is also obtained from the tag\n+    /// When getting the AllocId of a pointer, some extra data is also obtained from the provenance\n     /// that is passed to memory access hooks so they can do things with it.\n-    type TagExtra: Copy + 'static;\n+    type ProvenanceExtra: Copy + 'static;\n \n     /// Machines can define extra (non-instance) things that represent values of function pointers.\n     /// For example, Miri uses this to return a function pointer from `dlsym`\n@@ -105,15 +105,15 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Memory's allocation map\n     type MemoryMap: AllocMap<\n             AllocId,\n-            (MemoryKind<Self::MemoryKind>, Allocation<Self::PointerTag, Self::AllocExtra>),\n+            (MemoryKind<Self::MemoryKind>, Allocation<Self::Provenance, Self::AllocExtra>),\n         > + Default\n         + Clone;\n \n     /// The memory kind to use for copied global memory (held in `tcx`) --\n     /// or None if such memory should not be mutated and thus any such attempt will cause\n     /// a `ModifiedStatic` error to be raised.\n     /// Statics are copied under two circumstances: When they are mutated, and when\n-    /// `tag_allocation` (see below) returns an owned allocation\n+    /// `adjust_allocation` (see below) returns an owned allocation\n     /// that is added to the memory so that the work is not done twice.\n     const GLOBAL_KIND: Option<Self::MemoryKind>;\n \n@@ -126,7 +126,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Whether, when checking alignment, we should `force_int` and thus support\n     /// custom alignment logic based on whatever the integer address happens to be.\n     ///\n-    /// Requires PointerTag::OFFSET_IS_ADDR to be true.\n+    /// Requires Provenance::OFFSET_IS_ADDR to be true.\n     fn force_int_for_alignment_check(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n     /// Whether to enforce the validity invariant\n@@ -170,8 +170,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         abi: CallAbi,\n-        args: &[OpTy<'tcx, Self::PointerTag>],\n-        destination: &PlaceTy<'tcx, Self::PointerTag>,\n+        args: &[OpTy<'tcx, Self::Provenance>],\n+        destination: &PlaceTy<'tcx, Self::Provenance>,\n         target: Option<mir::BasicBlock>,\n         unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>>;\n@@ -182,8 +182,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         fn_val: Self::ExtraFnVal,\n         abi: CallAbi,\n-        args: &[OpTy<'tcx, Self::PointerTag>],\n-        destination: &PlaceTy<'tcx, Self::PointerTag>,\n+        args: &[OpTy<'tcx, Self::Provenance>],\n+        destination: &PlaceTy<'tcx, Self::Provenance>,\n         target: Option<mir::BasicBlock>,\n         unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx>;\n@@ -193,8 +193,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn call_intrinsic(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx, Self::PointerTag>],\n-        destination: &PlaceTy<'tcx, Self::PointerTag>,\n+        args: &[OpTy<'tcx, Self::Provenance>],\n+        destination: &PlaceTy<'tcx, Self::Provenance>,\n         target: Option<mir::BasicBlock>,\n         unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx>;\n@@ -217,18 +217,18 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn binary_ptr_op(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n-        left: &ImmTy<'tcx, Self::PointerTag>,\n-        right: &ImmTy<'tcx, Self::PointerTag>,\n-    ) -> InterpResult<'tcx, (Scalar<Self::PointerTag>, bool, Ty<'tcx>)>;\n+        left: &ImmTy<'tcx, Self::Provenance>,\n+        right: &ImmTy<'tcx, Self::Provenance>,\n+    ) -> InterpResult<'tcx, (Scalar<Self::Provenance>, bool, Ty<'tcx>)>;\n \n     /// Called to read the specified `local` from the `frame`.\n     /// Since reading a ZST is not actually accessing memory or locals, this is never invoked\n     /// for ZST reads.\n     #[inline]\n     fn access_local<'a>(\n-        frame: &'a Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n+        frame: &'a Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>,\n         local: mir::Local,\n-    ) -> InterpResult<'tcx, &'a Operand<Self::PointerTag>>\n+    ) -> InterpResult<'tcx, &'a Operand<Self::Provenance>>\n     where\n         'tcx: 'mir,\n     {\n@@ -243,7 +243,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n         frame: usize,\n         local: mir::Local,\n-    ) -> InterpResult<'tcx, &'a mut Operand<Self::PointerTag>>\n+    ) -> InterpResult<'tcx, &'a mut Operand<Self::Provenance>>\n     where\n         'tcx: 'mir,\n     {\n@@ -275,43 +275,43 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn thread_local_static_base_pointer(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         def_id: DefId,\n-    ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n+    ) -> InterpResult<'tcx, Pointer<Self::Provenance>> {\n         throw_unsup!(ThreadLocalStatic(def_id))\n     }\n \n     /// Return the root pointer for the given `extern static`.\n     fn extern_static_base_pointer(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         def_id: DefId,\n-    ) -> InterpResult<'tcx, Pointer<Self::PointerTag>>;\n+    ) -> InterpResult<'tcx, Pointer<Self::Provenance>>;\n \n     /// Return a \"base\" pointer for the given allocation: the one that is used for direct\n     /// accesses to this static/const/fn allocation, or the one returned from the heap allocator.\n     ///\n     /// Not called on `extern` or thread-local statics (those use the methods above).\n-    fn tag_alloc_base_pointer(\n+    fn adjust_alloc_base_pointer(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         ptr: Pointer,\n-    ) -> Pointer<Self::PointerTag>;\n+    ) -> Pointer<Self::Provenance>;\n \n     /// \"Int-to-pointer cast\"\n     fn ptr_from_addr_cast(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         addr: u64,\n-    ) -> InterpResult<'tcx, Pointer<Option<Self::PointerTag>>>;\n+    ) -> InterpResult<'tcx, Pointer<Option<Self::Provenance>>>;\n \n     /// Hook for returning a pointer from a transmute-like operation on an addr.\n     /// This is only needed to support Miri's (unsound) \"allow-ptr-int-transmute\" flag.\n     fn ptr_from_addr_transmute(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         addr: u64,\n-    ) -> Pointer<Option<Self::PointerTag>>;\n+    ) -> Pointer<Option<Self::Provenance>>;\n \n     /// Marks a pointer as exposed, allowing it's provenance\n     /// to be recovered. \"Pointer-to-int cast\"\n     fn expose_ptr(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        ptr: Pointer<Self::PointerTag>,\n+        ptr: Pointer<Self::Provenance>,\n     ) -> InterpResult<'tcx>;\n \n     /// Convert a pointer with provenance into an allocation-offset pair\n@@ -322,30 +322,30 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// When this fails, that means the pointer does not point to a live allocation.\n     fn ptr_get_alloc(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n-        ptr: Pointer<Self::PointerTag>,\n-    ) -> Option<(AllocId, Size, Self::TagExtra)>;\n-\n-    /// Called to initialize the \"extra\" state of an allocation and make the pointers\n-    /// it contains (in relocations) tagged.  The way we construct allocations is\n-    /// to always first construct it without extra and then add the extra.\n-    /// This keeps uniform code paths for handling both allocations created by CTFE\n-    /// for globals, and allocations created by Miri during evaluation.\n+        ptr: Pointer<Self::Provenance>,\n+    ) -> Option<(AllocId, Size, Self::ProvenanceExtra)>;\n+\n+    /// Called to adjust allocations to the Provenance and AllocExtra of this machine.\n+    ///\n+    /// The way we construct allocations is to always first construct it without extra and then add\n+    /// the extra. This keeps uniform code paths for handling both allocations created by CTFE for\n+    /// globals, and allocations created by Miri during evaluation.\n     ///\n-    /// `kind` is the kind of the allocation being tagged; it can be `None` when\n+    /// `kind` is the kind of the allocation being adjusted; it can be `None` when\n     /// it's a global and `GLOBAL_KIND` is `None`.\n     ///\n     /// This should avoid copying if no work has to be done! If this returns an owned\n-    /// allocation (because a copy had to be done to add tags or metadata), machine memory will\n+    /// allocation (because a copy had to be done to adjust things), machine memory will\n     /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n     /// owned allocation to the map even when the map is shared.)\n     ///\n     /// This must only fail if `alloc` contains relocations.\n-    fn init_allocation_extra<'b>(\n+    fn adjust_allocation<'b>(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n-    ) -> InterpResult<'tcx, Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>>;\n+    ) -> InterpResult<'tcx, Cow<'b, Allocation<Self::Provenance, Self::AllocExtra>>>;\n \n     /// Hook for performing extra checks on a memory read access.\n     ///\n@@ -357,7 +357,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _tcx: TyCtxt<'tcx>,\n         _machine: &Self,\n         _alloc_extra: &Self::AllocExtra,\n-        _tag: (AllocId, Self::TagExtra),\n+        _prov: (AllocId, Self::ProvenanceExtra),\n         _range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n@@ -369,7 +369,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _tcx: TyCtxt<'tcx>,\n         _machine: &mut Self,\n         _alloc_extra: &mut Self::AllocExtra,\n-        _tag: (AllocId, Self::TagExtra),\n+        _prov: (AllocId, Self::ProvenanceExtra),\n         _range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n@@ -381,7 +381,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _tcx: TyCtxt<'tcx>,\n         _machine: &mut Self,\n         _alloc_extra: &mut Self::AllocExtra,\n-        _tag: (AllocId, Self::TagExtra),\n+        _prov: (AllocId, Self::ProvenanceExtra),\n         _range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n@@ -392,26 +392,26 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn retag(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _kind: mir::RetagKind,\n-        _place: &PlaceTy<'tcx, Self::PointerTag>,\n+        _place: &PlaceTy<'tcx, Self::Provenance>,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n \n     /// Called immediately before a new stack frame gets pushed.\n     fn init_frame_extra(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        frame: Frame<'mir, 'tcx, Self::PointerTag>,\n-    ) -> InterpResult<'tcx, Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>>;\n+        frame: Frame<'mir, 'tcx, Self::Provenance>,\n+    ) -> InterpResult<'tcx, Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>>;\n \n     /// Borrow the current thread's stack.\n     fn stack<'a>(\n         ecx: &'a InterpCx<'mir, 'tcx, Self>,\n-    ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>];\n+    ) -> &'a [Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>];\n \n     /// Mutably borrow the current thread's stack.\n     fn stack_mut<'a>(\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n-    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>>;\n+    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>>;\n \n     /// Called immediately after a stack frame got pushed and its locals got initialized.\n     fn after_stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n@@ -422,7 +422,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// The `locals` have already been destroyed!\n     fn after_stack_pop(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _frame: Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n+        _frame: Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>,\n         unwinding: bool,\n     ) -> InterpResult<'tcx, StackPopJump> {\n         // By default, we do not support unwinding from panics\n@@ -434,8 +434,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n // A lot of the flexibility above is just needed for `Miri`, but all \"compile-time\" machines\n // (CTFE and ConstProp) use the same instance.  Here, we share that code.\n pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n-    type PointerTag = AllocId;\n-    type TagExtra = ();\n+    type Provenance = AllocId;\n+    type ProvenanceExtra = ();\n \n     type ExtraFnVal = !;\n \n@@ -485,21 +485,20 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n         fn_val: !,\n         _abi: CallAbi,\n         _args: &[OpTy<$tcx>],\n-        _destination: &PlaceTy<$tcx, Self::PointerTag>,\n+        _destination: &PlaceTy<$tcx, Self::Provenance>,\n         _target: Option<mir::BasicBlock>,\n         _unwind: StackPopUnwind,\n     ) -> InterpResult<$tcx> {\n         match fn_val {}\n     }\n \n     #[inline(always)]\n-    fn init_allocation_extra<'b>(\n+    fn adjust_allocation<'b>(\n         _ecx: &InterpCx<$mir, $tcx, Self>,\n         _id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         _kind: Option<MemoryKind<Self::MemoryKind>>,\n-    ) -> InterpResult<$tcx, Cow<'b, Allocation<Self::PointerTag>>> {\n-        // We do not use a tag so we can just cheaply forward the allocation\n+    ) -> InterpResult<$tcx, Cow<'b, Allocation<Self::Provenance>>> {\n         Ok(alloc)\n     }\n \n@@ -512,7 +511,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     }\n \n     #[inline(always)]\n-    fn tag_alloc_base_pointer(\n+    fn adjust_alloc_base_pointer(\n         _ecx: &InterpCx<$mir, $tcx, Self>,\n         ptr: Pointer<AllocId>,\n     ) -> Pointer<AllocId> {\n@@ -541,7 +540,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     fn ptr_get_alloc(\n         _ecx: &InterpCx<$mir, $tcx, Self>,\n         ptr: Pointer<AllocId>,\n-    ) -> Option<(AllocId, Size, Self::TagExtra)> {\n+    ) -> Option<(AllocId, Size, Self::ProvenanceExtra)> {\n         // We know `offset` is relative to the allocation, so we can use `into_parts`.\n         let (alloc_id, offset) = ptr.into_parts();\n         Some((alloc_id, offset, ()))"}, {"sha": "b665b21096061be7d4c9c9015269db4982cf5741", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 82, "deletions": 78, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -112,16 +112,16 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n /// A reference to some allocation that was already bounds-checked for the given region\n /// and had the on-access machine hooks run.\n #[derive(Copy, Clone)]\n-pub struct AllocRef<'a, 'tcx, Tag, Extra> {\n-    alloc: &'a Allocation<Tag, Extra>,\n+pub struct AllocRef<'a, 'tcx, Prov, Extra> {\n+    alloc: &'a Allocation<Prov, Extra>,\n     range: AllocRange,\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n }\n /// A reference to some allocation that was already bounds-checked for the given region\n /// and had the on-access machine hooks run.\n-pub struct AllocRefMut<'a, 'tcx, Tag, Extra> {\n-    alloc: &'a mut Allocation<Tag, Extra>,\n+pub struct AllocRefMut<'a, 'tcx, Prov, Extra> {\n+    alloc: &'a mut Allocation<Prov, Extra>,\n     range: AllocRange,\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n@@ -156,7 +156,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn global_base_pointer(\n         &self,\n         ptr: Pointer<AllocId>,\n-    ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Pointer<M::Provenance>> {\n         let alloc_id = ptr.provenance;\n         // We need to handle `extern static`.\n         match self.tcx.get_global_alloc(alloc_id) {\n@@ -168,14 +168,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             _ => {}\n         }\n-        // And we need to get the tag.\n-        Ok(M::tag_alloc_base_pointer(self, ptr))\n+        // And we need to get the provenance.\n+        Ok(M::adjust_alloc_base_pointer(self, ptr))\n     }\n \n     pub fn create_fn_alloc_ptr(\n         &mut self,\n         fn_val: FnVal<'tcx, M::ExtraFnVal>,\n-    ) -> Pointer<M::PointerTag> {\n+    ) -> Pointer<M::Provenance> {\n         let id = match fn_val {\n             FnVal::Instance(instance) => self.tcx.create_fn_alloc(instance),\n             FnVal::Other(extra) => {\n@@ -196,7 +196,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         size: Size,\n         align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n-    ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Pointer<M::Provenance>> {\n         let alloc = Allocation::uninit(size, align, M::PANIC_ON_ALLOC_FAIL)?;\n         // We can `unwrap` since `alloc` contains no pointers.\n         Ok(self.allocate_raw_ptr(alloc, kind).unwrap())\n@@ -208,7 +208,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n         mutability: Mutability,\n-    ) -> Pointer<M::PointerTag> {\n+    ) -> Pointer<M::Provenance> {\n         let alloc = Allocation::from_bytes(bytes, align, mutability);\n         // We can `unwrap` since `alloc` contains no pointers.\n         self.allocate_raw_ptr(alloc, kind).unwrap()\n@@ -219,27 +219,27 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self,\n         alloc: Allocation,\n         kind: MemoryKind<M::MemoryKind>,\n-    ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Pointer<M::Provenance>> {\n         let id = self.tcx.reserve_alloc_id();\n         debug_assert_ne!(\n             Some(kind),\n             M::GLOBAL_KIND.map(MemoryKind::Machine),\n             \"dynamically allocating global memory\"\n         );\n-        let alloc = M::init_allocation_extra(self, id, Cow::Owned(alloc), Some(kind))?;\n+        let alloc = M::adjust_allocation(self, id, Cow::Owned(alloc), Some(kind))?;\n         self.memory.alloc_map.insert(id, (kind, alloc.into_owned()));\n-        Ok(M::tag_alloc_base_pointer(self, Pointer::from(id)))\n+        Ok(M::adjust_alloc_base_pointer(self, Pointer::from(id)))\n     }\n \n     pub fn reallocate_ptr(\n         &mut self,\n-        ptr: Pointer<Option<M::PointerTag>>,\n+        ptr: Pointer<Option<M::Provenance>>,\n         old_size_and_align: Option<(Size, Align)>,\n         new_size: Size,\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n-    ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n-        let (alloc_id, offset, _tag) = self.ptr_get_alloc_id(ptr)?;\n+    ) -> InterpResult<'tcx, Pointer<M::Provenance>> {\n+        let (alloc_id, offset, _prov) = self.ptr_get_alloc_id(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub_format!(\n                 \"reallocating {:?} which does not point to the beginning of an object\",\n@@ -271,11 +271,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[instrument(skip(self), level = \"debug\")]\n     pub fn deallocate_ptr(\n         &mut self,\n-        ptr: Pointer<Option<M::PointerTag>>,\n+        ptr: Pointer<Option<M::Provenance>>,\n         old_size_and_align: Option<(Size, Align)>,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx> {\n-        let (alloc_id, offset, tag) = self.ptr_get_alloc_id(ptr)?;\n+        let (alloc_id, offset, prov) = self.ptr_get_alloc_id(ptr)?;\n         trace!(\"deallocating: {alloc_id:?}\");\n \n         if offset.bytes() != 0 {\n@@ -327,7 +327,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             *self.tcx,\n             &mut self.machine,\n             &mut alloc.extra,\n-            (alloc_id, tag),\n+            (alloc_id, prov),\n             alloc_range(Size::ZERO, size),\n         )?;\n \n@@ -344,19 +344,19 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline(always)]\n     fn get_ptr_access(\n         &self,\n-        ptr: Pointer<Option<M::PointerTag>>,\n+        ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n         align: Align,\n-    ) -> InterpResult<'tcx, Option<(AllocId, Size, M::TagExtra)>> {\n+    ) -> InterpResult<'tcx, Option<(AllocId, Size, M::ProvenanceExtra)>> {\n         let align = M::enforce_alignment(&self).then_some(align);\n         self.check_and_deref_ptr(\n             ptr,\n             size,\n             align,\n             CheckInAllocMsg::MemoryAccessTest,\n-            |alloc_id, offset, tag| {\n+            |alloc_id, offset, prov| {\n                 let (size, align) = self.get_live_alloc_size_and_align(alloc_id)?;\n-                Ok((size, align, (alloc_id, offset, tag)))\n+                Ok((size, align, (alloc_id, offset, prov)))\n             },\n         )\n     }\n@@ -367,7 +367,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline(always)]\n     pub fn check_ptr_access_align(\n         &self,\n-        ptr: Pointer<Option<M::PointerTag>>,\n+        ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n         align: Align,\n         msg: CheckInAllocMsg,\n@@ -385,11 +385,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// is done. Returns `None` for size 0, and otherwise `Some` of what `alloc_size` returned.\n     fn check_and_deref_ptr<T>(\n         &self,\n-        ptr: Pointer<Option<M::PointerTag>>,\n+        ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n         align: Option<Align>,\n         msg: CheckInAllocMsg,\n-        alloc_size: impl FnOnce(AllocId, Size, M::TagExtra) -> InterpResult<'tcx, (Size, Align, T)>,\n+        alloc_size: impl FnOnce(\n+            AllocId,\n+            Size,\n+            M::ProvenanceExtra,\n+        ) -> InterpResult<'tcx, (Size, Align, T)>,\n     ) -> InterpResult<'tcx, Option<T>> {\n         fn check_offset_align<'tcx>(offset: u64, align: Align) -> InterpResult<'tcx> {\n             if offset % align.bytes() == 0 {\n@@ -417,8 +421,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n                 None\n             }\n-            Ok((alloc_id, offset, tag)) => {\n-                let (alloc_size, alloc_align, ret_val) = alloc_size(alloc_id, offset, tag)?;\n+            Ok((alloc_id, offset, prov)) => {\n+                let (alloc_size, alloc_align, ret_val) = alloc_size(alloc_id, offset, prov)?;\n                 // Test bounds. This also ensures non-null.\n                 // It is sufficient to check this for the end pointer. Also check for overflow!\n                 if offset.checked_add(size, &self.tcx).map_or(true, |end| end > alloc_size) {\n@@ -431,7 +435,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     })\n                 }\n                 // Ensure we never consider the null pointer dereferencable.\n-                if M::PointerTag::OFFSET_IS_ADDR {\n+                if M::Provenance::OFFSET_IS_ADDR {\n                     assert_ne!(ptr.addr(), Size::ZERO);\n                 }\n                 // Test align. Check this last; if both bounds and alignment are violated\n@@ -462,13 +466,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Helper function to obtain a global (tcx) allocation.\n     /// This attempts to return a reference to an existing allocation if\n     /// one can be found in `tcx`. That, however, is only possible if `tcx` and\n-    /// this machine use the same pointer tag, so it is indirected through\n-    /// `M::tag_allocation`.\n+    /// this machine use the same pointer provenance, so it is indirected through\n+    /// `M::adjust_allocation`.\n     fn get_global_alloc(\n         &self,\n         id: AllocId,\n         is_write: bool,\n-    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::Provenance, M::AllocExtra>>> {\n         let (alloc, def_id) = match self.tcx.get_global_alloc(id) {\n             Some(GlobalAlloc::Memory(mem)) => {\n                 // Memory of a constant or promoted or anonymous memory referenced by a static.\n@@ -499,7 +503,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n         M::before_access_global(*self.tcx, &self.machine, id, alloc, def_id, is_write)?;\n         // We got tcx memory. Let the machine initialize its \"extra\" stuff.\n-        M::init_allocation_extra(\n+        M::adjust_allocation(\n             self,\n             id, // always use the ID we got as input, not the \"hidden\" one.\n             Cow::Borrowed(alloc.inner()),\n@@ -512,11 +516,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn get_alloc_raw(\n         &self,\n         id: AllocId,\n-    ) -> InterpResult<'tcx, &Allocation<M::PointerTag, M::AllocExtra>> {\n+    ) -> InterpResult<'tcx, &Allocation<M::Provenance, M::AllocExtra>> {\n         // The error type of the inner closure here is somewhat funny.  We have two\n         // ways of \"erroring\": An actual error, or because we got a reference from\n         // `get_global_alloc` that we can actually use directly without inserting anything anywhere.\n-        // So the error type is `InterpResult<'tcx, &Allocation<M::PointerTag>>`.\n+        // So the error type is `InterpResult<'tcx, &Allocation<M::Provenance>>`.\n         let a = self.memory.alloc_map.get_or(id, || {\n             let alloc = self.get_global_alloc(id, /*is_write*/ false).map_err(Err)?;\n             match alloc {\n@@ -545,24 +549,24 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// \"Safe\" (bounds and align-checked) allocation access.\n     pub fn get_ptr_alloc<'a>(\n         &'a self,\n-        ptr: Pointer<Option<M::PointerTag>>,\n+        ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n         align: Align,\n-    ) -> InterpResult<'tcx, Option<AllocRef<'a, 'tcx, M::PointerTag, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Option<AllocRef<'a, 'tcx, M::Provenance, M::AllocExtra>>> {\n         let align = M::enforce_alignment(self).then_some(align);\n         let ptr_and_alloc = self.check_and_deref_ptr(\n             ptr,\n             size,\n             align,\n             CheckInAllocMsg::MemoryAccessTest,\n-            |alloc_id, offset, tag| {\n+            |alloc_id, offset, prov| {\n                 let alloc = self.get_alloc_raw(alloc_id)?;\n-                Ok((alloc.size(), alloc.align, (alloc_id, offset, tag, alloc)))\n+                Ok((alloc.size(), alloc.align, (alloc_id, offset, prov, alloc)))\n             },\n         )?;\n-        if let Some((alloc_id, offset, tag, alloc)) = ptr_and_alloc {\n+        if let Some((alloc_id, offset, prov, alloc)) = ptr_and_alloc {\n             let range = alloc_range(offset, size);\n-            M::memory_read(*self.tcx, &self.machine, &alloc.extra, (alloc_id, tag), range)?;\n+            M::memory_read(*self.tcx, &self.machine, &alloc.extra, (alloc_id, prov), range)?;\n             Ok(Some(AllocRef { alloc, range, tcx: *self.tcx, alloc_id }))\n         } else {\n             // Even in this branch we have to be sure that we actually access the allocation, in\n@@ -586,7 +590,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn get_alloc_raw_mut(\n         &mut self,\n         id: AllocId,\n-    ) -> InterpResult<'tcx, (&mut Allocation<M::PointerTag, M::AllocExtra>, &mut M)> {\n+    ) -> InterpResult<'tcx, (&mut Allocation<M::Provenance, M::AllocExtra>, &mut M)> {\n         // We have \"NLL problem case #3\" here, which cannot be worked around without loss of\n         // efficiency even for the common case where the key is in the map.\n         // <https://rust-lang.github.io/rfcs/2094-nll.html#problem-case-3-conditional-control-flow-across-functions>\n@@ -612,18 +616,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// \"Safe\" (bounds and align-checked) allocation access.\n     pub fn get_ptr_alloc_mut<'a>(\n         &'a mut self,\n-        ptr: Pointer<Option<M::PointerTag>>,\n+        ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n         align: Align,\n-    ) -> InterpResult<'tcx, Option<AllocRefMut<'a, 'tcx, M::PointerTag, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Option<AllocRefMut<'a, 'tcx, M::Provenance, M::AllocExtra>>> {\n         let parts = self.get_ptr_access(ptr, size, align)?;\n-        if let Some((alloc_id, offset, tag)) = parts {\n+        if let Some((alloc_id, offset, prov)) = parts {\n             let tcx = *self.tcx;\n             // FIXME: can we somehow avoid looking up the allocation twice here?\n             // We cannot call `get_raw_mut` inside `check_and_deref_ptr` as that would duplicate `&mut self`.\n             let (alloc, machine) = self.get_alloc_raw_mut(alloc_id)?;\n             let range = alloc_range(offset, size);\n-            M::memory_written(tcx, machine, &mut alloc.extra, (alloc_id, tag), range)?;\n+            M::memory_written(tcx, machine, &mut alloc.extra, (alloc_id, prov), range)?;\n             Ok(Some(AllocRefMut { alloc, range, tcx, alloc_id }))\n         } else {\n             Ok(None)\n@@ -710,10 +714,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     pub fn get_ptr_fn(\n         &self,\n-        ptr: Pointer<Option<M::PointerTag>>,\n+        ptr: Pointer<Option<M::Provenance>>,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         trace!(\"get_fn({:?})\", ptr);\n-        let (alloc_id, offset, _tag) = self.ptr_get_alloc_id(ptr)?;\n+        let (alloc_id, offset, _prov) = self.ptr_get_alloc_id(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub!(InvalidFunctionPointer(Pointer::new(alloc_id, offset)))\n         }\n@@ -759,7 +763,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // This is a new allocation, add its relocations to `todo`.\n                     if let Some((_, alloc)) = self.memory.alloc_map.get(id) {\n                         todo.extend(\n-                            alloc.relocations().values().filter_map(|tag| tag.get_alloc_id()),\n+                            alloc.relocations().values().filter_map(|prov| prov.get_alloc_id()),\n                         );\n                     }\n                 }\n@@ -788,14 +792,14 @@ pub struct DumpAllocs<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a, 'mir, 'tcx, M> {\n     fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        // Cannot be a closure because it is generic in `Tag`, `Extra`.\n-        fn write_allocation_track_relocs<'tcx, Tag: Provenance, Extra>(\n+        // Cannot be a closure because it is generic in `Prov`, `Extra`.\n+        fn write_allocation_track_relocs<'tcx, Prov: Provenance, Extra>(\n             fmt: &mut std::fmt::Formatter<'_>,\n             tcx: TyCtxt<'tcx>,\n             allocs_to_print: &mut VecDeque<AllocId>,\n-            alloc: &Allocation<Tag, Extra>,\n+            alloc: &Allocation<Prov, Extra>,\n         ) -> std::fmt::Result {\n-            for alloc_id in alloc.relocations().values().filter_map(|tag| tag.get_alloc_id()) {\n+            for alloc_id in alloc.relocations().values().filter_map(|prov| prov.get_alloc_id()) {\n                 allocs_to_print.push_back(alloc_id);\n             }\n             write!(fmt, \"{}\", display_allocation(tcx, alloc))\n@@ -854,12 +858,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n }\n \n /// Reading and writing.\n-impl<'tcx, 'a, Tag: Provenance, Extra> AllocRefMut<'a, 'tcx, Tag, Extra> {\n+impl<'tcx, 'a, Prov: Provenance, Extra> AllocRefMut<'a, 'tcx, Prov, Extra> {\n     /// `range` is relative to this allocation reference, not the base of the allocation.\n     pub fn write_scalar(\n         &mut self,\n         range: AllocRange,\n-        val: ScalarMaybeUninit<Tag>,\n+        val: ScalarMaybeUninit<Prov>,\n     ) -> InterpResult<'tcx> {\n         let range = self.range.subrange(range);\n         debug!(\"write_scalar at {:?}{range:?}: {val:?}\", self.alloc_id);\n@@ -873,7 +877,7 @@ impl<'tcx, 'a, Tag: Provenance, Extra> AllocRefMut<'a, 'tcx, Tag, Extra> {\n     pub fn write_ptr_sized(\n         &mut self,\n         offset: Size,\n-        val: ScalarMaybeUninit<Tag>,\n+        val: ScalarMaybeUninit<Prov>,\n     ) -> InterpResult<'tcx> {\n         self.write_scalar(alloc_range(offset, self.tcx.data_layout().pointer_size), val)\n     }\n@@ -887,13 +891,13 @@ impl<'tcx, 'a, Tag: Provenance, Extra> AllocRefMut<'a, 'tcx, Tag, Extra> {\n     }\n }\n \n-impl<'tcx, 'a, Tag: Provenance, Extra> AllocRef<'a, 'tcx, Tag, Extra> {\n+impl<'tcx, 'a, Prov: Provenance, Extra> AllocRef<'a, 'tcx, Prov, Extra> {\n     /// `range` is relative to this allocation reference, not the base of the allocation.\n     pub fn read_scalar(\n         &self,\n         range: AllocRange,\n         read_provenance: bool,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<Prov>> {\n         let range = self.range.subrange(range);\n         let res = self\n             .alloc\n@@ -904,12 +908,12 @@ impl<'tcx, 'a, Tag: Provenance, Extra> AllocRef<'a, 'tcx, Tag, Extra> {\n     }\n \n     /// `range` is relative to this allocation reference, not the base of the allocation.\n-    pub fn read_integer(&self, range: AllocRange) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    pub fn read_integer(&self, range: AllocRange) -> InterpResult<'tcx, ScalarMaybeUninit<Prov>> {\n         self.read_scalar(range, /*read_provenance*/ false)\n     }\n \n     /// `offset` is relative to this allocation reference, not the base of the allocation.\n-    pub fn read_pointer(&self, offset: Size) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    pub fn read_pointer(&self, offset: Size) -> InterpResult<'tcx, ScalarMaybeUninit<Prov>> {\n         self.read_scalar(\n             alloc_range(offset, self.tcx.data_layout().pointer_size),\n             /*read_provenance*/ true,\n@@ -941,7 +945,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Performs appropriate bounds checks.\n     pub fn read_bytes_ptr(\n         &self,\n-        ptr: Pointer<Option<M::PointerTag>>,\n+        ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n     ) -> InterpResult<'tcx, &[u8]> {\n         let Some(alloc_ref) = self.get_ptr_alloc(ptr, size, Align::ONE)? else {\n@@ -961,7 +965,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Performs appropriate bounds checks.\n     pub fn write_bytes_ptr(\n         &mut self,\n-        ptr: Pointer<Option<M::PointerTag>>,\n+        ptr: Pointer<Option<M::Provenance>>,\n         src: impl IntoIterator<Item = u8>,\n     ) -> InterpResult<'tcx> {\n         let mut src = src.into_iter();\n@@ -998,9 +1002,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     pub fn mem_copy(\n         &mut self,\n-        src: Pointer<Option<M::PointerTag>>,\n+        src: Pointer<Option<M::Provenance>>,\n         src_align: Align,\n-        dest: Pointer<Option<M::PointerTag>>,\n+        dest: Pointer<Option<M::Provenance>>,\n         dest_align: Align,\n         size: Size,\n         nonoverlapping: bool,\n@@ -1010,9 +1014,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     pub fn mem_copy_repeatedly(\n         &mut self,\n-        src: Pointer<Option<M::PointerTag>>,\n+        src: Pointer<Option<M::Provenance>>,\n         src_align: Align,\n-        dest: Pointer<Option<M::PointerTag>>,\n+        dest: Pointer<Option<M::Provenance>>,\n         dest_align: Align,\n         size: Size,\n         num_copies: u64,\n@@ -1027,16 +1031,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // and once below to get the underlying `&[mut] Allocation`.\n \n         // Source alloc preparations and access hooks.\n-        let Some((src_alloc_id, src_offset, src_tag)) = src_parts else {\n+        let Some((src_alloc_id, src_offset, src_prov)) = src_parts else {\n             // Zero-sized *source*, that means dst is also zero-sized and we have nothing to do.\n             return Ok(());\n         };\n         let src_alloc = self.get_alloc_raw(src_alloc_id)?;\n         let src_range = alloc_range(src_offset, size);\n-        M::memory_read(*tcx, &self.machine, &src_alloc.extra, (src_alloc_id, src_tag), src_range)?;\n+        M::memory_read(*tcx, &self.machine, &src_alloc.extra, (src_alloc_id, src_prov), src_range)?;\n         // We need the `dest` ptr for the next operation, so we get it now.\n         // We already did the source checks and called the hooks so we are good to return early.\n-        let Some((dest_alloc_id, dest_offset, dest_tag)) = dest_parts else {\n+        let Some((dest_alloc_id, dest_offset, dest_prov)) = dest_parts else {\n             // Zero-sized *destination*.\n             return Ok(());\n         };\n@@ -1062,7 +1066,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             *tcx,\n             extra,\n             &mut dest_alloc.extra,\n-            (dest_alloc_id, dest_tag),\n+            (dest_alloc_id, dest_prov),\n             dest_range,\n         )?;\n         let dest_bytes = dest_alloc\n@@ -1135,8 +1139,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn scalar_to_ptr(\n         &self,\n-        scalar: Scalar<M::PointerTag>,\n-    ) -> InterpResult<'tcx, Pointer<Option<M::PointerTag>>> {\n+        scalar: Scalar<M::Provenance>,\n+    ) -> InterpResult<'tcx, Pointer<Option<M::Provenance>>> {\n         // We use `to_bits_or_ptr_internal` since we are just implementing the method people need to\n         // call to force getting out a pointer.\n         Ok(\n@@ -1155,7 +1159,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     /// Test if this value might be null.\n     /// If the machine does not support ptr-to-int casts, this is conservative.\n-    pub fn scalar_may_be_null(&self, scalar: Scalar<M::PointerTag>) -> InterpResult<'tcx, bool> {\n+    pub fn scalar_may_be_null(&self, scalar: Scalar<M::Provenance>) -> InterpResult<'tcx, bool> {\n         Ok(match scalar.try_to_int() {\n             Ok(int) => int.is_null(),\n             Err(_) => {\n@@ -1178,13 +1182,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// about where it points), or an absolute address.\n     pub fn ptr_try_get_alloc_id(\n         &self,\n-        ptr: Pointer<Option<M::PointerTag>>,\n-    ) -> Result<(AllocId, Size, M::TagExtra), u64> {\n+        ptr: Pointer<Option<M::Provenance>>,\n+    ) -> Result<(AllocId, Size, M::ProvenanceExtra), u64> {\n         match ptr.into_pointer_or_addr() {\n             Ok(ptr) => match M::ptr_get_alloc(self, ptr) {\n                 Some((alloc_id, offset, extra)) => Ok((alloc_id, offset, extra)),\n                 None => {\n-                    assert!(M::PointerTag::OFFSET_IS_ADDR);\n+                    assert!(M::Provenance::OFFSET_IS_ADDR);\n                     let (_, addr) = ptr.into_parts();\n                     Err(addr.bytes())\n                 }\n@@ -1197,8 +1201,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline(always)]\n     pub fn ptr_get_alloc_id(\n         &self,\n-        ptr: Pointer<Option<M::PointerTag>>,\n-    ) -> InterpResult<'tcx, (AllocId, Size, M::TagExtra)> {\n+        ptr: Pointer<Option<M::Provenance>>,\n+    ) -> InterpResult<'tcx, (AllocId, Size, M::ProvenanceExtra)> {\n         self.ptr_try_get_alloc_id(ptr).map_err(|offset| {\n             err_ub!(DanglingIntPointer(offset, CheckInAllocMsg::InboundsTest)).into()\n         })"}, {"sha": "7e5c6feb048d24d2b4e9ce7b838c7bf139c72efa", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 73, "deletions": 73, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -25,59 +25,59 @@ use super::{\n /// In particular, thanks to `ScalarPair`, arithmetic operations and casts can be entirely\n /// defined on `Immediate`, and do not have to work with a `Place`.\n #[derive(Copy, Clone, Debug)]\n-pub enum Immediate<Tag: Provenance = AllocId> {\n+pub enum Immediate<Prov: Provenance = AllocId> {\n     /// A single scalar value (must have *initialized* `Scalar` ABI).\n     /// FIXME: we also currently often use this for ZST.\n     /// `ScalarMaybeUninit` should reject ZST, and we should use `Uninit` for them instead.\n-    Scalar(ScalarMaybeUninit<Tag>),\n+    Scalar(ScalarMaybeUninit<Prov>),\n     /// A pair of two scalar value (must have `ScalarPair` ABI where both fields are\n     /// `Scalar::Initialized`).\n-    ScalarPair(ScalarMaybeUninit<Tag>, ScalarMaybeUninit<Tag>),\n+    ScalarPair(ScalarMaybeUninit<Prov>, ScalarMaybeUninit<Prov>),\n     /// A value of fully uninitialized memory. Can have and size and layout.\n     Uninit,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Immediate, 56);\n \n-impl<Tag: Provenance> From<ScalarMaybeUninit<Tag>> for Immediate<Tag> {\n+impl<Prov: Provenance> From<ScalarMaybeUninit<Prov>> for Immediate<Prov> {\n     #[inline(always)]\n-    fn from(val: ScalarMaybeUninit<Tag>) -> Self {\n+    fn from(val: ScalarMaybeUninit<Prov>) -> Self {\n         Immediate::Scalar(val)\n     }\n }\n \n-impl<Tag: Provenance> From<Scalar<Tag>> for Immediate<Tag> {\n+impl<Prov: Provenance> From<Scalar<Prov>> for Immediate<Prov> {\n     #[inline(always)]\n-    fn from(val: Scalar<Tag>) -> Self {\n+    fn from(val: Scalar<Prov>) -> Self {\n         Immediate::Scalar(val.into())\n     }\n }\n \n-impl<'tcx, Tag: Provenance> Immediate<Tag> {\n-    pub fn from_pointer(p: Pointer<Tag>, cx: &impl HasDataLayout) -> Self {\n+impl<'tcx, Prov: Provenance> Immediate<Prov> {\n+    pub fn from_pointer(p: Pointer<Prov>, cx: &impl HasDataLayout) -> Self {\n         Immediate::Scalar(ScalarMaybeUninit::from_pointer(p, cx))\n     }\n \n-    pub fn from_maybe_pointer(p: Pointer<Option<Tag>>, cx: &impl HasDataLayout) -> Self {\n+    pub fn from_maybe_pointer(p: Pointer<Option<Prov>>, cx: &impl HasDataLayout) -> Self {\n         Immediate::Scalar(ScalarMaybeUninit::from_maybe_pointer(p, cx))\n     }\n \n-    pub fn new_slice(val: Scalar<Tag>, len: u64, cx: &impl HasDataLayout) -> Self {\n+    pub fn new_slice(val: Scalar<Prov>, len: u64, cx: &impl HasDataLayout) -> Self {\n         Immediate::ScalarPair(val.into(), Scalar::from_machine_usize(len, cx).into())\n     }\n \n     pub fn new_dyn_trait(\n-        val: Scalar<Tag>,\n-        vtable: Pointer<Option<Tag>>,\n+        val: Scalar<Prov>,\n+        vtable: Pointer<Option<Prov>>,\n         cx: &impl HasDataLayout,\n     ) -> Self {\n         Immediate::ScalarPair(val.into(), ScalarMaybeUninit::from_maybe_pointer(vtable, cx))\n     }\n \n     #[inline]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n-    pub fn to_scalar_or_uninit(self) -> ScalarMaybeUninit<Tag> {\n+    pub fn to_scalar_or_uninit(self) -> ScalarMaybeUninit<Prov> {\n         match self {\n             Immediate::Scalar(val) => val,\n             Immediate::ScalarPair(..) => bug!(\"Got a scalar pair where a scalar was expected\"),\n@@ -87,13 +87,13 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n \n     #[inline]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n-    pub fn to_scalar(self) -> InterpResult<'tcx, Scalar<Tag>> {\n+    pub fn to_scalar(self) -> InterpResult<'tcx, Scalar<Prov>> {\n         self.to_scalar_or_uninit().check_init()\n     }\n \n     #[inline]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n-    pub fn to_scalar_or_uninit_pair(self) -> (ScalarMaybeUninit<Tag>, ScalarMaybeUninit<Tag>) {\n+    pub fn to_scalar_or_uninit_pair(self) -> (ScalarMaybeUninit<Prov>, ScalarMaybeUninit<Prov>) {\n         match self {\n             Immediate::ScalarPair(val1, val2) => (val1, val2),\n             Immediate::Scalar(..) => bug!(\"Got a scalar where a scalar pair was expected\"),\n@@ -103,7 +103,7 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n \n     #[inline]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n-    pub fn to_scalar_pair(self) -> InterpResult<'tcx, (Scalar<Tag>, Scalar<Tag>)> {\n+    pub fn to_scalar_pair(self) -> InterpResult<'tcx, (Scalar<Prov>, Scalar<Prov>)> {\n         let (val1, val2) = self.to_scalar_or_uninit_pair();\n         Ok((val1.check_init()?, val2.check_init()?))\n     }\n@@ -112,20 +112,20 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n // ScalarPair needs a type to interpret, so we often have an immediate and a type together\n // as input for binary and cast operations.\n #[derive(Clone, Debug)]\n-pub struct ImmTy<'tcx, Tag: Provenance = AllocId> {\n-    imm: Immediate<Tag>,\n+pub struct ImmTy<'tcx, Prov: Provenance = AllocId> {\n+    imm: Immediate<Prov>,\n     pub layout: TyAndLayout<'tcx>,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(ImmTy<'_>, 72);\n \n-impl<Tag: Provenance> std::fmt::Display for ImmTy<'_, Tag> {\n+impl<Prov: Provenance> std::fmt::Display for ImmTy<'_, Prov> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         /// Helper function for printing a scalar to a FmtPrinter\n-        fn p<'a, 'tcx, Tag: Provenance>(\n+        fn p<'a, 'tcx, Prov: Provenance>(\n             cx: FmtPrinter<'a, 'tcx>,\n-            s: ScalarMaybeUninit<Tag>,\n+            s: ScalarMaybeUninit<Prov>,\n             ty: Ty<'tcx>,\n         ) -> Result<FmtPrinter<'a, 'tcx>, std::fmt::Error> {\n             match s {\n@@ -170,10 +170,10 @@ impl<Tag: Provenance> std::fmt::Display for ImmTy<'_, Tag> {\n     }\n }\n \n-impl<'tcx, Tag: Provenance> std::ops::Deref for ImmTy<'tcx, Tag> {\n-    type Target = Immediate<Tag>;\n+impl<'tcx, Prov: Provenance> std::ops::Deref for ImmTy<'tcx, Prov> {\n+    type Target = Immediate<Prov>;\n     #[inline(always)]\n-    fn deref(&self) -> &Immediate<Tag> {\n+    fn deref(&self) -> &Immediate<Prov> {\n         &self.imm\n     }\n }\n@@ -182,17 +182,17 @@ impl<'tcx, Tag: Provenance> std::ops::Deref for ImmTy<'tcx, Tag> {\n /// or still in memory. The latter is an optimization, to delay reading that chunk of\n /// memory and to avoid having to store arbitrary-sized data here.\n #[derive(Copy, Clone, Debug)]\n-pub enum Operand<Tag: Provenance = AllocId> {\n-    Immediate(Immediate<Tag>),\n-    Indirect(MemPlace<Tag>),\n+pub enum Operand<Prov: Provenance = AllocId> {\n+    Immediate(Immediate<Prov>),\n+    Indirect(MemPlace<Prov>),\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Operand, 64);\n \n #[derive(Clone, Debug)]\n-pub struct OpTy<'tcx, Tag: Provenance = AllocId> {\n-    op: Operand<Tag>, // Keep this private; it helps enforce invariants.\n+pub struct OpTy<'tcx, Prov: Provenance = AllocId> {\n+    op: Operand<Prov>, // Keep this private; it helps enforce invariants.\n     pub layout: TyAndLayout<'tcx>,\n     /// rustc does not have a proper way to represent the type of a field of a `repr(packed)` struct:\n     /// it needs to have a different alignment than the field type would usually have.\n@@ -207,50 +207,50 @@ pub struct OpTy<'tcx, Tag: Provenance = AllocId> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(OpTy<'_>, 88);\n \n-impl<'tcx, Tag: Provenance> std::ops::Deref for OpTy<'tcx, Tag> {\n-    type Target = Operand<Tag>;\n+impl<'tcx, Prov: Provenance> std::ops::Deref for OpTy<'tcx, Prov> {\n+    type Target = Operand<Prov>;\n     #[inline(always)]\n-    fn deref(&self) -> &Operand<Tag> {\n+    fn deref(&self) -> &Operand<Prov> {\n         &self.op\n     }\n }\n \n-impl<'tcx, Tag: Provenance> From<MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n+impl<'tcx, Prov: Provenance> From<MPlaceTy<'tcx, Prov>> for OpTy<'tcx, Prov> {\n     #[inline(always)]\n-    fn from(mplace: MPlaceTy<'tcx, Tag>) -> Self {\n+    fn from(mplace: MPlaceTy<'tcx, Prov>) -> Self {\n         OpTy { op: Operand::Indirect(*mplace), layout: mplace.layout, align: Some(mplace.align) }\n     }\n }\n \n-impl<'tcx, Tag: Provenance> From<&'_ MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n+impl<'tcx, Prov: Provenance> From<&'_ MPlaceTy<'tcx, Prov>> for OpTy<'tcx, Prov> {\n     #[inline(always)]\n-    fn from(mplace: &MPlaceTy<'tcx, Tag>) -> Self {\n+    fn from(mplace: &MPlaceTy<'tcx, Prov>) -> Self {\n         OpTy { op: Operand::Indirect(**mplace), layout: mplace.layout, align: Some(mplace.align) }\n     }\n }\n \n-impl<'tcx, Tag: Provenance> From<&'_ mut MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n+impl<'tcx, Prov: Provenance> From<&'_ mut MPlaceTy<'tcx, Prov>> for OpTy<'tcx, Prov> {\n     #[inline(always)]\n-    fn from(mplace: &mut MPlaceTy<'tcx, Tag>) -> Self {\n+    fn from(mplace: &mut MPlaceTy<'tcx, Prov>) -> Self {\n         OpTy { op: Operand::Indirect(**mplace), layout: mplace.layout, align: Some(mplace.align) }\n     }\n }\n \n-impl<'tcx, Tag: Provenance> From<ImmTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n+impl<'tcx, Prov: Provenance> From<ImmTy<'tcx, Prov>> for OpTy<'tcx, Prov> {\n     #[inline(always)]\n-    fn from(val: ImmTy<'tcx, Tag>) -> Self {\n+    fn from(val: ImmTy<'tcx, Prov>) -> Self {\n         OpTy { op: Operand::Immediate(val.imm), layout: val.layout, align: None }\n     }\n }\n \n-impl<'tcx, Tag: Provenance> ImmTy<'tcx, Tag> {\n+impl<'tcx, Prov: Provenance> ImmTy<'tcx, Prov> {\n     #[inline]\n-    pub fn from_scalar(val: Scalar<Tag>, layout: TyAndLayout<'tcx>) -> Self {\n+    pub fn from_scalar(val: Scalar<Prov>, layout: TyAndLayout<'tcx>) -> Self {\n         ImmTy { imm: val.into(), layout }\n     }\n \n     #[inline]\n-    pub fn from_immediate(imm: Immediate<Tag>, layout: TyAndLayout<'tcx>) -> Self {\n+    pub fn from_immediate(imm: Immediate<Prov>, layout: TyAndLayout<'tcx>) -> Self {\n         ImmTy { imm, layout }\n     }\n \n@@ -286,7 +286,7 @@ impl<'tcx, Tag: Provenance> ImmTy<'tcx, Tag> {\n     }\n }\n \n-impl<'tcx, Tag: Provenance> OpTy<'tcx, Tag> {\n+impl<'tcx, Prov: Provenance> OpTy<'tcx, Prov> {\n     pub fn len(&self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n         if self.layout.is_unsized() {\n             // There are no unsized immediates.\n@@ -302,7 +302,7 @@ impl<'tcx, Tag: Provenance> OpTy<'tcx, Tag> {\n     pub fn offset_with_meta(\n         &self,\n         offset: Size,\n-        meta: MemPlaceMeta<Tag>,\n+        meta: MemPlaceMeta<Prov>,\n         layout: TyAndLayout<'tcx>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n@@ -338,9 +338,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// This is an internal function; call `read_immediate` instead.\n     fn read_immediate_from_mplace_raw(\n         &self,\n-        mplace: &MPlaceTy<'tcx, M::PointerTag>,\n+        mplace: &MPlaceTy<'tcx, M::Provenance>,\n         force: bool,\n-    ) -> InterpResult<'tcx, Option<ImmTy<'tcx, M::PointerTag>>> {\n+    ) -> InterpResult<'tcx, Option<ImmTy<'tcx, M::Provenance>>> {\n         if mplace.layout.is_unsized() {\n             // Don't touch unsized\n             return Ok(None);\n@@ -418,9 +418,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// ConstProp needs it, though.\n     pub fn read_immediate_raw(\n         &self,\n-        src: &OpTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::Provenance>,\n         force: bool,\n-    ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::PointerTag>, MPlaceTy<'tcx, M::PointerTag>>> {\n+    ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::Provenance>, MPlaceTy<'tcx, M::Provenance>>> {\n         Ok(match src.try_as_mplace() {\n             Ok(ref mplace) => {\n                 if let Some(val) = self.read_immediate_from_mplace_raw(mplace, force)? {\n@@ -437,8 +437,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline(always)]\n     pub fn read_immediate(\n         &self,\n-        op: &OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n+        op: &OpTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, M::Provenance>> {\n         if let Ok(imm) = self.read_immediate_raw(op, /*force*/ false)? {\n             Ok(imm)\n         } else {\n@@ -449,21 +449,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Read a scalar from a place\n     pub fn read_scalar(\n         &self,\n-        op: &OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<M::PointerTag>> {\n+        op: &OpTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<M::Provenance>> {\n         Ok(self.read_immediate(op)?.to_scalar_or_uninit())\n     }\n \n     /// Read a pointer from a place.\n     pub fn read_pointer(\n         &self,\n-        op: &OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, Pointer<Option<M::PointerTag>>> {\n+        op: &OpTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, Pointer<Option<M::Provenance>>> {\n         self.scalar_to_ptr(self.read_scalar(op)?.check_init()?)\n     }\n \n     /// Turn the wide MPlace into a string (must already be dereferenced!)\n-    pub fn read_str(&self, mplace: &MPlaceTy<'tcx, M::PointerTag>) -> InterpResult<'tcx, &str> {\n+    pub fn read_str(&self, mplace: &MPlaceTy<'tcx, M::Provenance>) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n         let bytes = self.read_bytes_ptr(mplace.ptr, Size::from_bytes(len))?;\n         let str = std::str::from_utf8(bytes).map_err(|err| err_ub!(InvalidStr(err)))?;\n@@ -476,8 +476,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Can (but does not always) trigger UB if `op` is uninitialized.\n     pub fn operand_to_simd(\n         &self,\n-        op: &OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, u64)> {\n+        op: &OpTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::Provenance>, u64)> {\n         // Basically we just transmute this place into an array following simd_size_and_type.\n         // This only works in memory, but repr(simd) types should never be immediates anyway.\n         assert!(op.layout.ty.is_simd());\n@@ -501,10 +501,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// OpTy from a local.\n     pub fn local_to_op(\n         &self,\n-        frame: &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n+        frame: &Frame<'mir, 'tcx, M::Provenance, M::FrameExtra>,\n         local: mir::Local,\n         layout: Option<TyAndLayout<'tcx>>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         let layout = self.layout_of_local(frame, local, layout)?;\n         let op = if layout.is_zst() {\n             // Bypass `access_local` (helps in ConstProp)\n@@ -521,8 +521,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline(always)]\n     pub fn place_to_op(\n         &self,\n-        place: &PlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        place: &PlaceTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         let op = match **place {\n             Place::Ptr(mplace) => Operand::Indirect(mplace),\n             Place::Local { frame, local } => {\n@@ -538,7 +538,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         mir_place: mir::Place<'tcx>,\n         layout: Option<TyAndLayout<'tcx>>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         // Do not use the layout passed in as argument if the base we are looking at\n         // here is not the entire place.\n         let layout = if mir_place.projection.is_empty() { layout } else { None };\n@@ -575,7 +575,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         mir_op: &mir::Operand<'tcx>,\n         layout: Option<TyAndLayout<'tcx>>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         use rustc_middle::mir::Operand::*;\n         let op = match *mir_op {\n             // FIXME: do some more logic on `move` to invalidate the old location\n@@ -600,7 +600,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub(super) fn eval_operands(\n         &self,\n         ops: &[mir::Operand<'tcx>],\n-    ) -> InterpResult<'tcx, Vec<OpTy<'tcx, M::PointerTag>>> {\n+    ) -> InterpResult<'tcx, Vec<OpTy<'tcx, M::Provenance>>> {\n         ops.iter().map(|op| self.eval_operand(op, None)).collect()\n     }\n \n@@ -612,7 +612,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         c: ty::Const<'tcx>,\n         layout: Option<TyAndLayout<'tcx>>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         match c.kind() {\n             ty::ConstKind::Param(_) | ty::ConstKind::Bound(..) => throw_inval!(TooGeneric),\n             ty::ConstKind::Error(DelaySpanBugEmitted { reported, .. }) => {\n@@ -637,7 +637,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         val: &mir::ConstantKind<'tcx>,\n         layout: Option<TyAndLayout<'tcx>>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         match val {\n             mir::ConstantKind::Ty(ct) => self.const_to_op(*ct, layout),\n             mir::ConstantKind::Val(val, ty) => self.const_val_to_op(*val, *ty, layout),\n@@ -649,9 +649,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         val_val: ConstValue<'tcx>,\n         ty: Ty<'tcx>,\n         layout: Option<TyAndLayout<'tcx>>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         // Other cases need layout.\n-        let tag_scalar = |scalar| -> InterpResult<'tcx, _> {\n+        let adjust_scalar = |scalar| -> InterpResult<'tcx, _> {\n             Ok(match scalar {\n                 Scalar::Ptr(ptr, size) => Scalar::Ptr(self.global_base_pointer(ptr)?, size),\n                 Scalar::Int(int) => Scalar::Int(int),\n@@ -666,7 +666,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let ptr = self.global_base_pointer(Pointer::new(id, offset))?;\n                 Operand::Indirect(MemPlace::from_ptr(ptr.into()))\n             }\n-            ConstValue::Scalar(x) => Operand::Immediate(tag_scalar(x)?.into()),\n+            ConstValue::Scalar(x) => Operand::Immediate(adjust_scalar(x)?.into()),\n             ConstValue::ZeroSized => Operand::Immediate(Immediate::Uninit),\n             ConstValue::Slice { data, start, end } => {\n                 // We rely on mutability being set correctly in `data` to prevent writes\n@@ -689,8 +689,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Can also legally be called on non-enums (e.g. through the discriminant_value intrinsic)!\n     pub fn read_discriminant(\n         &self,\n-        op: &OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, VariantIdx)> {\n+        op: &OpTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, (Scalar<M::Provenance>, VariantIdx)> {\n         trace!(\"read_discriminant_value {:#?}\", op.layout);\n         // Get type and layout of the discriminant.\n         let discr_layout = self.layout_of(op.layout.ty.discriminant_ty(*self.tcx))?;"}, {"sha": "f9912d706fb117a64f6cf56d0d7a3a9d0975ef50", "filename": "compiler/rustc_const_eval/src/interpret/operator.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -19,9 +19,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self,\n         op: mir::BinOp,\n         force_overflow_checks: bool,\n-        left: &ImmTy<'tcx, M::PointerTag>,\n-        right: &ImmTy<'tcx, M::PointerTag>,\n-        dest: &PlaceTy<'tcx, M::PointerTag>,\n+        left: &ImmTy<'tcx, M::Provenance>,\n+        right: &ImmTy<'tcx, M::Provenance>,\n+        dest: &PlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx> {\n         let (val, overflowed, ty) = self.overflowing_binary_op(op, &left, &right)?;\n         debug_assert_eq!(\n@@ -58,9 +58,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn binop_ignore_overflow(\n         &mut self,\n         op: mir::BinOp,\n-        left: &ImmTy<'tcx, M::PointerTag>,\n-        right: &ImmTy<'tcx, M::PointerTag>,\n-        dest: &PlaceTy<'tcx, M::PointerTag>,\n+        left: &ImmTy<'tcx, M::Provenance>,\n+        right: &ImmTy<'tcx, M::Provenance>,\n+        dest: &PlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx> {\n         let (val, _overflowed, ty) = self.overflowing_binary_op(op, left, right)?;\n         assert_eq!(ty, dest.layout.ty, \"type mismatch for result of {:?}\", op);\n@@ -74,7 +74,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         bin_op: mir::BinOp,\n         l: char,\n         r: char,\n-    ) -> (Scalar<M::PointerTag>, bool, Ty<'tcx>) {\n+    ) -> (Scalar<M::Provenance>, bool, Ty<'tcx>) {\n         use rustc_middle::mir::BinOp::*;\n \n         let res = match bin_op {\n@@ -94,7 +94,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         bin_op: mir::BinOp,\n         l: bool,\n         r: bool,\n-    ) -> (Scalar<M::PointerTag>, bool, Ty<'tcx>) {\n+    ) -> (Scalar<M::Provenance>, bool, Ty<'tcx>) {\n         use rustc_middle::mir::BinOp::*;\n \n         let res = match bin_op {\n@@ -112,13 +112,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         (Scalar::from_bool(res), false, self.tcx.types.bool)\n     }\n \n-    fn binary_float_op<F: Float + Into<Scalar<M::PointerTag>>>(\n+    fn binary_float_op<F: Float + Into<Scalar<M::Provenance>>>(\n         &self,\n         bin_op: mir::BinOp,\n         ty: Ty<'tcx>,\n         l: F,\n         r: F,\n-    ) -> (Scalar<M::PointerTag>, bool, Ty<'tcx>) {\n+    ) -> (Scalar<M::Provenance>, bool, Ty<'tcx>) {\n         use rustc_middle::mir::BinOp::*;\n \n         let (val, ty) = match bin_op {\n@@ -146,7 +146,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         left_layout: TyAndLayout<'tcx>,\n         r: u128,\n         right_layout: TyAndLayout<'tcx>,\n-    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool, Ty<'tcx>)> {\n+    ) -> InterpResult<'tcx, (Scalar<M::Provenance>, bool, Ty<'tcx>)> {\n         use rustc_middle::mir::BinOp::*;\n \n         // Shift ops can have an RHS with a different numeric type.\n@@ -314,9 +314,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn overflowing_binary_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: &ImmTy<'tcx, M::PointerTag>,\n-        right: &ImmTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool, Ty<'tcx>)> {\n+        left: &ImmTy<'tcx, M::Provenance>,\n+        right: &ImmTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, (Scalar<M::Provenance>, bool, Ty<'tcx>)> {\n         trace!(\n             \"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n             bin_op,\n@@ -393,9 +393,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn binary_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: &ImmTy<'tcx, M::PointerTag>,\n-        right: &ImmTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n+        left: &ImmTy<'tcx, M::Provenance>,\n+        right: &ImmTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, M::Provenance>> {\n         let (val, _overflow, ty) = self.overflowing_binary_op(bin_op, left, right)?;\n         Ok(ImmTy::from_scalar(val, self.layout_of(ty)?))\n     }\n@@ -405,8 +405,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn overflowing_unary_op(\n         &self,\n         un_op: mir::UnOp,\n-        val: &ImmTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool, Ty<'tcx>)> {\n+        val: &ImmTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, (Scalar<M::Provenance>, bool, Ty<'tcx>)> {\n         use rustc_middle::mir::UnOp::*;\n \n         let layout = val.layout;\n@@ -455,8 +455,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn unary_op(\n         &self,\n         un_op: mir::UnOp,\n-        val: &ImmTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n+        val: &ImmTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, M::Provenance>> {\n         let (val, _overflow, ty) = self.overflowing_unary_op(un_op, val)?;\n         Ok(ImmTy::from_scalar(val, self.layout_of(ty)?))\n     }"}, {"sha": "4a45d979a79a2d207320580e0786797e0fe49940", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -18,18 +18,18 @@ use super::{\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]\n /// Information required for the sound usage of a `MemPlace`.\n-pub enum MemPlaceMeta<Tag: Provenance = AllocId> {\n+pub enum MemPlaceMeta<Prov: Provenance = AllocId> {\n     /// The unsized payload (e.g. length for slices or vtable pointer for trait objects).\n-    Meta(Scalar<Tag>),\n+    Meta(Scalar<Prov>),\n     /// `Sized` types or unsized `extern type`\n     None,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(MemPlaceMeta, 24);\n \n-impl<Tag: Provenance> MemPlaceMeta<Tag> {\n-    pub fn unwrap_meta(self) -> Scalar<Tag> {\n+impl<Prov: Provenance> MemPlaceMeta<Prov> {\n+    pub fn unwrap_meta(self) -> Scalar<Prov> {\n         match self {\n             Self::Meta(s) => s,\n             Self::None => {\n@@ -47,22 +47,22 @@ impl<Tag: Provenance> MemPlaceMeta<Tag> {\n }\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]\n-pub struct MemPlace<Tag: Provenance = AllocId> {\n-    /// The pointer can be a pure integer, with the `None` tag.\n-    pub ptr: Pointer<Option<Tag>>,\n+pub struct MemPlace<Prov: Provenance = AllocId> {\n+    /// The pointer can be a pure integer, with the `None` provenance.\n+    pub ptr: Pointer<Option<Prov>>,\n     /// Metadata for unsized places. Interpretation is up to the type.\n     /// Must not be present for sized types, but can be missing for unsized types\n     /// (e.g., `extern type`).\n-    pub meta: MemPlaceMeta<Tag>,\n+    pub meta: MemPlaceMeta<Prov>,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(MemPlace, 40);\n \n /// A MemPlace with its layout. Constructing it is only possible in this module.\n #[derive(Copy, Clone, Hash, Eq, PartialEq, Debug)]\n-pub struct MPlaceTy<'tcx, Tag: Provenance = AllocId> {\n-    mplace: MemPlace<Tag>,\n+pub struct MPlaceTy<'tcx, Prov: Provenance = AllocId> {\n+    mplace: MemPlace<Prov>,\n     pub layout: TyAndLayout<'tcx>,\n     /// rustc does not have a proper way to represent the type of a field of a `repr(packed)` struct:\n     /// it needs to have a different alignment than the field type would usually have.\n@@ -75,9 +75,9 @@ pub struct MPlaceTy<'tcx, Tag: Provenance = AllocId> {\n rustc_data_structures::static_assert_size!(MPlaceTy<'_>, 64);\n \n #[derive(Copy, Clone, Debug)]\n-pub enum Place<Tag: Provenance = AllocId> {\n+pub enum Place<Prov: Provenance = AllocId> {\n     /// A place referring to a value allocated in the `Memory` system.\n-    Ptr(MemPlace<Tag>),\n+    Ptr(MemPlace<Prov>),\n \n     /// To support alloc-free locals, we are able to write directly to a local.\n     /// (Without that optimization, we'd just always be a `MemPlace`.)\n@@ -88,8 +88,8 @@ pub enum Place<Tag: Provenance = AllocId> {\n rustc_data_structures::static_assert_size!(Place, 48);\n \n #[derive(Clone, Debug)]\n-pub struct PlaceTy<'tcx, Tag: Provenance = AllocId> {\n-    place: Place<Tag>, // Keep this private; it helps enforce invariants.\n+pub struct PlaceTy<'tcx, Prov: Provenance = AllocId> {\n+    place: Place<Prov>, // Keep this private; it helps enforce invariants.\n     pub layout: TyAndLayout<'tcx>,\n     /// rustc does not have a proper way to represent the type of a field of a `repr(packed)` struct:\n     /// it needs to have a different alignment than the field type would usually have.\n@@ -101,58 +101,58 @@ pub struct PlaceTy<'tcx, Tag: Provenance = AllocId> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(PlaceTy<'_>, 72);\n \n-impl<'tcx, Tag: Provenance> std::ops::Deref for PlaceTy<'tcx, Tag> {\n-    type Target = Place<Tag>;\n+impl<'tcx, Prov: Provenance> std::ops::Deref for PlaceTy<'tcx, Prov> {\n+    type Target = Place<Prov>;\n     #[inline(always)]\n-    fn deref(&self) -> &Place<Tag> {\n+    fn deref(&self) -> &Place<Prov> {\n         &self.place\n     }\n }\n \n-impl<'tcx, Tag: Provenance> std::ops::Deref for MPlaceTy<'tcx, Tag> {\n-    type Target = MemPlace<Tag>;\n+impl<'tcx, Prov: Provenance> std::ops::Deref for MPlaceTy<'tcx, Prov> {\n+    type Target = MemPlace<Prov>;\n     #[inline(always)]\n-    fn deref(&self) -> &MemPlace<Tag> {\n+    fn deref(&self) -> &MemPlace<Prov> {\n         &self.mplace\n     }\n }\n \n-impl<'tcx, Tag: Provenance> From<MPlaceTy<'tcx, Tag>> for PlaceTy<'tcx, Tag> {\n+impl<'tcx, Prov: Provenance> From<MPlaceTy<'tcx, Prov>> for PlaceTy<'tcx, Prov> {\n     #[inline(always)]\n-    fn from(mplace: MPlaceTy<'tcx, Tag>) -> Self {\n+    fn from(mplace: MPlaceTy<'tcx, Prov>) -> Self {\n         PlaceTy { place: Place::Ptr(*mplace), layout: mplace.layout, align: mplace.align }\n     }\n }\n \n-impl<'tcx, Tag: Provenance> From<&'_ MPlaceTy<'tcx, Tag>> for PlaceTy<'tcx, Tag> {\n+impl<'tcx, Prov: Provenance> From<&'_ MPlaceTy<'tcx, Prov>> for PlaceTy<'tcx, Prov> {\n     #[inline(always)]\n-    fn from(mplace: &MPlaceTy<'tcx, Tag>) -> Self {\n+    fn from(mplace: &MPlaceTy<'tcx, Prov>) -> Self {\n         PlaceTy { place: Place::Ptr(**mplace), layout: mplace.layout, align: mplace.align }\n     }\n }\n \n-impl<'tcx, Tag: Provenance> From<&'_ mut MPlaceTy<'tcx, Tag>> for PlaceTy<'tcx, Tag> {\n+impl<'tcx, Prov: Provenance> From<&'_ mut MPlaceTy<'tcx, Prov>> for PlaceTy<'tcx, Prov> {\n     #[inline(always)]\n-    fn from(mplace: &mut MPlaceTy<'tcx, Tag>) -> Self {\n+    fn from(mplace: &mut MPlaceTy<'tcx, Prov>) -> Self {\n         PlaceTy { place: Place::Ptr(**mplace), layout: mplace.layout, align: mplace.align }\n     }\n }\n \n-impl<Tag: Provenance> MemPlace<Tag> {\n+impl<Prov: Provenance> MemPlace<Prov> {\n     #[inline(always)]\n-    pub fn from_ptr(ptr: Pointer<Option<Tag>>) -> Self {\n+    pub fn from_ptr(ptr: Pointer<Option<Prov>>) -> Self {\n         MemPlace { ptr, meta: MemPlaceMeta::None }\n     }\n \n     /// Adjust the provenance of the main pointer (metadata is unaffected).\n-    pub fn map_provenance(self, f: impl FnOnce(Option<Tag>) -> Option<Tag>) -> Self {\n+    pub fn map_provenance(self, f: impl FnOnce(Option<Prov>) -> Option<Prov>) -> Self {\n         MemPlace { ptr: self.ptr.map_provenance(f), ..self }\n     }\n \n     /// Turn a mplace into a (thin or wide) pointer, as a reference, pointing to the same space.\n     /// This is the inverse of `ref_to_mplace`.\n     #[inline(always)]\n-    pub fn to_ref(self, cx: &impl HasDataLayout) -> Immediate<Tag> {\n+    pub fn to_ref(self, cx: &impl HasDataLayout) -> Immediate<Prov> {\n         match self.meta {\n             MemPlaceMeta::None => Immediate::from(Scalar::from_maybe_pointer(self.ptr, cx)),\n             MemPlaceMeta::Meta(meta) => {\n@@ -165,14 +165,14 @@ impl<Tag: Provenance> MemPlace<Tag> {\n     pub fn offset_with_meta<'tcx>(\n         self,\n         offset: Size,\n-        meta: MemPlaceMeta<Tag>,\n+        meta: MemPlaceMeta<Prov>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n         Ok(MemPlace { ptr: self.ptr.offset(offset, cx)?, meta })\n     }\n }\n \n-impl<Tag: Provenance> Place<Tag> {\n+impl<Prov: Provenance> Place<Prov> {\n     /// Asserts that this points to some local variable.\n     /// Returns the frame idx and the variable idx.\n     #[inline]\n@@ -185,7 +185,7 @@ impl<Tag: Provenance> Place<Tag> {\n     }\n }\n \n-impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n+impl<'tcx, Prov: Provenance> MPlaceTy<'tcx, Prov> {\n     /// Produces a MemPlace that works for ZST but nothing else.\n     /// Conceptually this is a new allocation, but it doesn't actually create an allocation so you\n     /// don't need to worry about memory leaks.\n@@ -201,7 +201,7 @@ impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n     pub fn offset_with_meta(\n         &self,\n         offset: Size,\n-        meta: MemPlaceMeta<Tag>,\n+        meta: MemPlaceMeta<Prov>,\n         layout: TyAndLayout<'tcx>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n@@ -223,15 +223,15 @@ impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub fn from_aligned_ptr(ptr: Pointer<Option<Tag>>, layout: TyAndLayout<'tcx>) -> Self {\n+    pub fn from_aligned_ptr(ptr: Pointer<Option<Prov>>, layout: TyAndLayout<'tcx>) -> Self {\n         MPlaceTy { mplace: MemPlace::from_ptr(ptr), layout, align: layout.align.abi }\n     }\n \n     #[inline]\n     pub fn from_aligned_ptr_with_meta(\n-        ptr: Pointer<Option<Tag>>,\n+        ptr: Pointer<Option<Prov>>,\n         layout: TyAndLayout<'tcx>,\n-        meta: MemPlaceMeta<Tag>,\n+        meta: MemPlaceMeta<Prov>,\n     ) -> Self {\n         let mut mplace = MemPlace::from_ptr(ptr);\n         mplace.meta = meta;\n@@ -258,7 +258,7 @@ impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub(super) fn vtable(&self) -> Scalar<Tag> {\n+    pub(super) fn vtable(&self) -> Scalar<Prov> {\n         match self.layout.ty.kind() {\n             ty::Dynamic(..) => self.mplace.meta.unwrap_meta(),\n             _ => bug!(\"vtable not supported on type {:?}\", self.layout.ty),\n@@ -267,11 +267,11 @@ impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n }\n \n // These are defined here because they produce a place.\n-impl<'tcx, Tag: Provenance> OpTy<'tcx, Tag> {\n+impl<'tcx, Prov: Provenance> OpTy<'tcx, Prov> {\n     #[inline(always)]\n     /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n     /// read from the resulting mplace, not to get its address back.\n-    pub fn try_as_mplace(&self) -> Result<MPlaceTy<'tcx, Tag>, ImmTy<'tcx, Tag>> {\n+    pub fn try_as_mplace(&self) -> Result<MPlaceTy<'tcx, Prov>, ImmTy<'tcx, Prov>> {\n         match **self {\n             Operand::Indirect(mplace) => {\n                 Ok(MPlaceTy { mplace, layout: self.layout, align: self.align.unwrap() })\n@@ -284,15 +284,15 @@ impl<'tcx, Tag: Provenance> OpTy<'tcx, Tag> {\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n     /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n     /// read from the resulting mplace, not to get its address back.\n-    pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Tag> {\n+    pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Prov> {\n         self.try_as_mplace().unwrap()\n     }\n }\n \n-impl<'tcx, Tag: Provenance> PlaceTy<'tcx, Tag> {\n+impl<'tcx, Prov: Provenance> PlaceTy<'tcx, Prov> {\n     /// A place is either an mplace or some local.\n     #[inline]\n-    pub fn try_as_mplace(&self) -> Result<MPlaceTy<'tcx, Tag>, (usize, mir::Local)> {\n+    pub fn try_as_mplace(&self) -> Result<MPlaceTy<'tcx, Prov>, (usize, mir::Local)> {\n         match **self {\n             Place::Ptr(mplace) => Ok(MPlaceTy { mplace, layout: self.layout, align: self.align }),\n             Place::Local { frame, local } => Err((frame, local)),\n@@ -301,16 +301,16 @@ impl<'tcx, Tag: Provenance> PlaceTy<'tcx, Tag> {\n \n     #[inline(always)]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n-    pub fn assert_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n+    pub fn assert_mem_place(self) -> MPlaceTy<'tcx, Prov> {\n         self.try_as_mplace().unwrap()\n     }\n }\n \n // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n-impl<'mir, 'tcx: 'mir, Tag, M> InterpCx<'mir, 'tcx, M>\n+impl<'mir, 'tcx: 'mir, Prov, M> InterpCx<'mir, 'tcx, M>\n where\n-    Tag: Provenance + Eq + Hash + 'static,\n-    M: Machine<'mir, 'tcx, PointerTag = Tag>,\n+    Prov: Provenance + Eq + Hash + 'static,\n+    M: Machine<'mir, 'tcx, Provenance = Prov>,\n {\n     /// Take a value, which represents a (thin or wide) reference, and make it a place.\n     /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref()`.\n@@ -320,8 +320,8 @@ where\n     /// Generally prefer `deref_operand`.\n     pub fn ref_to_mplace(\n         &self,\n-        val: &ImmTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        val: &ImmTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n         let pointee_type =\n             val.layout.ty.builtin_deref(true).expect(\"`ref_to_mplace` called on non-ptr type\").ty;\n         let layout = self.layout_of(pointee_type)?;\n@@ -342,8 +342,8 @@ where\n     #[instrument(skip(self), level = \"debug\")]\n     pub fn deref_operand(\n         &self,\n-        src: &OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        src: &OpTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n         let val = self.read_immediate(src)?;\n         trace!(\"deref to {} on {:?}\", val.layout.ty, *val);\n \n@@ -359,8 +359,8 @@ where\n     #[inline]\n     pub(super) fn get_place_alloc(\n         &self,\n-        place: &MPlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, Option<AllocRef<'_, 'tcx, M::PointerTag, M::AllocExtra>>> {\n+        place: &MPlaceTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, Option<AllocRef<'_, 'tcx, M::Provenance, M::AllocExtra>>> {\n         assert!(!place.layout.is_unsized());\n         assert!(!place.meta.has_meta());\n         let size = place.layout.size;\n@@ -370,8 +370,8 @@ where\n     #[inline]\n     pub(super) fn get_place_alloc_mut(\n         &mut self,\n-        place: &MPlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, Option<AllocRefMut<'_, 'tcx, M::PointerTag, M::AllocExtra>>> {\n+        place: &MPlaceTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, Option<AllocRefMut<'_, 'tcx, M::Provenance, M::AllocExtra>>> {\n         assert!(!place.layout.is_unsized());\n         assert!(!place.meta.has_meta());\n         let size = place.layout.size;\n@@ -381,7 +381,7 @@ where\n     /// Check if this mplace is dereferenceable and sufficiently aligned.\n     fn check_mplace_access(\n         &self,\n-        mplace: MPlaceTy<'tcx, M::PointerTag>,\n+        mplace: MPlaceTy<'tcx, M::Provenance>,\n         msg: CheckInAllocMsg,\n     ) -> InterpResult<'tcx> {\n         let (size, align) = self\n@@ -397,8 +397,8 @@ where\n     /// Also returns the number of elements.\n     pub fn mplace_to_simd(\n         &self,\n-        mplace: &MPlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, u64)> {\n+        mplace: &MPlaceTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::Provenance>, u64)> {\n         // Basically we just transmute this place into an array following simd_size_and_type.\n         // (Transmuting is okay since this is an in-memory place. We also double-check the size\n         // stays the same.)\n@@ -413,8 +413,8 @@ where\n     /// Also returns the number of elements.\n     pub fn place_to_simd(\n         &mut self,\n-        place: &PlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, u64)> {\n+        place: &PlaceTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::Provenance>, u64)> {\n         let mplace = self.force_allocation(place)?;\n         self.mplace_to_simd(&mplace)\n     }\n@@ -423,7 +423,7 @@ where\n         &self,\n         frame: usize,\n         local: mir::Local,\n-    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::Provenance>> {\n         let layout = self.layout_of_local(&self.stack()[frame], local, None)?;\n         let place = Place::Local { frame, local };\n         Ok(PlaceTy { place, layout, align: layout.align.abi })\n@@ -435,7 +435,7 @@ where\n     pub fn eval_place(\n         &mut self,\n         mir_place: mir::Place<'tcx>,\n-    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::Provenance>> {\n         let mut place = self.local_to_place(self.frame_idx(), mir_place.local)?;\n         // Using `try_fold` turned out to be bad for performance, hence the loop.\n         for elem in mir_place.projection.iter() {\n@@ -465,8 +465,8 @@ where\n     #[instrument(skip(self), level = \"debug\")]\n     pub fn write_immediate(\n         &mut self,\n-        src: Immediate<M::PointerTag>,\n-        dest: &PlaceTy<'tcx, M::PointerTag>,\n+        src: Immediate<M::Provenance>,\n+        dest: &PlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx> {\n         self.write_immediate_no_validate(src, dest)?;\n \n@@ -482,8 +482,8 @@ where\n     #[inline(always)]\n     pub fn write_scalar(\n         &mut self,\n-        val: impl Into<ScalarMaybeUninit<M::PointerTag>>,\n-        dest: &PlaceTy<'tcx, M::PointerTag>,\n+        val: impl Into<ScalarMaybeUninit<M::Provenance>>,\n+        dest: &PlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx> {\n         self.write_immediate(Immediate::Scalar(val.into()), dest)\n     }\n@@ -492,8 +492,8 @@ where\n     #[inline(always)]\n     pub fn write_pointer(\n         &mut self,\n-        ptr: impl Into<Pointer<Option<M::PointerTag>>>,\n-        dest: &PlaceTy<'tcx, M::PointerTag>,\n+        ptr: impl Into<Pointer<Option<M::Provenance>>>,\n+        dest: &PlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx> {\n         self.write_scalar(Scalar::from_maybe_pointer(ptr.into(), self), dest)\n     }\n@@ -503,8 +503,8 @@ where\n     /// right type.\n     fn write_immediate_no_validate(\n         &mut self,\n-        src: Immediate<M::PointerTag>,\n-        dest: &PlaceTy<'tcx, M::PointerTag>,\n+        src: Immediate<M::Provenance>,\n+        dest: &PlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx> {\n         assert!(!dest.layout.is_unsized(), \"Cannot write unsized data\");\n         trace!(\"write_immediate: {:?} <- {:?}: {}\", *dest, src, dest.layout.ty);\n@@ -537,10 +537,10 @@ where\n     /// right layout.\n     fn write_immediate_to_mplace_no_validate(\n         &mut self,\n-        value: Immediate<M::PointerTag>,\n+        value: Immediate<M::Provenance>,\n         layout: TyAndLayout<'tcx>,\n         align: Align,\n-        dest: MemPlace<M::PointerTag>,\n+        dest: MemPlace<M::Provenance>,\n     ) -> InterpResult<'tcx> {\n         // Note that it is really important that the type here is the right one, and matches the\n         // type things are read at. In case `value` is a `ScalarPair`, we don't do any magic here\n@@ -589,7 +589,7 @@ where\n         }\n     }\n \n-    pub fn write_uninit(&mut self, dest: &PlaceTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n+    pub fn write_uninit(&mut self, dest: &PlaceTy<'tcx, M::Provenance>) -> InterpResult<'tcx> {\n         let mplace = match dest.try_as_mplace() {\n             Ok(mplace) => mplace,\n             Err((frame, local)) => {\n@@ -619,8 +619,8 @@ where\n     #[instrument(skip(self), level = \"debug\")]\n     pub fn copy_op(\n         &mut self,\n-        src: &OpTy<'tcx, M::PointerTag>,\n-        dest: &PlaceTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::Provenance>,\n+        dest: &PlaceTy<'tcx, M::Provenance>,\n         allow_transmute: bool,\n     ) -> InterpResult<'tcx> {\n         self.copy_op_no_validate(src, dest, allow_transmute)?;\n@@ -640,8 +640,8 @@ where\n     #[instrument(skip(self), level = \"debug\")]\n     fn copy_op_no_validate(\n         &mut self,\n-        src: &OpTy<'tcx, M::PointerTag>,\n-        dest: &PlaceTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::Provenance>,\n+        dest: &PlaceTy<'tcx, M::Provenance>,\n         allow_transmute: bool,\n     ) -> InterpResult<'tcx> {\n         // We do NOT compare the types for equality, because well-typed code can\n@@ -713,8 +713,8 @@ where\n     #[instrument(skip(self), level = \"debug\")]\n     pub fn force_allocation(\n         &mut self,\n-        place: &PlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        place: &PlaceTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n         let mplace = match place.place {\n             Place::Local { frame, local } => {\n                 match M::access_local_mut(self, frame, local)? {\n@@ -760,7 +760,7 @@ where\n         &mut self,\n         layout: TyAndLayout<'tcx>,\n         kind: MemoryKind<M::MemoryKind>,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n         assert!(!layout.is_unsized());\n         let ptr = self.allocate_ptr(layout.size, layout.align.abi, kind)?;\n         Ok(MPlaceTy::from_aligned_ptr(ptr.into(), layout))\n@@ -772,7 +772,7 @@ where\n         str: &str,\n         kind: MemoryKind<M::MemoryKind>,\n         mutbl: Mutability,\n-    ) -> MPlaceTy<'tcx, M::PointerTag> {\n+    ) -> MPlaceTy<'tcx, M::Provenance> {\n         let ptr = self.allocate_bytes_ptr(str.as_bytes(), Align::ONE, kind, mutbl);\n         let meta = Scalar::from_machine_usize(u64::try_from(str.len()).unwrap(), self);\n         let mplace = MemPlace { ptr: ptr.into(), meta: MemPlaceMeta::Meta(meta) };\n@@ -790,7 +790,7 @@ where\n     pub fn write_discriminant(\n         &mut self,\n         variant_index: VariantIdx,\n-        dest: &PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx> {\n         // This must be an enum or generator.\n         match dest.layout.ty.kind() {\n@@ -876,7 +876,7 @@ where\n     pub fn raw_const_to_mplace(\n         &self,\n         raw: ConstAlloc<'tcx>,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n         // This must be an allocation in `tcx`\n         let _ = self.tcx.global_alloc(raw.alloc_id);\n         let ptr = self.global_base_pointer(Pointer::from(raw.alloc_id))?;\n@@ -888,8 +888,8 @@ where\n     /// Also return some more information so drop doesn't have to run the same code twice.\n     pub(super) fn unpack_dyn_trait(\n         &self,\n-        mplace: &MPlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx, M::PointerTag>)> {\n+        mplace: &MPlaceTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx, M::Provenance>)> {\n         let vtable = self.scalar_to_ptr(mplace.vtable())?; // also sanity checks the type\n         let (instance, ty) = self.read_drop_type_from_vtable(vtable)?;\n         let layout = self.layout_of(ty)?;"}, {"sha": "742339f2b0aff0c76c440b06f981d2899d5163cc", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -20,10 +20,10 @@ use super::{\n };\n \n // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n-impl<'mir, 'tcx: 'mir, Tag, M> InterpCx<'mir, 'tcx, M>\n+impl<'mir, 'tcx: 'mir, Prov, M> InterpCx<'mir, 'tcx, M>\n where\n-    Tag: Provenance + Eq + Hash + 'static,\n-    M: Machine<'mir, 'tcx, PointerTag = Tag>,\n+    Prov: Provenance + Eq + Hash + 'static,\n+    M: Machine<'mir, 'tcx, Provenance = Prov>,\n {\n     //# Field access\n \n@@ -35,9 +35,9 @@ where\n     /// For indexing into arrays, use `mplace_index`.\n     pub fn mplace_field(\n         &self,\n-        base: &MPlaceTy<'tcx, M::PointerTag>,\n+        base: &MPlaceTy<'tcx, M::Provenance>,\n         field: usize,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n         let offset = base.layout.fields.offset(field);\n         let field_layout = base.layout.field(self, field);\n \n@@ -72,9 +72,9 @@ where\n     /// into the field of a local `ScalarPair`, we have to first allocate it.\n     pub fn place_field(\n         &mut self,\n-        base: &PlaceTy<'tcx, M::PointerTag>,\n+        base: &PlaceTy<'tcx, M::Provenance>,\n         field: usize,\n-    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::Provenance>> {\n         // FIXME: We could try to be smarter and avoid allocation for fields that span the\n         // entire place.\n         let base = self.force_allocation(base)?;\n@@ -83,9 +83,9 @@ where\n \n     pub fn operand_field(\n         &self,\n-        base: &OpTy<'tcx, M::PointerTag>,\n+        base: &OpTy<'tcx, M::Provenance>,\n         field: usize,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         let base = match base.try_as_mplace() {\n             Ok(ref mplace) => {\n                 // We can reuse the mplace field computation logic for indirect operands.\n@@ -139,9 +139,9 @@ where\n \n     pub fn mplace_downcast(\n         &self,\n-        base: &MPlaceTy<'tcx, M::PointerTag>,\n+        base: &MPlaceTy<'tcx, M::Provenance>,\n         variant: VariantIdx,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n         // Downcasts only change the layout.\n         // (In particular, no check about whether this is even the active variant -- that's by design,\n         // see https://github.com/rust-lang/rust/issues/93688#issuecomment-1032929496.)\n@@ -153,9 +153,9 @@ where\n \n     pub fn place_downcast(\n         &self,\n-        base: &PlaceTy<'tcx, M::PointerTag>,\n+        base: &PlaceTy<'tcx, M::Provenance>,\n         variant: VariantIdx,\n-    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::Provenance>> {\n         // Downcast just changes the layout\n         let mut base = base.clone();\n         base.layout = base.layout.for_variant(self, variant);\n@@ -164,9 +164,9 @@ where\n \n     pub fn operand_downcast(\n         &self,\n-        base: &OpTy<'tcx, M::PointerTag>,\n+        base: &OpTy<'tcx, M::Provenance>,\n         variant: VariantIdx,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         // Downcast just changes the layout\n         let mut base = base.clone();\n         base.layout = base.layout.for_variant(self, variant);\n@@ -178,9 +178,9 @@ where\n     #[inline(always)]\n     pub fn operand_index(\n         &self,\n-        base: &OpTy<'tcx, M::PointerTag>,\n+        base: &OpTy<'tcx, M::Provenance>,\n         index: u64,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         // Not using the layout method because we want to compute on u64\n         match base.layout.fields {\n             abi::FieldsShape::Array { stride, count: _ } => {\n@@ -207,8 +207,8 @@ where\n     // same by repeatedly calling `operand_index`.\n     pub fn operand_array_fields<'a>(\n         &self,\n-        base: &'a OpTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, impl Iterator<Item = InterpResult<'tcx, OpTy<'tcx, Tag>>> + 'a> {\n+        base: &'a OpTy<'tcx, Prov>,\n+    ) -> InterpResult<'tcx, impl Iterator<Item = InterpResult<'tcx, OpTy<'tcx, Prov>>> + 'a> {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let abi::FieldsShape::Array { stride, .. } = base.layout.fields else {\n             span_bug!(self.cur_span(), \"operand_array_fields: expected an array layout\");\n@@ -222,17 +222,17 @@ where\n     /// Index into an array.\n     pub fn mplace_index(\n         &self,\n-        base: &MPlaceTy<'tcx, M::PointerTag>,\n+        base: &MPlaceTy<'tcx, M::Provenance>,\n         index: u64,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n         Ok(self.operand_index(&base.into(), index)?.assert_mem_place())\n     }\n \n     pub fn place_index(\n         &mut self,\n-        base: &PlaceTy<'tcx, M::PointerTag>,\n+        base: &PlaceTy<'tcx, M::Provenance>,\n         index: u64,\n-    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::Provenance>> {\n         // There's not a lot we can do here, since we cannot have a place to a part of a local. If\n         // we are accessing the only element of a 1-element array, it's still the entire local...\n         // that doesn't seem worth it.\n@@ -244,11 +244,11 @@ where\n \n     fn operand_constant_index(\n         &self,\n-        base: &OpTy<'tcx, M::PointerTag>,\n+        base: &OpTy<'tcx, M::Provenance>,\n         offset: u64,\n         min_length: u64,\n         from_end: bool,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         let n = base.len(self)?;\n         if n < min_length {\n             // This can only be reached in ConstProp and non-rustc-MIR.\n@@ -268,11 +268,11 @@ where\n \n     fn place_constant_index(\n         &mut self,\n-        base: &PlaceTy<'tcx, M::PointerTag>,\n+        base: &PlaceTy<'tcx, M::Provenance>,\n         offset: u64,\n         min_length: u64,\n         from_end: bool,\n-    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::Provenance>> {\n         let base = self.force_allocation(base)?;\n         Ok(self\n             .operand_constant_index(&base.into(), offset, min_length, from_end)?\n@@ -284,11 +284,11 @@ where\n \n     fn operand_subslice(\n         &self,\n-        base: &OpTy<'tcx, M::PointerTag>,\n+        base: &OpTy<'tcx, M::Provenance>,\n         from: u64,\n         to: u64,\n         from_end: bool,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let actual_to = if from_end {\n             if from.checked_add(to).map_or(true, |to| to > len) {\n@@ -329,11 +329,11 @@ where\n \n     pub fn place_subslice(\n         &mut self,\n-        base: &PlaceTy<'tcx, M::PointerTag>,\n+        base: &PlaceTy<'tcx, M::Provenance>,\n         from: u64,\n         to: u64,\n         from_end: bool,\n-    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::Provenance>> {\n         let base = self.force_allocation(base)?;\n         Ok(self.operand_subslice(&base.into(), from, to, from_end)?.assert_mem_place().into())\n     }\n@@ -344,9 +344,9 @@ where\n     #[instrument(skip(self), level = \"trace\")]\n     pub fn place_projection(\n         &mut self,\n-        base: &PlaceTy<'tcx, M::PointerTag>,\n+        base: &PlaceTy<'tcx, M::Provenance>,\n         proj_elem: mir::PlaceElem<'tcx>,\n-    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::Provenance>> {\n         use rustc_middle::mir::ProjectionElem::*;\n         Ok(match proj_elem {\n             Field(field, _) => self.place_field(base, field.index())?,\n@@ -368,9 +368,9 @@ where\n     #[instrument(skip(self), level = \"trace\")]\n     pub fn operand_projection(\n         &self,\n-        base: &OpTy<'tcx, M::PointerTag>,\n+        base: &OpTy<'tcx, M::Provenance>,\n         proj_elem: mir::PlaceElem<'tcx>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         use rustc_middle::mir::ProjectionElem::*;\n         Ok(match proj_elem {\n             Field(field, _) => self.operand_field(base, field.index())?,"}, {"sha": "279ecef08c6502192f06478d57f62eab911ff074", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -267,10 +267,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn pass_argument<'x, 'y>(\n         &mut self,\n         caller_args: &mut impl Iterator<\n-            Item = (&'x OpTy<'tcx, M::PointerTag>, &'y ArgAbi<'tcx, Ty<'tcx>>),\n+            Item = (&'x OpTy<'tcx, M::Provenance>, &'y ArgAbi<'tcx, Ty<'tcx>>),\n         >,\n         callee_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n-        callee_arg: &PlaceTy<'tcx, M::PointerTag>,\n+        callee_arg: &PlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx>\n     where\n         'tcx: 'x,\n@@ -336,9 +336,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self,\n         fn_val: FnVal<'tcx, M::ExtraFnVal>,\n         (caller_abi, caller_fn_abi): (Abi, &FnAbi<'tcx, Ty<'tcx>>),\n-        args: &[OpTy<'tcx, M::PointerTag>],\n+        args: &[OpTy<'tcx, M::Provenance>],\n         with_caller_location: bool,\n-        destination: &PlaceTy<'tcx, M::PointerTag>,\n+        destination: &PlaceTy<'tcx, M::Provenance>,\n         target: Option<mir::BasicBlock>,\n         mut unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx> {\n@@ -437,7 +437,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // last incoming argument.  These two iterators do not have the same type,\n                     // so to keep the code paths uniform we accept an allocation\n                     // (for RustCall ABI only).\n-                    let caller_args: Cow<'_, [OpTy<'tcx, M::PointerTag>]> =\n+                    let caller_args: Cow<'_, [OpTy<'tcx, M::Provenance>]> =\n                         if caller_abi == Abi::RustCall && !args.is_empty() {\n                             // Untuple\n                             let (untuple_arg, args) = args.split_last().unwrap();\n@@ -449,7 +449,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                         (0..untuple_arg.layout.fields.count())\n                                             .map(|i| self.operand_field(untuple_arg, i)),\n                                     )\n-                                    .collect::<InterpResult<'_, Vec<OpTy<'tcx, M::PointerTag>>>>(\n+                                    .collect::<InterpResult<'_, Vec<OpTy<'tcx, M::Provenance>>>>(\n                                     )?,\n                             )\n                         } else {\n@@ -593,7 +593,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn drop_in_place(\n         &mut self,\n-        place: &PlaceTy<'tcx, M::PointerTag>,\n+        place: &PlaceTy<'tcx, M::Provenance>,\n         instance: ty::Instance<'tcx>,\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,"}, {"sha": "e4052b61782746961a82f33b0ce680fb2e21e31f", "filename": "compiler/rustc_const_eval/src/interpret/traits.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -21,7 +21,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self,\n         ty: Ty<'tcx>,\n         poly_trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n-    ) -> InterpResult<'tcx, Pointer<Option<M::PointerTag>>> {\n+    ) -> InterpResult<'tcx, Pointer<Option<M::Provenance>>> {\n         trace!(\"get_vtable(trait_ref={:?})\", poly_trait_ref);\n \n         let (ty, poly_trait_ref) = self.tcx.erase_regions((ty, poly_trait_ref));\n@@ -42,7 +42,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// corresponds to the first method declared in the trait of the provided vtable.\n     pub fn get_vtable_slot(\n         &self,\n-        vtable: Pointer<Option<M::PointerTag>>,\n+        vtable: Pointer<Option<M::Provenance>>,\n         idx: u64,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         let ptr_size = self.pointer_size();\n@@ -57,7 +57,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Returns the drop fn instance as well as the actual dynamic type.\n     pub fn read_drop_type_from_vtable(\n         &self,\n-        vtable: Pointer<Option<M::PointerTag>>,\n+        vtable: Pointer<Option<M::Provenance>>,\n     ) -> InterpResult<'tcx, (ty::Instance<'tcx>, Ty<'tcx>)> {\n         let pointer_size = self.pointer_size();\n         // We don't care about the pointee type; we just want a pointer.\n@@ -89,7 +89,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     pub fn read_size_and_align_from_vtable(\n         &self,\n-        vtable: Pointer<Option<M::PointerTag>>,\n+        vtable: Pointer<Option<M::Provenance>>,\n     ) -> InterpResult<'tcx, (Size, Align)> {\n         let pointer_size = self.pointer_size();\n         // We check for `size = 3 * ptr_size`, which covers the drop fn (unused here),\n@@ -126,9 +126,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     pub fn read_new_vtable_after_trait_upcasting_from_vtable(\n         &self,\n-        vtable: Pointer<Option<M::PointerTag>>,\n+        vtable: Pointer<Option<M::Provenance>>,\n         idx: u64,\n-    ) -> InterpResult<'tcx, Pointer<Option<M::PointerTag>>> {\n+    ) -> InterpResult<'tcx, Pointer<Option<M::Provenance>>> {\n         let pointer_size = self.pointer_size();\n \n         let vtable_slot = vtable.offset(pointer_size * idx, self)?;"}, {"sha": "54ae9065f74afd8ec1b18ed820df46348849fa7c", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -206,7 +206,7 @@ struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// starts must not be changed!  `visit_fields` and `visit_array` rely on\n     /// this stack discipline.\n     path: Vec<PathElem>,\n-    ref_tracking: Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>>,\n+    ref_tracking: Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::Provenance>, Vec<PathElem>>>,\n     /// `None` indicates this is not validating for CTFE (but for runtime).\n     ctfe_mode: Option<CtfeValidationMode>,\n     ecx: &'rt InterpCx<'mir, 'tcx, M>,\n@@ -306,7 +306,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n \n     fn check_wide_ptr_meta(\n         &mut self,\n-        meta: MemPlaceMeta<M::PointerTag>,\n+        meta: MemPlaceMeta<M::Provenance>,\n         pointee: TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(pointee.ty, self.ecx.param_env);\n@@ -380,7 +380,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     /// Check a reference or `Box`.\n     fn check_safe_pointer(\n         &mut self,\n-        value: &OpTy<'tcx, M::PointerTag>,\n+        value: &OpTy<'tcx, M::Provenance>,\n         kind: &str,\n     ) -> InterpResult<'tcx> {\n         let value = try_validation!(\n@@ -445,7 +445,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         if let Some(ref mut ref_tracking) = self.ref_tracking {\n             // Proceed recursively even for ZST, no reason to skip them!\n             // `!` is a ZST and we want to validate it.\n-            if let Ok((alloc_id, _offset, _tag)) = self.ecx.ptr_try_get_alloc_id(place.ptr) {\n+            if let Ok((alloc_id, _offset, _prov)) = self.ecx.ptr_try_get_alloc_id(place.ptr) {\n                 // Special handling for pointers to statics (irrespective of their type).\n                 let alloc_kind = self.ecx.tcx.get_global_alloc(alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n@@ -491,8 +491,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n \n     fn read_scalar(\n         &self,\n-        op: &OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<M::PointerTag>> {\n+        op: &OpTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<M::Provenance>> {\n         Ok(try_validation!(\n             self.ecx.read_scalar(op),\n             self.path,\n@@ -502,8 +502,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n \n     fn read_immediate_forced(\n         &self,\n-        op: &OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, Immediate<M::PointerTag>> {\n+        op: &OpTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n         Ok(*try_validation!(\n             self.ecx.read_immediate_raw(op, /*force*/ true),\n             self.path,\n@@ -515,7 +515,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     /// at that type.  Return `true` if the type is indeed primitive.\n     fn try_visit_primitive(\n         &mut self,\n-        value: &OpTy<'tcx, M::PointerTag>,\n+        value: &OpTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx, bool> {\n         // Go over all the primitive types\n         let ty = value.layout.ty;\n@@ -652,7 +652,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n \n     fn visit_scalar(\n         &mut self,\n-        scalar: ScalarMaybeUninit<M::PointerTag>,\n+        scalar: ScalarMaybeUninit<M::Provenance>,\n         scalar_layout: ScalarAbi,\n     ) -> InterpResult<'tcx> {\n         // We check `is_full_range` in a slightly complicated way because *if* we are checking\n@@ -735,7 +735,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     for ValidityVisitor<'rt, 'mir, 'tcx, M>\n {\n-    type V = OpTy<'tcx, M::PointerTag>;\n+    type V = OpTy<'tcx, M::Provenance>;\n \n     #[inline(always)]\n     fn ecx(&self) -> &InterpCx<'mir, 'tcx, M> {\n@@ -744,7 +744,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n \n     fn read_discriminant(\n         &mut self,\n-        op: &OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx, VariantIdx> {\n         self.with_elem(PathElem::EnumTag, move |this| {\n             Ok(try_validation!(\n@@ -764,9 +764,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     #[inline]\n     fn visit_field(\n         &mut self,\n-        old_op: &OpTy<'tcx, M::PointerTag>,\n+        old_op: &OpTy<'tcx, M::Provenance>,\n         field: usize,\n-        new_op: &OpTy<'tcx, M::PointerTag>,\n+        new_op: &OpTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx> {\n         let elem = self.aggregate_field_path_elem(old_op.layout, field);\n         self.with_elem(elem, move |this| this.visit_value(new_op))\n@@ -775,9 +775,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     #[inline]\n     fn visit_variant(\n         &mut self,\n-        old_op: &OpTy<'tcx, M::PointerTag>,\n+        old_op: &OpTy<'tcx, M::Provenance>,\n         variant_id: VariantIdx,\n-        new_op: &OpTy<'tcx, M::PointerTag>,\n+        new_op: &OpTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx> {\n         let name = match old_op.layout.ty.kind() {\n             ty::Adt(adt, _) => PathElem::Variant(adt.variant(variant_id).name),\n@@ -791,7 +791,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     #[inline(always)]\n     fn visit_union(\n         &mut self,\n-        op: &OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::Provenance>,\n         _fields: NonZeroUsize,\n     ) -> InterpResult<'tcx> {\n         // Special check preventing `UnsafeCell` inside unions in the inner part of constants.\n@@ -804,13 +804,13 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     }\n \n     #[inline]\n-    fn visit_box(&mut self, op: &OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n+    fn visit_box(&mut self, op: &OpTy<'tcx, M::Provenance>) -> InterpResult<'tcx> {\n         self.check_safe_pointer(op, \"box\")?;\n         Ok(())\n     }\n \n     #[inline]\n-    fn visit_value(&mut self, op: &OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n+    fn visit_value(&mut self, op: &OpTy<'tcx, M::Provenance>) -> InterpResult<'tcx> {\n         trace!(\"visit_value: {:?}, {:?}\", *op, op.layout);\n \n         // Check primitive types -- the leaves of our recursive descent.\n@@ -881,7 +881,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n \n     fn visit_aggregate(\n         &mut self,\n-        op: &OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::Provenance>,\n         fields: impl Iterator<Item = InterpResult<'tcx, Self::V>>,\n     ) -> InterpResult<'tcx> {\n         match op.layout.ty.kind() {\n@@ -992,9 +992,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn validate_operand_internal(\n         &self,\n-        op: &OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::Provenance>,\n         path: Vec<PathElem>,\n-        ref_tracking: Option<&mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>>,\n+        ref_tracking: Option<&mut RefTracking<MPlaceTy<'tcx, M::Provenance>, Vec<PathElem>>>,\n         ctfe_mode: Option<CtfeValidationMode>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"validate_operand_internal: {:?}, {:?}\", *op, op.layout.ty);\n@@ -1031,9 +1031,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline(always)]\n     pub fn const_validate_operand(\n         &self,\n-        op: &OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::Provenance>,\n         path: Vec<PathElem>,\n-        ref_tracking: &mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>,\n+        ref_tracking: &mut RefTracking<MPlaceTy<'tcx, M::Provenance>, Vec<PathElem>>,\n         ctfe_mode: CtfeValidationMode,\n     ) -> InterpResult<'tcx> {\n         self.validate_operand_internal(op, path, Some(ref_tracking), Some(ctfe_mode))\n@@ -1043,7 +1043,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// `op` is assumed to cover valid memory if it is an indirect operand.\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n     #[inline(always)]\n-    pub fn validate_operand(&self, op: &OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n+    pub fn validate_operand(&self, op: &OpTy<'tcx, M::Provenance>) -> InterpResult<'tcx> {\n         self.validate_operand_internal(op, vec![], None, None)\n     }\n }"}, {"sha": "24228feb73e7db7d384be3fabf79d190e91093d0", "filename": "compiler/rustc_const_eval/src/interpret/visitor.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -21,20 +21,20 @@ pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Sized {\n     fn to_op_for_read(\n         &self,\n         ecx: &InterpCx<'mir, 'tcx, M>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>>;\n \n     /// Makes this into an `OpTy`, in a potentially more expensive way that is good for projections.\n     fn to_op_for_proj(\n         &self,\n         ecx: &InterpCx<'mir, 'tcx, M>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         self.to_op_for_read(ecx)\n     }\n \n     /// Creates this from an `OpTy`.\n     ///\n     /// If `to_op_for_proj` only ever produces `Indirect` operands, then this one is definitely `Indirect`.\n-    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self;\n+    fn from_op(op: &OpTy<'tcx, M::Provenance>) -> Self;\n \n     /// Projects to the given enum variant.\n     fn project_downcast(\n@@ -62,18 +62,18 @@ pub trait ValueMut<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Sized {\n     fn to_op_for_read(\n         &self,\n         ecx: &InterpCx<'mir, 'tcx, M>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>>;\n \n     /// Makes this into an `OpTy`, in a potentially more expensive way that is good for projections.\n     fn to_op_for_proj(\n         &self,\n         ecx: &mut InterpCx<'mir, 'tcx, M>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>>;\n \n     /// Creates this from an `OpTy`.\n     ///\n     /// If `to_op_for_proj` only ever produces `Indirect` operands, then this one is definitely `Indirect`.\n-    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self;\n+    fn from_op(op: &OpTy<'tcx, M::Provenance>) -> Self;\n \n     /// Projects to the given enum variant.\n     fn project_downcast(\n@@ -95,7 +95,7 @@ pub trait ValueMut<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Sized {\n // So we have some copy-paste here. (We could have a macro but since we only have 2 types with this\n // double-impl, that would barely make the code shorter, if at all.)\n \n-impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::PointerTag> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::Provenance> {\n     #[inline(always)]\n     fn layout(&self) -> TyAndLayout<'tcx> {\n         self.layout\n@@ -105,12 +105,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tc\n     fn to_op_for_read(\n         &self,\n         _ecx: &InterpCx<'mir, 'tcx, M>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         Ok(self.clone())\n     }\n \n     #[inline(always)]\n-    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n+    fn from_op(op: &OpTy<'tcx, M::Provenance>) -> Self {\n         op.clone()\n     }\n \n@@ -134,7 +134,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tc\n }\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n-    for OpTy<'tcx, M::PointerTag>\n+    for OpTy<'tcx, M::Provenance>\n {\n     #[inline(always)]\n     fn layout(&self) -> TyAndLayout<'tcx> {\n@@ -145,20 +145,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n     fn to_op_for_read(\n         &self,\n         _ecx: &InterpCx<'mir, 'tcx, M>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         Ok(self.clone())\n     }\n \n     #[inline(always)]\n     fn to_op_for_proj(\n         &self,\n         _ecx: &mut InterpCx<'mir, 'tcx, M>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         Ok(self.clone())\n     }\n \n     #[inline(always)]\n-    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n+    fn from_op(op: &OpTy<'tcx, M::Provenance>) -> Self {\n         op.clone()\n     }\n \n@@ -182,7 +182,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n }\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n-    for MPlaceTy<'tcx, M::PointerTag>\n+    for MPlaceTy<'tcx, M::Provenance>\n {\n     #[inline(always)]\n     fn layout(&self) -> TyAndLayout<'tcx> {\n@@ -193,12 +193,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n     fn to_op_for_read(\n         &self,\n         _ecx: &InterpCx<'mir, 'tcx, M>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         Ok(self.into())\n     }\n \n     #[inline(always)]\n-    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n+    fn from_op(op: &OpTy<'tcx, M::Provenance>) -> Self {\n         // assert is justified because our `to_op_for_read` only ever produces `Indirect` operands.\n         op.assert_mem_place()\n     }\n@@ -223,7 +223,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n }\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n-    for MPlaceTy<'tcx, M::PointerTag>\n+    for MPlaceTy<'tcx, M::Provenance>\n {\n     #[inline(always)]\n     fn layout(&self) -> TyAndLayout<'tcx> {\n@@ -234,20 +234,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n     fn to_op_for_read(\n         &self,\n         _ecx: &InterpCx<'mir, 'tcx, M>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         Ok(self.into())\n     }\n \n     #[inline(always)]\n     fn to_op_for_proj(\n         &self,\n         _ecx: &mut InterpCx<'mir, 'tcx, M>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         Ok(self.into())\n     }\n \n     #[inline(always)]\n-    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n+    fn from_op(op: &OpTy<'tcx, M::Provenance>) -> Self {\n         // assert is justified because our `to_op_for_proj` only ever produces `Indirect` operands.\n         op.assert_mem_place()\n     }\n@@ -272,7 +272,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n }\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n-    for PlaceTy<'tcx, M::PointerTag>\n+    for PlaceTy<'tcx, M::Provenance>\n {\n     #[inline(always)]\n     fn layout(&self) -> TyAndLayout<'tcx> {\n@@ -283,7 +283,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n     fn to_op_for_read(\n         &self,\n         ecx: &InterpCx<'mir, 'tcx, M>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         // We `force_allocation` here so that `from_op` below can work.\n         ecx.place_to_op(self)\n     }\n@@ -292,13 +292,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n     fn to_op_for_proj(\n         &self,\n         ecx: &mut InterpCx<'mir, 'tcx, M>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         // We `force_allocation` here so that `from_op` below can work.\n         Ok(ecx.force_allocation(self)?.into())\n     }\n \n     #[inline(always)]\n-    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n+    fn from_op(op: &OpTy<'tcx, M::Provenance>) -> Self {\n         // assert is justified because our `to_op` only ever produces `Indirect` operands.\n         op.assert_mem_place().into()\n     }\n@@ -336,7 +336,7 @@ macro_rules! make_value_visitor {\n             #[inline(always)]\n             fn read_discriminant(\n                 &mut self,\n-                op: &OpTy<'tcx, M::PointerTag>,\n+                op: &OpTy<'tcx, M::Provenance>,\n             ) -> InterpResult<'tcx, VariantIdx> {\n                 Ok(self.ecx().read_discriminant(op)?.1)\n             }"}, {"sha": "db7e0fb8a3bdb88d50bf763bde69bc155b974015", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -30,15 +30,15 @@ use crate::ty;\n // hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n-pub struct Allocation<Tag = AllocId, Extra = ()> {\n+pub struct Allocation<Prov = AllocId, Extra = ()> {\n     /// The actual bytes of the allocation.\n     /// Note that the bytes of a pointer represent the offset of the pointer.\n     bytes: Box<[u8]>,\n     /// Maps from byte addresses to extra data for each pointer.\n     /// Only the first byte of a pointer is inserted into the map; i.e.,\n     /// every entry in this map applies to `pointer_size` consecutive bytes starting\n     /// at the given offset.\n-    relocations: Relocations<Tag>,\n+    relocations: Relocations<Prov>,\n     /// Denotes which part of this allocation is initialized.\n     init_mask: InitMask,\n     /// The alignment of the allocation to detect unaligned reads.\n@@ -102,8 +102,8 @@ impl hash::Hash for Allocation {\n /// (`ConstAllocation`) are used quite a bit.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable)]\n #[rustc_pass_by_value]\n-pub struct ConstAllocation<'tcx, Tag = AllocId, Extra = ()>(\n-    pub Interned<'tcx, Allocation<Tag, Extra>>,\n+pub struct ConstAllocation<'tcx, Prov = AllocId, Extra = ()>(\n+    pub Interned<'tcx, Allocation<Prov, Extra>>,\n );\n \n impl<'tcx> fmt::Debug for ConstAllocation<'tcx> {\n@@ -114,8 +114,8 @@ impl<'tcx> fmt::Debug for ConstAllocation<'tcx> {\n     }\n }\n \n-impl<'tcx, Tag, Extra> ConstAllocation<'tcx, Tag, Extra> {\n-    pub fn inner(self) -> &'tcx Allocation<Tag, Extra> {\n+impl<'tcx, Prov, Extra> ConstAllocation<'tcx, Prov, Extra> {\n+    pub fn inner(self) -> &'tcx Allocation<Prov, Extra> {\n         self.0.0\n     }\n }\n@@ -200,7 +200,7 @@ impl AllocRange {\n }\n \n // The constructors are all without extra; the extra gets added by a machine hook later.\n-impl<Tag> Allocation<Tag> {\n+impl<Prov> Allocation<Prov> {\n     /// Creates an allocation initialized by the given bytes\n     pub fn from_bytes<'a>(\n         slice: impl Into<Cow<'a, [u8]>>,\n@@ -256,14 +256,15 @@ impl<Tag> Allocation<Tag> {\n }\n \n impl Allocation {\n-    /// Convert Tag and add Extra fields\n-    pub fn convert_tag_add_extra<Tag, Extra, Err>(\n+    /// Adjust allocation from the ones in tcx to a custom Machine instance\n+    /// with a different Provenance and Extra type.\n+    pub fn adjust_from_tcx<Prov, Extra, Err>(\n         self,\n         cx: &impl HasDataLayout,\n         extra: Extra,\n-        mut tagger: impl FnMut(Pointer<AllocId>) -> Result<Pointer<Tag>, Err>,\n-    ) -> Result<Allocation<Tag, Extra>, Err> {\n-        // Compute new pointer tags, which also adjusts the bytes.\n+        mut adjust_ptr: impl FnMut(Pointer<AllocId>) -> Result<Pointer<Prov>, Err>,\n+    ) -> Result<Allocation<Prov, Extra>, Err> {\n+        // Compute new pointer provenance, which also adjusts the bytes.\n         let mut bytes = self.bytes;\n         let mut new_relocations = Vec::with_capacity(self.relocations.0.len());\n         let ptr_size = cx.data_layout().pointer_size.bytes_usize();\n@@ -272,10 +273,10 @@ impl Allocation {\n             let idx = offset.bytes_usize();\n             let ptr_bytes = &mut bytes[idx..idx + ptr_size];\n             let bits = read_target_uint(endian, ptr_bytes).unwrap();\n-            let (ptr_tag, ptr_offset) =\n-                tagger(Pointer::new(alloc_id, Size::from_bytes(bits)))?.into_parts();\n+            let (ptr_prov, ptr_offset) =\n+                adjust_ptr(Pointer::new(alloc_id, Size::from_bytes(bits)))?.into_parts();\n             write_target_uint(endian, ptr_bytes, ptr_offset.bytes().into()).unwrap();\n-            new_relocations.push((offset, ptr_tag));\n+            new_relocations.push((offset, ptr_prov));\n         }\n         // Create allocation.\n         Ok(Allocation {\n@@ -290,7 +291,7 @@ impl Allocation {\n }\n \n /// Raw accessors. Provide access to otherwise private bytes.\n-impl<Tag, Extra> Allocation<Tag, Extra> {\n+impl<Prov, Extra> Allocation<Prov, Extra> {\n     pub fn len(&self) -> usize {\n         self.bytes.len()\n     }\n@@ -313,13 +314,13 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n     }\n \n     /// Returns the relocation list.\n-    pub fn relocations(&self) -> &Relocations<Tag> {\n+    pub fn relocations(&self) -> &Relocations<Prov> {\n         &self.relocations\n     }\n }\n \n /// Byte accessors.\n-impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n+impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n     /// This is the entirely abstraction-violating way to just grab the raw bytes without\n     /// caring about relocations. It just deduplicates some code between `read_scalar`\n     /// and `get_bytes_internal`.\n@@ -413,7 +414,7 @@ impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n }\n \n /// Reading and writing.\n-impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n+impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n     /// Validates that `ptr.offset` and `ptr.offset + size` do not point to the middle of a\n     /// relocation. If `allow_uninit`/`allow_ptr` is `false`, also enforces that the memory in the\n     /// given range contains no uninitialized bytes/relocations.\n@@ -451,7 +452,7 @@ impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         range: AllocRange,\n         read_provenance: bool,\n-    ) -> AllocResult<ScalarMaybeUninit<Tag>> {\n+    ) -> AllocResult<ScalarMaybeUninit<Prov>> {\n         if read_provenance {\n             assert_eq!(range.size, cx.data_layout().pointer_size);\n         }\n@@ -475,7 +476,7 @@ impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n \n         // If we are *not* reading a pointer, and we can just ignore relocations,\n         // then do exactly that.\n-        if !read_provenance && Tag::OFFSET_IS_ADDR {\n+        if !read_provenance && Prov::OFFSET_IS_ADDR {\n             // We just strip provenance.\n             let bytes = self.get_bytes_even_more_internal(range);\n             let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n@@ -506,7 +507,7 @@ impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n         &mut self,\n         cx: &impl HasDataLayout,\n         range: AllocRange,\n-        val: ScalarMaybeUninit<Tag>,\n+        val: ScalarMaybeUninit<Prov>,\n     ) -> AllocResult {\n         assert!(self.mutability == Mutability::Mut);\n \n@@ -548,9 +549,9 @@ impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n }\n \n /// Relocations.\n-impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n+impl<Prov: Copy, Extra> Allocation<Prov, Extra> {\n     /// Returns all relocations overlapping with the given pointer-offset pair.\n-    fn get_relocations(&self, cx: &impl HasDataLayout, range: AllocRange) -> &[(Size, Tag)] {\n+    fn get_relocations(&self, cx: &impl HasDataLayout, range: AllocRange) -> &[(Size, Prov)] {\n         // We have to go back `pointer_size - 1` bytes, as that one would still overlap with\n         // the beginning of this range.\n         let start = range.start.bytes().saturating_sub(cx.data_layout().pointer_size.bytes() - 1);\n@@ -580,7 +581,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// immediately in that case.\n     fn clear_relocations(&mut self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult\n     where\n-        Tag: Provenance,\n+        Prov: Provenance,\n     {\n         // Find the start and end of the given range and its outermost relocations.\n         let (first, last) = {\n@@ -602,7 +603,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n         // FIXME: Miri should preserve partial relocations; see\n         // https://github.com/rust-lang/miri/issues/2181.\n         if first < start {\n-            if Tag::ERR_ON_PARTIAL_PTR_OVERWRITE {\n+            if Prov::ERR_ON_PARTIAL_PTR_OVERWRITE {\n                 return Err(AllocError::PartialPointerOverwrite(first));\n             }\n             warn!(\n@@ -611,7 +612,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n             self.init_mask.set_range(first, start, false);\n         }\n         if last > end {\n-            if Tag::ERR_ON_PARTIAL_PTR_OVERWRITE {\n+            if Prov::ERR_ON_PARTIAL_PTR_OVERWRITE {\n                 return Err(AllocError::PartialPointerOverwrite(\n                     last - cx.data_layout().pointer_size,\n                 ));\n@@ -642,22 +643,22 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n \n /// \"Relocations\" stores the provenance information of pointers stored in memory.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n-pub struct Relocations<Tag = AllocId>(SortedMap<Size, Tag>);\n+pub struct Relocations<Prov = AllocId>(SortedMap<Size, Prov>);\n \n-impl<Tag> Relocations<Tag> {\n+impl<Prov> Relocations<Prov> {\n     pub fn new() -> Self {\n         Relocations(SortedMap::new())\n     }\n \n     // The caller must guarantee that the given relocations are already sorted\n     // by address and contain no duplicates.\n-    pub fn from_presorted(r: Vec<(Size, Tag)>) -> Self {\n+    pub fn from_presorted(r: Vec<(Size, Prov)>) -> Self {\n         Relocations(SortedMap::from_presorted_elements(r))\n     }\n }\n \n-impl<Tag> Deref for Relocations<Tag> {\n-    type Target = SortedMap<Size, Tag>;\n+impl<Prov> Deref for Relocations<Prov> {\n+    type Target = SortedMap<Size, Prov>;\n \n     fn deref(&self) -> &Self::Target {\n         &self.0\n@@ -667,18 +668,18 @@ impl<Tag> Deref for Relocations<Tag> {\n /// A partial, owned list of relocations to transfer into another allocation.\n ///\n /// Offsets are already adjusted to the destination allocation.\n-pub struct AllocationRelocations<Tag> {\n-    dest_relocations: Vec<(Size, Tag)>,\n+pub struct AllocationRelocations<Prov> {\n+    dest_relocations: Vec<(Size, Prov)>,\n }\n \n-impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n+impl<Prov: Copy, Extra> Allocation<Prov, Extra> {\n     pub fn prepare_relocation_copy(\n         &self,\n         cx: &impl HasDataLayout,\n         src: AllocRange,\n         dest: Size,\n         count: u64,\n-    ) -> AllocationRelocations<Tag> {\n+    ) -> AllocationRelocations<Prov> {\n         let relocations = self.get_relocations(cx, src);\n         if relocations.is_empty() {\n             return AllocationRelocations { dest_relocations: Vec::new() };\n@@ -688,7 +689,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n         let mut new_relocations = Vec::with_capacity(relocations.len() * (count as usize));\n \n         // If `count` is large, this is rather wasteful -- we are allocating a big array here, which\n-        // is mostly filled with redundant information since it's just N copies of the same `Tag`s\n+        // is mostly filled with redundant information since it's just N copies of the same `Prov`s\n         // at slightly adjusted offsets. The reason we do this is so that in `mark_relocation_range`\n         // we can use `insert_presorted`. That wouldn't work with an `Iterator` that just produces\n         // the right sequence of relocations for all N copies.\n@@ -713,7 +714,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n     ///\n     /// This is dangerous to use as it can violate internal `Allocation` invariants!\n     /// It only exists to support an efficient implementation of `mem_copy_repeatedly`.\n-    pub fn mark_relocation_range(&mut self, relocations: AllocationRelocations<Tag>) {\n+    pub fn mark_relocation_range(&mut self, relocations: AllocationRelocations<Prov>) {\n         self.relocations.0.insert_presorted(relocations.dest_relocations);\n     }\n }\n@@ -1178,7 +1179,7 @@ impl<'a> Iterator for InitChunkIter<'a> {\n }\n \n /// Uninitialized bytes.\n-impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n+impl<Prov: Copy, Extra> Allocation<Prov, Extra> {\n     /// Checks whether the given range  is entirely initialized.\n     ///\n     /// Returns `Ok(())` if it's initialized. Otherwise returns the range of byte\n@@ -1226,7 +1227,7 @@ impl InitMaskCompressed {\n }\n \n /// Transferring the initialization mask to other allocations.\n-impl<Tag, Extra> Allocation<Tag, Extra> {\n+impl<Prov, Extra> Allocation<Prov, Extra> {\n     /// Creates a run-length encoding of the initialization mask; panics if range is empty.\n     ///\n     /// This is essentially a more space-efficient version of"}, {"sha": "384954cbbd5f7d3939fbde8828974a46de81147c", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -159,34 +159,34 @@ impl Provenance for AllocId {\n /// Pointers are \"tagged\" with provenance information; typically the `AllocId` they belong to.\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n-pub struct Pointer<Tag = AllocId> {\n-    pub(super) offset: Size, // kept private to avoid accidental misinterpretation (meaning depends on `Tag` type)\n-    pub provenance: Tag,\n+pub struct Pointer<Prov = AllocId> {\n+    pub(super) offset: Size, // kept private to avoid accidental misinterpretation (meaning depends on `Prov` type)\n+    pub provenance: Prov,\n }\n \n static_assert_size!(Pointer, 16);\n-// `Option<Tag>` pointers are also passed around quite a bit\n+// `Option<Prov>` pointers are also passed around quite a bit\n // (but not stored in permanent machine state).\n static_assert_size!(Pointer<Option<AllocId>>, 16);\n \n // We want the `Debug` output to be readable as it is used by `derive(Debug)` for\n // all the Miri types.\n-impl<Tag: Provenance> fmt::Debug for Pointer<Tag> {\n+impl<Prov: Provenance> fmt::Debug for Pointer<Prov> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         Provenance::fmt(self, f)\n     }\n }\n \n-impl<Tag: Provenance> fmt::Debug for Pointer<Option<Tag>> {\n+impl<Prov: Provenance> fmt::Debug for Pointer<Option<Prov>> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.provenance {\n-            Some(tag) => Provenance::fmt(&Pointer::new(tag, self.offset), f),\n+            Some(prov) => Provenance::fmt(&Pointer::new(prov, self.offset), f),\n             None => write!(f, \"{:#x}[noalloc]\", self.offset.bytes()),\n         }\n     }\n }\n \n-impl<Tag: Provenance> fmt::Display for Pointer<Option<Tag>> {\n+impl<Prov: Provenance> fmt::Display for Pointer<Option<Prov>> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if self.provenance.is_none() && self.offset.bytes() == 0 {\n             write!(f, \"null pointer\")\n@@ -204,38 +204,38 @@ impl From<AllocId> for Pointer {\n     }\n }\n \n-impl<Tag> From<Pointer<Tag>> for Pointer<Option<Tag>> {\n+impl<Prov> From<Pointer<Prov>> for Pointer<Option<Prov>> {\n     #[inline(always)]\n-    fn from(ptr: Pointer<Tag>) -> Self {\n-        let (tag, offset) = ptr.into_parts();\n-        Pointer::new(Some(tag), offset)\n+    fn from(ptr: Pointer<Prov>) -> Self {\n+        let (prov, offset) = ptr.into_parts();\n+        Pointer::new(Some(prov), offset)\n     }\n }\n \n-impl<Tag> Pointer<Option<Tag>> {\n-    /// Convert this pointer that *might* have a tag into a pointer that *definitely* has a tag, or\n-    /// an absolute address.\n+impl<Prov> Pointer<Option<Prov>> {\n+    /// Convert this pointer that *might* have a provenance into a pointer that *definitely* has a\n+    /// provenance, or an absolute address.\n     ///\n     /// This is rarely what you want; call `ptr_try_get_alloc_id` instead.\n-    pub fn into_pointer_or_addr(self) -> Result<Pointer<Tag>, Size> {\n+    pub fn into_pointer_or_addr(self) -> Result<Pointer<Prov>, Size> {\n         match self.provenance {\n-            Some(tag) => Ok(Pointer::new(tag, self.offset)),\n+            Some(prov) => Ok(Pointer::new(prov, self.offset)),\n             None => Err(self.offset),\n         }\n     }\n \n     /// Returns the absolute address the pointer points to.\n-    /// Only works if Tag::OFFSET_IS_ADDR is true!\n+    /// Only works if Prov::OFFSET_IS_ADDR is true!\n     pub fn addr(self) -> Size\n     where\n-        Tag: Provenance,\n+        Prov: Provenance,\n     {\n-        assert!(Tag::OFFSET_IS_ADDR);\n+        assert!(Prov::OFFSET_IS_ADDR);\n         self.offset\n     }\n }\n \n-impl<Tag> Pointer<Option<Tag>> {\n+impl<Prov> Pointer<Option<Prov>> {\n     #[inline(always)]\n     pub fn from_addr(addr: u64) -> Self {\n         Pointer { provenance: None, offset: Size::from_bytes(addr) }\n@@ -247,21 +247,21 @@ impl<Tag> Pointer<Option<Tag>> {\n     }\n }\n \n-impl<'tcx, Tag> Pointer<Tag> {\n+impl<'tcx, Prov> Pointer<Prov> {\n     #[inline(always)]\n-    pub fn new(provenance: Tag, offset: Size) -> Self {\n+    pub fn new(provenance: Prov, offset: Size) -> Self {\n         Pointer { provenance, offset }\n     }\n \n-    /// Obtain the constituents of this pointer. Not that the meaning of the offset depends on the type `Tag`!\n+    /// Obtain the constituents of this pointer. Not that the meaning of the offset depends on the type `Prov`!\n     /// This function must only be used in the implementation of `Machine::ptr_get_alloc`,\n     /// and when a `Pointer` is taken apart to be stored efficiently in an `Allocation`.\n     #[inline(always)]\n-    pub fn into_parts(self) -> (Tag, Size) {\n+    pub fn into_parts(self) -> (Prov, Size) {\n         (self.provenance, self.offset)\n     }\n \n-    pub fn map_provenance(self, f: impl FnOnce(Tag) -> Tag) -> Self {\n+    pub fn map_provenance(self, f: impl FnOnce(Prov) -> Prov) -> Self {\n         Pointer { provenance: f(self.provenance), ..self }\n     }\n "}, {"sha": "17088cf13a543e39adb44ece4631216769f7563b", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -126,7 +126,7 @@ impl<'tcx> ConstValue<'tcx> {\n /// Do *not* match on a `Scalar`! Use the various `to_*` methods instead.\n #[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n-pub enum Scalar<Tag = AllocId> {\n+pub enum Scalar<Prov = AllocId> {\n     /// The raw bytes of a simple value.\n     Int(ScalarInt),\n \n@@ -137,15 +137,15 @@ pub enum Scalar<Tag = AllocId> {\n     /// We also store the size of the pointer, such that a `Scalar` always knows how big it is.\n     /// The size is always the pointer size of the current target, but this is not information\n     /// that we always have readily available.\n-    Ptr(Pointer<Tag>, u8),\n+    Ptr(Pointer<Prov>, u8),\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(Scalar, 24);\n \n // We want the `Debug` output to be readable as it is used by `derive(Debug)` for\n // all the Miri types.\n-impl<Tag: Provenance> fmt::Debug for Scalar<Tag> {\n+impl<Prov: Provenance> fmt::Debug for Scalar<Prov> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Scalar::Ptr(ptr, _size) => write!(f, \"{:?}\", ptr),\n@@ -154,7 +154,7 @@ impl<Tag: Provenance> fmt::Debug for Scalar<Tag> {\n     }\n }\n \n-impl<Tag: Provenance> fmt::Display for Scalar<Tag> {\n+impl<Prov: Provenance> fmt::Display for Scalar<Prov> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Scalar::Ptr(ptr, _size) => write!(f, \"pointer to {:?}\", ptr),\n@@ -163,7 +163,7 @@ impl<Tag: Provenance> fmt::Display for Scalar<Tag> {\n     }\n }\n \n-impl<Tag: Provenance> fmt::LowerHex for Scalar<Tag> {\n+impl<Prov: Provenance> fmt::LowerHex for Scalar<Prov> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Scalar::Ptr(ptr, _size) => write!(f, \"pointer to {:?}\", ptr),\n@@ -172,37 +172,38 @@ impl<Tag: Provenance> fmt::LowerHex for Scalar<Tag> {\n     }\n }\n \n-impl<Tag> From<Single> for Scalar<Tag> {\n+impl<Prov> From<Single> for Scalar<Prov> {\n     #[inline(always)]\n     fn from(f: Single) -> Self {\n         Scalar::from_f32(f)\n     }\n }\n \n-impl<Tag> From<Double> for Scalar<Tag> {\n+impl<Prov> From<Double> for Scalar<Prov> {\n     #[inline(always)]\n     fn from(f: Double) -> Self {\n         Scalar::from_f64(f)\n     }\n }\n \n-impl<Tag> From<ScalarInt> for Scalar<Tag> {\n+impl<Prov> From<ScalarInt> for Scalar<Prov> {\n     #[inline(always)]\n     fn from(ptr: ScalarInt) -> Self {\n         Scalar::Int(ptr)\n     }\n }\n \n-impl<Tag> Scalar<Tag> {\n+impl<Prov> Scalar<Prov> {\n     #[inline(always)]\n-    pub fn from_pointer(ptr: Pointer<Tag>, cx: &impl HasDataLayout) -> Self {\n+    pub fn from_pointer(ptr: Pointer<Prov>, cx: &impl HasDataLayout) -> Self {\n         Scalar::Ptr(ptr, u8::try_from(cx.pointer_size().bytes()).unwrap())\n     }\n \n-    /// Create a Scalar from a pointer with an `Option<_>` tag (where `None` represents a plain integer).\n-    pub fn from_maybe_pointer(ptr: Pointer<Option<Tag>>, cx: &impl HasDataLayout) -> Self {\n+    /// Create a Scalar from a pointer with an `Option<_>` provenance (where `None` represents a\n+    /// plain integer / \"invalid\" pointer).\n+    pub fn from_maybe_pointer(ptr: Pointer<Option<Prov>>, cx: &impl HasDataLayout) -> Self {\n         match ptr.into_parts() {\n-            (Some(tag), offset) => Scalar::from_pointer(Pointer::new(tag, offset), cx),\n+            (Some(prov), offset) => Scalar::from_pointer(Pointer::new(prov, offset), cx),\n             (None, offset) => {\n                 Scalar::Int(ScalarInt::try_from_uint(offset.bytes(), cx.pointer_size()).unwrap())\n             }\n@@ -310,7 +311,7 @@ impl<Tag> Scalar<Tag> {\n     pub fn to_bits_or_ptr_internal(\n         self,\n         target_size: Size,\n-    ) -> Result<Result<u128, Pointer<Tag>>, ScalarSizeMismatch> {\n+    ) -> Result<Result<u128, Pointer<Prov>>, ScalarSizeMismatch> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         Ok(match self {\n             Scalar::Int(int) => Ok(int.to_bits(target_size).map_err(|size| {\n@@ -329,7 +330,7 @@ impl<Tag> Scalar<Tag> {\n     }\n }\n \n-impl<'tcx, Tag: Provenance> Scalar<Tag> {\n+impl<'tcx, Prov: Provenance> Scalar<Prov> {\n     /// Fundamental scalar-to-int (cast) operation. Many convenience wrappers exist below, that you\n     /// likely want to use instead.\n     ///\n@@ -341,13 +342,13 @@ impl<'tcx, Tag: Provenance> Scalar<Tag> {\n         match self {\n             Scalar::Int(int) => Ok(int),\n             Scalar::Ptr(ptr, sz) => {\n-                if Tag::OFFSET_IS_ADDR {\n+                if Prov::OFFSET_IS_ADDR {\n                     Ok(ScalarInt::try_from_uint(ptr.offset.bytes(), Size::from_bytes(sz)).unwrap())\n                 } else {\n                     // We know `offset` is relative, since `OFFSET_IS_ADDR == false`.\n-                    let (tag, offset) = ptr.into_parts();\n+                    let (prov, offset) = ptr.into_parts();\n                     // Because `OFFSET_IS_ADDR == false`, this unwrap can never fail.\n-                    Err(Scalar::Ptr(Pointer::new(tag.get_alloc_id().unwrap(), offset), sz))\n+                    Err(Scalar::Ptr(Pointer::new(prov.get_alloc_id().unwrap(), offset), sz))\n                 }\n             }\n         }\n@@ -489,24 +490,24 @@ impl<'tcx, Tag: Provenance> Scalar<Tag> {\n }\n \n #[derive(Clone, Copy, Eq, PartialEq, TyEncodable, TyDecodable, HashStable, Hash)]\n-pub enum ScalarMaybeUninit<Tag = AllocId> {\n-    Scalar(Scalar<Tag>),\n+pub enum ScalarMaybeUninit<Prov = AllocId> {\n+    Scalar(Scalar<Prov>),\n     Uninit,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(ScalarMaybeUninit, 24);\n \n-impl<Tag> From<Scalar<Tag>> for ScalarMaybeUninit<Tag> {\n+impl<Prov> From<Scalar<Prov>> for ScalarMaybeUninit<Prov> {\n     #[inline(always)]\n-    fn from(s: Scalar<Tag>) -> Self {\n+    fn from(s: Scalar<Prov>) -> Self {\n         ScalarMaybeUninit::Scalar(s)\n     }\n }\n \n // We want the `Debug` output to be readable as it is used by `derive(Debug)` for\n // all the Miri types.\n-impl<Tag: Provenance> fmt::Debug for ScalarMaybeUninit<Tag> {\n+impl<Prov: Provenance> fmt::Debug for ScalarMaybeUninit<Prov> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             ScalarMaybeUninit::Uninit => write!(f, \"<uninitialized>\"),\n@@ -515,7 +516,7 @@ impl<Tag: Provenance> fmt::Debug for ScalarMaybeUninit<Tag> {\n     }\n }\n \n-impl<Tag: Provenance> fmt::LowerHex for ScalarMaybeUninit<Tag> {\n+impl<Prov: Provenance> fmt::LowerHex for ScalarMaybeUninit<Prov> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             ScalarMaybeUninit::Uninit => write!(f, \"uninitialized bytes\"),\n@@ -524,27 +525,27 @@ impl<Tag: Provenance> fmt::LowerHex for ScalarMaybeUninit<Tag> {\n     }\n }\n \n-impl<Tag> ScalarMaybeUninit<Tag> {\n+impl<Prov> ScalarMaybeUninit<Prov> {\n     #[inline]\n-    pub fn from_pointer(ptr: Pointer<Tag>, cx: &impl HasDataLayout) -> Self {\n+    pub fn from_pointer(ptr: Pointer<Prov>, cx: &impl HasDataLayout) -> Self {\n         ScalarMaybeUninit::Scalar(Scalar::from_pointer(ptr, cx))\n     }\n \n     #[inline]\n-    pub fn from_maybe_pointer(ptr: Pointer<Option<Tag>>, cx: &impl HasDataLayout) -> Self {\n+    pub fn from_maybe_pointer(ptr: Pointer<Option<Prov>>, cx: &impl HasDataLayout) -> Self {\n         ScalarMaybeUninit::Scalar(Scalar::from_maybe_pointer(ptr, cx))\n     }\n \n     #[inline]\n-    pub fn check_init<'tcx>(self) -> InterpResult<'tcx, Scalar<Tag>> {\n+    pub fn check_init<'tcx>(self) -> InterpResult<'tcx, Scalar<Prov>> {\n         match self {\n             ScalarMaybeUninit::Scalar(scalar) => Ok(scalar),\n             ScalarMaybeUninit::Uninit => throw_ub!(InvalidUninitBytes(None)),\n         }\n     }\n }\n \n-impl<'tcx, Tag: Provenance> ScalarMaybeUninit<Tag> {\n+impl<'tcx, Prov: Provenance> ScalarMaybeUninit<Prov> {\n     #[inline(always)]\n     pub fn to_bool(self) -> InterpResult<'tcx, bool> {\n         self.check_init()?.to_bool()"}, {"sha": "437776ad765461fb17dcd0da8c3c991f56156fa3", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -767,21 +767,21 @@ pub fn write_allocations<'tcx>(\n /// After the hex dump, an ascii dump follows, replacing all unprintable characters (control\n /// characters or characters whose value is larger than 127) with a `.`\n /// This also prints relocations adequately.\n-pub fn display_allocation<'a, 'tcx, Tag, Extra>(\n+pub fn display_allocation<'a, 'tcx, Prov, Extra>(\n     tcx: TyCtxt<'tcx>,\n-    alloc: &'a Allocation<Tag, Extra>,\n-) -> RenderAllocation<'a, 'tcx, Tag, Extra> {\n+    alloc: &'a Allocation<Prov, Extra>,\n+) -> RenderAllocation<'a, 'tcx, Prov, Extra> {\n     RenderAllocation { tcx, alloc }\n }\n \n #[doc(hidden)]\n-pub struct RenderAllocation<'a, 'tcx, Tag, Extra> {\n+pub struct RenderAllocation<'a, 'tcx, Prov, Extra> {\n     tcx: TyCtxt<'tcx>,\n-    alloc: &'a Allocation<Tag, Extra>,\n+    alloc: &'a Allocation<Prov, Extra>,\n }\n \n-impl<'a, 'tcx, Tag: Provenance, Extra> std::fmt::Display\n-    for RenderAllocation<'a, 'tcx, Tag, Extra>\n+impl<'a, 'tcx, Prov: Provenance, Extra> std::fmt::Display\n+    for RenderAllocation<'a, 'tcx, Prov, Extra>\n {\n     fn fmt(&self, w: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         let RenderAllocation { tcx, alloc } = *self;\n@@ -825,9 +825,9 @@ fn write_allocation_newline(\n /// The `prefix` argument allows callers to add an arbitrary prefix before each line (even if there\n /// is only one line). Note that your prefix should contain a trailing space as the lines are\n /// printed directly after it.\n-fn write_allocation_bytes<'tcx, Tag: Provenance, Extra>(\n+fn write_allocation_bytes<'tcx, Prov: Provenance, Extra>(\n     tcx: TyCtxt<'tcx>,\n-    alloc: &Allocation<Tag, Extra>,\n+    alloc: &Allocation<Prov, Extra>,\n     w: &mut dyn std::fmt::Write,\n     prefix: &str,\n ) -> std::fmt::Result {\n@@ -861,7 +861,7 @@ fn write_allocation_bytes<'tcx, Tag: Provenance, Extra>(\n         if i != line_start {\n             write!(w, \" \")?;\n         }\n-        if let Some(&tag) = alloc.relocations().get(&i) {\n+        if let Some(&prov) = alloc.relocations().get(&i) {\n             // Memory with a relocation must be defined\n             assert!(alloc.init_mask().is_range_initialized(i, i + ptr_size).is_ok());\n             let j = i.bytes_usize();\n@@ -870,7 +870,7 @@ fn write_allocation_bytes<'tcx, Tag: Provenance, Extra>(\n             let offset = read_target_uint(tcx.data_layout.endian, offset).unwrap();\n             let offset = Size::from_bytes(offset);\n             let relocation_width = |bytes| bytes * 3;\n-            let ptr = Pointer::new(tag, offset);\n+            let ptr = Pointer::new(prov, offset);\n             let mut target = format!(\"{:?}\", ptr);\n             if target.len() > relocation_width(ptr_size.bytes_usize() - 1) {\n                 // This is too long, try to save some space."}, {"sha": "b78087ba7607e395e897672dae9c2d14ed462d11", "filename": "compiler/rustc_middle/src/ty/impls_ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -153,9 +153,9 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n }\n \n // `Relocations` with default type parameters is a sorted map.\n-impl<'a, Tag> HashStable<StableHashingContext<'a>> for mir::interpret::Relocations<Tag>\n+impl<'a, Prov> HashStable<StableHashingContext<'a>> for mir::interpret::Relocations<Prov>\n where\n-    Tag: HashStable<StableHashingContext<'a>>,\n+    Prov: HashStable<StableHashingContext<'a>>,\n {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.len().hash_stable(hcx, hasher);"}, {"sha": "da9394128ac38978a9cea44cd9fc40e10c02b9ac", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -1377,9 +1377,9 @@ pub trait PrettyPrinter<'tcx>:\n \n     /// This is overridden for MIR printing because we only want to hide alloc ids from users, not\n     /// from MIR where it is actually useful.\n-    fn pretty_print_const_pointer<Tag: Provenance>(\n+    fn pretty_print_const_pointer<Prov: Provenance>(\n         mut self,\n-        _: Pointer<Tag>,\n+        _: Pointer<Prov>,\n         ty: Ty<'tcx>,\n         print_ty: bool,\n     ) -> Result<Self::Const, Self::Error> {\n@@ -1952,9 +1952,9 @@ impl<'tcx> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx> {\n         }\n     }\n \n-    fn pretty_print_const_pointer<Tag: Provenance>(\n+    fn pretty_print_const_pointer<Prov: Provenance>(\n         self,\n-        p: Pointer<Tag>,\n+        p: Pointer<Prov>,\n         ty: Ty<'tcx>,\n         print_ty: bool,\n     ) -> Result<Self::Const, Self::Error> {"}, {"sha": "f6484a9b54d3c6d0db8f5b8be5401a2ab608e878", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -234,9 +234,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n     }\n \n     fn access_local<'a>(\n-        frame: &'a Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n+        frame: &'a Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>,\n         local: Local,\n-    ) -> InterpResult<'tcx, &'a interpret::Operand<Self::PointerTag>> {\n+    ) -> InterpResult<'tcx, &'a interpret::Operand<Self::Provenance>> {\n         let l = &frame.locals[local];\n \n         if matches!(\n@@ -255,7 +255,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n         frame: usize,\n         local: Local,\n-    ) -> InterpResult<'tcx, &'a mut interpret::Operand<Self::PointerTag>> {\n+    ) -> InterpResult<'tcx, &'a mut interpret::Operand<Self::Provenance>> {\n         if ecx.machine.can_const_prop[local] == ConstPropMode::NoPropagation {\n             throw_machine_stop_str!(\"tried to write to a local that is marked as not propagatable\")\n         }\n@@ -274,7 +274,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         _tcx: TyCtxt<'tcx>,\n         _machine: &Self,\n         _alloc_id: AllocId,\n-        alloc: ConstAllocation<'tcx, Self::PointerTag, Self::AllocExtra>,\n+        alloc: ConstAllocation<'tcx, Self::Provenance, Self::AllocExtra>,\n         _static_def_id: Option<DefId>,\n         is_write: bool,\n     ) -> InterpResult<'tcx> {\n@@ -309,14 +309,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n     #[inline(always)]\n     fn stack<'a>(\n         ecx: &'a InterpCx<'mir, 'tcx, Self>,\n-    ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>] {\n+    ) -> &'a [Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>] {\n         &ecx.machine.stack\n     }\n \n     #[inline(always)]\n     fn stack_mut<'a>(\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n-    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>> {\n+    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>> {\n         &mut ecx.machine.stack\n     }\n }"}, {"sha": "97b1433f5d27aba406036306e0c8082a91665025", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7468c60f8dbf5feb23ad840b174d7e57113a846/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=a7468c60f8dbf5feb23ad840b174d7e57113a846", "patch": "@@ -230,9 +230,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n     }\n \n     fn access_local<'a>(\n-        frame: &'a Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n+        frame: &'a Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>,\n         local: Local,\n-    ) -> InterpResult<'tcx, &'a interpret::Operand<Self::PointerTag>> {\n+    ) -> InterpResult<'tcx, &'a interpret::Operand<Self::Provenance>> {\n         let l = &frame.locals[local];\n \n         if matches!(\n@@ -251,7 +251,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n         frame: usize,\n         local: Local,\n-    ) -> InterpResult<'tcx, &'a mut interpret::Operand<Self::PointerTag>> {\n+    ) -> InterpResult<'tcx, &'a mut interpret::Operand<Self::Provenance>> {\n         if ecx.machine.can_const_prop[local] == ConstPropMode::NoPropagation {\n             throw_machine_stop_str!(\"tried to write to a local that is marked as not propagatable\")\n         }\n@@ -270,7 +270,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         _tcx: TyCtxt<'tcx>,\n         _machine: &Self,\n         _alloc_id: AllocId,\n-        alloc: ConstAllocation<'tcx, Self::PointerTag, Self::AllocExtra>,\n+        alloc: ConstAllocation<'tcx, Self::Provenance, Self::AllocExtra>,\n         _static_def_id: Option<DefId>,\n         is_write: bool,\n     ) -> InterpResult<'tcx> {\n@@ -305,14 +305,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n     #[inline(always)]\n     fn stack<'a>(\n         ecx: &'a InterpCx<'mir, 'tcx, Self>,\n-    ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>] {\n+    ) -> &'a [Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>] {\n         &ecx.machine.stack\n     }\n \n     #[inline(always)]\n     fn stack_mut<'a>(\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n-    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>> {\n+    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>> {\n         &mut ecx.machine.stack\n     }\n }"}]}