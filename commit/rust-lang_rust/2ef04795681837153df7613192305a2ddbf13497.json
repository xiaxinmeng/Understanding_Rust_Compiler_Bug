{"sha": "2ef04795681837153df7613192305a2ddbf13497", "node_id": "C_kwDOAAsO6NoAKDJlZjA0Nzk1NjgxODM3MTUzZGY3NjEzMTkyMzA1YTJkZGJmMTM0OTc", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-08-14T23:58:38Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-08-15T03:29:28Z"}, "message": "Simplify attribute handling in `parse_bottom_expr`.\n\n`Parser::parse_bottom_expr` currently constructs an empty `attrs` and\nthen passes it to a large number of other functions. This makes the code\nharder to read than it should be, because it's not clear that many\n`attrs` arguments are always empty.\n\nThis commit removes `attrs` and the passing, simplifying a lot of\nfunctions. The commit also renames `Parser::mk_expr` (which takes an\n`attrs` argument) as `mk_expr_with_attrs`, and introduces a new\n`mk_expr` which creates an expression with no attributes, which is the\nmore common case.", "tree": {"sha": "63ba7232dcbada3c9e175f7083118f3cba0e1748", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63ba7232dcbada3c9e175f7083118f3cba0e1748"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ef04795681837153df7613192305a2ddbf13497", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ef04795681837153df7613192305a2ddbf13497", "html_url": "https://github.com/rust-lang/rust/commit/2ef04795681837153df7613192305a2ddbf13497", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ef04795681837153df7613192305a2ddbf13497/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e8497351d7cb15eddd9db2f88866294bab27a21", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e8497351d7cb15eddd9db2f88866294bab27a21", "html_url": "https://github.com/rust-lang/rust/commit/1e8497351d7cb15eddd9db2f88866294bab27a21"}], "stats": {"total": 367, "additions": 159, "deletions": 208}, "files": [{"sha": "48909ff834234ba1a9bd80dca9bedd5dd21b1a92", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ef04795681837153df7613192305a2ddbf13497/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef04795681837153df7613192305a2ddbf13497/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=2ef04795681837153df7613192305a2ddbf13497", "patch": "@@ -734,7 +734,7 @@ impl<'a> Parser<'a> {\n             let mut snapshot = self.create_snapshot_for_diagnostic();\n             let path =\n                 Path { segments: vec![], span: self.prev_token.span.shrink_to_lo(), tokens: None };\n-            let struct_expr = snapshot.parse_struct_expr(None, path, AttrVec::new(), false);\n+            let struct_expr = snapshot.parse_struct_expr(None, path, false);\n             let block_tail = self.parse_block_tail(lo, s, AttemptLocalParseRecovery::No);\n             return Some(match (struct_expr, block_tail) {\n                 (Ok(expr), Err(mut err)) => {\n@@ -1188,8 +1188,7 @@ impl<'a> Parser<'a> {\n             outer_op.node,\n         );\n \n-        let mk_err_expr =\n-            |this: &Self, span| Ok(Some(this.mk_expr(span, ExprKind::Err, AttrVec::new())));\n+        let mk_err_expr = |this: &Self, span| Ok(Some(this.mk_expr(span, ExprKind::Err)));\n \n         match inner_op.kind {\n             ExprKind::Binary(op, ref l1, ref r1) if op.node.is_comparison() => {\n@@ -1647,7 +1646,6 @@ impl<'a> Parser<'a> {\n         &mut self,\n         lo: Span,\n         await_sp: Span,\n-        attrs: AttrVec,\n     ) -> PResult<'a, P<Expr>> {\n         let (hi, expr, is_question) = if self.token == token::Not {\n             // Handle `await!(<expr>)`.\n@@ -1662,7 +1660,7 @@ impl<'a> Parser<'a> {\n             ExprKind::Try(_) => ExprKind::Err,\n             _ => ExprKind::Await(expr),\n         };\n-        let expr = self.mk_expr(lo.to(sp), kind, attrs);\n+        let expr = self.mk_expr(lo.to(sp), kind);\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n@@ -1680,7 +1678,7 @@ impl<'a> Parser<'a> {\n             // Handle `await { <expr> }`.\n             // This needs to be handled separately from the next arm to avoid\n             // interpreting `await { <expr> }?` as `<expr>?.await`.\n-            self.parse_block_expr(None, self.token.span, BlockCheckMode::Default, AttrVec::new())\n+            self.parse_block_expr(None, self.token.span, BlockCheckMode::Default)\n         } else {\n             self.parse_expr()\n         }\n@@ -1823,7 +1821,7 @@ impl<'a> Parser<'a> {\n                 err.emit();\n                 // Recover from parse error, callers expect the closing delim to be consumed.\n                 self.consume_block(delim, ConsumeClosingDelim::Yes);\n-                self.mk_expr(lo.to(self.prev_token.span), ExprKind::Err, AttrVec::new())\n+                self.mk_expr(lo.to(self.prev_token.span), ExprKind::Err)\n             }\n         }\n     }"}, {"sha": "1bef277f3d0606138eef0f7d48e8668bfaa7d8c1", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 140, "deletions": 186, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/2ef04795681837153df7613192305a2ddbf13497/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef04795681837153df7613192305a2ddbf13497/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=2ef04795681837153df7613192305a2ddbf13497", "patch": "@@ -20,7 +20,6 @@ use rustc_ast::{AnonConst, BinOp, BinOpKind, FnDecl, FnRetTy, MacCall, Param, Ty\n use rustc_ast::{Arm, Async, BlockCheckMode, Expr, ExprKind, Label, Movability, RangeLimits};\n use rustc_ast::{ClosureBinder, StmtKind};\n use rustc_ast_pretty::pprust;\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, PResult};\n use rustc_session::lint::builtin::BREAK_WITH_LABEL_AND_LOOP;\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -45,20 +44,12 @@ macro_rules! maybe_whole_expr {\n                 token::NtPath(path) => {\n                     let path = (**path).clone();\n                     $p.bump();\n-                    return Ok($p.mk_expr(\n-                        $p.prev_token.span,\n-                        ExprKind::Path(None, path),\n-                        AttrVec::new(),\n-                    ));\n+                    return Ok($p.mk_expr($p.prev_token.span, ExprKind::Path(None, path)));\n                 }\n                 token::NtBlock(block) => {\n                     let block = block.clone();\n                     $p.bump();\n-                    return Ok($p.mk_expr(\n-                        $p.prev_token.span,\n-                        ExprKind::Block(block, None),\n-                        AttrVec::new(),\n-                    ));\n+                    return Ok($p.mk_expr($p.prev_token.span, ExprKind::Block(block, None)));\n                 }\n                 _ => {}\n             };\n@@ -120,7 +111,7 @@ impl<'a> Parser<'a> {\n                     // Special-case handling of `foo(_, _, _)`\n                     err.emit();\n                     self.bump();\n-                    Ok(self.mk_expr(self.prev_token.span, ExprKind::Err, AttrVec::new()))\n+                    Ok(self.mk_expr(self.prev_token.span, ExprKind::Err))\n                 }\n                 _ => Err(err),\n             },\n@@ -329,11 +320,9 @@ impl<'a> Parser<'a> {\n                 | AssocOp::GreaterEqual => {\n                     let ast_op = op.to_ast_binop().unwrap();\n                     let binary = self.mk_binary(source_map::respan(cur_op_span, ast_op), lhs, rhs);\n-                    self.mk_expr(span, binary, AttrVec::new())\n-                }\n-                AssocOp::Assign => {\n-                    self.mk_expr(span, ExprKind::Assign(lhs, rhs, cur_op_span), AttrVec::new())\n+                    self.mk_expr(span, binary)\n                 }\n+                AssocOp::Assign => self.mk_expr(span, ExprKind::Assign(lhs, rhs, cur_op_span)),\n                 AssocOp::AssignOp(k) => {\n                     let aop = match k {\n                         token::Plus => BinOpKind::Add,\n@@ -348,7 +337,7 @@ impl<'a> Parser<'a> {\n                         token::Shr => BinOpKind::Shr,\n                     };\n                     let aopexpr = self.mk_assign_op(source_map::respan(cur_op_span, aop), lhs, rhs);\n-                    self.mk_expr(span, aopexpr, AttrVec::new())\n+                    self.mk_expr(span, aopexpr)\n                 }\n                 AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotEq => {\n                     self.span_bug(span, \"AssocOp should have been handled by special case\")\n@@ -491,7 +480,7 @@ impl<'a> Parser<'a> {\n         let limits =\n             if op == AssocOp::DotDot { RangeLimits::HalfOpen } else { RangeLimits::Closed };\n         let range = self.mk_range(Some(lhs), rhs, limits);\n-        Ok(self.mk_expr(span, range, AttrVec::new()))\n+        Ok(self.mk_expr(span, range))\n     }\n \n     fn is_at_start_of_range_notation_rhs(&self) -> bool {\n@@ -540,7 +529,7 @@ impl<'a> Parser<'a> {\n                 (lo, None)\n             };\n             let range = this.mk_range(None, opt_end, limits);\n-            Ok(this.mk_expr(span, range, attrs.into()))\n+            Ok(this.mk_expr_with_attrs(span, range, attrs))\n         })\n     }\n \n@@ -553,7 +542,7 @@ impl<'a> Parser<'a> {\n             ($this:ident, $attrs:expr, |this, _| $body:expr) => {\n                 $this.collect_tokens_for_expr($attrs, |$this, attrs| {\n                     let (hi, ex) = $body?;\n-                    Ok($this.mk_expr(lo.to(hi), ex, attrs.into()))\n+                    Ok($this.mk_expr_with_attrs(lo.to(hi), ex, attrs))\n                 })\n             };\n         }\n@@ -705,11 +694,7 @@ impl<'a> Parser<'a> {\n         expr_kind: fn(P<Expr>, P<Ty>) -> ExprKind,\n     ) -> PResult<'a, P<Expr>> {\n         let mk_expr = |this: &mut Self, lhs: P<Expr>, rhs: P<Ty>| {\n-            this.mk_expr(\n-                this.mk_expr_sp(&lhs, lhs_span, rhs.span),\n-                expr_kind(lhs, rhs),\n-                AttrVec::new(),\n-            )\n+            this.mk_expr(this.mk_expr_sp(&lhs, lhs_span, rhs.span), expr_kind(lhs, rhs))\n         };\n \n         // Save the state of the parser before parsing type normally, in case there is a\n@@ -737,7 +722,7 @@ impl<'a> Parser<'a> {\n                                 segments[0].ident.span,\n                             ),\n                         };\n-                        match self.parse_labeled_expr(label, AttrVec::new(), false) {\n+                        match self.parse_labeled_expr(label, false) {\n                             Ok(expr) => {\n                                 type_err.cancel();\n                                 self.struct_span_err(label.ident.span, \"malformed loop label\")\n@@ -990,7 +975,7 @@ impl<'a> Parser<'a> {\n             };\n             if has_question {\n                 // `expr?`\n-                e = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Try(e), AttrVec::new());\n+                e = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Try(e));\n                 continue;\n             }\n             let has_dot = if self.prev_token.kind == TokenKind::Ident(kw::Return, false) {\n@@ -1168,7 +1153,7 @@ impl<'a> Parser<'a> {\n         let span = self.prev_token.span;\n         let field = ExprKind::Field(base, Ident::new(field, span));\n         self.expect_no_suffix(span, \"a tuple index\", suffix);\n-        self.mk_expr(lo.to(span), field, AttrVec::new())\n+        self.mk_expr(lo.to(span), field)\n     }\n \n     /// Parse a function call expression, `expr(...)`.\n@@ -1182,9 +1167,9 @@ impl<'a> Parser<'a> {\n         };\n         let open_paren = self.token.span;\n \n-        let mut seq = self.parse_paren_expr_seq().map(|args| {\n-            self.mk_expr(lo.to(self.prev_token.span), self.mk_call(fun, args), AttrVec::new())\n-        });\n+        let mut seq = self\n+            .parse_paren_expr_seq()\n+            .map(|args| self.mk_expr(lo.to(self.prev_token.span), self.mk_call(fun, args)));\n         if let Some(expr) =\n             self.maybe_recover_struct_lit_bad_delims(lo, open_paren, &mut seq, snapshot)\n         {\n@@ -1264,7 +1249,7 @@ impl<'a> Parser<'a> {\n         let index = self.parse_expr()?;\n         self.suggest_missing_semicolon_before_array(prev_span, open_delim_span)?;\n         self.expect(&token::CloseDelim(Delimiter::Bracket))?;\n-        Ok(self.mk_expr(lo.to(self.prev_token.span), self.mk_index(base, index), AttrVec::new()))\n+        Ok(self.mk_expr(lo.to(self.prev_token.span), self.mk_index(base, index)))\n     }\n \n     /// Assuming we have just parsed `.`, continue parsing into an expression.\n@@ -1283,11 +1268,7 @@ impl<'a> Parser<'a> {\n             let args = self.parse_paren_expr_seq()?;\n             let fn_span = fn_span_lo.to(self.prev_token.span);\n             let span = lo.to(self.prev_token.span);\n-            Ok(self.mk_expr(\n-                span,\n-                ExprKind::MethodCall(segment, self_arg, args, fn_span),\n-                AttrVec::new(),\n-            ))\n+            Ok(self.mk_expr(span, ExprKind::MethodCall(segment, self_arg, args, fn_span)))\n         } else {\n             // Field access `expr.f`\n             if let Some(args) = segment.args {\n@@ -1299,7 +1280,7 @@ impl<'a> Parser<'a> {\n             }\n \n             let span = lo.to(self.prev_token.span);\n-            Ok(self.mk_expr(span, ExprKind::Field(self_arg, segment.ident), AttrVec::new()))\n+            Ok(self.mk_expr(span, ExprKind::Field(self_arg, segment.ident)))\n         }\n     }\n \n@@ -1314,24 +1295,20 @@ impl<'a> Parser<'a> {\n \n         // Outer attributes are already parsed and will be\n         // added to the return value after the fact.\n-        //\n-        // Therefore, prevent sub-parser from parsing\n-        // attributes by giving them an empty \"already-parsed\" list.\n-        let attrs = AttrVec::new();\n \n         // Note: when adding new syntax here, don't forget to adjust `TokenKind::can_begin_expr()`.\n         let lo = self.token.span;\n         if let token::Literal(_) = self.token.kind {\n             // This match arm is a special-case of the `_` match arm below and\n             // could be removed without changing functionality, but it's faster\n             // to have it here, especially for programs with large constants.\n-            self.parse_lit_expr(attrs)\n+            self.parse_lit_expr()\n         } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n-            self.parse_tuple_parens_expr(attrs)\n+            self.parse_tuple_parens_expr()\n         } else if self.check(&token::OpenDelim(Delimiter::Brace)) {\n-            self.parse_block_expr(None, lo, BlockCheckMode::Default, attrs)\n+            self.parse_block_expr(None, lo, BlockCheckMode::Default)\n         } else if self.check(&token::BinOp(token::Or)) || self.check(&token::OrOr) {\n-            self.parse_closure_expr(attrs).map_err(|mut err| {\n+            self.parse_closure_expr().map_err(|mut err| {\n                 // If the input is something like `if a { 1 } else { 2 } | if a { 3 } else { 4 }`\n                 // then suggest parens around the lhs.\n                 if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow().get(&lo) {\n@@ -1340,65 +1317,66 @@ impl<'a> Parser<'a> {\n                 err\n             })\n         } else if self.check(&token::OpenDelim(Delimiter::Bracket)) {\n-            self.parse_array_or_repeat_expr(attrs, Delimiter::Bracket)\n+            self.parse_array_or_repeat_expr(Delimiter::Bracket)\n         } else if self.check_path() {\n-            self.parse_path_start_expr(attrs)\n+            self.parse_path_start_expr()\n         } else if self.check_keyword(kw::Move) || self.check_keyword(kw::Static) {\n-            self.parse_closure_expr(attrs)\n+            self.parse_closure_expr()\n         } else if self.eat_keyword(kw::If) {\n-            self.parse_if_expr(attrs)\n+            self.parse_if_expr()\n         } else if self.check_keyword(kw::For) {\n             if self.choose_generics_over_qpath(1) {\n-                self.parse_closure_expr(attrs)\n+                self.parse_closure_expr()\n             } else {\n                 assert!(self.eat_keyword(kw::For));\n-                self.parse_for_expr(None, self.prev_token.span, attrs)\n+                self.parse_for_expr(None, self.prev_token.span)\n             }\n         } else if self.eat_keyword(kw::While) {\n-            self.parse_while_expr(None, self.prev_token.span, attrs)\n+            self.parse_while_expr(None, self.prev_token.span)\n         } else if let Some(label) = self.eat_label() {\n-            self.parse_labeled_expr(label, attrs, true)\n+            self.parse_labeled_expr(label, true)\n         } else if self.eat_keyword(kw::Loop) {\n             let sp = self.prev_token.span;\n-            self.parse_loop_expr(None, self.prev_token.span, attrs).map_err(|mut err| {\n+            self.parse_loop_expr(None, self.prev_token.span).map_err(|mut err| {\n                 err.span_label(sp, \"while parsing this `loop` expression\");\n                 err\n             })\n         } else if self.eat_keyword(kw::Continue) {\n             let kind = ExprKind::Continue(self.eat_label());\n-            Ok(self.mk_expr(lo.to(self.prev_token.span), kind, attrs))\n+            Ok(self.mk_expr(lo.to(self.prev_token.span), kind))\n         } else if self.eat_keyword(kw::Match) {\n             let match_sp = self.prev_token.span;\n-            self.parse_match_expr(attrs).map_err(|mut err| {\n+            self.parse_match_expr().map_err(|mut err| {\n                 err.span_label(match_sp, \"while parsing this `match` expression\");\n                 err\n             })\n         } else if self.eat_keyword(kw::Unsafe) {\n             let sp = self.prev_token.span;\n-            self.parse_block_expr(None, lo, BlockCheckMode::Unsafe(ast::UserProvided), attrs)\n-                .map_err(|mut err| {\n+            self.parse_block_expr(None, lo, BlockCheckMode::Unsafe(ast::UserProvided)).map_err(\n+                |mut err| {\n                     err.span_label(sp, \"while parsing this `unsafe` expression\");\n                     err\n-                })\n+                },\n+            )\n         } else if self.check_inline_const(0) {\n             self.parse_const_block(lo.to(self.token.span), false)\n         } else if self.is_do_catch_block() {\n-            self.recover_do_catch(attrs)\n+            self.recover_do_catch()\n         } else if self.is_try_block() {\n             self.expect_keyword(kw::Try)?;\n-            self.parse_try_block(lo, attrs)\n+            self.parse_try_block(lo)\n         } else if self.eat_keyword(kw::Return) {\n-            self.parse_return_expr(attrs)\n+            self.parse_return_expr()\n         } else if self.eat_keyword(kw::Break) {\n-            self.parse_break_expr(attrs)\n+            self.parse_break_expr()\n         } else if self.eat_keyword(kw::Yield) {\n-            self.parse_yield_expr(attrs)\n+            self.parse_yield_expr()\n         } else if self.is_do_yeet() {\n-            self.parse_yeet_expr(attrs)\n+            self.parse_yeet_expr()\n         } else if self.check_keyword(kw::Let) {\n-            self.parse_let_expr(attrs)\n+            self.parse_let_expr()\n         } else if self.eat_keyword(kw::Underscore) {\n-            Ok(self.mk_expr(self.prev_token.span, ExprKind::Underscore, attrs))\n+            Ok(self.mk_expr(self.prev_token.span, ExprKind::Underscore))\n         } else if !self.unclosed_delims.is_empty() && self.check(&token::Semi) {\n             // Don't complain about bare semicolons after unclosed braces\n             // recovery in order to keep the error count down. Fixing the\n@@ -1417,32 +1395,32 @@ impl<'a> Parser<'a> {\n             if self.check_keyword(kw::Async) {\n                 if self.is_async_block() {\n                     // Check for `async {` and `async move {`.\n-                    self.parse_async_block(attrs)\n+                    self.parse_async_block()\n                 } else {\n-                    self.parse_closure_expr(attrs)\n+                    self.parse_closure_expr()\n                 }\n             } else if self.eat_keyword(kw::Await) {\n-                self.recover_incorrect_await_syntax(lo, self.prev_token.span, attrs)\n+                self.recover_incorrect_await_syntax(lo, self.prev_token.span)\n             } else {\n-                self.parse_lit_expr(attrs)\n+                self.parse_lit_expr()\n             }\n         } else {\n-            self.parse_lit_expr(attrs)\n+            self.parse_lit_expr()\n         }\n     }\n \n-    fn parse_lit_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_lit_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         match self.parse_opt_lit() {\n             Some(literal) => {\n-                let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Lit(literal), attrs);\n+                let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Lit(literal));\n                 self.maybe_recover_from_bad_qpath(expr)\n             }\n             None => self.try_macro_suggestion(),\n         }\n     }\n \n-    fn parse_tuple_parens_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_tuple_parens_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         self.expect(&token::OpenDelim(Delimiter::Parenthesis))?;\n         let (es, trailing_comma) = match self.parse_seq_to_end(\n@@ -1462,15 +1440,11 @@ impl<'a> Parser<'a> {\n             // `(e,)` is a tuple with only one field, `e`.\n             ExprKind::Tup(es)\n         };\n-        let expr = self.mk_expr(lo.to(self.prev_token.span), kind, attrs);\n+        let expr = self.mk_expr(lo.to(self.prev_token.span), kind);\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n-    fn parse_array_or_repeat_expr(\n-        &mut self,\n-        attrs: AttrVec,\n-        close_delim: Delimiter,\n-    ) -> PResult<'a, P<Expr>> {\n+    fn parse_array_or_repeat_expr(&mut self, close_delim: Delimiter) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         self.bump(); // `[` or other open delim\n \n@@ -1499,11 +1473,11 @@ impl<'a> Parser<'a> {\n                 ExprKind::Array(vec![first_expr])\n             }\n         };\n-        let expr = self.mk_expr(lo.to(self.prev_token.span), kind, attrs);\n+        let expr = self.mk_expr(lo.to(self.prev_token.span), kind);\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n-    fn parse_path_start_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_path_start_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let (qself, path) = if self.eat_lt() {\n             let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n             (Some(qself), path)\n@@ -1525,7 +1499,7 @@ impl<'a> Parser<'a> {\n             };\n             (lo.to(self.prev_token.span), ExprKind::MacCall(mac))\n         } else if self.check(&token::OpenDelim(Delimiter::Brace)) &&\n-            let Some(expr) = self.maybe_parse_struct_expr(qself.as_ref(), &path, &attrs) {\n+            let Some(expr) = self.maybe_parse_struct_expr(qself.as_ref(), &path) {\n                 if qself.is_some() {\n                     self.sess.gated_spans.gate(sym::more_qualified_paths, path.span);\n                 }\n@@ -1534,30 +1508,29 @@ impl<'a> Parser<'a> {\n             (path.span, ExprKind::Path(qself, path))\n         };\n \n-        let expr = self.mk_expr(span, kind, attrs);\n+        let expr = self.mk_expr(span, kind);\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     /// Parse `'label: $expr`. The label is already parsed.\n     fn parse_labeled_expr(\n         &mut self,\n         label: Label,\n-        attrs: AttrVec,\n         mut consume_colon: bool,\n     ) -> PResult<'a, P<Expr>> {\n         let lo = label.ident.span;\n         let label = Some(label);\n         let ate_colon = self.eat(&token::Colon);\n         let expr = if self.eat_keyword(kw::While) {\n-            self.parse_while_expr(label, lo, attrs)\n+            self.parse_while_expr(label, lo)\n         } else if self.eat_keyword(kw::For) {\n-            self.parse_for_expr(label, lo, attrs)\n+            self.parse_for_expr(label, lo)\n         } else if self.eat_keyword(kw::Loop) {\n-            self.parse_loop_expr(label, lo, attrs)\n+            self.parse_loop_expr(label, lo)\n         } else if self.check_noexpect(&token::OpenDelim(Delimiter::Brace))\n             || self.token.is_whole_block()\n         {\n-            self.parse_block_expr(label, lo, BlockCheckMode::Default, attrs)\n+            self.parse_block_expr(label, lo, BlockCheckMode::Default)\n         } else if !ate_colon\n             && (self.check_noexpect(&TokenKind::Comma) || self.check_noexpect(&TokenKind::Gt))\n         {\n@@ -1623,7 +1596,7 @@ impl<'a> Parser<'a> {\n                 // Replace `'label: non_block_expr` with `'label: {non_block_expr}` in order to supress future errors about `break 'label`.\n                 let stmt = self.mk_stmt(span, StmtKind::Expr(expr));\n                 let blk = self.mk_block(vec![stmt], BlockCheckMode::Default, span);\n-                self.mk_expr(span, ExprKind::Block(blk, label), ThinVec::new())\n+                self.mk_expr(span, ExprKind::Block(blk, label))\n             });\n \n             err.emit();\n@@ -1651,7 +1624,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Recover on the syntax `do catch { ... }` suggesting `try { ... }` instead.\n-    fn recover_do_catch(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn recover_do_catch(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n \n         self.bump(); // `do`\n@@ -1668,7 +1641,7 @@ impl<'a> Parser<'a> {\n             .note(\"following RFC #2388, the new non-placeholder syntax is `try`\")\n             .emit();\n \n-        self.parse_try_block(lo, attrs)\n+        self.parse_try_block(lo)\n     }\n \n     /// Parse an expression if the token can begin one.\n@@ -1677,15 +1650,15 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `\"return\" expr?`.\n-    fn parse_return_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_return_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n         let kind = ExprKind::Ret(self.parse_expr_opt()?);\n-        let expr = self.mk_expr(lo.to(self.prev_token.span), kind, attrs);\n+        let expr = self.mk_expr(lo.to(self.prev_token.span), kind);\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     /// Parse `\"do\" \"yeet\" expr?`.\n-    fn parse_yeet_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_yeet_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n \n         self.bump(); // `do`\n@@ -1695,7 +1668,7 @@ impl<'a> Parser<'a> {\n \n         let span = lo.to(self.prev_token.span);\n         self.sess.gated_spans.gate(sym::yeet_expr, span);\n-        let expr = self.mk_expr(span, kind, attrs);\n+        let expr = self.mk_expr(span, kind);\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n@@ -1707,13 +1680,13 @@ impl<'a> Parser<'a> {\n     /// `break 'lbl: loop {}`); a labeled break with an unlabeled loop as its value\n     /// expression only gets a warning for compatibility reasons; and a labeled break\n     /// with a labeled loop does not even get a warning because there is no ambiguity.\n-    fn parse_break_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_break_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n         let mut label = self.eat_label();\n         let kind = if label.is_some() && self.token == token::Colon {\n             // The value expression can be a labeled loop, see issue #86948, e.g.:\n             // `loop { break 'label: loop { break 'label 42; }; }`\n-            let lexpr = self.parse_labeled_expr(label.take().unwrap(), AttrVec::new(), true)?;\n+            let lexpr = self.parse_labeled_expr(label.take().unwrap(), true)?;\n             self.struct_span_err(\n                 lexpr.span,\n                 \"parentheses are required around this expression to avoid confusion with a labeled break expression\",\n@@ -1755,17 +1728,17 @@ impl<'a> Parser<'a> {\n         } else {\n             None\n         };\n-        let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Break(label, kind), attrs);\n+        let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Break(label, kind));\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     /// Parse `\"yield\" expr?`.\n-    fn parse_yield_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_yield_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n         let kind = ExprKind::Yield(self.parse_expr_opt()?);\n         let span = lo.to(self.prev_token.span);\n         self.sess.gated_spans.gate(sym::generators, span);\n-        let expr = self.mk_expr(span, kind, attrs);\n+        let expr = self.mk_expr(span, kind);\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n@@ -2009,14 +1982,10 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         let minus_present = self.eat(&token::BinOp(token::Minus));\n         let lit = self.parse_lit()?;\n-        let expr = self.mk_expr(lit.span, ExprKind::Lit(lit), AttrVec::new());\n+        let expr = self.mk_expr(lit.span, ExprKind::Lit(lit));\n \n         if minus_present {\n-            Ok(self.mk_expr(\n-                lo.to(self.prev_token.span),\n-                self.mk_unary(UnOp::Neg, expr),\n-                AttrVec::new(),\n-            ))\n+            Ok(self.mk_expr(lo.to(self.prev_token.span), self.mk_unary(UnOp::Neg, expr)))\n         } else {\n             Ok(expr)\n         }\n@@ -2031,13 +2000,9 @@ impl<'a> Parser<'a> {\n     /// Emits a suggestion if it looks like the user meant an array but\n     /// accidentally used braces, causing the code to be interpreted as a block\n     /// expression.\n-    fn maybe_suggest_brackets_instead_of_braces(\n-        &mut self,\n-        lo: Span,\n-        attrs: AttrVec,\n-    ) -> Option<P<Expr>> {\n+    fn maybe_suggest_brackets_instead_of_braces(&mut self, lo: Span) -> Option<P<Expr>> {\n         let mut snapshot = self.create_snapshot_for_diagnostic();\n-        match snapshot.parse_array_or_repeat_expr(attrs, Delimiter::Brace) {\n+        match snapshot.parse_array_or_repeat_expr(Delimiter::Brace) {\n             Ok(arr) => {\n                 let hi = snapshot.prev_token.span;\n                 self.struct_span_err(arr.span, \"this is a block expression, not an array\")\n@@ -2103,10 +2068,9 @@ impl<'a> Parser<'a> {\n         opt_label: Option<Label>,\n         lo: Span,\n         blk_mode: BlockCheckMode,\n-        mut attrs: AttrVec,\n     ) -> PResult<'a, P<Expr>> {\n         if self.is_array_like_block() {\n-            if let Some(arr) = self.maybe_suggest_brackets_instead_of_braces(lo, attrs.clone()) {\n+            if let Some(arr) = self.maybe_suggest_brackets_instead_of_braces(lo) {\n                 return Ok(arr);\n             }\n         }\n@@ -2121,19 +2085,18 @@ impl<'a> Parser<'a> {\n                 .emit();\n         }\n \n-        let (inner_attrs, blk) = self.parse_block_common(lo, blk_mode)?;\n-        attrs.extend(inner_attrs);\n-        Ok(self.mk_expr(blk.span, ExprKind::Block(blk, opt_label), attrs))\n+        let (attrs, blk) = self.parse_block_common(lo, blk_mode)?;\n+        Ok(self.mk_expr_with_attrs(blk.span, ExprKind::Block(blk, opt_label), attrs))\n     }\n \n     /// Parse a block which takes no attributes and has no label\n     fn parse_simple_block(&mut self) -> PResult<'a, P<Expr>> {\n         let blk = self.parse_block()?;\n-        Ok(self.mk_expr(blk.span, ExprKind::Block(blk, None), AttrVec::new()))\n+        Ok(self.mk_expr(blk.span, ExprKind::Block(blk, None)))\n     }\n \n     /// Parses a closure expression (e.g., `move |args| expr`).\n-    fn parse_closure_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_closure_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n \n         let binder = if self.check_keyword(kw::For) {\n@@ -2168,7 +2131,7 @@ impl<'a> Parser<'a> {\n             _ => {\n                 // If an explicit return type is given, require a block to appear (RFC 968).\n                 let body_lo = self.token.span;\n-                self.parse_block_expr(None, body_lo, BlockCheckMode::Default, AttrVec::new())?\n+                self.parse_block_expr(None, body_lo, BlockCheckMode::Default)?\n             }\n         };\n \n@@ -2199,7 +2162,6 @@ impl<'a> Parser<'a> {\n                 body,\n                 lo.to(decl_hi),\n             ),\n-            attrs,\n         );\n \n         // Disable recovery for closure body\n@@ -2275,19 +2237,13 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an `if` expression (`if` token already eaten).\n-    fn parse_if_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_if_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n         let cond = self.parse_cond_expr()?;\n-\n-        self.parse_if_after_cond(attrs, lo, cond)\n+        self.parse_if_after_cond(lo, cond)\n     }\n \n-    fn parse_if_after_cond(\n-        &mut self,\n-        attrs: AttrVec,\n-        lo: Span,\n-        mut cond: P<Expr>,\n-    ) -> PResult<'a, P<Expr>> {\n+    fn parse_if_after_cond(&mut self, lo: Span, mut cond: P<Expr>) -> PResult<'a, P<Expr>> {\n         let cond_span = cond.span;\n         // Tries to interpret `cond` as either a missing expression if it's a block,\n         // or as an unfinished expression if it's a binop and the RHS is a block.\n@@ -2343,7 +2299,7 @@ impl<'a> Parser<'a> {\n             block\n         };\n         let els = if self.eat_keyword(kw::Else) { Some(self.parse_else_expr()?) } else { None };\n-        Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::If(cond, thn, els), attrs))\n+        Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::If(cond, thn, els)))\n     }\n \n     fn error_missing_if_then_block(\n@@ -2385,7 +2341,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `let $pat = $expr` pseudo-expression.\n-    fn parse_let_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_let_expr(&mut self) -> PResult<'a, P<Expr>> {\n         // This is a *approximate* heuristic that detects if `let` chains are\n         // being parsed in the right position. It's approximate because it\n         // doesn't deny all invalid `let` expressions, just completely wrong usages.\n@@ -2411,15 +2367,15 @@ impl<'a> Parser<'a> {\n             this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n         })?;\n         let span = lo.to(expr.span);\n-        Ok(self.mk_expr(span, ExprKind::Let(pat, expr, span), attrs))\n+        Ok(self.mk_expr(span, ExprKind::Let(pat, expr, span)))\n     }\n \n     /// Parses an `else { ... }` expression (`else` token already eaten).\n     fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let else_span = self.prev_token.span; // `else`\n         let attrs = self.parse_outer_attributes()?.take_for_recovery(); // For recovery.\n         let expr = if self.eat_keyword(kw::If) {\n-            self.parse_if_expr(AttrVec::new())?\n+            self.parse_if_expr()?\n         } else if self.check(&TokenKind::OpenDelim(Delimiter::Brace)) {\n             self.parse_simple_block()?\n         } else {\n@@ -2442,7 +2398,7 @@ impl<'a> Parser<'a> {\n                             Applicability::MaybeIncorrect,\n                         )\n                         .emit();\n-                    self.parse_if_after_cond(AttrVec::new(), cond.span.shrink_to_lo(), cond)?\n+                    self.parse_if_after_cond(cond.span.shrink_to_lo(), cond)?\n                 }\n                 Err(e) => {\n                     e.cancel();\n@@ -2479,12 +2435,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `for <src_pat> in <src_expr> <src_loop_block>` (`for` token already eaten).\n-    fn parse_for_expr(\n-        &mut self,\n-        opt_label: Option<Label>,\n-        lo: Span,\n-        mut attrs: AttrVec,\n-    ) -> PResult<'a, P<Expr>> {\n+    fn parse_for_expr(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n         // Record whether we are about to parse `for (`.\n         // This is used below for recovery in case of `for ( $stuff ) $block`\n         // in which case we will suggest `for $stuff $block`.\n@@ -2507,11 +2458,10 @@ impl<'a> Parser<'a> {\n \n         let pat = self.recover_parens_around_for_head(pat, begin_paren);\n \n-        let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n-        attrs.extend(iattrs);\n+        let (attrs, loop_block) = self.parse_inner_attrs_and_block()?;\n \n         let kind = ExprKind::ForLoop(pat, expr, loop_block, opt_label);\n-        Ok(self.mk_expr(lo.to(self.prev_token.span), kind, attrs))\n+        Ok(self.mk_expr_with_attrs(lo.to(self.prev_token.span), kind, attrs))\n     }\n \n     fn error_missing_in_for_loop(&mut self) {\n@@ -2535,35 +2485,31 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `while` or `while let` expression (`while` token already eaten).\n-    fn parse_while_expr(\n-        &mut self,\n-        opt_label: Option<Label>,\n-        lo: Span,\n-        mut attrs: AttrVec,\n-    ) -> PResult<'a, P<Expr>> {\n+    fn parse_while_expr(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n         let cond = self.parse_cond_expr().map_err(|mut err| {\n             err.span_label(lo, \"while parsing the condition of this `while` expression\");\n             err\n         })?;\n-        let (iattrs, body) = self.parse_inner_attrs_and_block().map_err(|mut err| {\n+        let (attrs, body) = self.parse_inner_attrs_and_block().map_err(|mut err| {\n             err.span_label(lo, \"while parsing the body of this `while` expression\");\n             err.span_label(cond.span, \"this `while` condition successfully parsed\");\n             err\n         })?;\n-        attrs.extend(iattrs);\n-        Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::While(cond, body, opt_label), attrs))\n+        Ok(self.mk_expr_with_attrs(\n+            lo.to(self.prev_token.span),\n+            ExprKind::While(cond, body, opt_label),\n+            attrs,\n+        ))\n     }\n \n     /// Parses `loop { ... }` (`loop` token already eaten).\n-    fn parse_loop_expr(\n-        &mut self,\n-        opt_label: Option<Label>,\n-        lo: Span,\n-        mut attrs: AttrVec,\n-    ) -> PResult<'a, P<Expr>> {\n-        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        attrs.extend(iattrs);\n-        Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::Loop(body, opt_label), attrs))\n+    fn parse_loop_expr(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n+        let (attrs, body) = self.parse_inner_attrs_and_block()?;\n+        Ok(self.mk_expr_with_attrs(\n+            lo.to(self.prev_token.span),\n+            ExprKind::Loop(body, opt_label),\n+            attrs,\n+        ))\n     }\n \n     pub(crate) fn eat_label(&mut self) -> Option<Label> {\n@@ -2574,7 +2520,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `match ... { ... }` expression (`match` token already eaten).\n-    fn parse_match_expr(&mut self, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_match_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let match_span = self.prev_token.span;\n         let lo = self.prev_token.span;\n         let scrutinee = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n@@ -2594,7 +2540,7 @@ impl<'a> Parser<'a> {\n                 return Err(e);\n             }\n         }\n-        attrs.extend(self.parse_inner_attributes()?);\n+        let attrs = self.parse_inner_attributes()?;\n \n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::CloseDelim(Delimiter::Brace) {\n@@ -2608,13 +2554,17 @@ impl<'a> Parser<'a> {\n                     if self.token == token::CloseDelim(Delimiter::Brace) {\n                         self.bump();\n                     }\n-                    return Ok(self.mk_expr(span, ExprKind::Match(scrutinee, arms), attrs));\n+                    return Ok(self.mk_expr_with_attrs(\n+                        span,\n+                        ExprKind::Match(scrutinee, arms),\n+                        attrs,\n+                    ));\n                 }\n             }\n         }\n         let hi = self.token.span;\n         self.bump();\n-        Ok(self.mk_expr(lo.to(hi), ExprKind::Match(scrutinee, arms), attrs))\n+        Ok(self.mk_expr_with_attrs(lo.to(hi), ExprKind::Match(scrutinee, arms), attrs))\n     }\n \n     /// Attempt to recover from match arm body with statements and no surrounding braces.\n@@ -2874,9 +2824,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `try {...}` expression (`try` token already eaten).\n-    fn parse_try_block(&mut self, span_lo: Span, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n-        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        attrs.extend(iattrs);\n+    fn parse_try_block(&mut self, span_lo: Span) -> PResult<'a, P<Expr>> {\n+        let (attrs, body) = self.parse_inner_attrs_and_block()?;\n         if self.eat_keyword(kw::Catch) {\n             let mut error = self.struct_span_err(\n                 self.prev_token.span,\n@@ -2888,7 +2837,7 @@ impl<'a> Parser<'a> {\n         } else {\n             let span = span_lo.to(body.span);\n             self.sess.gated_spans.gate(sym::try_blocks, span);\n-            Ok(self.mk_expr(span, ExprKind::TryBlock(body), attrs))\n+            Ok(self.mk_expr_with_attrs(span, ExprKind::TryBlock(body), attrs))\n         }\n     }\n \n@@ -2910,14 +2859,13 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an `async move? {...}` expression.\n-    fn parse_async_block(&mut self, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_async_block(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         self.expect_keyword(kw::Async)?;\n         let capture_clause = self.parse_capture_clause()?;\n-        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        attrs.extend(iattrs);\n+        let (attrs, body) = self.parse_inner_attrs_and_block()?;\n         let kind = ExprKind::Async(capture_clause, DUMMY_NODE_ID, body);\n-        Ok(self.mk_expr(lo.to(self.prev_token.span), kind, attrs))\n+        Ok(self.mk_expr_with_attrs(lo.to(self.prev_token.span), kind, attrs))\n     }\n \n     fn is_async_block(&self) -> bool {\n@@ -2951,14 +2899,13 @@ impl<'a> Parser<'a> {\n         &mut self,\n         qself: Option<&ast::QSelf>,\n         path: &ast::Path,\n-        attrs: &AttrVec,\n     ) -> Option<PResult<'a, P<Expr>>> {\n         let struct_allowed = !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n         if struct_allowed || self.is_certainly_not_a_block() {\n             if let Err(err) = self.expect(&token::OpenDelim(Delimiter::Brace)) {\n                 return Some(Err(err));\n             }\n-            let expr = self.parse_struct_expr(qself.cloned(), path.clone(), attrs.clone(), true);\n+            let expr = self.parse_struct_expr(qself.cloned(), path.clone(), true);\n             if let (Ok(expr), false) = (&expr, struct_allowed) {\n                 // This is a struct literal, but we don't can't accept them here.\n                 self.error_struct_lit_not_allowed_here(path.span, expr.span);\n@@ -3095,7 +3042,6 @@ impl<'a> Parser<'a> {\n         &mut self,\n         qself: Option<ast::QSelf>,\n         pth: ast::Path,\n-        attrs: AttrVec,\n         recover: bool,\n     ) -> PResult<'a, P<Expr>> {\n         let lo = pth.span;\n@@ -3108,7 +3054,7 @@ impl<'a> Parser<'a> {\n         } else {\n             ExprKind::Struct(P(ast::StructExpr { qself, path: pth, fields, rest: base }))\n         };\n-        Ok(self.mk_expr(span, expr, attrs))\n+        Ok(self.mk_expr(span, expr))\n     }\n \n     /// Use in case of error after field-looking code: `S { foo: () with a }`.\n@@ -3163,7 +3109,7 @@ impl<'a> Parser<'a> {\n                 // Mimic `x: x` for the `x` field shorthand.\n                 let ident = this.parse_ident_common(false)?;\n                 let path = ast::Path::from_ident(ident);\n-                (ident, this.mk_expr(ident.span, ExprKind::Path(None, path), AttrVec::new()))\n+                (ident, this.mk_expr(ident.span, ExprKind::Path(None, path)))\n             } else {\n                 let ident = this.parse_field_name()?;\n                 this.error_on_eq_field_init(ident);\n@@ -3268,17 +3214,25 @@ impl<'a> Parser<'a> {\n \n     fn mk_await_expr(&mut self, self_arg: P<Expr>, lo: Span) -> P<Expr> {\n         let span = lo.to(self.prev_token.span);\n-        let await_expr = self.mk_expr(span, ExprKind::Await(self_arg), AttrVec::new());\n+        let await_expr = self.mk_expr(span, ExprKind::Await(self_arg));\n         self.recover_from_await_method_call();\n         await_expr\n     }\n \n-    pub(crate) fn mk_expr(&self, span: Span, kind: ExprKind, attrs: AttrVec) -> P<Expr> {\n-        P(Expr { kind, span, attrs, id: DUMMY_NODE_ID, tokens: None })\n+    pub(crate) fn mk_expr_with_attrs<A>(&self, span: Span, kind: ExprKind, attrs: A) -> P<Expr>\n+    where\n+        A: Into<AttrVec>,\n+    {\n+        P(Expr { kind, span, attrs: attrs.into(), id: DUMMY_NODE_ID, tokens: None })\n+    }\n+\n+    // njn: rename\n+    pub(crate) fn mk_expr(&self, span: Span, kind: ExprKind) -> P<Expr> {\n+        P(Expr { kind, span, attrs: AttrVec::new(), id: DUMMY_NODE_ID, tokens: None })\n     }\n \n     pub(super) fn mk_expr_err(&self, span: Span) -> P<Expr> {\n-        self.mk_expr(span, ExprKind::Err, AttrVec::new())\n+        self.mk_expr(span, ExprKind::Err)\n     }\n \n     /// Create expression span ensuring the span of the parent node"}, {"sha": "d61da7b6cc00def1abf8f54f705e2a173d7fa323", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ef04795681837153df7613192305a2ddbf13497/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef04795681837153df7613192305a2ddbf13497/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=2ef04795681837153df7613192305a2ddbf13497", "patch": "@@ -1116,10 +1116,14 @@ impl<'a> Parser<'a> {\n         let (attrs, blk) = self.parse_inner_attrs_and_block()?;\n         let anon_const = AnonConst {\n             id: DUMMY_NODE_ID,\n-            value: self.mk_expr(blk.span, ExprKind::Block(blk, None), AttrVec::new()),\n+            value: self.mk_expr(blk.span, ExprKind::Block(blk, None)),\n         };\n         let blk_span = anon_const.value.span;\n-        Ok(self.mk_expr(span.to(blk_span), ExprKind::ConstBlock(anon_const), AttrVec::from(attrs)))\n+        Ok(self.mk_expr_with_attrs(\n+            span.to(blk_span),\n+            ExprKind::ConstBlock(anon_const),\n+            AttrVec::from(attrs),\n+        ))\n     }\n \n     /// Parses mutability (`mut` or nothing)."}, {"sha": "98c974420eb3175ae8ffc3071cdb8bad4c7ca3bb", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ef04795681837153df7613192305a2ddbf13497/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef04795681837153df7613192305a2ddbf13497/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=2ef04795681837153df7613192305a2ddbf13497", "patch": "@@ -4,8 +4,8 @@ use rustc_ast::mut_visit::{noop_visit_pat, MutVisitor};\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter};\n use rustc_ast::{\n-    self as ast, AttrVec, Attribute, BindingMode, Expr, ExprKind, MacCall, Mutability, Pat,\n-    PatField, PatKind, Path, QSelf, RangeEnd, RangeSyntax,\n+    self as ast, Attribute, BindingMode, Expr, ExprKind, MacCall, Mutability, Pat, PatField,\n+    PatKind, Path, QSelf, RangeEnd, RangeSyntax,\n };\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult};\n@@ -385,7 +385,7 @@ impl<'a> Parser<'a> {\n             if qself.is_none() && self.check(&token::Not) {\n                 self.parse_pat_mac_invoc(path)?\n             } else if let Some(form) = self.parse_range_end() {\n-                let begin = self.mk_expr(span, ExprKind::Path(qself, path), AttrVec::new());\n+                let begin = self.mk_expr(span, ExprKind::Path(qself, path));\n                 self.parse_pat_range_begin_with(begin, form)?\n             } else if self.check(&token::OpenDelim(Delimiter::Brace)) {\n                 self.parse_pat_struct(qself, path)?\n@@ -807,7 +807,7 @@ impl<'a> Parser<'a> {\n                 (None, self.parse_path(PathStyle::Expr)?)\n             };\n             let hi = self.prev_token.span;\n-            Ok(self.mk_expr(lo.to(hi), ExprKind::Path(qself, path), AttrVec::new()))\n+            Ok(self.mk_expr(lo.to(hi), ExprKind::Path(qself, path)))\n         } else {\n             self.parse_literal_maybe_minus()\n         }"}, {"sha": "8332c171a9cbb6e71b2b4e4a09c7a69186ad8447", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2ef04795681837153df7613192305a2ddbf13497/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef04795681837153df7613192305a2ddbf13497/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=2ef04795681837153df7613192305a2ddbf13497", "patch": "@@ -652,12 +652,7 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_const_arg(&mut self) -> PResult<'a, AnonConst> {\n         // Parse const argument.\n         let value = if let token::OpenDelim(Delimiter::Brace) = self.token.kind {\n-            self.parse_block_expr(\n-                None,\n-                self.token.span,\n-                BlockCheckMode::Default,\n-                ast::AttrVec::new(),\n-            )?\n+            self.parse_block_expr(None, self.token.span, BlockCheckMode::Default)?\n         } else {\n             self.handle_unambiguous_unbraced_const_arg()?\n         };"}, {"sha": "89b5a8a9556886b29c9856f0242127ef6bb0fded", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ef04795681837153df7613192305a2ddbf13497/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef04795681837153df7613192305a2ddbf13497/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=2ef04795681837153df7613192305a2ddbf13497", "patch": "@@ -130,10 +130,10 @@ impl<'a> Parser<'a> {\n             }\n \n             let expr = if this.eat(&token::OpenDelim(Delimiter::Brace)) {\n-                this.parse_struct_expr(None, path, AttrVec::new(), true)?\n+                this.parse_struct_expr(None, path, true)?\n             } else {\n                 let hi = this.prev_token.span;\n-                this.mk_expr(lo.to(hi), ExprKind::Path(None, path), AttrVec::new())\n+                this.mk_expr(lo.to(hi), ExprKind::Path(None, path))\n             };\n \n             let expr = this.with_res(Restrictions::STMT_EXPR, |this| {\n@@ -179,7 +179,7 @@ impl<'a> Parser<'a> {\n             StmtKind::MacCall(P(MacCallStmt { mac, style, attrs, tokens: None }))\n         } else {\n             // Since none of the above applied, this is an expression statement macro.\n-            let e = self.mk_expr(lo.to(hi), ExprKind::MacCall(mac), AttrVec::new());\n+            let e = self.mk_expr(lo.to(hi), ExprKind::MacCall(mac));\n             let e = self.maybe_recover_from_bad_qpath(e)?;\n             let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n             let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;"}]}