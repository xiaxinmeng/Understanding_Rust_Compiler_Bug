{"sha": "ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMmM1ZmYwMjQxYmRkMDkwYWYxMWE3NDU2NmJkMDBmMDNhZThhZTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-16T08:15:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-16T08:15:23Z"}, "message": "Auto merge of #30206 - petrochenkov:newdepr, r=brson\n\nCloses https://github.com/rust-lang/rust/issues/29935\n\nThe attributes `deprecated` and `rustc_deprecated` are completely independent in this implementation and it leads to some noticeable code duplication. Representing `deprecated` as\n```\nStability {\n    level: Stable { since: \"\" },\n    feature: \"\",\n    depr: Some(Deprecation),\n}\n```\nor, contrariwise, splitting rustc_deprecation from stability makes most of the duplication go away.\nI can do this refactoring, but before doing it I must be sure, that further divergence of `deprecated` and `rustc_deprecated` is certainly not a goal.\n\ncc @llogiq", "tree": {"sha": "780d1609c300fedd2dd9c7af17a0366d185c61aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/780d1609c300fedd2dd9c7af17a0366d185c61aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "html_url": "https://github.com/rust-lang/rust/commit/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ace0a46de9b47cfa93c4e906805455b221e2881", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ace0a46de9b47cfa93c4e906805455b221e2881", "html_url": "https://github.com/rust-lang/rust/commit/9ace0a46de9b47cfa93c4e906805455b221e2881"}, {"sha": "67a978411a2009093bb40c4f1320a08d2a28b6c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/67a978411a2009093bb40c4f1320a08d2a28b6c7", "html_url": "https://github.com/rust-lang/rust/commit/67a978411a2009093bb40c4f1320a08d2a28b6c7"}], "stats": {"total": 1140, "additions": 1003, "deletions": 137}, "files": [{"sha": "a20d25711521116d9fcd2bc9912a766d6026f88f", "filename": "src/doc/reference.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -2390,6 +2390,8 @@ The currently implemented features of the reference compiler are:\n * - `stmt_expr_attributes` - Allows attributes on expressions and\n                              non-item statements.\n \n+* - `deprecated` - Allows using the `#[deprecated]` attribute.\n+\n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about `#![feature]` directives which enabled\n the new feature (because the directive is no longer necessary). However, if a"}, {"sha": "2c3b89bf2fbb2ffa31e77b6ae6c2fc9403c47b72", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -135,6 +135,7 @@ pub enum FoundAst<'ast> {\n pub trait CrateStore<'tcx> : Any {\n     // item info\n     fn stability(&self, def: DefId) -> Option<attr::Stability>;\n+    fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>;\n     fn closure_kind(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId)\n                     -> ty::ClosureKind;\n     fn closure_ty(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId)\n@@ -292,6 +293,7 @@ pub struct DummyCrateStore;\n impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // item info\n     fn stability(&self, def: DefId) -> Option<attr::Stability> { unimplemented!() }\n+    fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { unimplemented!() }\n     fn closure_kind(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId)\n                     -> ty::ClosureKind  { unimplemented!() }\n     fn closure_ty(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId)"}, {"sha": "31158901775f35dc911a066aec9a29ebd05e82fa", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 92, "deletions": 66, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -25,7 +25,7 @@ use syntax::codemap::{Span, DUMMY_SP};\n use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax::attr::{self, Stability, AttrMetaMethods};\n+use syntax::attr::{self, Stability, Deprecation, AttrMetaMethods};\n use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n \n use rustc_front::hir;\n@@ -61,7 +61,8 @@ enum AnnotationKind {\n pub struct Index<'tcx> {\n     /// This is mostly a cache, except the stabilities of local items\n     /// are filled by the annotator.\n-    map: DefIdMap<Option<&'tcx Stability>>,\n+    stab_map: DefIdMap<Option<&'tcx Stability>>,\n+    depr_map: DefIdMap<Option<Deprecation>>,\n \n     /// Maps for each crate whether it is part of the staged API.\n     staged_api: FnvHashMap<ast::CrateNum, bool>\n@@ -71,7 +72,8 @@ pub struct Index<'tcx> {\n struct Annotator<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     index: &'a mut Index<'tcx>,\n-    parent: Option<&'tcx Stability>,\n+    parent_stab: Option<&'tcx Stability>,\n+    parent_depr: Option<Deprecation>,\n     access_levels: &'a AccessLevels,\n     in_trait_impl: bool,\n     in_enum: bool,\n@@ -86,31 +88,35 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n     {\n         if self.index.staged_api[&LOCAL_CRATE] && self.tcx.sess.features.borrow().staged_api {\n             debug!(\"annotate(id = {:?}, attrs = {:?})\", id, attrs);\n+            if let Some(..) = attr::find_deprecation(self.tcx.sess.diagnostic(), attrs, item_sp) {\n+                self.tcx.sess.span_err(item_sp, \"`#[deprecated]` cannot be used in staged api, \\\n+                                                 use `#[rustc_deprecated]` instead\");\n+            }\n             if let Some(mut stab) = attr::find_stability(self.tcx.sess.diagnostic(),\n                                                          attrs, item_sp) {\n                 // Error if prohibited, or can't inherit anything from a container\n                 if kind == AnnotationKind::Prohibited ||\n                    (kind == AnnotationKind::Container &&\n                     stab.level.is_stable() &&\n-                    stab.depr.is_none()) {\n+                    stab.rustc_depr.is_none()) {\n                     self.tcx.sess.span_err(item_sp, \"This stability annotation is useless\");\n                 }\n \n                 debug!(\"annotate: found {:?}\", stab);\n                 // If parent is deprecated and we're not, inherit this by merging\n                 // deprecated_since and its reason.\n-                if let Some(parent_stab) = self.parent {\n-                    if parent_stab.depr.is_some() && stab.depr.is_none() {\n-                        stab.depr = parent_stab.depr.clone()\n+                if let Some(parent_stab) = self.parent_stab {\n+                    if parent_stab.rustc_depr.is_some() && stab.rustc_depr.is_none() {\n+                        stab.rustc_depr = parent_stab.rustc_depr.clone()\n                     }\n                 }\n \n                 let stab = self.tcx.intern_stability(stab);\n \n                 // Check if deprecated_since < stable_since. If it is,\n                 // this is *almost surely* an accident.\n-                if let (&Some(attr::Deprecation {since: ref dep_since, ..}),\n-                        &attr::Stable {since: ref stab_since}) = (&stab.depr, &stab.level) {\n+                if let (&Some(attr::RustcDeprecation {since: ref dep_since, ..}),\n+                        &attr::Stable {since: ref stab_since}) = (&stab.rustc_depr, &stab.level) {\n                     // Explicit version of iter::order::lt to handle parse errors properly\n                     for (dep_v, stab_v) in dep_since.split(\".\").zip(stab_since.split(\".\")) {\n                         if let (Ok(dep_v), Ok(stab_v)) = (dep_v.parse::<u64>(), stab_v.parse()) {\n@@ -134,20 +140,20 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 }\n \n                 let def_id = self.tcx.map.local_def_id(id);\n-                self.index.map.insert(def_id, Some(stab));\n+                self.index.stab_map.insert(def_id, Some(stab));\n \n-                let parent = replace(&mut self.parent, Some(stab));\n+                let orig_parent_stab = replace(&mut self.parent_stab, Some(stab));\n                 visit_children(self);\n-                self.parent = parent;\n+                self.parent_stab = orig_parent_stab;\n             } else {\n-                debug!(\"annotate: not found, parent = {:?}\", self.parent);\n+                debug!(\"annotate: not found, parent = {:?}\", self.parent_stab);\n                 let mut is_error = kind == AnnotationKind::Required &&\n                                    self.access_levels.is_reachable(id) &&\n                                    !self.tcx.sess.opts.test;\n-                if let Some(stab) = self.parent {\n+                if let Some(stab) = self.parent_stab {\n                     if stab.level.is_unstable() {\n                         let def_id = self.tcx.map.local_def_id(id);\n-                        self.index.map.insert(def_id, Some(stab));\n+                        self.index.stab_map.insert(def_id, Some(stab));\n                         is_error = false;\n                     }\n                 }\n@@ -167,7 +173,26 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                                                          outside of the standard library\");\n                 }\n             }\n-            visit_children(self);\n+\n+            if let Some(depr) = attr::find_deprecation(self.tcx.sess.diagnostic(), attrs, item_sp) {\n+                if kind == AnnotationKind::Prohibited {\n+                    self.tcx.sess.span_err(item_sp, \"This deprecation annotation is useless\");\n+                }\n+\n+                // `Deprecation` is just two pointers, no need to intern it\n+                let def_id = self.tcx.map.local_def_id(id);\n+                self.index.depr_map.insert(def_id, Some(depr.clone()));\n+\n+                let orig_parent_depr = replace(&mut self.parent_depr, Some(depr));\n+                visit_children(self);\n+                self.parent_depr = orig_parent_depr;\n+            } else if let Some(depr) = self.parent_depr.clone() {\n+                let def_id = self.tcx.map.local_def_id(id);\n+                self.index.depr_map.insert(def_id, Some(depr));\n+                visit_children(self);\n+            } else {\n+                visit_children(self);\n+            }\n         }\n     }\n }\n@@ -269,7 +294,8 @@ impl<'tcx> Index<'tcx> {\n         let mut annotator = Annotator {\n             tcx: tcx,\n             index: self,\n-            parent: None,\n+            parent_stab: None,\n+            parent_depr: None,\n             access_levels: access_levels,\n             in_trait_impl: false,\n             in_enum: false,\n@@ -291,7 +317,8 @@ impl<'tcx> Index<'tcx> {\n         staged_api.insert(LOCAL_CRATE, is_staged_api);\n         Index {\n             staged_api: staged_api,\n-            map: DefIdMap(),\n+            stab_map: DefIdMap(),\n+            depr_map: DefIdMap(),\n         }\n     }\n }\n@@ -327,7 +354,11 @@ struct Checker<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Checker<'a, 'tcx> {\n-    fn check(&mut self, id: DefId, span: Span, stab: &Option<&Stability>) {\n+    fn check(&mut self, id: DefId, span: Span,\n+             stab: &Option<&Stability>, _depr: &Option<Deprecation>) {\n+        if !is_staged_api(self.tcx, id) {\n+            return;\n+        }\n         // Only the cross-crate scenario matters when checking unstable APIs\n         let cross_crate = !id.is_local();\n         if !cross_crate {\n@@ -395,31 +426,31 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n         if item.span == DUMMY_SP && item.name.as_str() == \"__test\" { return }\n \n         check_item(self.tcx, item, true,\n-                   &mut |id, sp, stab| self.check(id, sp, stab));\n+                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_item(self, item);\n     }\n \n     fn visit_expr(&mut self, ex: &hir::Expr) {\n         check_expr(self.tcx, ex,\n-                   &mut |id, sp, stab| self.check(id, sp, stab));\n+                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_expr(self, ex);\n     }\n \n     fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n         check_path(self.tcx, path, id,\n-                   &mut |id, sp, stab| self.check(id, sp, stab));\n+                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_path(self, path)\n     }\n \n     fn visit_path_list_item(&mut self, prefix: &hir::Path, item: &hir::PathListItem) {\n         check_path_list_item(self.tcx, item,\n-                   &mut |id, sp, stab| self.check(id, sp, stab));\n+                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_path_list_item(self, prefix, item)\n     }\n \n     fn visit_pat(&mut self, pat: &hir::Pat) {\n         check_pat(self.tcx, pat,\n-                  &mut |id, sp, stab| self.check(id, sp, stab));\n+                  &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_pat(self, pat)\n     }\n \n@@ -441,7 +472,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n \n /// Helper for discovering nodes to check for stability\n pub fn check_item(tcx: &ty::ctxt, item: &hir::Item, warn_about_defns: bool,\n-                  cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n+                  cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n     match item.node {\n         hir::ItemExternCrate(_) => {\n             // compiler-generated `extern crate` items have a dummy span.\n@@ -478,7 +509,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &hir::Item, warn_about_defns: bool,\n \n /// Helper for discovering nodes to check for stability\n pub fn check_expr(tcx: &ty::ctxt, e: &hir::Expr,\n-                  cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n+                  cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n     let span;\n     let id = match e.node {\n         hir::ExprMethodCall(i, _, _) => {\n@@ -539,7 +570,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &hir::Expr,\n }\n \n pub fn check_path(tcx: &ty::ctxt, path: &hir::Path, id: ast::NodeId,\n-                  cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n+                  cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n     match tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n         Some(def::DefPrimTy(..)) => {}\n         Some(def::DefSelfTy(..)) => {}\n@@ -551,7 +582,7 @@ pub fn check_path(tcx: &ty::ctxt, path: &hir::Path, id: ast::NodeId,\n }\n \n pub fn check_path_list_item(tcx: &ty::ctxt, item: &hir::PathListItem,\n-                  cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n+                  cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n     match tcx.def_map.borrow().get(&item.node.id()).map(|d| d.full_def()) {\n         Some(def::DefPrimTy(..)) => {}\n         Some(def) => {\n@@ -562,7 +593,7 @@ pub fn check_path_list_item(tcx: &ty::ctxt, item: &hir::PathListItem,\n }\n \n pub fn check_pat(tcx: &ty::ctxt, pat: &hir::Pat,\n-                 cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n+                 cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n@@ -591,21 +622,21 @@ pub fn check_pat(tcx: &ty::ctxt, pat: &hir::Pat,\n }\n \n fn maybe_do_stability_check(tcx: &ty::ctxt, id: DefId, span: Span,\n-                            cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n-    if !is_staged_api(tcx, id) {\n-        debug!(\"maybe_do_stability_check: \\\n-                skipping id={:?} since it is not staged_api\", id);\n-        return;\n-    }\n+                            cb: &mut FnMut(DefId, Span,\n+                                           &Option<&Stability>, &Option<Deprecation>)) {\n     if is_internal(tcx, span) {\n         debug!(\"maybe_do_stability_check: \\\n                 skipping span={:?} since it is internal\", span);\n         return;\n     }\n-    let ref stability = lookup(tcx, id);\n+    let (stability, deprecation) = if is_staged_api(tcx, id) {\n+        (lookup_stability(tcx, id), None)\n+    } else {\n+        (None, lookup_deprecation(tcx, id))\n+    };\n     debug!(\"maybe_do_stability_check: \\\n             inspecting id={:?} span={:?} of stability={:?}\", id, span, stability);\n-    cb(id, span, stability);\n+    cb(id, span, &stability, &deprecation);\n }\n \n fn is_internal(tcx: &ty::ctxt, span: Span) -> bool {\n@@ -627,47 +658,42 @@ fn is_staged_api(tcx: &ty::ctxt, id: DefId) -> bool {\n \n /// Lookup the stability for a node, loading external crate\n /// metadata as necessary.\n-pub fn lookup<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stability> {\n-    if let Some(st) = tcx.stability.borrow().map.get(&id) {\n+pub fn lookup_stability<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stability> {\n+    if let Some(st) = tcx.stability.borrow().stab_map.get(&id) {\n         return *st;\n     }\n \n-    let st = lookup_uncached(tcx, id);\n-    tcx.stability.borrow_mut().map.insert(id, st);\n+    let st = lookup_stability_uncached(tcx, id);\n+    tcx.stability.borrow_mut().stab_map.insert(id, st);\n     st\n }\n \n-fn lookup_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stability> {\n-    debug!(\"lookup(id={:?})\", id);\n-\n-    // is this definition the implementation of a trait method?\n-    match tcx.trait_item_of_item(id) {\n-        Some(ty::MethodTraitItemId(trait_method_id)) if trait_method_id != id => {\n-            debug!(\"lookup: trait_method_id={:?}\", trait_method_id);\n-            return lookup(tcx, trait_method_id)\n-        }\n-        _ => {}\n+pub fn lookup_deprecation<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<Deprecation> {\n+    if let Some(depr) = tcx.stability.borrow().depr_map.get(&id) {\n+        return depr.clone();\n     }\n \n-    let item_stab = if id.is_local() {\n+    let depr = lookup_deprecation_uncached(tcx, id);\n+    tcx.stability.borrow_mut().depr_map.insert(id, depr.clone());\n+    depr\n+}\n+\n+fn lookup_stability_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stability> {\n+    debug!(\"lookup(id={:?})\", id);\n+    if id.is_local() {\n         None // The stability cache is filled partially lazily\n     } else {\n         tcx.sess.cstore.stability(id).map(|st| tcx.intern_stability(st))\n-    };\n-\n-    item_stab.or_else(|| {\n-        if tcx.is_impl(id) {\n-            if let Some(trait_id) = tcx.trait_id_of_impl(id) {\n-                // FIXME (#18969): for the time being, simply use the\n-                // stability of the trait to determine the stability of any\n-                // unmarked impls for it. See FIXME above for more details.\n+    }\n+}\n \n-                debug!(\"lookup: trait_id={:?}\", trait_id);\n-                return lookup(tcx, trait_id);\n-            }\n-        }\n-        None\n-    })\n+fn lookup_deprecation_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<Deprecation> {\n+    debug!(\"lookup(id={:?})\", id);\n+    if id.is_local() {\n+        None // The stability cache is filled partially lazily\n+    } else {\n+        tcx.sess.cstore.deprecation(id)\n+    }\n }\n \n /// Given the list of enabled features that were not language features (i.e. that"}, {"sha": "e403e6d067af1725254b8e122ea6cecde67e3efc", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -575,74 +575,71 @@ impl LateLintPass for MissingDebugImplementations {\n declare_lint! {\n     DEPRECATED,\n     Warn,\n-    \"detects use of #[rustc_deprecated] items\"\n+    \"detects use of deprecated items\"\n }\n \n-/// Checks for use of items with `#[rustc_deprecated]` attributes\n+/// Checks for use of items with `#[deprecated]` or `#[rustc_deprecated]` attributes\n #[derive(Copy, Clone)]\n-pub struct Stability;\n+pub struct Deprecated;\n \n-impl Stability {\n-    fn lint(&self, cx: &LateContext, _id: DefId,\n-            span: Span, stability: &Option<&attr::Stability>) {\n+impl Deprecated {\n+    fn lint(&self, cx: &LateContext, _id: DefId, span: Span,\n+            stability: &Option<&attr::Stability>, deprecation: &Option<attr::Deprecation>) {\n         // Deprecated attributes apply in-crate and cross-crate.\n-        let (lint, label) = match *stability {\n-            Some(&attr::Stability { depr: Some(_), .. }) =>\n-                (DEPRECATED, \"deprecated\"),\n-            _ => return\n-        };\n-\n-        output(cx, span, stability, lint, label);\n+        if let Some(&attr::Stability{rustc_depr: Some(attr::RustcDeprecation{ref reason, ..}), ..})\n+                = *stability {\n+            output(cx, DEPRECATED, span, Some(&reason))\n+        } else if let Some(attr::Deprecation{ref note, ..}) = *deprecation {\n+            output(cx, DEPRECATED, span, note.as_ref().map(|x| &**x))\n+        }\n \n-        fn output(cx: &LateContext, span: Span, stability: &Option<&attr::Stability>,\n-                  lint: &'static Lint, label: &'static str) {\n-            let msg = match *stability {\n-                Some(&attr::Stability {depr: Some(attr::Deprecation {ref reason, ..}), ..}) => {\n-                    format!(\"use of {} item: {}\", label, reason)\n-                }\n-                _ => format!(\"use of {} item\", label)\n+        fn output(cx: &LateContext, lint: &'static Lint, span: Span, note: Option<&str>) {\n+            let msg = if let Some(note) = note {\n+                format!(\"use of deprecated item: {}\", note)\n+            } else {\n+                format!(\"use of deprecated item\")\n             };\n \n-            cx.span_lint(lint, span, &msg[..]);\n+            cx.span_lint(lint, span, &msg);\n         }\n     }\n }\n \n-impl LintPass for Stability {\n+impl LintPass for Deprecated {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(DEPRECATED)\n     }\n }\n \n-impl LateLintPass for Stability {\n+impl LateLintPass for Deprecated {\n     fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         stability::check_item(cx.tcx, item, false,\n-                              &mut |id, sp, stab|\n-                                self.lint(cx, id, sp, &stab));\n+                              &mut |id, sp, stab, depr|\n+                                self.lint(cx, id, sp, &stab, &depr));\n     }\n \n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         stability::check_expr(cx.tcx, e,\n-                              &mut |id, sp, stab|\n-                                self.lint(cx, id, sp, &stab));\n+                              &mut |id, sp, stab, depr|\n+                                self.lint(cx, id, sp, &stab, &depr));\n     }\n \n     fn check_path(&mut self, cx: &LateContext, path: &hir::Path, id: ast::NodeId) {\n         stability::check_path(cx.tcx, path, id,\n-                              &mut |id, sp, stab|\n-                                self.lint(cx, id, sp, &stab));\n+                              &mut |id, sp, stab, depr|\n+                                self.lint(cx, id, sp, &stab, &depr));\n     }\n \n     fn check_path_list_item(&mut self, cx: &LateContext, item: &hir::PathListItem) {\n         stability::check_path_list_item(cx.tcx, item,\n-                                         &mut |id, sp, stab|\n-                                           self.lint(cx, id, sp, &stab));\n+                                         &mut |id, sp, stab, depr|\n+                                           self.lint(cx, id, sp, &stab, &depr));\n     }\n \n     fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n         stability::check_pat(cx.tcx, pat,\n-                             &mut |id, sp, stab|\n-                                self.lint(cx, id, sp, &stab));\n+                             &mut |id, sp, stab, depr|\n+                                self.lint(cx, id, sp, &stab, &depr));\n     }\n }\n "}, {"sha": "69fd569c8d48444a4d4b87b4ce9fbcec19d0eed4", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -124,7 +124,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                  UnusedAllocation,\n                  MissingCopyImplementations,\n                  UnstableFeatures,\n-                 Stability,\n+                 Deprecated,\n                  UnconditionalRecursion,\n                  InvalidNoMangleItems,\n                  PluginAsLibrary,"}, {"sha": "479ab7592784795a765e46f7ad4e32ccf4efc880", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -237,6 +237,8 @@ pub const tag_impl_coerce_unsized_kind: usize = 0xa5;\n \n pub const tag_items_data_item_constness: usize = 0xa6;\n \n+pub const tag_items_data_item_deprecation: usize = 0xa7;\n+\n pub const tag_rustc_version: usize = 0x10f;\n pub fn rustc_version() -> String {\n     format!("}, {"sha": "ecbc84023309105f9953e0a7babf1a36c43e79d5", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -42,6 +42,12 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_stability(&*cdata, def.index)\n     }\n \n+    fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_deprecation(&*cdata, def.index)\n+    }\n+\n     fn closure_kind(&self, _tcx: &ty::ctxt<'tcx>, def_id: DefId) -> ty::ClosureKind\n     {\n         assert!(!def_id.is_local());"}, {"sha": "357158c24bacda8809525246b087e7af956e3b31", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -526,6 +526,14 @@ pub fn get_stability(cdata: Cmd, id: DefIndex) -> Option<attr::Stability> {\n     })\n }\n \n+pub fn get_deprecation(cdata: Cmd, id: DefIndex) -> Option<attr::Deprecation> {\n+    let item = cdata.lookup_item(id);\n+    reader::maybe_get_doc(item, tag_items_data_item_deprecation).map(|doc| {\n+        let mut decoder = reader::Decoder::new(doc);\n+        Decodable::decode(&mut decoder).unwrap()\n+    })\n+}\n+\n pub fn get_repr_attrs(cdata: Cmd, id: DefIndex) -> Vec<attr::ReprAttr> {\n     let item = cdata.lookup_item(id);\n     match reader::maybe_get_doc(item, tag_items_data_item_repr).map(|doc| {"}, {"sha": "888776eaa56105647b4846ec518241f41cf9f875", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -342,8 +342,10 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_attributes(rbml_w, &attrs);\n         encode_repr_attrs(rbml_w, ecx, &attrs);\n \n-        let stab = stability::lookup(ecx.tcx, vid);\n+        let stab = stability::lookup_stability(ecx.tcx, vid);\n+        let depr = stability::lookup_deprecation(ecx.tcx, vid);\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n \n         encode_struct_fields(rbml_w, variant);\n \n@@ -450,8 +452,10 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     encode_path(rbml_w, path.clone());\n     encode_visibility(rbml_w, vis);\n \n-    let stab = stability::lookup(ecx.tcx, ecx.tcx.map.local_def_id(id));\n+    let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(id));\n+    let depr = stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(id));\n     encode_stability(rbml_w, stab);\n+    encode_deprecation(rbml_w, depr);\n \n     // Encode the reexports of this module, if this module is public.\n     if vis == hir::Public {\n@@ -538,8 +542,10 @@ fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_bounds_and_type_for_item(rbml_w, ecx, index, id);\n     encode_def_id_and_key(ecx, rbml_w, field.did);\n \n-    let stab = stability::lookup(ecx.tcx, field.did);\n+    let stab = stability::lookup_stability(ecx.tcx, field.did);\n+    let depr = stability::lookup_deprecation(ecx.tcx, field.did);\n     encode_stability(rbml_w, stab);\n+    encode_deprecation(rbml_w, depr);\n \n     rbml_w.end_tag();\n }\n@@ -565,8 +571,10 @@ fn encode_info_for_struct_ctor<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_symbol(ecx, rbml_w, ctor_id);\n     }\n \n-    let stab = stability::lookup(ecx.tcx, ecx.tcx.map.local_def_id(ctor_id));\n+    let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(ctor_id));\n+    let depr= stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(ctor_id));\n     encode_stability(rbml_w, stab);\n+    encode_deprecation(rbml_w, depr);\n \n     // indicate that this is a tuple struct ctor, because downstream users will normally want\n     // the tuple struct definition, but without this there is no way for them to tell that\n@@ -700,8 +708,10 @@ fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_bounds_and_type_for_item(rbml_w, ecx, index,\n                                     ecx.local_id(associated_const.def_id));\n \n-    let stab = stability::lookup(ecx.tcx, associated_const.def_id);\n+    let stab = stability::lookup_stability(ecx.tcx, associated_const.def_id);\n+    let depr = stability::lookup_deprecation(ecx.tcx, associated_const.def_id);\n     encode_stability(rbml_w, stab);\n+    encode_deprecation(rbml_w, depr);\n \n     let elem = ast_map::PathName(associated_const.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem)));\n@@ -735,8 +745,10 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_item_sort(rbml_w, 'r');\n \n-    let stab = stability::lookup(ecx.tcx, m.def_id);\n+    let stab = stability::lookup_stability(ecx.tcx, m.def_id);\n+    let depr = stability::lookup_deprecation(ecx.tcx, m.def_id);\n     encode_stability(rbml_w, stab);\n+    encode_deprecation(rbml_w, depr);\n \n     let m_node_id = ecx.local_id(m.def_id);\n     encode_bounds_and_type_for_item(rbml_w, ecx, index, m_node_id);\n@@ -789,8 +801,10 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_item_sort(rbml_w, 't');\n \n-    let stab = stability::lookup(ecx.tcx, associated_type.def_id);\n+    let stab = stability::lookup_stability(ecx.tcx, associated_type.def_id);\n+    let depr = stability::lookup_deprecation(ecx.tcx, associated_type.def_id);\n     encode_stability(rbml_w, stab);\n+    encode_deprecation(rbml_w, depr);\n \n     let elem = ast_map::PathName(associated_type.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem)));\n@@ -891,6 +905,14 @@ fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<&attr::Stability>) {\n     });\n }\n \n+fn encode_deprecation(rbml_w: &mut Encoder, depr_opt: Option<attr::Deprecation>) {\n+    depr_opt.map(|depr| {\n+        rbml_w.start_tag(tag_items_data_item_deprecation);\n+        depr.encode(rbml_w).unwrap();\n+        rbml_w.end_tag();\n+    });\n+}\n+\n fn encode_xrefs<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                           rbml_w: &mut Encoder,\n                           xrefs: FnvHashMap<XRef<'tcx>, u32>)\n@@ -931,7 +953,8 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n            tcx.sess.codemap().span_to_string(item.span));\n \n     let def_id = ecx.tcx.map.local_def_id(item.id);\n-    let stab = stability::lookup(tcx, ecx.tcx.map.local_def_id(item.id));\n+    let stab = stability::lookup_stability(tcx, ecx.tcx.map.local_def_id(item.id));\n+    let depr = stability::lookup_deprecation(tcx, ecx.tcx.map.local_def_id(item.id));\n \n     match item.node {\n       hir::ItemStatic(_, m, _) => {\n@@ -949,6 +972,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         encode_attributes(rbml_w, &item.attrs);\n         rbml_w.end_tag();\n       }\n@@ -964,6 +988,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         rbml_w.end_tag();\n       }\n       hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n@@ -986,6 +1011,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_constness(rbml_w, constness);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         encode_method_argument_names(rbml_w, &**decl);\n         rbml_w.end_tag();\n       }\n@@ -1015,6 +1041,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         rbml_w.end_tag();\n       }\n       hir::ItemTy(..) => {\n@@ -1027,6 +1054,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         rbml_w.end_tag();\n       }\n       hir::ItemEnum(ref enum_definition, _) => {\n@@ -1051,6 +1079,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         rbml_w.end_tag();\n \n         encode_enum_variant_info(ecx,\n@@ -1077,6 +1106,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_attributes(rbml_w, &item.attrs);\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         encode_visibility(rbml_w, vis);\n         encode_repr_attrs(rbml_w, ecx, &item.attrs);\n \n@@ -1167,6 +1197,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         rbml_w.end_tag();\n \n         // Iterate down the trait items, emitting them. We rely on the\n@@ -1236,6 +1267,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_attributes(rbml_w, &item.attrs);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         for &method_def_id in tcx.trait_item_def_ids(def_id).iter() {\n             rbml_w.start_tag(tag_item_trait_item);\n             match method_def_id {\n@@ -1274,8 +1306,10 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n             encode_parent_item(rbml_w, def_id);\n \n-            let stab = stability::lookup(tcx, item_def_id.def_id());\n+            let stab = stability::lookup_stability(tcx, item_def_id.def_id());\n+            let depr = stability::lookup_deprecation(tcx, item_def_id.def_id());\n             encode_stability(rbml_w, stab);\n+            encode_deprecation(rbml_w, depr);\n \n             let trait_item_type =\n                 tcx.impl_or_trait_item(item_def_id.def_id());\n@@ -1407,8 +1441,10 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n         }\n         encode_attributes(rbml_w, &*nitem.attrs);\n-        let stab = stability::lookup(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n+        let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n+        let depr = stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         encode_symbol(ecx, rbml_w, nitem.id);\n         encode_method_argument_names(rbml_w, &*fndecl);\n       }\n@@ -1420,8 +1456,10 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, nitem.id);\n         encode_attributes(rbml_w, &*nitem.attrs);\n-        let stab = stability::lookup(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n+        let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n+        let depr = stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         encode_symbol(ecx, rbml_w, nitem.id);\n         encode_name(rbml_w, nitem.name);\n       }"}, {"sha": "c0f62cddb98bfe2e9c05c270cb1b30aa83649b1e", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -120,7 +120,8 @@ fn try_inline_def(cx: &DocContext, tcx: &ty::ctxt,\n         attrs: load_attrs(cx, tcx, did),\n         inner: inner,\n         visibility: Some(hir::Public),\n-        stability: stability::lookup(tcx, did).clean(cx),\n+        stability: stability::lookup_stability(tcx, did).clean(cx),\n+        deprecation: stability::lookup_deprecation(tcx, did).clean(cx),\n         def_id: did,\n     });\n     Some(ret)\n@@ -303,7 +304,8 @@ pub fn build_impl(cx: &DocContext,\n             name: None,\n             attrs: attrs,\n             visibility: Some(hir::Inherited),\n-            stability: stability::lookup(tcx, did).clean(cx),\n+            stability: stability::lookup_stability(tcx, did).clean(cx),\n+            deprecation: stability::lookup_deprecation(tcx, did).clean(cx),\n             def_id: did,\n         });\n     }\n@@ -333,7 +335,8 @@ pub fn build_impl(cx: &DocContext,\n                     source: clean::Span::empty(),\n                     attrs: vec![],\n                     visibility: None,\n-                    stability: stability::lookup(tcx, did).clean(cx),\n+                    stability: stability::lookup_stability(tcx, did).clean(cx),\n+                    deprecation: stability::lookup_deprecation(tcx, did).clean(cx),\n                     def_id: did\n                 })\n             }\n@@ -381,7 +384,8 @@ pub fn build_impl(cx: &DocContext,\n                     source: clean::Span::empty(),\n                     attrs: vec![],\n                     visibility: None,\n-                    stability: stability::lookup(tcx, did).clean(cx),\n+                    stability: stability::lookup_stability(tcx, did).clean(cx),\n+                    deprecation: stability::lookup_deprecation(tcx, did).clean(cx),\n                     def_id: did\n                 })\n             }\n@@ -414,7 +418,8 @@ pub fn build_impl(cx: &DocContext,\n         name: None,\n         attrs: attrs,\n         visibility: Some(hir::Inherited),\n-        stability: stability::lookup(tcx, did).clean(cx),\n+        stability: stability::lookup_stability(tcx, did).clean(cx),\n+        deprecation: stability::lookup_deprecation(tcx, did).clean(cx),\n         def_id: did,\n     });\n "}, {"sha": "52eeb781b31cccc7cfa22c13717444e5be31cb8f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 50, "deletions": 5, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -62,7 +62,11 @@ mod simplify;\n \n // extract the stability index for a node from tcx, if possible\n fn get_stability(cx: &DocContext, def_id: DefId) -> Option<Stability> {\n-    cx.tcx_opt().and_then(|tcx| stability::lookup(tcx, def_id)).clean(cx)\n+    cx.tcx_opt().and_then(|tcx| stability::lookup_stability(tcx, def_id)).clean(cx)\n+}\n+\n+fn get_deprecation(cx: &DocContext, def_id: DefId) -> Option<Deprecation> {\n+    cx.tcx_opt().and_then(|tcx| stability::lookup_deprecation(tcx, def_id)).clean(cx)\n }\n \n pub trait Clean<T> {\n@@ -188,6 +192,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n                     attrs: child.attrs.clone(),\n                     visibility: Some(hir::Public),\n                     stability: None,\n+                    deprecation: None,\n                     def_id: DefId::local(prim.to_def_index()),\n                     inner: PrimitiveItem(prim),\n                 });\n@@ -254,6 +259,7 @@ pub struct Item {\n     pub visibility: Option<Visibility>,\n     pub def_id: DefId,\n     pub stability: Option<Stability>,\n+    pub deprecation: Option<Deprecation>,\n }\n \n impl Item {\n@@ -417,6 +423,7 @@ impl Clean<Item> for doctree::Module {\n             source: whence.clean(cx),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n+            deprecation: self.depr.clean(cx),\n             def_id: cx.map.local_def_id(self.id),\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n@@ -1078,6 +1085,7 @@ impl Clean<Item> for doctree::Function {\n             source: self.whence.clean(cx),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n+            deprecation: self.depr.clean(cx),\n             def_id: cx.map.local_def_id(self.id),\n             inner: FunctionItem(Function {\n                 decl: self.decl.clean(cx),\n@@ -1204,6 +1212,7 @@ impl Clean<Item> for doctree::Trait {\n             def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n+            deprecation: self.depr.clean(cx),\n             inner: TraitItem(Trait {\n                 unsafety: self.unsafety,\n                 items: self.items.clean(cx),\n@@ -1254,6 +1263,7 @@ impl Clean<Item> for hir::TraitItem {\n             def_id: cx.map.local_def_id(self.id),\n             visibility: None,\n             stability: get_stability(cx, cx.map.local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.map.local_def_id(self.id)),\n             inner: inner\n         }\n     }\n@@ -1287,6 +1297,7 @@ impl Clean<Item> for hir::ImplItem {\n             def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: get_stability(cx, cx.map.local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.map.local_def_id(self.id)),\n             inner: inner\n         }\n     }\n@@ -1357,6 +1368,7 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n             name: Some(self.name.clean(cx)),\n             visibility: Some(hir::Inherited),\n             stability: get_stability(cx, self.def_id),\n+            deprecation: get_deprecation(cx, self.def_id),\n             def_id: self.def_id,\n             attrs: inline::load_attrs(cx, cx.tcx(), self.def_id),\n             source: Span::empty(),\n@@ -1715,6 +1727,7 @@ impl Clean<Item> for hir::StructField {\n             source: self.span.clean(cx),\n             visibility: Some(vis),\n             stability: get_stability(cx, cx.map.local_def_id(self.node.id)),\n+            deprecation: get_deprecation(cx, cx.map.local_def_id(self.node.id)),\n             def_id: cx.map.local_def_id(self.node.id),\n             inner: StructFieldItem(TypedStructField(self.node.ty.clean(cx))),\n         }\n@@ -1740,6 +1753,7 @@ impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n             source: Span::empty(),\n             visibility: Some(self.vis),\n             stability: get_stability(cx, self.did),\n+            deprecation: get_deprecation(cx, self.did),\n             def_id: self.did,\n             inner: StructFieldItem(TypedStructField(self.unsubst_ty().clean(cx))),\n         }\n@@ -1771,6 +1785,7 @@ impl Clean<Item> for doctree::Struct {\n             def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n+            deprecation: self.depr.clean(cx),\n             inner: StructItem(Struct {\n                 struct_type: self.struct_type,\n                 generics: self.generics.clean(cx),\n@@ -1817,6 +1832,7 @@ impl Clean<Item> for doctree::Enum {\n             def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n+            deprecation: self.depr.clean(cx),\n             inner: EnumItem(Enum {\n                 variants: self.variants.clean(cx),\n                 generics: self.generics.clean(cx),\n@@ -1839,6 +1855,7 @@ impl Clean<Item> for doctree::Variant {\n             source: self.whence.clean(cx),\n             visibility: None,\n             stability: self.stab.clean(cx),\n+            deprecation: self.depr.clean(cx),\n             def_id: cx.map.local_def_id(self.def.id()),\n             inner: VariantItem(Variant {\n                 kind: struct_def_to_variant_kind(&self.def, cx),\n@@ -1876,6 +1893,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n                             //        at the needed information here.\n                             def_id: self.did,\n                             stability: get_stability(cx, self.did),\n+                            deprecation: get_deprecation(cx, self.did),\n                             inner: StructFieldItem(\n                                 TypedStructField(field.unsubst_ty().clean(cx))\n                             )\n@@ -1892,6 +1910,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n             def_id: self.did,\n             inner: VariantItem(Variant { kind: kind }),\n             stability: get_stability(cx, self.did),\n+            deprecation: get_deprecation(cx, self.did),\n         }\n     }\n }\n@@ -2067,6 +2086,7 @@ impl Clean<Item> for doctree::Typedef {\n             def_id: cx.map.local_def_id(self.id.clone()),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n+            deprecation: self.depr.clean(cx),\n             inner: TypedefItem(Typedef {\n                 type_: self.ty.clean(cx),\n                 generics: self.gen.clean(cx),\n@@ -2118,6 +2138,7 @@ impl Clean<Item> for doctree::Static {\n             def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n+            deprecation: self.depr.clean(cx),\n             inner: StaticItem(Static {\n                 type_: self.type_.clean(cx),\n                 mutability: self.mutability.clean(cx),\n@@ -2142,6 +2163,7 @@ impl Clean<Item> for doctree::Constant {\n             def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n+            deprecation: self.depr.clean(cx),\n             inner: ConstantItem(Constant {\n                 type_: self.type_.clean(cx),\n                 expr: self.expr.span.to_src(cx),\n@@ -2216,6 +2238,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n             def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n+            deprecation: self.depr.clean(cx),\n             inner: ImplItem(Impl {\n                 unsafety: self.unsafety,\n                 generics: self.generics.clean(cx),\n@@ -2298,6 +2321,7 @@ impl Clean<Item> for doctree::DefaultImpl {\n             def_id: cx.map.local_def_id(self.id),\n             visibility: Some(hir::Public),\n             stability: None,\n+            deprecation: None,\n             inner: DefaultImplItem(DefaultImpl {\n                 unsafety: self.unsafety,\n                 trait_: self.trait_.clean(cx),\n@@ -2315,6 +2339,7 @@ impl Clean<Item> for doctree::ExternCrate {\n             def_id: cx.map.local_def_id(0),\n             visibility: self.vis.clean(cx),\n             stability: None,\n+            deprecation: None,\n             inner: ExternCrateItem(self.name.clean(cx), self.path.clone())\n         }\n     }\n@@ -2380,6 +2405,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n             def_id: cx.map.local_def_id(0),\n             visibility: self.vis.clean(cx),\n             stability: None,\n+            deprecation: None,\n             inner: ImportItem(inner)\n         });\n         ret\n@@ -2466,6 +2492,7 @@ impl Clean<Item> for hir::ForeignItem {\n             def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: get_stability(cx, cx.map.local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.map.local_def_id(self.id)),\n             inner: inner,\n         }\n     }\n@@ -2659,6 +2686,7 @@ impl Clean<Item> for doctree::Macro {\n             source: self.whence.clean(cx),\n             visibility: hir::Public.clean(cx),\n             stability: self.stab.clean(cx),\n+            deprecation: self.depr.clean(cx),\n             def_id: cx.map.local_def_id(self.id),\n             inner: MacroItem(Macro {\n                 source: format!(\"macro_rules! {} {{\\n{}}}\",\n@@ -2680,6 +2708,12 @@ pub struct Stability {\n     pub issue: Option<u32>\n }\n \n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub struct Deprecation {\n+    pub since: String,\n+    pub note: String,\n+}\n+\n impl Clean<Stability> for attr::Stability {\n     fn clean(&self, _: &DocContext) -> Stability {\n         Stability {\n@@ -2689,12 +2723,12 @@ impl Clean<Stability> for attr::Stability {\n                 attr::Stable {ref since} => since.to_string(),\n                 _ => \"\".to_string(),\n             },\n-            deprecated_since: match self.depr {\n-                Some(attr::Deprecation {ref since, ..}) => since.to_string(),\n+            deprecated_since: match self.rustc_depr {\n+                Some(attr::RustcDeprecation {ref since, ..}) => since.to_string(),\n                 _=> \"\".to_string(),\n             },\n             reason: {\n-                if let Some(ref depr) = self.depr {\n+                if let Some(ref depr) = self.rustc_depr {\n                     depr.reason.to_string()\n                 } else if let attr::Unstable {reason: Some(ref reason), ..} = self.level {\n                     reason.to_string()\n@@ -2716,6 +2750,15 @@ impl<'a> Clean<Stability> for &'a attr::Stability {\n     }\n }\n \n+impl Clean<Deprecation> for attr::Deprecation {\n+    fn clean(&self, _: &DocContext) -> Deprecation {\n+        Deprecation {\n+            since: self.since.as_ref().map_or(\"\".to_string(), |s| s.to_string()),\n+            note: self.note.as_ref().map_or(\"\".to_string(), |s| s.to_string()),\n+        }\n+    }\n+}\n+\n impl<'tcx> Clean<Item> for ty::AssociatedConst<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n@@ -2726,6 +2769,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedConst<'tcx> {\n             visibility: None,\n             def_id: self.def_id,\n             stability: None,\n+            deprecation: None,\n         }\n     }\n }\n@@ -2782,7 +2826,8 @@ impl<'tcx> Clean<Item> for ty::AssociatedType<'tcx> {\n             inner: AssociatedTypeItem(bounds, self.ty.clean(cx)),\n             visibility: self.vis.clean(cx),\n             def_id: self.def_id,\n-            stability: stability::lookup(cx.tcx(), self.def_id).clean(cx),\n+            stability: stability::lookup_stability(cx.tcx(), self.def_id).clean(cx),\n+            deprecation: stability::lookup_deprecation(cx.tcx(), self.def_id).clean(cx),\n         }\n     }\n }"}, {"sha": "d1030a6fcb07c56234f99e4dae6298ec072ab0cb", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -40,6 +40,7 @@ pub struct Module {\n     pub traits: Vec<Trait>,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n+    pub depr: Option<attr::Deprecation>,\n     pub impls: Vec<Impl>,\n     pub def_traits: Vec<DefaultImpl>,\n     pub foreigns: Vec<hir::ForeignMod>,\n@@ -54,6 +55,7 @@ impl Module {\n             id: 0,\n             vis: hir::Inherited,\n             stab: None,\n+            depr: None,\n             where_outer: syntax::codemap::DUMMY_SP,\n             where_inner: syntax::codemap::DUMMY_SP,\n             attrs      : Vec::new(),\n@@ -96,6 +98,7 @@ pub enum TypeBound {\n pub struct Struct {\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n+    pub depr: Option<attr::Deprecation>,\n     pub id: NodeId,\n     pub struct_type: StructType,\n     pub name: Name,\n@@ -108,6 +111,7 @@ pub struct Struct {\n pub struct Enum {\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n+    pub depr: Option<attr::Deprecation>,\n     pub variants: Vec<Variant>,\n     pub generics: hir::Generics,\n     pub attrs: Vec<ast::Attribute>,\n@@ -121,6 +125,7 @@ pub struct Variant {\n     pub attrs: Vec<ast::Attribute>,\n     pub def: hir::VariantData,\n     pub stab: Option<attr::Stability>,\n+    pub depr: Option<attr::Deprecation>,\n     pub whence: Span,\n }\n \n@@ -131,6 +136,7 @@ pub struct Function {\n     pub name: Name,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n+    pub depr: Option<attr::Deprecation>,\n     pub unsafety: hir::Unsafety,\n     pub constness: hir::Constness,\n     pub whence: Span,\n@@ -147,6 +153,7 @@ pub struct Typedef {\n     pub whence: Span,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n+    pub depr: Option<attr::Deprecation>,\n }\n \n #[derive(Debug)]\n@@ -158,6 +165,7 @@ pub struct Static {\n     pub attrs: Vec<ast::Attribute>,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n+    pub depr: Option<attr::Deprecation>,\n     pub id: ast::NodeId,\n     pub whence: Span,\n }\n@@ -169,6 +177,7 @@ pub struct Constant {\n     pub attrs: Vec<ast::Attribute>,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n+    pub depr: Option<attr::Deprecation>,\n     pub id: ast::NodeId,\n     pub whence: Span,\n }\n@@ -184,6 +193,7 @@ pub struct Trait {\n     pub whence: Span,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n+    pub depr: Option<attr::Deprecation>,\n }\n \n pub struct Impl {\n@@ -197,6 +207,7 @@ pub struct Impl {\n     pub whence: Span,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n+    pub depr: Option<attr::Deprecation>,\n     pub id: ast::NodeId,\n }\n \n@@ -215,6 +226,7 @@ pub struct Macro {\n     pub whence: Span,\n     pub matchers: Vec<Span>,\n     pub stab: Option<attr::Stability>,\n+    pub depr: Option<attr::Deprecation>,\n     pub imported_from: Option<Name>,\n }\n "}, {"sha": "5a4f95d1a1a5a7b24f4ce8050e7faeb105b83b09", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -19,7 +19,7 @@ pub trait DocFolder : Sized {\n \n     /// don't override!\n     fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n-        let Item { attrs, name, source, visibility, def_id, inner, stability } = item;\n+        let Item { attrs, name, source, visibility, def_id, inner, stability, deprecation } = item;\n         let inner = inner;\n         let inner = match inner {\n             StructItem(mut i) => {\n@@ -66,7 +66,8 @@ pub trait DocFolder : Sized {\n         };\n \n         Some(Item { attrs: attrs, name: name, source: source, inner: inner,\n-                    visibility: visibility, stability: stability, def_id: def_id })\n+                    visibility: visibility, stability: stability, deprecation: deprecation,\n+                    def_id: def_id })\n     }\n \n     fn fold_mod(&mut self, m: Module) -> Module {"}, {"sha": "09a2a1b1c02699e46fb78243b5cf196a95325ed1", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -1801,7 +1801,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n }\n \n fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Option<String> {\n-    item.stability.as_ref().and_then(|stab| {\n+    let mut result = item.stability.as_ref().and_then(|stab| {\n         let reason = if show_reason && !stab.reason.is_empty() {\n             format!(\": {}\", stab.reason)\n         } else {\n@@ -1836,7 +1836,27 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Optio\n         };\n         Some(format!(\"<em class='stab {}'>{}</em>\",\n                      item.stability_class(), text))\n-    })\n+    });\n+\n+    if result.is_none() {\n+        result = item.deprecation.as_ref().and_then(|depr| {\n+            let note = if show_reason && !depr.note.is_empty() {\n+                format!(\": {}\", depr.note)\n+            } else {\n+                String::new()\n+            };\n+            let since = if show_reason && !depr.since.is_empty() {\n+                format!(\" since {}\", Escape(&depr.since))\n+            } else {\n+                String::new()\n+            };\n+\n+            let text = format!(\"Deprecated{}{}\", since, Markdown(&note));\n+            Some(format!(\"<em class='stab deprecated'>{}</em>\", text))\n+        });\n+    }\n+\n+    result\n }\n \n struct Initializer<'a>(&'a str);"}, {"sha": "d95a4553bf1f53b3b33e24a59c26b3c37d46acfe", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -64,11 +64,18 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     fn stability(&self, id: ast::NodeId) -> Option<attr::Stability> {\n         self.cx.tcx_opt().and_then(|tcx| {\n             self.cx.map.opt_local_def_id(id)\n-                       .and_then(|def_id| stability::lookup(tcx, def_id))\n+                       .and_then(|def_id| stability::lookup_stability(tcx, def_id))\n                        .cloned()\n         })\n     }\n \n+    fn deprecation(&self, id: ast::NodeId) -> Option<attr::Deprecation> {\n+        self.cx.tcx_opt().and_then(|tcx| {\n+            self.cx.map.opt_local_def_id(id)\n+                       .and_then(|def_id| stability::lookup_deprecation(tcx, def_id))\n+        })\n+    }\n+\n     pub fn visit(&mut self, krate: &hir::Crate) {\n         self.attrs = krate.attrs.clone();\n \n@@ -95,6 +102,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             name: name,\n             vis: item.vis,\n             stab: self.stability(item.id),\n+            depr: self.deprecation(item.id),\n             attrs: item.attrs.clone(),\n             generics: generics.clone(),\n             fields: sd.fields().iter().cloned().collect(),\n@@ -112,11 +120,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 name: v.node.name,\n                 attrs: v.node.attrs.clone(),\n                 stab: self.stability(v.node.data.id()),\n+                depr: self.deprecation(v.node.data.id()),\n                 def: v.node.data.clone(),\n                 whence: v.span,\n             }).collect(),\n             vis: it.vis,\n             stab: self.stability(it.id),\n+            depr: self.deprecation(it.id),\n             generics: params.clone(),\n             attrs: it.attrs.clone(),\n             id: it.id,\n@@ -135,6 +145,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             id: item.id,\n             vis: item.vis,\n             stab: self.stability(item.id),\n+            depr: self.deprecation(item.id),\n             attrs: item.attrs.clone(),\n             decl: fd.clone(),\n             name: name,\n@@ -156,6 +167,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om.attrs = attrs;\n         om.vis = vis;\n         om.stab = self.stability(id);\n+        om.depr = self.deprecation(id);\n         om.id = id;\n         for i in &m.item_ids {\n             let item = self.cx.map.expect_item(i.id);\n@@ -314,6 +326,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     whence: item.span,\n                     vis: item.vis,\n                     stab: self.stability(item.id),\n+                    depr: self.deprecation(item.id),\n                 };\n                 om.typedefs.push(t);\n             },\n@@ -328,6 +341,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     whence: item.span,\n                     vis: item.vis,\n                     stab: self.stability(item.id),\n+                    depr: self.deprecation(item.id),\n                 };\n                 om.statics.push(s);\n             },\n@@ -341,6 +355,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     whence: item.span,\n                     vis: item.vis,\n                     stab: self.stability(item.id),\n+                    depr: self.deprecation(item.id),\n                 };\n                 om.constants.push(s);\n             },\n@@ -356,6 +371,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     whence: item.span,\n                     vis: item.vis,\n                     stab: self.stability(item.id),\n+                    depr: self.deprecation(item.id),\n                 };\n                 om.traits.push(t);\n             },\n@@ -372,6 +388,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     whence: item.span,\n                     vis: item.vis,\n                     stab: self.stability(item.id),\n+                    depr: self.deprecation(item.id),\n                 };\n                 // Don't duplicate impls when inlining glob imports, we'll pick\n                 // them up regardless of where they're located.\n@@ -410,6 +427,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             whence: def.span,\n             matchers: matchers,\n             stab: self.stability(def.id),\n+            depr: self.deprecation(def.id),\n             imported_from: def.imported_from,\n         }\n     }"}, {"sha": "d511ce09a36167ad1a92ff4f93f7513b98fc93dd", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 81, "deletions": 10, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -398,7 +398,7 @@ pub fn cfg_matches<T: CfgDiag>(cfgs: &[P<MetaItem>],\n pub struct Stability {\n     pub level: StabilityLevel,\n     pub feature: InternedString,\n-    pub depr: Option<Deprecation>,\n+    pub rustc_depr: Option<RustcDeprecation>,\n }\n \n /// The available stability levels.\n@@ -410,11 +410,17 @@ pub enum StabilityLevel {\n }\n \n #[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n-pub struct Deprecation {\n+pub struct RustcDeprecation {\n     pub since: InternedString,\n     pub reason: InternedString,\n }\n \n+#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n+pub struct Deprecation {\n+    pub since: Option<InternedString>,\n+    pub note: Option<InternedString>,\n+}\n+\n impl StabilityLevel {\n     pub fn is_unstable(&self) -> bool { if let Unstable {..} = *self { true } else { false }}\n     pub fn is_stable(&self) -> bool { if let Stable {..} = *self { true } else { false }}\n@@ -427,7 +433,7 @@ fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n     where I: Iterator<Item = &'a Attribute>\n {\n     let mut stab: Option<Stability> = None;\n-    let mut depr: Option<Deprecation> = None;\n+    let mut rustc_depr: Option<RustcDeprecation> = None;\n \n     'outer: for attr in attrs_iter {\n         let tag = attr.name();\n@@ -456,7 +462,7 @@ fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n \n             match tag {\n                 \"rustc_deprecated\" => {\n-                    if depr.is_some() {\n+                    if rustc_depr.is_some() {\n                         diagnostic.span_err(item_sp, \"multiple rustc_deprecated attributes\");\n                         break\n                     }\n@@ -477,7 +483,7 @@ fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n \n                     match (since, reason) {\n                         (Some(since), Some(reason)) => {\n-                            depr = Some(Deprecation {\n+                            rustc_depr = Some(RustcDeprecation {\n                                 since: since,\n                                 reason: reason,\n                             })\n@@ -529,7 +535,7 @@ fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n                                     }\n                                 },\n                                 feature: feature,\n-                                depr: None,\n+                                rustc_depr: None,\n                             })\n                         }\n                         (None, _, _) => {\n@@ -569,7 +575,7 @@ fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n                                     since: since,\n                                 },\n                                 feature: feature,\n-                                depr: None,\n+                                rustc_depr: None,\n                             })\n                         }\n                         (None, _) => {\n@@ -591,12 +597,12 @@ fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n     }\n \n     // Merge the deprecation info into the stability info\n-    if let Some(depr) = depr {\n+    if let Some(rustc_depr) = rustc_depr {\n         if let Some(ref mut stab) = stab {\n             if let Unstable {reason: ref mut reason @ None, ..} = stab.level {\n-                *reason = Some(depr.reason.clone())\n+                *reason = Some(rustc_depr.reason.clone())\n             }\n-            stab.depr = Some(depr);\n+            stab.rustc_depr = Some(rustc_depr);\n         } else {\n             diagnostic.span_err(item_sp, \"rustc_deprecated attribute must be paired with \\\n                                           either stable or unstable attribute\");\n@@ -606,12 +612,77 @@ fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n     stab\n }\n \n+fn find_deprecation_generic<'a, I>(diagnostic: &SpanHandler,\n+                                 attrs_iter: I,\n+                                 item_sp: Span)\n+                                 -> Option<Deprecation>\n+    where I: Iterator<Item = &'a Attribute>\n+{\n+    let mut depr: Option<Deprecation> = None;\n+\n+    'outer: for attr in attrs_iter {\n+        if attr.name() != \"deprecated\" {\n+            continue\n+        }\n+\n+        mark_used(attr);\n+\n+        if depr.is_some() {\n+            diagnostic.span_err(item_sp, \"multiple deprecated attributes\");\n+            break\n+        }\n+\n+        depr = if let Some(metas) = attr.meta_item_list() {\n+            let get = |meta: &MetaItem, item: &mut Option<InternedString>| {\n+                if item.is_some() {\n+                    diagnostic.span_err(meta.span, &format!(\"multiple '{}' items\",\n+                                                             meta.name()));\n+                    return false\n+                }\n+                if let Some(v) = meta.value_str() {\n+                    *item = Some(v);\n+                    true\n+                } else {\n+                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n+                    false\n+                }\n+            };\n+\n+            let mut since = None;\n+            let mut note = None;\n+            for meta in metas {\n+                match &*meta.name() {\n+                    \"since\" => if !get(meta, &mut since) { continue 'outer },\n+                    \"note\" => if !get(meta, &mut note) { continue 'outer },\n+                    _ => {\n+                        diagnostic.span_err(meta.span, &format!(\"unknown meta item '{}'\",\n+                                                                meta.name()));\n+                        continue 'outer\n+                    }\n+                }\n+            }\n+\n+            Some(Deprecation {since: since, note: note})\n+        } else {\n+            Some(Deprecation{since: None, note: None})\n+        }\n+    }\n+\n+    depr\n+}\n+\n /// Find the first stability attribute. `None` if none exists.\n pub fn find_stability(diagnostic: &SpanHandler, attrs: &[Attribute],\n                       item_sp: Span) -> Option<Stability> {\n     find_stability_generic(diagnostic, attrs.iter(), item_sp)\n }\n \n+/// Find the deprecation attribute. `None` if none exists.\n+pub fn find_deprecation(diagnostic: &SpanHandler, attrs: &[Attribute],\n+                      item_sp: Span) -> Option<Deprecation> {\n+    find_deprecation_generic(diagnostic, attrs.iter(), item_sp)\n+}\n+\n pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n     let mut set = HashSet::new();\n     for meta in metas {"}, {"sha": "f186aff6d363ac40516cd227a1b10bb5f542986e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -230,6 +230,9 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n \n     // Allow attributes on expressions and non-item statements\n     (\"stmt_expr_attributes\", \"1.6.0\", Some(15701), Active),\n+\n+    // Allows `#[deprecated]` attribute\n+    (\"deprecated\", \"1.6.0\", Some(29935), Active),\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -377,6 +380,7 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n     (\"must_use\", Whitelisted, Ungated),\n     (\"stable\", Whitelisted, Ungated),\n     (\"unstable\", Whitelisted, Ungated),\n+    (\"deprecated\", Normal, Gated(\"deprecated\", \"`#[deprecated]` attribute is unstable\")),\n \n     (\"rustc_paren_sugar\", Normal, Gated(\"unboxed_closures\",\n                                         \"unboxed_closures are still evolving\")),\n@@ -539,6 +543,7 @@ pub struct Features {\n     pub braced_empty_structs: bool,\n     pub staged_api: bool,\n     pub stmt_expr_attributes: bool,\n+    pub deprecated: bool,\n }\n \n impl Features {\n@@ -573,6 +578,7 @@ impl Features {\n             braced_empty_structs: false,\n             staged_api: false,\n             stmt_expr_attributes: false,\n+            deprecated: false,\n         }\n     }\n }\n@@ -1151,6 +1157,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n         braced_empty_structs: cx.has_feature(\"braced_empty_structs\"),\n         staged_api: cx.has_feature(\"staged_api\"),\n         stmt_expr_attributes: cx.has_feature(\"stmt_expr_attributes\"),\n+        deprecated: cx.has_feature(\"deprecated\"),\n     }\n }\n "}, {"sha": "ff872efb7bdb1049f44ecad65feb2ae398a59f9c", "filename": "src/test/auxiliary/deprecation-lint.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Ftest%2Fauxiliary%2Fdeprecation-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Ftest%2Fauxiliary%2Fdeprecation-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fdeprecation-lint.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(deprecated)]\n+\n+#[deprecated(since = \"1.0.0\", note = \"text\")]\n+pub fn deprecated() {}\n+#[deprecated(since = \"1.0.0\", note = \"text\")]\n+pub fn deprecated_text() {}\n+\n+pub struct MethodTester;\n+\n+impl MethodTester {\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    pub fn method_deprecated(&self) {}\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    pub fn method_deprecated_text(&self) {}\n+}\n+\n+pub trait Trait {\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    fn trait_deprecated(&self) {}\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    fn trait_deprecated_text(&self) {}\n+}\n+\n+#[deprecated(since = \"1.0.0\", note = \"text\")]\n+pub trait DeprecatedTrait { fn dummy(&self) { } }\n+\n+impl Trait for MethodTester {}\n+\n+#[deprecated(since = \"1.0.0\", note = \"text\")]\n+pub struct DeprecatedStruct {\n+    pub i: isize\n+}\n+\n+#[deprecated(since = \"1.0.0\", note = \"text\")]\n+pub struct DeprecatedUnitStruct;\n+\n+pub enum Enum {\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    DeprecatedVariant,\n+}\n+\n+#[deprecated(since = \"1.0.0\", note = \"text\")]\n+pub struct DeprecatedTupleStruct(pub isize);\n+\n+pub struct Stable {\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    pub override2: u8,\n+}\n+\n+pub struct Stable2(pub u8, pub u8, #[deprecated(since = \"1.0.0\", note = \"text\")] pub u8);\n+\n+#[deprecated(since = \"1.0.0\", note = \"text\")]\n+pub struct Deprecated {\n+    pub inherit: u8,\n+}\n+\n+#[deprecated(since = \"1.0.0\", note = \"text\")]\n+pub struct Deprecated2(pub u8,\n+                       pub u8,\n+                       pub u8);\n+\n+#[deprecated(since = \"1.0.0\", note = \"text\")]\n+pub mod deprecated_mod {\n+    pub fn deprecated() {}\n+}\n+\n+#[macro_export]\n+macro_rules! macro_test {\n+    () => (deprecated());\n+}\n+\n+#[macro_export]\n+macro_rules! macro_test_arg {\n+    ($func:expr) => ($func);\n+}\n+\n+#[macro_export]\n+macro_rules! macro_test_arg_nested {\n+    ($func:ident) => (macro_test_arg!($func()));\n+}"}, {"sha": "3100aba4b72be3cfa027c52d61feec6bb0f67470", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -98,6 +98,12 @@ impl Trait for MethodTester {}\n #[unstable(feature = \"test_feature\", issue = \"0\")]\n pub trait UnstableTrait { fn dummy(&self) { } }\n \n+#[stable(feature = \"test_feature\", since = \"1.0.0\")]\n+#[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+pub trait DeprecatedTrait {\n+    #[stable(feature = \"test_feature\", since = \"1.0.0\")] fn dummy(&self) { }\n+}\n+\n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n pub struct DeprecatedStruct {"}, {"sha": "4f4aed21f994d8383c109e69ebd305862528457f", "filename": "src/test/compile-fail/deprecation-in-staged-api.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Ftest%2Fcompile-fail%2Fdeprecation-in-staged-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Ftest%2Fcompile-fail%2Fdeprecation-in-staged-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecation-in-staged-api.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// #[deprecated] can't be used in staged api\n+\n+#![feature(deprecated, staged_api)]\n+\n+#![stable(feature = \"test_feature\", since = \"1.0.0\")]\n+\n+#[deprecated]\n+fn main() { } //~ERROR `#[deprecated]` cannot be used in staged api"}, {"sha": "2817e06652afba450c734a1a891c1340b2aafa1f", "filename": "src/test/compile-fail/deprecation-lint-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint-2.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:deprecation-lint.rs\n+// error-pattern: use of deprecated item\n+\n+#![deny(deprecated)]\n+\n+#[macro_use]\n+extern crate deprecation_lint;\n+\n+use deprecation_lint::*;\n+\n+fn main() {\n+    macro_test!();\n+}"}, {"sha": "7faaa181d392261c913048e9c8c05dbc256131ce", "filename": "src/test/compile-fail/deprecation-lint-3.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint-3.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:deprecation-lint.rs\n+// error-pattern: use of deprecated item\n+\n+#![deny(deprecated)]\n+#![allow(warnings)]\n+\n+#[macro_use]\n+extern crate deprecation_lint;\n+\n+use deprecation_lint::*;\n+\n+fn main() {\n+    macro_test_arg_nested!(deprecated_text);\n+}"}, {"sha": "58fa00fb41086d2f09a621bbfb42047dcac29491", "filename": "src/test/compile-fail/deprecation-lint.rs", "status": "added", "additions": 389, "deletions": 0, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -0,0 +1,389 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:deprecation-lint.rs\n+\n+#![feature(deprecated)]\n+\n+#![deny(deprecated)]\n+#![allow(warnings)]\n+\n+#[macro_use]\n+extern crate deprecation_lint;\n+\n+mod cross_crate {\n+    use deprecation_lint::*;\n+\n+    fn test() {\n+        type Foo = MethodTester;\n+        let foo = MethodTester;\n+\n+        deprecated(); //~ ERROR use of deprecated item\n+        foo.method_deprecated(); //~ ERROR use of deprecated item\n+        Foo::method_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::method_deprecated(&foo); //~ ERROR use of deprecated item\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+\n+        deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.method_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Foo::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+\n+        let _ = DeprecatedStruct { //~ ERROR use of deprecated item\n+            i: 0 //~ ERROR use of deprecated item\n+        };\n+\n+        let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item\n+\n+        let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item\n+\n+        let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item\n+\n+        // At the moment, the lint checker only checks stability in\n+        // in the arguments of macros.\n+        // Eventually, we will want to lint the contents of the\n+        // macro in the module *defining* it. Also, stability levels\n+        // on macros themselves are not yet linted.\n+        macro_test_arg!(deprecated_text()); //~ ERROR use of deprecated item: text\n+        macro_test_arg!(macro_test_arg!(deprecated_text())); //~ ERROR use of deprecated item: text\n+    }\n+\n+    fn test_method_param<Foo: Trait>(foo: Foo) {\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+    }\n+\n+    fn test_method_object(foo: &Trait) {\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+    }\n+\n+    struct S;\n+\n+    impl DeprecatedTrait for S {} //~ ERROR use of deprecated item: text\n+    trait LocalTrait : DeprecatedTrait { } //~ ERROR use of deprecated item: text\n+\n+    pub fn foo() {\n+        let x = Stable {\n+            override2: 3,\n+            //~^ ERROR use of deprecated item\n+        };\n+\n+        let _ = x.override2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Stable {\n+            override2: _\n+            //~^ ERROR use of deprecated item\n+        } = x;\n+        // all fine\n+        let Stable { .. } = x;\n+\n+        let x = Stable2(1, 2, 3);\n+\n+        let _ = x.2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Stable2(_,\n+                   _,\n+                   _)\n+            //~^ ERROR use of deprecated item\n+            = x;\n+        // all fine\n+        let Stable2(..) = x;\n+\n+        let x = Deprecated {\n+            //~^ ERROR use of deprecated item\n+            inherit: 1,\n+            //~^ ERROR use of deprecated item\n+        };\n+\n+        let _ = x.inherit;\n+        //~^ ERROR use of deprecated item\n+\n+        let Deprecated {\n+            //~^ ERROR use of deprecated item\n+            inherit: _,\n+            //~^ ERROR use of deprecated item\n+        } = x;\n+\n+        let Deprecated\n+            //~^ ERROR use of deprecated item\n+            { .. } = x;\n+\n+        let x = Deprecated2(1, 2, 3);\n+        //~^ ERROR use of deprecated item\n+\n+        let _ = x.0;\n+        //~^ ERROR use of deprecated item\n+        let _ = x.1;\n+        //~^ ERROR use of deprecated item\n+        let _ = x.2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Deprecated2\n+        //~^ ERROR use of deprecated item\n+            (_,\n+             //~^ ERROR use of deprecated item\n+             _,\n+             //~^ ERROR use of deprecated item\n+             _)\n+             //~^ ERROR use of deprecated item\n+            = x;\n+        let Deprecated2\n+        //~^ ERROR use of deprecated item\n+            // the patterns are all fine:\n+            (..) = x;\n+    }\n+}\n+\n+mod inheritance {\n+    use deprecation_lint::*;\n+\n+    fn test_inheritance() {\n+        deprecated_mod::deprecated(); //~ ERROR use of deprecated item\n+    }\n+}\n+\n+mod this_crate {\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    pub fn deprecated() {}\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    pub fn deprecated_text() {}\n+\n+    pub struct MethodTester;\n+\n+    impl MethodTester {\n+        #[deprecated(since = \"1.0.0\", note = \"text\")]\n+        pub fn method_deprecated(&self) {}\n+        #[deprecated(since = \"1.0.0\", note = \"text\")]\n+        pub fn method_deprecated_text(&self) {}\n+    }\n+\n+    pub trait Trait {\n+        #[deprecated(since = \"1.0.0\", note = \"text\")]\n+        fn trait_deprecated(&self) {}\n+        #[deprecated(since = \"1.0.0\", note = \"text\")]\n+        fn trait_deprecated_text(&self) {}\n+    }\n+\n+    impl Trait for MethodTester {}\n+\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    pub struct DeprecatedStruct {\n+        i: isize\n+    }\n+    pub struct UnstableStruct {\n+        i: isize\n+    }\n+    pub struct StableStruct {\n+        i: isize\n+    }\n+\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    pub struct DeprecatedUnitStruct;\n+\n+    pub enum Enum {\n+        #[deprecated(since = \"1.0.0\", note = \"text\")]\n+        DeprecatedVariant,\n+    }\n+\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    pub struct DeprecatedTupleStruct(isize);\n+\n+    fn test() {\n+        // Only the deprecated cases of the following should generate\n+        // errors, because other stability attributes now have meaning\n+        // only *across* crates, not within a single crate.\n+\n+        type Foo = MethodTester;\n+        let foo = MethodTester;\n+\n+        deprecated(); //~ ERROR use of deprecated item\n+        foo.method_deprecated(); //~ ERROR use of deprecated item\n+        Foo::method_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::method_deprecated(&foo); //~ ERROR use of deprecated item\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+\n+        deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.method_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Foo::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+\n+        let _ = DeprecatedStruct {\n+            //~^ ERROR use of deprecated item\n+            i: 0 //~ ERROR use of deprecated item\n+        };\n+\n+        let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item\n+\n+        let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item\n+\n+        let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item\n+    }\n+\n+    fn test_method_param<Foo: Trait>(foo: Foo) {\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+    }\n+\n+    fn test_method_object(foo: &Trait) {\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+    }\n+\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    fn test_fn_body() {\n+        fn fn_in_body() {}\n+        fn_in_body(); //~ ERROR use of deprecated item: text\n+    }\n+\n+    impl MethodTester {\n+        #[deprecated(since = \"1.0.0\", note = \"text\")]\n+        fn test_method_body(&self) {\n+            fn fn_in_body() {}\n+            fn_in_body(); //~ ERROR use of deprecated item: text\n+        }\n+    }\n+\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    pub trait DeprecatedTrait {\n+        fn dummy(&self) { }\n+    }\n+\n+    struct S;\n+\n+    impl DeprecatedTrait for S { } //~ ERROR use of deprecated item\n+\n+    trait LocalTrait : DeprecatedTrait { } //~ ERROR use of deprecated item\n+}\n+\n+mod this_crate2 {\n+    struct Stable {\n+        #[deprecated(since = \"1.0.0\", note = \"text\")]\n+        override2: u8,\n+    }\n+\n+    struct Stable2(u8,\n+                   u8,\n+                   #[deprecated(since = \"1.0.0\", note = \"text\")] u8);\n+\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    struct Deprecated {\n+        inherit: u8,\n+    }\n+\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    struct Deprecated2(u8,\n+                       u8,\n+                       u8);\n+\n+    pub fn foo() {\n+        let x = Stable {\n+            override2: 3,\n+            //~^ ERROR use of deprecated item\n+        };\n+\n+        let _ = x.override2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Stable {\n+            override2: _\n+            //~^ ERROR use of deprecated item\n+        } = x;\n+        // all fine\n+        let Stable { .. } = x;\n+\n+        let x = Stable2(1, 2, 3);\n+\n+        let _ = x.2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Stable2(_,\n+                   _,\n+                   _)\n+            //~^ ERROR use of deprecated item\n+            = x;\n+        // all fine\n+        let Stable2(..) = x;\n+\n+        let x = Deprecated {\n+            //~^ ERROR use of deprecated item\n+            inherit: 1,\n+            //~^ ERROR use of deprecated item\n+        };\n+\n+        let _ = x.inherit;\n+        //~^ ERROR use of deprecated item\n+\n+        let Deprecated {\n+            //~^ ERROR use of deprecated item\n+            inherit: _,\n+            //~^ ERROR use of deprecated item\n+        } = x;\n+\n+        let Deprecated\n+            //~^ ERROR use of deprecated item\n+            // the patterns are all fine:\n+            { .. } = x;\n+\n+        let x = Deprecated2(1, 2, 3);\n+        //~^ ERROR use of deprecated item\n+\n+        let _ = x.0;\n+        //~^ ERROR use of deprecated item\n+        let _ = x.1;\n+        //~^ ERROR use of deprecated item\n+        let _ = x.2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Deprecated2\n+        //~^ ERROR use of deprecated item\n+            (_,\n+             //~^ ERROR use of deprecated item\n+             _,\n+             //~^ ERROR use of deprecated item\n+             _)\n+            //~^ ERROR use of deprecated item\n+            = x;\n+        let Deprecated2\n+        //~^ ERROR use of deprecated item\n+            // the patterns are all fine:\n+            (..) = x;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6ee5cd2c7e3cf171887d12ce69db6bbc325c4266", "filename": "src/test/compile-fail/deprecation-sanity.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Ftest%2Fcompile-fail%2Fdeprecation-sanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Ftest%2Fcompile-fail%2Fdeprecation-sanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecation-sanity.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Various checks that deprecation attributes are used correctly\n+\n+#![feature(deprecated)]\n+\n+mod bogus_attribute_types_1 {\n+    #[deprecated(since = \"a\", note = \"a\", reason)] //~ ERROR unknown meta item 'reason'\n+    fn f1() { }\n+\n+    #[deprecated(since = \"a\", note)] //~ ERROR incorrect meta item\n+    fn f2() { }\n+\n+    #[deprecated(since, note = \"a\")] //~ ERROR incorrect meta item\n+    fn f3() { }\n+\n+    #[deprecated(since = \"a\", note(b))] //~ ERROR incorrect meta item\n+    fn f5() { }\n+\n+    #[deprecated(since(b), note = \"a\")] //~ ERROR incorrect meta item\n+    fn f6() { }\n+}\n+\n+#[deprecated(since = \"a\", note = \"b\")]\n+#[deprecated(since = \"a\", note = \"b\")]\n+fn multiple1() { } //~ ERROR multiple deprecated attributes\n+\n+#[deprecated(since = \"a\", since = \"b\", note = \"c\")] //~ ERROR multiple 'since' items\n+fn f1() { }\n+\n+fn main() { }"}, {"sha": "414d2a857acc72b0f813ef977a9ffbe8166a1374", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -227,8 +227,9 @@ mod cross_crate {\n     struct S;\n \n     impl UnstableTrait for S { } //~ ERROR use of unstable library feature\n-\n+    impl DeprecatedTrait for S {} //~ ERROR use of deprecated item: text\n     trait LocalTrait : UnstableTrait { } //~ ERROR use of unstable library feature\n+    trait LocalTrait2 : DeprecatedTrait { } //~ ERROR use of deprecated item: text\n \n     impl Trait for S {\n         fn trait_stable(&self) {}"}, {"sha": "744304a62c216ec0a61768d85b9a9b367241f419", "filename": "src/test/rustdoc/deprecated.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Ftest%2Frustdoc%2Fdeprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2c5ff0241bdd090af11a74566bd00f03ae8ae0/src%2Ftest%2Frustdoc%2Fdeprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdeprecated.rs?ref=ac2c5ff0241bdd090af11a74566bd00f03ae8ae0", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(deprecated)]\n+\n+// @has deprecated/struct.S.html '//*[@class=\"stab deprecated\"]' \\\n+//      'Deprecated since 1.0.0: text'\n+#[deprecated(since = \"1.0.0\", note = \"text\")]\n+pub struct S;"}]}