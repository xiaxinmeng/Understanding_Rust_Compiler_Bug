{"sha": "8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkM2U5M2JlYWU5NTYyZjhiMzJiN2Y4MmMzODI0Mzg5ZjZhYzViYWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-21T06:32:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-21T06:32:03Z"}, "message": "Auto merge of #47622 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 10 pull requests\n\n- Successful merges: #46938, #47193, #47508, #47510, #47532, #47535, #47559, #47568, #47573, #47578\n- Failed merges:", "tree": {"sha": "456c25e3deb781ba5a4888799f1e11951999351d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/456c25e3deb781ba5a4888799f1e11951999351d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "html_url": "https://github.com/rust-lang/rust/commit/8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b85aefbc601b1fe89b4989c623305eb1def8e0e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b85aefbc601b1fe89b4989c623305eb1def8e0e7", "html_url": "https://github.com/rust-lang/rust/commit/b85aefbc601b1fe89b4989c623305eb1def8e0e7"}, {"sha": "4074893acd04938cfe71c2a36bf53fa54256ac5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4074893acd04938cfe71c2a36bf53fa54256ac5c", "html_url": "https://github.com/rust-lang/rust/commit/4074893acd04938cfe71c2a36bf53fa54256ac5c"}], "stats": {"total": 589, "additions": 388, "deletions": 201}, "files": [{"sha": "70376c120fc0a4fc8ae663cfa2f762eec0b18df7", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -301,12 +301,12 @@ It's absolutely fine to have multiple build directories with different\n [pull-requests]: #pull-requests\n \n Pull requests are the primary mechanism we use to change Rust. GitHub itself\n-has some [great documentation][pull-requests] on using the Pull Request feature.\n+has some [great documentation][about-pull-requests] on using the Pull Request feature.\n We use the \"fork and pull\" model [described here][development-models], where\n contributors push changes to their personal fork and create pull requests to\n bring those changes into the source repository.\n \n-[pull-requests]: https://help.github.com/articles/about-pull-requests/\n+[about-pull-requests]: https://help.github.com/articles/about-pull-requests/\n [development-models]: https://help.github.com/articles/about-collaborative-development-models/\n \n Please make pull requests against the `master` branch."}, {"sha": "3add2774105e07a0fdffa81dd95561fb800d792c", "filename": "src/doc/index.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -28,6 +28,7 @@ Rust provides a number of book-length sets of documentation, collectively\n nicknamed 'The Rust Bookshelf.'\n \n * [The Rust Programming Language][book] teaches you how to program in Rust.\n+* [Rust By Example][rbe] teaches you how to program in Rust using editable examples.\n * [The Cargo Book][cargo-book] is a guide to Cargo, Rust's build tool and dependency manager.\n * [The Unstable Book][unstable-book] has documentation for unstable features.\n * [The Rustonomicon][nomicon] is your guidebook to the dark arts of unsafe Rust.\n@@ -51,6 +52,7 @@ before this policy was put into place. That work is being tracked\n [refchecklist]: https://github.com/rust-lang-nursery/reference/issues/9\n [err]: error-index.html\n [book]: book/index.html\n+[rbe]: rust-by-example/index.html\n [nomicon]: nomicon/index.html\n [unstable-book]: unstable-book/index.html\n [rustdoc-book]: rustdoc/index.html"}, {"sha": "b8fe28d0f0d71b6fa7a8c07084464754acb979d2", "filename": "src/libcore/option.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -881,6 +881,35 @@ impl<T: Default> Option<T> {\n     }\n }\n \n+impl<T, E> Option<Result<T, E>> {\n+    /// Transposes an `Option` of a `Result` into a `Result` of an `Option`.\n+    ///\n+    /// `None` will be mapped to `Ok(None)`.\n+    /// `Some(Ok(_))` and `Some(Err(_))` will be mapped to `Ok(Some(_))` and `Err(_)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(transpose_result)]\n+    ///\n+    /// #[derive(Debug, Eq, PartialEq)]\n+    /// struct SomeErr;\n+    ///\n+    /// let x: Result<Option<i32>, SomeErr> = Ok(Some(5));\n+    /// let y: Option<Result<i32, SomeErr>> = Some(Ok(5));\n+    /// assert_eq!(x, y.transpose());\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"transpose_result\", issue = \"47338\")]\n+    pub fn transpose(self) -> Result<Option<T>, E> {\n+        match self {\n+            Some(Ok(x)) => Ok(Some(x)),\n+            Some(Err(e)) => Err(e),\n+            None => Ok(None),\n+        }\n+    }\n+}\n+\n // This is a separate function to reduce the code size of .expect() itself.\n #[inline(never)]\n #[cold]"}, {"sha": "3801db94e15d53242fc71986782f8ee161554079", "filename": "src/libcore/result.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -909,6 +909,35 @@ impl<T: Default, E> Result<T, E> {\n     }\n }\n \n+impl<T, E> Result<Option<T>, E> {\n+    /// Transposes a `Result` of an `Option` into an `Option` of a `Result`.\n+    ///\n+    /// `Ok(None)` will be mapped to `None`.\n+    /// `Ok(Some(_))` and `Err(_)` will be mapped to `Some(Ok(_))` and `Some(Err(_))`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(transpose_result)]\n+    ///\n+    /// #[derive(Debug, Eq, PartialEq)]\n+    /// struct SomeErr;\n+    ///\n+    /// let x: Result<Option<i32>, SomeErr> = Ok(Some(5));\n+    /// let y: Option<Result<i32, SomeErr>> = Some(Ok(5));\n+    /// assert_eq!(x.transpose(), y);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"transpose_result\", issue = \"47338\")]\n+    pub fn transpose(self) -> Option<Result<T, E>> {\n+        match self {\n+            Ok(Some(x)) => Some(Ok(x)),\n+            Ok(None) => None,\n+            Err(e) => Some(Err(e)),\n+        }\n+    }\n+}\n+\n // This is a separate function to reduce the code size of the methods\n #[inline(never)]\n #[cold]"}, {"sha": "e649f1b49df765052fdd61b6b3b69c0e69c8d2ef", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 152, "deletions": 153, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -717,93 +717,40 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     self.tcx.hir.span_if_local(did)\n                 }).map(|sp| self.tcx.sess.codemap().def_span(sp)); // the sp could be an fn def\n \n-                let found_ty_count =\n-                    match found_trait_ref.skip_binder().substs.type_at(1).sty {\n-                        ty::TyTuple(ref tys, _) => tys.len(),\n-                        _ => 1,\n-                    };\n-                let (expected_tys, expected_ty_count) =\n-                    match expected_trait_ref.skip_binder().substs.type_at(1).sty {\n-                        ty::TyTuple(ref tys, _) =>\n-                            (tys.iter().map(|t| &t.sty).collect(), tys.len()),\n-                        ref sty => (vec![sty], 1),\n-                    };\n-                if found_ty_count == expected_ty_count {\n+                let found = match found_trait_ref.skip_binder().substs.type_at(1).sty {\n+                    ty::TyTuple(ref tys, _) => tys.iter()\n+                        .map(|_| ArgKind::empty()).collect::<Vec<_>>(),\n+                    _ => vec![ArgKind::empty()],\n+                };\n+                let expected = match expected_trait_ref.skip_binder().substs.type_at(1).sty {\n+                    ty::TyTuple(ref tys, _) => tys.iter()\n+                        .map(|t| match t.sty {\n+                            ty::TypeVariants::TyTuple(ref tys, _) => ArgKind::Tuple(\n+                                span,\n+                                tys.iter()\n+                                    .map(|ty| (\"_\".to_owned(), format!(\"{}\", ty.sty)))\n+                                    .collect::<Vec<_>>()\n+                            ),\n+                            _ => ArgKind::Arg(\"_\".to_owned(), format!(\"{}\", t.sty)),\n+                        }).collect(),\n+                    ref sty => vec![ArgKind::Arg(\"_\".to_owned(), format!(\"{}\", sty))],\n+                };\n+                if found.len()== expected.len() {\n                     self.report_closure_arg_mismatch(span,\n                                                      found_span,\n                                                      found_trait_ref,\n                                                      expected_trait_ref)\n                 } else {\n-                    let expected_tuple = if expected_ty_count == 1 {\n-                        expected_tys.first().and_then(|t| {\n-                            if let &&ty::TyTuple(ref tuptys, _) = t {\n-                                Some(tuptys.len())\n-                            } else {\n-                                None\n-                            }\n-                        })\n-                    } else {\n-                        None\n-                    };\n-\n-                    // FIXME(#44150): Expand this to \"N args expected but a N-tuple found.\"\n-                    // Type of the 1st expected argument is somehow provided as type of a\n-                    // found one in that case.\n-                    //\n-                    // ```\n-                    // [1i32, 2, 3].sort_by(|(a, b)| ..)\n-                    // //           ^^^^^^^ --------\n-                    // // expected_trait_ref:  std::ops::FnMut<(&i32, &i32)>\n-                    // //    found_trait_ref:  std::ops::FnMut<(&i32,)>\n-                    // ```\n-\n-                    let (closure_span, closure_args) = found_did\n+                    let (closure_span, found) = found_did\n                         .and_then(|did| self.tcx.hir.get_if_local(did))\n-                        .and_then(|node| {\n-                            if let hir::map::NodeExpr(\n-                                &hir::Expr {\n-                                    node: hir::ExprClosure(_, ref decl, id, span, _),\n-                                    ..\n-                                }) = node\n-                            {\n-                                let ty_snips = decl.inputs.iter()\n-                                    .map(|ty| {\n-                                        self.tcx.sess.codemap().span_to_snippet(ty.span).ok()\n-                                            .and_then(|snip| {\n-                                                // filter out dummy spans\n-                                                if snip == \",\" || snip == \"|\" {\n-                                                    None\n-                                                } else {\n-                                                    Some(snip)\n-                                                }\n-                                            })\n-                                    })\n-                                    .collect::<Vec<Option<String>>>();\n-\n-                                let body = self.tcx.hir.body(id);\n-                                let pat_snips = body.arguments.iter()\n-                                    .map(|arg|\n-                                        self.tcx.sess.codemap().span_to_snippet(arg.pat.span).ok())\n-                                    .collect::<Option<Vec<String>>>();\n-\n-                                Some((span, pat_snips, ty_snips))\n-                            } else {\n-                                None\n-                            }\n-                        })\n-                        .map(|(span, pat, ty)| (Some(span), Some((pat, ty))))\n-                        .unwrap_or((None, None));\n-                    let closure_args = closure_args.and_then(|(pat, ty)| Some((pat?, ty)));\n-\n-                    self.report_arg_count_mismatch(\n-                        span,\n-                        closure_span.or(found_span),\n-                        expected_ty_count,\n-                        expected_tuple,\n-                        found_ty_count,\n-                        closure_args,\n-                        found_trait_ty.is_closure()\n-                    )\n+                        .map(|node| self.get_fn_like_arguments(node))\n+                        .unwrap_or((found_span.unwrap(), found));\n+\n+                    self.report_arg_count_mismatch(span,\n+                                                   closure_span,\n+                                                   expected,\n+                                                   found,\n+                                                   found_trait_ty.is_closure())\n                 }\n             }\n \n@@ -845,94 +792,135 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn get_fn_like_arguments(&self, node: hir::map::Node) -> (Span, Vec<ArgKind>) {\n+        if let hir::map::NodeExpr(&hir::Expr {\n+            node: hir::ExprClosure(_, ref _decl, id, span, _),\n+            ..\n+        }) = node {\n+            (self.tcx.sess.codemap().def_span(span), self.tcx.hir.body(id).arguments.iter()\n+                .map(|arg| {\n+                    if let hir::Pat {\n+                        node: hir::PatKind::Tuple(args, _),\n+                        span,\n+                        ..\n+                    } = arg.pat.clone().into_inner() {\n+                        ArgKind::Tuple(\n+                            span,\n+                            args.iter().map(|pat| {\n+                                let snippet = self.tcx.sess.codemap()\n+                                    .span_to_snippet(pat.span).unwrap();\n+                                (snippet, \"_\".to_owned())\n+                            }).collect::<Vec<_>>(),\n+                        )\n+                    } else {\n+                        let name = self.tcx.sess.codemap().span_to_snippet(arg.pat.span).unwrap();\n+                        ArgKind::Arg(name, \"_\".to_owned())\n+                    }\n+                })\n+                .collect::<Vec<ArgKind>>())\n+        } else if let hir::map::NodeItem(&hir::Item {\n+            span,\n+            node: hir::ItemFn(ref decl, ..),\n+            ..\n+        }) = node {\n+            (self.tcx.sess.codemap().def_span(span), decl.inputs.iter()\n+                    .map(|arg| match arg.clone().into_inner().node {\n+                hir::TyTup(ref tys) => ArgKind::Tuple(\n+                    arg.span,\n+                    tys.iter()\n+                        .map(|_| (\"_\".to_owned(), \"_\".to_owned()))\n+                        .collect::<Vec<_>>(),\n+                ),\n+                _ => ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n+            }).collect::<Vec<ArgKind>>())\n+        } else {\n+            panic!(\"non-FnLike node found: {:?}\", node);\n+        }\n+    }\n+\n     fn report_arg_count_mismatch(\n         &self,\n         span: Span,\n-        found_span: Option<Span>,\n-        expected: usize,\n-        expected_tuple: Option<usize>,\n-        found: usize,\n-        closure_args: Option<(Vec<String>, Vec<Option<String>>)>,\n-        is_closure: bool\n+        found_span: Span,\n+        expected_args: Vec<ArgKind>,\n+        found_args: Vec<ArgKind>,\n+        is_closure: bool,\n     ) -> DiagnosticBuilder<'tcx> {\n-        use std::borrow::Cow;\n-\n         let kind = if is_closure { \"closure\" } else { \"function\" };\n \n-        let args_str = |n, distinct| format!(\n-                \"{} {}argument{}\",\n-                n,\n-                if distinct && n >= 2 { \"distinct \" } else { \"\" },\n-                if n == 1 { \"\" } else { \"s\" },\n-            );\n-\n-        let expected_str = if let Some(n) = expected_tuple {\n-            assert!(expected == 1);\n-            if closure_args.as_ref().map(|&(ref pats, _)| pats.len()) == Some(n) {\n-                Cow::from(\"a single tuple as argument\")\n-            } else {\n-                // be verbose when numbers differ\n-                Cow::from(format!(\"a single {}-tuple as argument\", n))\n+        let args_str = |arguments: &Vec<ArgKind>, other: &Vec<ArgKind>| {\n+            let arg_length = arguments.len();\n+            let distinct = match &other[..] {\n+                &[ArgKind::Tuple(..)] => true,\n+                _ => false,\n+            };\n+            match (arg_length, arguments.get(0)) {\n+                (1, Some(&ArgKind::Tuple(_, ref fields))) => {\n+                    format!(\"a single {}-tuple as argument\", fields.len())\n+                }\n+                _ => format!(\"{} {}argument{}\",\n+                             arg_length,\n+                             if distinct && arg_length > 1 { \"distinct \" } else { \"\" },\n+                             if arg_length == 1 { \"\" } else { \"s\" }),\n             }\n-        } else {\n-            Cow::from(args_str(expected, false))\n-        };\n-\n-        let found_str = if expected_tuple.is_some() {\n-            args_str(found, true)\n-        } else {\n-            args_str(found, false)\n         };\n \n+        let expected_str = args_str(&expected_args, &found_args);\n+        let found_str = args_str(&found_args, &expected_args);\n \n-        let mut err = struct_span_err!(self.tcx.sess, span, E0593,\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            span,\n+            E0593,\n             \"{} is expected to take {}, but it takes {}\",\n             kind,\n             expected_str,\n             found_str,\n         );\n \n-        err.span_label(\n-            span,\n-            format!(\n-                \"expected {} that takes {}\",\n-                kind,\n-                expected_str,\n-            )\n-        );\n-\n-        if let Some(span) = found_span {\n-            if let (Some(expected_tuple), Some((pats, tys))) = (expected_tuple, closure_args) {\n-                if expected_tuple != found || pats.len() != found {\n-                    err.span_label(span, format!(\"takes {}\", found_str));\n-                } else {\n-                    let sugg = format!(\n-                        \"|({}){}|\",\n-                        pats.join(\", \"),\n-\n-                        // add type annotations if available\n-                        if tys.iter().any(|ty| ty.is_some()) {\n-                            Cow::from(format!(\n-                                \": ({})\",\n-                                tys.into_iter().map(|ty| if let Some(ty) = ty {\n-                                    ty\n-                                } else {\n-                                    \"_\".to_string()\n-                                }).collect::<Vec<String>>().join(\", \")\n-                            ))\n-                        } else {\n-                            Cow::from(\"\")\n-                        },\n-                    );\n-\n-                    err.span_suggestion(\n-                        span,\n-                        \"consider changing the closure to accept a tuple\",\n-                        sugg\n-                    );\n-                }\n-            } else {\n-                err.span_label(span, format!(\"takes {}\", found_str));\n+        err.span_label(span, format!( \"expected {} that takes {}\", kind, expected_str));\n+        err.span_label(found_span, format!(\"takes {}\", found_str));\n+\n+        if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n+            if fields.len() == expected_args.len() {\n+                let sugg = fields.iter()\n+                    .map(|(name, _)| name.to_owned())\n+                    .collect::<Vec<String>>().join(\", \");\n+                err.span_suggestion(found_span,\n+                                    \"change the closure to take multiple arguments instead of \\\n+                                     a single tuple\",\n+                                    format!(\"|{}|\", sugg));\n+            }\n+        }\n+        if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..] {\n+            if fields.len() == found_args.len() && is_closure {\n+                let sugg = format!(\n+                    \"|({}){}|\",\n+                    found_args.iter()\n+                        .map(|arg| match arg {\n+                            ArgKind::Arg(name, _) => name.to_owned(),\n+                            _ => \"_\".to_owned(),\n+                        })\n+                        .collect::<Vec<String>>()\n+                        .join(\", \"),\n+                    // add type annotations if available\n+                    if found_args.iter().any(|arg| match arg {\n+                        ArgKind::Arg(_, ty) => ty != \"_\",\n+                        _ => false,\n+                    }) {\n+                        format!(\": ({})\",\n+                                fields.iter()\n+                                    .map(|(_, ty)| ty.to_owned())\n+                                    .collect::<Vec<String>>()\n+                                    .join(\", \"))\n+                    } else {\n+                        \"\".to_owned()\n+                    },\n+                );\n+                err.span_suggestion(found_span,\n+                                    \"change the closure to accept a tuple instead of individual \\\n+                                     arguments\",\n+                                    sugg);\n             }\n         }\n \n@@ -1331,3 +1319,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                           suggested_limit));\n     }\n }\n+\n+enum ArgKind {\n+    Arg(String, String),\n+    Tuple(Span, Vec<(String, String)>),\n+}\n+\n+impl ArgKind {\n+    fn empty() -> ArgKind {\n+        ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n+    }\n+}"}, {"sha": "59c82e06a679c1eb2133e74f3136267362664b1d", "filename": "src/librustc_back/target/aarch64_unknown_cloudabi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_cloudabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_cloudabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_cloudabi.rs?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -15,6 +15,7 @@ pub fn target() -> TargetResult {\n     let mut base = super::cloudabi_base::opts();\n     base.max_atomic_width = Some(128);\n     base.abi_blacklist = super::arm_base::abi_blacklist();\n+    base.linker = \"aarch64-unknown-cloudabi-cc\".to_string();\n \n     Ok(Target {\n         llvm_target: \"aarch64-unknown-cloudabi\".to_string(),"}, {"sha": "faa2c4fdceb9b2fce6b8b60182a03bf6c12aef45", "filename": "src/librustc_back/target/armv7_unknown_cloudabi_eabihf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_cloudabi_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_cloudabi_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_cloudabi_eabihf.rs?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -17,6 +17,7 @@ pub fn target() -> TargetResult {\n     base.max_atomic_width = Some(64);\n     base.features = \"+v7,+vfp3,+neon\".to_string();\n     base.abi_blacklist = super::arm_base::abi_blacklist();\n+    base.linker = \"armv7-unknown-cloudabi-eabihf-cc\".to_string();\n \n     Ok(Target {\n         llvm_target: \"armv7-unknown-cloudabi-eabihf\".to_string(),"}, {"sha": "e244f443d3e3a353acf2fbd70995f933de14dcb6", "filename": "src/librustc_back/target/i686_unknown_cloudabi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_cloudabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_cloudabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_cloudabi.rs?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -15,6 +15,7 @@ pub fn target() -> TargetResult {\n     let mut base = super::cloudabi_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = Some(64);\n+    base.linker = \"i686-unknown-cloudabi-cc\".to_string();\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m32\".to_string());\n     base.stack_probes = true;\n "}, {"sha": "1ce3c6444f1ea718d492ed6be6b8eca154dd7402", "filename": "src/librustc_back/target/x86_64_unknown_cloudabi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_cloudabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_cloudabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_cloudabi.rs?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -15,6 +15,7 @@ pub fn target() -> TargetResult {\n     let mut base = super::cloudabi_base::opts();\n     base.cpu = \"x86-64\".to_string();\n     base.max_atomic_width = Some(64);\n+    base.linker = \"x86_64-unknown-cloudabi-cc\".to_string();\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n     base.stack_probes = true;\n "}, {"sha": "3a18c6b8a809e0de0c15fc7ed87fe6d18a83b154", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -94,20 +94,22 @@ r##\"<!DOCTYPE html>\n                 <h2>Keyboard Shortcuts</h2>\n \n                 <dl>\n-                    <dt>?</dt>\n+                    <dt><kbd>?</kbd></dt>\n                     <dd>Show this help dialog</dd>\n-                    <dt>S</dt>\n+                    <dt><kbd>S</kbd></dt>\n                     <dd>Focus the search field</dd>\n-                    <dt>\u2191</dt>\n+                    <dt><kbd>\u2191</kbd></dt>\n                     <dd>Move up in search results</dd>\n-                    <dt>\u2193</dt>\n+                    <dt><kbd>\u2193</kbd></dt>\n                     <dd>Move down in search results</dd>\n-                    <dt>\u21b9</dt>\n+                    <dt><kbd>\u21b9</kbd></dt>\n                     <dd>Switch tab</dd>\n-                    <dt>&#9166;</dt>\n+                    <dt><kbd>&#9166;</kbd></dt>\n                     <dd>Go to active search result</dd>\n-                    <dt style=\"width:31px;\">+ / -</dt>\n-                    <dd>Collapse/expand all sections</dd>\n+                    <dt><kbd>+</kbd></dt>\n+                    <dd>Expand all sections</dd>\n+                    <dt><kbd>-</kbd></dt>\n+                    <dd>Collapse all sections</dd>\n                 </dl>\n             </div>\n "}, {"sha": "34b04de86735e60f08f7550bc52bd2049c29b9e4", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -585,18 +585,13 @@ body.blur > :not(#help) {\n \tflex: 0 0 auto;\n \tbox-shadow: 0 0 6px rgba(0,0,0,.2);\n \twidth: 550px;\n-\theight: 354px;\n+\theight: auto;\n \tborder: 1px solid;\n }\n #help dt {\n \tfloat: left;\n-\tborder-radius: 4px;\n-\tborder: 1px solid;\n-\twidth: 23px;\n-\ttext-align: center;\n \tclear: left;\n \tdisplay: block;\n-\tmargin-top: -1px;\n }\n #help dd { margin: 5px 35px; }\n #help .infos { padding-left: 0; }\n@@ -1134,3 +1129,14 @@ h3.important {\n \tleft: -42px;\n \tmargin-top: 2px;\n }\n+\n+kbd {\n+\tdisplay: inline-block;\n+\tpadding: 3px 5px;\n+\tfont: 15px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n+\tline-height: 10px;\n+\tvertical-align: middle;\n+\tborder: solid 1px;\n+\tborder-radius: 3px;\n+\tbox-shadow: inset 0 -1px 0;\n+}"}, {"sha": "bd74056242442e2a66b3f3fd63c2d06a52ac85ed", "filename": "src/librustdoc/html/static/styles/main.css", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -194,11 +194,6 @@ a.test-arrow {\n \tborder-color: #bfbfbf;\n }\n \n-#help dt {\n-\tborder-color: #bfbfbf;\n-\tbackground: #fff;\n-}\n-\n .since {\n \tcolor: grey;\n }\n@@ -348,3 +343,11 @@ pre.ignore:hover, .information:hover + pre.ignore {\n \t\tborder-bottom-color: #e0e0e0;\n \t}\n }\n+\n+kbd {\n+\tcolor: #444d56;\n+\tbackground-color: #fafbfc;\n+\tborder-color: #d1d5da;\n+\tborder-bottom-color: #c6cbd1;\n+\tbox-shadow-color: #c6cbd1;\n+}"}, {"sha": "e9a150f34a51efdc31afe6b251d0ec780150a2fa", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -64,11 +64,11 @@\n //! * You want a map, with no extra functionality.\n //!\n //! ### Use a `BTreeMap` when:\n+//! * You want a map sorted by its keys.\n+//! * You want to be able to get a range of entries on-demand.\n //! * You're interested in what the smallest or largest key-value pair is.\n //! * You want to find the largest or smallest key that is smaller or larger\n //!   than something.\n-//! * You want to be able to get all of the entries in order on-demand.\n-//! * You want a map sorted by its keys.\n //!\n //! ### Use the `Set` variant of any of these `Map`s when:\n //! * You just want to remember which keys you've seen."}, {"sha": "fa430939f058c45e7e3c0ffc86ab0138bd89ee4c", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -12,7 +12,9 @@ use fmt;\n use hash;\n use io;\n use mem;\n-use net::{lookup_host, ntoh, hton, IpAddr, Ipv4Addr, Ipv6Addr};\n+use net::{ntoh, hton, IpAddr, Ipv4Addr, Ipv6Addr};\n+#[allow(deprecated)]\n+use net::lookup_host;\n use option;\n use sys::net::netc as c;\n use sys_common::{FromInner, AsInner, IntoInner};\n@@ -845,6 +847,7 @@ impl ToSocketAddrs for (Ipv6Addr, u16) {\n     }\n }\n \n+#[allow(deprecated)]\n fn resolve_socket_addr(s: &str, p: u16) -> io::Result<vec::IntoIter<SocketAddr>> {\n     let ips = lookup_host(s)?;\n     let v: Vec<_> = ips.map(|mut a| { a.set_port(p); a }).collect();"}, {"sha": "eb0e2e13b4cd2099100c85cdccb8f9c13879adb5", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -134,12 +134,15 @@ fn each_addr<A: ToSocketAddrs, F, T>(addr: A, mut f: F) -> io::Result<T>\n                                               iterator and returning socket \\\n                                               addresses\",\n            issue = \"27705\")]\n+#[rustc_deprecated(since = \"1.25\", reason = \"Use the ToSocketAddrs trait instead\")]\n pub struct LookupHost(net_imp::LookupHost);\n \n #[unstable(feature = \"lookup_host\", reason = \"unsure about the returned \\\n                                               iterator and returning socket \\\n                                               addresses\",\n            issue = \"27705\")]\n+#[rustc_deprecated(since = \"1.25\", reason = \"Use the ToSocketAddrs trait instead\")]\n+#[allow(deprecated)]\n impl Iterator for LookupHost {\n     type Item = SocketAddr;\n     fn next(&mut self) -> Option<SocketAddr> { self.0.next() }\n@@ -149,6 +152,8 @@ impl Iterator for LookupHost {\n                                               iterator and returning socket \\\n                                               addresses\",\n            issue = \"27705\")]\n+#[rustc_deprecated(since = \"1.25\", reason = \"Use the ToSocketAddrs trait instead\")]\n+#[allow(deprecated)]\n impl fmt::Debug for LookupHost {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"LookupHost { .. }\")\n@@ -181,6 +186,8 @@ impl fmt::Debug for LookupHost {\n                                               iterator and returning socket \\\n                                               addresses\",\n            issue = \"27705\")]\n+#[rustc_deprecated(since = \"1.25\", reason = \"Use the ToSocketAddrs trait instead\")]\n+#[allow(deprecated)]\n pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n     net_imp::lookup_host(host).map(LookupHost)\n }"}, {"sha": "ed102c2949ede7a667afc435e9f7d1c0a4ea88a1", "filename": "src/libstd/path.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -1869,7 +1869,11 @@ impl Path {\n     ///\n     /// let path = Path::new(\"/test/haha/foo.txt\");\n     ///\n+    /// assert_eq!(path.strip_prefix(\"/\"), Ok(Path::new(\"test/haha/foo.txt\")));\n     /// assert_eq!(path.strip_prefix(\"/test\"), Ok(Path::new(\"haha/foo.txt\")));\n+    /// assert_eq!(path.strip_prefix(\"/test/\"), Ok(Path::new(\"haha/foo.txt\")));\n+    /// assert_eq!(path.strip_prefix(\"/test/haha/foo.txt\"), Ok(Path::new(\"\")));\n+    /// assert_eq!(path.strip_prefix(\"/test/haha/foo.txt/\"), Ok(Path::new(\"\")));\n     /// assert_eq!(path.strip_prefix(\"test\").is_ok(), false);\n     /// assert_eq!(path.strip_prefix(\"/haha\").is_ok(), false);\n     /// ```\n@@ -1900,6 +1904,9 @@ impl Path {\n     /// let path = Path::new(\"/etc/passwd\");\n     ///\n     /// assert!(path.starts_with(\"/etc\"));\n+    /// assert!(path.starts_with(\"/etc/\"));\n+    /// assert!(path.starts_with(\"/etc/passwd\"));\n+    /// assert!(path.starts_with(\"/etc/passwd/\"));\n     ///\n     /// assert!(!path.starts_with(\"/e\"));\n     /// ```"}, {"sha": "0f6da002dda3759ce4c1db8a9e799534d6c87428", "filename": "src/test/run-pass/result-opt-conversions.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Ftest%2Frun-pass%2Fresult-opt-conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Ftest%2Frun-pass%2Fresult-opt-conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresult-opt-conversions.rs?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(transpose_result)]\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+struct BadNumErr;\n+\n+fn try_num(x: i32) -> Result<i32, BadNumErr> {\n+    if x <= 5 {\n+        Ok(x + 1)\n+    } else {\n+        Err(BadNumErr)\n+    }\n+}\n+\n+type ResOpt = Result<Option<i32>, BadNumErr>;\n+type OptRes = Option<Result<i32, BadNumErr>>;\n+\n+fn main() {\n+    let mut x: ResOpt = Ok(Some(5));\n+    let mut y: OptRes = Some(Ok(5));\n+    assert_eq!(x, y.transpose());\n+    assert_eq!(x.transpose(), y);\n+\n+    x = Ok(None);\n+    y = None;\n+    assert_eq!(x, y.transpose());\n+    assert_eq!(x.transpose(), y);\n+\n+    x = Err(BadNumErr);\n+    y = Some(Err(BadNumErr));\n+    assert_eq!(x, y.transpose());\n+    assert_eq!(x.transpose(), y);\n+\n+    let res: Result<Vec<i32>, BadNumErr> =\n+        (0..10)\n+            .map(|x| {\n+                let y = try_num(x)?;\n+                Ok(if y % 2 == 0 {\n+                    Some(y - 1)\n+                } else {\n+                    None\n+                })\n+            })\n+            .filter_map(Result::transpose)\n+            .collect();\n+\n+    assert_eq!(res, Err(BadNumErr))\n+}"}, {"sha": "96e5201716c7173f2be48a72aac924ed94d650ab", "filename": "src/test/ui/mismatched_types/closure-arg-count.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -18,6 +18,8 @@ fn main() {\n     //~^ ERROR closure is expected to take\n     [1, 2, 3].sort_by(|(tuple, tuple2)| panic!());\n     //~^ ERROR closure is expected to take\n+    [1, 2, 3].sort_by(|(tuple, tuple2): (usize, _)| panic!());\n+    //~^ ERROR closure is expected to take\n     f(|| panic!());\n     //~^ ERROR closure is expected to take\n \n@@ -32,6 +34,9 @@ fn main() {\n     let bar = |i, x, y| i;\n     let _it = vec![1, 2, 3].into_iter().enumerate().map(bar);\n     //~^ ERROR closure is expected to take\n+    let _it = vec![1, 2, 3].into_iter().enumerate().map(qux);\n+    //~^ ERROR function is expected to take\n }\n \n fn foo() {}\n+fn qux(x: usize, y: usize) {}"}, {"sha": "be00ee4d74e7eededd2590ec6468ed33a62e651d", "filename": "src/test/ui/mismatched_types/closure-arg-count.stderr", "status": "modified", "additions": 57, "deletions": 24, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -14,18 +14,34 @@ error[E0593]: closure is expected to take 2 arguments, but it takes 1 argument\n    |               |\n    |               expected closure that takes 2 arguments\n \n-error[E0593]: closure is expected to take 2 arguments, but it takes 1 argument\n+error[E0593]: closure is expected to take 2 distinct arguments, but it takes a single 2-tuple as argument\n   --> $DIR/closure-arg-count.rs:19:15\n    |\n 19 |     [1, 2, 3].sort_by(|(tuple, tuple2)| panic!());\n-   |               ^^^^^^^ ----------------- takes 1 argument\n+   |               ^^^^^^^ ----------------- takes a single 2-tuple as argument\n    |               |\n-   |               expected closure that takes 2 arguments\n+   |               expected closure that takes 2 distinct arguments\n+help: change the closure to take multiple arguments instead of a single tuple\n+   |\n+19 |     [1, 2, 3].sort_by(|tuple, tuple2| panic!());\n+   |                       ^^^^^^^^^^^^^^^\n+\n+error[E0593]: closure is expected to take 2 distinct arguments, but it takes a single 2-tuple as argument\n+  --> $DIR/closure-arg-count.rs:21:15\n+   |\n+21 |     [1, 2, 3].sort_by(|(tuple, tuple2): (usize, _)| panic!());\n+   |               ^^^^^^^ ----------------------------- takes a single 2-tuple as argument\n+   |               |\n+   |               expected closure that takes 2 distinct arguments\n+help: change the closure to take multiple arguments instead of a single tuple\n+   |\n+21 |     [1, 2, 3].sort_by(|tuple, tuple2| panic!());\n+   |                       ^^^^^^^^^^^^^^^\n \n error[E0593]: closure is expected to take 1 argument, but it takes 0 arguments\n-  --> $DIR/closure-arg-count.rs:21:5\n+  --> $DIR/closure-arg-count.rs:23:5\n    |\n-21 |     f(|| panic!());\n+23 |     f(|| panic!());\n    |     ^ -- takes 0 arguments\n    |     |\n    |     expected closure that takes 1 argument\n@@ -36,46 +52,63 @@ note: required by `f`\n 13 | fn f<F: Fn<usize>>(_: F) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0593]: closure is expected to take a single tuple as argument, but it takes 2 distinct arguments\n-  --> $DIR/closure-arg-count.rs:24:53\n+error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 2 distinct arguments\n+  --> $DIR/closure-arg-count.rs:26:53\n    |\n-24 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x| i);\n-   |                                                     ^^^ ------ help: consider changing the closure to accept a tuple: `|(i, x)|`\n+26 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x| i);\n+   |                                                     ^^^ ------ takes 2 distinct arguments\n    |                                                     |\n-   |                                                     expected closure that takes a single tuple as argument\n+   |                                                     expected closure that takes a single 2-tuple as argument\n+help: change the closure to accept a tuple instead of individual arguments\n+   |\n+26 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|(i, x)| i);\n+   |                                                         ^^^^^^^^\n \n-error[E0593]: closure is expected to take a single tuple as argument, but it takes 2 distinct arguments\n-  --> $DIR/closure-arg-count.rs:26:53\n+error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 2 distinct arguments\n+  --> $DIR/closure-arg-count.rs:28:53\n    |\n-26 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i: usize, x| i);\n-   |                                                     ^^^ ------------- help: consider changing the closure to accept a tuple: `|(i, x): (usize, _)|`\n+28 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i: usize, x| i);\n+   |                                                     ^^^ ------------- takes 2 distinct arguments\n    |                                                     |\n-   |                                                     expected closure that takes a single tuple as argument\n+   |                                                     expected closure that takes a single 2-tuple as argument\n+help: change the closure to accept a tuple instead of individual arguments\n+   |\n+28 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|(i, x)| i);\n+   |                                                         ^^^^^^^^\n \n error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 3 distinct arguments\n-  --> $DIR/closure-arg-count.rs:28:53\n+  --> $DIR/closure-arg-count.rs:30:53\n    |\n-28 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x, y| i);\n+30 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x, y| i);\n    |                                                     ^^^ --------- takes 3 distinct arguments\n    |                                                     |\n    |                                                     expected closure that takes a single 2-tuple as argument\n \n error[E0593]: function is expected to take a single 2-tuple as argument, but it takes 0 arguments\n-  --> $DIR/closure-arg-count.rs:30:53\n+  --> $DIR/closure-arg-count.rs:32:53\n    |\n-30 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(foo);\n+32 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(foo);\n    |                                                     ^^^ expected function that takes a single 2-tuple as argument\n ...\n-37 | fn foo() {}\n+41 | fn foo() {}\n    | -------- takes 0 arguments\n \n error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 3 distinct arguments\n-  --> $DIR/closure-arg-count.rs:33:53\n+  --> $DIR/closure-arg-count.rs:35:53\n    |\n-32 |     let bar = |i, x, y| i;\n+34 |     let bar = |i, x, y| i;\n    |               --------- takes 3 distinct arguments\n-33 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(bar);\n+35 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(bar);\n    |                                                     ^^^ expected closure that takes a single 2-tuple as argument\n \n-error: aborting due to 9 previous errors\n+error[E0593]: function is expected to take a single 2-tuple as argument, but it takes 2 distinct arguments\n+  --> $DIR/closure-arg-count.rs:37:53\n+   |\n+37 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(qux);\n+   |                                                     ^^^ expected function that takes a single 2-tuple as argument\n+...\n+42 | fn qux(x: usize, y: usize) {}\n+   | -------------------------- takes 2 distinct arguments\n+\n+error: aborting due to 11 previous errors\n "}, {"sha": "eee2902bfb6f736ccdd1a94af68293af1a1544b5", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -69,6 +69,7 @@ fn filter_dirs(path: &Path) -> bool {\n         \"src/tools/miri\",\n         \"src/librustc/mir/interpret\",\n         \"src/librustc_mir/interpret\",\n+        \"src/target\",\n     ];\n     skip.iter().any(|p| path.ends_with(p))\n }"}]}