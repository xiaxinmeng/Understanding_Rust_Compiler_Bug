{"sha": "b62543f756bb6219dcc1025e21f5e209349b6ed6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MjU0M2Y3NTZiYjYyMTlkY2MxMDI1ZTIxZjVlMjA5MzQ5YjZlZDY=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-11-13T06:27:42Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-11-13T06:27:42Z"}, "message": "literal representation restructure 7\n\nReplace `do_lint` with `get_group_size`. Return `None` if there are no\ngroups.", "tree": {"sha": "88840a82a633de6b8ac2cedbd82def339b36c14b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88840a82a633de6b8ac2cedbd82def339b36c14b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b62543f756bb6219dcc1025e21f5e209349b6ed6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b62543f756bb6219dcc1025e21f5e209349b6ed6", "html_url": "https://github.com/rust-lang/rust/commit/b62543f756bb6219dcc1025e21f5e209349b6ed6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b62543f756bb6219dcc1025e21f5e209349b6ed6/comments", "author": null, "committer": null, "parents": [{"sha": "abf62d8011cb8a4c66f6f9b4fd156d04fcfeb8f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/abf62d8011cb8a4c66f6f9b4fd156d04fcfeb8f2", "html_url": "https://github.com/rust-lang/rust/commit/abf62d8011cb8a4c66f6f9b4fd156d04fcfeb8f2"}], "stats": {"total": 67, "additions": 28, "deletions": 39}, "files": [{"sha": "42a75d1e3002c209eb9e73374b156f680923a964", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/b62543f756bb6219dcc1025e21f5e209349b6ed6/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62543f756bb6219dcc1025e21f5e209349b6ed6/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=b62543f756bb6219dcc1025e21f5e209349b6ed6", "patch": "@@ -397,10 +397,9 @@ impl LiteralDigitGrouping {\n \n                     let (integer, fraction, _) = digit_info.split_digit_parts();\n \n-                    let integral_group_size = Self::do_lint(integer, in_macro)?;\n+                    let integral_group_size = Self::get_group_size(integer.split('_'), in_macro)?;\n                     if let Some(fraction) = fraction {\n-                        let fractional_part = fraction.chars().rev().collect::<String>();\n-                        let fractional_group_size = Self::do_lint(&fractional_part, in_macro)?;\n+                        let fractional_group_size = Self::get_group_size(fraction.rsplit('_'), in_macro)?;\n \n                         let consistent = Self::parts_consistent(integral_group_size,\n                                                                 fractional_group_size,\n@@ -425,53 +424,43 @@ impl LiteralDigitGrouping {\n     /// parts, and the length\n     /// of both parts, determine if the digits have been grouped consistently.\n     #[must_use]\n-    fn parts_consistent(int_group_size: usize, frac_group_size: usize, int_size: usize, frac_size: usize) -> bool {\n+    fn parts_consistent(\n+        int_group_size: Option<usize>,\n+        frac_group_size: Option<usize>,\n+        int_size: usize,\n+        frac_size: usize,\n+    ) -> bool {\n         match (int_group_size, frac_group_size) {\n             // No groups on either side of decimal point - trivially consistent.\n-            (0, 0) => true,\n+            (None, None) => true,\n             // Integral part has grouped digits, fractional part does not.\n-            (_, 0) => frac_size <= int_group_size,\n+            (Some(int_group_size), None) => frac_size <= int_group_size,\n             // Fractional part has grouped digits, integral part does not.\n-            (0, _) => int_size <= frac_group_size,\n+            (None, Some(frac_group_size)) => int_size <= frac_group_size,\n             // Both parts have grouped digits. Groups should be the same size.\n-            (_, _) => int_group_size == frac_group_size,\n+            (Some(int_group_size), Some(frac_group_size)) => int_group_size == frac_group_size,\n         }\n     }\n \n-    /// Performs lint on `digits` (no decimal point) and returns the group\n-    /// size on success or `WarningType` when emitting a warning.\n-    fn do_lint(digits: &str, in_macro: bool) -> Result<usize, WarningType> {\n-        // Grab underscore indices with respect to the units digit.\n-        let underscore_positions: Vec<usize> = digits\n-            .chars()\n-            .rev()\n-            .enumerate()\n-            .filter_map(|(idx, digit)| if digit == '_' { Some(idx) } else { None })\n-            .collect();\n-\n-        if underscore_positions.is_empty() {\n-            // Check if literal needs underscores.\n-            if !in_macro && digits.len() > 5 {\n-                Err(WarningType::UnreadableLiteral)\n+    /// Returns the size of the digit groups (or None if ungrouped) if successful,\n+    /// otherwise returns a `WarningType` for linting.\n+    fn get_group_size<'a>(groups: impl Iterator<Item = &'a str>, in_macro: bool) -> Result<Option<usize>, WarningType> {\n+        let mut groups = groups.map(str::len);\n+\n+        let first = groups.next().expect(\"At least one group\");\n+\n+        if let Some(second) = groups.next() {\n+            if !groups.all(|x| x == second) || first > second {\n+                Err(WarningType::InconsistentDigitGrouping)\n+            } else if second > 4 {\n+                Err(WarningType::LargeDigitGroups)\n             } else {\n-                Ok(0)\n+                Ok(Some(second))\n             }\n+        } else if first > 5 && !in_macro {\n+            Err(WarningType::UnreadableLiteral)\n         } else {\n-            // Check consistency and the sizes of the groups.\n-            let group_size = underscore_positions[0];\n-            let consistent = underscore_positions\n-                .windows(2)\n-                .all(|ps| ps[1] - ps[0] == group_size + 1)\n-                // number of digits to the left of the last group cannot be bigger than group size.\n-                && (digits.len() - underscore_positions.last()\n-                                                       .expect(\"there's at least one element\") <= group_size + 1);\n-\n-            if !consistent {\n-                return Err(WarningType::InconsistentDigitGrouping);\n-            } else if group_size > 4 {\n-                return Err(WarningType::LargeDigitGroups);\n-            }\n-            Ok(group_size)\n+            Ok(None)\n         }\n     }\n }"}]}