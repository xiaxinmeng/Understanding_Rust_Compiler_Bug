{"sha": "12899e73a08ba86ff65c0e64eea489203446b58d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyODk5ZTczYTA4YmE4NmZmNjVjMGU2NGVlYTQ4OTIwMzQ0NmI1OGQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-07-16T08:43:38Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-07-16T08:43:38Z"}, "message": "Rollup merge of #26950 - AlisdairO:memset, r=alexcrichton\n\n In general, it's undesirable to have read_to_end use a buffer with uninitialized memory, as that could lead to undefined behaviour in the event of a bad Read implementation.  Since we control the implementations of Read for Stdin and File, however, it should be okay for us to specialise them to improve performance.  This PR is to do that!\n\nAdds some unsafe code to deal with creating the buffers.  Since the read_to_end function needed to be used from the io and fs crates, I moved it into a newly-created sys::common::io module.  Alternatively we could expose the new read_to_end functions to allow people to create their own read_to_end implementations for code they trust.\n\nBenchmarks:\n\nRead a 2.5MB file:\nsys_common::io::tests::bench_init_file      ... bench:  27,473,317 ns/iter (+/- 2,490,767)\nsys_common::io::tests::bench_uninit_file    ... bench:  25,611,793 ns/iter (+/- 2,137,387)\n\nRead a buffer full of constant values\nsys_common::io::tests::bench_uninitialized  ... bench:  12,877,645 ns/iter (+/- 931,025)\nsys_common::io::tests::bench_zeroed         ... bench:  18,581,082 ns/iter (+/- 1,541,108)\n\nSo, approx a 7% speedup for file reading, which I think is worthwhile.", "tree": {"sha": "53d2565a123c5e64c0c3ef67eb23e58b99d71909", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53d2565a123c5e64c0c3ef67eb23e58b99d71909"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12899e73a08ba86ff65c0e64eea489203446b58d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12899e73a08ba86ff65c0e64eea489203446b58d", "html_url": "https://github.com/rust-lang/rust/commit/12899e73a08ba86ff65c0e64eea489203446b58d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12899e73a08ba86ff65c0e64eea489203446b58d/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1da1a46d563135233dec770abbe67fccc70bd434", "url": "https://api.github.com/repos/rust-lang/rust/commits/1da1a46d563135233dec770abbe67fccc70bd434", "html_url": "https://github.com/rust-lang/rust/commit/1da1a46d563135233dec770abbe67fccc70bd434"}, {"sha": "98f287240ff9518c1ea5519c5cd03dc2ba6d4452", "url": "https://api.github.com/repos/rust-lang/rust/commits/98f287240ff9518c1ea5519c5cd03dc2ba6d4452", "html_url": "https://github.com/rust-lang/rust/commit/98f287240ff9518c1ea5519c5cd03dc2ba6d4452"}], "stats": {"total": 166, "additions": 166, "deletions": 0}, "files": [{"sha": "2c78b2894311d641d76cea2184585076b3291670", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12899e73a08ba86ff65c0e64eea489203446b58d/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12899e73a08ba86ff65c0e64eea489203446b58d/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=12899e73a08ba86ff65c0e64eea489203446b58d", "patch": "@@ -25,6 +25,7 @@ use io::{self, SeekFrom, Seek, Read, Write};\n use path::{Path, PathBuf};\n use sys::fs as fs_imp;\n use sys_common::{AsInnerMut, FromInner, AsInner};\n+use sys_common::io::read_to_end_uninitialized;\n use vec::Vec;\n \n /// A reference to an open file on the filesystem.\n@@ -328,6 +329,9 @@ impl Read for File {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        unsafe { read_to_end_uninitialized(self, buf) }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for File {"}, {"sha": "d0453c2e77692145aec4d2742935c92ed62864e1", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/12899e73a08ba86ff65c0e64eea489203446b58d/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12899e73a08ba86ff65c0e64eea489203446b58d/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=12899e73a08ba86ff65c0e64eea489203446b58d", "patch": "@@ -906,6 +906,8 @@ mod tests {\n     use io::prelude::*;\n     use io;\n     use super::Cursor;\n+    use test;\n+    use super::repeat;\n \n     #[test]\n     fn read_until() {\n@@ -1024,4 +1026,13 @@ mod tests {\n         let mut buf = [0; 1];\n         assert_eq!(0, R.take(0).read(&mut buf).unwrap());\n     }\n+\n+    #[bench]\n+    fn bench_read_to_end(b: &mut test::Bencher) {\n+        b.iter(|| {\n+            let mut lr = repeat(1).take(10000000);\n+            let mut vec = Vec::with_capacity(1024);\n+            super::read_to_end(&mut lr, &mut vec);\n+        });\n+    }\n }"}, {"sha": "d8b7c8a282ca297760d90d2b18ebf655efba77fe", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12899e73a08ba86ff65c0e64eea489203446b58d/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12899e73a08ba86ff65c0e64eea489203446b58d/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=12899e73a08ba86ff65c0e64eea489203446b58d", "patch": "@@ -18,6 +18,7 @@ use io::lazy::Lazy;\n use io::{self, BufReader, LineWriter};\n use sync::{Arc, Mutex, MutexGuard};\n use sys::stdio;\n+use sys_common::io::{read_to_end_uninitialized};\n use sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n use libc;\n \n@@ -277,6 +278,9 @@ impl<'a> Read for StdinLock<'a> {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        unsafe { read_to_end_uninitialized(self, buf) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "66c8403b2685e244775dfdaa777ec38b615ecde7", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12899e73a08ba86ff65c0e64eea489203446b58d/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12899e73a08ba86ff65c0e64eea489203446b58d/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=12899e73a08ba86ff65c0e64eea489203446b58d", "patch": "@@ -19,6 +19,7 @@ use io;\n use net::{ToSocketAddrs, SocketAddr, Shutdown};\n use sys_common::net as net_imp;\n use sys_common::{AsInner, FromInner};\n+use sys_common::io::read_to_end_uninitialized;\n use time::Duration;\n \n /// A structure which represents a TCP stream between a local socket and a\n@@ -189,6 +190,9 @@ impl TcpStream {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        unsafe { read_to_end_uninitialized(self, buf) }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for TcpStream {\n@@ -198,6 +202,9 @@ impl Write for TcpStream {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Read for &'a TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        unsafe { read_to_end_uninitialized(self, buf) }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for &'a TcpStream {"}, {"sha": "151d853fc9f7e033576df32ea0a093db9a0412c5", "filename": "src/libstd/sys/common/io.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/12899e73a08ba86ff65c0e64eea489203446b58d/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12899e73a08ba86ff65c0e64eea489203446b58d/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs?ref=12899e73a08ba86ff65c0e64eea489203446b58d", "patch": "@@ -0,0 +1,139 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+use prelude::v1::*;\n+use io;\n+use io::ErrorKind;\n+use io::Read;\n+use slice::from_raw_parts_mut;\n+\n+// Provides read_to_end functionality over an uninitialized buffer.\n+// This function is unsafe because it calls the underlying\n+// read function with a slice into uninitialized memory. The default\n+// implementation of read_to_end for readers will zero out new memory in\n+// the buf before passing it to read, but avoiding this zero can often\n+// lead to a fairly significant performance win.\n+//\n+// Implementations using this method have to adhere to two guarantees:\n+//  *  The implementation of read never reads the buffer provided.\n+//  *  The implementation of read correctly reports how many bytes were written.\n+pub unsafe fn read_to_end_uninitialized(r: &mut Read, buf: &mut Vec<u8>) -> io::Result<usize> {\n+\n+    let start_len = buf.len();\n+    buf.reserve(16);\n+\n+    // Always try to read into the empty space of the vector (from the length to the capacity).\n+    // If the vector ever fills up then we reserve an extra byte which should trigger the normal\n+    // reallocation routines for the vector, which will likely double the size.\n+    //\n+    // This function is similar to the read_to_end function in std::io, but the logic about\n+    // reservations and slicing is different enough that this is duplicated here.\n+    loop {\n+        if buf.len() == buf.capacity() {\n+            buf.reserve(1);\n+        }\n+\n+        let buf_slice = from_raw_parts_mut(buf.as_mut_ptr().offset(buf.len() as isize),\n+                                           buf.capacity() - buf.len());\n+\n+        match r.read(buf_slice) {\n+            Ok(0) => { return Ok(buf.len() - start_len); }\n+            Ok(n) => { let len = buf.len() + n; buf.set_len(len); },\n+            Err(ref e) if e.kind() == ErrorKind::Interrupted => { }\n+            Err(e) => { return Err(e); }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use io::prelude::*;\n+    use super::*;\n+    use io;\n+    use io::{ErrorKind, Take, Repeat, repeat};\n+    use test;\n+    use slice::from_raw_parts;\n+\n+    struct ErrorRepeat {\n+        lr: Take<Repeat>\n+    }\n+\n+    fn error_repeat(byte: u8, limit: u64) -> ErrorRepeat {\n+        ErrorRepeat { lr: repeat(byte).take(limit) }\n+    }\n+\n+    impl Read for ErrorRepeat {\n+        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+            let ret = self.lr.read(buf);\n+            if let Ok(0) = ret {\n+                return Err(io::Error::new(ErrorKind::Other, \"\"))\n+            }\n+            ret\n+        }\n+    }\n+\n+    fn init_vec_data() -> Vec<u8> {\n+        let mut vec = vec![10u8; 200];\n+        unsafe { vec.set_len(0); }\n+        vec\n+    }\n+\n+    fn assert_all_eq(buf: &[u8], value: u8) {\n+        for n in buf {\n+            assert_eq!(*n, value);\n+        }\n+    }\n+\n+    fn validate(buf: &Vec<u8>, good_read_len: usize) {\n+        assert_all_eq(buf, 1u8);\n+        let cap = buf.capacity();\n+        let end_slice = unsafe { from_raw_parts(buf.as_ptr().offset(good_read_len as isize),\n+                                                    cap - good_read_len) };\n+        assert_all_eq(end_slice, 10u8);\n+    }\n+\n+    #[test]\n+    fn read_to_end_uninit_error() {\n+        let mut er = error_repeat(1,100);\n+        let mut vec = init_vec_data();\n+        if let Err(_) = unsafe { read_to_end_uninitialized(&mut er, &mut vec) } {\n+            validate(&vec, 100);\n+        } else {\n+            assert!(false);\n+        }\n+    }\n+\n+    #[test]\n+    fn read_to_end_uninit_zero_len_vec() {\n+        let mut er = repeat(1).take(100);\n+        let mut vec = Vec::new();\n+        let n = unsafe{ read_to_end_uninitialized(&mut er, &mut vec).unwrap() };\n+        assert_all_eq(&vec, 1u8);\n+        assert_eq!(vec.len(), n);\n+    }\n+\n+    #[test]\n+    fn read_to_end_uninit_good() {\n+        let mut er = repeat(1).take(100);\n+        let mut vec = init_vec_data();\n+        let n = unsafe{ read_to_end_uninitialized(&mut er, &mut vec).unwrap() };\n+        validate(&vec, 100);\n+        assert_eq!(vec.len(), n);\n+    }\n+\n+    #[bench]\n+    fn bench_uninitialized(b: &mut test::Bencher) {\n+        b.iter(|| {\n+            let mut lr = repeat(1).take(10000000);\n+            let mut vec = Vec::with_capacity(1024);\n+            unsafe { read_to_end_uninitialized(&mut lr, &mut vec) };\n+        });\n+    }\n+}"}, {"sha": "69c54f989175973ee851e1ef54b212bf245dd233", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/12899e73a08ba86ff65c0e64eea489203446b58d/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12899e73a08ba86ff65c0e64eea489203446b58d/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=12899e73a08ba86ff65c0e64eea489203446b58d", "patch": "@@ -16,6 +16,7 @@ pub mod backtrace;\n pub mod condvar;\n pub mod mutex;\n pub mod net;\n+pub mod io;\n pub mod poison;\n pub mod remutex;\n pub mod rwlock;"}]}