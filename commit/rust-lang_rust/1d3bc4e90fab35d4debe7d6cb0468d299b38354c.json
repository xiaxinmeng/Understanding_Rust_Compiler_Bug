{"sha": "1d3bc4e90fab35d4debe7d6cb0468d299b38354c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkM2JjNGU5MGZhYjM1ZDRkZWJlN2Q2Y2IwNDY4ZDI5OWIzODM1NGM=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-06-15T20:44:56Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-06-15T21:48:30Z"}, "message": "Changed `Layout::from_size_align` to return `Option`.\n\nAdded `unwrap` calls in all the places where I can infer that the\nconditions are met to avoid panic (or when the calling method itself\nsays it will panic in such a case).", "tree": {"sha": "980b2e38c735479fd6ebae71d85a007d4fd970e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/980b2e38c735479fd6ebae71d85a007d4fd970e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d3bc4e90fab35d4debe7d6cb0468d299b38354c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d3bc4e90fab35d4debe7d6cb0468d299b38354c", "html_url": "https://github.com/rust-lang/rust/commit/1d3bc4e90fab35d4debe7d6cb0468d299b38354c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d3bc4e90fab35d4debe7d6cb0468d299b38354c/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "066fafe2062b17fac343219e0067edbc14b774ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/066fafe2062b17fac343219e0067edbc14b774ae", "html_url": "https://github.com/rust-lang/rust/commit/066fafe2062b17fac343219e0067edbc14b774ae"}], "stats": {"total": 62, "additions": 43, "deletions": 19}, "files": [{"sha": "c308d99a72c15e6eb44c33733b0490f8728af2fd", "filename": "src/liballoc/allocator.rs", "status": "modified", "additions": 43, "deletions": 19, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1d3bc4e90fab35d4debe7d6cb0468d299b38354c/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3bc4e90fab35d4debe7d6cb0468d299b38354c/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=1d3bc4e90fab35d4debe7d6cb0468d299b38354c", "patch": "@@ -63,19 +63,21 @@ pub struct Layout {\n //  overflowing_mul as necessary).\n \n impl Layout {\n-    /// Constructs a `Layout` from a given `size` and `align`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if any of the following conditions are not met:\n+    /// Constructs a `Layout` from a given `size` and `align`,\n+    /// or returns `None` if either of the following conditions\n+    /// are not met:\n     ///\n     /// * `align` must be a power of two,\n     ///\n     /// * `size`, when rounded up to the nearest multiple of `align`,\n     ///    must not overflow (i.e. the rounded value must be less than\n     ///    `usize::MAX`).\n-    pub fn from_size_align(size: usize, align: usize) -> Layout {\n-        assert!(align.is_power_of_two()); // (this implies align != 0.)\n+    pub fn from_size_align(size: usize, align: usize) -> Option<Layout> {\n+        if !align.is_power_of_two() {\n+            return None;\n+        }\n+\n+        // (power-of-two implies align != 0.)\n \n         // Rounded up size is:\n         //   size_rounded_up = (size + align - 1) & !(align - 1);\n@@ -89,9 +91,11 @@ impl Layout {\n         //\n         // Above implies that checking for summation overflow is both\n         // necessary and sufficient.\n-        assert!(size <= usize::MAX - (align - 1));\n+        if size > usize::MAX - (align - 1) {\n+            return None;\n+        }\n \n-        Layout { size: size, align: align }\n+        Some(Layout { size: size, align: align })\n     }\n \n     /// The minimum size in bytes for a memory block of this layout.\n@@ -103,15 +107,15 @@ impl Layout {\n     /// Constructs a `Layout` suitable for holding a value of type `T`.\n     pub fn new<T>() -> Self {\n         let (size, align) = size_align::<T>();\n-        Layout::from_size_align(size, align)\n+        Layout::from_size_align(size, align).unwrap()\n     }\n \n     /// Produces layout describing a record that could be used to\n     /// allocate backing structure for `T` (which could be a trait\n     /// or other unsized type like a slice).\n     pub fn for_value<T: ?Sized>(t: &T) -> Self {\n         let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n-        Layout::from_size_align(size, align)\n+        Layout::from_size_align(size, align).unwrap()\n     }\n \n     /// Creates a layout describing the record that can hold a value\n@@ -128,10 +132,10 @@ impl Layout {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `align` is not a power of two.\n+    /// Panics if the combination of `self.size` and the given `align`\n+    /// violates the conditions listed in `from_size_align`.\n     pub fn align_to(&self, align: usize) -> Self {\n-        assert!(align.is_power_of_two());\n-        Layout::from_size_align(self.size, cmp::max(self.align, align))\n+        Layout::from_size_align(self.size, cmp::max(self.align, align)).unwrap()\n     }\n \n     /// Returns the amount of padding we must insert after `self`\n@@ -193,7 +197,12 @@ impl Layout {\n             None => return None,\n             Some(alloc_size) => alloc_size,\n         };\n-        Some((Layout::from_size_align(alloc_size, self.align), padded_size))\n+\n+        // We can assume that `self.align` is a power-of-two.\n+        // Furthermore, `alloc_size` has alreayd been rounded up\n+        // to a multiple of `self.align`; therefore, the call\n+        // to `Layout::from_size_align` below should never panic.\n+        Some((Layout::from_size_align(alloc_size, self.align).unwrap(), padded_size))\n     }\n \n     /// Creates a layout describing the record for `self` followed by\n@@ -209,8 +218,13 @@ impl Layout {\n     /// On arithmetic overflow, returns `None`.\n     pub fn extend(&self, next: Self) -> Option<(Self, usize)> {\n         let new_align = cmp::max(self.align, next.align);\n-        let realigned = Layout::from_size_align(self.size, new_align);\n+        let realigned = match Layout::from_size_align(self.size, new_align) {\n+            None => return None,\n+            Some(l) => l,\n+        };\n+\n         let pad = realigned.padding_needed_for(next.align);\n+\n         let offset = match self.size.checked_add(pad) {\n             None => return None,\n             Some(offset) => offset,\n@@ -219,7 +233,12 @@ impl Layout {\n             None => return None,\n             Some(new_size) => new_size,\n         };\n-        Some((Layout::from_size_align(new_size, new_align), offset))\n+\n+        let layout = match Layout::from_size_align(new_size, new_align) {\n+            None => return None,\n+            Some(l) => l,\n+        };\n+        Some((layout, offset))\n     }\n \n     /// Creates a layout describing the record for `n` instances of\n@@ -239,7 +258,8 @@ impl Layout {\n             None => return None,\n             Some(scaled) => scaled,\n         };\n-        Some(Layout::from_size_align(size, self.align))\n+\n+        Layout::from_size_align(size, self.align)\n     }\n \n     /// Creates a layout describing the record for `self` followed by\n@@ -262,7 +282,11 @@ impl Layout {\n             None => return None,\n             Some(new_size) => new_size,\n         };\n-        Some((Layout::from_size_align(new_size, self.align), self.size()))\n+        let layout = match Layout::from_size_align(new_size, self.align) {\n+            None => return None,\n+            Some(l) => l,\n+        };\n+        Some((layout, self.size()))\n     }\n \n     /// Creates a layout describing the record for a `[T; n]`."}]}