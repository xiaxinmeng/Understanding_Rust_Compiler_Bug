{"sha": "7995d5cda4cd5154def40770f4527e7867f37c1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5OTVkNWNkYTRjZDUxNTRkZWY0MDc3MGY0NTI3ZTc4NjdmMzdjMWE=", "commit": {"author": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2020-09-19T12:05:42Z"}, "committer": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2020-09-21T01:58:30Z"}, "message": "Moved Inherited struct to own file", "tree": {"sha": "5bb52dfe936580ef7ca8ad79d22a813af0a9a7b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bb52dfe936580ef7ca8ad79d22a813af0a9a7b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7995d5cda4cd5154def40770f4527e7867f37c1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7995d5cda4cd5154def40770f4527e7867f37c1a", "html_url": "https://github.com/rust-lang/rust/commit/7995d5cda4cd5154def40770f4527e7867f37c1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7995d5cda4cd5154def40770f4527e7867f37c1a/comments", "author": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45fdf97d1131324b32510ab012825ccf600e947a", "url": "https://api.github.com/repos/rust-lang/rust/commits/45fdf97d1131324b32510ab012825ccf600e947a", "html_url": "https://github.com/rust-lang/rust/commit/45fdf97d1131324b32510ab012825ccf600e947a"}], "stats": {"total": 328, "additions": 173, "deletions": 155}, "files": [{"sha": "7e580485c3de4c5540127031bcb5209561ecb990", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/7995d5cda4cd5154def40770f4527e7867f37c1a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7995d5cda4cd5154def40770f4527e7867f37c1a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=7995d5cda4cd5154def40770f4527e7867f37c1a", "patch": "@@ -0,0 +1,167 @@\n+use super::callee::DeferredCallResolution;\n+use super::MaybeInProgressTables;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{DefIdMap, LocalDefId};\n+use rustc_hir::HirIdMap;\n+use rustc_infer::infer;\n+use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n+use rustc_middle::ty::fold::TypeFoldable;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::{self, Span};\n+use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::opaque_types::OpaqueTypeDecl;\n+use rustc_trait_selection::traits::{self, TraitEngine, TraitEngineExt};\n+\n+use std::cell::RefCell;\n+use std::ops::Deref;\n+\n+/// Closures defined within the function. For example:\n+///\n+///     fn foo() {\n+///         bar(move|| { ... })\n+///     }\n+///\n+/// Here, the function `foo()` and the closure passed to\n+/// `bar()` will each have their own `FnCtxt`, but they will\n+/// share the inherited fields.\n+pub struct Inherited<'a, 'tcx> {\n+    pub(super) infcx: InferCtxt<'a, 'tcx>,\n+\n+    pub(super) typeck_results: super::MaybeInProgressTables<'a, 'tcx>,\n+\n+    pub(super) locals: RefCell<HirIdMap<super::LocalTy<'tcx>>>,\n+\n+    pub(super) fulfillment_cx: RefCell<Box<dyn TraitEngine<'tcx>>>,\n+\n+    // Some additional `Sized` obligations badly affect type inference.\n+    // These obligations are added in a later stage of typeck.\n+    pub(super) deferred_sized_obligations:\n+        RefCell<Vec<(Ty<'tcx>, Span, traits::ObligationCauseCode<'tcx>)>>,\n+\n+    // When we process a call like `c()` where `c` is a closure type,\n+    // we may not have decided yet whether `c` is a `Fn`, `FnMut`, or\n+    // `FnOnce` closure. In that case, we defer full resolution of the\n+    // call until upvar inference can kick in and make the\n+    // decision. We keep these deferred resolutions grouped by the\n+    // def-id of the closure, so that once we decide, we can easily go\n+    // back and process them.\n+    pub(super) deferred_call_resolutions: RefCell<DefIdMap<Vec<DeferredCallResolution<'tcx>>>>,\n+\n+    pub(super) deferred_cast_checks: RefCell<Vec<super::cast::CastCheck<'tcx>>>,\n+\n+    pub(super) deferred_generator_interiors:\n+        RefCell<Vec<(hir::BodyId, Ty<'tcx>, hir::GeneratorKind)>>,\n+\n+    // Opaque types found in explicit return types and their\n+    // associated fresh inference variable. Writeback resolves these\n+    // variables to get the concrete type, which can be used to\n+    // 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n+    pub(super) opaque_types: RefCell<DefIdMap<OpaqueTypeDecl<'tcx>>>,\n+\n+    /// A map from inference variables created from opaque\n+    /// type instantiations (`ty::Infer`) to the actual opaque\n+    /// type (`ty::Opaque`). Used during fallback to map unconstrained\n+    /// opaque type inference variables to their corresponding\n+    /// opaque type.\n+    pub(super) opaque_types_vars: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n+\n+    pub(super) body_id: Option<hir::BodyId>,\n+}\n+\n+impl<'a, 'tcx> Deref for Inherited<'a, 'tcx> {\n+    type Target = InferCtxt<'a, 'tcx>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.infcx\n+    }\n+}\n+\n+/// Helper type of a temporary returned by `Inherited::build(...)`.\n+/// Necessary because we can't write the following bound:\n+/// `F: for<'b, 'tcx> where 'tcx FnOnce(Inherited<'b, 'tcx>)`.\n+pub struct InheritedBuilder<'tcx> {\n+    infcx: infer::InferCtxtBuilder<'tcx>,\n+    def_id: LocalDefId,\n+}\n+\n+impl Inherited<'_, 'tcx> {\n+    pub fn build(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> InheritedBuilder<'tcx> {\n+        let hir_owner = tcx.hir().local_def_id_to_hir_id(def_id).owner;\n+\n+        InheritedBuilder {\n+            infcx: tcx.infer_ctxt().with_fresh_in_progress_typeck_results(hir_owner),\n+            def_id,\n+        }\n+    }\n+}\n+\n+impl<'tcx> InheritedBuilder<'tcx> {\n+    pub fn enter<F, R>(&mut self, f: F) -> R\n+    where\n+        F: for<'a> FnOnce(Inherited<'a, 'tcx>) -> R,\n+    {\n+        let def_id = self.def_id;\n+        self.infcx.enter(|infcx| f(Inherited::new(infcx, def_id)))\n+    }\n+}\n+\n+impl Inherited<'a, 'tcx> {\n+    pub(super) fn new(infcx: InferCtxt<'a, 'tcx>, def_id: LocalDefId) -> Self {\n+        let tcx = infcx.tcx;\n+        let item_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        let body_id = tcx.hir().maybe_body_owned_by(item_id);\n+\n+        Inherited {\n+            typeck_results: MaybeInProgressTables {\n+                maybe_typeck_results: infcx.in_progress_typeck_results,\n+            },\n+            infcx,\n+            fulfillment_cx: RefCell::new(TraitEngine::new(tcx)),\n+            locals: RefCell::new(Default::default()),\n+            deferred_sized_obligations: RefCell::new(Vec::new()),\n+            deferred_call_resolutions: RefCell::new(Default::default()),\n+            deferred_cast_checks: RefCell::new(Vec::new()),\n+            deferred_generator_interiors: RefCell::new(Vec::new()),\n+            opaque_types: RefCell::new(Default::default()),\n+            opaque_types_vars: RefCell::new(Default::default()),\n+            body_id,\n+        }\n+    }\n+\n+    pub(super) fn register_predicate(&self, obligation: traits::PredicateObligation<'tcx>) {\n+        debug!(\"register_predicate({:?})\", obligation);\n+        if obligation.has_escaping_bound_vars() {\n+            span_bug!(obligation.cause.span, \"escaping bound vars in predicate {:?}\", obligation);\n+        }\n+        self.fulfillment_cx.borrow_mut().register_predicate_obligation(self, obligation);\n+    }\n+\n+    pub(super) fn register_predicates<I>(&self, obligations: I)\n+    where\n+        I: IntoIterator<Item = traits::PredicateObligation<'tcx>>,\n+    {\n+        for obligation in obligations {\n+            self.register_predicate(obligation);\n+        }\n+    }\n+\n+    pub(super) fn register_infer_ok_obligations<T>(&self, infer_ok: InferOk<'tcx, T>) -> T {\n+        self.register_predicates(infer_ok.obligations);\n+        infer_ok.value\n+    }\n+\n+    pub(super) fn normalize_associated_types_in<T>(\n+        &self,\n+        span: Span,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let ok = self.partially_normalize_associated_types_in(span, body_id, param_env, value);\n+        self.register_infer_ok_obligations(ok)\n+    }\n+}"}, {"sha": "529cf491dd894c19d40776c8307dc3bcddf1f6a1", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 6, "deletions": 155, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/7995d5cda4cd5154def40770f4527e7867f37c1a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7995d5cda4cd5154def40770f4527e7867f37c1a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=7995d5cda4cd5154def40770f4527e7867f37c1a", "patch": "@@ -75,6 +75,7 @@ mod expr;\n mod fn_ctxt;\n mod gather_locals;\n mod generator_interior;\n+mod inherited;\n pub mod intrinsic;\n pub mod method;\n mod op;\n@@ -86,6 +87,7 @@ mod wfcheck;\n pub mod writeback;\n \n pub use fn_ctxt::FnCtxt;\n+pub use inherited::{Inherited, InheritedBuilder};\n \n use crate::astconv::AstConv;\n use crate::check::gather_locals::GatherLocalsVisitor;\n@@ -94,16 +96,15 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{HirIdMap, ItemKind, Node};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n-use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{InferCtxt, InferOk, RegionVariableOrigin, TyCtxtInferExt};\n+use rustc_infer::infer::RegionVariableOrigin;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::GenericArgKind;\n@@ -119,20 +120,17 @@ use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{self, BytePos, MultiSpan, Span};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n-use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::opaque_types::OpaqueTypeDecl;\n use rustc_trait_selection::traits::error_reporting::recursive_type_with_infinite_size_error;\n use rustc_trait_selection::traits::error_reporting::suggestions::ReturnsVisitor;\n-use rustc_trait_selection::traits::{self, ObligationCauseCode, TraitEngine, TraitEngineExt};\n+use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n use std::cell::{Ref, RefCell, RefMut};\n use std::cmp;\n-use std::ops::{self, Deref};\n+use std::ops::{self};\n \n use crate::require_c_abi_if_c_variadic;\n use crate::util::common::indenter;\n \n-use self::callee::DeferredCallResolution;\n use self::coercion::{CoerceMany, DynamicCoerceMany};\n use self::compare_method::{compare_const_impl, compare_impl_method, compare_ty_impl};\n pub use self::Expectation::*;\n@@ -155,64 +153,6 @@ pub struct LocalTy<'tcx> {\n     revealed_ty: Ty<'tcx>,\n }\n \n-/// Closures defined within the function. For example:\n-///\n-///     fn foo() {\n-///         bar(move|| { ... })\n-///     }\n-///\n-/// Here, the function `foo()` and the closure passed to\n-/// `bar()` will each have their own `FnCtxt`, but they will\n-/// share the inherited fields.\n-pub struct Inherited<'a, 'tcx> {\n-    infcx: InferCtxt<'a, 'tcx>,\n-\n-    typeck_results: MaybeInProgressTables<'a, 'tcx>,\n-\n-    locals: RefCell<HirIdMap<LocalTy<'tcx>>>,\n-\n-    fulfillment_cx: RefCell<Box<dyn TraitEngine<'tcx>>>,\n-\n-    // Some additional `Sized` obligations badly affect type inference.\n-    // These obligations are added in a later stage of typeck.\n-    deferred_sized_obligations: RefCell<Vec<(Ty<'tcx>, Span, traits::ObligationCauseCode<'tcx>)>>,\n-\n-    // When we process a call like `c()` where `c` is a closure type,\n-    // we may not have decided yet whether `c` is a `Fn`, `FnMut`, or\n-    // `FnOnce` closure. In that case, we defer full resolution of the\n-    // call until upvar inference can kick in and make the\n-    // decision. We keep these deferred resolutions grouped by the\n-    // def-id of the closure, so that once we decide, we can easily go\n-    // back and process them.\n-    deferred_call_resolutions: RefCell<DefIdMap<Vec<DeferredCallResolution<'tcx>>>>,\n-\n-    deferred_cast_checks: RefCell<Vec<cast::CastCheck<'tcx>>>,\n-\n-    deferred_generator_interiors: RefCell<Vec<(hir::BodyId, Ty<'tcx>, hir::GeneratorKind)>>,\n-\n-    // Opaque types found in explicit return types and their\n-    // associated fresh inference variable. Writeback resolves these\n-    // variables to get the concrete type, which can be used to\n-    // 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n-    opaque_types: RefCell<DefIdMap<OpaqueTypeDecl<'tcx>>>,\n-\n-    /// A map from inference variables created from opaque\n-    /// type instantiations (`ty::Infer`) to the actual opaque\n-    /// type (`ty::Opaque`). Used during fallback to map unconstrained\n-    /// opaque type inference variables to their corresponding\n-    /// opaque type.\n-    opaque_types_vars: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n-\n-    body_id: Option<hir::BodyId>,\n-}\n-\n-impl<'a, 'tcx> Deref for Inherited<'a, 'tcx> {\n-    type Target = InferCtxt<'a, 'tcx>;\n-    fn deref(&self) -> &Self::Target {\n-        &self.infcx\n-    }\n-}\n-\n /// When type-checking an expression, we propagate downward\n /// whatever type hint we are able in the form of an `Expectation`.\n #[derive(Copy, Clone, Debug)]\n@@ -489,95 +429,6 @@ impl<'tcx> EnclosingBreakables<'tcx> {\n     }\n }\n \n-/// Helper type of a temporary returned by `Inherited::build(...)`.\n-/// Necessary because we can't write the following bound:\n-/// `F: for<'b, 'tcx> where 'tcx FnOnce(Inherited<'b, 'tcx>)`.\n-pub struct InheritedBuilder<'tcx> {\n-    infcx: infer::InferCtxtBuilder<'tcx>,\n-    def_id: LocalDefId,\n-}\n-\n-impl Inherited<'_, 'tcx> {\n-    pub fn build(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> InheritedBuilder<'tcx> {\n-        let hir_owner = tcx.hir().local_def_id_to_hir_id(def_id).owner;\n-\n-        InheritedBuilder {\n-            infcx: tcx.infer_ctxt().with_fresh_in_progress_typeck_results(hir_owner),\n-            def_id,\n-        }\n-    }\n-}\n-\n-impl<'tcx> InheritedBuilder<'tcx> {\n-    pub fn enter<F, R>(&mut self, f: F) -> R\n-    where\n-        F: for<'a> FnOnce(Inherited<'a, 'tcx>) -> R,\n-    {\n-        let def_id = self.def_id;\n-        self.infcx.enter(|infcx| f(Inherited::new(infcx, def_id)))\n-    }\n-}\n-\n-impl Inherited<'a, 'tcx> {\n-    fn new(infcx: InferCtxt<'a, 'tcx>, def_id: LocalDefId) -> Self {\n-        let tcx = infcx.tcx;\n-        let item_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        let body_id = tcx.hir().maybe_body_owned_by(item_id);\n-\n-        Inherited {\n-            typeck_results: MaybeInProgressTables {\n-                maybe_typeck_results: infcx.in_progress_typeck_results,\n-            },\n-            infcx,\n-            fulfillment_cx: RefCell::new(TraitEngine::new(tcx)),\n-            locals: RefCell::new(Default::default()),\n-            deferred_sized_obligations: RefCell::new(Vec::new()),\n-            deferred_call_resolutions: RefCell::new(Default::default()),\n-            deferred_cast_checks: RefCell::new(Vec::new()),\n-            deferred_generator_interiors: RefCell::new(Vec::new()),\n-            opaque_types: RefCell::new(Default::default()),\n-            opaque_types_vars: RefCell::new(Default::default()),\n-            body_id,\n-        }\n-    }\n-\n-    fn register_predicate(&self, obligation: traits::PredicateObligation<'tcx>) {\n-        debug!(\"register_predicate({:?})\", obligation);\n-        if obligation.has_escaping_bound_vars() {\n-            span_bug!(obligation.cause.span, \"escaping bound vars in predicate {:?}\", obligation);\n-        }\n-        self.fulfillment_cx.borrow_mut().register_predicate_obligation(self, obligation);\n-    }\n-\n-    fn register_predicates<I>(&self, obligations: I)\n-    where\n-        I: IntoIterator<Item = traits::PredicateObligation<'tcx>>,\n-    {\n-        for obligation in obligations {\n-            self.register_predicate(obligation);\n-        }\n-    }\n-\n-    fn register_infer_ok_obligations<T>(&self, infer_ok: InferOk<'tcx, T>) -> T {\n-        self.register_predicates(infer_ok.obligations);\n-        infer_ok.value\n-    }\n-\n-    fn normalize_associated_types_in<T>(\n-        &self,\n-        span: Span,\n-        body_id: hir::HirId,\n-        param_env: ty::ParamEnv<'tcx>,\n-        value: &T,\n-    ) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        let ok = self.partially_normalize_associated_types_in(span, body_id, param_env, value);\n-        self.register_infer_ok_obligations(ok)\n-    }\n-}\n-\n pub fn check_wf_new(tcx: TyCtxt<'_>) {\n     let visit = wfcheck::CheckTypeWellFormedVisitor::new(tcx);\n     tcx.hir().krate().par_visit_all_item_likes(&visit);"}]}