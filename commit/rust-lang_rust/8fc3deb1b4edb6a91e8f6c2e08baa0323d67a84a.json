{"sha": "8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a", "node_id": "C_kwDOAAsO6NoAKDhmYzNkZWIxYjRlZGI2YTkxZThmNmMyZTA4YmFhMDMyM2Q2N2E4NGE", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-05-02T18:32:17Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-07-06T21:15:57Z"}, "message": "Remove `sess` field from LoweringContext.", "tree": {"sha": "b3ad442d3a84c71708c3c4362c019a55f67739bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3ad442d3a84c71708c3c4362c019a55f67739bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a", "html_url": "https://github.com/rust-lang/rust/commit/8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74be9458200febab1ca4bc8c0ef57f8ed1f096dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/74be9458200febab1ca4bc8c0ef57f8ed1f096dc", "html_url": "https://github.com/rust-lang/rust/commit/74be9458200febab1ca4bc8c0ef57f8ed1f096dc"}], "stats": {"total": 126, "additions": 69, "deletions": 57}, "files": [{"sha": "0e395d703358610447ae658266608d0f063e1273", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a", "patch": "@@ -24,10 +24,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> &'hir hir::InlineAsm<'hir> {\n         // Rustdoc needs to support asm! from foreign architectures: don't try\n         // lowering the register constraints in this case.\n-        let asm_arch = if self.sess.opts.actually_rustdoc { None } else { self.sess.asm_arch };\n-        if asm_arch.is_none() && !self.sess.opts.actually_rustdoc {\n-            struct_span_err!(self.sess, sp, E0472, \"inline assembly is unsupported on this target\")\n-                .emit();\n+        let asm_arch =\n+            if self.tcx.sess.opts.actually_rustdoc { None } else { self.tcx.sess.asm_arch };\n+        if asm_arch.is_none() && !self.tcx.sess.opts.actually_rustdoc {\n+            struct_span_err!(\n+                self.tcx.sess,\n+                sp,\n+                E0472,\n+                \"inline assembly is unsupported on this target\"\n+            )\n+            .emit();\n         }\n         if let Some(asm_arch) = asm_arch {\n             // Inline assembly is currently only stable for these architectures.\n@@ -40,9 +46,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     | asm::InlineAsmArch::RiscV32\n                     | asm::InlineAsmArch::RiscV64\n             );\n-            if !is_stable && !self.sess.features_untracked().asm_experimental_arch {\n+            if !is_stable && !self.tcx.features().asm_experimental_arch {\n                 feature_err(\n-                    &self.sess.parse_sess,\n+                    &self.tcx.sess.parse_sess,\n                     sym::asm_experimental_arch,\n                     sp,\n                     \"inline assembly is not stable yet on this architecture\",\n@@ -52,17 +58,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n         if asm.options.contains(InlineAsmOptions::ATT_SYNTAX)\n             && !matches!(asm_arch, Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64))\n-            && !self.sess.opts.actually_rustdoc\n+            && !self.tcx.sess.opts.actually_rustdoc\n         {\n-            self.sess\n+            self.tcx\n+                .sess\n                 .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n                 .emit();\n         }\n-        if asm.options.contains(InlineAsmOptions::MAY_UNWIND)\n-            && !self.sess.features_untracked().asm_unwind\n-        {\n+        if asm.options.contains(InlineAsmOptions::MAY_UNWIND) && !self.tcx.features().asm_unwind {\n             feature_err(\n-                &self.sess.parse_sess,\n+                &self.tcx.sess.parse_sess,\n                 sym::asm_unwind,\n                 sp,\n                 \"the `may_unwind` option is unstable\",\n@@ -73,20 +78,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut clobber_abis = FxHashMap::default();\n         if let Some(asm_arch) = asm_arch {\n             for (abi_name, abi_span) in &asm.clobber_abis {\n-                match asm::InlineAsmClobberAbi::parse(asm_arch, &self.sess.target, *abi_name) {\n+                match asm::InlineAsmClobberAbi::parse(asm_arch, &self.tcx.sess.target, *abi_name) {\n                     Ok(abi) => {\n                         // If the abi was already in the list, emit an error\n                         match clobber_abis.get(&abi) {\n                             Some((prev_name, prev_sp)) => {\n-                                let mut err = self.sess.struct_span_err(\n+                                let mut err = self.tcx.sess.struct_span_err(\n                                     *abi_span,\n                                     &format!(\"`{}` ABI specified multiple times\", prev_name),\n                                 );\n                                 err.span_label(*prev_sp, \"previously specified here\");\n \n                                 // Multiple different abi names may actually be the same ABI\n                                 // If the specified ABIs are not the same name, alert the user that they resolve to the same ABI\n-                                let source_map = self.sess.source_map();\n+                                let source_map = self.tcx.sess.source_map();\n                                 if source_map.span_to_snippet(*prev_sp)\n                                     != source_map.span_to_snippet(*abi_span)\n                                 {\n@@ -101,16 +106,19 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         }\n                     }\n                     Err(&[]) => {\n-                        self.sess\n+                        self.tcx\n+                            .sess\n                             .struct_span_err(\n                                 *abi_span,\n                                 \"`clobber_abi` is not supported on this target\",\n                             )\n                             .emit();\n                     }\n                     Err(supported_abis) => {\n-                        let mut err =\n-                            self.sess.struct_span_err(*abi_span, \"invalid ABI for `clobber_abi`\");\n+                        let mut err = self\n+                            .tcx\n+                            .sess\n+                            .struct_span_err(*abi_span, \"invalid ABI for `clobber_abi`\");\n                         let mut abis = format!(\"`{}`\", supported_abis[0]);\n                         for m in &supported_abis[1..] {\n                             let _ = write!(abis, \", `{}`\", m);\n@@ -128,7 +136,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Lower operands to HIR. We use dummy register classes if an error\n         // occurs during lowering because we still need to be able to produce a\n         // valid HIR.\n-        let sess = self.sess;\n+        let sess = self.tcx.sess;\n         let mut operands: Vec<_> = asm\n             .operands\n             .iter()\n@@ -184,9 +192,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         }\n                     }\n                     InlineAsmOperand::Const { ref anon_const } => {\n-                        if !self.sess.features_untracked().asm_const {\n+                        if !self.tcx.features().asm_const {\n                             feature_err(\n-                                &self.sess.parse_sess,\n+                                &sess.parse_sess,\n                                 sym::asm_const,\n                                 *op_sp,\n                                 \"const operands for inline assembly are unstable\",\n@@ -198,9 +206,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         }\n                     }\n                     InlineAsmOperand::Sym { ref sym } => {\n-                        if !self.sess.features_untracked().asm_sym {\n+                        if !self.tcx.features().asm_sym {\n                             feature_err(\n-                                &self.sess.parse_sess,\n+                                &sess.parse_sess,\n                                 sym::asm_sym,\n                                 *op_sp,\n                                 \"sym operands for inline assembly are unstable\","}, {"sha": "9444fffc331c79adbbc8863ca5d8d834c30cdafe", "filename": "compiler/rustc_ast_lowering/src/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs?ref=8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a", "patch": "@@ -159,9 +159,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             span,\n             kind: hir::ExprKind::If(let_expr, then_expr, Some(else_expr)),\n         });\n-        if !self.sess.features_untracked().let_else {\n+        if !self.tcx.features().let_else {\n             feature_err(\n-                &self.sess.parse_sess,\n+                &self.tcx.sess.parse_sess,\n                 sym::let_else,\n                 local.span,\n                 \"`let...else` statements are unstable\","}, {"sha": "9e02e7ed3b9cf0048e66d07435aa03b0c747e437", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a", "patch": "@@ -46,7 +46,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             let hir_id = self.lower_node_id(e.id);\n                             return hir::Expr { hir_id, kind, span: self.lower_span(e.span) };\n                         } else {\n-                            self.sess\n+                            self.tcx.sess\n                                 .struct_span_err(\n                                     e.span,\n                                     \"#[rustc_box] requires precisely one argument \\\n@@ -207,8 +207,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), lims)\n                 }\n                 ExprKind::Underscore => {\n-                    self.sess\n-                        .struct_span_err(\n+                    self.tcx\n+                        .sess.struct_span_err(\n                             e.span,\n                             \"in expressions, `_` can only be used on the left-hand side of an assignment\",\n                         )\n@@ -245,7 +245,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let rest = match &se.rest {\n                         StructRest::Base(e) => Some(self.lower_expr(e)),\n                         StructRest::Rest(sp) => {\n-                            self.sess\n+                            self.tcx\n+                                .sess\n                                 .struct_span_err(*sp, \"base expression required after `..`\")\n                                 .span_label(*sp, \"add a base expression here\")\n                                 .emit();\n@@ -474,7 +475,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             } else {\n                 let try_span = this.mark_span_with_reason(\n                     DesugaringKind::TryBlock,\n-                    this.sess.source_map().end_point(body.span),\n+                    this.tcx.sess.source_map().end_point(body.span),\n                     this.allow_try_trait.clone(),\n                 );\n \n@@ -653,7 +654,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             Some(hir::GeneratorKind::Async(_)) => {}\n             Some(hir::GeneratorKind::Gen) | None => {\n                 let mut err = struct_span_err!(\n-                    self.sess,\n+                    self.tcx.sess,\n                     dot_await_span,\n                     E0728,\n                     \"`await` is only allowed inside `async` functions and blocks\"\n@@ -878,7 +879,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             Some(hir::GeneratorKind::Gen) => {\n                 if decl.inputs.len() > 1 {\n                     struct_span_err!(\n-                        self.sess,\n+                        self.tcx.sess,\n                         fn_decl_span,\n                         E0628,\n                         \"too many parameters for a generator (expected 0 or 1 parameters)\"\n@@ -892,8 +893,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             None => {\n                 if movability == Movability::Static {\n-                    struct_span_err!(self.sess, fn_decl_span, E0697, \"closures cannot be static\")\n-                        .emit();\n+                    struct_span_err!(\n+                        self.tcx.sess,\n+                        fn_decl_span,\n+                        E0697,\n+                        \"closures cannot be static\"\n+                    )\n+                    .emit();\n                 }\n                 None\n             }\n@@ -916,7 +922,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n             if capture_clause == CaptureBy::Ref && !decl.inputs.is_empty() {\n                 struct_span_err!(\n-                    this.sess,\n+                    this.tcx.sess,\n                     fn_decl_span,\n                     E0708,\n                     \"`async` non-`move` closures with parameters are not currently supported\",\n@@ -1163,7 +1169,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 let fields_omitted = match &se.rest {\n                     StructRest::Base(e) => {\n-                        self.sess\n+                        self.tcx\n+                            .sess\n                             .struct_span_err(\n                                 e.span,\n                                 \"functional record updates are not allowed in destructuring \\\n@@ -1371,7 +1378,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             Some(hir::GeneratorKind::Gen) => {}\n             Some(hir::GeneratorKind::Async(_)) => {\n                 struct_span_err!(\n-                    self.sess,\n+                    self.tcx.sess,\n                     span,\n                     E0727,\n                     \"`async` generators are not yet supported\"\n@@ -1516,7 +1523,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             span,\n             self.allow_try_trait.clone(),\n         );\n-        let try_span = self.sess.source_map().end_point(span);\n+        let try_span = self.tcx.sess.source_map().end_point(span);\n         let try_span = self.mark_span_with_reason(\n             DesugaringKind::QuestionMark,\n             try_span,"}, {"sha": "ec9f47ce590d987ce4d7445cf3a9ba444fdb4c74", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a", "patch": "@@ -58,7 +58,6 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n         let mut lctx = LoweringContext {\n             // Pseudo-globals.\n             tcx: self.tcx,\n-            sess: &self.tcx.sess,\n             resolver: self.resolver,\n             arena: self.tcx.hir_arena,\n \n@@ -1268,7 +1267,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn error_on_invalid_abi(&self, abi: StrLit) {\n-        struct_span_err!(self.sess, abi.span, E0703, \"invalid ABI: found `{}`\", abi.symbol)\n+        struct_span_err!(self.tcx.sess, abi.span, E0703, \"invalid ABI: found `{}`\", abi.symbol)\n             .span_label(abi.span, \"invalid ABI\")\n             .help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")))\n             .emit();"}, {"sha": "2dcbd0782ef72d9adcf6121e76f76916d138aae0", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a", "patch": "@@ -49,7 +49,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{struct_span_err, Applicability};\n+use rustc_errors::{struct_span_err, Applicability, Handler};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, LifetimeRes, Namespace, PartialRes, PerNS, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n@@ -58,7 +58,6 @@ use rustc_hir::{ConstArg, GenericArg, ItemLocalId, ParamName, TraitCandidate};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::ty::{ResolverAstLowering, TyCtxt};\n use rustc_session::parse::feature_err;\n-use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -83,7 +82,6 @@ mod path;\n \n struct LoweringContext<'a, 'hir> {\n     tcx: TyCtxt<'hir>,\n-    sess: &'hir Session,\n     resolver: &'a mut ResolverAstLowering,\n \n     /// Used to allocate HIR nodes.\n@@ -681,8 +679,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.resolver.get_import_res(id).present_items()\n     }\n \n-    fn diagnostic(&self) -> &rustc_errors::Handler {\n-        self.sess.diagnostic()\n+    fn diagnostic(&self) -> &Handler {\n+        self.tcx.sess.diagnostic()\n     }\n \n     /// Reuses the span but adds information like the kind of the desugaring and features that are\n@@ -694,14 +692,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     ) -> Span {\n         self.tcx.with_stable_hashing_context(|hcx| {\n-            span.mark_with_reason(allow_internal_unstable, reason, self.sess.edition(), hcx)\n+            span.mark_with_reason(allow_internal_unstable, reason, self.tcx.sess.edition(), hcx)\n         })\n     }\n \n     /// Intercept all spans entering HIR.\n     /// Mark a span as relative to the current owning item.\n     fn lower_span(&self, span: Span) -> Span {\n-        if self.sess.opts.debugging_opts.incremental_relative_spans {\n+        if self.tcx.sess.opts.debugging_opts.incremental_relative_spans {\n             span.with_parent(Some(self.current_hir_id_owner))\n         } else {\n             // Do not make spans relative when not using incremental compilation.\n@@ -1048,7 +1046,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn emit_bad_parenthesized_trait_in_assoc_ty(&self, data: &ParenthesizedArgs) {\n-        let mut err = self.sess.struct_span_err(\n+        let mut err = self.tcx.sess.struct_span_err(\n             data.span,\n             \"parenthesized generic arguments cannot be used in associated type constraints\",\n         );\n@@ -1093,7 +1091,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n             ast::GenericArg::Type(ty) => {\n                 match ty.kind {\n-                    TyKind::Infer if self.sess.features_untracked().generic_arg_infer => {\n+                    TyKind::Infer if self.tcx.features().generic_arg_infer => {\n                         return GenericArg::Infer(hir::InferArg {\n                             hir_id: self.lower_node_id(ty.id),\n                             span: self.lower_span(ty.span),\n@@ -1190,7 +1188,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     } else {\n                         self.next_node_id()\n                     };\n-                    let span = self.sess.source_map().next_point(t.span.shrink_to_lo());\n+                    let span = self.tcx.sess.source_map().next_point(t.span.shrink_to_lo());\n                     Lifetime { ident: Ident::new(kw::UnderscoreLifetime, span), id }\n                 });\n                 let lifetime = self.lower_lifetime(&region);\n@@ -1294,7 +1292,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }\n                     ImplTraitContext::Disallowed(position) => {\n                         let mut err = struct_span_err!(\n-                            self.sess,\n+                            self.tcx.sess,\n                             t.span,\n                             E0562,\n                             \"`impl Trait` only allowed in function and inherent method return types, not in {}\",\n@@ -1307,7 +1305,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             TyKind::MacCall(_) => panic!(\"`TyKind::MacCall` should have been expanded by now\"),\n             TyKind::CVarArgs => {\n-                self.sess.delay_span_bug(\n+                self.tcx.sess.delay_span_bug(\n                     t.span,\n                     \"`TyKind::CVarArgs` should have been handled elsewhere\",\n                 );\n@@ -1912,7 +1910,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             hir_id,\n             name,\n             span: self.lower_span(param.span()),\n-            pure_wrt_drop: self.sess.contains_name(&param.attrs, sym::may_dangle),\n+            pure_wrt_drop: self.tcx.sess.contains_name(&param.attrs, sym::may_dangle),\n             kind,\n             colon_span: param.colon_span.map(|s| self.lower_span(s)),\n         }\n@@ -2054,11 +2052,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_array_length(&mut self, c: &AnonConst) -> hir::ArrayLen {\n         match c.value.kind {\n             ExprKind::Underscore => {\n-                if self.sess.features_untracked().generic_arg_infer {\n+                if self.tcx.features().generic_arg_infer {\n                     hir::ArrayLen::Infer(self.lower_node_id(c.id), c.value.span)\n                 } else {\n                     feature_err(\n-                        &self.sess.parse_sess,\n+                        &self.tcx.sess.parse_sess,\n                         sym::generic_arg_infer,\n                         c.value.span,\n                         \"using `_` for array lengths is unstable\","}, {"sha": "393be3b454c3787c7630750abb2c1d79369dc1f4", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=8fc3deb1b4edb6a91e8f6c2e08baa0323d67a84a", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         // We should've returned in the for loop above.\n \n-        self.sess.diagnostic().span_bug(\n+        self.diagnostic().span_bug(\n             p.span,\n             &format!(\n                 \"lower_qpath: no final extension segment in {}..{}\",\n@@ -193,7 +193,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n                     ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n                     ParenthesizedGenericArgs::Err => {\n-                        let mut err = struct_span_err!(self.sess, data.span, E0214, \"{}\", msg);\n+                        let mut err = struct_span_err!(self.tcx.sess, data.span, E0214, \"{}\", msg);\n                         err.span_label(data.span, \"only `Fn` traits may use parentheses\");\n                         // Suggest replacing parentheses with angle brackets `Trait(params...)` to `Trait<params...>`\n                         if !data.inputs.is_empty() {"}]}