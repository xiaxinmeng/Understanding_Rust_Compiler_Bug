{"sha": "6ce76091c7cef21692a15dce1f0a4c415d245be4", "node_id": "C_kwDOAAsO6NoAKDZjZTc2MDkxYzdjZWYyMTY5MmExNWRjZTFmMGE0YzQxNWQyNDViZTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-15T05:50:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-15T05:50:54Z"}, "message": "Auto merge of #96745 - ehuss:even-more-attribute-validation, r=cjgillot\n\nVisit attributes in more places.\n\nThis adds 3 loosely related changes (I can split PRs if desired):\n\n- Attribute checking on pattern struct fields.\n- Attribute checking on struct expression fields.\n- Lint level visiting on pattern struct fields, struct expression fields, and generic parameters.\n\nThere are still some lints which ignore lint levels in various positions. This is a consequence of how the lints themselves are implemented. For example, lint levels on associated consts don't work with `unused_braces`.", "tree": {"sha": "c41de2e296638ec3db9cb8db375fd857da3a8737", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c41de2e296638ec3db9cb8db375fd857da3a8737"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ce76091c7cef21692a15dce1f0a4c415d245be4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ce76091c7cef21692a15dce1f0a4c415d245be4", "html_url": "https://github.com/rust-lang/rust/commit/6ce76091c7cef21692a15dce1f0a4c415d245be4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ce76091c7cef21692a15dce1f0a4c415d245be4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80ed61fbd64936ed676c2050e7e660b5ad78c9f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/80ed61fbd64936ed676c2050e7e660b5ad78c9f2", "html_url": "https://github.com/rust-lang/rust/commit/80ed61fbd64936ed676c2050e7e660b5ad78c9f2"}, {"sha": "900a9d3f4e80315b1fccd909336febede92503ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/900a9d3f4e80315b1fccd909336febede92503ed", "html_url": "https://github.com/rust-lang/rust/commit/900a9d3f4e80315b1fccd909336febede92503ed"}], "stats": {"total": 1661, "additions": 1520, "deletions": 141}, "files": [{"sha": "32dbd2ff47d6b98349cd4a51a65e13734a3b3107", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -1406,8 +1406,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_expr_field(&mut self, f: &ExprField) -> hir::ExprField<'hir> {\n+        let hir_id = self.lower_node_id(f.id);\n+        self.lower_attrs(hir_id, &f.attrs);\n         hir::ExprField {\n-            hir_id: self.next_id(),\n+            hir_id,\n             ident: self.lower_ident(f.ident),\n             expr: self.lower_expr(&f.expr),\n             span: self.lower_span(f.span),"}, {"sha": "2b7431f0990570a004902099db789a36f65cd989", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -199,6 +199,13 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n+    fn visit_pat_field(&mut self, field: &'hir PatField<'hir>) {\n+        self.insert(field.span, field.hir_id, Node::PatField(field));\n+        self.with_parent(field.hir_id, |this| {\n+            intravisit::walk_pat_field(this, field);\n+        });\n+    }\n+\n     fn visit_arm(&mut self, arm: &'hir Arm<'hir>) {\n         let node = Node::Arm(arm);\n \n@@ -225,6 +232,13 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n+    fn visit_expr_field(&mut self, field: &'hir ExprField<'hir>) {\n+        self.insert(field.span, field.hir_id, Node::ExprField(field));\n+        self.with_parent(field.hir_id, |this| {\n+            intravisit::walk_expr_field(this, field);\n+        });\n+    }\n+\n     fn visit_stmt(&mut self, stmt: &'hir Stmt<'hir>) {\n         self.insert(stmt.span, stmt.hir_id, Node::Stmt(stmt));\n "}, {"sha": "51f67e505f4eeae82458a7b138a95b7a112ce8be", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -64,12 +64,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                         );\n \n-                        let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::PatField {\n-                            hir_id: self.next_id(),\n-                            ident: self.lower_ident(f.ident),\n-                            pat: self.lower_pat(&f.pat),\n-                            is_shorthand: f.is_shorthand,\n-                            span: self.lower_span(f.span),\n+                        let fs = self.arena.alloc_from_iter(fields.iter().map(|f| {\n+                            let hir_id = self.lower_node_id(f.id);\n+                            self.lower_attrs(hir_id, &f.attrs);\n+\n+                            hir::PatField {\n+                                hir_id,\n+                                ident: self.lower_ident(f.ident),\n+                                pat: self.lower_pat(&f.pat),\n+                                is_shorthand: f.is_shorthand,\n+                                span: self.lower_span(f.span),\n+                            }\n                         }));\n                         break hir::PatKind::Struct(qpath, fs, etc);\n                     }"}, {"sha": "2610d0b92d8f39e9e29494aa0e7e4c01ac1d161d", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -3332,12 +3332,14 @@ pub enum Node<'hir> {\n     Field(&'hir FieldDef<'hir>),\n     AnonConst(&'hir AnonConst),\n     Expr(&'hir Expr<'hir>),\n+    ExprField(&'hir ExprField<'hir>),\n     Stmt(&'hir Stmt<'hir>),\n     PathSegment(&'hir PathSegment<'hir>),\n     Ty(&'hir Ty<'hir>),\n     TypeBinding(&'hir TypeBinding<'hir>),\n     TraitRef(&'hir TraitRef<'hir>),\n     Pat(&'hir Pat<'hir>),\n+    PatField(&'hir PatField<'hir>),\n     Arm(&'hir Arm<'hir>),\n     Block(&'hir Block<'hir>),\n     Local(&'hir Local<'hir>),\n@@ -3388,6 +3390,8 @@ impl<'hir> Node<'hir> {\n             | Node::Block(..)\n             | Node::Ctor(..)\n             | Node::Pat(..)\n+            | Node::PatField(..)\n+            | Node::ExprField(..)\n             | Node::Arm(..)\n             | Node::Local(..)\n             | Node::Crate(..)"}, {"sha": "900370937f79aecd7c507c71aacea749b2bcd9c5", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -325,6 +325,9 @@ pub trait Visitor<'v>: Sized {\n     fn visit_pat(&mut self, p: &'v Pat<'v>) {\n         walk_pat(self, p)\n     }\n+    fn visit_pat_field(&mut self, f: &'v PatField<'v>) {\n+        walk_pat_field(self, f)\n+    }\n     fn visit_array_length(&mut self, len: &'v ArrayLen) {\n         walk_array_len(self, len)\n     }\n@@ -337,6 +340,9 @@ pub trait Visitor<'v>: Sized {\n     fn visit_let_expr(&mut self, lex: &'v Let<'v>) {\n         walk_let_expr(self, lex)\n     }\n+    fn visit_expr_field(&mut self, field: &'v ExprField<'v>) {\n+        walk_expr_field(self, field)\n+    }\n     fn visit_ty(&mut self, t: &'v Ty<'v>) {\n         walk_ty(self, t)\n     }\n@@ -761,11 +767,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat<'v>) {\n         }\n         PatKind::Struct(ref qpath, fields, _) => {\n             visitor.visit_qpath(qpath, pattern.hir_id, pattern.span);\n-            for field in fields {\n-                visitor.visit_id(field.hir_id);\n-                visitor.visit_ident(field.ident);\n-                visitor.visit_pat(&field.pat)\n-            }\n+            walk_list!(visitor, visit_pat_field, fields);\n         }\n         PatKind::Or(pats) => walk_list!(visitor, visit_pat, pats),\n         PatKind::Tuple(tuple_elements, _) => {\n@@ -792,6 +794,12 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat<'v>) {\n     }\n }\n \n+pub fn walk_pat_field<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v PatField<'v>) {\n+    visitor.visit_id(field.hir_id);\n+    visitor.visit_ident(field.ident);\n+    visitor.visit_pat(&field.pat)\n+}\n+\n pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem<'v>) {\n     visitor.visit_id(foreign_item.hir_id());\n     visitor.visit_ident(foreign_item.ident);\n@@ -1059,6 +1067,12 @@ pub fn walk_let_expr<'v, V: Visitor<'v>>(visitor: &mut V, let_expr: &'v Let<'v>)\n     walk_list!(visitor, visit_ty, let_expr.ty);\n }\n \n+pub fn walk_expr_field<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v ExprField<'v>) {\n+    visitor.visit_id(field.hir_id);\n+    visitor.visit_ident(field.ident);\n+    visitor.visit_expr(&field.expr)\n+}\n+\n pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>) {\n     visitor.visit_id(expression.hir_id);\n     match expression.kind {\n@@ -1073,11 +1087,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n         }\n         ExprKind::Struct(ref qpath, fields, ref optional_base) => {\n             visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n-            for field in fields {\n-                visitor.visit_id(field.hir_id);\n-                visitor.visit_ident(field.ident);\n-                visitor.visit_expr(&field.expr)\n-            }\n+            walk_list!(visitor, visit_expr_field, fields);\n             walk_list!(visitor, visit_expr, optional_base);\n         }\n         ExprKind::Tup(subexpressions) => {"}, {"sha": "78bfd7191dba9b3f713377ff4830ac3667644988", "filename": "compiler/rustc_hir/src/target.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -56,6 +56,8 @@ pub enum Target {\n     GenericParam(GenericParamKind),\n     MacroDef,\n     Param,\n+    PatField,\n+    ExprField,\n }\n \n impl Display for Target {\n@@ -183,6 +185,8 @@ impl Target {\n             },\n             Target::MacroDef => \"macro def\",\n             Target::Param => \"function param\",\n+            Target::PatField => \"pattern field\",\n+            Target::ExprField => \"struct field\",\n         }\n     }\n }"}, {"sha": "e6fcb84730ea4701b8fd7c8e41d3e842600a7206", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -83,12 +83,14 @@ impl<'a> State<'a> {\n             Node::Variant(a) => self.print_variant(a),\n             Node::AnonConst(a) => self.print_anon_const(a),\n             Node::Expr(a) => self.print_expr(a),\n+            Node::ExprField(a) => self.print_expr_field(&a),\n             Node::Stmt(a) => self.print_stmt(a),\n             Node::PathSegment(a) => self.print_path_segment(a),\n             Node::Ty(a) => self.print_type(a),\n             Node::TypeBinding(a) => self.print_type_binding(a),\n             Node::TraitRef(a) => self.print_trait_ref(a),\n             Node::Pat(a) => self.print_pat(a),\n+            Node::PatField(a) => self.print_patfield(&a),\n             Node::Arm(a) => self.print_arm(a),\n             Node::Infer(_) => self.word(\"_\"),\n             Node::Block(a) => {\n@@ -1127,20 +1129,7 @@ impl<'a> State<'a> {\n     ) {\n         self.print_qpath(qpath, true);\n         self.word(\"{\");\n-        self.commasep_cmnt(\n-            Consistent,\n-            fields,\n-            |s, field| {\n-                s.ibox(INDENT_UNIT);\n-                if !field.is_shorthand {\n-                    s.print_ident(field.ident);\n-                    s.word_space(\":\");\n-                }\n-                s.print_expr(field.expr);\n-                s.end()\n-            },\n-            |f| f.span,\n-        );\n+        self.commasep_cmnt(Consistent, fields, |s, field| s.print_expr_field(field), |f| f.span);\n         if let Some(expr) = wth {\n             self.ibox(INDENT_UNIT);\n             if !fields.is_empty() {\n@@ -1157,6 +1146,20 @@ impl<'a> State<'a> {\n         self.word(\"}\");\n     }\n \n+    fn print_expr_field(&mut self, field: &hir::ExprField<'_>) {\n+        if self.attrs(field.hir_id).is_empty() {\n+            self.space();\n+        }\n+        self.cbox(INDENT_UNIT);\n+        self.print_outer_attributes(&self.attrs(field.hir_id));\n+        if !field.is_shorthand {\n+            self.print_ident(field.ident);\n+            self.word_space(\":\");\n+        }\n+        self.print_expr(&field.expr);\n+        self.end()\n+    }\n+\n     fn print_expr_tup(&mut self, exprs: &[hir::Expr<'_>]) {\n         self.popen();\n         self.commasep_exprs(Inconsistent, exprs);\n@@ -1803,20 +1806,7 @@ impl<'a> State<'a> {\n                 if !empty {\n                     self.space();\n                 }\n-                self.commasep_cmnt(\n-                    Consistent,\n-                    fields,\n-                    |s, f| {\n-                        s.cbox(INDENT_UNIT);\n-                        if !f.is_shorthand {\n-                            s.print_ident(f.ident);\n-                            s.word_nbsp(\":\");\n-                        }\n-                        s.print_pat(f.pat);\n-                        s.end()\n-                    },\n-                    |f| f.pat.span,\n-                );\n+                self.commasep_cmnt(Consistent, &fields, |s, f| s.print_patfield(f), |f| f.pat.span);\n                 if etc {\n                     if !fields.is_empty() {\n                         self.word_space(\",\");\n@@ -1911,6 +1901,20 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n+    pub fn print_patfield(&mut self, field: &hir::PatField<'_>) {\n+        if self.attrs(field.hir_id).is_empty() {\n+            self.space();\n+        }\n+        self.cbox(INDENT_UNIT);\n+        self.print_outer_attributes(&self.attrs(field.hir_id));\n+        if !field.is_shorthand {\n+            self.print_ident(field.ident);\n+            self.word_nbsp(\":\");\n+        }\n+        self.print_pat(field.pat);\n+        self.end();\n+    }\n+\n     pub fn print_param(&mut self, arg: &hir::Param<'_>) {\n         self.print_outer_attributes(self.attrs(arg.hir_id));\n         self.print_pat(arg.pat);"}, {"sha": "580a4566869f052e34e57c311d5fcc169fd75cee", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -101,6 +101,12 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         run_early_pass!(self, check_pat_post, p);\n     }\n \n+    fn visit_pat_field(&mut self, field: &'a ast::PatField) {\n+        self.with_lint_attrs(field.id, &field.attrs, |cx| {\n+            ast_visit::walk_pat_field(cx, field);\n+        });\n+    }\n+\n     fn visit_anon_const(&mut self, c: &'a ast::AnonConst) {\n         self.check_id(c.id);\n         ast_visit::walk_anon_const(self, c);\n@@ -219,9 +225,10 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n     }\n \n     fn visit_generic_param(&mut self, param: &'a ast::GenericParam) {\n-        run_early_pass!(self, check_generic_param, param);\n-        self.check_id(param.id);\n-        ast_visit::walk_generic_param(self, param);\n+        self.with_lint_attrs(param.id, &param.attrs, |cx| {\n+            run_early_pass!(cx, check_generic_param, param);\n+            ast_visit::walk_generic_param(cx, param);\n+        });\n     }\n \n     fn visit_generics(&mut self, g: &'a ast::Generics) {"}, {"sha": "1cabb58bbebfd3f1444a0c1b61ff7e2c2d7b2c0f", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -766,6 +766,12 @@ impl<'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'tcx> {\n         })\n     }\n \n+    fn visit_expr_field(&mut self, field: &'tcx hir::ExprField<'tcx>) {\n+        self.with_lint_attrs(field.hir_id, |builder| {\n+            intravisit::walk_expr_field(builder, field);\n+        })\n+    }\n+\n     fn visit_field_def(&mut self, s: &'tcx hir::FieldDef<'tcx>) {\n         self.with_lint_attrs(s.hir_id, |builder| {\n             intravisit::walk_field_def(builder, s);\n@@ -801,6 +807,18 @@ impl<'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'tcx> {\n             intravisit::walk_impl_item(builder, impl_item);\n         });\n     }\n+\n+    fn visit_pat_field(&mut self, field: &'tcx hir::PatField<'tcx>) {\n+        self.with_lint_attrs(field.hir_id, |builder| {\n+            intravisit::walk_pat_field(builder, field);\n+        })\n+    }\n+\n+    fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam<'tcx>) {\n+        self.with_lint_attrs(p.hir_id, |builder| {\n+            intravisit::walk_generic_param(builder, p);\n+        });\n+    }\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "2868aabfa07e21eea1923154ec83865eb81b6538", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -437,19 +437,14 @@ impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n \n     fn check_pat(&mut self, cx: &LateContext<'_>, p: &hir::Pat<'_>) {\n         if let PatKind::Binding(_, hid, ident, _) = p.kind {\n-            if let hir::Node::Pat(parent_pat) = cx.tcx.hir().get(cx.tcx.hir().get_parent_node(hid))\n+            if let hir::Node::PatField(field) = cx.tcx.hir().get(cx.tcx.hir().get_parent_node(hid))\n             {\n-                if let PatKind::Struct(_, field_pats, _) = &parent_pat.kind {\n-                    if field_pats\n-                        .iter()\n-                        .any(|field| !field.is_shorthand && field.pat.hir_id == p.hir_id)\n-                    {\n-                        // Only check if a new name has been introduced, to avoid warning\n-                        // on both the struct definition and this pattern.\n-                        self.check_snake_case(cx, \"variable\", &ident);\n-                    }\n-                    return;\n+                if !field.is_shorthand {\n+                    // Only check if a new name has been introduced, to avoid warning\n+                    // on both the struct definition and this pattern.\n+                    self.check_snake_case(cx, \"variable\", &ident);\n                 }\n+                return;\n             }\n             self.check_snake_case(cx, \"variable\", &ident);\n         }"}, {"sha": "cafd2c6e679949d5150102e02e452d706a408e35", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 47, "deletions": 51, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -125,45 +125,51 @@ fn lint_overflowing_range_endpoint<'tcx>(\n     lit_val: u128,\n     max: u128,\n     expr: &'tcx hir::Expr<'tcx>,\n-    parent_expr: &'tcx hir::Expr<'tcx>,\n     ty: &str,\n ) -> bool {\n     // We only want to handle exclusive (`..`) ranges,\n     // which are represented as `ExprKind::Struct`.\n+    let par_id = cx.tcx.hir().get_parent_node(expr.hir_id);\n+    let Node::ExprField(field) = cx.tcx.hir().get(par_id) else { return false };\n+    let field_par_id = cx.tcx.hir().get_parent_node(field.hir_id);\n+    let Node::Expr(struct_expr) = cx.tcx.hir().get(field_par_id) else { return false };\n+    if !is_range_literal(struct_expr) {\n+        return false;\n+    };\n+    let ExprKind::Struct(_, eps, _) = &struct_expr.kind else { return false };\n+    if eps.len() != 2 {\n+        return false;\n+    }\n+\n     let mut overwritten = false;\n-    if let ExprKind::Struct(_, eps, _) = &parent_expr.kind {\n-        if eps.len() != 2 {\n-            return false;\n-        }\n-        // We can suggest using an inclusive range\n-        // (`..=`) instead only if it is the `end` that is\n-        // overflowing and only by 1.\n-        if eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max {\n-            cx.struct_span_lint(OVERFLOWING_LITERALS, parent_expr.span, |lint| {\n-                let mut err = lint.build(fluent::lint::range_endpoint_out_of_range);\n-                err.set_arg(\"ty\", ty);\n-                if let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) {\n-                    use ast::{LitIntType, LitKind};\n-                    // We need to preserve the literal's suffix,\n-                    // as it may determine typing information.\n-                    let suffix = match lit.node {\n-                        LitKind::Int(_, LitIntType::Signed(s)) => s.name_str(),\n-                        LitKind::Int(_, LitIntType::Unsigned(s)) => s.name_str(),\n-                        LitKind::Int(_, LitIntType::Unsuffixed) => \"\",\n-                        _ => bug!(),\n-                    };\n-                    let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n-                    err.span_suggestion(\n-                        parent_expr.span,\n-                        fluent::lint::suggestion,\n-                        suggestion,\n-                        Applicability::MachineApplicable,\n-                    );\n-                    err.emit();\n-                    overwritten = true;\n-                }\n-            });\n-        }\n+    // We can suggest using an inclusive range\n+    // (`..=`) instead only if it is the `end` that is\n+    // overflowing and only by 1.\n+    if eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max {\n+        cx.struct_span_lint(OVERFLOWING_LITERALS, struct_expr.span, |lint| {\n+            let mut err = lint.build(fluent::lint::range_endpoint_out_of_range);\n+            err.set_arg(\"ty\", ty);\n+            if let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) {\n+                use ast::{LitIntType, LitKind};\n+                // We need to preserve the literal's suffix,\n+                // as it may determine typing information.\n+                let suffix = match lit.node {\n+                    LitKind::Int(_, LitIntType::Signed(s)) => s.name_str(),\n+                    LitKind::Int(_, LitIntType::Unsigned(s)) => s.name_str(),\n+                    LitKind::Int(_, LitIntType::Unsuffixed) => \"\",\n+                    _ => bug!(),\n+                };\n+                let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n+                err.span_suggestion(\n+                    struct_expr.span,\n+                    fluent::lint::suggestion,\n+                    suggestion,\n+                    Applicability::MachineApplicable,\n+                );\n+                err.emit();\n+                overwritten = true;\n+            }\n+        });\n     }\n     overwritten\n }\n@@ -339,16 +345,9 @@ fn lint_int_literal<'tcx>(\n             return;\n         }\n \n-        let par_id = cx.tcx.hir().get_parent_node(e.hir_id);\n-        if let Node::Expr(par_e) = cx.tcx.hir().get(par_id) {\n-            if let hir::ExprKind::Struct(..) = par_e.kind {\n-                if is_range_literal(par_e)\n-                    && lint_overflowing_range_endpoint(cx, lit, v, max, e, par_e, t.name_str())\n-                {\n-                    // The overflowing literal lint was overridden.\n-                    return;\n-                }\n-            }\n+        if lint_overflowing_range_endpoint(cx, lit, v, max, e, t.name_str()) {\n+            // The overflowing literal lint was overridden.\n+            return;\n         }\n \n         cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n@@ -408,16 +407,13 @@ fn lint_uint_literal<'tcx>(\n                         return;\n                     }\n                 }\n-                hir::ExprKind::Struct(..) if is_range_literal(par_e) => {\n-                    let t = t.name_str();\n-                    if lint_overflowing_range_endpoint(cx, lit, lit_val, max, e, par_e, t) {\n-                        // The overflowing literal lint was overridden.\n-                        return;\n-                    }\n-                }\n                 _ => {}\n             }\n         }\n+        if lint_overflowing_range_endpoint(cx, lit, lit_val, max, e, t.name_str()) {\n+            // The overflowing literal lint was overridden.\n+            return;\n+        }\n         if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n             report_bin_hex_error(\n                 cx,"}, {"sha": "79e6804a28992c74f6d8a24f5adaa4e2a4ece81d", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -297,6 +297,8 @@ impl<'hir> Map<'hir> {\n             | Node::Infer(_)\n             | Node::TraitRef(_)\n             | Node::Pat(_)\n+            | Node::PatField(_)\n+            | Node::ExprField(_)\n             | Node::Local(_)\n             | Node::Param(_)\n             | Node::Arm(_)\n@@ -1020,6 +1022,7 @@ impl<'hir> Map<'hir> {\n             Node::Field(field) => field.span,\n             Node::AnonConst(constant) => self.body(constant.body).value.span,\n             Node::Expr(expr) => expr.span,\n+            Node::ExprField(field) => field.span,\n             Node::Stmt(stmt) => stmt.span,\n             Node::PathSegment(seg) => {\n                 let ident_span = seg.ident.span;\n@@ -1030,6 +1033,7 @@ impl<'hir> Map<'hir> {\n             Node::TypeBinding(tb) => tb.span,\n             Node::TraitRef(tr) => tr.path.span,\n             Node::Pat(pat) => pat.span,\n+            Node::PatField(field) => field.span,\n             Node::Arm(arm) => arm.span,\n             Node::Block(block) => block.span,\n             Node::Ctor(..) => self.span_with_body(self.get_parent_node(hir_id)),\n@@ -1241,12 +1245,14 @@ fn hir_id_to_string(map: Map<'_>, id: HirId) -> String {\n         }\n         Some(Node::AnonConst(_)) => node_str(\"const\"),\n         Some(Node::Expr(_)) => node_str(\"expr\"),\n+        Some(Node::ExprField(_)) => node_str(\"expr field\"),\n         Some(Node::Stmt(_)) => node_str(\"stmt\"),\n         Some(Node::PathSegment(_)) => node_str(\"path segment\"),\n         Some(Node::Ty(_)) => node_str(\"type\"),\n         Some(Node::TypeBinding(_)) => node_str(\"type binding\"),\n         Some(Node::TraitRef(_)) => node_str(\"trait ref\"),\n         Some(Node::Pat(_)) => node_str(\"pat\"),\n+        Some(Node::PatField(_)) => node_str(\"pattern field\"),\n         Some(Node::Param(_)) => node_str(\"param\"),\n         Some(Node::Arm(_)) => node_str(\"arm\"),\n         Some(Node::Block(_)) => node_str(\"block\"),"}, {"sha": "5789531d2ff5ae3b1a47a975bd7521e4803917ac", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -652,7 +652,9 @@ impl CheckAttrVisitor<'_> {\n             | Target::ForeignStatic\n             | Target::ForeignTy\n             | Target::GenericParam(..)\n-            | Target::MacroDef => None,\n+            | Target::MacroDef\n+            | Target::PatField\n+            | Target::ExprField => None,\n         } {\n             tcx.sess.emit_err(errors::DocAliasBadLocation { span, attr_str, location });\n             return false;\n@@ -2066,6 +2068,11 @@ impl<'tcx> Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n         intravisit::walk_expr(self, expr)\n     }\n \n+    fn visit_expr_field(&mut self, field: &'tcx hir::ExprField<'tcx>) {\n+        self.check_attributes(field.hir_id, field.span, Target::ExprField, None);\n+        intravisit::walk_expr_field(self, field)\n+    }\n+\n     fn visit_variant(&mut self, variant: &'tcx hir::Variant<'tcx>) {\n         self.check_attributes(variant.id, variant.span, Target::Variant, None);\n         intravisit::walk_variant(self, variant)\n@@ -2076,6 +2083,11 @@ impl<'tcx> Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n \n         intravisit::walk_param(self, param);\n     }\n+\n+    fn visit_pat_field(&mut self, field: &'tcx hir::PatField<'tcx>) {\n+        self.check_attributes(field.hir_id, field.span, Target::PatField, None);\n+        intravisit::walk_pat_field(self, field);\n+    }\n }\n \n fn is_c_like_enum(item: &Item<'_>) -> bool {"}, {"sha": "07046f3f0326b119185f836728bd3bf49df39873", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -638,11 +638,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }?;\n \n         match hir.find(hir.get_parent_node(expr.hir_id))? {\n-            Node::Expr(hir::Expr { kind: hir::ExprKind::Struct(_, fields, ..), .. }) => {\n-                for field in *fields {\n-                    if field.ident.name == local.name && field.is_shorthand {\n-                        return Some(local.name);\n-                    }\n+            Node::ExprField(field) => {\n+                if field.ident.name == local.name && field.is_shorthand {\n+                    return Some(local.name);\n                 }\n             }\n             _ => {}\n@@ -1073,21 +1071,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let mut sugg = vec![];\n \n-        if let Some(hir::Node::Expr(hir::Expr {\n-            kind: hir::ExprKind::Struct(_, fields, _), ..\n-        })) = self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id))\n+        if let Some(hir::Node::ExprField(field)) =\n+            self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id))\n         {\n             // `expr` is a literal field for a struct, only suggest if appropriate\n-            match (*fields)\n-                .iter()\n-                .find(|field| field.expr.hir_id == expr.hir_id && field.is_shorthand)\n-            {\n+            if field.is_shorthand {\n                 // This is a field literal\n-                Some(field) => {\n-                    sugg.push((field.ident.span.shrink_to_lo(), format!(\"{}: \", field.ident)));\n-                }\n+                sugg.push((field.ident.span.shrink_to_lo(), format!(\"{}: \", field.ident)));\n+            } else {\n                 // Likely a field was meant, but this field wasn't found. Do not suggest anything.\n-                None => return false,\n+                return false;\n             }\n         };\n "}, {"sha": "3e96b3ffb0940e7b41228728ab0bf58704872dd5", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -256,6 +256,8 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n                 | hir::Node::TypeBinding(..)\n                 | hir::Node::TraitRef(..)\n                 | hir::Node::Pat(..)\n+                | hir::Node::PatField(..)\n+                | hir::Node::ExprField(..)\n                 | hir::Node::Arm(..)\n                 | hir::Node::Local(..)\n                 | hir::Node::Ctor(..)"}, {"sha": "6dcc364bb50f7838df7687d5428d643313748e77", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -927,7 +927,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ),\n                 );\n                 match self.tcx.hir().get(self.tcx.hir().get_parent_node(pat.hir_id)) {\n-                    hir::Node::Pat(Pat { kind: hir::PatKind::Struct(..), .. }) => {\n+                    hir::Node::PatField(..) => {\n                         e.span_suggestion_verbose(\n                             ident.span.shrink_to_hi(),\n                             \"bind the struct field to a different name instead\","}, {"sha": "fd0c4b43e05c63f2b8fe3f9efbdceac7163b1daa", "filename": "src/test/ui/lint/lint-attr-everywhere-early.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/src%2Ftest%2Fui%2Flint%2Flint-attr-everywhere-early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/src%2Ftest%2Fui%2Flint%2Flint-attr-everywhere-early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-attr-everywhere-early.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -0,0 +1,176 @@\n+// Tests that lint levels can be set for early lints.\n+#![allow(non_camel_case_types, unsafe_code, while_true, unused_parens)]\n+\n+// The following is a check of the lints used here to verify they do not warn\n+// when allowed.\n+fn verify_no_warnings() {\n+    type non_camel_type = i32; // non_camel_case_types\n+    struct NON_CAMEL_IS_ALLOWED; // non_camel_case_types\n+    unsafe {} // unsafe_code\n+    enum Enum {\n+        VARIANT_CAMEL // non_camel_case_types\n+    }\n+    fn generics<foo>() {} // non_camel_case_types\n+    while true {} // while_true\n+    type T = (i32); // unused_parens\n+}\n+\n+\n+// ################## Types\n+\n+#[deny(non_camel_case_types)]\n+type type_outer = i32; //~ ERROR type `type_outer` should have an upper camel case name\n+\n+type BareFnPtr = fn(#[deny(unused_parens)](i32)); //~ ERROR unnecessary parentheses around type\n+// There aren't any early lints that currently apply to the variadic spot.\n+// type BareFnPtrVariadic = extern \"C\" fn(i32, #[deny()]...);\n+\n+// ################## Items\n+#[deny(non_camel_case_types)]\n+struct ITEM_OUTER; //~ ERROR type `ITEM_OUTER` should have an upper camel case name\n+\n+mod module_inner {\n+    #![deny(unsafe_code)]\n+    fn f() {\n+        unsafe {} //~ ERROR usage of an `unsafe` block\n+    }\n+}\n+\n+struct Associated;\n+impl Associated {\n+    #![deny(unsafe_code)]\n+\n+    fn inherent_denied_from_inner() { unsafe {} } //~ usage of an `unsafe` block\n+\n+    #[deny(while_true)]\n+    fn inherent_fn() { while true {} } //~ ERROR denote infinite loops with\n+\n+    #[deny(while_true)]\n+    const INHERENT_CONST: i32 = {while true {} 1}; //~ ERROR denote infinite loops with\n+}\n+\n+trait trait_inner { //~ ERROR trait `trait_inner` should have an upper camel case name\n+    #![deny(non_camel_case_types)]\n+}\n+\n+trait AssociatedTrait {\n+    #![deny(unsafe_code)]\n+\n+    fn denied_from_inner() { unsafe {} } //~ ERROR usage of an `unsafe` block\n+\n+    #[deny(while_true)]\n+    fn assoc_fn() { while true {} } //~ ERROR denote infinite loops with\n+\n+    #[deny(while_true)]\n+    const ASSOC_CONST: i32 = {while true {} 1}; //~ ERROR denote infinite loops with\n+\n+    #[deny(non_camel_case_types)]\n+    type assoc_type; //~ ERROR associated type `assoc_type` should have an upper camel case name\n+}\n+\n+impl AssociatedTrait for Associated {\n+    #![deny(unsafe_code)]\n+\n+    fn denied_from_inner() { unsafe {} } //~ ERROR usage of an `unsafe` block\n+\n+    #[deny(while_true)]\n+    fn assoc_fn() { while true {} } //~ ERROR denote infinite loops with\n+\n+    #[deny(while_true)]\n+    const ASSOC_CONST: i32 = {while true {} 1};  //~ ERROR denote infinite loops with\n+\n+    #[deny(unused_parens)]\n+    type assoc_type = (i32); //~ ERROR unnecessary parentheses around type\n+}\n+\n+struct StructFields {\n+    #[deny(unused_parens)]f1: (i32), //~ ERROR unnecessary parentheses around type\n+}\n+struct StructTuple(#[deny(unused_parens)](i32)); //~ ERROR unnecessary parentheses around type\n+\n+enum Enum {\n+    #[deny(non_camel_case_types)]\n+    VARIANT_CAMEL, //~ ERROR variant `VARIANT_CAMEL` should have an upper camel case name\n+}\n+\n+extern \"C\" {\n+    #![deny(unused_parens)]\n+\n+    fn foreign_denied_from_inner(x: (i32)); //~ ERROR unnecessary parentheses around type\n+}\n+\n+extern \"C\" {\n+    #[deny(unused_parens)]\n+    fn foreign_denied_from_outer(x: (i32)); //~ ERROR unnecessary parentheses around type\n+}\n+\n+fn function(#[deny(unused_parens)] param: (i32)) {} //~ ERROR unnecessary parentheses around type\n+\n+fn generics<#[deny(non_camel_case_types)]foo>() {} //~ ERROR type parameter `foo` should have an upper camel case name\n+\n+\n+// ################## Statements\n+fn statements() {\n+    #[deny(unused_parens)]\n+    let x = (1); //~ ERROR unnecessary parentheses around assigned value\n+}\n+\n+\n+// ################## Expressions\n+fn expressions() {\n+    let closure = |#[deny(unused_parens)] param: (i32)| {}; //~ ERROR unnecessary parentheses around type\n+\n+    struct Match{f1: i32}\n+    // Strangely unused_parens doesn't fire with {f1: (123)}\n+    let f = Match{#[deny(unused_parens)]f1: {(123)}}; //~ ERROR unnecessary parentheses around block return value\n+\n+    match f {\n+        #![deny(unsafe_code)]\n+\n+        #[deny(while_true)]\n+        Match{f1} => {\n+            unsafe {} //~ ERROR usage of an `unsafe` block\n+            while true {} //~ ERROR denote infinite loops with\n+        }\n+    }\n+\n+    // Statement Block\n+    {\n+        #![deny(unsafe_code)]\n+        unsafe {} //~ ERROR usage of an `unsafe` block\n+    }\n+    let block_tail = {\n+        #[deny(unsafe_code)]\n+        unsafe {} //~ ERROR usage of an `unsafe` block\n+    };\n+\n+    // Before expression as a statement.\n+    #[deny(unsafe_code)]\n+    unsafe {}; //~ ERROR usage of an `unsafe` block\n+\n+    [#[deny(unsafe_code)] unsafe {123}]; //~ ERROR usage of an `unsafe` block\n+    (#[deny(unsafe_code)] unsafe {123},); //~ ERROR usage of an `unsafe` block\n+    fn call(p: i32) {}\n+    call(#[deny(unsafe_code)] unsafe {123}); //~ ERROR usage of an `unsafe` block\n+    struct TupleStruct(i32);\n+    TupleStruct(#[deny(unsafe_code)] unsafe {123}); //~ ERROR usage of an `unsafe` block\n+}\n+\n+\n+// ################## Patterns\n+fn patterns() {\n+    struct PatField{f1: i32, f2: i32};\n+    let f = PatField{f1: 1, f2: 2};\n+    match f {\n+        PatField {\n+            #[deny(ellipsis_inclusive_range_patterns)]\n+            f1: 0...100,\n+            //~^ ERROR range patterns are deprecated\n+            //~| WARNING this is accepted in the current edition\n+            ..\n+        } => {}\n+        _ => {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "1d6e3cda4e533fe012dc2ac10c7c0a1ee7fc7bc2", "filename": "src/test/ui/lint/lint-attr-everywhere-early.stderr", "status": "added", "additions": 486, "deletions": 0, "changes": 486, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/src%2Ftest%2Fui%2Flint%2Flint-attr-everywhere-early.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/src%2Ftest%2Fui%2Flint%2Flint-attr-everywhere-early.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-attr-everywhere-early.stderr?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -0,0 +1,486 @@\n+error: type `type_outer` should have an upper camel case name\n+  --> $DIR/lint-attr-everywhere-early.rs:22:6\n+   |\n+LL | type type_outer = i32;\n+   |      ^^^^^^^^^^ help: convert the identifier to upper camel case: `TypeOuter`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:21:8\n+   |\n+LL | #[deny(non_camel_case_types)]\n+   |        ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnecessary parentheses around type\n+  --> $DIR/lint-attr-everywhere-early.rs:24:43\n+   |\n+LL | type BareFnPtr = fn(#[deny(unused_parens)](i32));\n+   |                                           ^   ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:24:28\n+   |\n+LL | type BareFnPtr = fn(#[deny(unused_parens)](i32));\n+   |                            ^^^^^^^^^^^^^\n+help: remove these parentheses\n+   |\n+LL - type BareFnPtr = fn(#[deny(unused_parens)](i32));\n+LL + type BareFnPtr = fn(#[deny(unused_parens)]i32);\n+   |\n+\n+error: type `ITEM_OUTER` should have an upper camel case name\n+  --> $DIR/lint-attr-everywhere-early.rs:30:8\n+   |\n+LL | struct ITEM_OUTER;\n+   |        ^^^^^^^^^^ help: convert the identifier to upper camel case: `ItemOuter`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:29:8\n+   |\n+LL | #[deny(non_camel_case_types)]\n+   |        ^^^^^^^^^^^^^^^^^^^^\n+\n+error: usage of an `unsafe` block\n+  --> $DIR/lint-attr-everywhere-early.rs:35:9\n+   |\n+LL |         unsafe {}\n+   |         ^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:33:13\n+   |\n+LL |     #![deny(unsafe_code)]\n+   |             ^^^^^^^^^^^\n+\n+error: usage of an `unsafe` block\n+  --> $DIR/lint-attr-everywhere-early.rs:43:39\n+   |\n+LL |     fn inherent_denied_from_inner() { unsafe {} }\n+   |                                       ^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:41:13\n+   |\n+LL |     #![deny(unsafe_code)]\n+   |             ^^^^^^^^^^^\n+\n+error: denote infinite loops with `loop { ... }`\n+  --> $DIR/lint-attr-everywhere-early.rs:46:24\n+   |\n+LL |     fn inherent_fn() { while true {} }\n+   |                        ^^^^^^^^^^ help: use `loop`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:45:12\n+   |\n+LL |     #[deny(while_true)]\n+   |            ^^^^^^^^^^\n+\n+error: denote infinite loops with `loop { ... }`\n+  --> $DIR/lint-attr-everywhere-early.rs:49:34\n+   |\n+LL |     const INHERENT_CONST: i32 = {while true {} 1};\n+   |                                  ^^^^^^^^^^ help: use `loop`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:48:12\n+   |\n+LL |     #[deny(while_true)]\n+   |            ^^^^^^^^^^\n+\n+error: trait `trait_inner` should have an upper camel case name\n+  --> $DIR/lint-attr-everywhere-early.rs:52:7\n+   |\n+LL | trait trait_inner {\n+   |       ^^^^^^^^^^^ help: convert the identifier to upper camel case: `TraitInner`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:53:13\n+   |\n+LL |     #![deny(non_camel_case_types)]\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+\n+error: usage of an `unsafe` block\n+  --> $DIR/lint-attr-everywhere-early.rs:59:30\n+   |\n+LL |     fn denied_from_inner() { unsafe {} }\n+   |                              ^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:57:13\n+   |\n+LL |     #![deny(unsafe_code)]\n+   |             ^^^^^^^^^^^\n+\n+error: denote infinite loops with `loop { ... }`\n+  --> $DIR/lint-attr-everywhere-early.rs:62:21\n+   |\n+LL |     fn assoc_fn() { while true {} }\n+   |                     ^^^^^^^^^^ help: use `loop`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:61:12\n+   |\n+LL |     #[deny(while_true)]\n+   |            ^^^^^^^^^^\n+\n+error: denote infinite loops with `loop { ... }`\n+  --> $DIR/lint-attr-everywhere-early.rs:65:31\n+   |\n+LL |     const ASSOC_CONST: i32 = {while true {} 1};\n+   |                               ^^^^^^^^^^ help: use `loop`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:64:12\n+   |\n+LL |     #[deny(while_true)]\n+   |            ^^^^^^^^^^\n+\n+error: associated type `assoc_type` should have an upper camel case name\n+  --> $DIR/lint-attr-everywhere-early.rs:68:10\n+   |\n+LL |     type assoc_type;\n+   |          ^^^^^^^^^^ help: convert the identifier to upper camel case: `AssocType`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:67:12\n+   |\n+LL |     #[deny(non_camel_case_types)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+\n+error: usage of an `unsafe` block\n+  --> $DIR/lint-attr-everywhere-early.rs:74:30\n+   |\n+LL |     fn denied_from_inner() { unsafe {} }\n+   |                              ^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:72:13\n+   |\n+LL |     #![deny(unsafe_code)]\n+   |             ^^^^^^^^^^^\n+\n+error: denote infinite loops with `loop { ... }`\n+  --> $DIR/lint-attr-everywhere-early.rs:77:21\n+   |\n+LL |     fn assoc_fn() { while true {} }\n+   |                     ^^^^^^^^^^ help: use `loop`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:76:12\n+   |\n+LL |     #[deny(while_true)]\n+   |            ^^^^^^^^^^\n+\n+error: denote infinite loops with `loop { ... }`\n+  --> $DIR/lint-attr-everywhere-early.rs:80:31\n+   |\n+LL |     const ASSOC_CONST: i32 = {while true {} 1};\n+   |                               ^^^^^^^^^^ help: use `loop`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:79:12\n+   |\n+LL |     #[deny(while_true)]\n+   |            ^^^^^^^^^^\n+\n+error: unnecessary parentheses around type\n+  --> $DIR/lint-attr-everywhere-early.rs:83:23\n+   |\n+LL |     type assoc_type = (i32);\n+   |                       ^   ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:82:12\n+   |\n+LL |     #[deny(unused_parens)]\n+   |            ^^^^^^^^^^^^^\n+help: remove these parentheses\n+   |\n+LL -     type assoc_type = (i32);\n+LL +     type assoc_type = i32;\n+   |\n+\n+error: unnecessary parentheses around type\n+  --> $DIR/lint-attr-everywhere-early.rs:87:31\n+   |\n+LL |     #[deny(unused_parens)]f1: (i32),\n+   |                               ^   ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:87:12\n+   |\n+LL |     #[deny(unused_parens)]f1: (i32),\n+   |            ^^^^^^^^^^^^^\n+help: remove these parentheses\n+   |\n+LL -     #[deny(unused_parens)]f1: (i32),\n+LL +     #[deny(unused_parens)]f1: i32,\n+   |\n+\n+error: unnecessary parentheses around type\n+  --> $DIR/lint-attr-everywhere-early.rs:89:42\n+   |\n+LL | struct StructTuple(#[deny(unused_parens)](i32));\n+   |                                          ^   ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:89:27\n+   |\n+LL | struct StructTuple(#[deny(unused_parens)](i32));\n+   |                           ^^^^^^^^^^^^^\n+help: remove these parentheses\n+   |\n+LL - struct StructTuple(#[deny(unused_parens)](i32));\n+LL + struct StructTuple(#[deny(unused_parens)]i32);\n+   |\n+\n+error: variant `VARIANT_CAMEL` should have an upper camel case name\n+  --> $DIR/lint-attr-everywhere-early.rs:93:5\n+   |\n+LL |     VARIANT_CAMEL,\n+   |     ^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `VariantCamel`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:92:12\n+   |\n+LL |     #[deny(non_camel_case_types)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnecessary parentheses around type\n+  --> $DIR/lint-attr-everywhere-early.rs:99:37\n+   |\n+LL |     fn foreign_denied_from_inner(x: (i32));\n+   |                                     ^   ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:97:13\n+   |\n+LL |     #![deny(unused_parens)]\n+   |             ^^^^^^^^^^^^^\n+help: remove these parentheses\n+   |\n+LL -     fn foreign_denied_from_inner(x: (i32));\n+LL +     fn foreign_denied_from_inner(x: i32);\n+   |\n+\n+error: unnecessary parentheses around type\n+  --> $DIR/lint-attr-everywhere-early.rs:104:37\n+   |\n+LL |     fn foreign_denied_from_outer(x: (i32));\n+   |                                     ^   ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:103:12\n+   |\n+LL |     #[deny(unused_parens)]\n+   |            ^^^^^^^^^^^^^\n+help: remove these parentheses\n+   |\n+LL -     fn foreign_denied_from_outer(x: (i32));\n+LL +     fn foreign_denied_from_outer(x: i32);\n+   |\n+\n+error: unnecessary parentheses around type\n+  --> $DIR/lint-attr-everywhere-early.rs:107:43\n+   |\n+LL | fn function(#[deny(unused_parens)] param: (i32)) {}\n+   |                                           ^   ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:107:20\n+   |\n+LL | fn function(#[deny(unused_parens)] param: (i32)) {}\n+   |                    ^^^^^^^^^^^^^\n+help: remove these parentheses\n+   |\n+LL - fn function(#[deny(unused_parens)] param: (i32)) {}\n+LL + fn function(#[deny(unused_parens)] param: i32) {}\n+   |\n+\n+error: type parameter `foo` should have an upper camel case name\n+  --> $DIR/lint-attr-everywhere-early.rs:109:42\n+   |\n+LL | fn generics<#[deny(non_camel_case_types)]foo>() {}\n+   |                                          ^^^ help: convert the identifier to upper camel case (notice the capitalization): `Foo`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:109:20\n+   |\n+LL | fn generics<#[deny(non_camel_case_types)]foo>() {}\n+   |                    ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnecessary parentheses around assigned value\n+  --> $DIR/lint-attr-everywhere-early.rs:115:13\n+   |\n+LL |     let x = (1);\n+   |             ^ ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:114:12\n+   |\n+LL |     #[deny(unused_parens)]\n+   |            ^^^^^^^^^^^^^\n+help: remove these parentheses\n+   |\n+LL -     let x = (1);\n+LL +     let x = 1;\n+   |\n+\n+error: unnecessary parentheses around type\n+  --> $DIR/lint-attr-everywhere-early.rs:121:50\n+   |\n+LL |     let closure = |#[deny(unused_parens)] param: (i32)| {};\n+   |                                                  ^   ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:121:27\n+   |\n+LL |     let closure = |#[deny(unused_parens)] param: (i32)| {};\n+   |                           ^^^^^^^^^^^^^\n+help: remove these parentheses\n+   |\n+LL -     let closure = |#[deny(unused_parens)] param: (i32)| {};\n+LL +     let closure = |#[deny(unused_parens)] param: i32| {};\n+   |\n+\n+error: unnecessary parentheses around block return value\n+  --> $DIR/lint-attr-everywhere-early.rs:125:46\n+   |\n+LL |     let f = Match{#[deny(unused_parens)]f1: {(123)}};\n+   |                                              ^   ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:125:26\n+   |\n+LL |     let f = Match{#[deny(unused_parens)]f1: {(123)}};\n+   |                          ^^^^^^^^^^^^^\n+help: remove these parentheses\n+   |\n+LL -     let f = Match{#[deny(unused_parens)]f1: {(123)}};\n+LL +     let f = Match{#[deny(unused_parens)]f1: {123}};\n+   |\n+\n+error: usage of an `unsafe` block\n+  --> $DIR/lint-attr-everywhere-early.rs:132:13\n+   |\n+LL |             unsafe {}\n+   |             ^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:128:17\n+   |\n+LL |         #![deny(unsafe_code)]\n+   |                 ^^^^^^^^^^^\n+\n+error: denote infinite loops with `loop { ... }`\n+  --> $DIR/lint-attr-everywhere-early.rs:133:13\n+   |\n+LL |             while true {}\n+   |             ^^^^^^^^^^ help: use `loop`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:130:16\n+   |\n+LL |         #[deny(while_true)]\n+   |                ^^^^^^^^^^\n+\n+error: usage of an `unsafe` block\n+  --> $DIR/lint-attr-everywhere-early.rs:140:9\n+   |\n+LL |         unsafe {}\n+   |         ^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:139:17\n+   |\n+LL |         #![deny(unsafe_code)]\n+   |                 ^^^^^^^^^^^\n+\n+error: usage of an `unsafe` block\n+  --> $DIR/lint-attr-everywhere-early.rs:144:9\n+   |\n+LL |         unsafe {}\n+   |         ^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:143:16\n+   |\n+LL |         #[deny(unsafe_code)]\n+   |                ^^^^^^^^^^^\n+\n+error: usage of an `unsafe` block\n+  --> $DIR/lint-attr-everywhere-early.rs:149:5\n+   |\n+LL |     unsafe {};\n+   |     ^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:148:12\n+   |\n+LL |     #[deny(unsafe_code)]\n+   |            ^^^^^^^^^^^\n+\n+error: usage of an `unsafe` block\n+  --> $DIR/lint-attr-everywhere-early.rs:151:27\n+   |\n+LL |     [#[deny(unsafe_code)] unsafe {123}];\n+   |                           ^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:151:13\n+   |\n+LL |     [#[deny(unsafe_code)] unsafe {123}];\n+   |             ^^^^^^^^^^^\n+\n+error: usage of an `unsafe` block\n+  --> $DIR/lint-attr-everywhere-early.rs:152:27\n+   |\n+LL |     (#[deny(unsafe_code)] unsafe {123},);\n+   |                           ^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:152:13\n+   |\n+LL |     (#[deny(unsafe_code)] unsafe {123},);\n+   |             ^^^^^^^^^^^\n+\n+error: usage of an `unsafe` block\n+  --> $DIR/lint-attr-everywhere-early.rs:154:31\n+   |\n+LL |     call(#[deny(unsafe_code)] unsafe {123});\n+   |                               ^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:154:17\n+   |\n+LL |     call(#[deny(unsafe_code)] unsafe {123});\n+   |                 ^^^^^^^^^^^\n+\n+error: usage of an `unsafe` block\n+  --> $DIR/lint-attr-everywhere-early.rs:156:38\n+   |\n+LL |     TupleStruct(#[deny(unsafe_code)] unsafe {123});\n+   |                                      ^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:156:24\n+   |\n+LL |     TupleStruct(#[deny(unsafe_code)] unsafe {123});\n+   |                        ^^^^^^^^^^^\n+\n+error: `...` range patterns are deprecated\n+  --> $DIR/lint-attr-everywhere-early.rs:167:18\n+   |\n+LL |             f1: 0...100,\n+   |                  ^^^ help: use `..=` for an inclusive range\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:166:20\n+   |\n+LL |             #[deny(ellipsis_inclusive_range_patterns)]\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n+\n+error: aborting due to 36 previous errors\n+"}, {"sha": "1055157d6020c3442230139ed5d214a17cdd7bdf", "filename": "src/test/ui/lint/lint-attr-everywhere-late.rs", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/src%2Ftest%2Fui%2Flint%2Flint-attr-everywhere-late.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/src%2Ftest%2Fui%2Flint%2Flint-attr-everywhere-late.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-attr-everywhere-late.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -0,0 +1,197 @@\n+// Tests that lint levels can be set for late lints.\n+#![allow(\n+    non_snake_case,\n+    overflowing_literals,\n+    missing_docs,\n+    dyn_drop,\n+    enum_intrinsics_non_enums,\n+    clashing_extern_declarations\n+)]\n+\n+extern crate core;\n+use core::mem::{Discriminant, discriminant};\n+\n+// The following is a check of the lints used here to verify they do not warn\n+// when allowed.\n+pub fn missing_docs_allowed() {} // missing_docs\n+fn dyn_drop_allowed(_x: Box<dyn Drop>) {} // dyn_drop\n+fn verify_no_warnings() {\n+    discriminant::<i32>(&123); // enum_intrinsics_non_enums\n+    let x: u8 = 1000; // overflowing_literals\n+    let NON_SNAKE_CASE = 1; // non_snake_case\n+}\n+mod clashing_extern_allowed {\n+    extern \"C\" {\n+        fn extern_allowed();\n+    }\n+}\n+extern \"C\" {\n+    fn extern_allowed(_: i32); // clashing_extern_declarations\n+}\n+\n+// ################## Types\n+\n+#[deny(missing_docs)]\n+pub type MissingDocType = i32; //~ ERROR missing documentation for a type alias\n+\n+// There aren't any late lints that I can find that can be easily used with types.\n+// type BareFnPtr = fn(#[deny()]i32);\n+// type BareFnPtrVariadic = extern \"C\" fn(i32, #[deny()]...);\n+\n+// ################## Items\n+#[deny(missing_docs)]\n+pub struct ItemOuter; //~ ERROR missing documentation for a struct\n+\n+pub mod module_inner { //~ ERROR missing documentation for a module\n+    #![deny(missing_docs)]\n+    pub fn missing_inner() {} //~ ERROR missing documentation for a function\n+}\n+\n+pub struct Associated;\n+impl Associated {\n+    #![deny(missing_docs)]\n+\n+    pub fn inherent_denied_from_inner() {} //~ ERROR missing documentation for an associated function\n+}\n+\n+impl Associated {\n+    #[deny(missing_docs)]\n+    pub fn inherent_fn() {} //~ ERROR missing documentation for an associated function\n+\n+    #[deny(missing_docs)]\n+    pub const INHERENT_CONST: i32 = 1; //~ ERROR missing documentation for an associated constant\n+}\n+\n+pub trait TraitInner { //~ ERROR missing documentation for a trait\n+    #![deny(missing_docs)]\n+}\n+\n+pub trait AssociatedTraitInner { //~ ERROR missing documentation for a trait\n+    #![deny(missing_docs)]\n+\n+    fn denied_from_inner() {} //~ ERROR missing documentation for an associated function\n+}\n+\n+pub trait AssociatedTrait {\n+    fn denied_from_inner(_x: Box<dyn Drop>) {} // Used below\n+\n+    #[deny(missing_docs)]\n+    fn assoc_fn() {} //~ ERROR missing documentation for an associated function\n+\n+    #[deny(missing_docs)]\n+    const ASSOC_CONST: u8 = 1; //~ ERROR missing documentation for an associated constant\n+\n+    #[deny(missing_docs)]\n+    type AssocType; //~ ERROR missing documentation for an associated type\n+}\n+\n+struct Foo;\n+\n+impl AssociatedTrait for Associated {\n+    #![deny(dyn_drop)]\n+\n+    fn denied_from_inner(_x: Box<dyn Drop>) {} //~ ERROR types that do not implement `Drop`\n+\n+    #[deny(enum_intrinsics_non_enums)]\n+    fn assoc_fn() { discriminant::<i32>(&123); } //~ ERROR the return value of\n+\n+    #[deny(overflowing_literals)] const ASSOC_CONST: u8 = 1000; //~ ERROR literal out of range\n+    type AssocType = i32;\n+}\n+\n+\n+// There aren't any late lints that can apply to a field that I can find.\n+// non_snake_case doesn't work on fields\n+// struct StructFields {\n+//     #[deny()]f1: i32,\n+// }\n+// struct StructTuple(#[deny()]i32);\n+\n+pub enum Enum {\n+    #[deny(missing_docs)]\n+    Variant1, //~ ERROR missing documentation for a variant\n+}\n+\n+mod clashing_extern {\n+    extern \"C\" {\n+        fn clashing1();\n+        fn clashing2();\n+    }\n+}\n+extern \"C\" {\n+    #![deny(clashing_extern_declarations)]\n+    fn clashing1(_: i32); //~ ERROR `clashing1` redeclared with a different signature\n+}\n+\n+extern \"C\" {\n+    #[deny(clashing_extern_declarations)]\n+    fn clashing2(_: i32); //~ ERROR `clashing2` redeclared with a different signature\n+}\n+\n+fn function(#[deny(non_snake_case)] PARAM: i32) {} //~ ERROR variable `PARAM` should have a snake case name\n+// There aren't any late lints that can apply to generics that I can find.\n+// fn generics<#[deny()]T>() {}\n+\n+\n+// ################## Statements\n+fn statements() {\n+    #[deny(enum_intrinsics_non_enums)]\n+    let _ = discriminant::<i32>(&123); //~ ERROR the return value of\n+}\n+\n+\n+// ################## Expressions\n+fn expressions() {\n+    let closure = |#[deny(non_snake_case)] PARAM: i32| {}; //~ ERROR variable `PARAM` should have a snake case name\n+\n+    struct Match{f1: i32}\n+    // I can't find any late lints for patterns.\n+    // let f = Match{#[deny()]f1: 123};\n+\n+    let f = Match{f1: 123};\n+    match f {\n+        #![deny(enum_intrinsics_non_enums)]\n+        Match{f1} => {\n+            discriminant::<i32>(&123); //~ ERROR the return value of\n+        }\n+    }\n+    match f {\n+        #[deny(enum_intrinsics_non_enums)]\n+        Match{f1} => {\n+            discriminant::<i32>(&123); //~ ERROR the return value of\n+        }\n+    }\n+\n+    // Statement Block\n+    {\n+        #![deny(enum_intrinsics_non_enums)]\n+        discriminant::<i32>(&123); //~ ERROR the return value of\n+    }\n+    let block_tail = {\n+        #[deny(enum_intrinsics_non_enums)]\n+        discriminant::<i32>(&123); //~ ERROR the return value of\n+    };\n+\n+    // Before expression as a statement.\n+    #[deny(enum_intrinsics_non_enums)]\n+    discriminant::<i32>(&123); //~ ERROR the return value of\n+\n+    [#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123)]; //~ ERROR the return value of\n+    (#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123),); //~ ERROR the return value of\n+    fn call(p: Discriminant<i32>) {}\n+    call(#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123)); //~ ERROR the return value of\n+    struct TupleStruct(Discriminant<i32>);\n+    TupleStruct(#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123)); //~ ERROR the return value of\n+}\n+\n+\n+// ################## Patterns\n+fn patterns() {\n+    // There aren't any late lints that I can find that apply to pattern fields.\n+    //\n+    // struct PatField{f1: i32, f2: i32};\n+    // let f = PatField{f1: 1, f2: 2};\n+    // let PatField{#[deny()]f1, #[deny()]..} = f;\n+}\n+\n+fn main() {}"}, {"sha": "977843997c6dca6ff2a4dcb96e8f502581747161", "filename": "src/test/ui/lint/lint-attr-everywhere-late.stderr", "status": "added", "additions": 428, "deletions": 0, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/src%2Ftest%2Fui%2Flint%2Flint-attr-everywhere-late.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/src%2Ftest%2Fui%2Flint%2Flint-attr-everywhere-late.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-attr-everywhere-late.stderr?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -0,0 +1,428 @@\n+error: missing documentation for a type alias\n+  --> $DIR/lint-attr-everywhere-late.rs:35:1\n+   |\n+LL | pub type MissingDocType = i32;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:34:8\n+   |\n+LL | #[deny(missing_docs)]\n+   |        ^^^^^^^^^^^^\n+\n+error: missing documentation for a struct\n+  --> $DIR/lint-attr-everywhere-late.rs:43:1\n+   |\n+LL | pub struct ItemOuter;\n+   | ^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:42:8\n+   |\n+LL | #[deny(missing_docs)]\n+   |        ^^^^^^^^^^^^\n+\n+error: missing documentation for a module\n+  --> $DIR/lint-attr-everywhere-late.rs:45:1\n+   |\n+LL | pub mod module_inner {\n+   | ^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:46:13\n+   |\n+LL |     #![deny(missing_docs)]\n+   |             ^^^^^^^^^^^^\n+\n+error: missing documentation for a function\n+  --> $DIR/lint-attr-everywhere-late.rs:47:5\n+   |\n+LL |     pub fn missing_inner() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: missing documentation for an associated function\n+  --> $DIR/lint-attr-everywhere-late.rs:54:5\n+   |\n+LL |     pub fn inherent_denied_from_inner() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:52:13\n+   |\n+LL |     #![deny(missing_docs)]\n+   |             ^^^^^^^^^^^^\n+\n+error: missing documentation for an associated function\n+  --> $DIR/lint-attr-everywhere-late.rs:59:5\n+   |\n+LL |     pub fn inherent_fn() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:58:12\n+   |\n+LL |     #[deny(missing_docs)]\n+   |            ^^^^^^^^^^^^\n+\n+error: missing documentation for an associated constant\n+  --> $DIR/lint-attr-everywhere-late.rs:62:5\n+   |\n+LL |     pub const INHERENT_CONST: i32 = 1;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:61:12\n+   |\n+LL |     #[deny(missing_docs)]\n+   |            ^^^^^^^^^^^^\n+\n+error: missing documentation for a trait\n+  --> $DIR/lint-attr-everywhere-late.rs:65:1\n+   |\n+LL | pub trait TraitInner {\n+   | ^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:66:13\n+   |\n+LL |     #![deny(missing_docs)]\n+   |             ^^^^^^^^^^^^\n+\n+error: missing documentation for a trait\n+  --> $DIR/lint-attr-everywhere-late.rs:69:1\n+   |\n+LL | pub trait AssociatedTraitInner {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:70:13\n+   |\n+LL |     #![deny(missing_docs)]\n+   |             ^^^^^^^^^^^^\n+\n+error: missing documentation for an associated function\n+  --> $DIR/lint-attr-everywhere-late.rs:72:5\n+   |\n+LL |     fn denied_from_inner() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: missing documentation for an associated function\n+  --> $DIR/lint-attr-everywhere-late.rs:79:5\n+   |\n+LL |     fn assoc_fn() {}\n+   |     ^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:78:12\n+   |\n+LL |     #[deny(missing_docs)]\n+   |            ^^^^^^^^^^^^\n+\n+error: missing documentation for an associated constant\n+  --> $DIR/lint-attr-everywhere-late.rs:82:5\n+   |\n+LL |     const ASSOC_CONST: u8 = 1;\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:81:12\n+   |\n+LL |     #[deny(missing_docs)]\n+   |            ^^^^^^^^^^^^\n+\n+error: missing documentation for an associated type\n+  --> $DIR/lint-attr-everywhere-late.rs:85:5\n+   |\n+LL |     type AssocType;\n+   |     ^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:84:12\n+   |\n+LL |     #[deny(missing_docs)]\n+   |            ^^^^^^^^^^^^\n+\n+error: missing documentation for a variant\n+  --> $DIR/lint-attr-everywhere-late.rs:112:5\n+   |\n+LL |     Variant1,\n+   |     ^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:111:12\n+   |\n+LL |     #[deny(missing_docs)]\n+   |            ^^^^^^^^^^^^\n+\n+error: `clashing1` redeclared with a different signature\n+  --> $DIR/lint-attr-everywhere-late.rs:123:5\n+   |\n+LL |         fn clashing1();\n+   |         --------------- `clashing1` previously declared here\n+...\n+LL |     fn clashing1(_: i32);\n+   |     ^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:122:13\n+   |\n+LL |     #![deny(clashing_extern_declarations)]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: expected `unsafe extern \"C\" fn()`\n+              found `unsafe extern \"C\" fn(i32)`\n+\n+error: `clashing2` redeclared with a different signature\n+  --> $DIR/lint-attr-everywhere-late.rs:128:5\n+   |\n+LL |         fn clashing2();\n+   |         --------------- `clashing2` previously declared here\n+...\n+LL |     fn clashing2(_: i32);\n+   |     ^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:127:12\n+   |\n+LL |     #[deny(clashing_extern_declarations)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: expected `unsafe extern \"C\" fn()`\n+              found `unsafe extern \"C\" fn(i32)`\n+\n+error: types that do not implement `Drop` can still have drop glue, consider instead using `std::mem::needs_drop` to detect whether a type is trivially dropped\n+  --> $DIR/lint-attr-everywhere-late.rs:93:38\n+   |\n+LL |     fn denied_from_inner(_x: Box<dyn Drop>) {}\n+   |                                      ^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:91:13\n+   |\n+LL |     #![deny(dyn_drop)]\n+   |             ^^^^^^^^\n+\n+error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n+  --> $DIR/lint-attr-everywhere-late.rs:96:21\n+   |\n+LL |     fn assoc_fn() { discriminant::<i32>(&123); }\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:95:12\n+   |\n+LL |     #[deny(enum_intrinsics_non_enums)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n+  --> $DIR/lint-attr-everywhere-late.rs:96:41\n+   |\n+LL |     fn assoc_fn() { discriminant::<i32>(&123); }\n+   |                                         ^^^^\n+\n+error: literal out of range for `u8`\n+  --> $DIR/lint-attr-everywhere-late.rs:98:59\n+   |\n+LL |     #[deny(overflowing_literals)] const ASSOC_CONST: u8 = 1000;\n+   |                                                           ^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:98:12\n+   |\n+LL |     #[deny(overflowing_literals)] const ASSOC_CONST: u8 = 1000;\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   = note: the literal `1000` does not fit into the type `u8` whose range is `0..=255`\n+\n+error: variable `PARAM` should have a snake case name\n+  --> $DIR/lint-attr-everywhere-late.rs:131:37\n+   |\n+LL | fn function(#[deny(non_snake_case)] PARAM: i32) {}\n+   |                                     ^^^^^ help: convert the identifier to snake case: `param`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:131:20\n+   |\n+LL | fn function(#[deny(non_snake_case)] PARAM: i32) {}\n+   |                    ^^^^^^^^^^^^^^\n+\n+error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n+  --> $DIR/lint-attr-everywhere-late.rs:139:13\n+   |\n+LL |     let _ = discriminant::<i32>(&123);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:138:12\n+   |\n+LL |     #[deny(enum_intrinsics_non_enums)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n+  --> $DIR/lint-attr-everywhere-late.rs:139:33\n+   |\n+LL |     let _ = discriminant::<i32>(&123);\n+   |                                 ^^^^\n+\n+error: variable `PARAM` should have a snake case name\n+  --> $DIR/lint-attr-everywhere-late.rs:145:44\n+   |\n+LL |     let closure = |#[deny(non_snake_case)] PARAM: i32| {};\n+   |                                            ^^^^^ help: convert the identifier to snake case: `param`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:145:27\n+   |\n+LL |     let closure = |#[deny(non_snake_case)] PARAM: i32| {};\n+   |                           ^^^^^^^^^^^^^^\n+\n+error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n+  --> $DIR/lint-attr-everywhere-late.rs:155:13\n+   |\n+LL |             discriminant::<i32>(&123);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:153:17\n+   |\n+LL |         #![deny(enum_intrinsics_non_enums)]\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n+  --> $DIR/lint-attr-everywhere-late.rs:155:33\n+   |\n+LL |             discriminant::<i32>(&123);\n+   |                                 ^^^^\n+\n+error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n+  --> $DIR/lint-attr-everywhere-late.rs:161:13\n+   |\n+LL |             discriminant::<i32>(&123);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:159:16\n+   |\n+LL |         #[deny(enum_intrinsics_non_enums)]\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n+  --> $DIR/lint-attr-everywhere-late.rs:161:33\n+   |\n+LL |             discriminant::<i32>(&123);\n+   |                                 ^^^^\n+\n+error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n+  --> $DIR/lint-attr-everywhere-late.rs:168:9\n+   |\n+LL |         discriminant::<i32>(&123);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:167:17\n+   |\n+LL |         #![deny(enum_intrinsics_non_enums)]\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n+  --> $DIR/lint-attr-everywhere-late.rs:168:29\n+   |\n+LL |         discriminant::<i32>(&123);\n+   |                             ^^^^\n+\n+error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n+  --> $DIR/lint-attr-everywhere-late.rs:172:9\n+   |\n+LL |         discriminant::<i32>(&123);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:171:16\n+   |\n+LL |         #[deny(enum_intrinsics_non_enums)]\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n+  --> $DIR/lint-attr-everywhere-late.rs:172:29\n+   |\n+LL |         discriminant::<i32>(&123);\n+   |                             ^^^^\n+\n+error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n+  --> $DIR/lint-attr-everywhere-late.rs:177:5\n+   |\n+LL |     discriminant::<i32>(&123);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:176:12\n+   |\n+LL |     #[deny(enum_intrinsics_non_enums)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n+  --> $DIR/lint-attr-everywhere-late.rs:177:25\n+   |\n+LL |     discriminant::<i32>(&123);\n+   |                         ^^^^\n+\n+error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n+  --> $DIR/lint-attr-everywhere-late.rs:179:41\n+   |\n+LL |     [#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123)];\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:179:13\n+   |\n+LL |     [#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123)];\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n+  --> $DIR/lint-attr-everywhere-late.rs:179:61\n+   |\n+LL |     [#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123)];\n+   |                                                             ^^^^\n+\n+error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n+  --> $DIR/lint-attr-everywhere-late.rs:180:41\n+   |\n+LL |     (#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123),);\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:180:13\n+   |\n+LL |     (#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123),);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n+  --> $DIR/lint-attr-everywhere-late.rs:180:61\n+   |\n+LL |     (#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123),);\n+   |                                                             ^^^^\n+\n+error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n+  --> $DIR/lint-attr-everywhere-late.rs:182:45\n+   |\n+LL |     call(#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123));\n+   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:182:17\n+   |\n+LL |     call(#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123));\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n+  --> $DIR/lint-attr-everywhere-late.rs:182:65\n+   |\n+LL |     call(#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123));\n+   |                                                                 ^^^^\n+\n+error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n+  --> $DIR/lint-attr-everywhere-late.rs:184:52\n+   |\n+LL |     TupleStruct(#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123));\n+   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:184:24\n+   |\n+LL |     TupleStruct(#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n+  --> $DIR/lint-attr-everywhere-late.rs:184:72\n+   |\n+LL |     TupleStruct(#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123));\n+   |                                                                        ^^^^\n+\n+error: aborting due to 31 previous errors\n+"}, {"sha": "51f868706b69b76402f5be9d07c6a27624409706", "filename": "src/test/ui/lint/unused/unused_attributes-must_use.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/src%2Ftest%2Fui%2Flint%2Funused%2Funused_attributes-must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/src%2Ftest%2Fui%2Flint%2Funused%2Funused_attributes-must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Funused_attributes-must_use.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -122,4 +122,10 @@ fn main() {\n         Some(res) => res,\n         None => 0,\n     };\n+\n+    struct PatternField {\n+        foo: i32,\n+    }\n+    let s = PatternField { #[must_use]  foo: 123 }; //~ ERROR `#[must_use]` has no effect\n+    let PatternField { #[must_use] foo } = s; //~ ERROR `#[must_use]` has no effect\n }"}, {"sha": "dd112c23e5d9eba0b27a8b7efb93ebd7e2a3b1be", "filename": "src/test/ui/lint/unused/unused_attributes-must_use.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/src%2Ftest%2Fui%2Flint%2Funused%2Funused_attributes-must_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/src%2Ftest%2Fui%2Flint%2Funused%2Funused_attributes-must_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Funused_attributes-must_use.stderr?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -105,6 +105,18 @@ error: `#[must_use]` has no effect when applied to an match arm\n LL |         #[must_use]\n    |         ^^^^^^^^^^^\n \n+error: `#[must_use]` has no effect when applied to a struct field\n+  --> $DIR/unused_attributes-must_use.rs:129:28\n+   |\n+LL |     let s = PatternField { #[must_use]  foo: 123 };\n+   |                            ^^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to a pattern field\n+  --> $DIR/unused_attributes-must_use.rs:130:24\n+   |\n+LL |     let PatternField { #[must_use] foo } = s;\n+   |                        ^^^^^^^^^^^\n+\n error: `#[must_use]` has no effect when applied to an associated const\n   --> $DIR/unused_attributes-must_use.rs:68:5\n    |\n@@ -171,5 +183,5 @@ error: unused return value of `Use::get_four` that must be used\n LL |     ().get_four();\n    |     ^^^^^^^^^^^^^^\n \n-error: aborting due to 26 previous errors\n+error: aborting due to 28 previous errors\n "}, {"sha": "59f10247a11d4c98ea4821a3746ee2479c37aff9", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6ce76091c7cef21692a15dce1f0a4c415d245be4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce76091c7cef21692a15dce1f0a4c415d245be4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=6ce76091c7cef21692a15dce1f0a4c415d245be4", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::sugg::has_enclosing_paren;\n use clippy_utils::ty::{expr_sig, peel_mid_ty_refs, ty_sig, variant_of_res};\n-use clippy_utils::{get_parent_expr, is_lint_allowed, path_to_local, walk_to_expr_usage};\n+use clippy_utils::{get_parent_expr, get_parent_expr_for_hir, is_lint_allowed, path_to_local, walk_to_expr_usage};\n use rustc_ast::util::parser::{PREC_POSTFIX, PREC_PREFIX};\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n@@ -699,6 +699,19 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                 Some(ty_auto_deref_stability(cx, output, precedence).position_for_result(cx))\n             },\n \n+            Node::ExprField(field) if field.span.ctxt() == ctxt => match get_parent_expr_for_hir(cx, field.hir_id) {\n+                Some(Expr {\n+                    hir_id,\n+                    kind: ExprKind::Struct(path, ..),\n+                    ..\n+                }) => variant_of_res(cx, cx.qpath_res(path, *hir_id))\n+                    .and_then(|variant| variant.fields.iter().find(|f| f.name == field.ident.name))\n+                    .map(|field_def| {\n+                        ty_auto_deref_stability(cx, cx.tcx.type_of(field_def.did), precedence).position_for_arg()\n+                    }),\n+                _ => None,\n+            },\n+\n             Node::Expr(parent) if parent.span.ctxt() == ctxt => match parent.kind {\n                 ExprKind::Ret(_) => {\n                     let owner_id = cx.tcx.hir().body_owner(cx.enclosing_body.unwrap());\n@@ -788,17 +801,6 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                         }\n                     })\n                 },\n-                ExprKind::Struct(path, fields, _) => {\n-                    let variant = variant_of_res(cx, cx.qpath_res(path, parent.hir_id));\n-                    fields\n-                        .iter()\n-                        .find(|f| f.expr.hir_id == child_id)\n-                        .zip(variant)\n-                        .and_then(|(field, variant)| variant.fields.iter().find(|f| f.name == field.ident.name))\n-                        .map(|field| {\n-                            ty_auto_deref_stability(cx, cx.tcx.type_of(field.did), precedence).position_for_arg()\n-                        })\n-                },\n                 ExprKind::Field(child, name) if child.hir_id == e.hir_id => Some(Position::FieldAccess(name.name)),\n                 ExprKind::Unary(UnOp::Deref, child) if child.hir_id == e.hir_id => Some(Position::Deref),\n                 ExprKind::Match(child, _, MatchSource::TryDesugar | MatchSource::AwaitDesugar)"}]}