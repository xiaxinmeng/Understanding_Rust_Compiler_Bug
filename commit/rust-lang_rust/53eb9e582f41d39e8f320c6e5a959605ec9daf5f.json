{"sha": "53eb9e582f41d39e8f320c6e5a959605ec9daf5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzZWI5ZTU4MmY0MWQzOWU4ZjMyMGM2ZTVhOTU5NjA1ZWM5ZGFmNWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-01T14:50:05Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-05T09:03:56Z"}, "message": "add `Locations::All` as a concept\n\nIn particular, type annotations given by the user must hold at all\npoints in the program. This doesn't affect current analysis but\nwill affect fact generation later.", "tree": {"sha": "d5c625d5bc9cb5eaca72739f5bb0cda14ad7207e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5c625d5bc9cb5eaca72739f5bb0cda14ad7207e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53eb9e582f41d39e8f320c6e5a959605ec9daf5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53eb9e582f41d39e8f320c6e5a959605ec9daf5f", "html_url": "https://github.com/rust-lang/rust/commit/53eb9e582f41d39e8f320c6e5a959605ec9daf5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53eb9e582f41d39e8f320c6e5a959605ec9daf5f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81905a15c1f466fa6f57cf62d5277efcd01fbb9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/81905a15c1f466fa6f57cf62d5277efcd01fbb9b", "html_url": "https://github.com/rust-lang/rust/commit/81905a15c1f466fa6f57cf62d5277efcd01fbb9b"}], "stats": {"total": 124, "additions": 74, "deletions": 50}, "files": [{"sha": "411bf5b55ed6b3de70cbad768fcb99116ff132ee", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eb9e582f41d39e8f320c6e5a959605ec9daf5f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eb9e582f41d39e8f320c6e5a959605ec9daf5f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=53eb9e582f41d39e8f320c6e5a959605ec9daf5f", "patch": "@@ -38,7 +38,6 @@ mod universal_regions;\n use self::region_infer::RegionInferenceContext;\n use self::universal_regions::UniversalRegions;\n \n-\n /// Rewrites the regions in the MIR to use NLL variables, also\n /// scraping out the set of universal regions (e.g., region parameters)\n /// declared on the function. That set will need to be given to"}, {"sha": "05b61f25a398c1debff978feaaed0be72e943f28", "filename": "src/librustc_mir/borrow_check/nll/subtype_constraint_generation.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/53eb9e582f41d39e8f320c6e5a959605ec9daf5f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eb9e582f41d39e8f320c6e5a959605ec9daf5f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs?ref=53eb9e582f41d39e8f320c6e5a959605ec9daf5f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::mir::Mir;\n+use rustc::mir::{Location, Mir};\n use rustc::infer::region_constraints::Constraint;\n use rustc::infer::region_constraints::RegionConstraintData;\n use rustc::infer::region_constraints::{Verify, VerifyBound};\n@@ -65,7 +65,11 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n                 givens,\n             } = data;\n \n-            let span = self.mir.source_info(locations.from_location).span;\n+            let span = self.mir\n+                .source_info(locations.from_location().unwrap_or(Location::START))\n+                .span;\n+\n+            let at_location = locations.at_location().unwrap_or(Location::START);\n \n             for constraint in constraints.keys() {\n                 debug!(\"generate: constraint: {:?}\", constraint);\n@@ -83,8 +87,7 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n                 // reverse direction, because `regioncx` talks about\n                 // \"outlives\" (`>=`) whereas the region constraints\n                 // talk about `<=`.\n-                self.regioncx\n-                    .add_outlives(span, b_vid, a_vid, locations.at_location);\n+                self.regioncx.add_outlives(span, b_vid, a_vid, at_location);\n             }\n \n             for verify in verifys {\n@@ -109,7 +112,7 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n \n         let lower_bound = self.to_region_vid(verify.region);\n \n-        let point = locations.at_location;\n+        let point = locations.at_location().unwrap_or(Location::START);\n \n         let test = self.verify_bound_to_region_test(&verify.bound);\n \n@@ -149,14 +152,6 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n     }\n \n     fn to_region_vid(&self, r: ty::Region<'tcx>) -> ty::RegionVid {\n-        // Every region that we see in the constraints came from the\n-        // MIR or from the parameter environment. If the former, it\n-        // will be a region variable.  If the latter, it will be in\n-        // the set of universal regions *somewhere*.\n-        if let ty::ReVar(vid) = r {\n-            *vid\n-        } else {\n-            self.regioncx.to_region_vid(r)\n-        }\n+        self.regioncx.to_region_vid(r)\n     }\n }"}, {"sha": "2b1878c33e90b78f877672427d6c7f6703fae1de", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/53eb9e582f41d39e8f320c6e5a959605ec9daf5f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eb9e582f41d39e8f320c6e5a959605ec9daf5f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=53eb9e582f41d39e8f320c6e5a959605ec9daf5f", "patch": "@@ -29,7 +29,7 @@ use rustc::traits::PredicateObligations;\n \n use rustc_data_structures::indexed_vec::Idx;\n \n-use super::{AtLocation, TypeChecker};\n+use super::{Locations, TypeChecker};\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     pub(super) fn equate_inputs_and_outputs(\n@@ -47,26 +47,21 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         } = universal_regions;\n         let infcx = self.infcx;\n \n-        let start_position = Location {\n-            block: START_BLOCK,\n-            statement_index: 0,\n-        };\n-\n         // Equate expected input tys with those in the MIR.\n         let argument_locals = (1..).map(Local::new);\n         for (&unnormalized_input_ty, local) in unnormalized_input_tys.iter().zip(argument_locals) {\n-            let input_ty = self.normalize(&unnormalized_input_ty, start_position);\n+            let input_ty = self.normalize(&unnormalized_input_ty, Locations::All);\n             let mir_input_ty = mir.local_decls[local].ty;\n-            self.equate_normalized_input_or_output(start_position, input_ty, mir_input_ty);\n+            self.equate_normalized_input_or_output(input_ty, mir_input_ty);\n         }\n \n         assert!(\n             mir.yield_ty.is_some() && universal_regions.yield_ty.is_some() ||\n             mir.yield_ty.is_none() && universal_regions.yield_ty.is_none()\n-            );\n+        );\n         if let Some(mir_yield_ty) = mir.yield_ty {\n             let ur_yield_ty = universal_regions.yield_ty.unwrap();\n-            self.equate_normalized_input_or_output(start_position, ur_yield_ty, mir_yield_ty);\n+            self.equate_normalized_input_or_output(ur_yield_ty, mir_yield_ty);\n         }\n \n         // Return types are a bit more complex. They may contain existential `impl Trait`\n@@ -75,13 +70,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             \"equate_inputs_and_outputs: unnormalized_output_ty={:?}\",\n             unnormalized_output_ty\n         );\n-        let output_ty = self.normalize(&unnormalized_output_ty, start_position);\n+        let output_ty = self.normalize(&unnormalized_output_ty, Locations::All);\n         debug!(\n             \"equate_inputs_and_outputs: normalized output_ty={:?}\",\n             output_ty\n         );\n         let mir_output_ty = mir.local_decls[RETURN_PLACE].ty;\n-        let anon_type_map = self.fully_perform_op(start_position.at_self(), |cx| {\n+        let anon_type_map = self.fully_perform_op(Locations::All, |cx| {\n             let mut obligations = ObligationAccumulator::default();\n \n             let (output_ty, anon_type_map) = obligations.add(infcx.instantiate_anon_types(\n@@ -148,7 +143,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         // prove that `T: Iterator` where `T` is the type we\n         // instantiated it with).\n         if let Some(anon_type_map) = anon_type_map {\n-            self.fully_perform_op(start_position.at_self(), |_cx| {\n+            self.fully_perform_op(Locations::All, |_cx| {\n                 infcx.constrain_anon_types(&anon_type_map, universal_regions);\n                 Ok(InferOk {\n                     value: (),\n@@ -158,13 +153,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn equate_normalized_input_or_output(&mut self, location: Location, a: Ty<'tcx>, b: Ty<'tcx>) {\n+    fn equate_normalized_input_or_output(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {\n         debug!(\"equate_normalized_input_or_output(a={:?}, b={:?})\", a, b);\n \n-        if let Err(terr) = self.eq_types(a, b, location.at_self()) {\n+        if let Err(terr) = self.eq_types(a, b, Locations::All) {\n             span_mirbug!(\n                 self,\n-                location,\n+                Location::START,\n                 \"equate_normalized_input_or_output: `{:?}=={:?}` failed with `{:?}`\",\n                 a,\n                 b,"}, {"sha": "ec98a0a02c066144e0d1be58adb99ce8706de629", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 54, "deletions": 19, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/53eb9e582f41d39e8f320c6e5a959605ec9daf5f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eb9e582f41d39e8f320c6e5a959605ec9daf5f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=53eb9e582f41d39e8f320c6e5a959605ec9daf5f", "patch": "@@ -619,16 +619,35 @@ pub struct OutlivesSet<'tcx> {\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub struct Locations {\n-    /// The location in the MIR that generated these constraints.\n-    /// This is intended for error reporting and diagnosis; the\n-    /// constraints may *take effect* at a distinct spot.\n-    pub from_location: Location,\n-\n-    /// The constraints must be met at this location. In terms of the\n-    /// NLL RFC, when you have a constraint `R1: R2 @ P`, this field\n-    /// is the `P` value.\n-    pub at_location: Location,\n+pub enum Locations {\n+    All,\n+    Pair {\n+        /// The location in the MIR that generated these constraints.\n+        /// This is intended for error reporting and diagnosis; the\n+        /// constraints may *take effect* at a distinct spot.\n+        from_location: Location,\n+\n+        /// The constraints must be met at this location. In terms of the\n+        /// NLL RFC, when you have a constraint `R1: R2 @ P`, this field\n+        /// is the `P` value.\n+        at_location: Location,\n+    }\n+}\n+\n+impl Locations {\n+    pub fn from_location(&self) -> Option<Location> {\n+        match self {\n+            Locations::All => None,\n+            Locations::Pair { from_location, .. } => Some(*from_location),\n+        }\n+    }\n+\n+    pub fn at_location(&self) -> Option<Location> {\n+        match self {\n+            Locations::All => None,\n+            Locations::Pair { at_location, .. } => Some(*at_location),\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n@@ -770,7 +789,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     \"check_stmt: user_assert_ty ty={:?} local_ty={:?}\",\n                     ty, local_ty\n                 );\n-                if let Err(terr) = self.eq_types(ty, local_ty, location.at_self()) {\n+                if let Err(terr) = self.eq_types(ty, local_ty, Locations::All) {\n                     span_mirbug!(\n                         self,\n                         stmt,\n@@ -820,7 +839,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let place_ty = location.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = value.ty(mir, tcx);\n \n-                let locations = Locations {\n+                let locations = Locations::Pair {\n                     from_location: term_location,\n                     at_location: target.start_location(),\n                 };\n@@ -839,7 +858,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // *both* blocks, so we need to ensure that it holds\n                 // at both locations.\n                 if let Some(unwind) = unwind {\n-                    let locations = Locations {\n+                    let locations = Locations::Pair {\n                         from_location: term_location,\n                         at_location: unwind.start_location(),\n                     };\n@@ -971,7 +990,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         match *destination {\n             Some((ref dest, target_block)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n-                let locations = Locations {\n+                let locations = Locations::Pair {\n                     from_location: term_location,\n                     at_location: target_block.start_location(),\n                 };\n@@ -1375,7 +1394,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             };\n             let operand_ty = operand.ty(mir, tcx);\n             if let Err(terr) =\n-                self.sub_types(operand_ty, field_ty, location.at_successor_within_block())\n+                self.sub_types(operand_ty, field_ty, location.at_self())\n             {\n                 span_mirbug!(\n                     self,\n@@ -1514,12 +1533,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn normalize<T>(&mut self, value: &T, location: Location) -> T\n+    fn normalize<T>(&mut self, value: &T, location: impl ToLocations) -> T\n     where\n         T: fmt::Debug + TypeFoldable<'tcx>,\n     {\n         debug!(\"normalize(value={:?}, location={:?})\", value, location);\n-        self.fully_perform_op(location.at_self(), |this| {\n+        self.fully_perform_op(location.to_locations(), |this| {\n             let Normalized { value, obligations } = this.infcx\n                 .at(&this.misc(this.last_span), this.param_env)\n                 .normalize(value)\n@@ -1585,16 +1604,32 @@ trait AtLocation {\n \n impl AtLocation for Location {\n     fn at_self(self) -> Locations {\n-        Locations {\n+        Locations::Pair {\n             from_location: self,\n             at_location: self,\n         }\n     }\n \n     fn at_successor_within_block(self) -> Locations {\n-        Locations {\n+        Locations::Pair {\n             from_location: self,\n             at_location: self.successor_within_block(),\n         }\n     }\n }\n+\n+trait ToLocations: fmt::Debug + Copy {\n+    fn to_locations(self) -> Locations;\n+}\n+\n+impl ToLocations for Locations {\n+    fn to_locations(self) -> Locations {\n+        self\n+    }\n+}\n+\n+impl ToLocations for Location {\n+    fn to_locations(self) -> Locations {\n+        self.at_self()\n+    }\n+}"}]}