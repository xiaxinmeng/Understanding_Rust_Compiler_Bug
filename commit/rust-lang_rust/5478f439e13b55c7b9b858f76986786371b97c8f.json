{"sha": "5478f439e13b55c7b9b858f76986786371b97c8f", "node_id": "C_kwDOAAsO6NoAKDU0NzhmNDM5ZTEzYjU1YzdiOWI4NThmNzY5ODY3ODYzNzFiOTdjOGY", "commit": {"author": {"name": "Ibraheem Ahmed", "email": "ibrah1440@gmail.com", "date": "2021-12-08T22:08:23Z"}, "committer": {"name": "Ibraheem Ahmed", "email": "ibrah1440@gmail.com", "date": "2021-12-08T22:21:32Z"}, "message": "trim down expansion of `core::future::join`", "tree": {"sha": "54c87a7232d4ea7ad02610dc9df2bbbbb28ef17e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54c87a7232d4ea7ad02610dc9df2bbbbb28ef17e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5478f439e13b55c7b9b858f76986786371b97c8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5478f439e13b55c7b9b858f76986786371b97c8f", "html_url": "https://github.com/rust-lang/rust/commit/5478f439e13b55c7b9b858f76986786371b97c8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5478f439e13b55c7b9b858f76986786371b97c8f/comments", "author": {"login": "ibraheemdev", "id": 34988408, "node_id": "MDQ6VXNlcjM0OTg4NDA4", "avatar_url": "https://avatars.githubusercontent.com/u/34988408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibraheemdev", "html_url": "https://github.com/ibraheemdev", "followers_url": "https://api.github.com/users/ibraheemdev/followers", "following_url": "https://api.github.com/users/ibraheemdev/following{/other_user}", "gists_url": "https://api.github.com/users/ibraheemdev/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibraheemdev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibraheemdev/subscriptions", "organizations_url": "https://api.github.com/users/ibraheemdev/orgs", "repos_url": "https://api.github.com/users/ibraheemdev/repos", "events_url": "https://api.github.com/users/ibraheemdev/events{/privacy}", "received_events_url": "https://api.github.com/users/ibraheemdev/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibraheemdev", "id": 34988408, "node_id": "MDQ6VXNlcjM0OTg4NDA4", "avatar_url": "https://avatars.githubusercontent.com/u/34988408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibraheemdev", "html_url": "https://github.com/ibraheemdev", "followers_url": "https://api.github.com/users/ibraheemdev/followers", "following_url": "https://api.github.com/users/ibraheemdev/following{/other_user}", "gists_url": "https://api.github.com/users/ibraheemdev/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibraheemdev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibraheemdev/subscriptions", "organizations_url": "https://api.github.com/users/ibraheemdev/orgs", "repos_url": "https://api.github.com/users/ibraheemdev/repos", "events_url": "https://api.github.com/users/ibraheemdev/events{/privacy}", "received_events_url": "https://api.github.com/users/ibraheemdev/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8c931410020840584a2efa5f77239a9c5fcb85c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8c931410020840584a2efa5f77239a9c5fcb85c", "html_url": "https://github.com/rust-lang/rust/commit/a8c931410020840584a2efa5f77239a9c5fcb85c"}], "stats": {"total": 98, "additions": 56, "deletions": 42}, "files": [{"sha": "aadff103ebab44ef04973612948e6113ddaba30f", "filename": "library/core/src/future/join.rs", "status": "modified", "additions": 56, "deletions": 42, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/5478f439e13b55c7b9b858f76986786371b97c8f/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5478f439e13b55c7b9b858f76986786371b97c8f/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs?ref=5478f439e13b55c7b9b858f76986786371b97c8f", "patch": "@@ -2,8 +2,9 @@\n \n use crate::cell::UnsafeCell;\n use crate::future::{poll_fn, Future};\n+use crate::mem;\n use crate::pin::Pin;\n-use crate::task::Poll;\n+use crate::task::{Context, Poll};\n \n /// Polls multiple futures simultaneously, returning a tuple\n /// of all results once complete.\n@@ -70,64 +71,77 @@ pub macro join {\n             $( $(@$f:tt)? $fut:expr => ( $($pos:tt)* ), )*\n         },\n         @rest: ()\n-    ) => {{\n+    ) => {\n         async move {\n-            // The futures and whether they have completed\n-            let mut state = ( $( UnsafeCell::new(($fut, false)), )* );\n-\n-            // Make sure the futures don't panic\n-            // if polled after completion, and\n-            // store their output separately\n-            let mut futures = ($(\n-                ({\n-                    let ( $($pos,)* state, .. ) = &state;\n-\n-                    poll_fn(move |cx| {\n-                        // SAFETY: each future borrows a distinct element\n-                        // of the tuple\n-                        let (fut, done) = unsafe { &mut *state.get() };\n-\n-                        if *done {\n-                            return Poll::Ready(None)\n-                        }\n-\n-                        // SAFETY: The futures are never moved\n-                        match unsafe { Pin::new_unchecked(fut).poll(cx) } {\n-                            Poll::Ready(val) => {\n-                                *done = true;\n-                                Poll::Ready(Some(val))\n-                            }\n-                            Poll::Pending => Poll::Pending\n-                        }\n-                    })\n-                }, None),\n-            )*);\n+            let mut futures = ( $( MaybeDone::Future($fut), )* );\n \n             poll_fn(move |cx| {\n                 let mut done = true;\n \n                 $(\n-                    let ( $($pos,)* (fut, out), .. ) = &mut futures;\n+                    let ( $($pos,)* fut, .. ) = &mut futures;\n \n                     // SAFETY: The futures are never moved\n-                    match unsafe { Pin::new_unchecked(fut).poll(cx) } {\n-                        Poll::Ready(Some(val)) => *out = Some(val),\n-                        // the future was already done\n-                        Poll::Ready(None) => {},\n-                        Poll::Pending => done = false,\n-                    }\n+                    done &= unsafe { Pin::new_unchecked(fut).poll(cx).is_ready() };\n                 )*\n \n                 if done {\n                     // Extract all the outputs\n                     Poll::Ready(($({\n-                        let ( $($pos,)* (_, val), .. ) = &mut futures;\n-                        val.unwrap()\n+                        let ( $($pos,)* fut, .. ) = &mut futures;\n+\n+                        fut.take_output().unwrap()\n                     }),*))\n                 } else {\n                     Poll::Pending\n                 }\n             }).await\n         }\n-    }}\n+    }\n+}\n+\n+/// Future used by `join!` that stores it's output to\n+/// be later taken and doesn't panic when polled after ready.\n+///\n+/// This type is public in a private module for use by the macro.\n+#[allow(missing_debug_implementations)]\n+#[unstable(feature = \"future_join\", issue = \"91642\")]\n+pub enum MaybeDone<F: Future> {\n+    Future(F),\n+    Done(F::Output),\n+    Took,\n+}\n+\n+#[unstable(feature = \"future_join\", issue = \"91642\")]\n+impl<F: Future> MaybeDone<F> {\n+    pub fn take_output(&mut self) -> Option<F::Output> {\n+        match &*self {\n+            MaybeDone::Done(_) => match mem::replace(self, Self::Took) {\n+                MaybeDone::Done(val) => Some(val),\n+                _ => unreachable!(),\n+            },\n+            _ => None,\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"future_join\", issue = \"91642\")]\n+impl<F: Future> Future for MaybeDone<F> {\n+    type Output = ();\n+\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        // SAFETY: pinning in structural for `f`\n+        unsafe {\n+            match self.as_mut().get_unchecked_mut() {\n+                MaybeDone::Future(f) => match Pin::new_unchecked(f).poll(cx) {\n+                    Poll::Ready(val) => self.set(Self::Done(val)),\n+                    Poll::Pending => return Poll::Pending,\n+                },\n+                MaybeDone::Done(_) => {}\n+                MaybeDone::Took => unreachable!(),\n+            }\n+        }\n+\n+        Poll::Ready(())\n+    }\n }"}]}