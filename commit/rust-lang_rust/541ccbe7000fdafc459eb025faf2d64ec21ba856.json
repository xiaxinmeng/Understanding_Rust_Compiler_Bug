{"sha": "541ccbe7000fdafc459eb025faf2d64ec21ba856", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MWNjYmU3MDAwZmRhZmM0NTllYjAyNWZhZjJkNjRlYzIxYmE4NTY=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-05-11T22:31:51Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-05-11T22:31:51Z"}, "message": "Merge pull request #61 from oli-obk/master\n\na panic->Result conversion approach to idem test", "tree": {"sha": "45e7714d5e00ea82842eeb064d5bb135ec7f5a15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45e7714d5e00ea82842eeb064d5bb135ec7f5a15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/541ccbe7000fdafc459eb025faf2d64ec21ba856", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/541ccbe7000fdafc459eb025faf2d64ec21ba856", "html_url": "https://github.com/rust-lang/rust/commit/541ccbe7000fdafc459eb025faf2d64ec21ba856", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/541ccbe7000fdafc459eb025faf2d64ec21ba856/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83285269ee7f5221c1527096c9e5ca375f89a3a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/83285269ee7f5221c1527096c9e5ca375f89a3a1", "html_url": "https://github.com/rust-lang/rust/commit/83285269ee7f5221c1527096c9e5ca375f89a3a1"}, {"sha": "ee338d934e0ab1c13cfc14a90219036da3a67ed1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee338d934e0ab1c13cfc14a90219036da3a67ed1", "html_url": "https://github.com/rust-lang/rust/commit/ee338d934e0ab1c13cfc14a90219036da3a67ed1"}], "stats": {"total": 75, "additions": 50, "deletions": 25}, "files": [{"sha": "d19bcc6fa55c5264b904c4ed4f09ca16de6066bc", "filename": "tests/idem.rs", "status": "modified", "additions": 50, "deletions": 25, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/541ccbe7000fdafc459eb025faf2d64ec21ba856/tests%2Fidem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541ccbe7000fdafc459eb025faf2d64ec21ba856/tests%2Fidem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fidem.rs?ref=541ccbe7000fdafc459eb025faf2d64ec21ba856", "patch": "@@ -8,12 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(catch_panic)]\n+\n extern crate rustfmt;\n \n use std::collections::HashMap;\n use std::fs;\n use std::io::Read;\n-use std::sync::atomic;\n+use std::thread;\n use rustfmt::*;\n \n // For now, the only supported regression tests are idempotent tests - the input and\n@@ -22,52 +24,75 @@ use rustfmt::*;\n #[test]\n fn idempotent_tests() {\n     println!(\"Idempotent tests:\");\n-    FAILURES.store(0, atomic::Ordering::Relaxed);\n \n     // Get all files in the tests/idem directory\n     let files = fs::read_dir(\"tests/idem\").unwrap();\n+    let files = files.chain(fs::read_dir(\"tests\").unwrap());\n+    let files = files.chain(fs::read_dir(\"src/bin\").unwrap());\n+    // turn a DirEntry into a String that represents the relative path to the file\n+    let files = files.map(|e| e.unwrap().path().to_str().unwrap().to_owned());\n+    // hack because there's no `IntoIterator` impl for `[T; N]`\n+    let files = files.chain(Some(\"src/lib.rs\".to_owned()).into_iter());\n+\n     // For each file, run rustfmt and collect the output\n     let mut count = 0;\n-    for entry in files {\n-        let path = entry.unwrap().path();\n-        let file_name = path.to_str().unwrap();\n+    let mut fails = 0;\n+    for file_name in files.filter(|f| f.ends_with(\".rs\")) {\n         println!(\"Testing '{}'...\", file_name);\n-        run(vec![\"rustfmt\".to_owned(), file_name.to_owned()], WriteMode::Return(HANDLE_RESULT));\n+        match idempotent_check(file_name) {\n+            Ok(()) => {},\n+            Err(m) => {\n+                print_mismatches(m);\n+                fails += 1;\n+            },\n+        }\n         count += 1;\n     }\n-    // And also dogfood ourselves!\n-    println!(\"Testing 'src/lib.rs'...\");\n-    run(vec![\"rustfmt\".to_string(), \"src/lib.rs\".to_string()],\n-        WriteMode::Return(HANDLE_RESULT));\n-    count += 1;\n \n     // Display results\n-    let fails = FAILURES.load(atomic::Ordering::Relaxed);\n     println!(\"Ran {} idempotent tests; {} failures.\", count, fails);\n     assert!(fails == 0, \"{} idempotent tests failed\", fails);\n }\n \n-// 'global' used by sys_tests and handle_result.\n-static FAILURES: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n+// Compare output to input.\n+fn print_mismatches(result: HashMap<String, String>) {\n+    for (file_name, fmt_text) in result {\n+        println!(\"Mismatch in {}.\", file_name);\n+        println!(\"{}\", fmt_text);\n+    }\n+}\n+\n // Ick, just needed to get a &'static to handle_result.\n static HANDLE_RESULT: &'static Fn(HashMap<String, String>) = &handle_result;\n \n+pub fn idempotent_check(filename: String) -> Result<(), HashMap<String, String>> {\n+    let args = vec![\"rustfmt\".to_owned(), filename];\n+    // this thread is not used for concurrency, but rather to workaround the issue that the passed\n+    // function handle needs to have static lifetime. Instead of using a global RefCell, we use\n+    // panic to return a result in case of failure. This has the advantage of smoothing the road to\n+    // multithreaded rustfmt\n+    thread::catch_panic(move || {\n+        run(args, WriteMode::Return(HANDLE_RESULT));\n+    }).map_err(|any|\n+        // i know it is a hashmap\n+        *any.downcast().unwrap()\n+    )\n+}\n+\n // Compare output to input.\n fn handle_result(result: HashMap<String, String>) {\n-    let mut fails = 0;\n+    let mut failures = HashMap::new();\n \n-    for file_name in result.keys() {\n-        let mut f = fs::File::open(file_name).unwrap();\n+    for (file_name, fmt_text) in result {\n+        let mut f = fs::File::open(&file_name).unwrap();\n         let mut text = String::new();\n+        // TODO: speedup by running through bytes iterator\n         f.read_to_string(&mut text).unwrap();\n-        if result[file_name] != text {\n-            fails += 1;\n-            println!(\"Mismatch in {}.\", file_name);\n-            println!(\"{}\", result[file_name]);\n+        if fmt_text != text {\n+            failures.insert(file_name, fmt_text);\n         }\n     }\n-\n-    if fails > 0 {\n-        FAILURES.fetch_add(1, atomic::Ordering::Relaxed);\n+    if !failures.is_empty() {\n+        panic!(failures);\n     }\n-}\n\\ No newline at end of file\n+}"}]}