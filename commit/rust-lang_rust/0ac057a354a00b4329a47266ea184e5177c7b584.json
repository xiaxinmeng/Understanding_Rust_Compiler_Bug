{"sha": "0ac057a354a00b4329a47266ea184e5177c7b584", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhYzA1N2EzNTRhMDBiNDMyOWE0NzI2NmVhMTg0ZTUxNzdjN2I1ODQ=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-01-07T06:26:29Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-02-15T23:22:24Z"}, "message": "Add integer tests", "tree": {"sha": "d12c4c31347e40eab1d3ec0b49c0174351006fdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d12c4c31347e40eab1d3ec0b49c0174351006fdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ac057a354a00b4329a47266ea184e5177c7b584", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ac057a354a00b4329a47266ea184e5177c7b584", "html_url": "https://github.com/rust-lang/rust/commit/0ac057a354a00b4329a47266ea184e5177c7b584", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ac057a354a00b4329a47266ea184e5177c7b584/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5c227998bdc854938bdbf7dea96a58d2f7395a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5c227998bdc854938bdbf7dea96a58d2f7395a2", "html_url": "https://github.com/rust-lang/rust/commit/d5c227998bdc854938bdbf7dea96a58d2f7395a2"}], "stats": {"total": 212, "additions": 208, "deletions": 4}, "files": [{"sha": "56d66239e8060a1f96a771a90091816bccb94354", "filename": "crates/core_simd/tests/float.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ac057a354a00b4329a47266ea184e5177c7b584/crates%2Fcore_simd%2Ftests%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac057a354a00b4329a47266ea184e5177c7b584/crates%2Fcore_simd%2Ftests%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Ffloat.rs?ref=0ac057a354a00b4329a47266ea184e5177c7b584", "patch": "@@ -8,6 +8,7 @@ macro_rules! impl_op_test {\n                 test_helpers::test_unary_elementwise(\n                     <$vector as core::ops::$trait>::$fn,\n                     <$scalar as core::ops::$trait>::$fn,\n+                    |_| true,\n                 );\n             }\n         }\n@@ -21,34 +22,39 @@ macro_rules! impl_op_test {\n                     test_helpers::test_binary_elementwise(\n                         <$vector as core::ops::$trait>::$fn,\n                         <$scalar as core::ops::$trait>::$fn,\n+                        |_, _| true,\n                     );\n                 }\n \n                 fn scalar_rhs<const LANES: usize>() {\n                     test_helpers::test_binary_scalar_rhs_elementwise(\n                         <$vector as core::ops::$trait<$scalar>>::$fn,\n                         <$scalar as core::ops::$trait>::$fn,\n+                        |_, _| true,\n                     );\n                 }\n \n                 fn scalar_lhs<const LANES: usize>() {\n                     test_helpers::test_binary_scalar_lhs_elementwise(\n                         <$scalar as core::ops::$trait<$vector>>::$fn,\n                         <$scalar as core::ops::$trait>::$fn,\n+                        |_, _| true,\n                     );\n                 }\n \n                 fn assign<const LANES: usize>() {\n                     test_helpers::test_binary_elementwise(\n                         |mut a, b| { <$vector as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n                         |mut a, b| { <$scalar as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n+                        |_, _| true,\n                     )\n                 }\n \n                 fn assign_scalar_rhs<const LANES: usize>() {\n                     test_helpers::test_binary_scalar_rhs_elementwise(\n                         |mut a, b| { <$vector as core::ops::$trait_assign<$scalar>>::$fn_assign(&mut a, b); a },\n                         |mut a, b| { <$scalar as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n+                        |_, _| true,\n                     )\n                 }\n             }\n@@ -62,7 +68,7 @@ macro_rules! impl_tests {\n             type Vector<const LANES: usize> = core_simd::$vector<LANES>;\n             type Scalar = $scalar;\n             type IntScalar = $int_scalar;\n-            \n+\n             impl_op_test! { unary, Vector<LANES>, Scalar, Neg::neg }\n             impl_op_test! { binary, Vector<LANES>, Scalar, Add::add, AddAssign::add_assign }\n             impl_op_test! { binary, Vector<LANES>, Scalar, Sub::sub, SubAssign::sub_assign }\n@@ -75,27 +81,31 @@ macro_rules! impl_tests {\n                     test_helpers::test_unary_elementwise(\n                         Vector::<LANES>::abs,\n                         Scalar::abs,\n+                        |_| true,\n                     )\n                 }\n \n                 fn ceil<const LANES: usize>() {\n                     test_helpers::test_unary_elementwise(\n                         Vector::<LANES>::ceil,\n                         Scalar::ceil,\n+                        |_| true,\n                     )\n                 }\n \n                 fn floor<const LANES: usize>() {\n                     test_helpers::test_unary_elementwise(\n                         Vector::<LANES>::floor,\n                         Scalar::floor,\n+                        |_| true,\n                     )\n                 }\n \n                 fn round_from_int<const LANES: usize>() {\n                     test_helpers::test_unary_elementwise(\n                         Vector::<LANES>::round_from_int,\n                         |x| x as Scalar,\n+                        |_| true,\n                     )\n                 }\n "}, {"sha": "4f38cdb1ed63723d673cd311906d7fdb144383a6", "filename": "crates/core_simd/tests/integer.rs", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/0ac057a354a00b4329a47266ea184e5177c7b584/crates%2Fcore_simd%2Ftests%2Finteger.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac057a354a00b4329a47266ea184e5177c7b584/crates%2Fcore_simd%2Ftests%2Finteger.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Finteger.rs?ref=0ac057a354a00b4329a47266ea184e5177c7b584", "patch": "@@ -0,0 +1,189 @@\n+#[cfg(target_arch = \"wasm32\")]\n+wasm_bindgen_test_configure!(run_in_browser);\n+\n+macro_rules! impl_unary_op_test {\n+    { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $scalar_fn:expr } => {\n+        test_helpers::test_lanes! {\n+            fn $fn<const LANES: usize>() {\n+                test_helpers::test_unary_elementwise(\n+                    <$vector as core::ops::$trait>::$fn,\n+                    $scalar_fn,\n+                    |_| true,\n+                );\n+            }\n+        }\n+    };\n+    { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident } => {\n+        impl_unary_op_test! { $vector, $scalar, $trait::$fn, <$scalar as core::ops::$trait>::$fn }\n+    };\n+}\n+\n+macro_rules! impl_binary_op_test {\n+    { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $scalar_fn:expr } => {\n+        mod $fn {\n+            use super::*;\n+\n+            test_helpers::test_lanes! {\n+                fn normal<const LANES: usize>() {\n+                    test_helpers::test_binary_elementwise(\n+                        <$vector as core::ops::$trait>::$fn,\n+                        $scalar_fn,\n+                        |_, _| true,\n+                    );\n+                }\n+\n+                fn scalar_rhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_rhs_elementwise(\n+                        <$vector as core::ops::$trait<$scalar>>::$fn,\n+                        $scalar_fn,\n+                        |_, _| true,\n+                    );\n+                }\n+\n+                fn scalar_lhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_lhs_elementwise(\n+                        <$scalar as core::ops::$trait<$vector>>::$fn,\n+                        $scalar_fn,\n+                        |_, _| true,\n+                    );\n+                }\n+\n+                fn assign<const LANES: usize>() {\n+                    test_helpers::test_binary_elementwise(\n+                        |mut a, b| { <$vector as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n+                        $scalar_fn,\n+                        |_, _| true,\n+                    )\n+                }\n+\n+                fn assign_scalar_rhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_rhs_elementwise(\n+                        |mut a, b| { <$vector as core::ops::$trait_assign<$scalar>>::$fn_assign(&mut a, b); a },\n+                        $scalar_fn,\n+                        |_, _| true,\n+                    )\n+                }\n+            }\n+        }\n+    };\n+    { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident } => {\n+        impl_binary_op_test! { $vector, $scalar, $trait::$fn, $trait_assign::$fn_assign, <$scalar as core::ops::$trait>::$fn }\n+    };\n+}\n+\n+macro_rules! impl_binary_checked_op_test {\n+    { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $scalar_fn:expr, $check_fn:expr } => {\n+        mod $fn {\n+            use super::*;\n+\n+            test_helpers::test_lanes! {\n+                fn normal<const LANES: usize>() {\n+                    test_helpers::test_binary_elementwise(\n+                        <$vector as core::ops::$trait>::$fn,\n+                        $scalar_fn,\n+                        |x, y| x.iter().zip(y.iter()).all(|(x, y)| $check_fn(*x, *y)),\n+                    );\n+                }\n+\n+                fn scalar_rhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_rhs_elementwise(\n+                        <$vector as core::ops::$trait<$scalar>>::$fn,\n+                        $scalar_fn,\n+                        |x, y| x.iter().all(|x| $check_fn(*x, y)),\n+                    );\n+                }\n+\n+                fn scalar_lhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_lhs_elementwise(\n+                        <$scalar as core::ops::$trait<$vector>>::$fn,\n+                        $scalar_fn,\n+                        |x, y| y.iter().all(|y| $check_fn(x, *y)),\n+                    );\n+                }\n+\n+                fn assign<const LANES: usize>() {\n+                    test_helpers::test_binary_elementwise(\n+                        |mut a, b| { <$vector as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n+                        $scalar_fn,\n+                        |x, y| x.iter().zip(y.iter()).all(|(x, y)| $check_fn(*x, *y)),\n+                    )\n+                }\n+\n+                fn assign_scalar_rhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_rhs_elementwise(\n+                        |mut a, b| { <$vector as core::ops::$trait_assign<$scalar>>::$fn_assign(&mut a, b); a },\n+                        $scalar_fn,\n+                        |x, y| x.iter().all(|x| $check_fn(*x, y)),\n+                    )\n+                }\n+            }\n+        }\n+    };\n+    { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $check_fn:expr } => {\n+        impl_binary_nonzero_rhs_op_test! { $vector, $scalar, $trait::$fn, $trait_assign::$fn_assign, <$scalar as core::ops::$trait>::$fn, $check_fn }\n+    };\n+}\n+\n+macro_rules! impl_signed_tests {\n+    { $vector:ident, $scalar:tt } => {\n+        mod $scalar {\n+            type Vector<const LANES: usize> = core_simd::$vector<LANES>;\n+            type Scalar = $scalar;\n+\n+            test_helpers::test_lanes! {\n+                fn neg<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        <Vector<LANES> as core::ops::Neg>::neg,\n+                        <Scalar as core::ops::Neg>::neg,\n+                        |x| !x.contains(&Scalar::MIN),\n+                    );\n+                }\n+            }\n+\n+            impl_binary_op_test!(Vector<LANES>, Scalar, Add::add, AddAssign::add_assign, Scalar::wrapping_add);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, Sub::sub, SubAssign::sub_assign, Scalar::wrapping_sub);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, Mul::mul, MulAssign::mul_assign, Scalar::wrapping_mul);\n+            impl_binary_checked_op_test!(Vector<LANES>, Scalar, Div::div, DivAssign::div_assign, Scalar::wrapping_div, |x, y| y != 0 && !(x == Scalar::MIN && y == -1));\n+            impl_binary_checked_op_test!(Vector<LANES>, Scalar, Rem::rem, RemAssign::rem_assign, Scalar::wrapping_rem, |x, y| y != 0 && !(x == Scalar::MIN && y == -1));\n+\n+            impl_unary_op_test!(Vector<LANES>, Scalar, Not::not);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, BitAnd::bitand, BitAndAssign::bitand_assign);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, BitOr::bitor, BitOrAssign::bitor_assign);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, BitXor::bitxor, BitXorAssign::bitxor_assign);\n+        }\n+    }\n+}\n+\n+macro_rules! impl_unsigned_tests {\n+    { $vector:ident, $scalar:tt } => {\n+        mod $scalar {\n+            type Vector<const LANES: usize> = core_simd::$vector<LANES>;\n+            type Scalar = $scalar;\n+\n+            impl_binary_op_test!(Vector<LANES>, Scalar, Add::add, AddAssign::add_assign, Scalar::wrapping_add);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, Sub::sub, SubAssign::sub_assign, Scalar::wrapping_sub);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, Mul::mul, MulAssign::mul_assign, Scalar::wrapping_mul);\n+            impl_binary_checked_op_test!(Vector<LANES>, Scalar, Div::div, DivAssign::div_assign, Scalar::wrapping_div, |_, y| y != 0);\n+            impl_binary_checked_op_test!(Vector<LANES>, Scalar, Rem::rem, RemAssign::rem_assign, Scalar::wrapping_rem, |_, y| y != 0);\n+\n+            impl_unary_op_test!(Vector<LANES>, Scalar, Not::not);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, BitAnd::bitand, BitAndAssign::bitand_assign);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, BitOr::bitor, BitOrAssign::bitor_assign);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, BitXor::bitxor, BitXorAssign::bitxor_assign);\n+        }\n+    }\n+}\n+\n+impl_signed_tests! { SimdI8, i8 }\n+impl_signed_tests! { SimdI16, i16 }\n+impl_signed_tests! { SimdI32, i32 }\n+impl_signed_tests! { SimdI64, i64 }\n+impl_signed_tests! { SimdI128, i128 }\n+impl_signed_tests! { SimdIsize, isize }\n+\n+impl_unsigned_tests! { SimdU8, u8 }\n+impl_unsigned_tests! { SimdU16, u16 }\n+impl_unsigned_tests! { SimdU32, u32 }\n+impl_unsigned_tests! { SimdU64, u64 }\n+impl_unsigned_tests! { SimdU128, u128 }\n+impl_unsigned_tests! { SimdUsize, usize }"}, {"sha": "c9b2858ccc24346894a2c0601312f1c9cc8c88a8", "filename": "crates/test_helpers/src/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ac057a354a00b4329a47266ea184e5177c7b584/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac057a354a00b4329a47266ea184e5177c7b584/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=0ac057a354a00b4329a47266ea184e5177c7b584", "patch": "@@ -62,13 +62,15 @@ pub fn test_2<A: core::fmt::Debug + DefaultStrategy, B: core::fmt::Debug + Defau\n pub fn test_unary_elementwise<Scalar, ScalarResult, Vector, VectorResult, const LANES: usize>(\n     fv: impl Fn(Vector) -> VectorResult,\n     fs: impl Fn(Scalar) -> ScalarResult,\n+    check: impl Fn([Scalar; LANES]) -> bool,\n ) where\n     Scalar: Copy + Default + core::fmt::Debug + DefaultStrategy,\n     ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n     Vector: Into<[Scalar; LANES]> + From<[Scalar; LANES]> + Copy,\n     VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n {\n     test_1(|x: [Scalar; LANES]| {\n+        proptest::prop_assume!(check(x));\n         let result_1: [ScalarResult; LANES] = fv(x.into()).into();\n         let result_2: [ScalarResult; LANES] = {\n             let mut result = [ScalarResult::default(); LANES];\n@@ -93,6 +95,7 @@ pub fn test_binary_elementwise<\n >(\n     fv: impl Fn(Vector1, Vector2) -> VectorResult,\n     fs: impl Fn(Scalar1, Scalar2) -> ScalarResult,\n+    check: impl Fn([Scalar1; LANES], [Scalar2; LANES]) -> bool,\n ) where\n     Scalar1: Copy + Default + core::fmt::Debug + DefaultStrategy,\n     Scalar2: Copy + Default + core::fmt::Debug + DefaultStrategy,\n@@ -102,6 +105,7 @@ pub fn test_binary_elementwise<\n     VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n {\n     test_2(|x: [Scalar1; LANES], y: [Scalar2; LANES]| {\n+        proptest::prop_assume!(check(x, y));\n         let result_1: [ScalarResult; LANES] = fv(x.into(), y.into()).into();\n         let result_2: [ScalarResult; LANES] = {\n             let mut result = [ScalarResult::default(); LANES];\n@@ -125,6 +129,7 @@ pub fn test_binary_scalar_rhs_elementwise<\n >(\n     fv: impl Fn(Vector, Scalar2) -> VectorResult,\n     fs: impl Fn(Scalar1, Scalar2) -> ScalarResult,\n+    check: impl Fn([Scalar1; LANES], Scalar2) -> bool,\n ) where\n     Scalar1: Copy + Default + core::fmt::Debug + DefaultStrategy,\n     Scalar2: Copy + Default + core::fmt::Debug + DefaultStrategy,\n@@ -133,6 +138,7 @@ pub fn test_binary_scalar_rhs_elementwise<\n     VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n {\n     test_2(|x: [Scalar1; LANES], y: Scalar2| {\n+        proptest::prop_assume!(check(x, y));\n         let result_1: [ScalarResult; LANES] = fv(x.into(), y).into();\n         let result_2: [ScalarResult; LANES] = {\n             let mut result = [ScalarResult::default(); LANES];\n@@ -156,6 +162,7 @@ pub fn test_binary_scalar_lhs_elementwise<\n >(\n     fv: impl Fn(Scalar1, Vector) -> VectorResult,\n     fs: impl Fn(Scalar1, Scalar2) -> ScalarResult,\n+    check: impl Fn(Scalar1, [Scalar2; LANES]) -> bool,\n ) where\n     Scalar1: Copy + Default + core::fmt::Debug + DefaultStrategy,\n     Scalar2: Copy + Default + core::fmt::Debug + DefaultStrategy,\n@@ -164,6 +171,7 @@ pub fn test_binary_scalar_lhs_elementwise<\n     VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n {\n     test_2(|x: Scalar1, y: [Scalar2; LANES]| {\n+        proptest::prop_assume!(check(x, y));\n         let result_1: [ScalarResult; LANES] = fv(x, y.into()).into();\n         let result_2: [ScalarResult; LANES] = {\n             let mut result = [ScalarResult::default(); LANES];\n@@ -215,9 +223,6 @@ macro_rules! test_lanes {\n             lanes_8 => 8,\n             lanes_16 => 16,\n             lanes_32 => 32,\n-            lanes_64 => 64,\n-            lanes_128 => 128,\n-            lanes_256 => 256,\n         }\n         )*\n     }"}]}