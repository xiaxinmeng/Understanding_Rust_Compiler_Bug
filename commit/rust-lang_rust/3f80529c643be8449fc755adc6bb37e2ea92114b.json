{"sha": "3f80529c643be8449fc755adc6bb37e2ea92114b", "node_id": "C_kwDOAAsO6NoAKDNmODA1MjljNjQzYmU4NDQ5ZmM3NTVhZGM2YmIzN2UyZWE5MjExNGI", "commit": {"author": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2023-03-27T15:52:17Z"}, "committer": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2023-03-27T15:52:17Z"}, "message": "make InitMask lazy for fully init/uninit cases\n\nAvoid materializing bits in the InitMask bitset when a single value\nwould be enough: when the mask represents a fully initialized or fully\nuninitialized const allocation.", "tree": {"sha": "a42c85bc579ed122cadfa837cf44b69791a050b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a42c85bc579ed122cadfa837cf44b69791a050b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f80529c643be8449fc755adc6bb37e2ea92114b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f80529c643be8449fc755adc6bb37e2ea92114b", "html_url": "https://github.com/rust-lang/rust/commit/3f80529c643be8449fc755adc6bb37e2ea92114b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f80529c643be8449fc755adc6bb37e2ea92114b/comments", "author": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309", "html_url": "https://github.com/rust-lang/rust/commit/7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309"}], "stats": {"total": 283, "additions": 225, "deletions": 58}, "files": [{"sha": "3f7e252310637a5dfcd015f970b0dee1b6488c93", "filename": "compiler/rustc_middle/src/mir/interpret/allocation/init_mask.rs", "status": "modified", "additions": 225, "deletions": 58, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/3f80529c643be8449fc755adc6bb37e2ea92114b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f80529c643be8449fc755adc6bb37e2ea92114b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs?ref=3f80529c643be8449fc755adc6bb37e2ea92114b", "patch": "@@ -10,20 +10,185 @@ type Block = u64;\n \n /// A bitmask where each bit refers to the byte with the same index. If the bit is `true`, the byte\n /// is initialized. If it is `false` the byte is uninitialized.\n-// Note: for performance reasons when interning, some of the `InitMask` fields can be partially\n-// hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n-#[derive(Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable)]\n-#[derive(HashStable)]\n+/// The actual bits are only materialized when needed, and we try to keep this data lazy as long as\n+/// possible. Currently, if all the blocks have the same value, then the mask represents either a\n+/// fully initialized or fully uninitialized const allocation, so we can only store that single\n+/// value.\n+#[derive(Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n pub struct InitMask {\n-    blocks: Vec<Block>,\n+    pub(crate) blocks: InitMaskBlocks,\n     len: Size,\n }\n \n+#[derive(Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n+pub(crate) enum InitMaskBlocks {\n+    Lazy {\n+        /// Whether the lazy init mask is fully initialized or uninitialized.\n+        state: bool,\n+    },\n+    Materialized(InitMaskMaterialized),\n+}\n+\n+impl InitMask {\n+    pub fn new(size: Size, state: bool) -> Self {\n+        // Blocks start lazily allocated, until we have to materialize them.\n+        let blocks = InitMaskBlocks::Lazy { state };\n+        InitMask { len: size, blocks }\n+    }\n+\n+    /// Checks whether the `range` is entirely initialized.\n+    ///\n+    /// Returns `Ok(())` if it's initialized. Otherwise returns a range of byte\n+    /// indexes for the first contiguous span of the uninitialized access.\n+    #[inline]\n+    pub fn is_range_initialized(&self, range: AllocRange) -> Result<(), AllocRange> {\n+        let end = range.end();\n+        if end > self.len {\n+            return Err(AllocRange::from(self.len..end));\n+        }\n+\n+        match self.blocks {\n+            InitMaskBlocks::Lazy { state } => {\n+                // Lazily allocated blocks represent the full mask, and cover the requested range by\n+                // definition.\n+                if state { Ok(()) } else { Err(range) }\n+            }\n+            InitMaskBlocks::Materialized(ref blocks) => {\n+                blocks.is_range_initialized(range.start, end)\n+            }\n+        }\n+    }\n+\n+    /// Sets a specified range to a value. If the range is out-of-bounds, the mask will grow to\n+    /// accomodate it entirely.\n+    pub fn set_range(&mut self, range: AllocRange, new_state: bool) {\n+        let start = range.start;\n+        let end = range.end();\n+\n+        let is_full_overwrite = start == Size::ZERO && end >= self.len;\n+\n+        // Optimize the cases of a full init/uninit state, while handling growth if needed.\n+        match self.blocks {\n+            InitMaskBlocks::Lazy { ref mut state } if is_full_overwrite => {\n+                // This is fully overwriting the mask, and we'll still have a single initialization\n+                // state: the blocks can stay lazy.\n+                *state = new_state;\n+                self.len = end;\n+            }\n+            InitMaskBlocks::Materialized(_) if is_full_overwrite => {\n+                // This is also fully overwriting materialized blocks with a single initialization\n+                // state: we'll have no need for these blocks anymore and can make them lazy.\n+                self.blocks = InitMaskBlocks::Lazy { state: new_state };\n+                self.len = end;\n+            }\n+            InitMaskBlocks::Lazy { state } if state == new_state => {\n+                // Here we're partially overwriting the mask but the initialization state doesn't\n+                // change: the blocks can stay lazy.\n+                if end > self.len {\n+                    self.len = end;\n+                }\n+            }\n+            _ => {\n+                // Otherwise, we have a partial overwrite that can result in a mix of initialization\n+                // states, so we'll need materialized blocks.\n+                let len = self.len;\n+                let blocks = self.materialize_blocks();\n+\n+                // There are 3 cases of interest here, if we have:\n+                //\n+                //         [--------]\n+                //         ^        ^\n+                //         0        len\n+                //\n+                // 1) the range to set can be in-bounds:\n+                //\n+                //            xxxx = [start, end]\n+                //         [--------]\n+                //         ^        ^\n+                //         0        len\n+                //\n+                // Here, we'll simply set the single `start` to `end` range.\n+                //\n+                // 2) the range to set can be partially out-of-bounds:\n+                //\n+                //                xxxx = [start, end]\n+                //         [--------]\n+                //         ^        ^\n+                //         0        len\n+                //\n+                // We have 2 subranges to handle:\n+                // - we'll set the existing `start` to `len` range.\n+                // - we'll grow and set the `len` to `end` range.\n+                //\n+                // 3) the range to set can be fully out-of-bounds:\n+                //\n+                //                   ---xxxx = [start, end]\n+                //         [--------]\n+                //         ^        ^\n+                //         0        len\n+                //\n+                // Since we're growing the mask to a single `new_state` value, we consider the gap\n+                // from `len` to `start` to be part of the range, and have a single subrange to\n+                // handle: we'll grow and set the `len` to `end` range.\n+                //\n+                // Note that we have to materialize, set blocks, and grow the mask. We could\n+                // therefore slightly optimize things in situations where these writes overlap.\n+                // However, as of writing this, growing the mask doesn't happen in practice yet, so\n+                // we don't do this micro-optimization.\n+\n+                if end <= len {\n+                    // Handle case 1.\n+                    blocks.set_range_inbounds(start, end, new_state);\n+                } else {\n+                    if start < len {\n+                        // Handle the first subrange of case 2.\n+                        blocks.set_range_inbounds(start, len, new_state);\n+                    }\n+\n+                    // Handle the second subrange of case 2, and case 3.\n+                    blocks.grow(len, end - len, new_state); // `Size` operation\n+                    self.len = end;\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Materializes this mask's blocks when the mask is lazy.\n+    #[inline]\n+    fn materialize_blocks(&mut self) -> &mut InitMaskMaterialized {\n+        if let InitMaskBlocks::Lazy { state } = self.blocks {\n+            self.blocks = InitMaskBlocks::Materialized(InitMaskMaterialized::new(self.len, state));\n+        }\n+\n+        let InitMaskBlocks::Materialized(ref mut blocks) = self.blocks else {\n+            bug!(\"initmask blocks must be materialized here\")\n+        };\n+        blocks\n+    }\n+\n+    /// Returns the initialization state at the specified in-bounds index.\n+    #[inline]\n+    pub fn get(&self, idx: Size) -> bool {\n+        match self.blocks {\n+            InitMaskBlocks::Lazy { state } => state,\n+            InitMaskBlocks::Materialized(ref blocks) => blocks.get(idx),\n+        }\n+    }\n+}\n+\n+/// The actual materialized blocks of the bitmask, when we can't keep the `InitMask` lazy.\n+// Note: for performance reasons when interning, some of the fields can be partially\n+// hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n+#[derive(Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable, HashStable)]\n+pub(crate) struct InitMaskMaterialized {\n+    pub(crate) blocks: Vec<Block>,\n+}\n+\n // Const allocations are only hashed for interning. However, they can be large, making the hashing\n // expensive especially since it uses `FxHash`: it's better suited to short keys, not potentially\n // big buffers like the allocation's init mask. We can partially hash some fields when they're\n // large.\n-impl hash::Hash for InitMask {\n+impl hash::Hash for InitMaskMaterialized {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         const MAX_BLOCKS_TO_HASH: usize = super::MAX_BYTES_TO_HASH / std::mem::size_of::<Block>();\n         const MAX_BLOCKS_LEN: usize = super::MAX_HASHED_BUFFER_LEN / std::mem::size_of::<Block>();\n@@ -41,18 +206,15 @@ impl hash::Hash for InitMask {\n         } else {\n             self.blocks.hash(state);\n         }\n-\n-        // Hash the other fields as usual.\n-        self.len.hash(state);\n     }\n }\n \n-impl InitMask {\n+impl InitMaskMaterialized {\n     pub const BLOCK_SIZE: u64 = 64;\n \n-    pub fn new(size: Size, state: bool) -> Self {\n-        let mut m = InitMask { blocks: vec![], len: Size::ZERO };\n-        m.grow(size, state);\n+    fn new(size: Size, state: bool) -> Self {\n+        let mut m = InitMaskMaterialized { blocks: vec![] };\n+        m.grow(Size::ZERO, size, state);\n         m\n     }\n \n@@ -62,30 +224,25 @@ impl InitMask {\n         // Each bit in a `Block` represents the initialization state of one byte of an allocation,\n         // so we use `.bytes()` here.\n         let bits = bits.bytes();\n-        let a = bits / InitMask::BLOCK_SIZE;\n-        let b = bits % InitMask::BLOCK_SIZE;\n+        let a = bits / Self::BLOCK_SIZE;\n+        let b = bits % Self::BLOCK_SIZE;\n         (usize::try_from(a).unwrap(), usize::try_from(b).unwrap())\n     }\n \n     #[inline]\n     fn size_from_bit_index(block: impl TryInto<u64>, bit: impl TryInto<u64>) -> Size {\n         let block = block.try_into().ok().unwrap();\n         let bit = bit.try_into().ok().unwrap();\n-        Size::from_bytes(block * InitMask::BLOCK_SIZE + bit)\n+        Size::from_bytes(block * Self::BLOCK_SIZE + bit)\n     }\n \n     /// Checks whether the `range` is entirely initialized.\n     ///\n     /// Returns `Ok(())` if it's initialized. Otherwise returns a range of byte\n     /// indexes for the first contiguous span of the uninitialized access.\n     #[inline]\n-    pub fn is_range_initialized(&self, range: AllocRange) -> Result<(), AllocRange> {\n-        let end = range.end();\n-        if end > self.len {\n-            return Err(AllocRange::from(self.len..end));\n-        }\n-\n-        let uninit_start = self.find_bit(range.start, end, false);\n+    fn is_range_initialized(&self, start: Size, end: Size) -> Result<(), AllocRange> {\n+        let uninit_start = self.find_bit(start, end, false);\n \n         match uninit_start {\n             Some(uninit_start) => {\n@@ -96,15 +253,6 @@ impl InitMask {\n         }\n     }\n \n-    pub fn set_range(&mut self, range: AllocRange, new_state: bool) {\n-        let end = range.end();\n-        let len = self.len;\n-        if end > len {\n-            self.grow(end - len, new_state);\n-        }\n-        self.set_range_inbounds(range.start, end, new_state);\n-    }\n-\n     fn set_range_inbounds(&mut self, start: Size, end: Size, new_state: bool) {\n         let (blocka, bita) = Self::bit_index(start);\n         let (blockb, bitb) = Self::bit_index(end);\n@@ -150,27 +298,35 @@ impl InitMask {\n     }\n \n     #[inline]\n-    pub fn get(&self, i: Size) -> bool {\n+    fn get(&self, i: Size) -> bool {\n         let (block, bit) = Self::bit_index(i);\n         (self.blocks[block] & (1 << bit)) != 0\n     }\n \n-    fn grow(&mut self, amount: Size, new_state: bool) {\n+    fn grow(&mut self, len: Size, amount: Size, new_state: bool) {\n         if amount.bytes() == 0 {\n             return;\n         }\n         let unused_trailing_bits =\n-            u64::try_from(self.blocks.len()).unwrap() * Self::BLOCK_SIZE - self.len.bytes();\n+            u64::try_from(self.blocks.len()).unwrap() * Self::BLOCK_SIZE - len.bytes();\n+\n+        // If there's not enough capacity in the currently allocated blocks, allocate some more.\n         if amount.bytes() > unused_trailing_bits {\n             let additional_blocks = amount.bytes() / Self::BLOCK_SIZE + 1;\n-            self.blocks.extend(\n-                // FIXME(oli-obk): optimize this by repeating `new_state as Block`.\n-                iter::repeat(0).take(usize::try_from(additional_blocks).unwrap()),\n-            );\n+\n+            // We allocate the blocks to the correct value for the requested init state, so we won't\n+            // have to manually set them with another write.\n+            let block = if new_state { u64::MAX } else { 0 };\n+            self.blocks\n+                .extend(iter::repeat(block).take(usize::try_from(additional_blocks).unwrap()));\n+        }\n+\n+        // New blocks have already been set here, so we only need to set the unused trailing bits,\n+        // if any.\n+        if unused_trailing_bits > 0 {\n+            let in_bounds_tail = Size::from_bytes(unused_trailing_bits);\n+            self.set_range_inbounds(len, len + in_bounds_tail, new_state); // `Size` operation\n         }\n-        let start = self.len;\n-        self.len += amount;\n-        self.set_range_inbounds(start, start + amount, new_state); // `Size` operation\n     }\n \n     /// Returns the index of the first bit in `start..end` (end-exclusive) that is equal to is_init.\n@@ -188,7 +344,7 @@ impl InitMask {\n         /// ```\n         /// Also, if not stated, assume that `is_init = true`, that is, we are searching for the first 1 bit.\n         fn find_bit_fast(\n-            init_mask: &InitMask,\n+            init_mask: &InitMaskMaterialized,\n             start: Size,\n             end: Size,\n             is_init: bool,\n@@ -223,7 +379,7 @@ impl InitMask {\n                     None\n                 } else {\n                     let bit = bits.trailing_zeros();\n-                    Some(InitMask::size_from_bit_index(block, bit))\n+                    Some(InitMaskMaterialized::size_from_bit_index(block, bit))\n                 }\n             }\n \n@@ -253,9 +409,9 @@ impl InitMask {\n             // This provides the desired behavior of searching blocks 0 and 1 for (a),\n             // and searching only block 0 for (b).\n             // There is no concern of overflows since we checked for `start >= end` above.\n-            let (start_block, start_bit) = InitMask::bit_index(start);\n+            let (start_block, start_bit) = InitMaskMaterialized::bit_index(start);\n             let end_inclusive = Size::from_bytes(end.bytes() - 1);\n-            let (end_block_inclusive, _) = InitMask::bit_index(end_inclusive);\n+            let (end_block_inclusive, _) = InitMaskMaterialized::bit_index(end_inclusive);\n \n             // Handle first block: need to skip `start_bit` bits.\n             //\n@@ -340,7 +496,7 @@ impl InitMask {\n \n         #[cfg_attr(not(debug_assertions), allow(dead_code))]\n         fn find_bit_slow(\n-            init_mask: &InitMask,\n+            init_mask: &InitMaskMaterialized,\n             start: Size,\n             end: Size,\n             is_init: bool,\n@@ -436,10 +592,19 @@ impl<'a> Iterator for InitChunkIter<'a> {\n             return None;\n         }\n \n-        let end_of_chunk =\n-            self.init_mask.find_bit(self.start, self.end, !self.is_init).unwrap_or(self.end);\n+        let end_of_chunk = match self.init_mask.blocks {\n+            InitMaskBlocks::Lazy { .. } => {\n+                // If we're iterating over the chunks of lazy blocks, we just emit a single\n+                // full-size chunk.\n+                self.end\n+            }\n+            InitMaskBlocks::Materialized(ref blocks) => {\n+                let end_of_chunk =\n+                    blocks.find_bit(self.start, self.end, !self.is_init).unwrap_or(self.end);\n+                end_of_chunk\n+            }\n+        };\n         let range = self.start..end_of_chunk;\n-\n         let ret =\n             Some(if self.is_init { InitChunk::Init(range) } else { InitChunk::Uninit(range) });\n \n@@ -504,25 +669,27 @@ impl InitMask {\n \n     /// Applies multiple instances of the run-length encoding to the initialization mask.\n     pub fn apply_copy(&mut self, defined: InitCopy, range: AllocRange, repeat: u64) {\n-        // An optimization where we can just overwrite an entire range of initialization\n-        // bits if they are going to be uniformly `1` or `0`.\n+        // An optimization where we can just overwrite an entire range of initialization bits if\n+        // they are going to be uniformly `1` or `0`. If this happens to be a full-range overwrite,\n+        // we won't need materialized blocks either.\n         if defined.ranges.len() <= 1 {\n-            self.set_range_inbounds(\n-                range.start,\n-                range.start + range.size * repeat, // `Size` operations\n-                defined.initial,\n-            );\n+            let start = range.start;\n+            let end = range.start + range.size * repeat; // `Size` operations\n+            self.set_range(AllocRange::from(start..end), defined.initial);\n             return;\n         }\n \n+        // We're about to do one or more partial writes, so we ensure the blocks are materialized.\n+        let blocks = self.materialize_blocks();\n+\n         for mut j in 0..repeat {\n             j *= range.size.bytes();\n             j += range.start.bytes();\n             let mut cur = defined.initial;\n             for range in &defined.ranges {\n                 let old_j = j;\n                 j += range;\n-                self.set_range_inbounds(Size::from_bytes(old_j), Size::from_bytes(j), cur);\n+                blocks.set_range_inbounds(Size::from_bytes(old_j), Size::from_bytes(j), cur);\n                 cur = !cur;\n             }\n         }"}]}