{"sha": "d9eaaf59733d29911e2882020931a77aa0178c32", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ZWFhZjU5NzMzZDI5OTExZTI4ODIwMjA5MzFhNzdhYTAxNzhjMzI=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-10T18:30:19Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-19T19:48:02Z"}, "message": "Derive HashStable in librustc_mir.", "tree": {"sha": "73ae37736587119dfa18d556166b6978148ea7fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73ae37736587119dfa18d556166b6978148ea7fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9eaaf59733d29911e2882020931a77aa0178c32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9eaaf59733d29911e2882020931a77aa0178c32", "html_url": "https://github.com/rust-lang/rust/commit/d9eaaf59733d29911e2882020931a77aa0178c32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9eaaf59733d29911e2882020931a77aa0178c32/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1522fa1832a0e82d235e6fb9f15d9d2647ff5aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1522fa1832a0e82d235e6fb9f15d9d2647ff5aa", "html_url": "https://github.com/rust-lang/rust/commit/e1522fa1832a0e82d235e6fb9f15d9d2647ff5aa"}], "stats": {"total": 94, "additions": 37, "deletions": 57}, "files": [{"sha": "5e0880da343a12271e8db83854009ced136dab87", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d9eaaf59733d29911e2882020931a77aa0178c32/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d9eaaf59733d29911e2882020931a77aa0178c32/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d9eaaf59733d29911e2882020931a77aa0178c32", "patch": "@@ -3720,6 +3720,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_index\",\n  \"rustc_lexer\",\n+ \"rustc_macros\",\n  \"rustc_target\",\n  \"serialize\",\n  \"smallvec 1.0.0\","}, {"sha": "9bc6d32b7cb385a990e483a6a2431cfa9bbf1183", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d9eaaf59733d29911e2882020931a77aa0178c32/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d9eaaf59733d29911e2882020931a77aa0178c32/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=d9eaaf59733d29911e2882020931a77aa0178c32", "patch": "@@ -22,6 +22,7 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_lexer = { path = \"../librustc_lexer\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "471227f74037ea5f4011850eb75b05354b8faf0c", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d9eaaf59733d29911e2882020931a77aa0178c32/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9eaaf59733d29911e2882020931a77aa0178c32/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=d9eaaf59733d29911e2882020931a77aa0178c32", "patch": "@@ -3,6 +3,7 @@ use std::fmt::Write;\n use std::mem;\n \n use syntax::source_map::{self, Span, DUMMY_SP};\n+use rustc::ich::StableHashingContext;\n use rustc::hir::def_id::DefId;\n use rustc::hir::def::DefKind;\n use rustc::mir;\n@@ -18,6 +19,8 @@ use rustc::mir::interpret::{\n     InterpResult, truncate, sign_extend,\n };\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_macros::HashStable;\n \n use super::{\n     Immediate, Operand, MemPlace, MPlaceTy, Place, PlaceTy, ScalarMaybeUndef,\n@@ -93,7 +96,7 @@ pub struct Frame<'mir, 'tcx, Tag=(), Extra=()> {\n     pub stmt: usize,\n }\n \n-#[derive(Clone, Eq, PartialEq, Debug)] // Miri debug-prints these\n+#[derive(Clone, Eq, PartialEq, Debug, HashStable)] // Miri debug-prints these\n pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n     /// that may never return). Also store layout of return place so\n@@ -109,15 +112,16 @@ pub enum StackPopCleanup {\n }\n \n /// State of a local variable including a memoized layout\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, HashStable)]\n pub struct LocalState<'tcx, Tag=(), Id=AllocId> {\n     pub value: LocalValue<Tag, Id>,\n     /// Don't modify if `Some`, this is only used to prevent computing the layout twice\n+    #[stable_hasher(ignore)]\n     pub layout: Cell<Option<TyLayout<'tcx>>>,\n }\n \n /// Current value of a local variable\n-#[derive(Clone, PartialEq, Eq, Debug)] // Miri debug-prints these\n+#[derive(Clone, PartialEq, Eq, Debug, HashStable)] // Miri debug-prints these\n pub enum LocalValue<Tag=(), Id=AllocId> {\n     /// This local is not currently alive, and cannot be used at all.\n     Dead,\n@@ -827,3 +831,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         frames\n     }\n }\n+\n+impl<'ctx, 'mir, 'tcx, Tag, Extra> HashStable<StableHashingContext<'ctx>>\n+for Frame<'mir, 'tcx, Tag, Extra>\n+    where Extra: HashStable<StableHashingContext<'ctx>>,\n+          Tag:   HashStable<StableHashingContext<'ctx>>\n+{\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'ctx>, hasher: &mut StableHasher) {\n+        self.body.hash_stable(hcx, hasher);\n+        self.instance.hash_stable(hcx, hasher);\n+        self.span.hash_stable(hcx, hasher);\n+        self.return_to_block.hash_stable(hcx, hasher);\n+        self.return_place.as_ref().map(|r| &**r).hash_stable(hcx, hasher);\n+        self.locals.hash_stable(hcx, hasher);\n+        self.block.hash_stable(hcx, hasher);\n+        self.stmt.hash_stable(hcx, hasher);\n+        self.extra.hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "cfa70164cdce430aca3e9f16fdee91132a76f8f2", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d9eaaf59733d29911e2882020931a77aa0178c32/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9eaaf59733d29911e2882020931a77aa0178c32/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=d9eaaf59733d29911e2882020931a77aa0178c32", "patch": "@@ -18,6 +18,7 @@ use super::{\n     MemPlace, MPlaceTy, PlaceTy, Place,\n };\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n+use rustc_macros::HashStable;\n \n /// An `Immediate` represents a single immediate self-contained Rust value.\n ///\n@@ -26,7 +27,7 @@ pub use rustc::mir::interpret::ScalarMaybeUndef;\n /// operations and fat pointers. This idea was taken from rustc's codegen.\n /// In particular, thanks to `ScalarPair`, arithmetic operations and casts can be entirely\n /// defined on `Immediate`, and do not have to work with a `Place`.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable)]\n pub enum Immediate<Tag=(), Id=AllocId> {\n     Scalar(ScalarMaybeUndef<Tag, Id>),\n     ScalarPair(ScalarMaybeUndef<Tag, Id>, ScalarMaybeUndef<Tag, Id>),\n@@ -103,7 +104,7 @@ impl<'tcx, Tag> ::std::ops::Deref for ImmTy<'tcx, Tag> {\n /// An `Operand` is the result of computing a `mir::Operand`. It can be immediate,\n /// or still in memory. The latter is an optimization, to delay reading that chunk of\n /// memory and to avoid having to store arbitrary-sized data here.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable)]\n pub enum Operand<Tag=(), Id=AllocId> {\n     Immediate(Immediate<Tag, Id>),\n     Indirect(MemPlace<Tag, Id>),"}, {"sha": "088fbe1695efd3cedc0619341264bb4949518516", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d9eaaf59733d29911e2882020931a77aa0178c32/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9eaaf59733d29911e2882020931a77aa0178c32/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=d9eaaf59733d29911e2882020931a77aa0178c32", "patch": "@@ -12,14 +12,15 @@ use rustc::ty::layout::{\n     self, Size, Align, LayoutOf, TyLayout, HasDataLayout, VariantIdx, PrimitiveExt\n };\n use rustc::ty::TypeFoldable;\n+use rustc_macros::HashStable;\n \n use super::{\n     GlobalId, AllocId, Allocation, Scalar, InterpResult, Pointer, PointerArithmetic,\n     InterpCx, Machine, AllocMap, AllocationExtra,\n     RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind, LocalValue,\n };\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n pub struct MemPlace<Tag=(), Id=AllocId> {\n     /// A place may have an integral pointer for ZSTs, and since it might\n     /// be turned back into a reference before ever being dereferenced.\n@@ -32,7 +33,7 @@ pub struct MemPlace<Tag=(), Id=AllocId> {\n     pub meta: Option<Scalar<Tag, Id>>,\n }\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n pub enum Place<Tag=(), Id=AllocId> {\n     /// A place referring to a value allocated in the `Memory` system.\n     Ptr(MemPlace<Tag, Id>),"}, {"sha": "3ea00d69221868ee46fe7247d5440441ff973f86", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 4, "deletions": 50, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d9eaaf59733d29911e2882020931a77aa0178c32/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9eaaf59733d29911e2882020931a77aa0178c32/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=d9eaaf59733d29911e2882020931a77aa0178c32", "patch": "@@ -19,6 +19,7 @@ use rustc::ty::layout::{Align, Size};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_index::vec::IndexVec;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_macros::HashStable;\n use syntax::ast::Mutability;\n use syntax::source_map::Span;\n \n@@ -197,21 +198,12 @@ impl_snapshot_for!(enum ScalarMaybeUndef {\n     Undef,\n });\n \n-impl_stable_hash_for!(struct crate::interpret::MemPlace {\n-    ptr,\n-    align,\n-    meta,\n-});\n impl_snapshot_for!(struct MemPlace {\n     ptr,\n     meta,\n     align -> *align, // just copy alignment verbatim\n });\n \n-impl_stable_hash_for!(enum crate::interpret::Place {\n-    Ptr(mem_place),\n-    Local { frame, local },\n-});\n impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n     where Ctx: SnapshotContext<'a>,\n {\n@@ -229,29 +221,16 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n     }\n }\n \n-impl_stable_hash_for!(enum crate::interpret::Immediate {\n-    Scalar(x),\n-    ScalarPair(x, y),\n-});\n impl_snapshot_for!(enum Immediate {\n     Scalar(s),\n     ScalarPair(s, t),\n });\n \n-impl_stable_hash_for!(enum crate::interpret::Operand {\n-    Immediate(x),\n-    Indirect(x),\n-});\n impl_snapshot_for!(enum Operand {\n     Immediate(v),\n     Indirect(m),\n });\n \n-impl_stable_hash_for!(enum crate::interpret::LocalValue {\n-    Dead,\n-    Uninitialized,\n-    Live(x),\n-});\n impl_snapshot_for!(enum LocalValue {\n     Dead,\n     Uninitialized,\n@@ -314,11 +293,6 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for &'a Allocation\n     }\n }\n \n-impl_stable_hash_for!(enum crate::interpret::eval_context::StackPopCleanup {\n-    Goto { ret, unwind },\n-    None { cleanup },\n-});\n-\n #[derive(Eq, PartialEq)]\n struct FrameSnapshot<'a, 'tcx> {\n     instance: ty::Instance<'tcx>,\n@@ -330,18 +304,6 @@ struct FrameSnapshot<'a, 'tcx> {\n     stmt: usize,\n }\n \n-impl_stable_hash_for!(impl<> for struct Frame<'mir, 'tcx> {\n-    body,\n-    instance,\n-    span,\n-    return_to_block,\n-    return_place -> (return_place.as_ref().map(|r| &**r)),\n-    locals,\n-    block,\n-    stmt,\n-    extra,\n-});\n-\n impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n     where Ctx: SnapshotContext<'a>,\n {\n@@ -383,11 +345,6 @@ impl<'a, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a LocalState<'tcx>\n     }\n }\n \n-impl_stable_hash_for!(struct LocalState<'tcx> {\n-    value,\n-    layout -> _,\n-});\n-\n impl<'b, 'mir, 'tcx> SnapshotContext<'b>\n     for Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>\n {\n@@ -399,7 +356,10 @@ impl<'b, 'mir, 'tcx> SnapshotContext<'b>\n /// The virtual machine state during const-evaluation at a given point in time.\n /// We assume the `CompileTimeInterpreter` has no interesting extra state that\n /// is worth considering here.\n+#[derive(HashStable)]\n struct InterpSnapshot<'mir, 'tcx> {\n+    // Not hashing memory: Avoid hashing memory all the time during execution\n+    #[stable_hasher(ignore)]\n     memory: Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n     stack: Vec<Frame<'mir, 'tcx>>,\n }\n@@ -434,12 +394,6 @@ impl<'mir, 'tcx> Hash for InterpSnapshot<'mir, 'tcx> {\n     }\n }\n \n-impl_stable_hash_for!(impl<> for struct InterpSnapshot<'mir, 'tcx> {\n-    // Not hashing memory: Avoid hashing memory all the time during execution\n-    memory -> _,\n-    stack,\n-});\n-\n impl<'mir, 'tcx> Eq for InterpSnapshot<'mir, 'tcx> {}\n \n impl<'mir, 'tcx> PartialEq for InterpSnapshot<'mir, 'tcx> {"}]}