{"sha": "41da875faef58e618cafc7dfdc5f3985a58f1e98", "node_id": "C_kwDOAAsO6NoAKDQxZGE4NzVmYWVmNThlNjE4Y2FmYzdkZmRjNWYzOTg1YTU4ZjFlOTg", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2022-12-18T14:40:46Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2023-02-28T23:05:31Z"}, "message": "Add `Option::as_slice`(`_mut`)\n\nThis adds the following functions:\n\n* `Option<T>::as_slice(&self) -> &[T]`\n* `Option<T>::as_slice_mut(&mut self) -> &[T]`\n\nThe `as_slice` and `as_slice_mut` functions benefit from an\noptimization that makes them completely branch-free.\n\nNote that the optimization's soundness hinges on the fact that either\nthe niche optimization makes the offset of the `Some(_)` contents zero\nor the mempory layout of `Option<T>` is equal to that of\n`Option<MaybeUninit<T>>`.", "tree": {"sha": "1200a1f2eb32151c90896d1d440aaaadda550b6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1200a1f2eb32151c90896d1d440aaaadda550b6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41da875faef58e618cafc7dfdc5f3985a58f1e98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41da875faef58e618cafc7dfdc5f3985a58f1e98", "html_url": "https://github.com/rust-lang/rust/commit/41da875faef58e618cafc7dfdc5f3985a58f1e98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41da875faef58e618cafc7dfdc5f3985a58f1e98/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd4a96a12d0bf6dc12edf20a45df3a33052c9d7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd4a96a12d0bf6dc12edf20a45df3a33052c9d7d", "html_url": "https://github.com/rust-lang/rust/commit/bd4a96a12d0bf6dc12edf20a45df3a33052c9d7d"}], "stats": {"total": 148, "additions": 148, "deletions": 0}, "files": [{"sha": "7b8f3880d3e50a75a8a53b3567ac497012d29454", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41da875faef58e618cafc7dfdc5f3985a58f1e98/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41da875faef58e618cafc7dfdc5f3985a58f1e98/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=41da875faef58e618cafc7dfdc5f3985a58f1e98", "patch": "@@ -134,6 +134,7 @@\n #![feature(const_option)]\n #![feature(const_option_ext)]\n #![feature(const_pin)]\n+#![feature(const_pointer_byte_offsets)]\n #![feature(const_pointer_is_aligned)]\n #![feature(const_ptr_sub_ptr)]\n #![feature(const_replace)]"}, {"sha": "994c08d1fb50d19c1655b70481e742088511f3ca", "filename": "library/core/src/option.rs", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/41da875faef58e618cafc7dfdc5f3985a58f1e98/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41da875faef58e618cafc7dfdc5f3985a58f1e98/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=41da875faef58e618cafc7dfdc5f3985a58f1e98", "patch": "@@ -553,6 +553,7 @@ use crate::pin::Pin;\n use crate::{\n     cmp, convert, hint, mem,\n     ops::{self, ControlFlow, Deref, DerefMut},\n+    slice,\n };\n \n /// The `Option` type. See [the module level documentation](self) for more.\n@@ -734,6 +735,124 @@ impl<T> Option<T> {\n         }\n     }\n \n+    const fn get_some_offset() -> isize {\n+        if mem::size_of::<Option<T>>() == mem::size_of::<T>() {\n+            // niche optimization means the `T` is always stored at the same position as the Option.\n+            0\n+        } else {\n+            assert!(mem::size_of::<Option<T>>() == mem::size_of::<Option<mem::MaybeUninit<T>>>());\n+            let some_uninit = Some(mem::MaybeUninit::<T>::uninit());\n+            // SAFETY: This gets the byte offset of the `Some(_)` value following the fact that\n+            // niche optimization is not active, and thus Option<T> and Option<MaybeUninit<t>> share\n+            // the same layout.\n+            unsafe {\n+                (some_uninit.as_ref().unwrap() as *const mem::MaybeUninit<T>)\n+                    .byte_offset_from(&some_uninit as *const Option<mem::MaybeUninit<T>>)\n+            }\n+        }\n+    }\n+\n+    /// Returns a slice of the contained value, if any. If this is `None`, an\n+    /// empty slice is returned. This can be useful to have a single type of\n+    /// iterator over an `Option` or slice.\n+    ///\n+    /// Note: Should you have an `Option<&T>` and wish to get a slice of `T`,\n+    /// you can unpack it via `opt.map_or(&[], std::slice::from_ref)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(option_as_slice)]\n+    ///\n+    /// assert_eq!(\n+    ///     [Some(1234).as_slice(), None.as_slice()],\n+    ///     [&[1234][..], &[][..]],\n+    /// );\n+    /// ```\n+    ///\n+    /// The inverse of this function is (discounting\n+    /// borrowing) [`[_]::first`](slice::first):\n+    ///\n+    /// ```rust\n+    /// #![feature(option_as_slice)]\n+    ///\n+    /// for i in [Some(1234_u16), None] {\n+    ///     assert_eq!(i.as_ref(), i.as_slice().first());\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[must_use]\n+    #[unstable(feature = \"option_as_slice\", issue = \"108545\")]\n+    pub fn as_slice(&self) -> &[T] {\n+        // SAFETY: This is sound as long as `get_some_offset` returns the\n+        // correct offset. Though in the `None` case, the slice may be located\n+        // at a pointer pointing into padding, the fact that the slice is\n+        // empty, and the padding is at a properly aligned position for a\n+        // value of that type makes it sound.\n+        unsafe {\n+            slice::from_raw_parts(\n+                (self as *const Option<T>).wrapping_byte_offset(Self::get_some_offset())\n+                    as *const T,\n+                self.is_some() as usize,\n+            )\n+        }\n+    }\n+\n+    /// Returns a mutable slice of the contained value, if any. If this is\n+    /// `None`, an empty slice is returned. This can be useful to have a\n+    /// single type of iterator over an `Option` or slice.\n+    ///\n+    /// Note: Should you have an `Option<&mut T>` instead of a\n+    /// `&mut Option<T>`, which this method takes, you can obtain a mutable\n+    /// slice via `opt.map_or(&mut [], std::slice::from_mut)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(option_as_slice)]\n+    ///\n+    /// assert_eq!(\n+    ///     [Some(1234).as_mut_slice(), None.as_mut_slice()],\n+    ///     [&mut [1234][..], &mut [][..]],\n+    /// );\n+    /// ```\n+    ///\n+    /// The result is a mutable slice of zero or one items that points into\n+    /// our original `Option`:\n+    ///\n+    /// ```rust\n+    /// #![feature(option_as_slice)]\n+    ///\n+    /// let mut x = Some(1234);\n+    /// x.as_mut_slice()[0] += 1;\n+    /// assert_eq!(x, Some(1235));\n+    /// ```\n+    ///\n+    /// The inverse of this method (discounting borrowing)\n+    /// is [`[_]::first_mut`](slice::first_mut):\n+    ///\n+    /// ```rust\n+    /// #![feature(option_as_slice)]\n+    ///\n+    /// assert_eq!(Some(123).as_mut_slice().first_mut(), Some(&mut 123))\n+    /// ```\n+    #[inline]\n+    #[must_use]\n+    #[unstable(feature = \"option_as_slice\", issue = \"108545\")]\n+    pub fn as_mut_slice(&mut self) -> &mut [T] {\n+        // SAFETY: This is sound as long as `get_some_offset` returns the\n+        // correct offset. Though in the `None` case, the slice may be located\n+        // at a pointer pointing into padding, the fact that the slice is\n+        // empty, and the padding is at a properly aligned position for a\n+        // value of that type makes it sound.\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                (self as *mut Option<T>).wrapping_byte_offset(Self::get_some_offset()) as *mut T,\n+                self.is_some() as usize,\n+            )\n+        }\n+    }\n+\n     /////////////////////////////////////////////////////////////////////////\n     // Getting to contained values\n     /////////////////////////////////////////////////////////////////////////"}, {"sha": "d5077dbf6ccd98adc8e08d742457f6ab51e775c4", "filename": "tests/codegen/option-as-slice.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/41da875faef58e618cafc7dfdc5f3985a58f1e98/tests%2Fcodegen%2Foption-as-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41da875faef58e618cafc7dfdc5f3985a58f1e98/tests%2Fcodegen%2Foption-as-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Foption-as-slice.rs?ref=41da875faef58e618cafc7dfdc5f3985a58f1e98", "patch": "@@ -0,0 +1,28 @@\n+// compile-flags: -O\n+// only-x86_64\n+\n+#![crate_type = \"lib\"]\n+#![feature(option_as_slice)]\n+\n+extern crate core;\n+\n+use core::num::NonZeroU64;\n+use core::option::Option;\n+\n+// CHECK-LABEL: @u64_opt_as_slice\n+#[no_mangle]\n+pub fn u64_opt_as_slice(o: &Option<u64>) -> &[u64] {\n+    // CHECK: start:\n+    // CHECK-NOT: select\n+    // CHECK: ret\n+    o.as_slice()\n+}\n+\n+// CHECK-LABEL: @nonzero_u64_opt_as_slice\n+#[no_mangle]\n+pub fn nonzero_u64_opt_as_slice(o: &Option<NonZeroU64>) -> &[NonZeroU64] {\n+    // CHECK: start:\n+    // CHECK-NOT: select\n+    // CHECK: ret\n+    o.as_slice()\n+}"}]}