{"sha": "2f3cff6956d56048ef7afb6d33e17cbdb2dcf038", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmM2NmZjY5NTZkNTYwNDhlZjdhZmI2ZDMzZTE3Y2JkYjJkY2YwMzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-22T17:11:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-22T17:11:37Z"}, "message": "auto merge of #20132 : alexcrichton/rust/revert-20027, r=sfackler\n\nThe introduced issue https://github.com/rust-lang/rust/issues/20127 seems serious enough that we may want to enqueue a reversion for now. Feel free to beat me with a fix though @michaelwoerister!", "tree": {"sha": "5b8bafb900533ca1eea410f17f91785d34a243ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b8bafb900533ca1eea410f17f91785d34a243ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038", "html_url": "https://github.com/rust-lang/rust/commit/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34d680009205de2302b902d8f9f5f7ae7a042f1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/34d680009205de2302b902d8f9f5f7ae7a042f1a", "html_url": "https://github.com/rust-lang/rust/commit/34d680009205de2302b902d8f9f5f7ae7a042f1a"}, {"sha": "c5aaa8cc05fc9d7a565eabbaafb8a1fc1effb66d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5aaa8cc05fc9d7a565eabbaafb8a1fc1effb66d", "html_url": "https://github.com/rust-lang/rust/commit/c5aaa8cc05fc9d7a565eabbaafb8a1fc1effb66d"}], "stats": {"total": 373, "additions": 71, "deletions": 302}, "files": [{"sha": "2b73944d2b0ae51f1f817af078bd2a31bf35d4b5", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=2f3cff6956d56048ef7afb6d33e17cbdb2dcf038", "patch": "@@ -286,7 +286,6 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     debug!(\"iterator type is {}, datum type is {}\",\n            ppaux::ty_to_string(bcx.tcx(), iterator_type),\n            ppaux::ty_to_string(bcx.tcx(), iterator_datum.ty));\n-\n     let lliterator = load_ty(bcx, iterator_datum.val, iterator_datum.ty);\n \n     // Create our basic blocks and set up our loop cleanups.\n@@ -366,8 +365,6 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                        llpayload,\n                                        binding_cleanup_scope_id);\n \n-    debuginfo::create_for_loop_var_metadata(body_bcx_in, pat);\n-\n     // Codegen the body.\n     body_bcx_out = trans_block(body_bcx_out, body, expr::Ignore);\n     body_bcx_out ="}, {"sha": "cdb36602f154161fb238a34bda32f26dcb60e95b", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 70, "deletions": 121, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=2f3cff6956d56048ef7afb6d33e17cbdb2dcf038", "patch": "@@ -182,6 +182,7 @@\n //! comparatively expensive to construct, though, `ty::type_id()` is still used\n //! additionally as an optimization for cases where the exact same type has been\n //! seen before (which is most of the time).\n+use self::FunctionDebugContextRepr::*;\n use self::VariableAccess::*;\n use self::VariableKind::*;\n use self::MemberOffset::*;\n@@ -678,8 +679,12 @@ impl<'tcx> CrateDebugContext<'tcx> {\n     }\n }\n \n-pub enum FunctionDebugContext {\n-    RegularContext(Box<FunctionDebugContextData>),\n+pub struct FunctionDebugContext {\n+    repr: FunctionDebugContextRepr,\n+}\n+\n+enum FunctionDebugContextRepr {\n+    DebugInfo(Box<FunctionDebugContextData>),\n     DebugInfoDisabled,\n     FunctionWithoutDebugInfo,\n }\n@@ -689,13 +694,13 @@ impl FunctionDebugContext {\n                    cx: &CrateContext,\n                    span: Span)\n                    -> &'a FunctionDebugContextData {\n-        match *self {\n-            FunctionDebugContext::RegularContext(box ref data) => data,\n-            FunctionDebugContext::DebugInfoDisabled => {\n+        match self.repr {\n+            DebugInfo(box ref data) => data,\n+            DebugInfoDisabled => {\n                 cx.sess().span_bug(span,\n                                    FunctionDebugContext::debuginfo_disabled_message());\n             }\n-            FunctionDebugContext::FunctionWithoutDebugInfo => {\n+            FunctionWithoutDebugInfo => {\n                 cx.sess().span_bug(span,\n                                    FunctionDebugContext::should_be_ignored_message());\n             }\n@@ -839,8 +844,6 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n \n /// Creates debug information for the given local variable.\n ///\n-/// This function assumes that there's a datum for each pattern component of the\n-/// local in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n     if fn_should_be_ignored(bcx.fcx) {\n@@ -849,10 +852,11 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n \n     let cx = bcx.ccx();\n     let def_map = &cx.tcx().def_map;\n-    let locals = bcx.fcx.lllocals.borrow();\n \n-    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, var_ident| {\n-        let datum = match locals.get(&node_id) {\n+    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, path1| {\n+        let var_ident = path1.node;\n+\n+        let datum = match bcx.fcx.lllocals.borrow().get(&node_id).cloned() {\n             Some(datum) => datum,\n             None => {\n                 bcx.sess().span_bug(span,\n@@ -861,15 +865,10 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n             }\n         };\n \n-        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n-            cx.sess().span_bug(span, \"debuginfo::create_local_var_metadata() - \\\n-                                      Referenced variable location is not an alloca!\");\n-        }\n-\n         let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n \n         declare_local(bcx,\n-                      var_ident.node,\n+                      var_ident,\n                       datum.ty,\n                       scope_metadata,\n                       DirectVariable { alloca: datum.val },\n@@ -982,7 +981,7 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // for the binding. For ByRef bindings that's a `T*` but for ByMove bindings we\n     // actually have `T**`. So to get the actual variable we need to dereference once\n     // more. For ByCopy we just use the stack slot we created for the binding.\n-    let var_access = match binding.trmode {\n+    let var_type = match binding.trmode {\n         TrByCopy(llbinding) => DirectVariable {\n             alloca: llbinding\n         },\n@@ -999,31 +998,27 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   variable_ident,\n                   binding.ty,\n                   scope_metadata,\n-                  var_access,\n+                  var_type,\n                   LocalVariable,\n                   binding.span);\n }\n \n /// Creates debug information for the given function argument.\n ///\n-/// This function assumes that there's a datum for each pattern component of the\n-/// argument in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n \n-    let def_map = &bcx.tcx().def_map;\n-    let scope_metadata = bcx\n-                         .fcx\n-                         .debug_context\n-                         .get_ref(bcx.ccx(), arg.pat.span)\n-                         .fn_metadata;\n-    let locals = bcx.fcx.lllocals.borrow();\n+    let fcx = bcx.fcx;\n+    let cx = fcx.ccx;\n \n-    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, var_ident| {\n-        let datum = match locals.get(&node_id) {\n+    let def_map = &cx.tcx().def_map;\n+    let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n+\n+    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, path1| {\n+        let llarg = match bcx.fcx.lllocals.borrow().get(&node_id).cloned() {\n             Some(v) => v,\n             None => {\n                 bcx.sess().span_bug(span,\n@@ -1032,72 +1027,28 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n             }\n         };\n \n-        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n-            bcx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n-                                       Referenced variable location is not an alloca!\");\n+        if unsafe { llvm::LLVMIsAAllocaInst(llarg.val) } == ptr::null_mut() {\n+            cx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n+                                    Referenced variable location is not an alloca!\");\n         }\n \n         let argument_index = {\n-            let counter = &bcx\n-                          .fcx\n-                          .debug_context\n-                          .get_ref(bcx.ccx(), span)\n-                          .argument_counter;\n+            let counter = &fcx.debug_context.get_ref(cx, span).argument_counter;\n             let argument_index = counter.get();\n             counter.set(argument_index + 1);\n             argument_index\n         };\n \n         declare_local(bcx,\n-                      var_ident.node,\n-                      datum.ty,\n+                      path1.node,\n+                      llarg.ty,\n                       scope_metadata,\n-                      DirectVariable { alloca: datum.val },\n+                      DirectVariable { alloca: llarg.val },\n                       ArgumentVariable(argument_index),\n                       span);\n     })\n }\n \n-/// Creates debug information for the given for-loop variable.\n-///\n-/// This function assumes that there's a datum for each pattern component of the\n-/// loop variable in `bcx.fcx.lllocals`.\n-/// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_for_loop_var_metadata(bcx: Block, pat: &ast::Pat) {\n-    if fn_should_be_ignored(bcx.fcx) {\n-        return;\n-    }\n-\n-    let def_map = &bcx.tcx().def_map;\n-    let locals = bcx.fcx.lllocals.borrow();\n-\n-    pat_util::pat_bindings(def_map, pat, |_, node_id, span, var_ident| {\n-        let datum = match locals.get(&node_id) {\n-            Some(datum) => datum,\n-            None => {\n-                bcx.sess().span_bug(span,\n-                    format!(\"no entry in lllocals table for {}\",\n-                            node_id).as_slice());\n-            }\n-        };\n-\n-        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n-            bcx.sess().span_bug(span, \"debuginfo::create_for_loop_var_metadata() - \\\n-                                       Referenced variable location is not an alloca!\");\n-        }\n-\n-        let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n-\n-        declare_local(bcx,\n-                      var_ident.node,\n-                      datum.ty,\n-                      scope_metadata,\n-                      DirectVariable { alloca: datum.val },\n-                      LocalVariable,\n-                      span);\n-    })\n-}\n-\n pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                     node_id: ast::NodeId,\n                                                     node_span: Span,\n@@ -1166,13 +1117,13 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n pub fn set_source_location(fcx: &FunctionContext,\n                            node_id: ast::NodeId,\n                            span: Span) {\n-    match fcx.debug_context {\n-        FunctionDebugContext::DebugInfoDisabled => return,\n-        FunctionDebugContext::FunctionWithoutDebugInfo => {\n+    match fcx.debug_context.repr {\n+        DebugInfoDisabled => return,\n+        FunctionWithoutDebugInfo => {\n             set_debug_location(fcx.ccx, UnknownLocation);\n             return;\n         }\n-        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n+        DebugInfo(box ref function_debug_context) => {\n             let cx = fcx.ccx;\n \n             debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_string(span));\n@@ -1209,8 +1160,8 @@ pub fn clear_source_location(fcx: &FunctionContext) {\n /// switches source location emitting on and must therefore be called before the\n /// first real statement/expression of the function is translated.\n pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n-    match fcx.debug_context {\n-        FunctionDebugContext::RegularContext(box ref data) => {\n+    match fcx.debug_context.repr {\n+        DebugInfo(box ref data) => {\n             data.source_locations_enabled.set(true)\n         },\n         _ => { /* safe to ignore */ }\n@@ -1228,7 +1179,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                param_substs: &Substs<'tcx>,\n                                                llfn: ValueRef) -> FunctionDebugContext {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n-        return FunctionDebugContext::DebugInfoDisabled;\n+        return FunctionDebugContext { repr: DebugInfoDisabled };\n     }\n \n     // Clear the debug location so we don't assign them in the function prelude.\n@@ -1238,7 +1189,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     if fn_ast_id == ast::DUMMY_NODE_ID {\n         // This is a function not linked to any source location, so don't\n         // generate debuginfo for it.\n-        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+        return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n     }\n \n     let empty_generics = ast_util::empty_generics();\n@@ -1248,7 +1199,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let (ident, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n         ast_map::NodeItem(ref item) => {\n             if contains_nodebug_attribute(item.attrs.as_slice()) {\n-                return FunctionDebugContext::FunctionWithoutDebugInfo;\n+                return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n             }\n \n             match item.node {\n@@ -1265,7 +1216,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match **item {\n                 ast::MethodImplItem(ref method) => {\n                     if contains_nodebug_attribute(method.attrs.as_slice()) {\n-                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+                        return FunctionDebugContext {\n+                            repr: FunctionWithoutDebugInfo\n+                        };\n                     }\n \n                     (method.pe_ident(),\n@@ -1304,7 +1257,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match **trait_method {\n                 ast::ProvidedMethod(ref method) => {\n                     if contains_nodebug_attribute(method.attrs.as_slice()) {\n-                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+                        return FunctionDebugContext {\n+                            repr: FunctionWithoutDebugInfo\n+                        };\n                     }\n \n                     (method.pe_ident(),\n@@ -1325,7 +1280,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ast_map::NodeForeignItem(..) |\n         ast_map::NodeVariant(..) |\n         ast_map::NodeStructCtor(..) => {\n-            return FunctionDebugContext::FunctionWithoutDebugInfo;\n+            return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n         }\n         _ => cx.sess().bug(format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {}\",\n@@ -1334,7 +1289,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // This can be the case for functions inlined from another crate\n     if span == codemap::DUMMY_SP {\n-        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+        return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n     }\n \n     let loc = span_start(cx, span);\n@@ -1401,23 +1356,22 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         })\n     });\n \n-    let scope_map = create_scope_map(cx,\n-                                     fn_decl.inputs.as_slice(),\n-                                     &*top_level_block,\n-                                     fn_metadata,\n-                                     fn_ast_id);\n-\n     // Initialize fn debug context (including scope map and namespace map)\n     let fn_debug_context = box FunctionDebugContextData {\n-        scope_map: RefCell::new(scope_map),\n+        scope_map: RefCell::new(NodeMap::new()),\n         fn_metadata: fn_metadata,\n         argument_counter: Cell::new(1),\n         source_locations_enabled: Cell::new(false),\n     };\n \n+    populate_scope_map(cx,\n+                       fn_decl.inputs.as_slice(),\n+                       &*top_level_block,\n+                       fn_metadata,\n+                       fn_ast_id,\n+                       &mut *fn_debug_context.scope_map.borrow_mut());\n \n-\n-    return FunctionDebugContext::RegularContext(fn_debug_context);\n+    return FunctionDebugContext { repr: DebugInfo(fn_debug_context) };\n \n     fn get_function_signature<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                         fn_ast_id: ast::NodeId,\n@@ -3180,8 +3134,8 @@ fn DIB(cx: &CrateContext) -> DIBuilderRef {\n }\n \n fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n-    match fcx.debug_context {\n-        FunctionDebugContext::RegularContext(_) => false,\n+    match fcx.debug_context.repr {\n+        DebugInfo(_) => false,\n         _ => true\n     }\n }\n@@ -3215,14 +3169,12 @@ fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n // what belongs to which scope, creating DIScope DIEs along the way, and\n // introducing *artificial* lexical scope descriptors where necessary. These\n // artificial scopes allow GDB to correctly handle name shadowing.\n-fn create_scope_map(cx: &CrateContext,\n-                    args: &[ast::Arg],\n-                    fn_entry_block: &ast::Block,\n-                    fn_metadata: DISubprogram,\n-                    fn_ast_id: ast::NodeId)\n-                 -> NodeMap<DIScope> {\n-    let mut scope_map = NodeMap::new();\n-\n+fn populate_scope_map(cx: &CrateContext,\n+                      args: &[ast::Arg],\n+                      fn_entry_block: &ast::Block,\n+                      fn_metadata: DISubprogram,\n+                      fn_ast_id: ast::NodeId,\n+                      scope_map: &mut NodeMap<DIScope>) {\n     let def_map = &cx.tcx().def_map;\n \n     struct ScopeStackEntry {\n@@ -3248,14 +3200,11 @@ fn create_scope_map(cx: &CrateContext,\n     with_new_scope(cx,\n                    fn_entry_block.span,\n                    &mut scope_stack,\n-                   &mut scope_map,\n+                   scope_map,\n                    |cx, scope_stack, scope_map| {\n         walk_block(cx, fn_entry_block, scope_stack, scope_map);\n     });\n \n-    return scope_map;\n-\n-\n     // local helper functions for walking the AST.\n     fn with_new_scope<F>(cx: &CrateContext,\n                          scope_span: Span,\n@@ -3491,7 +3440,7 @@ fn create_scope_map(cx: &CrateContext,\n             }\n \n             ast::PatMac(_) => {\n-                cx.sess().span_bug(pat.span, \"debuginfo::create_scope_map() - \\\n+                cx.sess().span_bug(pat.span, \"debuginfo::populate_scope_map() - \\\n                                               Found unexpanded macro.\");\n             }\n         }\n@@ -3577,7 +3526,7 @@ fn create_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprIfLet(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n                                               Found unexpanded if-let.\");\n             }\n \n@@ -3594,7 +3543,7 @@ fn create_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprWhileLet(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n                                               Found unexpanded while-let.\");\n             }\n \n@@ -3619,7 +3568,7 @@ fn create_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprMac(_) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n                                               Found unexpanded macro.\");\n             }\n "}, {"sha": "19a82ee5e67b3f5a702dfbf4e02b78ad0d6af303", "filename": "src/test/debuginfo/destructured-for-loop-variable.rs", "status": "removed", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -1,178 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-android: FIXME(#10381)\n-// min-lldb-version: 310\n-\n-// compile-flags:-g\n-\n-// === GDB TESTS ===================================================================================\n-\n-// gdb-command:run\n-\n-// DESTRUCTURED STRUCT\n-// gdb-command:print x\n-// gdb-check:$1 = 400\n-// gdb-command:print y\n-// gdb-check:$2 = 401.5\n-// gdb-command:print z\n-// gdb-check:$3 = true\n-// gdb-command:continue\n-\n-// DESTRUCTURED TUPLE\n-// gdb-command:print/x _i8\n-// gdb-check:$4 = 0x6f\n-// gdb-command:print/x _u8\n-// gdb-check:$5 = 0x70\n-// gdb-command:print _i16\n-// gdb-check:$6 = -113\n-// gdb-command:print _u16\n-// gdb-check:$7 = 114\n-// gdb-command:print _i32\n-// gdb-check:$8 = -115\n-// gdb-command:print _u32\n-// gdb-check:$9 = 116\n-// gdb-command:print _i64\n-// gdb-check:$10 = -117\n-// gdb-command:print _u64\n-// gdb-check:$11 = 118\n-// gdb-command:print _f32\n-// gdb-check:$12 = 119.5\n-// gdb-command:print _f64\n-// gdb-check:$13 = 120.5\n-// gdb-command:continue\n-\n-// MORE COMPLEX CASE\n-// gdb-command:print v1\n-// gdb-check:$14 = 80000\n-// gdb-command:print x1\n-// gdb-check:$15 = 8000\n-// gdb-command:print *y1\n-// gdb-check:$16 = 80001.5\n-// gdb-command:print z1\n-// gdb-check:$17 = false\n-// gdb-command:print *x2\n-// gdb-check:$18 = -30000\n-// gdb-command:print y2\n-// gdb-check:$19 = -300001.5\n-// gdb-command:print *z2\n-// gdb-check:$20 = true\n-// gdb-command:print v2\n-// gdb-check:$21 = 854237.5\n-// gdb-command:continue\n-\n-\n-// === LLDB TESTS ==================================================================================\n-\n-// lldb-command:type format add --format hex char\n-// lldb-command:type format add --format hex 'unsigned char'\n-\n-// lldb-command:run\n-\n-// DESTRUCTURED STRUCT\n-// lldb-command:print x\n-// lldb-check:[...]$0 = 400\n-// lldb-command:print y\n-// lldb-check:[...]$1 = 401.5\n-// lldb-command:print z\n-// lldb-check:[...]$2 = true\n-// lldb-command:continue\n-\n-// DESTRUCTURED TUPLE\n-// lldb-command:print _i8\n-// lldb-check:[...]$3 = 0x6f\n-// lldb-command:print _u8\n-// lldb-check:[...]$4 = 0x70\n-// lldb-command:print _i16\n-// lldb-check:[...]$5 = -113\n-// lldb-command:print _u16\n-// lldb-check:[...]$6 = 114\n-// lldb-command:print _i32\n-// lldb-check:[...]$7 = -115\n-// lldb-command:print _u32\n-// lldb-check:[...]$8 = 116\n-// lldb-command:print _i64\n-// lldb-check:[...]$9 = -117\n-// lldb-command:print _u64\n-// lldb-check:[...]$10 = 118\n-// lldb-command:print _f32\n-// lldb-check:[...]$11 = 119.5\n-// lldb-command:print _f64\n-// lldb-check:[...]$12 = 120.5\n-// lldb-command:continue\n-\n-// MORE COMPLEX CASE\n-// lldb-command:print v1\n-// lldb-check:[...]$13 = 80000\n-// lldb-command:print x1\n-// lldb-check:[...]$14 = 8000\n-// lldb-command:print *y1\n-// lldb-check:[...]$15 = 80001.5\n-// lldb-command:print z1\n-// lldb-check:[...]$16 = false\n-// lldb-command:print *x2\n-// lldb-check:[...]$17 = -30000\n-// lldb-command:print y2\n-// lldb-check:[...]$18 = -300001.5\n-// lldb-command:print *z2\n-// lldb-check:[...]$19 = true\n-// lldb-command:print v2\n-// lldb-check:[...]$20 = 854237.5\n-// lldb-command:continue\n-\n-\n-struct Struct {\n-    x: i16,\n-    y: f32,\n-    z: bool\n-}\n-\n-fn main() {\n-\n-    let s = Struct {\n-        x: 400,\n-        y: 401.5,\n-        z: true\n-    };\n-\n-    for &Struct { x, y, z } in [s].iter() {\n-        zzz(); // #break\n-    }\n-\n-    let tuple: (i8, u8, i16, u16, i32, u32, i64, u64, f32, f64) =\n-        (0x6f, 0x70, -113, 114, -115, 116, -117, 118, 119.5, 120.5);\n-\n-    for &(_i8, _u8, _i16, _u16, _i32, _u32, _i64, _u64, _f32, _f64) in [tuple].iter() {\n-        zzz(); // #break\n-    }\n-\n-    let more_complex: (i32, &Struct, Struct, Box<f64>) =\n-        (80000,\n-         &Struct {\n-            x: 8000,\n-            y: 80001.5,\n-            z: false\n-         },\n-         Struct {\n-            x: -30000,\n-            y: -300001.5,\n-            z: true\n-         },\n-         box 854237.5);\n-\n-    for &(v1,\n-          &Struct { x: x1, y: ref y1, z: z1 },\n-          Struct { x: ref x2, y: y2, z: ref z2 },\n-          box v2) in [more_complex].iter() {\n-        zzz(); // #break\n-    }\n-}\n-\n-fn zzz() {()}"}, {"sha": "bcaebb5c153f5d411f685243110d9aec4b4c25ac", "filename": "src/test/debuginfo/lexical-scope-in-for-loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs?ref=2f3cff6956d56048ef7afb6d33e17cbdb2dcf038", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // ignore-android: FIXME(#10381)\n+// ignore-test: Not sure what is going on here --pcwalton\n // min-lldb-version: 310\n \n // compile-flags:-g"}]}