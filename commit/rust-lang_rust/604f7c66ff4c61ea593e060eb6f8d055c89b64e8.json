{"sha": "604f7c66ff4c61ea593e060eb6f8d055c89b64e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwNGY3YzY2ZmY0YzYxZWE1OTNlMDYwZWI2ZjhkMDU1Yzg5YjY0ZTg=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-06T18:05:28Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-06T18:05:28Z"}, "message": "Removing locked queue port/chan prototype.", "tree": {"sha": "dd03baf6dbcb5d67709469758ee49237add78a9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd03baf6dbcb5d67709469758ee49237add78a9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/604f7c66ff4c61ea593e060eb6f8d055c89b64e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/604f7c66ff4c61ea593e060eb6f8d055c89b64e8", "html_url": "https://github.com/rust-lang/rust/commit/604f7c66ff4c61ea593e060eb6f8d055c89b64e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/604f7c66ff4c61ea593e060eb6f8d055c89b64e8/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b03832c958826b27ea77df91f2d2ac276bb7411", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b03832c958826b27ea77df91f2d2ac276bb7411", "html_url": "https://github.com/rust-lang/rust/commit/7b03832c958826b27ea77df91f2d2ac276bb7411"}], "stats": {"total": 165, "additions": 1, "deletions": 164}, "files": [{"sha": "d17cef756295b97a9b7ca035bed8f9414249674a", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/604f7c66ff4c61ea593e060eb6f8d055c89b64e8/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/604f7c66ff4c61ea593e060eb6f8d055c89b64e8/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=604f7c66ff4c61ea593e060eb6f8d055c89b64e8", "patch": "@@ -39,7 +39,7 @@ export float, f32, f64;\n export box, char, str, ptr, vec, bool;\n export either, option, result, iter;\n export libc, os, io, run, rand, sys, unsafe, logging;\n-export arc, newcomm, comm, task, future, pipes;\n+export arc, comm, task, future, pipes;\n export extfmt;\n export tuple;\n export to_str, to_bytes;\n@@ -183,7 +183,6 @@ mod dlist_iter {\n \n // Concurrency\n mod arc;\n-mod newcomm;\n mod comm;\n mod task;\n mod future;"}, {"sha": "ec3c37d151d65fd3a216761670cc4f358230e2a2", "filename": "src/libcore/newcomm.rs", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/7b03832c958826b27ea77df91f2d2ac276bb7411/src%2Flibcore%2Fnewcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b03832c958826b27ea77df91f2d2ac276bb7411/src%2Flibcore%2Fnewcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnewcomm.rs?ref=7b03832c958826b27ea77df91f2d2ac276bb7411", "patch": "@@ -1,85 +0,0 @@\n-/**\n- * A new implementation of communication.\n- *\n- * This should be implementing almost entirely in Rust, and hopefully\n- * avoid needing a single global lock.\n- */\n-\n-import arc::methods;\n-import dvec::dvec;\n-import dvec::extensions;\n-import sys::methods;\n-\n-export port;\n-export chan;\n-export send, recv;\n-export methods;\n-\n-type raw_port<T: send> = arc::exclusive<dvec<T>>;\n-\n-enum port<T: send> {\n-    port_(raw_port<T>)\n-}\n-enum chan<T: send> {\n-    chan_(raw_port<T>)\n-}\n-\n-fn port<T: send>() -> port<T> {\n-    port_(arc::exclusive(dvec()))\n-}\n-\n-fn chan<T: send>(p: port<T>) -> chan<T> {\n-    chan_((*p).clone())\n-}\n-\n-fn send<T: send>(c: chan<T>, -x: T) {\n-    let mut x <- some(x);\n-    do (*c).with |cond, data| {\n-        let mut xx = none;\n-        xx <-> x;\n-        (*data).push(option::unwrap(xx));\n-        cond.signal();\n-    }\n-}\n-\n-fn recv<T: send>(p: port<T>) -> T {\n-    do (*p).with |cond, data| {\n-        if (*data).len() == 0u {\n-            cond.wait();\n-        }\n-        assert (*data).len() > 0u;\n-        (*data).shift()\n-    }\n-}\n-\n-impl methods<T: send> for chan<T> {\n-    fn send(-x: T) {\n-        send(self, x)\n-    }\n-\n-    fn clone() -> chan<T> {\n-        chan_((*self).clone())\n-    }\n-}\n-\n-impl methods<T: send> for port<T> {\n-    fn recv() -> T {\n-        recv(self)\n-    }\n-\n-    fn chan() -> chan<T> {\n-        chan(self)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    #[test]\n-    fn newport_simple() {\n-        let p = port();\n-        let c = chan(p);\n-\n-        c.send(42);\n-        assert p.recv() == 42;\n-    }\n-}"}, {"sha": "93f78df7d7e2700bb69269ec1c03e8a7e80fa3a3", "filename": "src/test/bench/msgsend-ring-new.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7b03832c958826b27ea77df91f2d2ac276bb7411/src%2Ftest%2Fbench%2Fmsgsend-ring-new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b03832c958826b27ea77df91f2d2ac276bb7411/src%2Ftest%2Fbench%2Fmsgsend-ring-new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-new.rs?ref=7b03832c958826b27ea77df91f2d2ac276bb7411", "patch": "@@ -1,77 +0,0 @@\n-// This test creates a bunch of tasks that simultaneously send to each\n-// other in a ring. The messages should all be basically\n-// independent. It's designed to hammer the global kernel lock, so\n-// that things will look really good once we get that lock out of the\n-// message path.\n-\n-import newcomm::*;\n-import future::future;\n-import future::extensions;\n-\n-use std;\n-import std::time;\n-\n-fn thread_ring(i: uint,\n-               count: uint,\n-               num_chan: chan<uint>,\n-               num_port: port<uint>) {\n-    // Send/Receive lots of messages.\n-    for uint::range(0u, count) |j| {\n-        num_chan.send(i * j);\n-        num_port.recv();\n-    };\n-}\n-\n-fn main(args: ~[str]) {\n-    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        ~[\"\", \"100\", \"10000\"]\n-    } else if args.len() <= 1u {\n-        ~[\"\", \"100\", \"1000\"]\n-    } else {\n-        args\n-    };        \n-\n-    let num_tasks = option::get(uint::from_str(args[1]));\n-    let msg_per_task = option::get(uint::from_str(args[2]));\n-\n-    let num_port = port();\n-    let mut num_chan = chan(num_port);\n-\n-    let start = time::precise_time_s();\n-\n-    // create the ring\n-    let mut futures = ~[];\n-\n-    for uint::range(1u, num_tasks) |i| {\n-        let get_chan = port();\n-        let get_chan_chan = chan(get_chan);\n-        {\n-            let num_chan = num_chan.clone();\n-            futures += ~[do future::spawn |move num_chan, move get_chan_chan| {\n-                let p = port();\n-                get_chan_chan.send(chan(p));\n-                thread_ring(i, msg_per_task, num_chan,  p)\n-            }];\n-        }\n-        \n-        num_chan = get_chan.recv();\n-    };\n-\n-    // do our iteration\n-    thread_ring(0u, msg_per_task, num_chan, num_port);\n-\n-    // synchronize\n-    for futures.each |f| { f.get() };\n-\n-    let stop = time::precise_time_s();\n-\n-    // all done, report stats.\n-    let num_msgs = num_tasks * msg_per_task;\n-    let elapsed = (stop - start);\n-    let rate = (num_msgs as float) / elapsed;\n-\n-    io::println(#fmt(\"Sent %? messages in %? seconds\",\n-                     num_msgs, elapsed));\n-    io::println(#fmt(\"  %? messages / second\", rate));\n-    io::println(#fmt(\"  %? \u03bcs / message\", 1000000. / rate));\n-}"}]}