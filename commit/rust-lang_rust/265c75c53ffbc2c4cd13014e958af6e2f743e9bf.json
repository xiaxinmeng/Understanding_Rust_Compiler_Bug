{"sha": "265c75c53ffbc2c4cd13014e958af6e2f743e9bf", "node_id": "C_kwDOAAsO6NoAKDI2NWM3NWM1M2ZmYmMyYzRjZDEzMDE0ZTk1OGFmNmUyZjc0M2U5YmY", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-09-05T09:35:50Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-09-05T10:13:32Z"}, "message": "fix: sort all bounds on trait object types", "tree": {"sha": "146b64b682fc8f6da87b7117e8341e52f972390b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/146b64b682fc8f6da87b7117e8341e52f972390b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/265c75c53ffbc2c4cd13014e958af6e2f743e9bf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmMVy8wACgkQ4laYqTBY\nYXFFlg//eSlYtZXbh3z3cmBcqFLGSIQ8vkHyXBPbjfm8jBF2OpoI1IdpBAwwkbbP\nPR0iV5Pn+i1y0LevgkogZ52MBTPqDvQERz+V2VuqxhbTLIA88M9vjVaKeYcCcEXq\nmofap7wzlQTTR6CKAVnl2b0L+fVxMGaoyYrh4CR1sh3n/nco9TYQMw3aObK7HHoX\nzuVwHS/qhAYfaffLnfeUH1zcnhF+Kqa4EE3JEAA0B/ON7GDaoG2PuiJrRKpmRox0\nmxP11ItgU0R3GnXZ2eymbuokn9ftE1LbVbZme4Xmd+Hn45Q2kvnqQFpANLYmkQn1\nLdDsUT/bnBSLLswJ99FEo3t5KeggkfMV5eg594+TPVvRo5M+lI35+IA5pFngN2DK\naTweCLAV5QvowDjGcHApZVY/BUlg9fRj01Sz/fABkVhBu5odXUzAZq8yx++dsZ7P\nj8a72CqeJ2NJSKMdvqW6RqYDAoNL0D5pN2b/n/tHbWTu2NKizvclIsUhZBhAPSY/\nEZklGWjiUkUkS6BDlBjo0VXhhypVLHwuuEaZGWIx5YZinozBPPBkUt2f9LVZ/YDH\nmBniq3DIg5KXfBTcDjbCPrsW1XznsPAp032/Zrt+m5DnmhmyCYy3GGSlLxjrM93w\nr0igJt7JqeeSSXoL4DMbeooPDJ68IAPc27NjEnoZNbjfibVy3q4=\n=xf5j\n-----END PGP SIGNATURE-----", "payload": "tree 146b64b682fc8f6da87b7117e8341e52f972390b\nparent 67920f797511c360b25dab4d30730be304848f32\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1662370550 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1662372812 +0900\n\nfix: sort all bounds on trait object types\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/265c75c53ffbc2c4cd13014e958af6e2f743e9bf", "html_url": "https://github.com/rust-lang/rust/commit/265c75c53ffbc2c4cd13014e958af6e2f743e9bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/265c75c53ffbc2c4cd13014e958af6e2f743e9bf/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67920f797511c360b25dab4d30730be304848f32", "url": "https://api.github.com/repos/rust-lang/rust/commits/67920f797511c360b25dab4d30730be304848f32", "html_url": "https://github.com/rust-lang/rust/commit/67920f797511c360b25dab4d30730be304848f32"}], "stats": {"total": 105, "additions": 82, "deletions": 23}, "files": [{"sha": "4a5533c6487e48361dd1a94943f7e917c384821e", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265c75c53ffbc2c4cd13014e958af6e2f743e9bf/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265c75c53ffbc2c4cd13014e958af6e2f743e9bf/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=265c75c53ffbc2c4cd13014e958af6e2f743e9bf", "patch": "@@ -164,6 +164,8 @@ impl TyExt for Ty {\n \n     fn dyn_trait(&self) -> Option<TraitId> {\n         let trait_ref = match self.kind(Interner) {\n+            // The principal trait bound should be the first element of the bounds. This is an\n+            // invariant ensured by `TyLoweringContext::lower_dyn_trait()`.\n             TyKind::Dyn(dyn_ty) => dyn_ty.bounds.skip_binders().interned().get(0).and_then(|b| {\n                 match b.skip_binders() {\n                     WhereClause::Implemented(trait_ref) => Some(trait_ref),"}, {"sha": "532544fee595c51eee1680627a70cbfe327a7a01", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 52, "deletions": 23, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/265c75c53ffbc2c4cd13014e958af6e2f743e9bf/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265c75c53ffbc2c4cd13014e958af6e2f743e9bf/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=265c75c53ffbc2c4cd13014e958af6e2f743e9bf", "patch": "@@ -981,43 +981,72 @@ impl<'a> TyLoweringContext<'a> {\n \n     fn lower_dyn_trait(&self, bounds: &[Interned<TypeBound>]) -> Ty {\n         let self_ty = TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(Interner);\n+        // INVARIANT: The principal trait bound must come first. Others may be in any order but\n+        // should be in the same order for the same set but possibly different order of bounds in\n+        // the input.\n+        // This invariant is used by `TyExt::dyn_trait()` and chalk.\n         let bounds = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n-            let bounds =\n-                bounds.iter().flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false));\n-\n-            let mut auto_traits = SmallVec::<[_; 8]>::new();\n-            let mut regular_traits = SmallVec::<[_; 2]>::new();\n-            let mut other_bounds = SmallVec::<[_; 8]>::new();\n-            for bound in bounds {\n-                if let Some(id) = bound.trait_id() {\n-                    if ctx.db.trait_data(from_chalk_trait_id(id)).is_auto {\n-                        auto_traits.push(bound);\n-                    } else {\n-                        regular_traits.push(bound);\n+            let mut bounds: Vec<_> = bounds\n+                .iter()\n+                .flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false))\n+                .collect();\n+\n+            let mut multiple_regular_traits = false;\n+            let mut multiple_same_projection = false;\n+            bounds.sort_unstable_by(|lhs, rhs| {\n+                use std::cmp::Ordering;\n+                match (lhs.skip_binders(), rhs.skip_binders()) {\n+                    (WhereClause::Implemented(lhs), WhereClause::Implemented(rhs)) => {\n+                        let lhs_id = lhs.trait_id;\n+                        let lhs_is_auto = ctx.db.trait_data(from_chalk_trait_id(lhs_id)).is_auto;\n+                        let rhs_id = rhs.trait_id;\n+                        let rhs_is_auto = ctx.db.trait_data(from_chalk_trait_id(rhs_id)).is_auto;\n+\n+                        if !lhs_is_auto && !rhs_is_auto {\n+                            multiple_regular_traits = true;\n+                        }\n+                        // Note that the ordering here is important; this ensures the invariant\n+                        // mentioned above.\n+                        (lhs_is_auto, lhs_id).cmp(&(rhs_is_auto, rhs_id))\n                     }\n-                } else {\n-                    other_bounds.push(bound);\n+                    (WhereClause::Implemented(_), _) => Ordering::Less,\n+                    (_, WhereClause::Implemented(_)) => Ordering::Greater,\n+                    (WhereClause::AliasEq(lhs), WhereClause::AliasEq(rhs)) => {\n+                        match (&lhs.alias, &rhs.alias) {\n+                            (AliasTy::Projection(lhs_proj), AliasTy::Projection(rhs_proj)) => {\n+                                // We only compare the `associated_ty_id`s. We shouldn't have\n+                                // multiple bounds for an associated type in the correct Rust code,\n+                                // and if we do, we error out.\n+                                if lhs_proj.associated_ty_id == rhs_proj.associated_ty_id {\n+                                    multiple_same_projection = true;\n+                                }\n+                                lhs_proj.associated_ty_id.cmp(&rhs_proj.associated_ty_id)\n+                            }\n+                            // We don't produce `AliasTy::Opaque`s yet.\n+                            _ => unreachable!(),\n+                        }\n+                    }\n+                    // We don't produce `WhereClause::{TypeOutlives, LifetimeOutlives}` yet.\n+                    _ => unreachable!(),\n                 }\n-            }\n+            });\n \n-            if regular_traits.len() > 1 {\n+            if multiple_regular_traits || multiple_same_projection {\n                 return None;\n             }\n \n-            auto_traits.sort_unstable_by_key(|b| b.trait_id().unwrap());\n-            auto_traits.dedup();\n+            // As multiple occurrences of the same auto traits *are* permitted, we dedulicate the\n+            // bounds. We shouldn't have repeated elements besides auto traits at this point.\n+            bounds.dedup();\n \n-            Some(QuantifiedWhereClauses::from_iter(\n-                Interner,\n-                regular_traits.into_iter().chain(other_bounds).chain(auto_traits),\n-            ))\n+            Some(QuantifiedWhereClauses::from_iter(Interner, bounds))\n         });\n \n         if let Some(bounds) = bounds {\n             let bounds = crate::make_single_type_binders(bounds);\n             TyKind::Dyn(DynTy { bounds, lifetime: static_lifetime() }).intern(Interner)\n         } else {\n-            // FIXME: report error (additional non-auto traits)\n+            // FIXME: report error (additional non-auto traits or associated type rebound)\n             TyKind::Error.intern(Interner)\n         }\n     }"}, {"sha": "21a86319763fc1d78212c1aef02e9f9e22878918", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/265c75c53ffbc2c4cd13014e958af6e2f743e9bf/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265c75c53ffbc2c4cd13014e958af6e2f743e9bf/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=265c75c53ffbc2c4cd13014e958af6e2f743e9bf", "patch": "@@ -3900,6 +3900,34 @@ fn g(t: &(dyn Sync + T<Proj = ()> + Send)) {\n     );\n }\n \n+#[test]\n+fn dyn_multiple_projection_bounds() {\n+    check_no_mismatches(\n+        r#\"\n+trait Trait {\n+    type T;\n+    type U;\n+}\n+\n+fn f(t: &dyn Trait<T = (), U = ()>) {}\n+fn g(t: &dyn Trait<U = (), T = ()>) {\n+    f(t);\n+}\n+        \"#,\n+    );\n+\n+    check_types(\n+        r#\"\n+trait Trait {\n+    type T;\n+}\n+\n+fn f(t: &dyn Trait<T = (), T = ()>) {}\n+   //^&{unknown}\n+        \"#,\n+    );\n+}\n+\n #[test]\n fn dyn_duplicate_auto_trait() {\n     check_no_mismatches("}]}