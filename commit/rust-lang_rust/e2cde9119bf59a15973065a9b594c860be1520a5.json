{"sha": "e2cde9119bf59a15973065a9b594c860be1520a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyY2RlOTExOWJmNTlhMTU5NzMwNjVhOWI1OTRjODYwYmUxNTIwYTU=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-05-15T00:44:46Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-05-15T01:33:13Z"}, "message": "Remove separation between generator_drop and unwind paths", "tree": {"sha": "40fb8905a9e61241a31f05031d152d13bfbbd18c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40fb8905a9e61241a31f05031d152d13bfbbd18c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2cde9119bf59a15973065a9b594c860be1520a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2cde9119bf59a15973065a9b594c860be1520a5", "html_url": "https://github.com/rust-lang/rust/commit/e2cde9119bf59a15973065a9b594c860be1520a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2cde9119bf59a15973065a9b594c860be1520a5/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd2eabc49d415dd30cea0953df5d7659d4d9440f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd2eabc49d415dd30cea0953df5d7659d4d9440f", "html_url": "https://github.com/rust-lang/rust/commit/dd2eabc49d415dd30cea0953df5d7659d4d9440f"}], "stats": {"total": 81, "additions": 28, "deletions": 53}, "files": [{"sha": "e6cebd72f19db3bc4aac4271b8d61514de71f062", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 28, "deletions": 53, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/e2cde9119bf59a15973065a9b594c860be1520a5/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2cde9119bf59a15973065a9b594c860be1520a5/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=e2cde9119bf59a15973065a9b594c860be1520a5", "patch": "@@ -124,7 +124,10 @@ pub struct Scope<'tcx> {\n     /// The cache for drop chain on \"generator drop\" exit.\n     cached_generator_drop: Option<BasicBlock>,\n \n-    /// The cache for drop chain on \"unwind\" exit.\n+    /// The cache for drop chain on \"unwind\" exit. This block\n+    /// contains code to run the current drop and all the preceding\n+    /// drops (i.e., those having lower index in Drop\u2019s Scope drop\n+    /// array)\n     cached_unwind: CachedBlock,\n }\n \n@@ -141,21 +144,7 @@ struct DropData<'tcx> {\n }\n \n #[derive(Debug, Default, Clone, Copy)]\n-pub(crate) struct CachedBlock {\n-    /// The cached block for the cleanups-on-diverge path. This block\n-    /// contains code to run the current drop and all the preceding\n-    /// drops (i.e., those having lower index in Drop\u2019s Scope drop\n-    /// array)\n-    unwind: Option<BasicBlock>,\n-\n-    /// The cached block for unwinds during cleanups-on-generator-drop path\n-    ///\n-    /// This is split from the standard unwind path here to prevent drop\n-    /// elaboration from creating drop flags that would have to be captured\n-    /// by the generator. I'm not sure how important this optimization is,\n-    /// but it is here.\n-    generator_drop: Option<BasicBlock>,\n-}\n+pub(crate) struct CachedBlock(Option<BasicBlock>);\n \n #[derive(Debug)]\n pub(crate) enum DropKind {\n@@ -181,24 +170,15 @@ pub struct BreakableScope<'tcx> {\n \n impl CachedBlock {\n     fn invalidate(&mut self) {\n-        self.generator_drop = None;\n-        self.unwind = None;\n+        self.0 = None;\n     }\n \n-    fn get(&self, generator_drop: bool) -> Option<BasicBlock> {\n-        if generator_drop {\n-            self.generator_drop\n-        } else {\n-            self.unwind\n-        }\n+    fn get(&self) -> Option<BasicBlock> {\n+        self.0\n     }\n \n-    fn ref_mut(&mut self, generator_drop: bool) -> &mut Option<BasicBlock> {\n-        if generator_drop {\n-            &mut self.generator_drop\n-        } else {\n-            &mut self.unwind\n-        }\n+    fn ref_mut(&mut self) -> &mut Option<BasicBlock> {\n+        &mut self.0\n     }\n }\n \n@@ -378,7 +358,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         assert_eq!(scope.region_scope, region_scope.0);\n \n         let unwind_to = self.scopes.last().and_then(|next_scope| {\n-            next_scope.cached_unwind.get(false)\n+            next_scope.cached_unwind.get()\n         }).unwrap_or_else(|| self.resume_block());\n \n         unpack!(block = build_scope_drops(\n@@ -387,7 +367,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             block,\n             unwind_to,\n             self.arg_count,\n-            false,\n         ));\n \n         block.unit()\n@@ -442,7 +421,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             };\n \n-            let unwind_to = next_scope.cached_unwind.get(false).unwrap_or_else(|| {\n+            let unwind_to = next_scope.cached_unwind.get().unwrap_or_else(|| {\n                 debug_assert!(!may_panic, \"cached block not present?\");\n                 START_BLOCK\n             });\n@@ -453,7 +432,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block,\n                 unwind_to,\n                 self.arg_count,\n-                false,\n             ));\n \n             scope = next_scope;\n@@ -470,7 +448,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// None indicates there\u2019s no cleanup to do at this point.\n     pub fn generator_drop_cleanup(&mut self) -> Option<BasicBlock> {\n         // Fill in the cache for unwinds\n-        self.diverge_cleanup_gen(true);\n+        self.diverge_cleanup_gen();\n \n         let src_info = self.scopes[0].source_info(self.fn_span);\n         let resume_block = self.resume_block();\n@@ -496,7 +474,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             };\n \n             let unwind_to = scopes.peek().as_ref().map(|scope| {\n-                scope.cached_unwind.get(true).unwrap_or_else(|| {\n+                scope.cached_unwind.get().unwrap_or_else(|| {\n                     span_bug!(src_info.span, \"cached block not present?\")\n                 })\n             }).unwrap_or(resume_block);\n@@ -507,7 +485,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block,\n                 unwind_to,\n                 self.arg_count,\n-                true,\n             ));\n         }\n \n@@ -760,7 +737,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// This path terminates in Resume. Returns the start of the path.\n     /// See module comment for more details.\n     pub fn diverge_cleanup(&mut self) -> BasicBlock {\n-        self.diverge_cleanup_gen(false)\n+        self.diverge_cleanup_gen()\n     }\n \n     fn resume_block(&mut self) -> BasicBlock {\n@@ -779,7 +756,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn diverge_cleanup_gen(&mut self, generator_drop: bool) -> BasicBlock {\n+    fn diverge_cleanup_gen(&mut self) -> BasicBlock {\n         // Build up the drops in **reverse** order. The end result will\n         // look like:\n         //\n@@ -793,15 +770,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // Find the last cached block\n         let (mut target, first_uncached) = if let Some(cached_index) = self.scopes.iter()\n-            .rposition(|scope| scope.cached_unwind.get(generator_drop).is_some()) {\n-            (self.scopes[cached_index].cached_unwind.get(generator_drop).unwrap(), cached_index + 1)\n+            .rposition(|scope| scope.cached_unwind.get().is_some()) {\n+            (self.scopes[cached_index].cached_unwind.get().unwrap(), cached_index + 1)\n         } else {\n             (self.resume_block(), 0)\n         };\n \n         for scope in self.scopes[first_uncached..].iter_mut() {\n             target = build_diverge_scope(&mut self.cfg, scope.region_scope_span,\n-                                         scope, target, generator_drop, self.is_generator);\n+                                         scope, target, self.is_generator);\n         }\n \n         target\n@@ -881,7 +858,6 @@ fn build_scope_drops<'tcx>(\n     mut block: BasicBlock,\n     last_unwind_to: BasicBlock,\n     arg_count: usize,\n-    generator_drop: bool,\n ) -> BlockAnd<()> {\n     debug!(\"build_scope_drops({:?} -> {:?}\", block, scope);\n \n@@ -902,7 +878,7 @@ fn build_scope_drops<'tcx>(\n \n     let mut unwind_blocks = scope.drops.iter().rev().filter_map(|drop_data| {\n         if let DropKind::Value { cached_block } = drop_data.kind {\n-            Some(cached_block.get(generator_drop).unwrap_or_else(|| {\n+            Some(cached_block.get().unwrap_or_else(|| {\n                 span_bug!(drop_data.span, \"cached block not present?\")\n             }))\n         } else {\n@@ -946,13 +922,12 @@ fn build_scope_drops<'tcx>(\n     block.unit()\n }\n \n-fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n-                             span: Span,\n-                             scope: &mut Scope<'tcx>,\n-                             mut target: BasicBlock,\n-                             generator_drop: bool,\n-                             is_generator: bool)\n-                             -> BasicBlock\n+fn build_diverge_scope(cfg: &mut CFG<'tcx>,\n+                       span: Span,\n+                       scope: &mut Scope<'tcx>,\n+                       mut target: BasicBlock,\n+                       is_generator: bool)\n+                       -> BasicBlock\n {\n     // Build up the drops in **reverse** order. The end result will\n     // look like:\n@@ -1004,7 +979,7 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n             }\n             DropKind::Storage => {}\n             DropKind::Value { ref mut cached_block } => {\n-                let cached_block = cached_block.ref_mut(generator_drop);\n+                let cached_block = cached_block.ref_mut();\n                 target = if let Some(cached_block) = *cached_block {\n                     storage_deads.clear();\n                     target_built_by_us = false;\n@@ -1027,7 +1002,7 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n         };\n     }\n     push_storage_deads(cfg, &mut target, &mut storage_deads, target_built_by_us, source_scope);\n-    *scope.cached_unwind.ref_mut(generator_drop) = Some(target);\n+    *scope.cached_unwind.ref_mut() = Some(target);\n \n     assert!(storage_deads.is_empty());\n     debug!(\"build_diverge_scope({:?}, {:?}) = {:?}\", scope, span, target);"}]}