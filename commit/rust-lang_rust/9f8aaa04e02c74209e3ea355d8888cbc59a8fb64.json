{"sha": "9f8aaa04e02c74209e3ea355d8888cbc59a8fb64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmOGFhYTA0ZTAyYzc0MjA5ZTNlYTM1NWQ4ODg4Y2JjNTlhOGZiNjQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-12-19T11:25:31Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: move the contents of ty::item_path to ty::print.", "tree": {"sha": "3be028f8146429f1d5772abf9fee70e873bf62e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3be028f8146429f1d5772abf9fee70e873bf62e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64", "html_url": "https://github.com/rust-lang/rust/commit/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0c75ff40def45bbf39bfed5766a1a8a56f2409f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0c75ff40def45bbf39bfed5766a1a8a56f2409f", "html_url": "https://github.com/rust-lang/rust/commit/e0c75ff40def45bbf39bfed5766a1a8a56f2409f"}], "stats": {"total": 1153, "additions": 573, "deletions": 580}, "files": [{"sha": "9f34f475eff6b15ebf7bf87746eb1eeeca212f54", "filename": "src/librustc/ty/item_path.rs", "status": "removed", "additions": 0, "deletions": 560, "changes": 560, "blob_url": "https://github.com/rust-lang/rust/blob/e0c75ff40def45bbf39bfed5766a1a8a56f2409f/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0c75ff40def45bbf39bfed5766a1a8a56f2409f/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=e0c75ff40def45bbf39bfed5766a1a8a56f2409f", "patch": "@@ -1,560 +0,0 @@\n-use crate::hir::def::Namespace;\n-use crate::hir::map::DefPathData;\n-use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n-use crate::ty::print::PrintCx;\n-use crate::ty::subst::{Subst, SubstsRef};\n-use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n-use syntax::ast;\n-use syntax::symbol::{keywords, Symbol};\n-\n-use std::cell::Cell;\n-\n-thread_local! {\n-    static FORCE_ABSOLUTE: Cell<bool> = Cell::new(false);\n-    static FORCE_IMPL_FILENAME_LINE: Cell<bool> = Cell::new(false);\n-    static SHOULD_PREFIX_WITH_CRATE: Cell<bool> = Cell::new(false);\n-}\n-\n-/// Enforces that def_path_str always returns an absolute path and\n-/// also enables \"type-based\" impl paths. This is used when building\n-/// symbols that contain types, where we want the crate name to be\n-/// part of the symbol.\n-pub fn with_forced_absolute_paths<F: FnOnce() -> R, R>(f: F) -> R {\n-    FORCE_ABSOLUTE.with(|force| {\n-        let old = force.get();\n-        force.set(true);\n-        let result = f();\n-        force.set(old);\n-        result\n-    })\n-}\n-\n-/// Force us to name impls with just the filename/line number. We\n-/// normally try to use types. But at some points, notably while printing\n-/// cycle errors, this can result in extra or suboptimal error output,\n-/// so this variable disables that check.\n-pub fn with_forced_impl_filename_line<F: FnOnce() -> R, R>(f: F) -> R {\n-    FORCE_IMPL_FILENAME_LINE.with(|force| {\n-        let old = force.get();\n-        force.set(true);\n-        let result = f();\n-        force.set(old);\n-        result\n-    })\n-}\n-\n-/// Adds the `crate::` prefix to paths where appropriate.\n-pub fn with_crate_prefix<F: FnOnce() -> R, R>(f: F) -> R {\n-    SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n-        let old = flag.get();\n-        flag.set(true);\n-        let result = f();\n-        flag.set(old);\n-        result\n-    })\n-}\n-\n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    // HACK(eddyb) get rid of `def_path_str` and/or pass `Namespace` explicitly always\n-    // (but also some things just print a `DefId` generally so maybe we need this?)\n-    fn guess_def_namespace(self, def_id: DefId) -> Namespace {\n-        match self.def_key(def_id).disambiguated_data.data {\n-            DefPathData::ValueNs(..) |\n-            DefPathData::EnumVariant(..) |\n-            DefPathData::Field(..) |\n-            DefPathData::AnonConst |\n-            DefPathData::ClosureExpr |\n-            DefPathData::StructCtor => Namespace::ValueNS,\n-\n-            DefPathData::MacroDef(..) => Namespace::MacroNS,\n-\n-            _ => Namespace::TypeNS,\n-        }\n-    }\n-\n-    /// Returns a string identifying this `DefId`. This string is\n-    /// suitable for user output. It is relative to the current crate\n-    /// root, unless with_forced_absolute_paths was used.\n-    pub fn def_path_str_with_substs_and_ns(\n-        self,\n-        def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n-        ns: Namespace,\n-    ) -> String {\n-        debug!(\"def_path_str: def_id={:?}, substs={:?}, ns={:?}\", def_id, substs, ns);\n-        if FORCE_ABSOLUTE.with(|force| force.get()) {\n-            PrintCx::new(self, AbsolutePathPrinter).print_def_path(def_id, substs, ns)\n-        } else {\n-            PrintCx::new(self, LocalPathPrinter).print_def_path(def_id, substs, ns)\n-        }\n-    }\n-\n-    /// Returns a string identifying this def-id. This string is\n-    /// suitable for user output. It is relative to the current crate\n-    /// root, unless with_forced_absolute_paths was used.\n-    pub fn def_path_str(self, def_id: DefId) -> String {\n-        let ns = self.guess_def_namespace(def_id);\n-        self.def_path_str_with_substs_and_ns(def_id, None, ns)\n-    }\n-\n-    /// Returns a string identifying this local node-id.\n-    pub fn node_path_str(self, id: ast::NodeId) -> String {\n-        self.def_path_str(self.hir().local_def_id(id))\n-    }\n-\n-    /// Returns a string identifying this def-id. This string is\n-    /// suitable for user output. It always begins with a crate identifier.\n-    pub fn absolute_def_path_str(self, def_id: DefId) -> String {\n-        debug!(\"absolute_def_path_str: def_id={:?}\", def_id);\n-        let ns = self.guess_def_namespace(def_id);\n-        PrintCx::new(self, AbsolutePathPrinter).print_def_path(def_id, None, ns)\n-    }\n-}\n-\n-impl<P: ItemPathPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n-    pub fn default_print_def_path(\n-        &mut self,\n-        def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n-        ns: Namespace,\n-    ) -> P::Path {\n-        debug!(\"default_print_def_path: def_id={:?}, substs={:?}, ns={:?}\", def_id, substs, ns);\n-        let key = self.tcx.def_key(def_id);\n-        debug!(\"default_print_def_path: key={:?}\", key);\n-        match key.disambiguated_data.data {\n-            DefPathData::CrateRoot => {\n-                assert!(key.parent.is_none());\n-                self.path_crate(def_id.krate)\n-            }\n-\n-            DefPathData::Impl => {\n-                self.print_impl_path(def_id, substs, ns)\n-            }\n-\n-            // Unclear if there is any value in distinguishing these.\n-            // Probably eventually (and maybe we would even want\n-            // finer-grained distinctions, e.g., between enum/struct).\n-            data @ DefPathData::Misc |\n-            data @ DefPathData::TypeNs(..) |\n-            data @ DefPathData::Trait(..) |\n-            data @ DefPathData::TraitAlias(..) |\n-            data @ DefPathData::AssocTypeInTrait(..) |\n-            data @ DefPathData::AssocTypeInImpl(..) |\n-            data @ DefPathData::AssocExistentialInImpl(..) |\n-            data @ DefPathData::ValueNs(..) |\n-            data @ DefPathData::Module(..) |\n-            data @ DefPathData::TypeParam(..) |\n-            data @ DefPathData::LifetimeParam(..) |\n-            data @ DefPathData::ConstParam(..) |\n-            data @ DefPathData::EnumVariant(..) |\n-            data @ DefPathData::Field(..) |\n-            data @ DefPathData::AnonConst |\n-            data @ DefPathData::MacroDef(..) |\n-            data @ DefPathData::ClosureExpr |\n-            data @ DefPathData::ImplTrait |\n-            data @ DefPathData::GlobalMetaData(..) => {\n-                let parent_did = self.tcx.parent(def_id).unwrap();\n-                let path = self.print_def_path(parent_did, None, ns);\n-                self.path_append(path, &data.as_interned_str().as_symbol().as_str())\n-            },\n-\n-            DefPathData::StructCtor => { // present `X` instead of `X::{{constructor}}`\n-                let parent_def_id = self.tcx.parent(def_id).unwrap();\n-                self.print_def_path(parent_def_id, substs, ns)\n-            }\n-        }\n-    }\n-\n-    fn default_print_impl_path(\n-        &mut self,\n-        impl_def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n-        ns: Namespace,\n-    ) -> P::Path {\n-        debug!(\"default_print_impl_path: impl_def_id={:?}\", impl_def_id);\n-        let parent_def_id = self.tcx.parent(impl_def_id).unwrap();\n-\n-        // Decide whether to print the parent path for the impl.\n-        // Logically, since impls are global, it's never needed, but\n-        // users may find it useful. Currently, we omit the parent if\n-        // the impl is either in the same module as the self-type or\n-        // as the trait.\n-        let mut self_ty = self.tcx.type_of(impl_def_id);\n-        if let Some(substs) = substs {\n-            self_ty = self_ty.subst(self.tcx, substs);\n-        }\n-        let in_self_mod = match characteristic_def_id_of_type(self_ty) {\n-            None => false,\n-            Some(ty_def_id) => self.tcx.parent(ty_def_id) == Some(parent_def_id),\n-        };\n-\n-        let mut impl_trait_ref = self.tcx.impl_trait_ref(impl_def_id);\n-        if let Some(substs) = substs {\n-            impl_trait_ref = impl_trait_ref.subst(self.tcx, substs);\n-        }\n-        let in_trait_mod = match impl_trait_ref {\n-            None => false,\n-            Some(trait_ref) => self.tcx.parent(trait_ref.def_id) == Some(parent_def_id),\n-        };\n-\n-        if !in_self_mod && !in_trait_mod {\n-            // If the impl is not co-located with either self-type or\n-            // trait-type, then fallback to a format that identifies\n-            // the module more clearly.\n-            let path = self.print_def_path(parent_def_id, None, ns);\n-            if let Some(trait_ref) = impl_trait_ref {\n-                return self.path_append(path, &format!(\"<impl {} for {}>\", trait_ref, self_ty));\n-            } else {\n-                return self.path_append(path, &format!(\"<impl {}>\", self_ty));\n-            }\n-        }\n-\n-        // Otherwise, try to give a good form that would be valid language\n-        // syntax. Preferably using associated item notation.\n-\n-        if let Some(trait_ref) = impl_trait_ref {\n-            // Trait impls.\n-            return self.path_impl(&format!(\"<{} as {}>\", self_ty, trait_ref));\n-        }\n-\n-        // Inherent impls. Try to print `Foo::bar` for an inherent\n-        // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n-        // anything other than a simple path.\n-        match self_ty.sty {\n-            ty::Adt(adt_def, substs) => {\n-                // FIXME(eddyb) this should recurse to build the path piecewise.\n-                // self.print_def_path(adt_def.did, Some(substs), ns)\n-                let mut s = String::new();\n-                crate::util::ppaux::parameterized(&mut s, adt_def.did, substs, ns).unwrap();\n-                self.path_impl(&s)\n-            }\n-\n-            ty::Foreign(did) => self.print_def_path(did, None, ns),\n-\n-            ty::Bool |\n-            ty::Char |\n-            ty::Int(_) |\n-            ty::Uint(_) |\n-            ty::Float(_) |\n-            ty::Str => {\n-                self.path_impl(&self_ty.to_string())\n-            }\n-\n-            _ => {\n-                self.path_impl(&format!(\"<{}>\", self_ty))\n-            }\n-        }\n-    }\n-}\n-\n-/// As a heuristic, when we see an impl, if we see that the\n-/// 'self type' is a type defined in the same module as the impl,\n-/// we can omit including the path to the impl itself. This\n-/// function tries to find a \"characteristic `DefId`\" for a\n-/// type. It's just a heuristic so it makes some questionable\n-/// decisions and we may want to adjust it later.\n-pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n-    match ty.sty {\n-        ty::Adt(adt_def, _) => Some(adt_def.did),\n-\n-        ty::Dynamic(data, ..) => data.principal_def_id(),\n-\n-        ty::Array(subty, _) |\n-        ty::Slice(subty) => characteristic_def_id_of_type(subty),\n-\n-        ty::RawPtr(mt) => characteristic_def_id_of_type(mt.ty),\n-\n-        ty::Ref(_, ty, _) => characteristic_def_id_of_type(ty),\n-\n-        ty::Tuple(ref tys) => tys.iter()\n-                                   .filter_map(|ty| characteristic_def_id_of_type(ty))\n-                                   .next(),\n-\n-        ty::FnDef(def_id, _) |\n-        ty::Closure(def_id, _) |\n-        ty::Generator(def_id, _, _) |\n-        ty::Foreign(def_id) => Some(def_id),\n-\n-        ty::Bool |\n-        ty::Char |\n-        ty::Int(_) |\n-        ty::Uint(_) |\n-        ty::Str |\n-        ty::FnPtr(_) |\n-        ty::Projection(_) |\n-        ty::Placeholder(..) |\n-        ty::UnnormalizedProjection(..) |\n-        ty::Param(_) |\n-        ty::Opaque(..) |\n-        ty::Infer(_) |\n-        ty::Bound(..) |\n-        ty::Error |\n-        ty::GeneratorWitness(..) |\n-        ty::Never |\n-        ty::Float(_) => None,\n-    }\n-}\n-\n-/// Unifying Trait for different kinds of item paths we might\n-/// construct. The basic interface is that components get appended.\n-pub trait ItemPathPrinter: Sized {\n-    type Path;\n-\n-    fn print_def_path(\n-        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n-        def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n-        ns: Namespace,\n-    ) -> Self::Path {\n-        self.default_print_def_path(def_id, substs, ns)\n-    }\n-    fn print_impl_path(\n-        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n-        impl_def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n-        ns: Namespace,\n-    ) -> Self::Path {\n-        self.default_print_impl_path(impl_def_id, substs, ns)\n-    }\n-\n-    fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path;\n-    fn path_impl(self: &mut PrintCx<'_, '_, '_, Self>, text: &str) -> Self::Path;\n-    fn path_append(\n-        self: &mut PrintCx<'_, '_, '_, Self>,\n-        path: Self::Path,\n-        text: &str,\n-    ) -> Self::Path;\n-}\n-\n-struct AbsolutePathPrinter;\n-\n-impl ItemPathPrinter for AbsolutePathPrinter {\n-    type Path = String;\n-\n-    fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {\n-        self.tcx.original_crate_name(cnum).to_string()\n-    }\n-    fn path_impl(self: &mut PrintCx<'_, '_, '_, Self>, text: &str) -> Self::Path {\n-        text.to_string()\n-    }\n-    fn path_append(\n-        self: &mut PrintCx<'_, '_, '_, Self>,\n-        mut path: Self::Path,\n-        text: &str,\n-    ) -> Self::Path {\n-        if !path.is_empty() {\n-            path.push_str(\"::\");\n-        }\n-        path.push_str(text);\n-        path\n-    }\n-}\n-\n-struct LocalPathPrinter;\n-\n-impl LocalPathPrinter {\n-    /// If possible, this returns a global path resolving to `def_id` that is visible\n-    /// from at least one local module and returns true. If the crate defining `def_id` is\n-    /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n-    fn try_print_visible_def_path(\n-        self: &mut PrintCx<'_, '_, '_, Self>,\n-        def_id: DefId,\n-        ns: Namespace,\n-    ) -> Option<<Self as ItemPathPrinter>::Path> {\n-        debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n-\n-        // If `def_id` is a direct or injected extern crate, return the\n-        // path to the crate followed by the path to the item within the crate.\n-        if def_id.index == CRATE_DEF_INDEX {\n-            let cnum = def_id.krate;\n-\n-            if cnum == LOCAL_CRATE {\n-                return Some(self.path_crate(cnum));\n-            }\n-\n-            // In local mode, when we encounter a crate other than\n-            // LOCAL_CRATE, execution proceeds in one of two ways:\n-            //\n-            // 1. for a direct dependency, where user added an\n-            //    `extern crate` manually, we put the `extern\n-            //    crate` as the parent. So you wind up with\n-            //    something relative to the current crate.\n-            // 2. for an extern inferred from a path or an indirect crate,\n-            //    where there is no explicit `extern crate`, we just prepend\n-            //    the crate name.\n-            match *self.tcx.extern_crate(def_id) {\n-                Some(ExternCrate {\n-                    src: ExternCrateSource::Extern(def_id),\n-                    direct: true,\n-                    span,\n-                    ..\n-                }) => {\n-                    debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n-                    let path = if !span.is_dummy() {\n-                        self.print_def_path(def_id, None, ns)\n-                    } else {\n-                        self.path_crate(cnum)\n-                    };\n-                    return Some(path);\n-                }\n-                None => {\n-                    return Some(self.path_crate(cnum));\n-                }\n-                _ => {},\n-            }\n-        }\n-\n-        if def_id.is_local() {\n-            return None;\n-        }\n-\n-        let visible_parent_map = self.tcx.visible_parent_map(LOCAL_CRATE);\n-\n-        let mut cur_def_key = self.tcx.def_key(def_id);\n-        debug!(\"try_print_visible_def_path: cur_def_key={:?}\", cur_def_key);\n-\n-        // For a UnitStruct or TupleStruct we want the name of its parent rather than <unnamed>.\n-        if let DefPathData::StructCtor = cur_def_key.disambiguated_data.data {\n-            let parent = DefId {\n-                krate: def_id.krate,\n-                index: cur_def_key.parent.expect(\"DefPathData::StructCtor missing a parent\"),\n-            };\n-\n-            cur_def_key = self.tcx.def_key(parent);\n-        }\n-\n-        let visible_parent = visible_parent_map.get(&def_id).cloned()?;\n-        let path = self.try_print_visible_def_path(visible_parent, ns)?;\n-        let actual_parent = self.tcx.parent(def_id);\n-\n-        let data = cur_def_key.disambiguated_data.data;\n-        debug!(\n-            \"try_print_visible_def_path: data={:?} visible_parent={:?} actual_parent={:?}\",\n-            data, visible_parent, actual_parent,\n-        );\n-\n-        let symbol = match data {\n-            // In order to output a path that could actually be imported (valid and visible),\n-            // we need to handle re-exports correctly.\n-            //\n-            // For example, take `std::os::unix::process::CommandExt`, this trait is actually\n-            // defined at `std::sys::unix::ext::process::CommandExt` (at time of writing).\n-            //\n-            // `std::os::unix` rexports the contents of `std::sys::unix::ext`. `std::sys` is\n-            // private so the \"true\" path to `CommandExt` isn't accessible.\n-            //\n-            // In this case, the `visible_parent_map` will look something like this:\n-            //\n-            // (child) -> (parent)\n-            // `std::sys::unix::ext::process::CommandExt` -> `std::sys::unix::ext::process`\n-            // `std::sys::unix::ext::process` -> `std::sys::unix::ext`\n-            // `std::sys::unix::ext` -> `std::os`\n-            //\n-            // This is correct, as the visible parent of `std::sys::unix::ext` is in fact\n-            // `std::os`.\n-            //\n-            // When printing the path to `CommandExt` and looking at the `cur_def_key` that\n-            // corresponds to `std::sys::unix::ext`, we would normally print `ext` and then go\n-            // to the parent - resulting in a mangled path like\n-            // `std::os::ext::process::CommandExt`.\n-            //\n-            // Instead, we must detect that there was a re-export and instead print `unix`\n-            // (which is the name `std::sys::unix::ext` was re-exported as in `std::os`). To\n-            // do this, we compare the parent of `std::sys::unix::ext` (`std::sys::unix`) with\n-            // the visible parent (`std::os`). If these do not match, then we iterate over\n-            // the children of the visible parent (as was done when computing\n-            // `visible_parent_map`), looking for the specific child we currently have and then\n-            // have access to the re-exported name.\n-            DefPathData::Module(actual_name) |\n-            DefPathData::TypeNs(actual_name) if Some(visible_parent) != actual_parent => {\n-                self.tcx.item_children(visible_parent)\n-                    .iter()\n-                    .find(|child| child.def.def_id() == def_id)\n-                    .map(|child| child.ident.as_str())\n-                    .unwrap_or_else(|| actual_name.as_str())\n-            }\n-            _ => {\n-                data.get_opt_name().map(|n| n.as_str()).unwrap_or_else(|| {\n-                    // Re-exported `extern crate` (#43189).\n-                    if let DefPathData::CrateRoot = data {\n-                        self.tcx.original_crate_name(def_id.krate).as_str()\n-                    } else {\n-                        Symbol::intern(\"<unnamed>\").as_str()\n-                    }\n-                })\n-            },\n-        };\n-        debug!(\"try_print_visible_def_path: symbol={:?}\", symbol);\n-        Some(self.path_append(path, &symbol))\n-    }\n-}\n-\n-impl ItemPathPrinter for LocalPathPrinter {\n-    type Path = String;\n-\n-    fn print_def_path(\n-        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n-        def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n-        ns: Namespace,\n-    ) -> Self::Path {\n-        self.try_print_visible_def_path(def_id, ns)\n-            .unwrap_or_else(|| self.default_print_def_path(def_id, substs, ns))\n-    }\n-    fn print_impl_path(\n-        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n-        impl_def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n-        ns: Namespace,\n-    ) -> Self::Path {\n-        // Always use types for non-local impls, where types are always\n-        // available, and filename/line-number is mostly uninteresting.\n-        let use_types = !impl_def_id.is_local() || {\n-            // Otherwise, use filename/line-number if forced.\n-            let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n-            !force_no_types\n-        };\n-\n-        if !use_types {\n-            // If no type info is available, fall back to\n-            // pretty printing some span information. This should\n-            // only occur very early in the compiler pipeline.\n-            // FIXME(eddyb) this should just be using `tcx.def_span(impl_def_id)`\n-            let parent_def_id = self.tcx.parent(impl_def_id).unwrap();\n-            let path = self.print_def_path(parent_def_id, None, ns);\n-            let span = self.tcx.def_span(impl_def_id);\n-            return self.path_append(path, &format!(\"<impl at {:?}>\", span));\n-        }\n-\n-        self.default_print_impl_path(impl_def_id, substs, ns)\n-    }\n-\n-    fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {\n-        if cnum == LOCAL_CRATE {\n-            if self.tcx.sess.rust_2018() {\n-                // We add the `crate::` keyword on Rust 2018, only when desired.\n-                if SHOULD_PREFIX_WITH_CRATE.with(|flag| flag.get()) {\n-                    return keywords::Crate.name().to_string();\n-                }\n-            }\n-            String::new()\n-        } else {\n-            self.tcx.crate_name(cnum).to_string()\n-        }\n-    }\n-    fn path_impl(self: &mut PrintCx<'_, '_, '_, Self>, text: &str) -> Self::Path {\n-        text.to_string()\n-    }\n-    fn path_append(\n-        self: &mut PrintCx<'_, '_, '_, Self>,\n-        mut path: Self::Path,\n-        text: &str,\n-    ) -> Self::Path {\n-        if !path.is_empty() {\n-            path.push_str(\"::\");\n-        }\n-        path.push_str(text);\n-        path\n-    }\n-}"}, {"sha": "882e2dc62b1c376b55a25c94002102d624da35e4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9f8aaa04e02c74209e3ea355d8888cbc59a8fb64", "patch": "@@ -95,7 +95,6 @@ mod erase_regions;\n pub mod fast_reject;\n pub mod fold;\n pub mod inhabitedness;\n-pub mod item_path;\n pub mod layout;\n pub mod _match;\n pub mod outlives;"}, {"sha": "053a7531cadd66c986888c1731b4bcf8ecaf4c94", "filename": "src/librustc/ty/print.rs", "status": "modified", "additions": 559, "deletions": 1, "changes": 560, "blob_url": "https://github.com/rust-lang/rust/blob/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/src%2Flibrustc%2Fty%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/src%2Flibrustc%2Fty%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint.rs?ref=9f8aaa04e02c74209e3ea355d8888cbc59a8fb64", "patch": "@@ -1,11 +1,64 @@\n-use crate::ty::{self, TyCtxt, TypeFoldable};\n+use crate::hir::def::Namespace;\n+use crate::hir::map::DefPathData;\n+use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use crate::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::subst::{Subst, SubstsRef};\n+use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n+use syntax::ast;\n+use syntax::symbol::{keywords, Symbol};\n \n use rustc_data_structures::fx::FxHashSet;\n use syntax::symbol::InternedString;\n \n+use std::cell::Cell;\n use std::fmt;\n use std::ops::Deref;\n \n+thread_local! {\n+    static FORCE_ABSOLUTE: Cell<bool> = Cell::new(false);\n+    static FORCE_IMPL_FILENAME_LINE: Cell<bool> = Cell::new(false);\n+    static SHOULD_PREFIX_WITH_CRATE: Cell<bool> = Cell::new(false);\n+}\n+\n+/// Enforces that def_path_str always returns an absolute path and\n+/// also enables \"type-based\" impl paths. This is used when building\n+/// symbols that contain types, where we want the crate name to be\n+/// part of the symbol.\n+pub fn with_forced_absolute_paths<F: FnOnce() -> R, R>(f: F) -> R {\n+    FORCE_ABSOLUTE.with(|force| {\n+        let old = force.get();\n+        force.set(true);\n+        let result = f();\n+        force.set(old);\n+        result\n+    })\n+}\n+\n+/// Force us to name impls with just the filename/line number. We\n+/// normally try to use types. But at some points, notably while printing\n+/// cycle errors, this can result in extra or suboptimal error output,\n+/// so this variable disables that check.\n+pub fn with_forced_impl_filename_line<F: FnOnce() -> R, R>(f: F) -> R {\n+    FORCE_IMPL_FILENAME_LINE.with(|force| {\n+        let old = force.get();\n+        force.set(true);\n+        let result = f();\n+        force.set(old);\n+        result\n+    })\n+}\n+\n+/// Adds the `crate::` prefix to paths where appropriate.\n+pub fn with_crate_prefix<F: FnOnce() -> R, R>(f: F) -> R {\n+    SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n+        let old = flag.get();\n+        flag.set(true);\n+        let result = f();\n+        flag.set(old);\n+        result\n+    })\n+}\n+\n // FIXME(eddyb) this module uses `pub(crate)` for things used only\n // from `ppaux` - when that is removed, they can be re-privatized.\n \n@@ -89,6 +142,511 @@ pub trait Print<'tcx, P> {\n     }\n }\n \n+pub trait Printer: Sized {\n+    type Path;\n+\n+    fn print_def_path(\n+        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        def_id: DefId,\n+        substs: Option<SubstsRef<'tcx>>,\n+        ns: Namespace,\n+    ) -> Self::Path {\n+        self.default_print_def_path(def_id, substs, ns)\n+    }\n+    fn print_impl_path(\n+        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        impl_def_id: DefId,\n+        substs: Option<SubstsRef<'tcx>>,\n+        ns: Namespace,\n+    ) -> Self::Path {\n+        self.default_print_impl_path(impl_def_id, substs, ns)\n+    }\n+\n+    fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path;\n+    fn path_impl(self: &mut PrintCx<'_, '_, '_, Self>, text: &str) -> Self::Path;\n+    fn path_append(\n+        self: &mut PrintCx<'_, '_, '_, Self>,\n+        path: Self::Path,\n+        text: &str,\n+    ) -> Self::Path;\n+}\n+\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    // HACK(eddyb) get rid of `def_path_str` and/or pass `Namespace` explicitly always\n+    // (but also some things just print a `DefId` generally so maybe we need this?)\n+    fn guess_def_namespace(self, def_id: DefId) -> Namespace {\n+        match self.def_key(def_id).disambiguated_data.data {\n+            DefPathData::ValueNs(..) |\n+            DefPathData::EnumVariant(..) |\n+            DefPathData::Field(..) |\n+            DefPathData::AnonConst |\n+            DefPathData::ClosureExpr |\n+            DefPathData::StructCtor => Namespace::ValueNS,\n+\n+            DefPathData::MacroDef(..) => Namespace::MacroNS,\n+\n+            _ => Namespace::TypeNS,\n+        }\n+    }\n+\n+    /// Returns a string identifying this `DefId`. This string is\n+    /// suitable for user output. It is relative to the current crate\n+    /// root, unless with_forced_absolute_paths was used.\n+    pub fn def_path_str_with_substs_and_ns(\n+        self,\n+        def_id: DefId,\n+        substs: Option<SubstsRef<'tcx>>,\n+        ns: Namespace,\n+    ) -> String {\n+        debug!(\"def_path_str: def_id={:?}, substs={:?}, ns={:?}\", def_id, substs, ns);\n+        if FORCE_ABSOLUTE.with(|force| force.get()) {\n+            PrintCx::new(self, AbsolutePathPrinter).print_def_path(def_id, substs, ns)\n+        } else {\n+            PrintCx::new(self, LocalPathPrinter).print_def_path(def_id, substs, ns)\n+        }\n+    }\n+\n+    /// Returns a string identifying this `DefId`. This string is\n+    /// suitable for user output. It is relative to the current crate\n+    /// root, unless with_forced_absolute_paths was used.\n+    pub fn def_path_str(self, def_id: DefId) -> String {\n+        let ns = self.guess_def_namespace(def_id);\n+        self.def_path_str_with_substs_and_ns(def_id, None, ns)\n+    }\n+\n+    /// Returns a string identifying this local node-id.\n+    // FIXME(eddyb) remove in favor of calling `def_path_str` directly.\n+    pub fn node_path_str(self, id: ast::NodeId) -> String {\n+        self.def_path_str(self.hir().local_def_id(id))\n+    }\n+\n+    /// Returns a string identifying this `DefId`. This string is\n+    /// suitable for user output. It always begins with a crate identifier.\n+    pub fn absolute_def_path_str(self, def_id: DefId) -> String {\n+        debug!(\"absolute_def_path_str: def_id={:?}\", def_id);\n+        let ns = self.guess_def_namespace(def_id);\n+        PrintCx::new(self, AbsolutePathPrinter).print_def_path(def_id, None, ns)\n+    }\n+}\n+\n+impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n+    pub fn default_print_def_path(\n+        &mut self,\n+        def_id: DefId,\n+        substs: Option<SubstsRef<'tcx>>,\n+        ns: Namespace,\n+    ) -> P::Path {\n+        debug!(\"default_print_def_path: def_id={:?}, substs={:?}, ns={:?}\", def_id, substs, ns);\n+        let key = self.tcx.def_key(def_id);\n+        debug!(\"default_print_def_path: key={:?}\", key);\n+        match key.disambiguated_data.data {\n+            DefPathData::CrateRoot => {\n+                assert!(key.parent.is_none());\n+                self.path_crate(def_id.krate)\n+            }\n+\n+            DefPathData::Impl => {\n+                self.print_impl_path(def_id, substs, ns)\n+            }\n+\n+            // Unclear if there is any value in distinguishing these.\n+            // Probably eventually (and maybe we would even want\n+            // finer-grained distinctions, e.g., between enum/struct).\n+            data @ DefPathData::Misc |\n+            data @ DefPathData::TypeNs(..) |\n+            data @ DefPathData::Trait(..) |\n+            data @ DefPathData::TraitAlias(..) |\n+            data @ DefPathData::AssocTypeInTrait(..) |\n+            data @ DefPathData::AssocTypeInImpl(..) |\n+            data @ DefPathData::AssocExistentialInImpl(..) |\n+            data @ DefPathData::ValueNs(..) |\n+            data @ DefPathData::Module(..) |\n+            data @ DefPathData::TypeParam(..) |\n+            data @ DefPathData::LifetimeParam(..) |\n+            data @ DefPathData::ConstParam(..) |\n+            data @ DefPathData::EnumVariant(..) |\n+            data @ DefPathData::Field(..) |\n+            data @ DefPathData::AnonConst |\n+            data @ DefPathData::MacroDef(..) |\n+            data @ DefPathData::ClosureExpr |\n+            data @ DefPathData::ImplTrait |\n+            data @ DefPathData::GlobalMetaData(..) => {\n+                let parent_did = self.tcx.parent(def_id).unwrap();\n+                let path = self.print_def_path(parent_did, None, ns);\n+                self.path_append(path, &data.as_interned_str().as_symbol().as_str())\n+            },\n+\n+            DefPathData::StructCtor => { // present `X` instead of `X::{{constructor}}`\n+                let parent_def_id = self.tcx.parent(def_id).unwrap();\n+                self.print_def_path(parent_def_id, substs, ns)\n+            }\n+        }\n+    }\n+\n+    fn default_print_impl_path(\n+        &mut self,\n+        impl_def_id: DefId,\n+        substs: Option<SubstsRef<'tcx>>,\n+        ns: Namespace,\n+    ) -> P::Path {\n+        debug!(\"default_print_impl_path: impl_def_id={:?}\", impl_def_id);\n+        let parent_def_id = self.tcx.parent(impl_def_id).unwrap();\n+\n+        // Decide whether to print the parent path for the impl.\n+        // Logically, since impls are global, it's never needed, but\n+        // users may find it useful. Currently, we omit the parent if\n+        // the impl is either in the same module as the self-type or\n+        // as the trait.\n+        let mut self_ty = self.tcx.type_of(impl_def_id);\n+        if let Some(substs) = substs {\n+            self_ty = self_ty.subst(self.tcx, substs);\n+        }\n+        let in_self_mod = match characteristic_def_id_of_type(self_ty) {\n+            None => false,\n+            Some(ty_def_id) => self.tcx.parent(ty_def_id) == Some(parent_def_id),\n+        };\n+\n+        let mut impl_trait_ref = self.tcx.impl_trait_ref(impl_def_id);\n+        if let Some(substs) = substs {\n+            impl_trait_ref = impl_trait_ref.subst(self.tcx, substs);\n+        }\n+        let in_trait_mod = match impl_trait_ref {\n+            None => false,\n+            Some(trait_ref) => self.tcx.parent(trait_ref.def_id) == Some(parent_def_id),\n+        };\n+\n+        if !in_self_mod && !in_trait_mod {\n+            // If the impl is not co-located with either self-type or\n+            // trait-type, then fallback to a format that identifies\n+            // the module more clearly.\n+            let path = self.print_def_path(parent_def_id, None, ns);\n+            if let Some(trait_ref) = impl_trait_ref {\n+                return self.path_append(path, &format!(\"<impl {} for {}>\", trait_ref, self_ty));\n+            } else {\n+                return self.path_append(path, &format!(\"<impl {}>\", self_ty));\n+            }\n+        }\n+\n+        // Otherwise, try to give a good form that would be valid language\n+        // syntax. Preferably using associated item notation.\n+\n+        if let Some(trait_ref) = impl_trait_ref {\n+            // Trait impls.\n+            return self.path_impl(&format!(\"<{} as {}>\", self_ty, trait_ref));\n+        }\n+\n+        // Inherent impls. Try to print `Foo::bar` for an inherent\n+        // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n+        // anything other than a simple path.\n+        match self_ty.sty {\n+            ty::Adt(adt_def, substs) => {\n+                // FIXME(eddyb) this should recurse to build the path piecewise.\n+                // self.print_def_path(adt_def.did, Some(substs), ns)\n+                let mut s = String::new();\n+                crate::util::ppaux::parameterized(&mut s, adt_def.did, substs, ns).unwrap();\n+                self.path_impl(&s)\n+            }\n+\n+            ty::Foreign(did) => self.print_def_path(did, None, ns),\n+\n+            ty::Bool |\n+            ty::Char |\n+            ty::Int(_) |\n+            ty::Uint(_) |\n+            ty::Float(_) |\n+            ty::Str => {\n+                self.path_impl(&self_ty.to_string())\n+            }\n+\n+            _ => {\n+                self.path_impl(&format!(\"<{}>\", self_ty))\n+            }\n+        }\n+    }\n+}\n+\n+/// As a heuristic, when we see an impl, if we see that the\n+/// 'self type' is a type defined in the same module as the impl,\n+/// we can omit including the path to the impl itself. This\n+/// function tries to find a \"characteristic `DefId`\" for a\n+/// type. It's just a heuristic so it makes some questionable\n+/// decisions and we may want to adjust it later.\n+pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n+    match ty.sty {\n+        ty::Adt(adt_def, _) => Some(adt_def.did),\n+\n+        ty::Dynamic(data, ..) => data.principal_def_id(),\n+\n+        ty::Array(subty, _) |\n+        ty::Slice(subty) => characteristic_def_id_of_type(subty),\n+\n+        ty::RawPtr(mt) => characteristic_def_id_of_type(mt.ty),\n+\n+        ty::Ref(_, ty, _) => characteristic_def_id_of_type(ty),\n+\n+        ty::Tuple(ref tys) => tys.iter()\n+                                   .filter_map(|ty| characteristic_def_id_of_type(ty))\n+                                   .next(),\n+\n+        ty::FnDef(def_id, _) |\n+        ty::Closure(def_id, _) |\n+        ty::Generator(def_id, _, _) |\n+        ty::Foreign(def_id) => Some(def_id),\n+\n+        ty::Bool |\n+        ty::Char |\n+        ty::Int(_) |\n+        ty::Uint(_) |\n+        ty::Str |\n+        ty::FnPtr(_) |\n+        ty::Projection(_) |\n+        ty::Placeholder(..) |\n+        ty::UnnormalizedProjection(..) |\n+        ty::Param(_) |\n+        ty::Opaque(..) |\n+        ty::Infer(_) |\n+        ty::Bound(..) |\n+        ty::Error |\n+        ty::GeneratorWitness(..) |\n+        ty::Never |\n+        ty::Float(_) => None,\n+    }\n+}\n+\n+// FIXME(eddyb) remove, alongside `FORCE_ABSOLUTE` and `absolute_def_path_str`.\n+struct AbsolutePathPrinter;\n+\n+impl Printer for AbsolutePathPrinter {\n+    type Path = String;\n+\n+    fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {\n+        self.tcx.original_crate_name(cnum).to_string()\n+    }\n+    fn path_impl(self: &mut PrintCx<'_, '_, '_, Self>, text: &str) -> Self::Path {\n+        text.to_string()\n+    }\n+    fn path_append(\n+        self: &mut PrintCx<'_, '_, '_, Self>,\n+        mut path: Self::Path,\n+        text: &str,\n+    ) -> Self::Path {\n+        if !path.is_empty() {\n+            path.push_str(\"::\");\n+        }\n+        path.push_str(text);\n+        path\n+    }\n+}\n+\n pub struct FmtPrinter<F: fmt::Write> {\n     pub fmt: F,\n }\n+\n+// FIXME(eddyb) integrate into `FmtPrinter`.\n+struct LocalPathPrinter;\n+\n+impl LocalPathPrinter {\n+    /// If possible, this returns a global path resolving to `def_id` that is visible\n+    /// from at least one local module and returns true. If the crate defining `def_id` is\n+    /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n+    fn try_print_visible_def_path(\n+        self: &mut PrintCx<'_, '_, '_, Self>,\n+        def_id: DefId,\n+        ns: Namespace,\n+    ) -> Option<<Self as Printer>::Path> {\n+        debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n+\n+        // If `def_id` is a direct or injected extern crate, return the\n+        // path to the crate followed by the path to the item within the crate.\n+        if def_id.index == CRATE_DEF_INDEX {\n+            let cnum = def_id.krate;\n+\n+            if cnum == LOCAL_CRATE {\n+                return Some(self.path_crate(cnum));\n+            }\n+\n+            // In local mode, when we encounter a crate other than\n+            // LOCAL_CRATE, execution proceeds in one of two ways:\n+            //\n+            // 1. for a direct dependency, where user added an\n+            //    `extern crate` manually, we put the `extern\n+            //    crate` as the parent. So you wind up with\n+            //    something relative to the current crate.\n+            // 2. for an extern inferred from a path or an indirect crate,\n+            //    where there is no explicit `extern crate`, we just prepend\n+            //    the crate name.\n+            match *self.tcx.extern_crate(def_id) {\n+                Some(ExternCrate {\n+                    src: ExternCrateSource::Extern(def_id),\n+                    direct: true,\n+                    span,\n+                    ..\n+                }) => {\n+                    debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n+                    let path = if !span.is_dummy() {\n+                        self.print_def_path(def_id, None, ns)\n+                    } else {\n+                        self.path_crate(cnum)\n+                    };\n+                    return Some(path);\n+                }\n+                None => {\n+                    return Some(self.path_crate(cnum));\n+                }\n+                _ => {},\n+            }\n+        }\n+\n+        if def_id.is_local() {\n+            return None;\n+        }\n+\n+        let visible_parent_map = self.tcx.visible_parent_map(LOCAL_CRATE);\n+\n+        let mut cur_def_key = self.tcx.def_key(def_id);\n+        debug!(\"try_print_visible_def_path: cur_def_key={:?}\", cur_def_key);\n+\n+        // For a UnitStruct or TupleStruct we want the name of its parent rather than <unnamed>.\n+        if let DefPathData::StructCtor = cur_def_key.disambiguated_data.data {\n+            let parent = DefId {\n+                krate: def_id.krate,\n+                index: cur_def_key.parent.expect(\"DefPathData::StructCtor missing a parent\"),\n+            };\n+\n+            cur_def_key = self.tcx.def_key(parent);\n+        }\n+\n+        let visible_parent = visible_parent_map.get(&def_id).cloned()?;\n+        let path = self.try_print_visible_def_path(visible_parent, ns)?;\n+        let actual_parent = self.tcx.parent(def_id);\n+\n+        let data = cur_def_key.disambiguated_data.data;\n+        debug!(\n+            \"try_print_visible_def_path: data={:?} visible_parent={:?} actual_parent={:?}\",\n+            data, visible_parent, actual_parent,\n+        );\n+\n+        let symbol = match data {\n+            // In order to output a path that could actually be imported (valid and visible),\n+            // we need to handle re-exports correctly.\n+            //\n+            // For example, take `std::os::unix::process::CommandExt`, this trait is actually\n+            // defined at `std::sys::unix::ext::process::CommandExt` (at time of writing).\n+            //\n+            // `std::os::unix` rexports the contents of `std::sys::unix::ext`. `std::sys` is\n+            // private so the \"true\" path to `CommandExt` isn't accessible.\n+            //\n+            // In this case, the `visible_parent_map` will look something like this:\n+            //\n+            // (child) -> (parent)\n+            // `std::sys::unix::ext::process::CommandExt` -> `std::sys::unix::ext::process`\n+            // `std::sys::unix::ext::process` -> `std::sys::unix::ext`\n+            // `std::sys::unix::ext` -> `std::os`\n+            //\n+            // This is correct, as the visible parent of `std::sys::unix::ext` is in fact\n+            // `std::os`.\n+            //\n+            // When printing the path to `CommandExt` and looking at the `cur_def_key` that\n+            // corresponds to `std::sys::unix::ext`, we would normally print `ext` and then go\n+            // to the parent - resulting in a mangled path like\n+            // `std::os::ext::process::CommandExt`.\n+            //\n+            // Instead, we must detect that there was a re-export and instead print `unix`\n+            // (which is the name `std::sys::unix::ext` was re-exported as in `std::os`). To\n+            // do this, we compare the parent of `std::sys::unix::ext` (`std::sys::unix`) with\n+            // the visible parent (`std::os`). If these do not match, then we iterate over\n+            // the children of the visible parent (as was done when computing\n+            // `visible_parent_map`), looking for the specific child we currently have and then\n+            // have access to the re-exported name.\n+            DefPathData::Module(actual_name) |\n+            DefPathData::TypeNs(actual_name) if Some(visible_parent) != actual_parent => {\n+                self.tcx.item_children(visible_parent)\n+                    .iter()\n+                    .find(|child| child.def.def_id() == def_id)\n+                    .map(|child| child.ident.as_str())\n+                    .unwrap_or_else(|| actual_name.as_str())\n+            }\n+            _ => {\n+                data.get_opt_name().map(|n| n.as_str()).unwrap_or_else(|| {\n+                    // Re-exported `extern crate` (#43189).\n+                    if let DefPathData::CrateRoot = data {\n+                        self.tcx.original_crate_name(def_id.krate).as_str()\n+                    } else {\n+                        Symbol::intern(\"<unnamed>\").as_str()\n+                    }\n+                })\n+            },\n+        };\n+        debug!(\"try_print_visible_def_path: symbol={:?}\", symbol);\n+        Some(self.path_append(path, &symbol))\n+    }\n+}\n+\n+impl Printer for LocalPathPrinter {\n+    type Path = String;\n+\n+    fn print_def_path(\n+        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        def_id: DefId,\n+        substs: Option<SubstsRef<'tcx>>,\n+        ns: Namespace,\n+    ) -> Self::Path {\n+        self.try_print_visible_def_path(def_id, ns)\n+            .unwrap_or_else(|| self.default_print_def_path(def_id, substs, ns))\n+    }\n+    fn print_impl_path(\n+        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        impl_def_id: DefId,\n+        substs: Option<SubstsRef<'tcx>>,\n+        ns: Namespace,\n+    ) -> Self::Path {\n+        // Always use types for non-local impls, where types are always\n+        // available, and filename/line-number is mostly uninteresting.\n+        let use_types = !impl_def_id.is_local() || {\n+            // Otherwise, use filename/line-number if forced.\n+            let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n+            !force_no_types\n+        };\n+\n+        if !use_types {\n+            // If no type info is available, fall back to\n+            // pretty printing some span information. This should\n+            // only occur very early in the compiler pipeline.\n+            // FIXME(eddyb) this should just be using `tcx.def_span(impl_def_id)`\n+            let parent_def_id = self.tcx.parent(impl_def_id).unwrap();\n+            let path = self.print_def_path(parent_def_id, None, ns);\n+            let span = self.tcx.def_span(impl_def_id);\n+            return self.path_append(path, &format!(\"<impl at {:?}>\", span));\n+        }\n+\n+        self.default_print_impl_path(impl_def_id, substs, ns)\n+    }\n+\n+    fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {\n+        if cnum == LOCAL_CRATE {\n+            if self.tcx.sess.rust_2018() {\n+                // We add the `crate::` keyword on Rust 2018, only when desired.\n+                if SHOULD_PREFIX_WITH_CRATE.with(|flag| flag.get()) {\n+                    return keywords::Crate.name().to_string();\n+                }\n+            }\n+            String::new()\n+        } else {\n+            self.tcx.crate_name(cnum).to_string()\n+        }\n+    }\n+    fn path_impl(self: &mut PrintCx<'_, '_, '_, Self>, text: &str) -> Self::Path {\n+        text.to_string()\n+    }\n+    fn path_append(\n+        self: &mut PrintCx<'_, '_, '_, Self>,\n+        mut path: Self::Path,\n+        text: &str,\n+    ) -> Self::Path {\n+        if !path.is_empty() {\n+            path.push_str(\"::\");\n+        }\n+        path.push_str(text);\n+        path\n+    }\n+}"}, {"sha": "cff99f23d0e95176d5765cadb6f847f3419d47d0", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=9f8aaa04e02c74209e3ea355d8888cbc59a8fb64", "patch": "@@ -4,11 +4,10 @@\n \n use crate::dep_graph::{DepNodeIndex, DepNode, DepKind, SerializedDepNodeIndex};\n use crate::ty::tls;\n-use crate::ty::{TyCtxt};\n+use crate::ty::{self, TyCtxt};\n use crate::ty::query::Query;\n use crate::ty::query::config::{QueryConfig, QueryDescription};\n use crate::ty::query::job::{QueryJob, QueryResult, QueryInfo};\n-use crate::ty::item_path;\n \n use crate::util::common::{profq_msg, ProfileQueriesMsg, QueryMsg};\n \n@@ -299,7 +298,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // sometimes cycles itself, leading to extra cycle errors.\n         // (And cycle errors around impls tend to occur during the\n         // collect/coherence phases anyhow.)\n-        item_path::with_forced_impl_filename_line(|| {\n+        ty::print::with_forced_impl_filename_line(|| {\n             let span = fix_span(stack[1 % stack.len()].span, &stack[0].query);\n             let mut err = struct_span_err!(self.sess,\n                                            span,"}, {"sha": "b417091704d72091c6bf0178c488a85619990326", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=9f8aaa04e02c74209e3ea355d8888cbc59a8fb64", "patch": "@@ -93,8 +93,7 @@ use rustc::hir::Node;\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::ich::NodeIdHashingMode;\n-use rustc::ty::item_path::{self, ItemPathPrinter};\n-use rustc::ty::print::PrintCx;\n+use rustc::ty::print::{PrintCx, Printer};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -225,7 +224,7 @@ fn get_symbol_hash<'a, 'tcx>(\n }\n \n fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n-    item_path::with_forced_absolute_paths(|| {\n+    ty::print::with_forced_absolute_paths(|| {\n         PrintCx::new(tcx, SymbolPathPrinter)\n             .print_def_path(def_id, None, Namespace::ValueNS)\n             .into_interned()\n@@ -400,7 +399,7 @@ impl SymbolPath {\n \n struct SymbolPathPrinter;\n \n-impl ItemPathPrinter for SymbolPathPrinter {\n+impl Printer for SymbolPathPrinter {\n     type Path = SymbolPath;\n \n     fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {"}, {"sha": "4a2c05b2013286f0b263b0c7781272efd9d7e8e6", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=9f8aaa04e02c74209e3ea355d8888cbc59a8fb64", "patch": "@@ -104,7 +104,7 @@ use rustc::hir::map::DefPathData;\n use rustc::mir::mono::{Linkage, Visibility, CodegenUnitNameBuilder};\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::ty::{self, TyCtxt, InstanceDef};\n-use rustc::ty::item_path::characteristic_def_id_of_type;\n+use rustc::ty::print::characteristic_def_id_of_type;\n use rustc::ty::query::Providers;\n use rustc::util::common::time;\n use rustc::util::nodemap::{DefIdSet, FxHashMap, FxHashSet};"}, {"sha": "cbdd50cf4052af71d62f40f2bb97e77b22767836", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=9f8aaa04e02c74209e3ea355d8888cbc59a8fb64", "patch": "@@ -29,7 +29,7 @@ use rustc::mir::visit::{\n };\n use rustc::mir::Local;\n use rustc::mir::*;\n-use rustc::ty::{item_path, TyCtxt};\n+use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::work_queue::WorkQueue;\n@@ -265,7 +265,7 @@ pub fn dump_mir<'a, 'tcx>(\n     if !dump_enabled(tcx, pass_name, source) {\n         return;\n     }\n-    let node_path = item_path::with_forced_impl_filename_line(|| {\n+    let node_path = ty::print::with_forced_impl_filename_line(|| {\n         // see notes on #41697 below\n         tcx.def_path_str(source.def_id())\n     });"}, {"sha": "a76d26a6831c29ff1ede0cc2547b8affc26a1276", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=9f8aaa04e02c74209e3ea355d8888cbc59a8fb64", "patch": "@@ -2,7 +2,6 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::mir::*;\n use rustc::mir::visit::Visitor;\n use rustc::ty::{self, TyCtxt};\n-use rustc::ty::item_path;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use std::fmt::Display;\n@@ -78,7 +77,7 @@ pub fn dump_mir<'a, 'gcx, 'tcx, F>(\n         return;\n     }\n \n-    let node_path = item_path::with_forced_impl_filename_line(|| {\n+    let node_path = ty::print::with_forced_impl_filename_line(|| {\n         // see notes on #41697 below\n         tcx.def_path_str(source.def_id())\n     });\n@@ -103,7 +102,7 @@ pub fn dump_enabled<'a, 'gcx, 'tcx>(\n         None => return false,\n         Some(ref filters) => filters,\n     };\n-    let node_path = item_path::with_forced_impl_filename_line(|| {\n+    let node_path = ty::print::with_forced_impl_filename_line(|| {\n         // see notes on #41697 below\n         tcx.def_path_str(source.def_id())\n     });\n@@ -612,7 +611,7 @@ fn write_mir_sig(\n         _ => bug!(\"Unexpected def description {:?}\", descr),\n     }\n \n-    item_path::with_forced_impl_filename_line(|| {\n+    ty::print::with_forced_impl_filename_line(|| {\n         // see notes on #41697 elsewhere\n         write!(w, \" {}\", tcx.def_path_str(src.def_id()))\n     })?;"}, {"sha": "b4a1a2d76c262554fbf400e8724b58ad7f239810", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=9f8aaa04e02c74209e3ea355d8888cbc59a8fb64", "patch": "@@ -15,7 +15,7 @@ use rustc::hir::print;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::Obligation;\n use rustc::ty::{self, Adt, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TypeFoldable};\n-use rustc::ty::item_path::with_crate_prefix;\n+use rustc::ty::print::with_crate_prefix;\n use syntax_pos::{Span, FileName};\n use syntax::ast;\n use syntax::util::lev_distance::find_best_match_for_name;"}, {"sha": "6cf8a9896d513cf4c0102831ef5b0252e0de3004", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8aaa04e02c74209e3ea355d8888cbc59a8fb64/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9f8aaa04e02c74209e3ea355d8888cbc59a8fb64", "patch": "@@ -4225,12 +4225,11 @@ pub fn path_to_def(tcx: &TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n \n pub fn get_path_for_type<F>(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, def_ctor: F) -> hir::Path\n where F: Fn(DefId) -> Def {\n-    use rustc::ty::item_path::ItemPathPrinter;\n-    use rustc::ty::print::PrintCx;\n+    use rustc::ty::print::{PrintCx, Printer};\n \n     struct AbsolutePathPrinter;\n \n-    impl ItemPathPrinter for AbsolutePathPrinter {\n+    impl Printer for AbsolutePathPrinter {\n         type Path = Vec<String>;\n \n         fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {"}]}