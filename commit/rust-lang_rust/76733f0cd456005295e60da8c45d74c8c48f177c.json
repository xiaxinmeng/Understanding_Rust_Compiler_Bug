{"sha": "76733f0cd456005295e60da8c45d74c8c48f177c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NzMzZjBjZDQ1NjAwNTI5NWU2MGRhOGM0NWQ3NGM4YzQ4ZjE3N2M=", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-29T11:52:55Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-29T12:08:30Z"}, "message": "Add unwrap block assist #4156\n\nSigned-off-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>", "tree": {"sha": "c5fb8ad0429bb9ad4c749612225f776844b4d127", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5fb8ad0429bb9ad4c749612225f776844b4d127"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76733f0cd456005295e60da8c45d74c8c48f177c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76733f0cd456005295e60da8c45d74c8c48f177c", "html_url": "https://github.com/rust-lang/rust/commit/76733f0cd456005295e60da8c45d74c8c48f177c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76733f0cd456005295e60da8c45d74c8c48f177c/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3c7edb9bc3f2860686383dc1498c988a56859e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3c7edb9bc3f2860686383dc1498c988a56859e8", "html_url": "https://github.com/rust-lang/rust/commit/c3c7edb9bc3f2860686383dc1498c988a56859e8"}], "stats": {"total": 476, "additions": 475, "deletions": 1}, "files": [{"sha": "6fe95da6abefde24c2d51a68f9e40a36008bcda5", "filename": "crates/ra_assists/src/doc_tests/generated.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/76733f0cd456005295e60da8c45d74c8c48f177c/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76733f0cd456005295e60da8c45d74c8c48f177c/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs?ref=76733f0cd456005295e60da8c45d74c8c48f177c", "patch": "@@ -726,3 +726,22 @@ use std::{collections::HashMap};\n \"#####,\n     )\n }\n+\n+#[test]\n+fn doctest_unwrap_block() {\n+    check(\n+        \"unwrap_block\",\n+        r#####\"\n+fn foo() {\n+    if true {<|>\n+        println!(\"foo\");\n+    }\n+}\n+\"#####,\n+        r#####\"\n+fn foo() {\n+    <|>println!(\"foo\");\n+}\n+\"#####,\n+    )\n+}"}, {"sha": "b98601f1c0815ea4b7ad7cedd579d023014e05fb", "filename": "crates/ra_assists/src/handlers/unwrap_block.rs", "status": "added", "additions": 435, "deletions": 0, "changes": 435, "blob_url": "https://github.com/rust-lang/rust/blob/76733f0cd456005295e60da8c45d74c8c48f177c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76733f0cd456005295e60da8c45d74c8c48f177c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs?ref=76733f0cd456005295e60da8c45d74c8c48f177c", "patch": "@@ -0,0 +1,435 @@\n+use crate::{Assist, AssistCtx, AssistId};\n+\n+use ast::LoopBodyOwner;\n+use ra_fmt::unwrap_trivial_block;\n+use ra_syntax::{ast, AstNode};\n+\n+// Assist: unwrap_block\n+//\n+// Removes the `mut` keyword.\n+//\n+// ```\n+// fn foo() {\n+//     if true {<|>\n+//         println!(\"foo\");\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// fn foo() {\n+//     <|>println!(\"foo\");\n+// }\n+// ```\n+pub(crate) fn unwrap_block(ctx: AssistCtx) -> Option<Assist> {\n+    let res = if let Some(if_expr) = ctx.find_node_at_offset::<ast::IfExpr>() {\n+        // if expression\n+        let mut expr_to_unwrap: Option<ast::Expr> = None;\n+        for block_expr in if_expr.blocks() {\n+            if let Some(block) = block_expr.block() {\n+                let cursor_in_range =\n+                    block.l_curly_token()?.text_range().contains_range(ctx.frange.range);\n+\n+                if cursor_in_range {\n+                    let exprto = unwrap_trivial_block(block_expr);\n+                    expr_to_unwrap = Some(exprto);\n+                    break;\n+                }\n+            }\n+        }\n+        let expr_to_unwrap = expr_to_unwrap?;\n+        // Find if we are in a else if block\n+        let ancestor = ctx\n+            .sema\n+            .ancestors_with_macros(if_expr.syntax().clone())\n+            .skip(1)\n+            .find_map(ast::IfExpr::cast);\n+\n+        if let Some(ancestor) = ancestor {\n+            Some((ast::Expr::IfExpr(ancestor), expr_to_unwrap))\n+        } else {\n+            Some((ast::Expr::IfExpr(if_expr), expr_to_unwrap))\n+        }\n+    } else if let Some(for_expr) = ctx.find_node_at_offset::<ast::ForExpr>() {\n+        // for expression\n+        let block_expr = for_expr.loop_body()?;\n+        let block = block_expr.block()?;\n+        let cursor_in_range = block.l_curly_token()?.text_range().contains_range(ctx.frange.range);\n+\n+        if cursor_in_range {\n+            let expr_to_unwrap = unwrap_trivial_block(block_expr);\n+\n+            Some((ast::Expr::ForExpr(for_expr), expr_to_unwrap))\n+        } else {\n+            None\n+        }\n+    } else if let Some(while_expr) = ctx.find_node_at_offset::<ast::WhileExpr>() {\n+        // while expression\n+        let block_expr = while_expr.loop_body()?;\n+        let block = block_expr.block()?;\n+        let cursor_in_range = block.l_curly_token()?.text_range().contains_range(ctx.frange.range);\n+\n+        if cursor_in_range {\n+            let expr_to_unwrap = unwrap_trivial_block(block_expr);\n+\n+            Some((ast::Expr::WhileExpr(while_expr), expr_to_unwrap))\n+        } else {\n+            None\n+        }\n+    } else if let Some(loop_expr) = ctx.find_node_at_offset::<ast::LoopExpr>() {\n+        // loop expression\n+        let block_expr = loop_expr.loop_body()?;\n+        let block = block_expr.block()?;\n+        let cursor_in_range = block.l_curly_token()?.text_range().contains_range(ctx.frange.range);\n+\n+        if cursor_in_range {\n+            let expr_to_unwrap = unwrap_trivial_block(block_expr);\n+\n+            Some((ast::Expr::LoopExpr(loop_expr), expr_to_unwrap))\n+        } else {\n+            None\n+        }\n+    } else {\n+        None\n+    };\n+\n+    let (expr, expr_to_unwrap) = res?;\n+    ctx.add_assist(AssistId(\"unwrap_block\"), \"Unwrap block\", |edit| {\n+        edit.set_cursor(expr.syntax().text_range().start());\n+        edit.target(expr_to_unwrap.syntax().text_range());\n+\n+        let pat_start: &[_] = &[' ', '{', '\\n'];\n+        let expr_to_unwrap = expr_to_unwrap.to_string();\n+        let expr_string = expr_to_unwrap.trim_start_matches(pat_start);\n+        let mut expr_string_lines: Vec<&str> = expr_string.lines().collect();\n+        expr_string_lines.pop(); // Delete last line\n+\n+        let expr_string = expr_string_lines\n+            .into_iter()\n+            .map(|line| line.replacen(\"    \", \"\", 1)) // Delete indentation\n+            .collect::<Vec<String>>()\n+            .join(\"\\n\");\n+\n+        edit.replace(expr.syntax().text_range(), expr_string);\n+    })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::helpers::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn simple_if() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                bar();\n+                if true {<|>\n+                    foo();\n+\n+                    //comment\n+                    bar();\n+                } else {\n+                    println!(\"bar\");\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                bar();\n+                <|>foo();\n+\n+                //comment\n+                bar();\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_if_else() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                bar();\n+                if true {\n+                    foo();\n+\n+                    //comment\n+                    bar();\n+                } else {<|>\n+                    println!(\"bar\");\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                bar();\n+                <|>println!(\"bar\");\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_if_else_if() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                //bar();\n+                if true {\n+                    println!(\"true\");\n+\n+                    //comment\n+                    //bar();\n+                } else if false {<|>\n+                    println!(\"bar\");\n+                } else {\n+                    println!(\"foo\");\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                //bar();\n+                <|>println!(\"bar\");\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_if_bad_cursor_position() {\n+        check_assist_not_applicable(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                bar();<|>\n+                if true {\n+                    foo();\n+\n+                    //comment\n+                    bar();\n+                } else {\n+                    println!(\"bar\");\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn issue_example_with_if() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+            fn complete_enum_variants(acc: &mut Completions, ctx: &CompletionContext, ty: &Type) {\n+                if let Some(ty) = &ctx.expected_type {<|>\n+                    if let Some(Adt::Enum(enum_data)) = ty.as_adt() {\n+                        let variants = enum_data.variants(ctx.db);\n+\n+                        let module = if let Some(module) = ctx.scope().module() {\n+                            // Compute path from the completion site if available.\n+                            module\n+                        } else {\n+                            // Otherwise fall back to the enum's definition site.\n+                            enum_data.module(ctx.db)\n+                        };\n+\n+                        for variant in variants {\n+                            if let Some(path) = module.find_use_path(ctx.db, ModuleDef::from(variant)) {\n+                                // Variants with trivial paths are already added by the existing completion logic,\n+                                // so we should avoid adding these twice\n+                                if path.segments.len() > 1 {\n+                                    acc.add_enum_variant(ctx, variant, Some(path.to_string()));\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn complete_enum_variants(acc: &mut Completions, ctx: &CompletionContext, ty: &Type) {\n+                <|>if let Some(Adt::Enum(enum_data)) = ty.as_adt() {\n+                    let variants = enum_data.variants(ctx.db);\n+\n+                    let module = if let Some(module) = ctx.scope().module() {\n+                        // Compute path from the completion site if available.\n+                        module\n+                    } else {\n+                        // Otherwise fall back to the enum's definition site.\n+                        enum_data.module(ctx.db)\n+                    };\n+\n+                    for variant in variants {\n+                        if let Some(path) = module.find_use_path(ctx.db, ModuleDef::from(variant)) {\n+                            // Variants with trivial paths are already added by the existing completion logic,\n+                            // so we should avoid adding these twice\n+                            if path.segments.len() > 1 {\n+                                acc.add_enum_variant(ctx, variant, Some(path.to_string()));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_for() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                for i in 0..5 {<|>\n+                    if true {\n+                        foo();\n+\n+                        //comment\n+                        bar();\n+                    } else {\n+                        println!(\"bar\");\n+                    }\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                <|>if true {\n+                    foo();\n+\n+                    //comment\n+                    bar();\n+                } else {\n+                    println!(\"bar\");\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_if_in_for() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                for i in 0..5 {\n+                    if true {<|>\n+                        foo();\n+\n+                        //comment\n+                        bar();\n+                    } else {\n+                        println!(\"bar\");\n+                    }\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                for i in 0..5 {\n+                    <|>foo();\n+\n+                    //comment\n+                    bar();\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_loop() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                loop {<|>\n+                    if true {\n+                        foo();\n+\n+                        //comment\n+                        bar();\n+                    } else {\n+                        println!(\"bar\");\n+                    }\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                <|>if true {\n+                    foo();\n+\n+                    //comment\n+                    bar();\n+                } else {\n+                    println!(\"bar\");\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_while() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                while true {<|>\n+                    if true {\n+                        foo();\n+\n+                        //comment\n+                        bar();\n+                    } else {\n+                        println!(\"bar\");\n+                    }\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                <|>if true {\n+                    foo();\n+\n+                    //comment\n+                    bar();\n+                } else {\n+                    println!(\"bar\");\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_if_in_while_bad_cursor_position() {\n+        check_assist_not_applicable(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                while true {\n+                    if true {\n+                        foo();<|>\n+\n+                        //comment\n+                        bar();\n+                    } else {\n+                        println!(\"bar\");\n+                    }\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+}"}, {"sha": "c5df86600f51d24cc45a7525a5bb61b19c00dba3", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76733f0cd456005295e60da8c45d74c8c48f177c/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76733f0cd456005295e60da8c45d74c8c48f177c/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=76733f0cd456005295e60da8c45d74c8c48f177c", "patch": "@@ -143,6 +143,7 @@ mod handlers {\n     mod split_import;\n     mod add_from_impl_for_enum;\n     mod reorder_fields;\n+    mod unwrap_block;\n \n     pub(crate) fn all() -> &'static [AssistHandler] {\n         &[\n@@ -181,6 +182,7 @@ mod handlers {\n             replace_unwrap_with_match::replace_unwrap_with_match,\n             split_import::split_import,\n             add_from_impl_for_enum::add_from_impl_for_enum,\n+            unwrap_block::unwrap_block,\n             // These are manually sorted for better priorities\n             add_missing_impl_members::add_missing_impl_members,\n             add_missing_impl_members::add_missing_default_members,"}, {"sha": "1c1134bc5d1d7a21444284a3b7ff5efec4df186b", "filename": "crates/ra_syntax/src/ast/expr_extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76733f0cd456005295e60da8c45d74c8c48f177c/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76733f0cd456005295e60da8c45d74c8c48f177c/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs?ref=76733f0cd456005295e60da8c45d74c8c48f177c", "patch": "@@ -43,7 +43,7 @@ impl ast::IfExpr {\n         Some(res)\n     }\n \n-    fn blocks(&self) -> AstChildren<ast::BlockExpr> {\n+    pub fn blocks(&self) -> AstChildren<ast::BlockExpr> {\n         support::children(self.syntax())\n     }\n }"}, {"sha": "02323772c0d8920b37f321cf063b2d28ba9dab1a", "filename": "docs/user/assists.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/76733f0cd456005295e60da8c45d74c8c48f177c/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/76733f0cd456005295e60da8c45d74c8c48f177c/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=76733f0cd456005295e60da8c45d74c8c48f177c", "patch": "@@ -695,3 +695,21 @@ use std::\u2503collections::HashMap;\n // AFTER\n use std::{collections::HashMap};\n ```\n+\n+## `unwrap_block`\n+\n+Removes the `mut` keyword.\n+\n+```rust\n+// BEFORE\n+fn foo() {\n+    if true {\u2503\n+        println!(\"foo\");\n+    }\n+}\n+\n+// AFTER\n+fn foo() {\n+    \u2503println!(\"foo\");\n+}\n+```"}]}