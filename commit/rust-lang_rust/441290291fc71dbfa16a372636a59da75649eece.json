{"sha": "441290291fc71dbfa16a372636a59da75649eece", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MTI5MDI5MWZjNzFkYmZhMTZhMzcyNjM2YTU5ZGE3NTY0OWVlY2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-01T08:46:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-01T08:46:38Z"}, "message": "Auto merge of #51060 - michaelwoerister:thread-safe-consts, r=Zoxc\n\nMake const decoding thread-safe.\n\nThis is an alternative to https://github.com/rust-lang/rust/pull/50957. It's a proof of concept (e.g. it doesn't adapt metadata decoding, just the incr. comp. cache) but I think it turned out nice. It's rather simple and does not require passing around a bunch of weird closures, like we currently do.\n\nIf you (@Zoxc & @oli-obk) think this approach is good then I'm happy to finish and clean this up.\n\nNote: The current version just spins when it encounters an in-progress decoding. I don't have a strong preference for this approach. Decoding concurrently is equally fine by me (or maybe even better because it doesn't require poisoning).\n\nr? @Zoxc", "tree": {"sha": "b11bb92bd1325e4bf07bb59145d8c098f0a5df35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b11bb92bd1325e4bf07bb59145d8c098f0a5df35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/441290291fc71dbfa16a372636a59da75649eece", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/441290291fc71dbfa16a372636a59da75649eece", "html_url": "https://github.com/rust-lang/rust/commit/441290291fc71dbfa16a372636a59da75649eece", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/441290291fc71dbfa16a372636a59da75649eece/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dcda69586d72d13c3e7815393c3c16b2b880d48", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dcda69586d72d13c3e7815393c3c16b2b880d48", "html_url": "https://github.com/rust-lang/rust/commit/1dcda69586d72d13c3e7815393c3c16b2b880d48"}, {"sha": "12e83599566e5b40a7f8fdbe0fd9fdbc7ddd2e75", "url": "https://api.github.com/repos/rust-lang/rust/commits/12e83599566e5b40a7f8fdbe0fd9fdbc7ddd2e75", "html_url": "https://github.com/rust-lang/rust/commit/12e83599566e5b40a7f8fdbe0fd9fdbc7ddd2e75"}], "stats": {"total": 564, "additions": 449, "deletions": 115}, "files": [{"sha": "10e8905054d11399c8e6246c2ecebf14e6edab8e", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/441290291fc71dbfa16a372636a59da75649eece/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441290291fc71dbfa16a372636a59da75649eece/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=441290291fc71dbfa16a372636a59da75649eece", "patch": "@@ -68,6 +68,7 @@\n #![feature(trace_macros)]\n #![feature(trusted_len)]\n #![feature(catch_expr)]\n+#![feature(integer_atomics)]\n #![feature(test)]\n #![feature(in_band_lifetimes)]\n #![feature(macro_at_most_once_rep)]"}, {"sha": "6bd5814799ae07d6c1847c99bfc77b11528dc55c", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 167, "deletions": 39, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/441290291fc71dbfa16a372636a59da75649eece/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441290291fc71dbfa16a372636a59da75649eece/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=441290291fc71dbfa16a372636a59da75649eece", "patch": "@@ -23,10 +23,15 @@ use std::io;\n use std::ops::{Deref, DerefMut};\n use std::hash::Hash;\n use syntax::ast::Mutability;\n-use rustc_serialize::{Encoder, Decoder, Decodable, Encodable};\n+use rustc_serialize::{Encoder, Decodable, Encodable};\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::{Lock as Mutex, HashMapExt};\n+use rustc_data_structures::tiny_list::TinyList;\n use byteorder::{WriteBytesExt, ReadBytesExt, LittleEndian, BigEndian};\n+use ty::codec::TyDecoder;\n+use std::sync::atomic::{AtomicU32, Ordering};\n+use std::num::NonZeroU32;\n \n #[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Lock {\n@@ -204,44 +209,163 @@ pub fn specialized_encode_alloc_id<\n     Ok(())\n }\n \n-pub fn specialized_decode_alloc_id<\n-    'a, 'tcx,\n-    D: Decoder,\n-    CACHE: FnOnce(&mut D, AllocId),\n->(\n-    decoder: &mut D,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    cache: CACHE,\n-) -> Result<AllocId, D::Error> {\n-    match AllocKind::decode(decoder)? {\n-        AllocKind::Alloc => {\n-            let alloc_id = tcx.alloc_map.lock().reserve();\n-            trace!(\"creating alloc id {:?}\", alloc_id);\n-            // insert early to allow recursive allocs\n-            cache(decoder, alloc_id);\n-\n-            let allocation = <&'tcx Allocation as Decodable>::decode(decoder)?;\n-            trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n-            tcx.alloc_map.lock().set_id_memory(alloc_id, allocation);\n-\n-            Ok(alloc_id)\n-        },\n-        AllocKind::Fn => {\n-            trace!(\"creating fn alloc id\");\n-            let instance = ty::Instance::decode(decoder)?;\n-            trace!(\"decoded fn alloc instance: {:?}\", instance);\n-            let id = tcx.alloc_map.lock().create_fn_alloc(instance);\n-            trace!(\"created fn alloc id: {:?}\", id);\n-            cache(decoder, id);\n-            Ok(id)\n-        },\n-        AllocKind::Static => {\n-            trace!(\"creating extern static alloc id at\");\n-            let did = DefId::decode(decoder)?;\n-            let alloc_id = tcx.alloc_map.lock().intern_static(did);\n-            cache(decoder, alloc_id);\n-            Ok(alloc_id)\n-        },\n+// Used to avoid infinite recursion when decoding cyclic allocations.\n+type DecodingSessionId = NonZeroU32;\n+\n+#[derive(Clone)]\n+enum State {\n+    Empty,\n+    InProgressNonAlloc(TinyList<DecodingSessionId>),\n+    InProgress(TinyList<DecodingSessionId>, AllocId),\n+    Done(AllocId),\n+}\n+\n+pub struct AllocDecodingState {\n+    // For each AllocId we keep track of which decoding state it's currently in.\n+    decoding_state: Vec<Mutex<State>>,\n+    // The offsets of each allocation in the data stream.\n+    data_offsets: Vec<u32>,\n+}\n+\n+impl AllocDecodingState {\n+\n+    pub fn new_decoding_session(&self) -> AllocDecodingSession {\n+        static DECODER_SESSION_ID: AtomicU32 = AtomicU32::new(0);\n+        let counter = DECODER_SESSION_ID.fetch_add(1, Ordering::SeqCst);\n+\n+        // Make sure this is never zero\n+        let session_id = DecodingSessionId::new((counter & 0x7FFFFFFF) + 1).unwrap();\n+\n+        AllocDecodingSession {\n+            state: self,\n+            session_id,\n+        }\n+    }\n+\n+    pub fn new(data_offsets: Vec<u32>) -> AllocDecodingState {\n+        let decoding_state: Vec<_> = ::std::iter::repeat(Mutex::new(State::Empty))\n+            .take(data_offsets.len())\n+            .collect();\n+\n+        AllocDecodingState {\n+            decoding_state: decoding_state,\n+            data_offsets,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct AllocDecodingSession<'s> {\n+    state: &'s AllocDecodingState,\n+    session_id: DecodingSessionId,\n+}\n+\n+impl<'s> AllocDecodingSession<'s> {\n+\n+    // Decodes an AllocId in a thread-safe way.\n+    pub fn decode_alloc_id<'a, 'tcx, D>(&self,\n+                                        decoder: &mut D)\n+                                        -> Result<AllocId, D::Error>\n+        where D: TyDecoder<'a, 'tcx>,\n+              'tcx: 'a,\n+    {\n+        // Read the index of the allocation\n+        let idx = decoder.read_u32()? as usize;\n+        let pos = self.state.data_offsets[idx] as usize;\n+\n+        // Decode the AllocKind now so that we know if we have to reserve an\n+        // AllocId.\n+        let (alloc_kind, pos) = decoder.with_position(pos, |decoder| {\n+            let alloc_kind = AllocKind::decode(decoder)?;\n+            Ok((alloc_kind, decoder.position()))\n+        })?;\n+\n+        // Check the decoding state, see if it's already decoded or if we should\n+        // decode it here.\n+        let alloc_id = {\n+            let mut entry = self.state.decoding_state[idx].lock();\n+\n+            match *entry {\n+                State::Done(alloc_id) => {\n+                    return Ok(alloc_id);\n+                }\n+                ref mut entry @ State::Empty => {\n+                    // We are allowed to decode\n+                    match alloc_kind {\n+                        AllocKind::Alloc => {\n+                            // If this is an allocation, we need to reserve an\n+                            // AllocId so we can decode cyclic graphs.\n+                            let alloc_id = decoder.tcx().alloc_map.lock().reserve();\n+                            *entry = State::InProgress(\n+                                TinyList::new_single(self.session_id),\n+                                alloc_id);\n+                            Some(alloc_id)\n+                        },\n+                        AllocKind::Fn | AllocKind::Static => {\n+                            // Fns and statics cannot be cyclic and their AllocId\n+                            // is determined later by interning\n+                            *entry = State::InProgressNonAlloc(\n+                                TinyList::new_single(self.session_id));\n+                            None\n+                        }\n+                    }\n+                }\n+                State::InProgressNonAlloc(ref mut sessions) => {\n+                    if sessions.contains(&self.session_id) {\n+                        bug!(\"This should be unreachable\")\n+                    } else {\n+                        // Start decoding concurrently\n+                        sessions.insert(self.session_id);\n+                        None\n+                    }\n+                }\n+                State::InProgress(ref mut sessions, alloc_id) => {\n+                    if sessions.contains(&self.session_id) {\n+                        // Don't recurse.\n+                        return Ok(alloc_id)\n+                    } else {\n+                        // Start decoding concurrently\n+                        sessions.insert(self.session_id);\n+                        Some(alloc_id)\n+                    }\n+                }\n+            }\n+        };\n+\n+        // Now decode the actual data\n+        let alloc_id = decoder.with_position(pos, |decoder| {\n+            match alloc_kind {\n+                AllocKind::Alloc => {\n+                    let allocation = <&'tcx Allocation as Decodable>::decode(decoder)?;\n+                    // We already have a reserved AllocId.\n+                    let alloc_id = alloc_id.unwrap();\n+                    trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n+                    decoder.tcx().alloc_map.lock().set_id_same_memory(alloc_id, allocation);\n+                    Ok(alloc_id)\n+                },\n+                AllocKind::Fn => {\n+                    assert!(alloc_id.is_none());\n+                    trace!(\"creating fn alloc id\");\n+                    let instance = ty::Instance::decode(decoder)?;\n+                    trace!(\"decoded fn alloc instance: {:?}\", instance);\n+                    let alloc_id = decoder.tcx().alloc_map.lock().create_fn_alloc(instance);\n+                    Ok(alloc_id)\n+                },\n+                AllocKind::Static => {\n+                    assert!(alloc_id.is_none());\n+                    trace!(\"creating extern static alloc id at\");\n+                    let did = DefId::decode(decoder)?;\n+                    let alloc_id = decoder.tcx().alloc_map.lock().intern_static(did);\n+                    Ok(alloc_id)\n+                }\n+            }\n+        })?;\n+\n+        self.state.decoding_state[idx].with_lock(|entry| {\n+            *entry = State::Done(alloc_id);\n+        });\n+\n+        Ok(alloc_id)\n     }\n }\n \n@@ -340,6 +464,10 @@ impl<'tcx, M: fmt::Debug + Eq + Hash + Clone> AllocMap<'tcx, M> {\n             bug!(\"tried to set allocation id {}, but it was already existing as {:#?}\", id, old);\n         }\n     }\n+\n+    pub fn set_id_same_memory(&mut self, id: AllocId, mem: M) {\n+       self.id_to_type.insert_same(id, AllocType::Memory(mem));\n+    }\n }\n \n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]"}, {"sha": "cd317ff6cdbef04c307cba312f82a2731882f076", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 10, "deletions": 41, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/441290291fc71dbfa16a372636a59da75649eece/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441290291fc71dbfa16a372636a59da75649eece/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=441290291fc71dbfa16a372636a59da75649eece", "patch": "@@ -16,14 +16,14 @@ use hir::def_id::{CrateNum, DefIndex, DefId, LocalDefId,\n use hir::map::definitions::DefPathHash;\n use ich::{CachingCodemapView, Fingerprint};\n use mir::{self, interpret};\n+use mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{Lrc, Lock, HashMapExt, Once};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder, opaque,\n                       SpecializedDecoder, SpecializedEncoder,\n                       UseSpecializedDecodable, UseSpecializedEncodable};\n use session::{CrateDisambiguator, Session};\n-use std::cell::RefCell;\n use std::mem;\n use syntax::ast::NodeId;\n use syntax::codemap::{CodeMap, StableFilemapId};\n@@ -77,11 +77,7 @@ pub struct OnDiskCache<'sess> {\n     // `serialized_data`.\n     prev_diagnostics_index: FxHashMap<SerializedDepNodeIndex, AbsoluteBytePos>,\n \n-    // Alloc indices to memory location map\n-    prev_interpret_alloc_index: Vec<AbsoluteBytePos>,\n-\n-    /// Deserialization: A cache to ensure we don't read allocations twice\n-    interpret_alloc_cache: RefCell<FxHashMap<usize, interpret::AllocId>>,\n+    alloc_decoding_state: AllocDecodingState,\n }\n \n // This type is used only for (de-)serialization.\n@@ -92,7 +88,7 @@ struct Footer {\n     query_result_index: EncodedQueryResultIndex,\n     diagnostics_index: EncodedQueryResultIndex,\n     // the location of all allocations\n-    interpret_alloc_index: Vec<AbsoluteBytePos>,\n+    interpret_alloc_index: Vec<u32>,\n }\n \n type EncodedQueryResultIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n@@ -149,8 +145,7 @@ impl<'sess> OnDiskCache<'sess> {\n             query_result_index: footer.query_result_index.into_iter().collect(),\n             prev_diagnostics_index: footer.diagnostics_index.into_iter().collect(),\n             synthetic_expansion_infos: Lock::new(FxHashMap()),\n-            prev_interpret_alloc_index: footer.interpret_alloc_index,\n-            interpret_alloc_cache: RefCell::new(FxHashMap::default()),\n+            alloc_decoding_state: AllocDecodingState::new(footer.interpret_alloc_index),\n         }\n     }\n \n@@ -166,8 +161,7 @@ impl<'sess> OnDiskCache<'sess> {\n             query_result_index: FxHashMap(),\n             prev_diagnostics_index: FxHashMap(),\n             synthetic_expansion_infos: Lock::new(FxHashMap()),\n-            prev_interpret_alloc_index: Vec::new(),\n-            interpret_alloc_cache: RefCell::new(FxHashMap::default()),\n+            alloc_decoding_state: AllocDecodingState::new(Vec::new()),\n         }\n     }\n \n@@ -291,7 +285,7 @@ impl<'sess> OnDiskCache<'sess> {\n                     }\n                     for idx in n..new_n {\n                         let id = encoder.interpret_allocs_inverse[idx];\n-                        let pos = AbsoluteBytePos::new(encoder.position());\n+                        let pos = encoder.position() as u32;\n                         interpret_alloc_index.push(pos);\n                         interpret::specialized_encode_alloc_id(\n                             &mut encoder,\n@@ -424,8 +418,7 @@ impl<'sess> OnDiskCache<'sess> {\n             file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,\n             synthetic_expansion_infos: &self.synthetic_expansion_infos,\n-            prev_interpret_alloc_index: &self.prev_interpret_alloc_index,\n-            interpret_alloc_cache: &self.interpret_alloc_cache,\n+            alloc_decoding_session: self.alloc_decoding_state.new_decoding_session(),\n         };\n \n         match decode_tagged(&mut decoder, dep_node_index) {\n@@ -487,9 +480,7 @@ struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n     synthetic_expansion_infos: &'x Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n     file_index_to_file: &'x Lock<FxHashMap<FileMapIndex, Lrc<FileMap>>>,\n     file_index_to_stable_id: &'x FxHashMap<FileMapIndex, StableFilemapId>,\n-    interpret_alloc_cache: &'x RefCell<FxHashMap<usize, interpret::AllocId>>,\n-    /// maps from index in the cache file to location in the cache file\n-    prev_interpret_alloc_index: &'x [AbsoluteBytePos],\n+    alloc_decoding_session: AllocDecodingSession<'x>,\n }\n \n impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n@@ -612,30 +603,8 @@ implement_ty_decoder!( CacheDecoder<'a, 'tcx, 'x> );\n \n impl<'a, 'tcx, 'x> SpecializedDecoder<interpret::AllocId> for CacheDecoder<'a, 'tcx, 'x> {\n     fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n-        let tcx = self.tcx;\n-        let idx = usize::decode(self)?;\n-        trace!(\"loading index {}\", idx);\n-\n-        if let Some(cached) = self.interpret_alloc_cache.borrow().get(&idx).cloned() {\n-            trace!(\"loading alloc id {:?} from alloc_cache\", cached);\n-            return Ok(cached);\n-        }\n-        let pos = self.prev_interpret_alloc_index[idx].to_usize();\n-        trace!(\"loading position {}\", pos);\n-        self.with_position(pos, |this| {\n-            interpret::specialized_decode_alloc_id(\n-                this,\n-                tcx,\n-                |this, alloc_id| {\n-                    trace!(\"caching idx {} for alloc id {} at position {}\", idx, alloc_id, pos);\n-                    assert!(this\n-                        .interpret_alloc_cache\n-                        .borrow_mut()\n-                        .insert(idx, alloc_id)\n-                        .is_none());\n-                },\n-            )\n-        })\n+        let alloc_decoding_session = self.alloc_decoding_session;\n+        alloc_decoding_session.decode_alloc_id(self)\n     }\n }\n impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {"}, {"sha": "23a920739b964dcd28925cf6a78771205a589145", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/441290291fc71dbfa16a372636a59da75649eece/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441290291fc71dbfa16a372636a59da75649eece/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=441290291fc71dbfa16a372636a59da75649eece", "patch": "@@ -74,6 +74,7 @@ pub mod control_flow_graph;\n pub mod flock;\n pub mod sync;\n pub mod owning_ref;\n+pub mod tiny_list;\n pub mod sorted_map;\n \n pub struct OnDrop<F: Fn()>(pub F);"}, {"sha": "5b1b2aadec5638d433168f2de54a7d0083a889b6", "filename": "src/librustc_data_structures/tiny_list.rs", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/441290291fc71dbfa16a372636a59da75649eece/src%2Flibrustc_data_structures%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441290291fc71dbfa16a372636a59da75649eece/src%2Flibrustc_data_structures%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list.rs?ref=441290291fc71dbfa16a372636a59da75649eece", "patch": "@@ -0,0 +1,251 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+//! A singly-linked list.\n+//!\n+//! Using this data structure only makes sense under very specific\n+//! circumstances:\n+//!\n+//! - If you have a list that rarely stores more than one element, then this\n+//!   data-structure can store the element without allocating and only uses as\n+//!   much space as a `Option<(T, usize)>`. If T can double as the `Option`\n+//!   discriminant, it will even only be as large as `T, usize`.\n+//!\n+//! If you expect to store more than 1 element in the common case, steer clear\n+//! and use a `Vec<T>`, `Box<[T]>`, or a `SmallVec<T>`.\n+\n+use std::mem;\n+\n+#[derive(Clone, Hash, Debug, PartialEq)]\n+pub struct TinyList<T: PartialEq> {\n+    head: Option<Element<T>>\n+}\n+\n+impl<T: PartialEq> TinyList<T> {\n+\n+    #[inline]\n+    pub fn new() -> TinyList<T> {\n+        TinyList {\n+            head: None\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn new_single(data: T) -> TinyList<T> {\n+        TinyList {\n+            head: Some(Element {\n+                data,\n+                next: None,\n+            })\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn insert(&mut self, data: T) {\n+        let current_head = mem::replace(&mut self.head, None);\n+\n+        if let Some(current_head) = current_head {\n+            let current_head = Box::new(current_head);\n+            self.head = Some(Element {\n+                data,\n+                next: Some(current_head)\n+            });\n+        } else {\n+            self.head = Some(Element {\n+                data,\n+                next: None,\n+            })\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn remove(&mut self, data: &T) -> bool {\n+        let remove_head = if let Some(ref mut head) = self.head {\n+            if head.data == *data {\n+                Some(mem::replace(&mut head.next, None))\n+            } else {\n+                None\n+            }\n+        } else {\n+            return false\n+        };\n+\n+        if let Some(remove_head) = remove_head {\n+            if let Some(next) = remove_head {\n+                self.head = Some(*next);\n+            } else {\n+                self.head = None;\n+            }\n+            return true\n+        }\n+\n+        self.head.as_mut().unwrap().remove_next(data)\n+    }\n+\n+    #[inline]\n+    pub fn contains(&self, data: &T) -> bool {\n+        if let Some(ref head) = self.head {\n+            head.contains(data)\n+        } else {\n+            false\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        if let Some(ref head) = self.head {\n+            head.len()\n+        } else {\n+            0\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Hash, Debug, PartialEq)]\n+struct Element<T: PartialEq> {\n+    data: T,\n+    next: Option<Box<Element<T>>>,\n+}\n+\n+impl<T: PartialEq> Element<T> {\n+\n+    fn remove_next(&mut self, data: &T) -> bool {\n+        let new_next = if let Some(ref mut next) = self.next {\n+            if next.data != *data {\n+                return next.remove_next(data)\n+            } else {\n+                mem::replace(&mut next.next, None)\n+            }\n+        } else {\n+            return false\n+        };\n+\n+        self.next = new_next;\n+        return true\n+    }\n+\n+    fn len(&self) -> usize {\n+        if let Some(ref next) = self.next {\n+            1 + next.len()\n+        } else {\n+            1\n+        }\n+    }\n+\n+    fn contains(&self, data: &T) -> bool {\n+        if self.data == *data {\n+            return true\n+        }\n+\n+        if let Some(ref next) = self.next {\n+            next.contains(data)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn test_contains_and_insert() {\n+        fn do_insert(i : u32) -> bool {\n+            i % 2 == 0\n+        }\n+\n+        let mut list = TinyList::new();\n+\n+        for i in 0 .. 10 {\n+            for j in 0 .. i {\n+                if do_insert(j) {\n+                    assert!(list.contains(&j));\n+                } else {\n+                    assert!(!list.contains(&j));\n+                }\n+            }\n+\n+            assert!(!list.contains(&i));\n+\n+            if do_insert(i) {\n+                list.insert(i);\n+                assert!(list.contains(&i));\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_remove_first() {\n+        let mut list = TinyList::new();\n+        list.insert(1);\n+        list.insert(2);\n+        list.insert(3);\n+        list.insert(4);\n+        assert_eq!(list.len(), 4);\n+\n+        assert!(list.remove(&4));\n+        assert!(!list.contains(&4));\n+\n+        assert_eq!(list.len(), 3);\n+        assert!(list.contains(&1));\n+        assert!(list.contains(&2));\n+        assert!(list.contains(&3));\n+    }\n+\n+    #[test]\n+    fn test_remove_last() {\n+        let mut list = TinyList::new();\n+        list.insert(1);\n+        list.insert(2);\n+        list.insert(3);\n+        list.insert(4);\n+        assert_eq!(list.len(), 4);\n+\n+        assert!(list.remove(&1));\n+        assert!(!list.contains(&1));\n+\n+        assert_eq!(list.len(), 3);\n+        assert!(list.contains(&2));\n+        assert!(list.contains(&3));\n+        assert!(list.contains(&4));\n+    }\n+\n+    #[test]\n+    fn test_remove_middle() {\n+        let mut list = TinyList::new();\n+        list.insert(1);\n+        list.insert(2);\n+        list.insert(3);\n+        list.insert(4);\n+        assert_eq!(list.len(), 4);\n+\n+        assert!(list.remove(&2));\n+        assert!(!list.contains(&2));\n+\n+        assert_eq!(list.len(), 3);\n+        assert!(list.contains(&1));\n+        assert!(list.contains(&3));\n+        assert!(list.contains(&4));\n+    }\n+\n+    #[test]\n+    fn test_remove_single() {\n+        let mut list = TinyList::new();\n+        list.insert(1);\n+        assert_eq!(list.len(), 1);\n+\n+        assert!(list.remove(&1));\n+        assert!(!list.contains(&1));\n+\n+        assert_eq!(list.len(), 0);\n+    }\n+}"}, {"sha": "e41b3f5f53b252fee2d1829136d077bd8a0bcdd8", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/441290291fc71dbfa16a372636a59da75649eece/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441290291fc71dbfa16a372636a59da75649eece/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=441290291fc71dbfa16a372636a59da75649eece", "patch": "@@ -19,6 +19,7 @@ use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX};\n use rustc::hir::svh::Svh;\n use rustc::middle::allocator::AllocatorKind;\n use rustc::middle::cstore::DepKind;\n+use rustc::mir::interpret::AllocDecodingState;\n use rustc::session::{Session, CrateDisambiguator};\n use rustc::session::config::{Sanitizer, self};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n@@ -222,6 +223,9 @@ impl<'a> CrateLoader<'a> {\n             crate_root.def_path_table.decode((&metadata, self.sess))\n         });\n \n+        let interpret_alloc_index: Vec<u32> = crate_root.interpret_alloc_index\n+                                                        .decode(&metadata)\n+                                                        .collect();\n         let trait_impls = crate_root\n             .impls\n             .decode((&metadata, self.sess))\n@@ -242,6 +246,7 @@ impl<'a> CrateLoader<'a> {\n             cnum,\n             dependencies: Lock::new(dependencies),\n             codemap_import_info: RwLock::new(vec![]),\n+            alloc_decoding_state: AllocDecodingState::new(interpret_alloc_index),\n             dep_kind: Lock::new(dep_kind),\n             source: cstore::CrateSource {\n                 dylib,"}, {"sha": "2bc5f6074866432742c32d15ce322dd817e7a1d3", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/441290291fc71dbfa16a372636a59da75649eece/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441290291fc71dbfa16a372636a59da75649eece/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=441290291fc71dbfa16a372636a59da75649eece", "patch": "@@ -12,10 +12,10 @@\n // crates and libraries\n \n use schema;\n-\n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::middle::cstore::{DepKind, ExternCrate, MetadataLoader};\n+use rustc::mir::interpret::AllocDecodingState;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::util::nodemap::{FxHashMap, NodeMap};\n \n@@ -66,6 +66,9 @@ pub struct CrateMetadata {\n     pub dependencies: Lock<Vec<CrateNum>>,\n     pub codemap_import_info: RwLock<Vec<ImportedFileMap>>,\n \n+    /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n+    pub alloc_decoding_state: AllocDecodingState,\n+\n     pub root: schema::CrateRoot,\n \n     /// For each public item in this crate, we encode a key.  When the"}, {"sha": "69e873bb95d2557778ef12e5d5a2f480630d4739", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 34, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/441290291fc71dbfa16a372636a59da75649eece/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441290291fc71dbfa16a372636a59da75649eece/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=441290291fc71dbfa16a372636a59da75649eece", "patch": "@@ -25,12 +25,12 @@ use rustc::hir::def_id::{CrateNum, DefId, DefIndex,\n use rustc::ich::Fingerprint;\n use rustc::middle::lang_items;\n use rustc::mir::{self, interpret};\n+use rustc::mir::interpret::AllocDecodingSession;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::codec::TyDecoder;\n use rustc::mir::Mir;\n use rustc::util::captures::Captures;\n-use rustc::util::nodemap::FxHashMap;\n \n use std::io;\n use std::mem;\n@@ -55,11 +55,8 @@ pub struct DecodeContext<'a, 'tcx: 'a> {\n \n     lazy_state: LazyState,\n \n-    // interpreter allocation cache\n-    interpret_alloc_cache: FxHashMap<usize, interpret::AllocId>,\n-\n-    // Read from the LazySeq CrateRoot::inpterpret_alloc_index on demand\n-    interpret_alloc_index: Option<Vec<u32>>,\n+    // Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n+    alloc_decoding_session: Option<AllocDecodingSession<'a>>,\n }\n \n /// Abstract over the various ways one can create metadata decoders.\n@@ -78,8 +75,9 @@ pub trait Metadata<'a, 'tcx>: Copy {\n             tcx,\n             last_filemap_index: 0,\n             lazy_state: LazyState::NoNode,\n-            interpret_alloc_cache: FxHashMap::default(),\n-            interpret_alloc_index: None,\n+            alloc_decoding_session: self.cdata().map(|cdata| {\n+                cdata.alloc_decoding_state.new_decoding_session()\n+            }),\n         }\n     }\n }\n@@ -178,17 +176,6 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         self.lazy_state = LazyState::Previous(position + min_size);\n         Ok(position)\n     }\n-\n-    fn interpret_alloc(&mut self, idx: usize) -> usize {\n-        if let Some(index) = self.interpret_alloc_index.as_mut() {\n-            return index[idx] as usize;\n-        }\n-        let cdata = self.cdata();\n-        let index: Vec<u32> = cdata.root.interpret_alloc_index.decode(cdata).collect();\n-        let pos = index[idx];\n-        self.interpret_alloc_index = Some(index);\n-        pos as usize\n-    }\n }\n \n impl<'a, 'tcx: 'a> TyDecoder<'a, 'tcx> for DecodeContext<'a, 'tcx> {\n@@ -299,22 +286,11 @@ impl<'a, 'tcx> SpecializedDecoder<LocalDefId> for DecodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedDecoder<interpret::AllocId> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n-        let tcx = self.tcx.unwrap();\n-        let idx = usize::decode(self)?;\n-\n-        if let Some(cached) = self.interpret_alloc_cache.get(&idx).cloned() {\n-            return Ok(cached);\n+        if let Some(alloc_decoding_session) = self.alloc_decoding_session {\n+            alloc_decoding_session.decode_alloc_id(self)\n+        } else {\n+            bug!(\"Attempting to decode interpret::AllocId without CrateMetadata\")\n         }\n-        let pos = self.interpret_alloc(idx);\n-        self.with_position(pos, |this| {\n-            interpret::specialized_decode_alloc_id(\n-                this,\n-                tcx,\n-                |this, alloc_id| {\n-                    assert!(this.interpret_alloc_cache.insert(idx, alloc_id).is_none());\n-                },\n-            )\n-        })\n     }\n }\n "}]}