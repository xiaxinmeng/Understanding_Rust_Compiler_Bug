{"sha": "ed47c479d73fd7b57d3b493e03c74e2932733163", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNDdjNDc5ZDczZmQ3YjU3ZDNiNDkzZTAzYzc0ZTI5MzI3MzMxNjM=", "commit": {"author": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-06-20T23:05:06Z"}, "committer": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-07-04T00:28:20Z"}, "message": "liburl: remove redundant fields in Url.\n\nurl.path - Now a Path instead of a String.\n\nTo fix old code:\nurl.path => url.path.path\nurl.query => url.path.query\nurl.fragment => url.path.fragment\n\nNot much point having the Path struct if it's not going to be used.\n\n[breaking-change]", "tree": {"sha": "d580f80e9b02e5c8be1ec2e223296a8e6466631e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d580f80e9b02e5c8be1ec2e223296a8e6466631e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed47c479d73fd7b57d3b493e03c74e2932733163", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed47c479d73fd7b57d3b493e03c74e2932733163", "html_url": "https://github.com/rust-lang/rust/commit/ed47c479d73fd7b57d3b493e03c74e2932733163", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed47c479d73fd7b57d3b493e03c74e2932733163/comments", "author": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9e82e145e61f4b9825b4622f78ea9364387ae70", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9e82e145e61f4b9825b4622f78ea9364387ae70", "html_url": "https://github.com/rust-lang/rust/commit/a9e82e145e61f4b9825b4622f78ea9364387ae70"}], "stats": {"total": 53, "additions": 17, "deletions": 36}, "files": [{"sha": "a5031e11d4cd03c8566f25e2481bcac4cc347058", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 17, "deletions": 36, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ed47c479d73fd7b57d3b493e03c74e2932733163/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed47c479d73fd7b57d3b493e03c74e2932733163/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=ed47c479d73fd7b57d3b493e03c74e2932733163", "patch": "@@ -54,22 +54,16 @@ pub struct Url {\n     pub host: String,\n     /// A TCP port number, for example `8080`.\n     pub port: Option<String>,\n-    /// The path component of a URL, for example `/foo/bar`.\n-    pub path: String,\n-    /// The query component of a URL.\n-    /// `vec!((\"baz\".to_string(), \"qux\".to_string()))` represents the fragment\n-    /// `baz=qux` in the above example.\n-    pub query: Query,\n-    /// The fragment component, such as `quz`. Not including the leading `#` character.\n-    pub fragment: Option<String>\n+    /// The path component of a URL, for example `/foo/bar?baz=qux#quz`.\n+    pub path: Path,\n }\n \n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, PartialEq, Eq)]\n pub struct Path {\n     /// The path component of a URL, for example `/foo/bar`.\n     pub path: String,\n     /// The query component of a URL.\n-    /// `vec!((\"baz\".to_string(), \"qux\".to_string()))` represents the fragment\n+    /// `vec![(\"baz\".to_string(), \"qux\".to_string())]` represents the fragment\n     /// `baz=qux` in the above example.\n     pub query: Query,\n     /// The fragment component, such as `quz`. Not including the leading `#` character.\n@@ -102,9 +96,7 @@ impl Url {\n             user: user,\n             host: host,\n             port: port,\n-            path: path,\n-            query: query,\n-            fragment: fragment,\n+            path: Path::new(path, query, fragment)\n         }\n     }\n \n@@ -836,26 +828,15 @@ impl fmt::Show for Url {\n             }\n         }\n \n-        try!(write!(f, \"{}\", self.path));\n-\n-        if !self.query.is_empty() {\n-            try!(write!(f, \"?{}\", query_to_str(&self.query)));\n-        }\n-\n-        match self.fragment {\n-            Some(ref fragment) => {\n-                write!(f, \"#{}\", encode_component(fragment.as_slice()))\n-            }\n-            None => Ok(()),\n-        }\n+        write!(f, \"{}\", self.path)\n     }\n }\n \n impl fmt::Show for Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{}\", self.path));\n         if !self.query.is_empty() {\n-            try!(write!(f, \"?{}\", self.query))\n+            try!(write!(f, \"?{}\", query_to_str(&self.query)))\n         }\n \n         match self.fragment {\n@@ -981,9 +962,9 @@ mod tests {\n         assert_eq!(&u.user, &Some(UserInfo::new(\"user\".to_string(), Some(\"pass\".to_string()))));\n         assert_eq!(&u.host, &\"rust-lang.org\".to_string());\n         assert_eq!(&u.port, &Some(\"8080\".to_string()));\n-        assert_eq!(&u.path, &\"/doc/~u\".to_string());\n-        assert_eq!(&u.query, &vec!((\"s\".to_string(), \"v\".to_string())));\n-        assert_eq!(&u.fragment, &Some(\"something\".to_string()));\n+        assert_eq!(&u.path.path, &\"/doc/~u\".to_string());\n+        assert_eq!(&u.path.query, &vec!((\"s\".to_string(), \"v\".to_string())));\n+        assert_eq!(&u.path.fragment, &Some(\"something\".to_string()));\n     }\n \n     #[test]\n@@ -1002,7 +983,7 @@ mod tests {\n         let urlstr = \"http://0.42.42.42/\";\n         let url = from_str::<Url>(urlstr).unwrap();\n         assert!(url.host == \"0.42.42.42\".to_string());\n-        assert!(url.path == \"/\".to_string());\n+        assert!(url.path.path == \"/\".to_string());\n     }\n \n     #[test]\n@@ -1020,20 +1001,20 @@ mod tests {\n         assert_eq!(&url.host, &\"host\".to_string());\n         assert_eq!(&url.port, &Some(\"1234\".to_string()));\n         // is empty path really correct? Other tests think so\n-        assert_eq!(&url.path, &\"\".to_string());\n+        assert_eq!(&url.path.path, &\"\".to_string());\n         let urlstr = \"scheme://host:1234/\";\n         let url = from_str::<Url>(urlstr).unwrap();\n         assert_eq!(&url.scheme, &\"scheme\".to_string());\n         assert_eq!(&url.host, &\"host\".to_string());\n         assert_eq!(&url.port, &Some(\"1234\".to_string()));\n-        assert_eq!(&url.path, &\"/\".to_string());\n+        assert_eq!(&url.path.path, &\"/\".to_string());\n     }\n \n     #[test]\n     fn test_url_with_underscores() {\n         let urlstr = \"http://dotcom.com/file_name.html\";\n         let url = from_str::<Url>(urlstr).unwrap();\n-        assert!(url.path == \"/file_name.html\".to_string());\n+        assert!(url.path.path == \"/file_name.html\".to_string());\n     }\n \n     #[test]\n@@ -1047,7 +1028,7 @@ mod tests {\n     fn test_url_with_dashes() {\n         let urlstr = \"http://dotcom.com/file-name.html\";\n         let url = from_str::<Url>(urlstr).unwrap();\n-        assert!(url.path == \"/file-name.html\".to_string());\n+        assert!(url.path.path == \"/file-name.html\".to_string());\n     }\n \n     #[test]\n@@ -1133,8 +1114,8 @@ mod tests {\n     fn test_url_component_encoding() {\n         let url = \"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\";\n         let u = from_str::<Url>(url).unwrap();\n-        assert!(u.path == \"/doc uments\".to_string());\n-        assert!(u.query == vec!((\"ba%d \".to_string(), \"#&+\".to_string())));\n+        assert!(u.path.path == \"/doc uments\".to_string());\n+        assert!(u.path.query == vec!((\"ba%d \".to_string(), \"#&+\".to_string())));\n     }\n \n     #[test]"}]}