{"sha": "c80e3bac3e676abb106f7ef8ac7da5b153c65c8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4MGUzYmFjM2U2NzZhYmIxMDZmN2VmOGFjN2RhNWIxNTNjNjVjOGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-29T09:34:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-29T09:34:43Z"}, "message": "auto merge of #7244 : bblum/rust/once, r=nikomatsakis\n\n@graydon suggested that once closures not be part of the language for 1.0, but that they might be hidden behind a -Z compile flag as an \"experimental feature\" in case people decide they need them.\r\n\r\nRegardless of whether ```-Z once-fns``` is set, this PR will parse the ```once``` keyword and will prevent closures labelled with it from being called more than once. It will also permit moving out of captured vars in heap closures, just to let the runtime writers stop using ```Cell``` sooner. Setting ```-Z once-fns``` only toggles whether the move-out-from-capture privilege is also given for stack closures.\r\n\r\nr? @nikomatsakis", "tree": {"sha": "dc1a7abef3d983d7a13e9a94f987e63b2fb78e44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc1a7abef3d983d7a13e9a94f987e63b2fb78e44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e", "html_url": "https://github.com/rust-lang/rust/commit/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a229c980c8c8e628571008882bd7da71f2b3ef7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a229c980c8c8e628571008882bd7da71f2b3ef7a", "html_url": "https://github.com/rust-lang/rust/commit/a229c980c8c8e628571008882bd7da71f2b3ef7a"}, {"sha": "e0788c7f523dc13609179b8f40c09af5c8668df6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0788c7f523dc13609179b8f40c09af5c8668df6", "html_url": "https://github.com/rust-lang/rust/commit/e0788c7f523dc13609179b8f40c09af5c8668df6"}], "stats": {"total": 356, "additions": 304, "deletions": 52}, "files": [{"sha": "9459116307d82536ae53a3f1d25dac37ae37b3dd", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=c80e3bac3e676abb106f7ef8ac7da5b153c65c8e", "patch": "@@ -45,32 +45,33 @@ pub struct config {\n     float_type: float_ty\n }\n \n-pub static verbose: uint = 1 << 0;\n-pub static time_passes: uint = 1 << 1;\n-pub static count_llvm_insns: uint = 1 << 2;\n-pub static time_llvm_passes: uint = 1 << 3;\n-pub static trans_stats: uint = 1 << 4;\n-pub static asm_comments: uint = 1 << 5;\n-pub static no_verify: uint = 1 << 6;\n-pub static trace: uint = 1 << 7;\n-pub static coherence: uint = 1 << 8;\n-pub static borrowck_stats: uint = 1 << 9;\n-pub static borrowck_note_pure: uint = 1 << 10;\n-pub static borrowck_note_loan: uint = 1 << 11;\n-pub static no_landing_pads: uint = 1 << 12;\n-pub static debug_llvm: uint = 1 << 13;\n-pub static count_type_sizes: uint = 1 << 14;\n-pub static meta_stats: uint = 1 << 15;\n-pub static no_opt: uint = 1 << 16;\n+pub static verbose:                 uint = 1 <<  0;\n+pub static time_passes:             uint = 1 <<  1;\n+pub static count_llvm_insns:        uint = 1 <<  2;\n+pub static time_llvm_passes:        uint = 1 <<  3;\n+pub static trans_stats:             uint = 1 <<  4;\n+pub static asm_comments:            uint = 1 <<  5;\n+pub static no_verify:               uint = 1 <<  6;\n+pub static trace:                   uint = 1 <<  7;\n+pub static coherence:               uint = 1 <<  8;\n+pub static borrowck_stats:          uint = 1 <<  9;\n+pub static borrowck_note_pure:      uint = 1 << 10;\n+pub static borrowck_note_loan:      uint = 1 << 11;\n+pub static no_landing_pads:         uint = 1 << 12;\n+pub static debug_llvm:              uint = 1 << 13;\n+pub static count_type_sizes:        uint = 1 << 14;\n+pub static meta_stats:              uint = 1 << 15;\n+pub static no_opt:                  uint = 1 << 16;\n pub static no_monomorphic_collapse: uint = 1 << 17;\n-pub static gc: uint = 1 << 18;\n-pub static jit: uint = 1 << 19;\n-pub static debug_info: uint = 1 << 20;\n-pub static extra_debug_info: uint = 1 << 21;\n-pub static statik: uint = 1 << 22;\n-pub static print_link_args: uint = 1 << 23;\n-pub static no_debug_borrows: uint = 1 << 24;\n-pub static lint_llvm : uint = 1 << 25;\n+pub static gc:                      uint = 1 << 18;\n+pub static jit:                     uint = 1 << 19;\n+pub static debug_info:              uint = 1 << 20;\n+pub static extra_debug_info:        uint = 1 << 21;\n+pub static statik:                  uint = 1 << 22;\n+pub static print_link_args:         uint = 1 << 23;\n+pub static no_debug_borrows:        uint = 1 << 24;\n+pub static lint_llvm:               uint = 1 << 25;\n+pub static once_fns:                uint = 1 << 26;\n \n pub fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n     ~[(~\"verbose\", ~\"in general, enable more debug printouts\", verbose),\n@@ -112,6 +113,9 @@ pub fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n      (~\"lint-llvm\",\n       ~\"Run the LLVM lint pass on the pre-optimization IR\",\n       lint_llvm),\n+     (~\"once-fns\",\n+      ~\"Allow 'once fn' closures to deinitialize captured variables\",\n+      once_fns),\n     ]\n }\n \n@@ -293,6 +297,7 @@ impl Session_ {\n     pub fn debug_borrows(@self) -> bool {\n         self.opts.optimize == No && !self.debugging_opt(no_debug_borrows)\n     }\n+    pub fn once_fns(@self) -> bool { self.debugging_opt(once_fns) }\n \n     // pointless function, now...\n     pub fn str_of(@self, id: ast::ident) -> @str {"}, {"sha": "e950610cce6d0e53e28de1cd1702370f6be63244", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=c80e3bac3e676abb106f7ef8ac7da5b153c65c8e", "patch": "@@ -101,9 +101,7 @@ fn check_is_legal_to_move_from(bccx: @BorrowckCtxt,\n                                cmt0: mc::cmt,\n                                cmt: mc::cmt) -> bool {\n     match cmt.cat {\n-        mc::cat_stack_upvar(*) |\n         mc::cat_implicit_self(*) |\n-        mc::cat_copied_upvar(*) |\n         mc::cat_deref(_, _, mc::region_ptr(*)) |\n         mc::cat_deref(_, _, mc::gc_ptr(*)) |\n         mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n@@ -114,6 +112,27 @@ fn check_is_legal_to_move_from(bccx: @BorrowckCtxt,\n             false\n         }\n \n+        // These are separate from the above cases for a better error message.\n+        mc::cat_stack_upvar(*) |\n+        mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Many, _ }) => {\n+            let once_hint = if bccx.tcx.sess.once_fns() {\n+                \" (unless the destination closure type is `once fn')\"\n+            } else {\n+                \"\"\n+            };\n+            bccx.span_err(\n+                cmt0.span,\n+                fmt!(\"cannot move out of %s%s\", bccx.cmt_to_str(cmt), once_hint));\n+            false\n+        }\n+\n+        // Can move out of captured upvars only if the destination closure\n+        // type is 'once'. 1-shot stack closures emit the copied_upvar form\n+        // (see mem_categorization.rs).\n+        mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Once, _ }) => {\n+            true\n+        }\n+\n         // It seems strange to allow a move out of a static item,\n         // but what happens in practice is that you have a\n         // reference to a constant with a type that should be"}, {"sha": "07e65e8af56ca6b0a321320d7293fe60b80591b1", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=c80e3bac3e676abb106f7ef8ac7da5b153c65c8e", "patch": "@@ -78,7 +78,7 @@ pub enum categorization {\n }\n \n #[deriving(Eq)]\n-struct CopiedUpvar {\n+pub struct CopiedUpvar {\n     upvar_id: ast::node_id,\n     onceness: ast::Onceness,\n }\n@@ -507,30 +507,41 @@ impl mem_categorization_ctxt {\n               let ty = ty::node_id_to_type(self.tcx, fn_node_id);\n               match ty::get(ty).sty {\n                   ty::ty_closure(ref closure_ty) => {\n-                      let sigil = closure_ty.sigil;\n-                      match sigil {\n-                          ast::BorrowedSigil => {\n-                              let upvar_cmt =\n-                                  self.cat_def(id, span, expr_ty, *inner);\n-                              @cmt_ {\n-                                  id:id,\n-                                  span:span,\n-                                  cat:cat_stack_upvar(upvar_cmt),\n-                                  mutbl:upvar_cmt.mutbl.inherit(),\n-                                  ty:upvar_cmt.ty\n-                              }\n+                      // Decide whether to use implicit reference or by copy/move\n+                      // capture for the upvar. This, combined with the onceness,\n+                      // determines whether the closure can move out of it.\n+                      let var_is_refd = match (closure_ty.sigil, closure_ty.onceness) {\n+                          // Many-shot stack closures can never move out.\n+                          (ast::BorrowedSigil, ast::Many) => true,\n+                          // 1-shot stack closures can move out with \"-Z once-fns\".\n+                          (ast::BorrowedSigil, ast::Once)\n+                              if self.tcx.sess.once_fns() => false,\n+                          (ast::BorrowedSigil, ast::Once) => true,\n+                          // Heap closures always capture by copy/move, and can\n+                          // move out iff they are once.\n+                          (ast::OwnedSigil, _) | (ast::ManagedSigil, _) => false,\n+\n+                      };\n+                      if var_is_refd {\n+                          let upvar_cmt =\n+                              self.cat_def(id, span, expr_ty, *inner);\n+                          @cmt_ {\n+                              id:id,\n+                              span:span,\n+                              cat:cat_stack_upvar(upvar_cmt),\n+                              mutbl:upvar_cmt.mutbl.inherit(),\n+                              ty:upvar_cmt.ty\n                           }\n-                          ast::OwnedSigil | ast::ManagedSigil => {\n-                              // FIXME #2152 allow mutation of moved upvars\n-                              @cmt_ {\n-                                  id:id,\n-                                  span:span,\n-                                  cat:cat_copied_upvar(CopiedUpvar {\n-                                      upvar_id: upvar_id,\n-                                      onceness: closure_ty.onceness}),\n-                                  mutbl:McImmutable,\n-                                  ty:expr_ty\n-                              }\n+                      } else {\n+                          // FIXME #2152 allow mutation of moved upvars\n+                          @cmt_ {\n+                              id:id,\n+                              span:span,\n+                              cat:cat_copied_upvar(CopiedUpvar {\n+                                  upvar_id: upvar_id,\n+                                  onceness: closure_ty.onceness}),\n+                              mutbl:McImmutable,\n+                              ty:expr_ty\n                           }\n                       }\n                   }"}, {"sha": "cd9d8738026b83853ec9eba696328cb1554c6b2f", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=c80e3bac3e676abb106f7ef8ac7da5b153c65c8e", "patch": "@@ -183,6 +183,7 @@ struct VisitContext {\n     move_maps: MoveMaps\n }\n \n+#[deriving(Eq)]\n enum UseMode {\n     Move,        // This value or something owned by it is moved.\n     Read         // Read no matter what the type.\n@@ -335,7 +336,27 @@ impl VisitContext {\n             }\n \n             expr_call(callee, ref args, _) => {    // callee(args)\n-                self.use_expr(callee, Read, visitor);\n+                // Figure out whether the called function is consumed.\n+                let mode = match ty::get(ty::expr_ty(self.tcx, callee)).sty {\n+                    ty::ty_closure(ref cty) => {\n+                        match cty.onceness {\n+                        Once => Move,\n+                        Many => Read,\n+                        }\n+                    },\n+                    ty::ty_bare_fn(*) => Read,\n+                    ref x =>\n+                        self.tcx.sess.span_bug(callee.span,\n+                            fmt!(\"non-function type in moves for expr_call: %?\", x)),\n+                };\n+                // Note we're not using consume_expr, which uses type_moves_by_default\n+                // to determine the mode, for this. The reason is that while stack\n+                // closures should be noncopyable, they shouldn't move by default;\n+                // calling a closure should only consume it if it's once.\n+                if mode == Move {\n+                    self.move_maps.moves_map.insert(callee.id);\n+                }\n+                self.use_expr(callee, mode, visitor);\n                 self.use_fn_args(callee.id, *args, visitor);\n             }\n "}, {"sha": "4436675d69a5fbb624d6a6b8169f0adaca60e598", "filename": "src/test/compile-fail/once-cant-call-twice-on-heap.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs?ref=c80e3bac3e676abb106f7ef8ac7da5b153c65c8e", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Testing guarantees provided by once functions.\n+// This program would segfault if it were legal.\n+\n+extern mod extra;\n+use extra::arc;\n+use std::util;\n+\n+fn foo(blk: ~once fn()) {\n+    blk();\n+    blk(); //~ ERROR use of moved value\n+}\n+\n+fn main() {\n+    let x = arc::ARC(true);\n+    do foo {\n+        assert!(*x.get());\n+        util::ignore(x);\n+    }\n+}"}, {"sha": "10877be549e28cede74d551d070309d7508471d7", "filename": "src/test/compile-fail/once-cant-call-twice-on-stack.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-stack.rs?ref=c80e3bac3e676abb106f7ef8ac7da5b153c65c8e", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Testing guarantees provided by once functions.\n+// This program would segfault if it were legal.\n+\n+// compile-flags:-Z once-fns\n+extern mod extra;\n+use extra::arc;\n+use std::util;\n+\n+fn foo(blk: &once fn()) {\n+    blk();\n+    blk(); //~ ERROR use of moved value\n+}\n+\n+fn main() {\n+    let x = arc::ARC(true);\n+    do foo {\n+        assert!(*x.get());\n+        util::ignore(x);\n+    }\n+}"}, {"sha": "6f524c0068b9dd150f139dc9069351563ccaf08a", "filename": "src/test/compile-fail/once-cant-copy-stack-once-fn-copy.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Ftest%2Fcompile-fail%2Fonce-cant-copy-stack-once-fn-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Ftest%2Fcompile-fail%2Fonce-cant-copy-stack-once-fn-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-copy-stack-once-fn-copy.rs?ref=c80e3bac3e676abb106f7ef8ac7da5b153c65c8e", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Though it should be legal to copy a heap-allocated \"once fn:Copy\",\n+// stack closures are not deep-copied, so (counterintuitively) it should be\n+// illegal to copy them.\n+\n+fn foo<'r>(blk: &'r once fn:Copy()) -> (&'r once fn:Copy(), &'r once fn:Copy()) {\n+    (copy blk, blk) //~ ERROR copying a value of non-copyable type\n+}\n+\n+fn main() {\n+}"}, {"sha": "61f158cec27e3068338ea91b51631f4a69c6223b", "filename": "src/test/compile-fail/once-cant-move-out-of-non-once-on-heap.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-heap.rs?ref=c80e3bac3e676abb106f7ef8ac7da5b153c65c8e", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Testing guarantees provided by once functions.\n+// This program would segfault if it were legal.\n+\n+extern mod extra;\n+use extra::arc;\n+use std::util;\n+\n+fn foo(blk: ~fn()) {\n+    blk();\n+    blk();\n+}\n+\n+fn main() {\n+    let x = arc::ARC(true);\n+    do foo {\n+        assert!(*x.get());\n+        util::ignore(x); //~ ERROR cannot move out of captured outer variable\n+    }\n+}"}, {"sha": "42c8b9a9998215cba4421cf01e6e6ed1ff013d57", "filename": "src/test/compile-fail/once-cant-move-out-of-non-once-on-stack.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-stack.rs?ref=c80e3bac3e676abb106f7ef8ac7da5b153c65c8e", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Testing guarantees provided by once functions.\n+// This program would segfault if it were legal.\n+\n+extern mod extra;\n+use extra::arc;\n+use std::util;\n+\n+fn foo(blk: &fn()) {\n+    blk();\n+    blk();\n+}\n+\n+fn main() {\n+    let x = arc::ARC(true);\n+    do foo {\n+        assert!(*x.get());\n+        util::ignore(x); //~ ERROR cannot move out of captured outer variable\n+    }\n+}"}, {"sha": "38b23fd128d4eaf526ca08f718051d0c756505cd", "filename": "src/test/run-pass/once-move-out-on-heap.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs?ref=c80e3bac3e676abb106f7ef8ac7da5b153c65c8e", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Testing guarantees provided by once functions.\n+\n+// xfail-fast\n+\n+extern mod extra;\n+use extra::arc;\n+use std::util;\n+\n+fn foo(blk: ~once fn()) {\n+    blk();\n+}\n+\n+fn main() {\n+    let x = arc::ARC(true);\n+    do foo {\n+        assert!(*x.get());\n+        util::ignore(x);\n+    }\n+}"}, {"sha": "e881f5766736c75b93e6b875784f99b0934758a4", "filename": "src/test/run-pass/once-move-out-on-stack.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs?ref=c80e3bac3e676abb106f7ef8ac7da5b153c65c8e", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Testing guarantees provided by once functions.\n+\n+// xfail-fast\n+\n+// compile-flags:-Z once-fns\n+extern mod extra;\n+use extra::arc;\n+use std::util;\n+\n+fn foo(blk: &once fn()) {\n+    blk();\n+}\n+\n+fn main() {\n+    let x = arc::ARC(true);\n+    do foo {\n+        assert!(*x.get());\n+        util::ignore(x);\n+    }\n+}"}]}