{"sha": "2f311b07c8d95b1192e585e983535de89bcbdfaa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMzExYjA3YzhkOTViMTE5MmU1ODVlOTgzNTM1ZGU4OWJjYmRmYWE=", "commit": {"author": {"name": "csmoe", "email": "csmoe@msn.com", "date": "2020-05-18T00:46:24Z"}, "committer": {"name": "csmoe", "email": "csmoe@msn.com", "date": "2020-05-19T03:02:29Z"}, "message": "Merge branch 'master' into issue-69276", "tree": {"sha": "0e12c995dfdd9352eaa61d542c6f604aca23b456", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e12c995dfdd9352eaa61d542c6f604aca23b456"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f311b07c8d95b1192e585e983535de89bcbdfaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f311b07c8d95b1192e585e983535de89bcbdfaa", "html_url": "https://github.com/rust-lang/rust/commit/2f311b07c8d95b1192e585e983535de89bcbdfaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f311b07c8d95b1192e585e983535de89bcbdfaa/comments", "author": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8841ede3648b5f12284dae850ec065374fd3af46", "url": "https://api.github.com/repos/rust-lang/rust/commits/8841ede3648b5f12284dae850ec065374fd3af46", "html_url": "https://github.com/rust-lang/rust/commit/8841ede3648b5f12284dae850ec065374fd3af46"}, {"sha": "d79f1bd31a1401b5d08096fcdf9a9eb23ddf95df", "url": "https://api.github.com/repos/rust-lang/rust/commits/d79f1bd31a1401b5d08096fcdf9a9eb23ddf95df", "html_url": "https://github.com/rust-lang/rust/commit/d79f1bd31a1401b5d08096fcdf9a9eb23ddf95df"}], "stats": {"total": 11046, "additions": 7965, "deletions": 3081}, "files": [{"sha": "291dbf603612a71441121ec13d1e601b06242158", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -34,6 +34,7 @@ jobs:\n       CI_JOB_NAME: \"${{ matrix.name }}\"\n       SCCACHE_BUCKET: rust-lang-gha-caches\n       TOOLSTATE_REPO: \"https://github.com/pietroalbini/rust-toolstate\"\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n     if: \"github.event_name == 'pull_request'\"\n     strategy:\n       matrix:\n@@ -146,6 +147,7 @@ jobs:\n       TOOLSTATE_PUBLISH: 1\n       CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n       ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n     if: \"github.event_name == 'push' && github.ref == 'refs/heads/try' && github.repository == 'rust-lang-ci/rust'\"\n     strategy:\n       matrix:\n@@ -255,6 +257,7 @@ jobs:\n       TOOLSTATE_PUBLISH: 1\n       CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n       ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n     if: \"github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n     strategy:\n       matrix:\n@@ -606,6 +609,7 @@ jobs:\n       TOOLSTATE_PUBLISH: 1\n       CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n       ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n     if: \"github.event_name == 'push' && github.ref == 'refs/heads/master' && github.repository == 'rust-lang-ci/rust'\"\n     steps:\n       - name: checkout the source code"}, {"sha": "d6357823a37f2fcbb76f306499fcd61dee07704f", "filename": "Cargo.lock", "status": "modified", "additions": 33, "deletions": 58, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -438,7 +438,7 @@ dependencies = [\n  \"proc-macro2 1.0.3\",\n  \"quote 1.0.2\",\n  \"syn 1.0.11\",\n- \"synstructure 0.12.1\",\n+ \"synstructure\",\n ]\n \n [[package]]\n@@ -537,7 +537,6 @@ dependencies = [\n  \"compiletest_rs\",\n  \"derive-new\",\n  \"lazy_static 1.4.0\",\n- \"regex\",\n  \"rustc-workspace-hack\",\n  \"rustc_tools_util 0.2.0\",\n  \"semver\",\n@@ -938,13 +937,13 @@ checksum = \"a0afaad2b26fa326569eb264b1363e8ae3357618c43982b3f285f0774ce76b69\"\n \n [[package]]\n name = \"derive-new\"\n-version = \"0.5.6\"\n+version = \"0.5.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6ca414e896ae072546f4d789f452daaecf60ddee4c9df5dc6d5936d769e3d87c\"\n+checksum = \"71f31892cd5c62e414316f2963c5689242c43d8e7bbcaaeca97e5e28c95d91d9\"\n dependencies = [\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n ]\n \n [[package]]\n@@ -1145,14 +1144,14 @@ dependencies = [\n \n [[package]]\n name = \"failure_derive\"\n-version = \"0.1.5\"\n+version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ea1063915fd7ef4309e222a5a07cf9c319fb9c7836b1f89b85458672dbb127e1\"\n+checksum = \"aa4da3c766cd7a0db8242e326e9e4e081edd567072893ed320008189715366a4\"\n dependencies = [\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n- \"synstructure 0.10.2\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n+ \"synstructure\",\n ]\n \n [[package]]\n@@ -1405,30 +1404,18 @@ dependencies = [\n \n [[package]]\n name = \"handlebars\"\n-version = \"2.0.1\"\n+version = \"3.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"df044dd42cdb7e32f28557b661406fc0f2494be75199779998810dbc35030e0d\"\n+checksum = \"ba758d094d31274eb49d15da6f326b96bf3185239a6359bf684f3d5321148900\"\n dependencies = [\n- \"hashbrown 0.5.0\",\n- \"lazy_static 1.4.0\",\n  \"log\",\n  \"pest\",\n  \"pest_derive\",\n  \"quick-error\",\n- \"regex\",\n  \"serde\",\n  \"serde_json\",\n ]\n \n-[[package]]\n-name = \"hashbrown\"\n-version = \"0.5.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e1de41fb8dba9714efd92241565cdff73f78508c95697dd56787d3cba27e2353\"\n-dependencies = [\n- \"serde\",\n-]\n-\n [[package]]\n name = \"hashbrown\"\n version = \"0.6.2\"\n@@ -2055,9 +2042,9 @@ dependencies = [\n \n [[package]]\n name = \"mdbook\"\n-version = \"0.3.5\"\n+version = \"0.3.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"031bdd9d4893c983e2f69ebc4b59070feee8276a584c4aabdcb351235ea28016\"\n+checksum = \"e7ec525f7ebccc2dd935c263717250cd37f9a4b264a77c5dbc950ea2734d8159\"\n dependencies = [\n  \"ammonia\",\n  \"chrono\",\n@@ -2557,15 +2544,15 @@ dependencies = [\n \n [[package]]\n name = \"pest_generator\"\n-version = \"2.1.0\"\n+version = \"2.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"63120576c4efd69615b5537d3d052257328a4ca82876771d6944424ccfd9f646\"\n+checksum = \"99b8db626e31e5b81787b9783425769681b347011cc59471e33ea46d2ea0cf55\"\n dependencies = [\n  \"pest\",\n  \"pest_meta\",\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n ]\n \n [[package]]\n@@ -2785,9 +2772,9 @@ checksum = \"6ddd112cca70a4d30883b2d21568a1d376ff8be4758649f64f973c6845128ad3\"\n \n [[package]]\n name = \"quick-error\"\n-version = \"1.2.2\"\n+version = \"1.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n+checksum = \"a1d01941d82fa2ab50be1e79e6714289dd7cde78eba4c074bc5a4374f650dfe0\"\n \n [[package]]\n name = \"quine-mc_cluskey\"\n@@ -3449,7 +3436,7 @@ dependencies = [\n  \"proc-macro2 1.0.3\",\n  \"quote 1.0.2\",\n  \"syn 1.0.11\",\n- \"synstructure 0.12.1\",\n+ \"synstructure\",\n ]\n \n [[package]]\n@@ -4059,7 +4046,7 @@ dependencies = [\n  \"proc-macro2 1.0.3\",\n  \"quote 1.0.2\",\n  \"syn 1.0.11\",\n- \"synstructure 0.12.1\",\n+ \"synstructure\",\n ]\n \n [[package]]\n@@ -4630,13 +4617,13 @@ dependencies = [\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.81\"\n+version = \"1.0.106\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"477b13b646f5b5b56fc95bedfc3b550d12141ce84f466f6c44b9a17589923885\"\n+checksum = \"9e549e3abf4fb8621bd1609f11dfc9f5e50320802273b12f3811a67e6716ea6c\"\n dependencies = [\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n ]\n \n [[package]]\n@@ -4778,9 +4765,9 @@ checksum = \"ffbc596e092fe5f598b12ef46cc03754085ac2f4d8c739ad61c4ae266cc3b3fa\"\n \n [[package]]\n name = \"stacker\"\n-version = \"0.1.8\"\n+version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"32c2467b8abbb417e4e62fd62229719b9c9d77714a7fa989f1afad16ba9c9743\"\n+checksum = \"72dd941b456e1c006d6b9f27c526d5b69281288aeea8cba82c19d3843d8ccdd2\"\n dependencies = [\n  \"cc\",\n  \"cfg-if\",\n@@ -4800,7 +4787,7 @@ dependencies = [\n  \"core\",\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n- \"hashbrown 0.6.2\",\n+ \"hashbrown\",\n  \"hermit-abi\",\n  \"libc\",\n  \"panic_abort\",\n@@ -4932,18 +4919,6 @@ dependencies = [\n  \"unicode-xid 0.2.0\",\n ]\n \n-[[package]]\n-name = \"synstructure\"\n-version = \"0.10.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"02353edf96d6e4dc81aea2d8490a7e9db177bf8acb0e951c24940bf866cb313f\"\n-dependencies = [\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n- \"unicode-xid 0.1.0\",\n-]\n-\n [[package]]\n name = \"synstructure\"\n version = \"0.12.1\""}, {"sha": "ffe907c9da97c97e7b046346de54c1c26ac70f40", "filename": "config.toml.example", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -314,6 +314,10 @@\n # library.\n #debug-assertions = false\n \n+# Whether or not debug assertions are enabled for the standard library.\n+# Overrides the `debug-assertions` option, if defined.\n+#debug-assertions-std = false\n+\n # Debuginfo level for most of Rust code, corresponds to the `-C debuginfo=N` option of `rustc`.\n # `0` - no debug info\n # `1` - line tables only\n@@ -411,10 +415,6 @@\n # sysroot.\n #llvm-tools = false\n \n-# Indicates whether LLDB will be made available in the sysroot.\n-# This is only built if LLVM is also being built.\n-#lldb = false\n-\n # Whether to deny warnings in crates\n #deny-warnings = true\n "}, {"sha": "b7d0fac5be31fdca554d690289ce8756c0df6fac", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -180,13 +180,16 @@ def format_build_time(duration):\n def default_build_triple():\n     \"\"\"Build triple as in LLVM\"\"\"\n     default_encoding = sys.getdefaultencoding()\n-    required = not sys.platform == 'win32'\n-    ostype = require([\"uname\", \"-s\"], exit=required).decode(default_encoding)\n-    cputype = require(['uname', '-m'], exit=required).decode(default_encoding)\n+    required = sys.platform != 'win32'\n+    ostype = require([\"uname\", \"-s\"], exit=required)\n+    cputype = require(['uname', '-m'], exit=required)\n \n     if ostype is None or cputype is None:\n         return 'x86_64-pc-windows-msvc'\n \n+    ostype = ostype.decode(default_encoding)\n+    cputype = cputype.decode(default_encoding)\n+\n     # The goal here is to come up with the same triple as LLVM would,\n     # at least for the subset of platforms we're willing to target.\n     ostype_mapper = {"}, {"sha": "4bc81a7b42dc00089a95cc6e715604ecc93453cf", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -439,7 +439,6 @@ impl<'a> Builder<'a> {\n                 dist::Clippy,\n                 dist::Miri,\n                 dist::LlvmTools,\n-                dist::Lldb,\n                 dist::Extended,\n                 dist::HashSign\n             ),\n@@ -916,7 +915,14 @@ impl<'a> Builder<'a> {\n             .env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n             .env(\"RUSTC_REAL\", self.rustc(compiler))\n             .env(\"RUSTC_STAGE\", stage.to_string())\n-            .env(\"RUSTC_DEBUG_ASSERTIONS\", self.config.rust_debug_assertions.to_string())\n+            .env(\n+                \"RUSTC_DEBUG_ASSERTIONS\",\n+                if mode == Mode::Std {\n+                    self.config.rust_debug_assertions_std.to_string()\n+                } else {\n+                    self.config.rust_debug_assertions.to_string()\n+                },\n+            )\n             .env(\"RUSTC_SYSROOT\", &sysroot)\n             .env(\"RUSTC_LIBDIR\", &libdir)\n             .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))"}, {"sha": "771f952abc013b4827ce51c25241e5eb159a19c2", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -85,7 +85,6 @@ pub struct Config {\n \n     pub use_lld: bool,\n     pub lld_enabled: bool,\n-    pub lldb_enabled: bool,\n     pub llvm_tools_enabled: bool,\n \n     pub llvm_cflags: Option<String>,\n@@ -98,6 +97,7 @@ pub struct Config {\n     pub rust_codegen_units: Option<u32>,\n     pub rust_codegen_units_std: Option<u32>,\n     pub rust_debug_assertions: bool,\n+    pub rust_debug_assertions_std: bool,\n     pub rust_debuginfo_level_rustc: u32,\n     pub rust_debuginfo_level_std: u32,\n     pub rust_debuginfo_level_tools: u32,\n@@ -315,6 +315,7 @@ struct Rust {\n     codegen_units: Option<u32>,\n     codegen_units_std: Option<u32>,\n     debug_assertions: Option<bool>,\n+    debug_assertions_std: Option<bool>,\n     debuginfo_level: Option<u32>,\n     debuginfo_level_rustc: Option<u32>,\n     debuginfo_level_std: Option<u32>,\n@@ -337,7 +338,6 @@ struct Rust {\n     lld: Option<bool>,\n     use_lld: Option<bool>,\n     llvm_tools: Option<bool>,\n-    lldb: Option<bool>,\n     deny_warnings: Option<bool>,\n     backtrace_on_ice: Option<bool>,\n     verify_llvm_ir: Option<bool>,\n@@ -520,6 +520,7 @@ impl Config {\n         let mut llvm_assertions = None;\n         let mut debug = None;\n         let mut debug_assertions = None;\n+        let mut debug_assertions_std = None;\n         let mut debuginfo_level = None;\n         let mut debuginfo_level_rustc = None;\n         let mut debuginfo_level_std = None;\n@@ -562,6 +563,7 @@ impl Config {\n         if let Some(ref rust) = toml.rust {\n             debug = rust.debug;\n             debug_assertions = rust.debug_assertions;\n+            debug_assertions_std = rust.debug_assertions_std;\n             debuginfo_level = rust.debuginfo_level;\n             debuginfo_level_rustc = rust.debuginfo_level_rustc;\n             debuginfo_level_std = rust.debuginfo_level_std;\n@@ -585,7 +587,6 @@ impl Config {\n             }\n             set(&mut config.use_lld, rust.use_lld);\n             set(&mut config.lld_enabled, rust.lld);\n-            set(&mut config.lldb_enabled, rust.lldb);\n             set(&mut config.llvm_tools_enabled, rust.llvm_tools);\n             config.rustc_parallel = rust.parallel_compiler.unwrap_or(false);\n             config.rustc_default_linker = rust.default_linker.clone();\n@@ -661,6 +662,8 @@ impl Config {\n \n         let default = debug == Some(true);\n         config.rust_debug_assertions = debug_assertions.unwrap_or(default);\n+        config.rust_debug_assertions_std =\n+            debug_assertions_std.unwrap_or(config.rust_debug_assertions);\n \n         let with_defaults = |debuginfo_level_specific: Option<u32>| {\n             debuginfo_level_specific.or(debuginfo_level).unwrap_or(if debug == Some(true) {"}, {"sha": "d1e53db573e4cbd8366902f8e49a7a861ff61b73", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -57,7 +57,6 @@ def v(*args):\n o(\"profiler\", \"build.profiler\", \"build the profiler runtime\")\n o(\"full-tools\", None, \"enable all tools\")\n o(\"lld\", \"rust.lld\", \"build lld\")\n-o(\"lldb\", \"rust.lldb\", \"build lldb\")\n o(\"missing-tools\", \"dist.missing-tools\", \"allow failures when building tools\")\n o(\"use-libcxx\", \"llvm.use-libcxx\", \"build LLVM with libc++\")\n o(\"control-flow-guard\", \"rust.control-flow-guard\", \"Enable Control Flow Guard\")"}, {"sha": "c4bca4a00408912a9758142df685a0c2617ac824", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -38,8 +38,6 @@ pub fn pkgname(builder: &Builder<'_>, component: &str) -> String {\n         format!(\"{}-{}\", component, builder.rustfmt_package_vers())\n     } else if component == \"llvm-tools\" {\n         format!(\"{}-{}\", component, builder.llvm_tools_package_vers())\n-    } else if component == \"lldb\" {\n-        format!(\"{}-{}\", component, builder.lldb_package_vers())\n     } else {\n         assert!(component.starts_with(\"rust\"));\n         format!(\"{}-{}\", component, builder.rust_package_vers())\n@@ -1645,7 +1643,6 @@ impl Step for Extended {\n         let llvm_tools_installer = builder.ensure(LlvmTools { target });\n         let clippy_installer = builder.ensure(Clippy { compiler, target });\n         let miri_installer = builder.ensure(Miri { compiler, target });\n-        let lldb_installer = builder.ensure(Lldb { target });\n         let mingw_installer = builder.ensure(Mingw { host: target });\n         let analysis_installer = builder.ensure(Analysis { compiler, target });\n \n@@ -1681,7 +1678,6 @@ impl Step for Extended {\n         tarballs.extend(miri_installer.clone());\n         tarballs.extend(rustfmt_installer.clone());\n         tarballs.extend(llvm_tools_installer);\n-        tarballs.extend(lldb_installer);\n         tarballs.push(analysis_installer);\n         tarballs.push(std_installer);\n         if builder.config.docs {\n@@ -2222,7 +2218,6 @@ impl Step for HashSign {\n         cmd.arg(builder.package_vers(&builder.release_num(\"miri\")));\n         cmd.arg(builder.package_vers(&builder.release_num(\"rustfmt\")));\n         cmd.arg(builder.llvm_tools_package_vers());\n-        cmd.arg(builder.lldb_package_vers());\n \n         builder.create_dir(&distdir(builder));\n \n@@ -2349,119 +2344,3 @@ impl Step for LlvmTools {\n         Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n }\n-\n-#[derive(Clone, Debug, Eq, Hash, PartialEq)]\n-pub struct Lldb {\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for Lldb {\n-    type Output = Option<PathBuf>;\n-    const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"src/llvm-project/lldb\").path(\"src/tools/lldb\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Lldb { target: run.target });\n-    }\n-\n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let target = self.target;\n-\n-        if builder.config.dry_run {\n-            return None;\n-        }\n-\n-        let bindir = builder.llvm_out(target).join(\"bin\");\n-        let lldb_exe = bindir.join(exe(\"lldb\", &target));\n-        if !lldb_exe.exists() {\n-            return None;\n-        }\n-\n-        builder.info(&format!(\"Dist Lldb ({})\", target));\n-        let src = builder.src.join(\"src/llvm-project/lldb\");\n-        let name = pkgname(builder, \"lldb\");\n-\n-        let tmp = tmpdir(builder);\n-        let image = tmp.join(\"lldb-image\");\n-        drop(fs::remove_dir_all(&image));\n-\n-        // Prepare the image directory\n-        let root = image.join(\"lib/rustlib\").join(&*target);\n-        let dst = root.join(\"bin\");\n-        t!(fs::create_dir_all(&dst));\n-        for program in &[\"lldb\", \"lldb-argdumper\", \"lldb-mi\", \"lldb-server\"] {\n-            let exe = bindir.join(exe(program, &target));\n-            builder.install(&exe, &dst, 0o755);\n-        }\n-\n-        // The libraries.\n-        let libdir = builder.llvm_out(target).join(\"lib\");\n-        let dst = root.join(\"lib\");\n-        t!(fs::create_dir_all(&dst));\n-        for entry in t!(fs::read_dir(&libdir)) {\n-            let entry = entry.unwrap();\n-            if let Ok(name) = entry.file_name().into_string() {\n-                if name.starts_with(\"liblldb.\") && !name.ends_with(\".a\") {\n-                    if t!(entry.file_type()).is_symlink() {\n-                        builder.copy_to_folder(&entry.path(), &dst);\n-                    } else {\n-                        builder.install(&entry.path(), &dst, 0o755);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // The lldb scripts might be installed in lib/python$version\n-        // or in lib64/python$version.  If lib64 exists, use it;\n-        // otherwise lib.\n-        let libdir = builder.llvm_out(target).join(\"lib64\");\n-        let (libdir, libdir_name) = if libdir.exists() {\n-            (libdir, \"lib64\")\n-        } else {\n-            (builder.llvm_out(target).join(\"lib\"), \"lib\")\n-        };\n-        for entry in t!(fs::read_dir(&libdir)) {\n-            let entry = t!(entry);\n-            if let Ok(name) = entry.file_name().into_string() {\n-                if name.starts_with(\"python\") {\n-                    let dst = root.join(libdir_name).join(entry.file_name());\n-                    t!(fs::create_dir_all(&dst));\n-                    builder.cp_r(&entry.path(), &dst);\n-                    break;\n-                }\n-            }\n-        }\n-\n-        // Prepare the overlay\n-        let overlay = tmp.join(\"lldb-overlay\");\n-        drop(fs::remove_dir_all(&overlay));\n-        builder.create_dir(&overlay);\n-        builder.install(&src.join(\"LICENSE.TXT\"), &overlay, 0o644);\n-        builder.create(&overlay.join(\"version\"), &builder.lldb_vers());\n-\n-        // Generate the installer tarball\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=lldb-installed.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(\"--non-installed-overlay\")\n-            .arg(&overlay)\n-            .arg(format!(\"--package-name={}-{}\", name, target))\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-            .arg(\"--component-name=lldb-preview\");\n-\n-        builder.run(&mut cmd);\n-        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n-    }\n-}"}, {"sha": "646b9e05d99c3c25c9357c3d24f2e359dee06deb", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -503,6 +503,20 @@ Arguments:\n             }\n         };\n \n+        if let Subcommand::Check { .. } = &cmd {\n+            if matches.opt_str(\"stage\").is_some() {\n+                println!(\"{}\", \"--stage not supported for x.py check, always treated as stage 0\");\n+                process::exit(1);\n+            }\n+            if matches.opt_str(\"keep-stage\").is_some() {\n+                println!(\n+                    \"{}\",\n+                    \"--keep-stage not supported for x.py check, only one stage available\"\n+                );\n+                process::exit(1);\n+            }\n+        }\n+\n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n             stage: matches.opt_str(\"stage\").map(|j| j.parse().expect(\"`stage` should be a number\")),"}, {"sha": "390b7e96b9a543cecdd806fe2369b10469bd9f50", "filename": "src/bootstrap/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fformat.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -23,7 +23,7 @@ fn rustfmt(src: &Path, rustfmt: &Path, path: &Path, check: bool) {\n     if !status.success() {\n         eprintln!(\n             \"Running `{}` failed.\\nIf you're running `tidy`, \\\n-            try again with `--bless` flag. Or, you just want to format \\\n+            try again with `--bless`. Or, if you just want to format \\\n             code, run `./x.py fmt` instead.\",\n             cmd_debug,\n         );"}, {"sha": "15bf831a14835a846f42dde91912ab6293735219", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1029,14 +1029,6 @@ impl Build {\n         self.rust_version()\n     }\n \n-    fn lldb_package_vers(&self) -> String {\n-        self.package_vers(channel::CFG_RELEASE_NUM)\n-    }\n-\n-    fn lldb_vers(&self) -> String {\n-        self.rust_version()\n-    }\n-\n     fn llvm_link_tools_dynamically(&self, target: Interned<String>) -> bool {\n         target.contains(\"linux-gnu\") || target.contains(\"apple-darwin\")\n     }"}, {"sha": "446017f1fabe0f2ca96bd278475b3bb1bfd8703b", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -184,7 +184,7 @@ impl Step for Llvm {\n         }\n \n         // For distribution we want the LLVM tools to be *statically* linked to libstdc++\n-        if builder.config.llvm_tools_enabled || builder.config.lldb_enabled {\n+        if builder.config.llvm_tools_enabled {\n             if !target.contains(\"msvc\") {\n                 if target.contains(\"apple\") {\n                     cfg.define(\"CMAKE_EXE_LINKER_FLAGS\", \"-static-libstdc++\");\n@@ -212,17 +212,9 @@ impl Step for Llvm {\n             enabled_llvm_projects.push(\"compiler-rt\");\n         }\n \n-        if builder.config.lldb_enabled {\n-            enabled_llvm_projects.push(\"clang\");\n-            enabled_llvm_projects.push(\"lldb\");\n-            // For the time being, disable code signing.\n-            cfg.define(\"LLDB_CODESIGN_IDENTITY\", \"\");\n-            cfg.define(\"LLDB_NO_DEBUGSERVER\", \"ON\");\n-        } else {\n-            // LLDB requires libxml2; but otherwise we want it to be disabled.\n-            // See https://github.com/rust-lang/rust/pull/50104\n-            cfg.define(\"LLVM_ENABLE_LIBXML2\", \"OFF\");\n-        }\n+        // We want libxml to be disabled.\n+        // See https://github.com/rust-lang/rust/pull/50104\n+        cfg.define(\"LLVM_ENABLE_LIBXML2\", \"OFF\");\n \n         if !enabled_llvm_projects.is_empty() {\n             enabled_llvm_projects.sort();"}, {"sha": "74b47d0772837a5c57f562a6ce5ef0eae97fe48b", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -117,14 +117,6 @@ pub fn check(build: &mut Build) {\n                 build.config.ninja = true;\n             }\n         }\n-\n-        if build.config.lldb_enabled {\n-            cmd_finder.must_have(\"swig\");\n-            let out = output(Command::new(\"swig\").arg(\"-version\"));\n-            if !out.contains(\"SWIG Version 3\") && !out.contains(\"SWIG Version 4\") {\n-                panic!(\"Ensure that Swig 3.x.x or 4.x.x is installed.\");\n-            }\n-        }\n     }\n \n     build.config.python = build"}, {"sha": "96196a80be466d628c77cfd578bfb3da091baadf", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -436,7 +436,6 @@ impl Step for Miri {\n \n             // miri tests need to know about the stage sysroot\n             cargo.env(\"MIRI_SYSROOT\", miri_sysroot);\n-            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n             cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n             cargo.env(\"MIRI_PATH\", miri);\n \n@@ -1097,20 +1096,15 @@ impl Step for Compiletest {\n                     .to_string()\n             })\n         };\n-        let lldb_exe = if builder.config.lldb_enabled {\n-            // Test against the lldb that was just built.\n-            builder.llvm_out(target).join(\"bin\").join(\"lldb\")\n-        } else {\n-            PathBuf::from(\"lldb\")\n-        };\n-        let lldb_version = Command::new(&lldb_exe)\n+        let lldb_exe = \"lldb\";\n+        let lldb_version = Command::new(lldb_exe)\n             .arg(\"--version\")\n             .output()\n             .map(|output| String::from_utf8_lossy(&output.stdout).to_string())\n             .ok();\n         if let Some(ref vers) = lldb_version {\n             cmd.arg(\"--lldb-version\").arg(vers);\n-            let lldb_python_dir = run(Command::new(&lldb_exe).arg(\"-P\")).ok();\n+            let lldb_python_dir = run(Command::new(lldb_exe).arg(\"-P\")).ok();\n             if let Some(ref dir) = lldb_python_dir {\n                 cmd.arg(\"--lldb-python-dir\").arg(dir);\n             }"}, {"sha": "d891ad1b6680e622323b7bbd21632d21a3e81fb2", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -17,6 +17,8 @@ dist=$objdir/build/dist\n \n source \"$ci_dir/shared.sh\"\n \n+CACHE_DOMAIN=\"${CACHE_DOMAIN:-ci-caches.rust-lang.org}\"\n+\n if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n     if [ \"$CI\" != \"\" ]; then\n       hash_key=/tmp/.docker-hash-key.txt\n@@ -38,9 +40,7 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       cksum=$(sha512sum $hash_key | \\\n         awk '{print $1}')\n \n-      s3url=\"s3://$SCCACHE_BUCKET/docker/$cksum\"\n-      url=\"https://$SCCACHE_BUCKET.s3.amazonaws.com/docker/$cksum\"\n-      upload=\"aws s3 cp - $s3url\"\n+      url=\"https://$CACHE_DOMAIN/docker/$cksum\"\n \n       echo \"Attempting to download $url\"\n       rm -f /tmp/rustci_docker_cache\n@@ -65,7 +65,9 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       -f \"$dockerfile\" \\\n       \"$context\"\n \n-    if [ \"$upload\" != \"\" ]; then\n+    if [ \"$CI\" != \"\" ]; then\n+      s3url=\"s3://$SCCACHE_BUCKET/docker/$cksum\"\n+      upload=\"aws s3 cp - $s3url\"\n       digest=$(docker inspect rust-ci --format '{{.Id}}')\n       echo \"Built container $digest\"\n       if ! grep -q \"$digest\" <(echo \"$loaded_images\"); then"}, {"sha": "1c120f8163459579e0fcfdf4c8fa33df9c748976", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -37,6 +37,7 @@ x--expand-yaml-anchors--remove:\n   - &public-variables\n     SCCACHE_BUCKET: rust-lang-gha-caches\n     TOOLSTATE_REPO: https://github.com/pietroalbini/rust-toolstate\n+    CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n \n   - &prod-variables\n     SCCACHE_BUCKET: rust-lang-gha-caches\n@@ -51,6 +52,7 @@ x--expand-yaml-anchors--remove:\n     # (caches, artifacts...).\n     CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n     ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+    CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n \n   - &base-job\n     env: {}"}, {"sha": "6247be15a7f7509559f7981ee2209b9e0cc121df", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1 +1 @@\n-Subproject commit e37c0e84e2ef73d3a4ebffda8011db6814a3b02d\n+Subproject commit 6247be15a7f7509559f7981ee2209b9e0cc121df"}, {"sha": "49270740c7a4bff2763e6bc730b191d45b7d5167", "filename": "src/doc/edition-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fedition-guide?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1 +1 @@\n-Subproject commit 8204c1d123472cd17f0c1c5c77300ae802eb0271\n+Subproject commit 49270740c7a4bff2763e6bc730b191d45b7d5167"}, {"sha": "366c50a03bed928589771eba8a6f18e0c0c01d23", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1 +1 @@\n-Subproject commit 40beccdf1bb8eb9184a2e3b42db8b8c6e394247f\n+Subproject commit 366c50a03bed928589771eba8a6f18e0c0c01d23"}, {"sha": "d1517d4e3f29264c5c67bce2658516bb5202c800", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1 +1 @@\n-Subproject commit 4d2d275997746d35eabfc4d992dfbdcce2f626ed\n+Subproject commit d1517d4e3f29264c5c67bce2658516bb5202c800"}, {"sha": "892b928b565e35d25b6f9c47faee03b94bc41489", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1 +1 @@\n-Subproject commit ed22e6fbfcb6ce436e9ea3b4bb4a55b2fb50a57e\n+Subproject commit 892b928b565e35d25b6f9c47faee03b94bc41489"}, {"sha": "ab072b14393cbd9e8a1d1d75879bf51e27217bbb", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1 +1 @@\n-Subproject commit ffc99581689fe2455908aaef5f5cf50dd03bb8f5\n+Subproject commit ab072b14393cbd9e8a1d1d75879bf51e27217bbb"}, {"sha": "c638f88057a526aa394457bc425acc88a49f1d57", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -464,7 +464,15 @@ machine. Each target has a default base CPU.\n \n Individual targets will support different features; this flag lets you control\n enabling or disabling a feature. Each feature should be prefixed with a `+` to\n-enable it or `-` to disable it. Separate multiple features with commas.\n+enable it or `-` to disable it.\n+\n+Features from multiple `-C target-feature` options are combined. \\\n+Multiple features can be specified in a single option by separating them\n+with commas - `-C target-feature=+x,-y`. \\\n+If some feature is specified more than once with both `+` and `-`,\n+then values passed later override values passed earlier. \\\n+For example, `-C target-feature=+x,-y,+z -Ctarget-feature=-x,+y`\n+is equivalent to `-C target-feature=-x,+y,+z`.\n \n To see the valid options and an example of use, run `rustc --print\n target-features`."}, {"sha": "1c003983df9892a1c13aef1d7796a9ad36594559", "filename": "src/liballoc/alloc/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -23,7 +23,7 @@ fn allocate_zeroed() {\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn alloc_owned_small(b: &mut Bencher) {\n     b.iter(|| {\n         let _: Box<_> = box 10;"}, {"sha": "c6cb39b1bf51114ed619a3eacc252d87bb7b6af4", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -215,59 +215,6 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n             clone_subtree(self.root.as_ref().unwrap().as_ref())\n         }\n     }\n-\n-    fn clone_from(&mut self, other: &Self) {\n-        BTreeClone::clone_from(self, other);\n-    }\n-}\n-\n-trait BTreeClone {\n-    fn clone_from(&mut self, other: &Self);\n-}\n-\n-impl<K: Clone, V: Clone> BTreeClone for BTreeMap<K, V> {\n-    default fn clone_from(&mut self, other: &Self) {\n-        *self = other.clone();\n-    }\n-}\n-\n-impl<K: Clone + Ord, V: Clone> BTreeClone for BTreeMap<K, V> {\n-    fn clone_from(&mut self, other: &Self) {\n-        // This truncates `self` to `other.len()` by calling `split_off` on\n-        // the first key after `other.len()` elements if it exists.\n-        let split_off_key = if self.len() > other.len() {\n-            let diff = self.len() - other.len();\n-            if diff <= other.len() {\n-                self.iter().nth_back(diff - 1).map(|pair| (*pair.0).clone())\n-            } else {\n-                self.iter().nth(other.len()).map(|pair| (*pair.0).clone())\n-            }\n-        } else {\n-            None\n-        };\n-        if let Some(key) = split_off_key {\n-            self.split_off(&key);\n-        }\n-\n-        let mut siter = self.range_mut(..);\n-        let mut oiter = other.iter();\n-        // After truncation, `self` is at most as long as `other` so this loop\n-        // replaces every key-value pair in `self`. Since `oiter` is in sorted\n-        // order and the structure of the `BTreeMap` stays the same,\n-        // the BTree invariants are maintained at the end of the loop.\n-        while !siter.is_empty() {\n-            if let Some((ok, ov)) = oiter.next() {\n-                // SAFETY: This is safe because `siter` is nonempty.\n-                let (sk, sv) = unsafe { siter.next_unchecked() };\n-                sk.clone_from(ok);\n-                sv.clone_from(ov);\n-            } else {\n-                break;\n-            }\n-        }\n-        // If `other` is longer than `self`, the remaining elements are inserted.\n-        self.extend(oiter.map(|(k, v)| ((*k).clone(), (*v).clone())));\n-    }\n }\n \n impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>"}, {"sha": "b8c93a28bba815a1bfa38fea9a49e581a335c13f", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -182,7 +182,6 @@ fn test_insert_prev() {\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg_attr(miri, ignore)] // Miri does not support threads\n fn test_send() {\n     let n = list_from(&[1, 2, 3]);\n     thread::spawn(move || {"}, {"sha": "540649c61b332345e59f143efcc318839d39bd7f", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1354,7 +1354,9 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, value: T) {\n-        self.grow_if_necessary();\n+        if self.is_full() {\n+            self.grow();\n+        }\n \n         self.tail = self.wrap_sub(self.tail, 1);\n         let tail = self.tail;\n@@ -1377,7 +1379,9 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_back(&mut self, value: T) {\n-        self.grow_if_necessary();\n+        if self.is_full() {\n+            self.grow();\n+        }\n \n         let head = self.head;\n         self.head = self.wrap_add(self.head, 1);\n@@ -1485,7 +1489,9 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn insert(&mut self, index: usize, value: T) {\n         assert!(index <= self.len(), \"index out of bounds\");\n-        self.grow_if_necessary();\n+        if self.is_full() {\n+            self.grow();\n+        }\n \n         // Move the least number of elements in the ring buffer and insert\n         // the given object\n@@ -2003,11 +2009,13 @@ impl<T> VecDeque<T> {\n     }\n \n     // This may panic or abort\n-    #[inline]\n-    fn grow_if_necessary(&mut self) {\n+    #[inline(never)]\n+    fn grow(&mut self) {\n         if self.is_full() {\n             let old_cap = self.cap();\n-            self.buf.double();\n+            // Double the buffer size.\n+            self.buf.reserve_exact(old_cap, old_cap);\n+            assert!(self.cap() == old_cap * 2);\n             unsafe {\n                 self.handle_capacity_increase(old_cap);\n             }"}, {"sha": "fc2ec7908e82368e5c667a847a1abc2ab8a6765b", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -3,7 +3,7 @@ use super::*;\n use test;\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_push_back_100(b: &mut test::Bencher) {\n     let mut deq = VecDeque::with_capacity(101);\n     b.iter(|| {\n@@ -16,7 +16,7 @@ fn bench_push_back_100(b: &mut test::Bencher) {\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_push_front_100(b: &mut test::Bencher) {\n     let mut deq = VecDeque::with_capacity(101);\n     b.iter(|| {\n@@ -29,7 +29,7 @@ fn bench_push_front_100(b: &mut test::Bencher) {\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_pop_back_100(b: &mut test::Bencher) {\n     let mut deq = VecDeque::<i32>::with_capacity(101);\n \n@@ -43,7 +43,7 @@ fn bench_pop_back_100(b: &mut test::Bencher) {\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_pop_front_100(b: &mut test::Bencher) {\n     let mut deq = VecDeque::<i32>::with_capacity(101);\n "}, {"sha": "7aaa91ee10d97d1628768aaf3604b16cfb0bd0a0", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -109,7 +109,7 @@\n #![feature(ptr_offset_from)]\n #![feature(rustc_attrs)]\n #![feature(receiver_trait)]\n-#![feature(specialization)]\n+#![feature(min_specialization)]\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(str_internals)]"}, {"sha": "d46bf81f996f73433649a331789e2203475695a3", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 81, "deletions": 143, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,7 +1,7 @@\n #![unstable(feature = \"raw_vec_internals\", reason = \"implementation detail\", issue = \"none\")]\n #![doc(hidden)]\n \n-use core::alloc::MemoryBlock;\n+use core::alloc::{LayoutErr, MemoryBlock};\n use core::cmp;\n use core::mem::{self, ManuallyDrop, MaybeUninit};\n use core::ops::Drop;\n@@ -211,82 +211,6 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         }\n     }\n \n-    /// Doubles the size of the type's backing allocation. This is common enough\n-    /// to want to do that it's easiest to just have a dedicated method. Slightly\n-    /// more efficient logic can be provided for this than the general case.\n-    ///\n-    /// This function is ideal for when pushing elements one-at-a-time because\n-    /// you don't need to incur the costs of the more general computations\n-    /// reserve needs to do to guard against overflow. You do however need to\n-    /// manually check if your `len == capacity`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n-    ///   all `usize::MAX` slots in your imaginary buffer.\n-    /// * Panics on 32-bit platforms if the requested capacity exceeds\n-    ///   `isize::MAX` bytes.\n-    ///\n-    /// # Aborts\n-    ///\n-    /// Aborts on OOM\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(raw_vec_internals)]\n-    /// # extern crate alloc;\n-    /// # use std::ptr;\n-    /// # use alloc::raw_vec::RawVec;\n-    /// struct MyVec<T> {\n-    ///     buf: RawVec<T>,\n-    ///     len: usize,\n-    /// }\n-    ///\n-    /// impl<T> MyVec<T> {\n-    ///     pub fn push(&mut self, elem: T) {\n-    ///         if self.len == self.buf.capacity() { self.buf.double(); }\n-    ///         // double would have aborted or panicked if the len exceeded\n-    ///         // `isize::MAX` so this is safe to do unchecked now.\n-    ///         unsafe {\n-    ///             ptr::write(self.buf.ptr().add(self.len), elem);\n-    ///         }\n-    ///         self.len += 1;\n-    ///     }\n-    /// }\n-    /// # fn main() {\n-    /// #   let mut vec = MyVec { buf: RawVec::new(), len: 0 };\n-    /// #   vec.push(1);\n-    /// # }\n-    /// ```\n-    #[inline(never)]\n-    #[cold]\n-    pub fn double(&mut self) {\n-        match self.grow(Double, MayMove, Uninitialized) {\n-            Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n-            Ok(()) => { /* yay */ }\n-        }\n-    }\n-\n-    /// Attempts to double the size of the type's backing allocation in place. This is common\n-    /// enough to want to do that it's easiest to just have a dedicated method. Slightly\n-    /// more efficient logic can be provided for this than the general case.\n-    ///\n-    /// Returns `true` if the reallocation attempt has succeeded.\n-    ///\n-    /// # Panics\n-    ///\n-    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n-    ///   all `usize::MAX` slots in your imaginary buffer.\n-    /// * Panics on 32-bit platforms if the requested capacity exceeds\n-    ///   `isize::MAX` bytes.\n-    #[inline(never)]\n-    #[cold]\n-    pub fn double_in_place(&mut self) -> bool {\n-        self.grow(Double, InPlace, Uninitialized).is_ok()\n-    }\n-\n     /// Ensures that the buffer contains at least enough space to hold\n     /// `used_capacity + needed_extra_capacity` elements. If it doesn't already have\n     /// enough capacity, will reallocate enough space plus comfortable slack\n@@ -354,7 +278,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         needed_extra_capacity: usize,\n     ) -> Result<(), TryReserveError> {\n         if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n-            self.grow(Amortized { used_capacity, needed_extra_capacity }, MayMove, Uninitialized)\n+            self.grow_amortized(used_capacity, needed_extra_capacity, MayMove)\n         } else {\n             Ok(())\n         }\n@@ -381,8 +305,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         // This is more readable than putting this in one line:\n         // `!self.needs_to_grow(...) || self.grow(...).is_ok()`\n         if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n-            self.grow(Amortized { used_capacity, needed_extra_capacity }, InPlace, Uninitialized)\n-                .is_ok()\n+            self.grow_amortized(used_capacity, needed_extra_capacity, InPlace).is_ok()\n         } else {\n             true\n         }\n@@ -423,7 +346,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         needed_extra_capacity: usize,\n     ) -> Result<(), TryReserveError> {\n         if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n-            self.grow(Exact { used_capacity, needed_extra_capacity }, MayMove, Uninitialized)\n+            self.grow_exact(used_capacity, needed_extra_capacity)\n         } else {\n             Ok(())\n         }\n@@ -448,14 +371,6 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     }\n }\n \n-#[derive(Copy, Clone)]\n-enum Strategy {\n-    Double,\n-    Amortized { used_capacity: usize, needed_extra_capacity: usize },\n-    Exact { used_capacity: usize, needed_extra_capacity: usize },\n-}\n-use Strategy::*;\n-\n impl<T, A: AllocRef> RawVec<T, A> {\n     /// Returns if the buffer needs to grow to fulfill the needed extra capacity.\n     /// Mainly used to make inlining reserve-calls possible without inlining `grow`.\n@@ -473,68 +388,59 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         self.cap = Self::capacity_from_bytes(memory.size);\n     }\n \n-    /// Single method to handle all possibilities of growing the buffer.\n-    fn grow(\n+    // This method is usually instantiated many times. So we want it to be as\n+    // small as possible, to improve compile times. But we also want as much of\n+    // its contents to be statically computable as possible, to make the\n+    // generated code run faster. Therefore, this method is carefully written\n+    // so that all of the code that depends on `T` is within it, while as much\n+    // of the code that doesn't depend on `T` as possible is in functions that\n+    // are non-generic over `T`.\n+    fn grow_amortized(\n         &mut self,\n-        strategy: Strategy,\n+        used_capacity: usize,\n+        needed_extra_capacity: usize,\n         placement: ReallocPlacement,\n-        init: AllocInit,\n     ) -> Result<(), TryReserveError> {\n-        let elem_size = mem::size_of::<T>();\n-        if elem_size == 0 {\n+        if mem::size_of::<T>() == 0 {\n             // Since we return a capacity of `usize::MAX` when `elem_size` is\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n             return Err(CapacityOverflow);\n         }\n-        let new_layout = match strategy {\n-            Double => unsafe {\n-                // Since we guarantee that we never allocate more than `isize::MAX` bytes,\n-                // `elem_size * self.cap <= isize::MAX` as a precondition, so this can't overflow.\n-                // Additionally the alignment will never be too large as to \"not be satisfiable\",\n-                // so `Layout::from_size_align` will always return `Some`.\n-                //\n-                // TL;DR, we bypass runtime checks due to dynamic assertions in this module,\n-                // allowing us to use `from_size_align_unchecked`.\n-                let cap = if self.cap == 0 {\n-                    // Skip to 4 because tiny `Vec`'s are dumb; but not if that would cause overflow.\n-                    if elem_size > usize::MAX / 8 { 1 } else { 4 }\n-                } else {\n-                    self.cap * 2\n-                };\n-                Layout::from_size_align_unchecked(cap * elem_size, mem::align_of::<T>())\n-            },\n-            Amortized { used_capacity, needed_extra_capacity } => {\n-                // Nothing we can really do about these checks, sadly.\n-                let required_cap =\n-                    used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n-                // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n-                let double_cap = self.cap * 2;\n-                // `double_cap` guarantees exponential growth.\n-                let cap = cmp::max(double_cap, required_cap);\n-                Layout::array::<T>(cap).map_err(|_| CapacityOverflow)?\n-            }\n-            Exact { used_capacity, needed_extra_capacity } => {\n-                let cap =\n-                    used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n-                Layout::array::<T>(cap).map_err(|_| CapacityOverflow)?\n-            }\n-        };\n-        alloc_guard(new_layout.size())?;\n \n-        let memory = if let Some((ptr, old_layout)) = self.current_memory() {\n-            debug_assert_eq!(old_layout.align(), new_layout.align());\n-            unsafe {\n-                self.alloc\n-                    .grow(ptr, old_layout, new_layout.size(), placement, init)\n-                    .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?\n-            }\n-        } else {\n-            match placement {\n-                MayMove => self.alloc.alloc(new_layout, init),\n-                InPlace => Err(AllocErr),\n-            }\n-            .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?\n-        };\n+        // Nothing we can really do about these checks, sadly.\n+        let required_cap =\n+            used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n+        // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n+        let double_cap = self.cap * 2;\n+        // `double_cap` guarantees exponential growth.\n+        let cap = cmp::max(double_cap, required_cap);\n+        let new_layout = Layout::array::<T>(cap);\n+\n+        // `finish_grow` is non-generic over `T`.\n+        let memory = finish_grow(new_layout, placement, self.current_memory(), &mut self.alloc)?;\n+        self.set_memory(memory);\n+        Ok(())\n+    }\n+\n+    // The constraints on this method are much the same as those on\n+    // `grow_amortized`, but this method is usually instantiated less often so\n+    // it's less critical.\n+    fn grow_exact(\n+        &mut self,\n+        used_capacity: usize,\n+        needed_extra_capacity: usize,\n+    ) -> Result<(), TryReserveError> {\n+        if mem::size_of::<T>() == 0 {\n+            // Since we return a capacity of `usize::MAX` when the type size is\n+            // 0, getting to here necessarily means the `RawVec` is overfull.\n+            return Err(CapacityOverflow);\n+        }\n+\n+        let cap = used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n+        let new_layout = Layout::array::<T>(cap);\n+\n+        // `finish_grow` is non-generic over `T`.\n+        let memory = finish_grow(new_layout, MayMove, self.current_memory(), &mut self.alloc)?;\n         self.set_memory(memory);\n         Ok(())\n     }\n@@ -562,6 +468,38 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     }\n }\n \n+// This function is outside `RawVec` to minimize compile times. See the comment\n+// above `RawVec::grow_amortized` for details. (The `A` parameter isn't\n+// significant, because the number of different `A` types seen in practice is\n+// much smaller than the number of `T` types.)\n+fn finish_grow<A>(\n+    new_layout: Result<Layout, LayoutErr>,\n+    placement: ReallocPlacement,\n+    current_memory: Option<(NonNull<u8>, Layout)>,\n+    alloc: &mut A,\n+) -> Result<MemoryBlock, TryReserveError>\n+where\n+    A: AllocRef,\n+{\n+    // Check for the error here to minimize the size of `RawVec::grow_*`.\n+    let new_layout = new_layout.map_err(|_| CapacityOverflow)?;\n+\n+    alloc_guard(new_layout.size())?;\n+\n+    let memory = if let Some((ptr, old_layout)) = current_memory {\n+        debug_assert_eq!(old_layout.align(), new_layout.align());\n+        unsafe { alloc.grow(ptr, old_layout, new_layout.size(), placement, Uninitialized) }\n+    } else {\n+        match placement {\n+            MayMove => alloc.alloc(new_layout, Uninitialized),\n+            InPlace => Err(AllocErr),\n+        }\n+    }\n+    .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?;\n+\n+    Ok(memory)\n+}\n+\n impl<T> RawVec<T, Global> {\n     /// Converts the entire buffer into `Box<[MaybeUninit<T>]>` with the specified `len`.\n     ///"}, {"sha": "76213e65bab5aaa08651bf81fd61d50451e4dac7", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -249,7 +249,7 @@ use core::mem::{self, align_of, align_of_val, forget, size_of_val};\n use core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n-use core::slice::{self, from_raw_parts_mut};\n+use core::slice::from_raw_parts_mut;\n \n use crate::alloc::{box_free, handle_alloc_error, AllocInit, AllocRef, Global, Layout};\n use crate::string::String;\n@@ -1221,6 +1221,12 @@ impl<T: ?Sized + PartialEq> RcEqIdent<T> for Rc<T> {\n     }\n }\n \n+// Hack to allow specializing on `Eq` even though `Eq` has a method.\n+#[rustc_unsafe_specialization_marker]\n+pub(crate) trait MarkerEq: PartialEq<Self> {}\n+\n+impl<T: Eq> MarkerEq for T {}\n+\n /// We're doing this specialization here, and not as a more general optimization on `&T`, because it\n /// would otherwise add a cost to all equality checks on refs. We assume that `Rc`s are used to\n /// store large values, that are slow to clone, but also heavy to check for equality, causing this\n@@ -1229,7 +1235,7 @@ impl<T: ?Sized + PartialEq> RcEqIdent<T> for Rc<T> {\n ///\n /// We can only do this when `T: Eq` as a `PartialEq` might be deliberately irreflexive.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + Eq> RcEqIdent<T> for Rc<T> {\n+impl<T: ?Sized + MarkerEq> RcEqIdent<T> for Rc<T> {\n     #[inline]\n     fn eq(&self, other: &Rc<T>) -> bool {\n         Rc::ptr_eq(self, other) || **self == **other\n@@ -1548,25 +1554,25 @@ impl<T> iter::FromIterator<T> for Rc<[T]> {\n     /// # assert_eq!(&*evens, &*(0..10).collect::<Vec<_>>());\n     /// ```\n     fn from_iter<I: iter::IntoIterator<Item = T>>(iter: I) -> Self {\n-        RcFromIter::from_iter(iter.into_iter())\n+        ToRcSlice::to_rc_slice(iter.into_iter())\n     }\n }\n \n /// Specialization trait used for collecting into `Rc<[T]>`.\n-trait RcFromIter<T, I> {\n-    fn from_iter(iter: I) -> Self;\n+trait ToRcSlice<T>: Iterator<Item = T> + Sized {\n+    fn to_rc_slice(self) -> Rc<[T]>;\n }\n \n-impl<T, I: Iterator<Item = T>> RcFromIter<T, I> for Rc<[T]> {\n-    default fn from_iter(iter: I) -> Self {\n-        iter.collect::<Vec<T>>().into()\n+impl<T, I: Iterator<Item = T>> ToRcSlice<T> for I {\n+    default fn to_rc_slice(self) -> Rc<[T]> {\n+        self.collect::<Vec<T>>().into()\n     }\n }\n \n-impl<T, I: iter::TrustedLen<Item = T>> RcFromIter<T, I> for Rc<[T]> {\n-    default fn from_iter(iter: I) -> Self {\n+impl<T, I: iter::TrustedLen<Item = T>> ToRcSlice<T> for I {\n+    fn to_rc_slice(self) -> Rc<[T]> {\n         // This is the case for a `TrustedLen` iterator.\n-        let (low, high) = iter.size_hint();\n+        let (low, high) = self.size_hint();\n         if let Some(high) = high {\n             debug_assert_eq!(\n                 low,\n@@ -1577,29 +1583,15 @@ impl<T, I: iter::TrustedLen<Item = T>> RcFromIter<T, I> for Rc<[T]> {\n \n             unsafe {\n                 // SAFETY: We need to ensure that the iterator has an exact length and we have.\n-                Rc::from_iter_exact(iter, low)\n+                Rc::from_iter_exact(self, low)\n             }\n         } else {\n             // Fall back to normal implementation.\n-            iter.collect::<Vec<T>>().into()\n+            self.collect::<Vec<T>>().into()\n         }\n     }\n }\n \n-impl<'a, T: 'a + Clone> RcFromIter<&'a T, slice::Iter<'a, T>> for Rc<[T]> {\n-    fn from_iter(iter: slice::Iter<'a, T>) -> Self {\n-        // Delegate to `impl<T: Clone> From<&[T]> for Rc<[T]>`.\n-        //\n-        // In the case that `T: Copy`, we get to use `ptr::copy_nonoverlapping`\n-        // which is even more performant.\n-        //\n-        // In the fall-back case we have `T: Clone`. This is still better\n-        // than the `TrustedLen` implementation as slices have a known length\n-        // and so we get to avoid calling `size_hint` and avoid the branching.\n-        iter.as_slice().into()\n-    }\n-}\n-\n /// `Weak` is a version of [`Rc`] that holds a non-owning reference to the\n /// managed allocation. The allocation is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Rc`]`<T>>`.\n@@ -2035,6 +2027,8 @@ trait RcBoxPtr<T: ?Sized> {\n         // nevertheless, we insert an abort here to hint LLVM at\n         // an otherwise missed optimization.\n         if strong == 0 || strong == usize::max_value() {\n+            // remove `unsafe` on bootstrap bump\n+            #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n             unsafe {\n                 abort();\n             }\n@@ -2061,6 +2055,8 @@ trait RcBoxPtr<T: ?Sized> {\n         // nevertheless, we insert an abort here to hint LLVM at\n         // an otherwise missed optimization.\n         if weak == 0 || weak == usize::max_value() {\n+            // remove `unsafe` on bootstrap bump\n+            #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n             unsafe {\n                 abort();\n             }"}, {"sha": "2c6d130826bf3c6dd661b045a51a779170c72e8e", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -20,7 +20,7 @@ use core::mem::{self, align_of, align_of_val, size_of_val};\n use core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n-use core::slice::{self, from_raw_parts_mut};\n+use core::slice::from_raw_parts_mut;\n use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n \n@@ -835,12 +835,14 @@ impl<T: ?Sized> Arc<T> {\n     ///\n     /// unsafe {\n     ///     let ptr = Arc::into_raw(five);\n-    ///     Arc::decr_strong_count(ptr);\n+    ///     Arc::incr_strong_count(ptr);\n     ///\n-    ///     // This assertion is deterministic because we haven't shared\n+    ///     // Those assertions are deterministic because we haven't shared\n     ///     // the `Arc` between threads.\n     ///     let five = Arc::from_raw(ptr);\n-    ///     assert_eq!(0, Arc::strong_count(&five));\n+    ///     assert_eq!(2, Arc::strong_count(&five));\n+    ///     Arc::decr_strong_count(ptr);\n+    ///     assert_eq!(1, Arc::strong_count(&five));\n     /// }\n     /// ```\n     #[inline]\n@@ -1094,6 +1096,8 @@ impl<T: ?Sized> Clone for Arc<T> {\n         // We abort because such a program is incredibly degenerate, and we\n         // don't care to support it.\n         if old_size > MAX_REFCOUNT {\n+            // remove `unsafe` on bootstrap bump\n+            #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n             unsafe {\n                 abort();\n             }\n@@ -1612,6 +1616,8 @@ impl<T: ?Sized> Weak<T> {\n \n             // See comments in `Arc::clone` for why we do this (for `mem::forget`).\n             if n > MAX_REFCOUNT {\n+                // remove `unsafe` on bootstrap bump\n+                #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n                 unsafe {\n                     abort();\n                 }\n@@ -1751,6 +1757,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n \n         // See comments in Arc::clone() for why we do this (for mem::forget).\n         if old_size > MAX_REFCOUNT {\n+            #[cfg_attr(not(bootstrap), allow(unused_unsafe))] // remove `unsafe` on bootstrap bump\n             unsafe {\n                 abort();\n             }\n@@ -1852,7 +1859,7 @@ impl<T: ?Sized + PartialEq> ArcEqIdent<T> for Arc<T> {\n ///\n /// We can only do this when `T: Eq` as a `PartialEq` might be deliberately irreflexive.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + Eq> ArcEqIdent<T> for Arc<T> {\n+impl<T: ?Sized + crate::rc::MarkerEq> ArcEqIdent<T> for Arc<T> {\n     #[inline]\n     fn eq(&self, other: &Arc<T>) -> bool {\n         Arc::ptr_eq(self, other) || **self == **other\n@@ -2178,25 +2185,25 @@ impl<T> iter::FromIterator<T> for Arc<[T]> {\n     /// # assert_eq!(&*evens, &*(0..10).collect::<Vec<_>>());\n     /// ```\n     fn from_iter<I: iter::IntoIterator<Item = T>>(iter: I) -> Self {\n-        ArcFromIter::from_iter(iter.into_iter())\n+        ToArcSlice::to_arc_slice(iter.into_iter())\n     }\n }\n \n /// Specialization trait used for collecting into `Arc<[T]>`.\n-trait ArcFromIter<T, I> {\n-    fn from_iter(iter: I) -> Self;\n+trait ToArcSlice<T>: Iterator<Item = T> + Sized {\n+    fn to_arc_slice(self) -> Arc<[T]>;\n }\n \n-impl<T, I: Iterator<Item = T>> ArcFromIter<T, I> for Arc<[T]> {\n-    default fn from_iter(iter: I) -> Self {\n-        iter.collect::<Vec<T>>().into()\n+impl<T, I: Iterator<Item = T>> ToArcSlice<T> for I {\n+    default fn to_arc_slice(self) -> Arc<[T]> {\n+        self.collect::<Vec<T>>().into()\n     }\n }\n \n-impl<T, I: iter::TrustedLen<Item = T>> ArcFromIter<T, I> for Arc<[T]> {\n-    default fn from_iter(iter: I) -> Self {\n+impl<T, I: iter::TrustedLen<Item = T>> ToArcSlice<T> for I {\n+    fn to_arc_slice(self) -> Arc<[T]> {\n         // This is the case for a `TrustedLen` iterator.\n-        let (low, high) = iter.size_hint();\n+        let (low, high) = self.size_hint();\n         if let Some(high) = high {\n             debug_assert_eq!(\n                 low,\n@@ -2207,29 +2214,15 @@ impl<T, I: iter::TrustedLen<Item = T>> ArcFromIter<T, I> for Arc<[T]> {\n \n             unsafe {\n                 // SAFETY: We need to ensure that the iterator has an exact length and we have.\n-                Arc::from_iter_exact(iter, low)\n+                Arc::from_iter_exact(self, low)\n             }\n         } else {\n             // Fall back to normal implementation.\n-            iter.collect::<Vec<T>>().into()\n+            self.collect::<Vec<T>>().into()\n         }\n     }\n }\n \n-impl<'a, T: 'a + Clone> ArcFromIter<&'a T, slice::Iter<'a, T>> for Arc<[T]> {\n-    fn from_iter(iter: slice::Iter<'a, T>) -> Self {\n-        // Delegate to `impl<T: Clone> From<&[T]> for Arc<[T]>`.\n-        //\n-        // In the case that `T: Copy`, we get to use `ptr::copy_nonoverlapping`\n-        // which is even more performant.\n-        //\n-        // In the fall-back case we have `T: Clone`. This is still better\n-        // than the `TrustedLen` implementation as slices have a known length\n-        // and so we get to avoid calling `size_hint` and avoid the branching.\n-        iter.as_slice().into()\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> borrow::Borrow<T> for Arc<T> {\n     fn borrow(&self) -> &T {"}, {"sha": "a2bb651e2b77804397d0e88fea8955cacee86d5b", "filename": "src/liballoc/sync/tests.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync%2Ftests.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -32,7 +32,6 @@ impl Drop for Canary {\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg_attr(miri, ignore)] // Miri does not support threads\n fn manually_share_arc() {\n     let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     let arc_v = Arc::new(v);\n@@ -337,12 +336,13 @@ fn test_ptr_eq() {\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg_attr(miri, ignore)] // Miri does not support threads\n fn test_weak_count_locked() {\n     let mut a = Arc::new(atomic::AtomicBool::new(false));\n     let a2 = a.clone();\n     let t = thread::spawn(move || {\n-        for _i in 0..1000000 {\n+        // Miri is too slow\n+        let count = if cfg!(miri) { 1000 } else { 1000000 };\n+        for _i in 0..count {\n             Arc::get_mut(&mut a);\n         }\n         a.store(true, SeqCst);\n@@ -351,6 +351,8 @@ fn test_weak_count_locked() {\n     while !a2.load(SeqCst) {\n         let n = Arc::weak_count(&a2);\n         assert!(n < 2, \"bad weak count: {}\", n);\n+        #[cfg(miri)] // Miri's scheduler does not guarantee liveness, and thus needs this hint.\n+        atomic::spin_loop_hint();\n     }\n     t.join().unwrap();\n }"}, {"sha": "d26cd77aae4b7120e9ca0a04fbd885b6bf942556", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1619,8 +1619,8 @@ impl<T: Default> Vec<T> {\n     #[unstable(feature = \"vec_resize_default\", issue = \"41758\")]\n     #[rustc_deprecated(\n         reason = \"This is moving towards being removed in favor \\\n-        of `.resize_with(Default::default)`.  If you disagree, please comment \\\n-        in the tracking issue.\",\n+                  of `.resize_with(Default::default)`.  If you disagree, please comment \\\n+                  in the tracking issue.\",\n         since = \"1.33.0\"\n     )]\n     pub fn resize_default(&mut self, new_len: usize) {\n@@ -1825,6 +1825,7 @@ impl<T: Clone + IsZero> SpecFromElem for T {\n     }\n }\n \n+#[rustc_specialization_trait]\n unsafe trait IsZero {\n     /// Whether this value is zero\n     fn is_zero(&self) -> bool;\n@@ -1874,9 +1875,12 @@ unsafe impl<T> IsZero for *mut T {\n     }\n }\n \n-// `Option<&T>`, `Option<&mut T>` and `Option<Box<T>>` are guaranteed to represent `None` as null.\n-// For fat pointers, the bytes that would be the pointer metadata in the `Some` variant\n-// are padding in the `None` variant, so ignoring them and zero-initializing instead is ok.\n+// `Option<&T>` and `Option<Box<T>>` are guaranteed to represent `None` as null.\n+// For fat pointers, the bytes that would be the pointer metadata in the `Some`\n+// variant are padding in the `None` variant, so ignoring them and\n+// zero-initializing instead is ok.\n+// `Option<&mut T>` never implements `Clone`, so there's no need for an impl of\n+// `SpecFromElem`.\n \n unsafe impl<T: ?Sized> IsZero for Option<&T> {\n     #[inline]\n@@ -1885,13 +1889,6 @@ unsafe impl<T: ?Sized> IsZero for Option<&T> {\n     }\n }\n \n-unsafe impl<T: ?Sized> IsZero for Option<&mut T> {\n-    #[inline]\n-    fn is_zero(&self) -> bool {\n-        self.is_none()\n-    }\n-}\n-\n unsafe impl<T: ?Sized> IsZero for Option<Box<T>> {\n     #[inline]\n     fn is_zero(&self) -> bool {"}, {"sha": "bbe80c26dcbf98d9c2612e15eb6b4670fdd4c274", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -5,8 +5,7 @@\n //! of individual objects while the arena itself is still alive. The benefit\n //! of an arena is very fast allocation; just a pointer bump.\n //!\n-//! This crate implements `TypedArena`, a simple arena that can only hold\n-//! objects of a single type.\n+//! This crate implements several kinds of arena.\n \n #![doc(\n     html_root_url = \"https://doc.rust-lang.org/nightly/\",\n@@ -98,7 +97,13 @@ impl<T> TypedArenaChunk<T> {\n     }\n }\n \n+// The arenas start with PAGE-sized chunks, and then each new chunk is twice as\n+// big as its predecessor, up until we reach HUGE_PAGE-sized chunks, whereupon\n+// we stop growing. This scales well, from arenas that are barely used up to\n+// arenas that are used for 100s of MiBs. Note also that the chosen sizes match\n+// the usual sizes of pages and huge pages on Linux.\n const PAGE: usize = 4096;\n+const HUGE_PAGE: usize = 2 * 1024 * 1024;\n \n impl<T> Default for TypedArena<T> {\n     /// Creates a new `TypedArena`.\n@@ -211,6 +216,9 @@ impl<T> TypedArena<T> {\n     #[cold]\n     fn grow(&self, n: usize) {\n         unsafe {\n+            // We need the element size in to convert chunk sizes (ranging from\n+            // PAGE to HUGE_PAGE bytes) to element counts.\n+            let elem_size = cmp::max(1, mem::size_of::<T>());\n             let mut chunks = self.chunks.borrow_mut();\n             let (chunk, mut new_capacity);\n             if let Some(last_chunk) = chunks.last_mut() {\n@@ -221,18 +229,20 @@ impl<T> TypedArena<T> {\n                     self.end.set(last_chunk.end());\n                     return;\n                 } else {\n+                    // If the previous chunk's capacity is less than HUGE_PAGE\n+                    // bytes, then this chunk will be least double the previous\n+                    // chunk's size.\n                     new_capacity = last_chunk.storage.capacity();\n-                    loop {\n+                    if new_capacity < HUGE_PAGE / elem_size {\n                         new_capacity = new_capacity.checked_mul(2).unwrap();\n-                        if new_capacity >= currently_used_cap + n {\n-                            break;\n-                        }\n                     }\n                 }\n             } else {\n-                let elem_size = cmp::max(1, mem::size_of::<T>());\n-                new_capacity = cmp::max(n, PAGE / elem_size);\n+                new_capacity = PAGE / elem_size;\n             }\n+            // Also ensure that this chunk can fit `n`.\n+            new_capacity = cmp::max(n, new_capacity);\n+\n             chunk = TypedArenaChunk::<T>::new(new_capacity);\n             self.ptr.set(chunk.start());\n             self.end.set(chunk.end());\n@@ -347,17 +357,20 @@ impl DroplessArena {\n                     self.end.set(last_chunk.end());\n                     return;\n                 } else {\n+                    // If the previous chunk's capacity is less than HUGE_PAGE\n+                    // bytes, then this chunk will be least double the previous\n+                    // chunk's size.\n                     new_capacity = last_chunk.storage.capacity();\n-                    loop {\n+                    if new_capacity < HUGE_PAGE {\n                         new_capacity = new_capacity.checked_mul(2).unwrap();\n-                        if new_capacity >= used_bytes + needed_bytes {\n-                            break;\n-                        }\n                     }\n                 }\n             } else {\n-                new_capacity = cmp::max(needed_bytes, PAGE);\n+                new_capacity = PAGE;\n             }\n+            // Also ensure that this chunk can fit `needed_bytes`.\n+            new_capacity = cmp::max(needed_bytes, new_capacity);\n+\n             chunk = TypedArenaChunk::<u8>::new(new_capacity);\n             self.ptr.set(chunk.start());\n             self.end.set(chunk.end());"}, {"sha": "79b6304958d51332af85ff9987ba5c8740feb385", "filename": "src/libcore/any.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -446,14 +446,16 @@ impl TypeId {\n /// # Note\n ///\n /// This is intended for diagnostic use. The exact contents and format of the\n-/// string are not specified, other than being a best-effort description of the\n-/// type. For example, `type_name::<Option<String>>()` could return the\n-/// `\"Option<String>\"` or `\"std::option::Option<std::string::String>\"`, but not\n-/// `\"foobar\"`. In addition, the output may change between versions of the\n-/// compiler.\n+/// string returned are not specified, other than being a best-effort\n+/// description of the type. For example, amongst the strings\n+/// that `type_name::<Option<String>>()` might return are `\"Option<String>\"` and\n+/// `\"std::option::Option<std::string::String>\"`.\n ///\n-/// The type name should not be considered a unique identifier of a type;\n-/// multiple types may share the same type name.\n+/// The returned string must not be considered to be a unique identifier of a\n+/// type as multiple types may map to the same type name. Similarly, there is no\n+/// guarantee that all parts of a type will appear in the returned string: for\n+/// example, lifetime specifiers are currently not included. In addition, the\n+/// output may change between versions of the compiler.\n ///\n /// The current implementation uses the same infrastructure as compiler\n /// diagnostics and debuginfo, but this is not guaranteed."}, {"sha": "fad3095f8a3fcd4b4fe1128516aba2afb198781f", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -133,10 +133,9 @@\n //! `Cell<T>`.\n //!\n //! ```\n-//! #![feature(core_intrinsics)]\n //! use std::cell::Cell;\n //! use std::ptr::NonNull;\n-//! use std::intrinsics::abort;\n+//! use std::process::abort;\n //! use std::marker::PhantomData;\n //!\n //! struct Rc<T: ?Sized> {\n@@ -173,7 +172,7 @@\n //!             .strong\n //!             .set(self.strong()\n //!                      .checked_add(1)\n-//!                      .unwrap_or_else(|| unsafe { abort() }));\n+//!                      .unwrap_or_else(|| abort() ));\n //!     }\n //! }\n //!"}, {"sha": "43512f7a2366da9980be7e67612765bbe681e2ab", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -918,7 +918,7 @@ extern \"rust-intrinsic\" {\n \n     /// Aborts the execution of the process.\n     ///\n-    /// The stabilized version of this intrinsic is\n+    /// A more user-friendly and stable version of this operation is\n     /// [`std::process::abort`](../../std/process/fn.abort.html).\n     pub fn abort() -> !;\n "}, {"sha": "d74df82bddd9d97f2709597163b4a74bf9157656", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 411, "deletions": 171, "changes": 582, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -4,175 +4,401 @@ use crate::ops::{self, Add, Sub, Try};\n \n use super::{FusedIterator, TrustedLen};\n \n-/// Objects that can be stepped over in both directions.\n+/// Objects that have a notion of *successor* and *predecessor* operations.\n ///\n-/// The `steps_between` function provides a way to efficiently compare\n-/// two `Step` objects.\n-#[unstable(\n-    feature = \"step_trait\",\n-    reason = \"likely to be replaced by finer-grained traits\",\n-    issue = \"42168\"\n-)]\n-pub trait Step: Clone + PartialOrd + Sized {\n-    /// Returns the number of steps between two step objects. The count is\n-    /// inclusive of `start` and exclusive of `end`.\n-    ///\n-    /// Returns `None` if it is not possible to calculate `steps_between`\n-    /// without overflow.\n+/// The *successor* operation moves towards values that compare greater.\n+/// The *predecessor* operation moves towards values that compare lesser.\n+///\n+/// # Safety\n+///\n+/// This trait is `unsafe` because its implementation must be correct for\n+/// the safety of `unsafe trait TrustedLen` implementations, and the results\n+/// of using this trait can otherwise be trusted by `unsafe` code to be correct\n+/// and fulfill the listed obligations.\n+#[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n+pub unsafe trait Step: Clone + PartialOrd + Sized {\n+    /// Returns the number of *successor* steps required to get from `start` to `end`.\n+    ///\n+    /// Returns `None` if the number of steps would overflow `usize`\n+    /// (or is infinite, or if `end` would never be reached).\n+    ///\n+    /// # Invariants\n+    ///\n+    /// For any `a`, `b`, and `n`:\n+    ///\n+    /// * `steps_between(&a, &b) == Some(n)` if and only if `Step::forward_checked(&a, n) == Some(b)`\n+    /// * `steps_between(&a, &b) == Some(n)` if and only if `Step::backward_checked(&a, n) == Some(a)`\n+    /// * `steps_between(&a, &b) == Some(n)` only if `a <= b`\n+    ///   * Corollary: `steps_between(&a, &b) == Some(0)` if and only if `a == b`\n+    ///   * Note that `a <= b` does _not_ imply `steps_between(&a, &b) != None`;\n+    ///     this is the case wheen it would require more than `usize::MAX` steps to get to `b`\n+    /// * `steps_between(&a, &b) == None` if `a > b`\n     fn steps_between(start: &Self, end: &Self) -> Option<usize>;\n \n-    /// Replaces this step with `1`, returning a clone of itself.\n+    /// Returns the value that would be obtained by taking the *successor*\n+    /// of `self` `count` times.\n+    ///\n+    /// If this would overflow the range of values supported by `Self`, returns `None`.\n     ///\n-    /// The output of this method should always be greater than the output of replace_zero.\n-    fn replace_one(&mut self) -> Self;\n+    /// # Invariants\n+    ///\n+    /// For any `a`, `n`, and `m`:\n+    ///\n+    /// * `Step::forward_checked(a, n).and_then(|x| Step::forward_checked(x, m)) == Step::forward_checked(a, m).and_then(|x| Step::forward_checked(x, n))`\n+    ///\n+    /// For any `a`, `n`, and `m` where `n + m` does not overflow:\n+    ///\n+    /// * `Step::forward_checked(a, n).and_then(|x| Step::forward_checked(x, m)) == Step::forward_checked(a, n + m)`\n+    ///\n+    /// For any `a` and `n`:\n+    ///\n+    /// * `Step::forward_checked(a, n) == (0..n).try_fold(a, |x, _| Step::forward_checked(&x, 1))`\n+    ///   * Corollary: `Step::forward_checked(&a, 0) == Some(a)`\n+    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n+    fn forward_checked(start: Self, count: usize) -> Option<Self>;\n \n-    /// Replaces this step with `0`, returning a clone of itself.\n+    /// Returns the value that would be obtained by taking the *successor*\n+    /// of `self` `count` times.\n+    ///\n+    /// If this would overflow the range of values supported by `Self`,\n+    /// this function is allowed to panic, wrap, or saturate.\n+    /// The suggested behavior is to panic when debug assertions are enabled,\n+    /// and to wrap or saturate otherwise.\n     ///\n-    /// The output of this method should always be less than the output of replace_one.\n-    fn replace_zero(&mut self) -> Self;\n+    /// Unsafe code should not rely on the correctness of behavior after overflow.\n+    ///\n+    /// # Invariants\n+    ///\n+    /// For any `a`, `n`, and `m`, where no overflow occurs:\n+    ///\n+    /// * `Step::forward(Step::forward(a, n), m) == Step::forward(a, n + m)`\n+    ///\n+    /// For any `a` and `n`, where no overflow occurs:\n+    ///\n+    /// * `Step::forward_checked(a, n) == Some(Step::forward(a, n))`\n+    /// * `Step::forward(a, n) == (0..n).fold(a, |x, _| Step::forward(x, 1))`\n+    ///   * Corollary: `Step::forward(a, 0) == a`\n+    /// * `Step::forward(a, n) >= a`\n+    /// * `Step::backward(Step::forward(a, n), n) == a`\n+    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n+    fn forward(start: Self, count: usize) -> Self {\n+        Step::forward_checked(start, count).expect(\"overflow in `Step::forward`\")\n+    }\n \n-    /// Adds one to this step, returning the result.\n-    fn add_one(&self) -> Self;\n+    /// Returns the value that would be obtained by taking the *successor*\n+    /// of `self` `count` times.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is undefined behavior for this operation to overflow the\n+    /// range of values supported by `Self`. If you cannot guarantee that this\n+    /// will not overflow, use `forward` or `forward_checked` instead.\n+    ///\n+    /// # Invariants\n+    ///\n+    /// For any `a`:\n+    ///\n+    /// * if there exists `b` such that `b > a`, it is safe to call `Step::forward_unchecked(a, 1)`\n+    /// * if there exists `b`, `n` such that `steps_between(&a, &b) == Some(n)`,\n+    ///   it is safe to call `Step::forward_unchecked(a, m)` for any `m <= n`.\n+    ///\n+    /// For any `a` and `n`, where no overflow occurs:\n+    ///\n+    /// * `Step::forward_unchecked(a, n)` is equivalent to `Step::forward(a, n)`\n+    #[unstable(feature = \"unchecked_math\", reason = \"niche optimization path\", issue = \"none\")]\n+    unsafe fn forward_unchecked(start: Self, count: usize) -> Self {\n+        Step::forward(start, count)\n+    }\n \n-    /// Subtracts one to this step, returning the result.\n-    fn sub_one(&self) -> Self;\n+    /// Returns the value that would be obtained by taking the *successor*\n+    /// of `self` `count` times.\n+    ///\n+    /// If this would overflow the range of values supported by `Self`, returns `None`.\n+    ///\n+    /// # Invariants\n+    ///\n+    /// For any `a`, `n`, and `m`:\n+    ///\n+    /// * `Step::backward_checked(a, n).and_then(|x| Step::backward_checked(x, m)) == n.checked_add(m).and_then(|x| Step::backward_checked(a, x))`\n+    /// * `Step::backward_checked(a, n).and_then(|x| Step::backward_checked(x, m)) == try { Step::backward_checked(a, n.checked_add(m)?) }`\n+    ///\n+    /// For any `a` and `n`:\n+    ///\n+    /// * `Step::backward_checked(a, n) == (0..n).try_fold(a, |x, _| Step::backward_checked(&x, 1))`\n+    ///   * Corollary: `Step::backward_checked(&a, 0) == Some(a)`\n+    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n+    fn backward_checked(start: Self, count: usize) -> Option<Self>;\n \n-    /// Adds a `usize`, returning `None` on overflow.\n-    fn add_usize(&self, n: usize) -> Option<Self>;\n+    /// Returns the value that would be obtained by taking the *predecessor*\n+    /// of `self` `count` times.\n+    ///\n+    /// If this would overflow the range of values supported by `Self`,\n+    /// this function is allowed to panic, wrap, or saturate.\n+    /// The suggested behavior is to panic when debug assertions are enabled,\n+    /// and to wrap or saturate otherwise.\n+    ///\n+    /// Unsafe code should not rely on the correctness of behavior after overflow.\n+    ///\n+    /// # Invariants\n+    ///\n+    /// For any `a`, `n`, and `m`, where no overflow occurs:\n+    ///\n+    /// * `Step::backward(Step::backward(a, n), m) == Step::backward(a, n + m)`\n+    ///\n+    /// For any `a` and `n`, where no overflow occurs:\n+    ///\n+    /// * `Step::backward_checked(a, n) == Some(Step::backward(a, n))`\n+    /// * `Step::backward(a, n) == (0..n).fold(a, |x, _| Step::backward(x, 1))`\n+    ///   * Corollary: `Step::backward(a, 0) == a`\n+    /// * `Step::backward(a, n) <= a`\n+    /// * `Step::forward(Step::backward(a, n), n) == a`\n+    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n+    fn backward(start: Self, count: usize) -> Self {\n+        Step::backward_checked(start, count).expect(\"overflow in `Step::backward`\")\n+    }\n \n-    /// Subtracts a `usize`, returning `None` on underflow.\n-    fn sub_usize(&self, n: usize) -> Option<Self> {\n-        // this default implementation makes the addition of `sub_usize` a non-breaking change\n-        let _ = n;\n-        unimplemented!()\n+    /// Returns the value that would be obtained by taking the *predecessor*\n+    /// of `self` `count` times.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is undefined behavior for this operation to overflow the\n+    /// range of values supported by `Self`. If you cannot guarantee that this\n+    /// will not overflow, use `backward` or `backward_checked` instead.\n+    ///\n+    /// # Invariants\n+    ///\n+    /// For any `a`:\n+    ///\n+    /// * if there exists `b` such that `b < a`, it is safe to call `Step::backward_unchecked(a, 1)`\n+    /// * if there exists `b`, `n` such that `steps_between(&b, &a) == Some(n)`,\n+    ///   it is safe to call `Step::backward_unchecked(a, m)` for any `m <= n`.\n+    ///\n+    /// For any `a` and `n`, where no overflow occurs:\n+    ///\n+    /// * `Step::backward_unchecked(a, n)` is equivalent to `Step::backward(a, n)`\n+    #[unstable(feature = \"unchecked_math\", reason = \"niche optimization path\", issue = \"none\")]\n+    unsafe fn backward_unchecked(start: Self, count: usize) -> Self {\n+        Step::backward(start, count)\n     }\n }\n \n // These are still macro-generated because the integer literals resolve to different types.\n macro_rules! step_identical_methods {\n     () => {\n         #[inline]\n-        fn replace_one(&mut self) -> Self {\n-            mem::replace(self, 1)\n+        unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n+            start.unchecked_add(n as Self)\n         }\n \n         #[inline]\n-        fn replace_zero(&mut self) -> Self {\n-            mem::replace(self, 0)\n+        unsafe fn backward_unchecked(start: Self, n: usize) -> Self {\n+            start.unchecked_sub(n as Self)\n         }\n \n         #[inline]\n-        fn add_one(&self) -> Self {\n-            Add::add(*self, 1)\n+        fn forward(start: Self, n: usize) -> Self {\n+            // In debug builds, trigger a panic on overflow.\n+            // This should optimize completely out in release builds.\n+            if Self::forward_checked(start, n).is_none() {\n+                let _ = Add::add(Self::MAX, 1);\n+            }\n+            // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.\n+            start.wrapping_add(n as Self)\n         }\n \n         #[inline]\n-        fn sub_one(&self) -> Self {\n-            Sub::sub(*self, 1)\n+        fn backward(start: Self, n: usize) -> Self {\n+            // In debug builds, trigger a panic on overflow.\n+            // This should optimize completely out in release builds.\n+            if Self::backward_checked(start, n).is_none() {\n+                let _ = Sub::sub(Self::MIN, 1);\n+            }\n+            // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.\n+            start.wrapping_sub(n as Self)\n         }\n     };\n }\n \n-macro_rules! step_impl_unsigned {\n-    ($($t:ty)*) => ($(\n-        #[unstable(feature = \"step_trait\",\n-                   reason = \"likely to be replaced by finer-grained traits\",\n-                   issue = \"42168\")]\n-        impl Step for $t {\n-            #[inline]\n-            fn steps_between(start: &$t, end: &$t) -> Option<usize> {\n-                if *start < *end {\n-                    usize::try_from(*end - *start).ok()\n-                } else {\n-                    Some(0)\n+macro_rules! step_integer_impls {\n+    {\n+        narrower than or same width as usize:\n+            $( [ $u_narrower:ident $i_narrower:ident ] ),+;\n+        wider than usize:\n+            $( [ $u_wider:ident $i_wider:ident ] ),+;\n+    } => {\n+        $(\n+            #[allow(unreachable_patterns)]\n+            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n+            unsafe impl Step for $u_narrower {\n+                step_identical_methods!();\n+\n+                #[inline]\n+                fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n+                    if *start <= *end {\n+                        // This relies on $u_narrower <= usize\n+                        Some((*end - *start) as usize)\n+                    } else {\n+                        None\n+                    }\n                 }\n-            }\n \n-            #[inline]\n-            #[allow(unreachable_patterns)]\n-            fn add_usize(&self, n: usize) -> Option<Self> {\n-                match <$t>::try_from(n) {\n-                    Ok(n_as_t) => self.checked_add(n_as_t),\n-                    Err(_) => None,\n+                #[inline]\n+                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n+                    match Self::try_from(n) {\n+                        Ok(n) => start.checked_add(n),\n+                        Err(_) => None, // if n is out of range, `unsigned_start + n` is too\n+                    }\n+                }\n+\n+                #[inline]\n+                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n+                    match Self::try_from(n) {\n+                        Ok(n) => start.checked_sub(n),\n+                        Err(_) => None, // if n is out of range, `unsigned_start - n` is too\n+                    }\n                 }\n             }\n \n-            #[inline]\n             #[allow(unreachable_patterns)]\n-            fn sub_usize(&self, n: usize) -> Option<Self> {\n-                match <$t>::try_from(n) {\n-                    Ok(n_as_t) => self.checked_sub(n_as_t),\n-                    Err(_) => None,\n+            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n+            unsafe impl Step for $i_narrower {\n+                step_identical_methods!();\n+\n+                #[inline]\n+                fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n+                    if *start <= *end {\n+                        // This relies on $i_narrower <= usize\n+                        //\n+                        // Casting to isize extends the width but preserves the sign.\n+                        // Use wrapping_sub in isize space and cast to usize to compute\n+                        // the difference that may not fit inside the range of isize.\n+                        Some((*end as isize).wrapping_sub(*start as isize) as usize)\n+                    } else {\n+                        None\n+                    }\n                 }\n-            }\n \n-            step_identical_methods!();\n-        }\n-    )*)\n-}\n-macro_rules! step_impl_signed {\n-    ($( [$t:ty : $unsigned:ty] )*) => ($(\n-        #[unstable(feature = \"step_trait\",\n-                   reason = \"likely to be replaced by finer-grained traits\",\n-                   issue = \"42168\")]\n-        impl Step for $t {\n-            #[inline]\n-            fn steps_between(start: &$t, end: &$t) -> Option<usize> {\n-                if *start < *end {\n-                    // Use .wrapping_sub and cast to unsigned to compute the\n-                    // difference that may not fit inside the range of $t.\n-                    usize::try_from(end.wrapping_sub(*start) as $unsigned).ok()\n-                } else {\n-                    Some(0)\n+                #[inline]\n+                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n+                    match $u_narrower::try_from(n) {\n+                        Ok(n) => {\n+                            // Wrapping handles cases like\n+                            // `Step::forward(-120_i8, 200) == Some(80_i8)`,\n+                            // even though 200 is out of range for i8.\n+                            let wrapped = start.wrapping_add(n as Self);\n+                            if wrapped >= start {\n+                                Some(wrapped)\n+                            } else {\n+                                None // Addition overflowed\n+                            }\n+                        }\n+                        // If n is out of range of e.g. u8,\n+                        // then it is bigger than the entire range for i8 is wide\n+                        // so `any_i8 + n` necessarily overflows i8.\n+                        Err(_) => None,\n+                    }\n+                }\n+\n+                #[inline]\n+                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n+                    match $u_narrower::try_from(n) {\n+                        Ok(n) => {\n+                            // Wrapping handles cases like\n+                            // `Step::forward(-120_i8, 200) == Some(80_i8)`,\n+                            // even though 200 is out of range for i8.\n+                            let wrapped = start.wrapping_sub(n as Self);\n+                            if wrapped <= start {\n+                                Some(wrapped)\n+                            } else {\n+                                None // Subtraction overflowed\n+                            }\n+                        }\n+                        // If n is out of range of e.g. u8,\n+                        // then it is bigger than the entire range for i8 is wide\n+                        // so `any_i8 - n` necessarily overflows i8.\n+                        Err(_) => None,\n+                    }\n                 }\n             }\n+        )+\n \n-            #[inline]\n+        $(\n             #[allow(unreachable_patterns)]\n-            fn add_usize(&self, n: usize) -> Option<Self> {\n-                match <$unsigned>::try_from(n) {\n-                    Ok(n_as_unsigned) => {\n-                        // Wrapping in unsigned space handles cases like\n-                        // `-120_i8.add_usize(200) == Some(80_i8)`,\n-                        // even though 200_usize is out of range for i8.\n-                        let wrapped = (*self as $unsigned).wrapping_add(n_as_unsigned) as $t;\n-                        if wrapped >= *self {\n-                            Some(wrapped)\n-                        } else {\n-                            None  // Addition overflowed\n-                        }\n+            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n+            unsafe impl Step for $u_wider {\n+                step_identical_methods!();\n+\n+                #[inline]\n+                fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n+                    if *start <= *end {\n+                        usize::try_from(*end - *start).ok()\n+                    } else {\n+                        None\n                     }\n-                    Err(_) => None,\n+                }\n+\n+                #[inline]\n+                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n+                    start.checked_add(n as Self)\n+                }\n+\n+                #[inline]\n+                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n+                    start.checked_sub(n as Self)\n                 }\n             }\n \n-            #[inline]\n             #[allow(unreachable_patterns)]\n-            fn sub_usize(&self, n: usize) -> Option<Self> {\n-                match <$unsigned>::try_from(n) {\n-                    Ok(n_as_unsigned) => {\n-                        // Wrapping in unsigned space handles cases like\n-                        // `80_i8.sub_usize(200) == Some(-120_i8)`,\n-                        // even though 200_usize is out of range for i8.\n-                        let wrapped = (*self as $unsigned).wrapping_sub(n_as_unsigned) as $t;\n-                        if wrapped <= *self {\n-                            Some(wrapped)\n-                        } else {\n-                            None  // Subtraction underflowed\n+            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n+            unsafe impl Step for $i_wider {\n+                step_identical_methods!();\n+\n+                #[inline]\n+                fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n+                    if *start <= *end {\n+                        match end.checked_sub(*start) {\n+                            Some(result) => usize::try_from(result).ok(),\n+                            // If the difference is too big for e.g. i128,\n+                            // it's also gonna be too big for usize with fewer bits.\n+                            None => None,\n                         }\n+                    } else {\n+                        None\n                     }\n-                    Err(_) => None,\n+                }\n+\n+                #[inline]\n+                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n+                    start.checked_add(n as Self)\n+                }\n+\n+                #[inline]\n+                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n+                    start.checked_sub(n as Self)\n                 }\n             }\n+        )+\n+    };\n+}\n \n-            step_identical_methods!();\n-        }\n-    )*)\n+#[cfg(target_pointer_width = \"64\")]\n+step_integer_impls! {\n+    narrower than or same width as usize: [u8 i8], [u16 i16], [u32 i32], [u64 i64], [usize isize];\n+    wider than usize: [u128 i128];\n }\n \n-step_impl_unsigned!(usize u8 u16 u32 u64 u128);\n-step_impl_signed!([isize: usize][i8: u8][i16: u16]);\n-step_impl_signed!([i32: u32][i64: u64][i128: u128]);\n+#[cfg(target_pointer_width = \"32\")]\n+step_integer_impls! {\n+    narrower than or same width as usize: [u8 i8], [u16 i16], [u32 i32], [usize isize];\n+    wider than usize: [u64 i64], [u128 i128];\n+}\n+\n+#[cfg(target_pointer_width = \"16\")]\n+step_integer_impls! {\n+    narrower than or same width as usize: [u8 i8], [u16 i16], [usize isize];\n+    wider than usize: [u32 i32], [u64 i64], [u128 i128];\n+}\n \n macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n@@ -188,55 +414,39 @@ macro_rules! range_incl_exact_iter_impl {\n     )*)\n }\n \n-macro_rules! range_trusted_len_impl {\n-    ($($t:ty)*) => ($(\n-        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-        unsafe impl TrustedLen for ops::Range<$t> { }\n-    )*)\n-}\n-\n-macro_rules! range_incl_trusted_len_impl {\n-    ($($t:ty)*) => ($(\n-        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-        unsafe impl TrustedLen for ops::RangeInclusive<$t> { }\n-    )*)\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Step> Iterator for ops::Range<A> {\n     type Item = A;\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.start < self.end {\n-            // We check for overflow here, even though it can't actually\n-            // happen. Adding this check does however help llvm vectorize loops\n-            // for some ranges that don't get vectorized otherwise,\n-            // and this won't actually result in an extra check in an optimized build.\n-            if let Some(mut n) = self.start.add_usize(1) {\n-                mem::swap(&mut n, &mut self.start);\n-                Some(n)\n-            } else {\n-                None\n-            }\n+            // SAFETY: just checked precondition\n+            // We use the unchecked version here, because\n+            // this helps LLVM vectorize loops for some ranges\n+            // that don't get vectorized otherwise.\n+            let n = unsafe { Step::forward_unchecked(self.start.clone(), 1) };\n+            Some(mem::replace(&mut self.start, n))\n         } else {\n             None\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        match Step::steps_between(&self.start, &self.end) {\n-            Some(hint) => (hint, Some(hint)),\n-            None => (usize::MAX, None),\n+        if self.start < self.end {\n+            let hint = Step::steps_between(&self.start, &self.end);\n+            (hint.unwrap_or(usize::MAX), hint)\n+        } else {\n+            (0, Some(0))\n         }\n     }\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<A> {\n-        if let Some(plus_n) = self.start.add_usize(n) {\n+        if let Some(plus_n) = Step::forward_checked(self.start.clone(), n) {\n             if plus_n < self.end {\n-                self.start = plus_n.add_one();\n+                self.start = Step::forward(plus_n.clone(), 1);\n                 return Some(plus_n);\n             }\n         }\n@@ -262,25 +472,42 @@ impl<A: Step> Iterator for ops::Range<A> {\n }\n \n // These macros generate `ExactSizeIterator` impls for various range types.\n-// Range<{u,i}64> and RangeInclusive<{u,i}{32,64,size}> are excluded\n-// because they cannot guarantee having a length <= usize::MAX, which is\n-// required by ExactSizeIterator.\n-range_exact_iter_impl!(usize u8 u16 u32 isize i8 i16 i32);\n-range_incl_exact_iter_impl!(u8 u16 i8 i16);\n-\n-// These macros generate `TrustedLen` impls.\n //\n-// They need to guarantee that .size_hint() is either exact, or that\n-// the upper bound is None when it does not fit the type limits.\n-range_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 u64 i64 u128 i128);\n-range_incl_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 u64 i64 u128 i128);\n+// * `ExactSizeIterator::len` is required to always return an exact `usize`,\n+//   so no range can be longer than `usize::MAX`.\n+// * For integer types in `Range<_>` this is the case for types narrower than or as wide as `usize`.\n+//   For integer types in `RangeInclusive<_>`\n+//   this is the case for types *strictly narrower* than `usize`\n+//   since e.g. `(0..=u64::MAX).len()` would be `u64::MAX + 1`.\n+range_exact_iter_impl! {\n+    usize u8 u16\n+    isize i8 i16\n+\n+    // These are incorect per the reasoning above,\n+    // but removing them would be a breaking change as they were stabilized in Rust 1.0.0.\n+    // So e.g. `(0..66_000_u32).len()` for example will compile without error or warnings\n+    // on 16-bit platforms, but continue to give a wrong result.\n+    u32\n+    i32\n+}\n+range_incl_exact_iter_impl! {\n+    u8\n+    i8\n+\n+    // These are incorect per the reasoning above,\n+    // but removing them would be a breaking change as they were stabilized in Rust 1.26.0.\n+    // So e.g. `(0..=u16::MAX).len()` for example will compile without error or warnings\n+    // on 16-bit platforms, but continue to give a wrong result.\n+    u16\n+    i16\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.start < self.end {\n-            self.end = self.end.sub_one();\n+            self.end = Step::backward(self.end.clone(), 1);\n             Some(self.end.clone())\n         } else {\n             None\n@@ -289,9 +516,9 @@ impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n \n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<A> {\n-        if let Some(minus_n) = self.end.sub_usize(n) {\n+        if let Some(minus_n) = Step::backward_checked(self.end.clone(), n) {\n             if minus_n > self.start {\n-                self.end = minus_n.sub_one();\n+                self.end = Step::backward(minus_n, 1);\n                 return Some(self.end.clone());\n             }\n         }\n@@ -301,6 +528,9 @@ impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n     }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A: Step> TrustedLen for ops::Range<A> {}\n+\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::Range<A> {}\n \n@@ -310,9 +540,8 @@ impl<A: Step> Iterator for ops::RangeFrom<A> {\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        let mut n = self.start.add_one();\n-        mem::swap(&mut n, &mut self.start);\n-        Some(n)\n+        let n = Step::forward(self.start.clone(), 1);\n+        Some(mem::replace(&mut self.start, n))\n     }\n \n     #[inline]\n@@ -322,8 +551,16 @@ impl<A: Step> Iterator for ops::RangeFrom<A> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<A> {\n-        let plus_n = self.start.add_usize(n).expect(\"overflow in RangeFrom::nth\");\n-        self.start = plus_n.add_one();\n+        // If we would jump over the maximum value, panic immediately.\n+        // This is consistent with behavior before the Step redesign,\n+        // even though it's inconsistent with n `next` calls.\n+        // To get consistent behavior, change it to use `forward` instead.\n+        // This change should go through FCP separately to the redesign, so is for now left as a\n+        // FIXME: make this consistent\n+        let plus_n =\n+            Step::forward_checked(self.start.clone(), n).expect(\"overflow in RangeFrom::nth\");\n+        // The final step should always be debug-checked.\n+        self.start = Step::forward(plus_n.clone(), 1);\n         Some(plus_n)\n     }\n }\n@@ -345,7 +582,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         }\n         let is_iterating = self.start < self.end;\n         Some(if is_iterating {\n-            let n = self.start.add_one();\n+            let n = Step::forward(self.start.clone(), 1);\n             mem::replace(&mut self.start, n)\n         } else {\n             self.exhausted = true;\n@@ -371,12 +608,12 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n             return None;\n         }\n \n-        if let Some(plus_n) = self.start.add_usize(n) {\n+        if let Some(plus_n) = Step::forward_checked(self.start.clone(), n) {\n             use crate::cmp::Ordering::*;\n \n             match plus_n.partial_cmp(&self.end) {\n                 Some(Less) => {\n-                    self.start = plus_n.add_one();\n+                    self.start = Step::forward(plus_n.clone(), 1);\n                     return Some(plus_n);\n                 }\n                 Some(Equal) => {\n@@ -407,7 +644,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         let mut accum = init;\n \n         while self.start < self.end {\n-            let n = self.start.add_one();\n+            let n = Step::forward(self.start.clone(), 1);\n             let n = mem::replace(&mut self.start, n);\n             accum = f(accum, n)?;\n         }\n@@ -446,7 +683,7 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n         }\n         let is_iterating = self.start < self.end;\n         Some(if is_iterating {\n-            let n = self.end.sub_one();\n+            let n = Step::backward(self.end.clone(), 1);\n             mem::replace(&mut self.end, n)\n         } else {\n             self.exhausted = true;\n@@ -460,12 +697,12 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n             return None;\n         }\n \n-        if let Some(minus_n) = self.end.sub_usize(n) {\n+        if let Some(minus_n) = Step::backward_checked(self.end.clone(), n) {\n             use crate::cmp::Ordering::*;\n \n             match minus_n.partial_cmp(&self.start) {\n                 Some(Greater) => {\n-                    self.end = minus_n.sub_one();\n+                    self.end = Step::backward(minus_n.clone(), 1);\n                     return Some(minus_n);\n                 }\n                 Some(Equal) => {\n@@ -496,7 +733,7 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n         let mut accum = init;\n \n         while self.start < self.end {\n-            let n = self.end.sub_one();\n+            let n = Step::backward(self.end.clone(), 1);\n             let n = mem::replace(&mut self.end, n);\n             accum = f(accum, n)?;\n         }\n@@ -511,5 +748,8 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A: Step> TrustedLen for ops::RangeInclusive<A> {}\n+\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::RangeInclusive<A> {}"}, {"sha": "447db405c02805d040ff8ade6918e3e1e883f9ec", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -333,7 +333,7 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n-        for x in self {\n+        while let Some(x) = self.next() {\n             if n == 0 {\n                 return Some(x);\n             }"}, {"sha": "a9ba3908c38982a1e4014e0bf6efb09e4c068456", "filename": "src/libcore/iter/traits/marker.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -13,6 +13,7 @@\n /// [`Iterator::fuse`]: ../../std/iter/trait.Iterator.html#method.fuse\n /// [`Fuse`]: ../../std/iter/struct.Fuse.html\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n+#[rustc_unsafe_specialization_marker]\n pub trait FusedIterator: Iterator {}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -38,6 +39,7 @@ impl<I: FusedIterator + ?Sized> FusedIterator for &mut I {}\n /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n /// [`.size_hint`]: ../../std/iter/trait.Iterator.html#method.size_hint\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+#[rustc_unsafe_specialization_marker]\n pub unsafe trait TrustedLen: Iterator {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]"}, {"sha": "339b07119c6d59f1de428ecfeda7fcd05486554f", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -363,6 +363,13 @@ pub trait StructuralEq {\n /// [impls]: #implementors\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"copy\"]\n+// FIXME(matthewjasper) This allows copying a type that doesn't implement\n+// `Copy` because of unsatisfied lifetime bounds (copying `A<'_>` when only\n+// `A<'static>: Copy` and `A<'_>: Clone`).\n+// We have this attribute here for now only because there are quite a few\n+// existing specializations on `Copy` that already exist in the standard\n+// library, and there's no way to safely have this behavior right now.\n+#[rustc_unsafe_specialization_marker]\n pub trait Copy: Clone {\n     // Empty.\n }"}, {"sha": "18767c482c77ea47cd863685db33ee1110ffe1dc", "filename": "src/libcore/mem/manually_drop.rs", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmanually_drop.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -2,19 +2,23 @@ use crate::ops::{Deref, DerefMut};\n use crate::ptr;\n \n /// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n-///\n /// This wrapper is 0-cost.\n ///\n /// `ManuallyDrop<T>` is subject to the same layout optimizations as `T`.\n /// As a consequence, it has *no effect* on the assumptions that the compiler makes\n-/// about all values being initialized at their type.  In particular, initializing\n-/// a `ManuallyDrop<&mut T>` with [`mem::zeroed`] is undefined behavior.\n+/// about its contents. For example, initializing a `ManuallyDrop<&mut T>`\n+/// with [`mem::zeroed`] is undefined behavior.\n /// If you need to handle uninitialized data, use [`MaybeUninit<T>`] instead.\n ///\n+/// Note that accessing the value inside a `ManuallyDrop<T>` is safe.\n+/// This means that a `ManuallyDrop<T>` whose content has been dropped must not\n+/// be exposed through a public safe API.\n+/// Correspondingly, `ManuallyDrop::drop` is unsafe.\n+///\n /// # Examples\n ///\n-/// This wrapper helps with explicitly documenting the drop order dependencies between fields of\n-/// the type:\n+/// This wrapper can be used to enforce a particular drop order on fields, regardless\n+/// of how they are defined in the struct:\n ///\n /// ```rust\n /// use std::mem::ManuallyDrop;\n@@ -43,8 +47,18 @@ use crate::ptr;\n /// }\n /// ```\n ///\n+/// However, care should be taken when using this pattern as it can lead to *leak amplification*.\n+/// In this example, if the `Drop` implementation for `Peach` were to panic, the `banana` field\n+/// would also be leaked.\n+///\n+/// In contrast, the automatically-generated compiler drop implementation would have ensured\n+/// that all fields are dropped even in the presence of panics. This is especially important when\n+/// working with [pinned] data, where reusing the memory without calling the destructor could lead\n+/// to Undefined Behaviour.\n+///\n /// [`mem::zeroed`]: fn.zeroed.html\n /// [`MaybeUninit<T>`]: union.MaybeUninit.html\n+/// [pinned]: ../pin/index.html\n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n #[lang = \"manually_drop\"]\n #[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -113,19 +127,28 @@ impl<T> ManuallyDrop<T> {\n }\n \n impl<T: ?Sized> ManuallyDrop<T> {\n-    /// Manually drops the contained value.\n+    /// Manually drops the contained value. This is exactly equivalent to calling\n+    /// [`ptr::drop_in_place`] with a pointer to the contained value. As such, unless\n+    /// the contained value is a packed struct, the destructor will be called in-place\n+    /// without moving the value, and thus can be used to safely drop [pinned] data.\n     ///\n     /// If you have ownership of the value, you can use [`ManuallyDrop::into_inner`] instead.\n     ///\n     /// # Safety\n     ///\n-    /// This function runs the destructor of the contained value and thus the wrapped value\n-    /// now represents uninitialized data. It is up to the user of this method to ensure the\n-    /// uninitialized data is not actually used.\n-    /// In particular, this function can only be called at most once\n-    /// for a given instance of `ManuallyDrop<T>`.\n+    /// This function runs the destructor of the contained value. Other than changes made by\n+    /// the destructor itself, the memory is left unchanged, and so as far as the compiler is\n+    /// concerned still holds a bit-pattern which is valid for the type `T`.\n+    ///\n+    /// However, this \"zombie\" value should not be exposed to safe code, and this function\n+    /// should not be called more than once. To use a value after it's been dropped, or drop\n+    /// a value multiple times, can cause Undefined Behavior (depending on what `drop` does).\n+    /// This is normally prevented by the type system, but users of `ManuallyDrop` must\n+    /// uphold those guarantees without assistance from the compiler.\n     ///\n     /// [`ManuallyDrop::into_inner`]: #method.into_inner\n+    /// [`ptr::drop_in_place`]: ../ptr/fn.drop_in_place.html\n+    /// [pinned]: ../pin/index.html\n     #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {"}, {"sha": "434569020d2a8b1b00cdfce94c6648113d0af2d8", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -367,7 +367,7 @@ impl f32 {\n     /// Infinity (\u221e).\n     #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n     pub const INFINITY: f32 = 1.0_f32 / 0.0_f32;\n-    /// Negative infinity (-\u221e).\n+    /// Negative infinity (\u2212\u221e).\n     #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n     pub const NEG_INFINITY: f32 = -1.0_f32 / 0.0_f32;\n "}, {"sha": "6476ddb4541ff8900952247be05e5082c3ba94e3", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -366,7 +366,7 @@ impl f64 {\n     /// Infinity (\u221e).\n     #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n     pub const INFINITY: f64 = 1.0_f64 / 0.0_f64;\n-    /// Negative infinity (-\u221e).\n+    /// Negative infinity (\u2212\u221e).\n     #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n     pub const NEG_INFINITY: f64 = -1.0_f64 / 0.0_f64;\n "}, {"sha": "9e1971c9a945b27fff7408e984ad05a1ebb65653", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 110, "deletions": 8, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -749,6 +749,23 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Unchecked integer addition. Computes `self + rhs, assuming overflow\n+cannot occur. This results in undefined behavior when `self + rhs > \", stringify!($SelfT),\n+\"::max_value()` or `self + rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+            #[unstable(\n+                feature = \"unchecked_math\",\n+                reason = \"niche optimization path\",\n+                issue = \"none\",\n+            )]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub unsafe fn unchecked_add(self, rhs: Self) -> Self {\n+                intrinsics::unchecked_add(self, rhs)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked integer subtraction. Computes `self - rhs`, returning `None` if\n overflow occurred.\n@@ -774,6 +791,23 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Unchecked integer subtraction. Computes `self - rhs, assuming overflow\n+cannot occur. This results in undefined behavior when `self - rhs > \", stringify!($SelfT),\n+\"::max_value()` or `self - rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+            #[unstable(\n+                feature = \"unchecked_math\",\n+                reason = \"niche optimization path\",\n+                issue = \"none\",\n+            )]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n+                intrinsics::unchecked_sub(self, rhs)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked integer multiplication. Computes `self * rhs`, returning `None` if\n overflow occurred.\n@@ -799,6 +833,23 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Unchecked integer multiplication. Computes `self * rhs, assuming overflow\n+cannot occur. This results in undefined behavior when `self * rhs > \", stringify!($SelfT),\n+\"::max_value()` or `self * rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+            #[unstable(\n+                feature = \"unchecked_math\",\n+                reason = \"niche optimization path\",\n+                issue = \"none\",\n+            )]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n+                intrinsics::unchecked_mul(self, rhs)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`\n or the division results in overflow.\n@@ -1448,8 +1499,8 @@ any high-order bits of `rhs` that would cause the shift to exceed the bitwidth o\n \n Note that this is *not* the same as a rotate-left; the RHS of a wrapping shift-left is restricted to\n the range of the type, rather than the bits shifted out of the LHS being returned to the other end.\n-The primitive integer types all implement a `rotate_left` function, which may be what you want\n-instead.\n+The primitive integer types all implement a `[`rotate_left`](#method.rotate_left) function,\n+which may be what you want instead.\n \n # Examples\n \n@@ -1480,8 +1531,8 @@ removes any high-order bits of `rhs` that would cause the shift to exceed the bi\n \n Note that this is *not* the same as a rotate-right; the RHS of a wrapping shift-right is restricted\n to the range of the type, rather than the bits shifted out of the LHS being returned to the other\n-end. The primitive integer types all implement a `rotate_right` function, which may be what you want\n-instead.\n+end. The primitive integer types all implement a [`rotate_right`](#method.rotate_right) function,\n+which may be what you want instead.\n \n # Examples\n \n@@ -2936,6 +2987,23 @@ assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\", $EndFeat\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Unchecked integer addition. Computes `self + rhs, assuming overflow\n+cannot occur. This results in undefined behavior when `self + rhs > \", stringify!($SelfT),\n+\"::max_value()` or `self + rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+            #[unstable(\n+                feature = \"unchecked_math\",\n+                reason = \"niche optimization path\",\n+                issue = \"none\",\n+            )]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub unsafe fn unchecked_add(self, rhs: Self) -> Self {\n+                intrinsics::unchecked_add(self, rhs)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked integer subtraction. Computes `self - rhs`, returning\n `None` if overflow occurred.\n@@ -2959,6 +3027,23 @@ assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\", $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Unchecked integer subtraction. Computes `self - rhs, assuming overflow\n+cannot occur. This results in undefined behavior when `self - rhs > \", stringify!($SelfT),\n+\"::max_value()` or `self - rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+            #[unstable(\n+                feature = \"unchecked_math\",\n+                reason = \"niche optimization path\",\n+                issue = \"none\",\n+            )]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n+                intrinsics::unchecked_sub(self, rhs)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked integer multiplication. Computes `self * rhs`, returning\n `None` if overflow occurred.\n@@ -2982,6 +3067,23 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\", $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Unchecked integer multiplication. Computes `self * rhs, assuming overflow\n+cannot occur. This results in undefined behavior when `self * rhs > \", stringify!($SelfT),\n+\"::max_value()` or `self * rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+            #[unstable(\n+                feature = \"unchecked_math\",\n+                reason = \"niche optimization path\",\n+                issue = \"none\",\n+            )]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n+                intrinsics::unchecked_mul(self, rhs)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked integer division. Computes `self / rhs`, returning `None`\n if `rhs == 0`.\n@@ -3508,8 +3610,8 @@ Note that this is *not* the same as a rotate-left; the\n RHS of a wrapping shift-left is restricted to the range\n of the type, rather than the bits shifted out of the LHS\n being returned to the other end. The primitive integer\n-types all implement a `rotate_left` function, which may\n-be what you want instead.\n+types all implement a [`rotate_left`](#method.rotate_left) function,\n+which may be what you want instead.\n \n # Examples\n \n@@ -3542,8 +3644,8 @@ Note that this is *not* the same as a rotate-right; the\n RHS of a wrapping shift-right is restricted to the range\n of the type, rather than the bits shifted out of the LHS\n being returned to the other end. The primitive integer\n-types all implement a `rotate_right` function, which may\n-be what you want instead.\n+types all implement a [`rotate_right`](#method.rotate_right) function,\n+which may be what you want instead.\n \n # Examples\n "}, {"sha": "e8483875c97e5b87eebea50b5b4bd253ab6914d5", "filename": "src/libcore/option.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1357,20 +1357,65 @@ impl<'a, T> IntoIterator for &'a mut Option<T> {\n \n #[stable(since = \"1.12.0\", feature = \"option_from\")]\n impl<T> From<T> for Option<T> {\n+    /// Copies `val` into a new `Some`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let o: Option<u8> = Option::from(67);\n+    ///\n+    /// assert_eq!(Some(67), o);\n+    /// ```\n     fn from(val: T) -> Option<T> {\n         Some(val)\n     }\n }\n \n #[stable(feature = \"option_ref_from_ref_option\", since = \"1.30.0\")]\n impl<'a, T> From<&'a Option<T>> for Option<&'a T> {\n+    /// Converts from `&Option<T>` to `Option<&T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, preserving the original.\n+    /// The [`map`] method takes the `self` argument by value, consuming the original,\n+    /// so this technique uses `as_ref` to first take an `Option` to a reference\n+    /// to the value inside the original.\n+    ///\n+    /// [`map`]: ../../std/option/enum.Option.html#method.map\n+    /// [`String`]: ../../std/string/struct.String.html\n+    /// [`usize`]: ../../std/primitive.usize.html\n+    ///\n+    /// ```\n+    /// let s: Option<String> = Some(String::from(\"Hello, Rustaceans!\"));\n+    /// let o: Option<usize> = Option::from(&s).map(|ss: &String| ss.len());\n+    ///\n+    /// println!(\"Can still print s: {:?}\", s);\n+    ///\n+    /// assert_eq!(o, Some(18));\n+    /// ```\n     fn from(o: &'a Option<T>) -> Option<&'a T> {\n         o.as_ref()\n     }\n }\n \n #[stable(feature = \"option_ref_from_ref_option\", since = \"1.30.0\")]\n impl<'a, T> From<&'a mut Option<T>> for Option<&'a mut T> {\n+    /// Converts from `&mut Option<T>` to `Option<&mut T>`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut s = Some(String::from(\"Hello\"));\n+    /// let o: Option<&mut String> = Option::from(&mut s);\n+    ///\n+    /// match o {\n+    ///     Some(t) => *t = String::from(\"Hello, Rustaceans!\"),\n+    ///     None => (),\n+    /// }\n+    ///\n+    /// assert_eq!(s, Some(String::from(\"Hello, Rustaceans!\")));\n+    /// ```\n     fn from(o: &'a mut Option<T>) -> Option<&'a mut T> {\n         o.as_mut()\n     }"}, {"sha": "16739b4a1afdf9628f12a713bb0a7b95acfe01a0", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -39,8 +39,12 @@ use crate::panic::{Location, PanicInfo};\n #[lang = \"panic\"] // needed by codegen for panic on overflow and other `Assert` MIR terminators\n pub fn panic(expr: &str) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n+        // remove `unsafe` (and safety comment) on bootstrap bump\n+        #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n         // SAFETY: the `abort` intrinsic has no requirements to be called.\n-        unsafe { super::intrinsics::abort() }\n+        unsafe {\n+            super::intrinsics::abort()\n+        }\n     }\n \n     // Use Arguments::new_v1 instead of format_args!(\"{}\", expr) to potentially\n@@ -58,8 +62,12 @@ pub fn panic(expr: &str) -> ! {\n #[lang = \"panic_bounds_check\"] // needed by codegen for panic on OOB array/slice access\n fn panic_bounds_check(index: usize, len: usize) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n+        // remove `unsafe` (and safety comment) on bootstrap bump\n+        #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n         // SAFETY: the `abort` intrinsic has no requirements to be called.\n-        unsafe { super::intrinsics::abort() }\n+        unsafe {\n+            super::intrinsics::abort()\n+        }\n     }\n \n     panic!(\"index out of bounds: the len is {} but the index is {}\", len, index)\n@@ -72,8 +80,12 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n #[track_caller]\n pub fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n+        // remove `unsafe` (and safety comment) on bootstrap bump\n+        #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n         // SAFETY: the `abort` intrinsic has no requirements to be called.\n-        unsafe { super::intrinsics::abort() }\n+        unsafe {\n+            super::intrinsics::abort()\n+        }\n     }\n \n     // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call"}, {"sha": "ecc70adda4111c764bb084f1bcab5bc907a772b2", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -110,11 +110,17 @@ mod mut_ptr;\n ///   as the compiler doesn't need to prove that it's sound to elide the\n ///   copy.\n ///\n+/// * It can be used to drop [pinned] data when `T` is not `repr(packed)`\n+///   (pinned data must not be moved before it is dropped).\n+///\n /// Unaligned values cannot be dropped in place, they must be copied to an aligned\n-/// location first using [`ptr::read_unaligned`].\n+/// location first using [`ptr::read_unaligned`]. For packed structs, this move is\n+/// done automatically by the compiler. This means the fields of packed structs\n+/// are not dropped in-place.\n ///\n /// [`ptr::read`]: ../ptr/fn.read.html\n /// [`ptr::read_unaligned`]: ../ptr/fn.read_unaligned.html\n+/// [pinned]: ../pin/index.html\n ///\n /// # Safety\n ///"}, {"sha": "3386f83ec810fb36035efcbe4b9ab4915c433c1f", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 105, "deletions": 17, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -3179,6 +3179,7 @@ macro_rules! is_empty {\n         $self.ptr.as_ptr() as *const T == $self.end\n     };\n }\n+\n // To get rid of some bounds checks (see `position`), we compute the length in a somewhat\n // unexpected way. (Tested by `codegen/slice-position-bounds-check`.)\n macro_rules! len {\n@@ -3347,40 +3348,127 @@ macro_rules! iterator {\n                 self.next_back()\n             }\n \n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile.\n+            #[inline]\n+            fn for_each<F>(mut self, mut f: F)\n+            where\n+                Self: Sized,\n+                F: FnMut(Self::Item),\n+            {\n+                while let Some(x) = self.next() {\n+                    f(x);\n+                }\n+            }\n+\n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile.\n+            #[inline]\n+            fn all<F>(&mut self, mut f: F) -> bool\n+            where\n+                Self: Sized,\n+                F: FnMut(Self::Item) -> bool,\n+            {\n+                while let Some(x) = self.next() {\n+                    if !f(x) {\n+                        return false;\n+                    }\n+                }\n+                true\n+            }\n+\n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile.\n+            #[inline]\n+            fn any<F>(&mut self, mut f: F) -> bool\n+            where\n+                Self: Sized,\n+                F: FnMut(Self::Item) -> bool,\n+            {\n+                while let Some(x) = self.next() {\n+                    if f(x) {\n+                        return true;\n+                    }\n+                }\n+                false\n+            }\n+\n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile.\n+            #[inline]\n+            fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n+            where\n+                Self: Sized,\n+                P: FnMut(&Self::Item) -> bool,\n+            {\n+                while let Some(x) = self.next() {\n+                    if predicate(&x) {\n+                        return Some(x);\n+                    }\n+                }\n+                None\n+            }\n+\n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile.\n+            #[inline]\n+            fn find_map<B, F>(&mut self, mut f: F) -> Option<B>\n+            where\n+                Self: Sized,\n+                F: FnMut(Self::Item) -> Option<B>,\n+            {\n+                while let Some(x) = self.next() {\n+                    if let Some(y) = f(x) {\n+                        return Some(y);\n+                    }\n+                }\n+                None\n+            }\n+\n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile. Also, the `assume` avoids a bounds check.\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n                 Self: Sized,\n                 P: FnMut(Self::Item) -> bool,\n             {\n-                // The addition might panic on overflow.\n                 let n = len!(self);\n-                self.try_fold(0, move |i, x| {\n-                    if predicate(x) { Err(i) }\n-                    else { Ok(i + 1) }\n-                }).err()\n-                    .map(|i| {\n+                let mut i = 0;\n+                while let Some(x) = self.next() {\n+                    if predicate(x) {\n                         unsafe { assume(i < n) };\n-                        i\n-                    })\n+                        return Some(i);\n+                    }\n+                    i += 1;\n+                }\n+                None\n             }\n \n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile. Also, the `assume` avoids a bounds check.\n             #[inline]\n             fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                 P: FnMut(Self::Item) -> bool,\n                 Self: Sized + ExactSizeIterator + DoubleEndedIterator\n             {\n-                // No need for an overflow check here, because `ExactSizeIterator`\n                 let n = len!(self);\n-                self.try_rfold(n, move |i, x| {\n-                    let i = i - 1;\n-                    if predicate(x) { Err(i) }\n-                    else { Ok(i) }\n-                }).err()\n-                    .map(|i| {\n+                let mut i = n;\n+                while let Some(x) = self.next_back() {\n+                    i -= 1;\n+                    if predicate(x) {\n                         unsafe { assume(i < n) };\n-                        i\n-                    })\n+                        return Some(i);\n+                    }\n+                }\n+                None\n             }\n \n             $($extra)*"}, {"sha": "52cf068f0a56720c362035ff494b6453fb35c51f", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 94, "deletions": 27, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -2139,6 +2139,24 @@ fn test_range_inclusive_nth_back() {\n     assert_eq!(ExactSizeIterator::is_empty(&r), true);\n }\n \n+#[test]\n+fn test_range_len() {\n+    assert_eq!((0..10_u8).len(), 10);\n+    assert_eq!((9..10_u8).len(), 1);\n+    assert_eq!((10..10_u8).len(), 0);\n+    assert_eq!((11..10_u8).len(), 0);\n+    assert_eq!((100..10_u8).len(), 0);\n+}\n+\n+#[test]\n+fn test_range_inclusive_len() {\n+    assert_eq!((0..=10_u8).len(), 11);\n+    assert_eq!((9..=10_u8).len(), 2);\n+    assert_eq!((10..=10_u8).len(), 1);\n+    assert_eq!((11..=10_u8).len(), 0);\n+    assert_eq!((100..=10_u8).len(), 0);\n+}\n+\n #[test]\n fn test_range_step() {\n     #![allow(deprecated)]\n@@ -2509,42 +2527,91 @@ fn test_chain_fold() {\n }\n \n #[test]\n-fn test_step_replace_unsigned() {\n-    let mut x = 4u32;\n-    let y = x.replace_zero();\n-    assert_eq!(x, 0);\n-    assert_eq!(y, 4);\n+fn test_steps_between() {\n+    assert_eq!(Step::steps_between(&20_u8, &200_u8), Some(180_usize));\n+    assert_eq!(Step::steps_between(&-20_i8, &80_i8), Some(100_usize));\n+    assert_eq!(Step::steps_between(&-120_i8, &80_i8), Some(200_usize));\n+    assert_eq!(Step::steps_between(&20_u32, &4_000_100_u32), Some(4_000_080_usize));\n+    assert_eq!(Step::steps_between(&-20_i32, &80_i32), Some(100_usize));\n+    assert_eq!(Step::steps_between(&-2_000_030_i32, &2_000_050_i32), Some(4_000_080_usize));\n \n-    x = 5;\n-    let y = x.replace_one();\n-    assert_eq!(x, 1);\n-    assert_eq!(y, 5);\n+    // Skip u64/i64 to avoid differences with 32-bit vs 64-bit platforms\n+\n+    assert_eq!(Step::steps_between(&20_u128, &200_u128), Some(180_usize));\n+    assert_eq!(Step::steps_between(&-20_i128, &80_i128), Some(100_usize));\n+    if cfg!(target_pointer_width = \"64\") {\n+        assert_eq!(Step::steps_between(&10_u128, &0x1_0000_0000_0000_0009_u128), Some(usize::MAX));\n+    }\n+    assert_eq!(Step::steps_between(&10_u128, &0x1_0000_0000_0000_000a_u128), None);\n+    assert_eq!(Step::steps_between(&10_i128, &0x1_0000_0000_0000_000a_i128), None);\n+    assert_eq!(\n+        Step::steps_between(&-0x1_0000_0000_0000_0000_i128, &0x1_0000_0000_0000_0000_i128,),\n+        None,\n+    );\n }\n \n #[test]\n-fn test_step_replace_signed() {\n-    let mut x = 4i32;\n-    let y = x.replace_zero();\n-    assert_eq!(x, 0);\n-    assert_eq!(y, 4);\n+fn test_step_forward() {\n+    assert_eq!(Step::forward_checked(55_u8, 200_usize), Some(255_u8));\n+    assert_eq!(Step::forward_checked(252_u8, 200_usize), None);\n+    assert_eq!(Step::forward_checked(0_u8, 256_usize), None);\n+    assert_eq!(Step::forward_checked(-110_i8, 200_usize), Some(90_i8));\n+    assert_eq!(Step::forward_checked(-110_i8, 248_usize), None);\n+    assert_eq!(Step::forward_checked(-126_i8, 256_usize), None);\n+\n+    assert_eq!(Step::forward_checked(35_u16, 100_usize), Some(135_u16));\n+    assert_eq!(Step::forward_checked(35_u16, 65500_usize), Some(u16::MAX));\n+    assert_eq!(Step::forward_checked(36_u16, 65500_usize), None);\n+    assert_eq!(Step::forward_checked(-110_i16, 200_usize), Some(90_i16));\n+    assert_eq!(Step::forward_checked(-20_030_i16, 50_050_usize), Some(30_020_i16));\n+    assert_eq!(Step::forward_checked(-10_i16, 40_000_usize), None);\n+    assert_eq!(Step::forward_checked(-10_i16, 70_000_usize), None);\n \n-    x = 5;\n-    let y = x.replace_one();\n-    assert_eq!(x, 1);\n-    assert_eq!(y, 5);\n+    assert_eq!(Step::forward_checked(10_u128, 70_000_usize), Some(70_010_u128));\n+    assert_eq!(Step::forward_checked(10_i128, 70_030_usize), Some(70_040_i128));\n+    assert_eq!(\n+        Step::forward_checked(0xffff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_u128, 0xff_usize),\n+        Some(u128::MAX),\n+    );\n+    assert_eq!(\n+        Step::forward_checked(0xffff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_u128, 0x100_usize),\n+        None\n+    );\n+    assert_eq!(\n+        Step::forward_checked(0x7fff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_i128, 0xff_usize),\n+        Some(i128::MAX),\n+    );\n+    assert_eq!(\n+        Step::forward_checked(0x7fff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_i128, 0x100_usize),\n+        None\n+    );\n }\n \n #[test]\n-fn test_step_replace_no_between() {\n-    let mut x = 4u128;\n-    let y = x.replace_zero();\n-    assert_eq!(x, 0);\n-    assert_eq!(y, 4);\n+fn test_step_backward() {\n+    assert_eq!(Step::backward_checked(255_u8, 200_usize), Some(55_u8));\n+    assert_eq!(Step::backward_checked(100_u8, 200_usize), None);\n+    assert_eq!(Step::backward_checked(255_u8, 256_usize), None);\n+    assert_eq!(Step::backward_checked(90_i8, 200_usize), Some(-110_i8));\n+    assert_eq!(Step::backward_checked(110_i8, 248_usize), None);\n+    assert_eq!(Step::backward_checked(127_i8, 256_usize), None);\n+\n+    assert_eq!(Step::backward_checked(135_u16, 100_usize), Some(35_u16));\n+    assert_eq!(Step::backward_checked(u16::MAX, 65500_usize), Some(35_u16));\n+    assert_eq!(Step::backward_checked(10_u16, 11_usize), None);\n+    assert_eq!(Step::backward_checked(90_i16, 200_usize), Some(-110_i16));\n+    assert_eq!(Step::backward_checked(30_020_i16, 50_050_usize), Some(-20_030_i16));\n+    assert_eq!(Step::backward_checked(-10_i16, 40_000_usize), None);\n+    assert_eq!(Step::backward_checked(-10_i16, 70_000_usize), None);\n \n-    x = 5;\n-    let y = x.replace_one();\n-    assert_eq!(x, 1);\n-    assert_eq!(y, 5);\n+    assert_eq!(Step::backward_checked(70_010_u128, 70_000_usize), Some(10_u128));\n+    assert_eq!(Step::backward_checked(70_020_i128, 70_030_usize), Some(-10_i128));\n+    assert_eq!(Step::backward_checked(10_u128, 7_usize), Some(3_u128));\n+    assert_eq!(Step::backward_checked(10_u128, 11_usize), None);\n+    assert_eq!(\n+        Step::backward_checked(-0x7fff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_i128, 0x100_usize),\n+        Some(i128::MIN)\n+    );\n }\n \n #[test]"}, {"sha": "d636542d699f932a232a52311d8e139c58a4b252", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -22,6 +22,7 @@\n #![feature(slice_partition_at_index)]\n #![feature(specialization)]\n #![feature(step_trait)]\n+#![feature(step_trait_ext)]\n #![feature(str_internals)]\n #![feature(test)]\n #![feature(trusted_len)]"}, {"sha": "b1e87a7cac26a5313a7fc371c19032c052daaedb", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -327,5 +327,8 @@ pub unsafe fn cleanup(payload: *mut u8) -> Box<dyn Any + Send> {\n #[lang = \"eh_personality\"]\n #[cfg(not(test))]\n fn rust_eh_personality() {\n-    unsafe { core::intrinsics::abort() }\n+    #[cfg_attr(not(bootstrap), allow(unused_unsafe))] // remove `unsafe` on bootstrap bump\n+    unsafe {\n+        core::intrinsics::abort()\n+    }\n }"}, {"sha": "283aa25b0ea13e1603903972505699c560f4d89a", "filename": "src/libproc_macro/bridge/client.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -202,10 +202,16 @@ impl Clone for Literal {\n     }\n }\n \n-// FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n impl fmt::Debug for Literal {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.debug())\n+        f.debug_struct(\"Literal\")\n+            // format the kind without quotes, as in `kind: Float`\n+            .field(\"kind\", &format_args!(\"{}\", &self.debug_kind()))\n+            .field(\"symbol\", &self.symbol())\n+            // format `Some(\"...\")` on one line even in {:#?} mode\n+            .field(\"suffix\", &format_args!(\"{:?}\", &self.suffix()))\n+            .field(\"span\", &self.span())\n+            .finish()\n     }\n }\n "}, {"sha": "bf0d8fcee5b8f4cd31b9fe908f0316874c2a7792", "filename": "src/libproc_macro/bridge/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -103,8 +103,9 @@ macro_rules! with_api {\n             Literal {\n                 fn drop($self: $S::Literal);\n                 fn clone($self: &$S::Literal) -> $S::Literal;\n-                // FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n-                fn debug($self: &$S::Literal) -> String;\n+                fn debug_kind($self: &$S::Literal) -> String;\n+                fn symbol($self: &$S::Literal) -> String;\n+                fn suffix($self: &$S::Literal) -> Option<String>;\n                 fn integer(n: &str) -> $S::Literal;\n                 fn typed_integer(n: &str, kind: &str) -> $S::Literal;\n                 fn float(n: &str) -> $S::Literal;"}, {"sha": "f11401b5a0c7c2afc2558d4d9c833de4022fbd77", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -158,6 +158,13 @@ impl fmt::Debug for TokenStream {\n     }\n }\n \n+#[stable(feature = \"proc_macro_token_stream_default\", since = \"1.45.0\")]\n+impl Default for TokenStream {\n+    fn default() -> Self {\n+        TokenStream::new()\n+    }\n+}\n+\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n pub use quote::{quote, quote_span};\n \n@@ -1134,7 +1141,6 @@ impl fmt::Display for Literal {\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for Literal {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n         self.0.fmt(f)\n     }\n }"}, {"sha": "4428d09902b92d6b8a3360e130737b33eb66b32d", "filename": "src/librustc_ast/util/literal.rs", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_ast%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_ast%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Futil%2Fliteral.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -6,8 +6,7 @@ use crate::tokenstream::TokenTree;\n \n use rustc_data_structures::sync::Lrc;\n use rustc_lexer::unescape::{unescape_byte, unescape_char};\n-use rustc_lexer::unescape::{unescape_byte_str, unescape_str};\n-use rustc_lexer::unescape::{unescape_raw_byte_str, unescape_raw_str};\n+use rustc_lexer::unescape::{unescape_byte_literal, unescape_literal, Mode};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n@@ -59,45 +58,53 @@ impl LitKind {\n                 // new symbol because the string in the LitKind is different to the\n                 // string in the token.\n                 let s = symbol.as_str();\n-                let symbol = if s.contains(&['\\\\', '\\r'][..]) {\n-                    let mut buf = String::with_capacity(s.len());\n-                    let mut error = Ok(());\n-                    unescape_str(&s, &mut |_, unescaped_char| match unescaped_char {\n-                        Ok(c) => buf.push(c),\n-                        Err(_) => error = Err(LitError::LexerError),\n-                    });\n-                    error?;\n-                    Symbol::intern(&buf)\n-                } else {\n-                    symbol\n-                };\n+                let symbol =\n+                    if s.contains(&['\\\\', '\\r'][..]) {\n+                        let mut buf = String::with_capacity(s.len());\n+                        let mut error = Ok(());\n+                        unescape_literal(&s, Mode::Str, &mut |_, unescaped_char| {\n+                            match unescaped_char {\n+                                Ok(c) => buf.push(c),\n+                                Err(_) => error = Err(LitError::LexerError),\n+                            }\n+                        });\n+                        error?;\n+                        Symbol::intern(&buf)\n+                    } else {\n+                        symbol\n+                    };\n                 LitKind::Str(symbol, ast::StrStyle::Cooked)\n             }\n             token::StrRaw(n) => {\n                 // Ditto.\n                 let s = symbol.as_str();\n-                let symbol = if s.contains('\\r') {\n-                    let mut buf = String::with_capacity(s.len());\n-                    let mut error = Ok(());\n-                    unescape_raw_str(&s, &mut |_, unescaped_char| match unescaped_char {\n-                        Ok(c) => buf.push(c),\n-                        Err(_) => error = Err(LitError::LexerError),\n-                    });\n-                    error?;\n-                    buf.shrink_to_fit();\n-                    Symbol::intern(&buf)\n-                } else {\n-                    symbol\n-                };\n+                let symbol =\n+                    if s.contains('\\r') {\n+                        let mut buf = String::with_capacity(s.len());\n+                        let mut error = Ok(());\n+                        unescape_literal(&s, Mode::RawStr, &mut |_, unescaped_char| {\n+                            match unescaped_char {\n+                                Ok(c) => buf.push(c),\n+                                Err(_) => error = Err(LitError::LexerError),\n+                            }\n+                        });\n+                        error?;\n+                        buf.shrink_to_fit();\n+                        Symbol::intern(&buf)\n+                    } else {\n+                        symbol\n+                    };\n                 LitKind::Str(symbol, ast::StrStyle::Raw(n))\n             }\n             token::ByteStr => {\n                 let s = symbol.as_str();\n                 let mut buf = Vec::with_capacity(s.len());\n                 let mut error = Ok(());\n-                unescape_byte_str(&s, &mut |_, unescaped_byte| match unescaped_byte {\n-                    Ok(c) => buf.push(c),\n-                    Err(_) => error = Err(LitError::LexerError),\n+                unescape_byte_literal(&s, Mode::ByteStr, &mut |_, unescaped_byte| {\n+                    match unescaped_byte {\n+                        Ok(c) => buf.push(c),\n+                        Err(_) => error = Err(LitError::LexerError),\n+                    }\n                 });\n                 error?;\n                 buf.shrink_to_fit();\n@@ -108,9 +115,11 @@ impl LitKind {\n                 let bytes = if s.contains('\\r') {\n                     let mut buf = Vec::with_capacity(s.len());\n                     let mut error = Ok(());\n-                    unescape_raw_byte_str(&s, &mut |_, unescaped_byte| match unescaped_byte {\n-                        Ok(c) => buf.push(c),\n-                        Err(_) => error = Err(LitError::LexerError),\n+                    unescape_byte_literal(&s, Mode::RawByteStr, &mut |_, unescaped_byte| {\n+                        match unescaped_byte {\n+                            Ok(c) => buf.push(c),\n+                            Err(_) => error = Err(LitError::LexerError),\n+                        }\n                     });\n                     error?;\n                     buf.shrink_to_fit();"}, {"sha": "2cf81af04166cb692d9012ffd7a1fc98b78d8da7", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -33,7 +33,7 @@\n #![feature(array_value_iter)]\n #![feature(crate_visibility_modifier)]\n #![feature(marker_trait_attr)]\n-#![feature(specialization)]\n+#![feature(specialization)] // FIXME: min_specialization does not work\n #![feature(or_patterns)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "8eb125e444053d0191da9b7021cedd97b5bfa7ec", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -572,6 +572,35 @@ impl<'a> AstValidator<'a> {\n             .emit();\n     }\n \n+    fn check_nomangle_item_asciionly(&self, ident: Ident, item_span: Span) {\n+        if ident.name.as_str().is_ascii() {\n+            return;\n+        }\n+        let head_span = self.session.source_map().guess_head_span(item_span);\n+        struct_span_err!(\n+            self.session,\n+            head_span,\n+            E0754,\n+            \"`#[no_mangle]` requires ASCII identifier\"\n+        )\n+        .emit();\n+    }\n+\n+    fn check_mod_file_item_asciionly(&self, ident: Ident) {\n+        if ident.name.as_str().is_ascii() {\n+            return;\n+        }\n+        struct_span_err!(\n+            self.session,\n+            ident.span,\n+            E0754,\n+            \"trying to load file for module `{}` with non ascii identifer name\",\n+            ident.name\n+        )\n+        .help(\"consider using `#[path]` attribute to specify filesystem path\")\n+        .emit();\n+    }\n+\n     fn deny_generic_params(&self, generics: &Generics, ident_span: Span) {\n         if !generics.params.is_empty() {\n             struct_span_err!(\n@@ -866,6 +895,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             self.has_proc_macro_decls = true;\n         }\n \n+        if attr::contains_name(&item.attrs, sym::no_mangle) {\n+            self.check_nomangle_item_asciionly(item.ident, item.span);\n+        }\n+\n         match item.kind {\n             ItemKind::Impl {\n                 unsafety,\n@@ -992,9 +1025,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 walk_list!(self, visit_attribute, &item.attrs);\n                 return;\n             }\n-            ItemKind::Mod(_) => {\n+            ItemKind::Mod(Mod { inline, .. }) => {\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n-                attr::first_attr_value_str_by_name(&item.attrs, sym::path);\n+                if !inline && !attr::contains_name(&item.attrs, sym::path) {\n+                    self.check_mod_file_item_asciionly(item.ident);\n+                }\n             }\n             ItemKind::Union(ref vdata, _) => {\n                 if let VariantData::Tuple(..) | VariantData::Unit(..) = vdata {"}, {"sha": "34db59b1b458d67f66cbf7375e47262dc6f0c155", "filename": "src/librustc_ast_passes/node_count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_ast_passes%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_ast_passes%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fnode_count.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,4 +1,4 @@\n-// Simply gives a rought count of the number of nodes in an AST.\n+// Simply gives a rough count of the number of nodes in an AST.\n \n use rustc_ast::ast::*;\n use rustc_ast::visit::*;"}, {"sha": "af09779d072c313d608ea781676bb6e97699dae4", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -634,7 +634,7 @@ pub fn eval_condition(\n                 [NestedMetaItem::Literal(Lit { span, .. })\n                 | NestedMetaItem::MetaItem(MetaItem { span, .. })] => {\n                     sess.span_diagnostic\n-                        .struct_span_err(*span, &*format!(\"expected a version literal\"))\n+                        .struct_span_err(*span, \"expected a version literal\")\n                         .emit();\n                     return false;\n                 }"}, {"sha": "a08235b304dc50c6948afd9c047aadb62d866393", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -394,6 +394,7 @@ pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n         config.vectorize_slp,\n         config.vectorize_loop,\n         config.no_builtins,\n+        config.emit_lifetime_markers,\n         sanitizer_options.as_ref(),\n         pgo_gen_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n         pgo_use_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n@@ -934,10 +935,10 @@ pub unsafe fn with_llvm_pmb(\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 25);\n         }\n         (llvm::CodeGenOptLevel::None, ..) => {\n-            llvm::LLVMRustAddAlwaysInlinePass(builder, false);\n+            llvm::LLVMRustAddAlwaysInlinePass(builder, config.emit_lifetime_markers);\n         }\n         (llvm::CodeGenOptLevel::Less, ..) => {\n-            llvm::LLVMRustAddAlwaysInlinePass(builder, true);\n+            llvm::LLVMRustAddAlwaysInlinePass(builder, config.emit_lifetime_markers);\n         }\n         (llvm::CodeGenOptLevel::Default, ..) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 225);"}, {"sha": "f5ae9824df8946b108527ec757d59a5bc840c261", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -18,7 +18,6 @@ use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_session::config::{self, Sanitizer};\n use rustc_target::abi::{self, Align, Size};\n use rustc_target::spec::{HasTargetSpec, Target};\n use std::borrow::Cow;\n@@ -1243,14 +1242,7 @@ impl Builder<'a, 'll, 'tcx> {\n             return;\n         }\n \n-        let opts = &self.cx.sess().opts;\n-        let emit = match opts.debugging_opts.sanitizer {\n-            // Some sanitizer use lifetime intrinsics. When they are in use,\n-            // emit lifetime intrinsics regardless of optimization level.\n-            Some(Sanitizer::Address | Sanitizer::Memory) => true,\n-            _ => opts.optimize != config::OptLevel::No,\n-        };\n-        if !emit {\n+        if !self.cx().sess().emit_lifetime_markers() {\n             return;\n         }\n "}, {"sha": "713cb2324f7f7c53a76248b7ca31730837ec0cb2", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -2000,6 +2000,7 @@ extern \"C\" {\n         SLPVectorize: bool,\n         LoopVectorize: bool,\n         DisableSimplifyLibCalls: bool,\n+        EmitLifetimeMarkers: bool,\n         SanitizerOptions: Option<&SanitizerOptions>,\n         PGOGenPath: *const c_char,\n         PGOUsePath: *const c_char,"}, {"sha": "ce158fb07da95914718e9c450d73791d540c087a", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1179,6 +1179,28 @@ fn add_pre_link_args(\n     cmd.args(&sess.opts.debugging_opts.pre_link_args);\n }\n \n+/// Add a link script embedded in the target, if applicable.\n+fn add_link_script(cmd: &mut dyn Linker, sess: &Session, tmpdir: &Path, crate_type: CrateType) {\n+    match (crate_type, &sess.target.target.options.link_script) {\n+        (CrateType::Cdylib | CrateType::Executable, Some(script)) => {\n+            if !sess.target.target.options.linker_is_gnu {\n+                sess.fatal(\"can only use link script when linking with GNU-like linker\");\n+            }\n+\n+            let file_name = [\"rustc\", &sess.target.target.llvm_target, \"linkfile.ld\"].join(\"-\");\n+\n+            let path = tmpdir.join(file_name);\n+            if let Err(e) = fs::write(&path, script) {\n+                sess.fatal(&format!(\"failed to write link script to {}: {}\", path.display(), e));\n+            }\n+\n+            cmd.arg(\"--script\");\n+            cmd.arg(path);\n+        }\n+        _ => {}\n+    }\n+}\n+\n /// Add arbitrary \"user defined\" args defined from command line and by `#[link_args]` attributes.\n /// FIXME: Determine where exactly these args need to be inserted.\n fn add_user_defined_link_args(\n@@ -1421,8 +1443,11 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n     add_pre_link_args(cmd, sess, flavor, crate_type);\n \n+    // NO-OPT-OUT\n+    add_link_script(cmd, sess, tmpdir, crate_type);\n+\n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    if sess.target.target.options.is_like_fuchsia {\n+    if sess.target.target.options.is_like_fuchsia && crate_type == CrateType::Executable {\n         let prefix = match sess.opts.debugging_opts.sanitizer {\n             Some(Sanitizer::Address) => \"asan/\",\n             _ => \"\","}, {"sha": "53dfe7cb7499803b5ac46c6e0448a17aea2e8ef7", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -21,7 +21,7 @@ use rustc_errors::{DiagnosticId, FatalError, Handler, Level};\n use rustc_fs_util::link_or_copy;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_incremental::{\n-    copy_cgu_workproducts_to_incr_comp_cache_dir, in_incr_comp_dir, in_incr_comp_dir_sess,\n+    copy_cgu_workproduct_to_incr_comp_cache_dir, in_incr_comp_dir, in_incr_comp_dir_sess,\n };\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::middle::cstore::EncodedMetadata;\n@@ -110,6 +110,7 @@ pub struct ModuleConfig {\n     pub merge_functions: bool,\n     pub inline_threshold: Option<usize>,\n     pub new_llvm_pass_manager: bool,\n+    pub emit_lifetime_markers: bool,\n }\n \n impl ModuleConfig {\n@@ -244,6 +245,7 @@ impl ModuleConfig {\n \n             inline_threshold: sess.opts.cg.inline_threshold,\n             new_llvm_pass_manager: sess.opts.debugging_opts.new_llvm_pass_manager,\n+            emit_lifetime_markers: sess.emit_lifetime_markers(),\n         }\n     }\n \n@@ -465,17 +467,13 @@ fn copy_all_cgu_workproducts_to_incr_comp_cache_dir(\n         return work_products;\n     }\n \n-    let _timer = sess.timer(\"incr_comp_copy_cgu_workproducts\");\n+    let _timer = sess.timer(\"copy_all_cgu_workproducts_to_incr_comp_cache_dir\");\n \n     for module in compiled_modules.modules.iter().filter(|m| m.kind == ModuleKind::Regular) {\n-        let mut files = vec![];\n-\n-        if let Some(ref path) = module.object {\n-            files.push(path.clone());\n-        }\n+        let path = module.object.as_ref().map(|path| path.clone());\n \n         if let Some((id, product)) =\n-            copy_cgu_workproducts_to_incr_comp_cache_dir(sess, &module.name, &files)\n+            copy_cgu_workproduct_to_incr_comp_cache_dir(sess, &module.name, &path)\n         {\n             work_products.insert(id, product);\n         }\n@@ -817,7 +815,7 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n ) -> Result<WorkItemResult<B>, FatalError> {\n     let incr_comp_session_dir = cgcx.incr_comp_session_dir.as_ref().unwrap();\n     let mut object = None;\n-    for saved_file in &module.source.saved_files {\n+    if let Some(saved_file) = module.source.saved_file {\n         let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, Some(&module.name));\n         object = Some(obj_out.clone());\n         let source_file = in_incr_comp_dir(&incr_comp_session_dir, &saved_file);"}, {"sha": "1d8730db546029ef23b339c6e8791bf25cc3be36", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -198,7 +198,6 @@ pub fn push_debuginfo_type_name<'tcx>(\n         ty::Error\n         | ty::Infer(_)\n         | ty::Placeholder(..)\n-        | ty::UnnormalizedProjection(..)\n         | ty::Projection(..)\n         | ty::Bound(..)\n         | ty::Opaque(..)"}, {"sha": "81ad032967bfd283fa676d21613f749838936d3c", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -28,7 +28,7 @@ rustc_index = { path = \"../librustc_index\", package = \"rustc_index\" }\n bitflags = \"1.2.1\"\n measureme = \"0.7.1\"\n libc = \"0.2\"\n-stacker = \"0.1.6\"\n+stacker = \"0.1.9\"\n \n [dependencies.parking_lot]\n version = \"0.10\""}, {"sha": "7ee60176dbead16ce3eb0be88bfd9ec50a86b9e7", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -12,7 +12,7 @@\n #![feature(generators)]\n #![feature(generator_trait)]\n #![feature(fn_traits)]\n-#![feature(specialization)]\n+#![feature(min_specialization)]\n #![feature(optin_builtin_traits)]\n #![feature(nll)]\n #![feature(allow_internal_unstable)]"}, {"sha": "e94a0c6eb5943d8012fc5c0e1a5ae3bc19d695a7", "filename": "src/librustc_data_structures/tiny_list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_data_structures%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_data_structures%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -52,7 +52,7 @@ impl<T: PartialEq> TinyList<T> {\n             if &e.data == data {\n                 return true;\n             }\n-            elem = e.next.as_ref().map(|e| &**e);\n+            elem = e.next.as_deref();\n         }\n         false\n     }\n@@ -62,7 +62,7 @@ impl<T: PartialEq> TinyList<T> {\n         let (mut elem, mut count) = (self.head.as_ref(), 0);\n         while let Some(ref e) = elem {\n             count += 1;\n-            elem = e.next.as_ref().map(|e| &**e);\n+            elem = e.next.as_deref();\n         }\n         count\n     }"}, {"sha": "6847b175e60ebdb4b779a249fe8dfd933e5375d6", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1138,6 +1138,16 @@ pub fn catch_fatal_errors<F: FnOnce() -> R, R>(f: F) -> Result<R, ErrorReported>\n     })\n }\n \n+/// Variant of `catch_fatal_errors` for the `interface::Result` return type\n+/// that also computes the exit code.\n+pub fn catch_with_exit_code(f: impl FnOnce() -> interface::Result<()>) -> i32 {\n+    let result = catch_fatal_errors(f).and_then(|result| result);\n+    match result {\n+        Ok(()) => EXIT_SUCCESS,\n+        Err(_) => EXIT_FAILURE,\n+    }\n+}\n+\n lazy_static! {\n     static ref DEFAULT_HOOK: Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static> = {\n         let hook = panic::take_hook();\n@@ -1228,12 +1238,12 @@ pub fn init_rustc_env_logger() {\n     env_logger::init_from_env(\"RUSTC_LOG\");\n }\n \n-pub fn main() {\n+pub fn main() -> ! {\n     let start = Instant::now();\n     init_rustc_env_logger();\n     let mut callbacks = TimePassesCallbacks::default();\n     install_ice_hook();\n-    let result = catch_fatal_errors(|| {\n+    let exit_code = catch_with_exit_code(|| {\n         let args = env::args_os()\n             .enumerate()\n             .map(|(i, arg)| {\n@@ -1246,13 +1256,8 @@ pub fn main() {\n             })\n             .collect::<Vec<_>>();\n         run_compiler(&args, &mut callbacks, None, None)\n-    })\n-    .and_then(|result| result);\n-    let exit_code = match result {\n-        Ok(_) => EXIT_SUCCESS,\n-        Err(_) => EXIT_FAILURE,\n-    };\n+    });\n     // The extra `\\t` is necessary to align this label with the others.\n     print_time_passes_entry(callbacks.time_passes, \"\\ttotal\", start.elapsed());\n-    process::exit(exit_code);\n+    process::exit(exit_code)\n }"}, {"sha": "c0b16c22e4d98fdcf0ff37a525d872e392cdf5db", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -120,6 +120,7 @@ E0223: include_str!(\"./error_codes/E0223.md\"),\n E0224: include_str!(\"./error_codes/E0224.md\"),\n E0225: include_str!(\"./error_codes/E0225.md\"),\n E0226: include_str!(\"./error_codes/E0226.md\"),\n+E0228: include_str!(\"./error_codes/E0228.md\"),\n E0229: include_str!(\"./error_codes/E0229.md\"),\n E0230: include_str!(\"./error_codes/E0230.md\"),\n E0231: include_str!(\"./error_codes/E0231.md\"),\n@@ -435,6 +436,7 @@ E0750: include_str!(\"./error_codes/E0750.md\"),\n E0751: include_str!(\"./error_codes/E0751.md\"),\n E0752: include_str!(\"./error_codes/E0752.md\"),\n E0753: include_str!(\"./error_codes/E0753.md\"),\n+E0754: include_str!(\"./error_codes/E0754.md\"),\n E0755: include_str!(\"./error_codes/E0755.md\"),\n ;\n //  E0006, // merged with E0005\n@@ -483,7 +485,6 @@ E0755: include_str!(\"./error_codes/E0755.md\"),\n //  E0218, // no associated type defined\n //  E0219, // associated type defined in higher-ranked supertrait\n     E0227, // ambiguous lifetime bound, explicit lifetime bound required\n-    E0228, // explicit lifetime bound required\n //  E0233,\n //  E0234,\n //  E0235, // structure constructor specifies a structure of type but"}, {"sha": "3443a5ae8638ce8fa342bec01892a01eddfc385f", "filename": "src/librustc_error_codes/error_codes/E0228.md", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0228.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0228.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0228.md?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,40 @@\n+The lifetime bound for this object type cannot be deduced from context and must\n+be specified.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0228\n+trait Trait { }\n+\n+struct TwoBounds<'a, 'b, T: Sized + 'a + 'b> {\n+    x: &'a i32,\n+    y: &'b i32,\n+    z: T,\n+}\n+\n+type Foo<'a, 'b> = TwoBounds<'a, 'b, dyn Trait>;\n+```\n+\n+When a trait object is used as a type argument of a generic type, Rust will try\n+to infer its lifetime if unspecified. However, this isn't possible when the\n+containing type has more than one lifetime bound.\n+\n+The above example can be resolved by either reducing the number of lifetime\n+bounds to one or by making the trait object lifetime explicit, like so:\n+\n+```\n+trait Trait { }\n+\n+struct TwoBounds<'a, 'b, T: Sized + 'a + 'b> {\n+    x: &'a i32,\n+    y: &'b i32,\n+    z: T,\n+}\n+\n+type Foo<'a, 'b> = TwoBounds<'a, 'b, dyn Trait + 'b>;\n+```\n+\n+For more information, see [RFC 599] and its amendment [RFC 1156].\n+\n+[RFC 599]: https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md\n+[RFC 1156]: https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md"}, {"sha": "0d29d56ea1a75c2cccbc00eba0b5f1714fb7ec58", "filename": "src/librustc_error_codes/error_codes/E0307.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0307.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0307.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0307.md?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -64,7 +64,7 @@ impl Trait for Foo {\n }\n ```\n \n-The nightly feature [Arbintrary self types][AST] extends the accepted\n+The nightly feature [Arbitrary self types][AST] extends the accepted\n set of receiver types to also include any type that can dereference to\n `Self`:\n "}, {"sha": "eadae05aa304c04af0f0c25ef6ebe1b310d29aa4", "filename": "src/librustc_error_codes/error_codes/E0571.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0571.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0571.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0571.md?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -7,7 +7,7 @@ Example of erroneous code:\n # fn satisfied(n: usize) -> bool { n % 23 == 0 }\n let result = while true {\n     if satisfied(i) {\n-        break 2*i; // error: `break` with value from a `while` loop\n+        break 2 * i; // error: `break` with value from a `while` loop\n     }\n     i += 1;\n };\n@@ -22,9 +22,9 @@ Make sure `break value;` statements only occur in `loop` loops:\n ```\n # let mut i = 1;\n # fn satisfied(n: usize) -> bool { n % 23 == 0 }\n-let result = loop { // ok!\n+let result = loop { // This is now a \"loop\" loop.\n     if satisfied(i) {\n-        break 2*i;\n+        break 2 * i; // ok!\n     }\n     i += 1;\n };"}, {"sha": "f554242a3d466e1265b0092959eec3bdf765bd12", "filename": "src/librustc_error_codes/error_codes/E0579.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0579.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0579.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0579.md?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,7 +1,4 @@\n-When matching against an exclusive range, the compiler verifies that the range\n-is non-empty. Exclusive range patterns include the start point but not the end\n-point, so this is equivalent to requiring the start of the range to be less\n-than the end of the range.\n+A lower range wasn't less than the upper range.\n \n Erroneous code example:\n \n@@ -17,3 +14,8 @@ fn main() {\n     }\n }\n ```\n+\n+When matching against an exclusive range, the compiler verifies that the range\n+is non-empty. Exclusive range patterns include the start point but not the end\n+point, so this is equivalent to requiring the start of the range to be less\n+than the end of the range."}, {"sha": "89f6e3269ec36856a83a5cd23a72d39e0950ce33", "filename": "src/librustc_error_codes/error_codes/E0581.md", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0581.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0581.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0581.md?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,4 +1,4 @@\n-In a `fn` type, a lifetime appears only in the return type,\n+In a `fn` type, a lifetime appears only in the return type\n and not in the arguments types.\n \n Erroneous code example:\n@@ -10,8 +10,11 @@ fn main() {\n }\n ```\n \n-To fix this issue, either use the lifetime in the arguments, or use\n-`'static`. Example:\n+The problem here is that the lifetime isn't contrained by any of the arguments,\n+making it impossible to determine how long it's supposed to live.\n+\n+To fix this issue, either use the lifetime in the arguments, or use the\n+`'static` lifetime. Example:\n \n ```\n fn main() {"}, {"sha": "e50cc60ea33023881673071ea0b6e8bf21351a54", "filename": "src/librustc_error_codes/error_codes/E0582.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0582.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0582.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0582.md?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,5 +1,5 @@\n-A lifetime appears only in an associated-type binding,\n-and not in the input types to the trait.\n+A lifetime is only present in an associated-type binding, and not in the input\n+types to the trait.\n \n Erroneous code example:\n "}, {"sha": "8a4f8d2172585021034ebfe4e10a7f8bf2cc861a", "filename": "src/librustc_error_codes/error_codes/E0589.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0589.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0589.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0589.md?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,6 +1,8 @@\n The value of `N` that was specified for `repr(align(N))` was not a power\n of two, or was greater than 2^29.\n \n+Erroneous code example:\n+\n ```compile_fail,E0589\n #[repr(align(15))] // error: invalid `repr(align)` attribute: not a power of two\n enum Foo {"}, {"sha": "abdc01ed21ab738dcece9a0d7c0e2a219a0ffbc1", "filename": "src/librustc_error_codes/error_codes/E0754.md", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0754.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0754.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0754.md?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,33 @@\n+An non-ascii identifier was used in an invalid context.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0754\n+# #![feature(non_ascii_idents)]\n+\n+mod \u0159\u0173\u015b\u0165;\n+// ^ error!\n+fn main() {}\n+```\n+\n+```compile_fail,E0754\n+# #![feature(non_ascii_idents)]\n+\n+#[no_mangle]\n+fn \u0159\u0173\u015b\u0165() {}\n+// ^ error!\n+fn main() {}\n+```\n+\n+Non-ascii can be used as module names if it is inline\n+or a #\\[path\\] attribute is specified. For example:\n+\n+```\n+# #![feature(non_ascii_idents)]\n+\n+mod \u0159\u0173\u015b\u0165 {\n+    const IS_GREAT: bool = true;\n+}\n+\n+fn main() {}\n+```"}, {"sha": "0c289146176d98ca50e6bb1c919e88c3509446af", "filename": "src/librustc_error_codes/error_codes/E0755.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0755.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0755.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0755.md?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -3,7 +3,7 @@ or `Self` that references lifetimes from a parent scope.\n \n Erroneous code example:\n \n-```compile_fail,E0754,edition2018\n+```compile_fail,E0755,edition2018\n struct S<'a>(&'a i32);\n \n impl<'a> S<'a> {"}, {"sha": "2932475430bbfead59547288a7f175200508a777", "filename": "src/librustc_expand/parse/lexer/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_expand%2Fparse%2Flexer%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_expand%2Fparse%2Flexer%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fparse%2Flexer%2Ftests.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -50,13 +50,13 @@ fn t1() {\n         assert_eq!(string_reader.next_token(), token::Whitespace);\n         // Read another token.\n         let tok3 = string_reader.next_token();\n-        assert_eq!(string_reader.pos.clone(), BytePos(28));\n+        assert_eq!(string_reader.pos(), BytePos(28));\n         let tok4 = Token::new(mk_ident(\"main\"), Span::with_root_ctxt(BytePos(24), BytePos(28)));\n         assert_eq!(tok3.kind, tok4.kind);\n         assert_eq!(tok3.span, tok4.span);\n \n         assert_eq!(string_reader.next_token(), token::OpenDelim(token::Paren));\n-        assert_eq!(string_reader.pos.clone(), BytePos(29))\n+        assert_eq!(string_reader.pos(), BytePos(29))\n     })\n }\n "}, {"sha": "b9693c2c862785dc52138c470950b728db073218", "filename": "src/librustc_expand/proc_macro_server.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_expand%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_expand%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro_server.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -507,9 +507,14 @@ impl server::Ident for Rustc<'_> {\n }\n \n impl server::Literal for Rustc<'_> {\n-    // FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n-    fn debug(&mut self, literal: &Self::Literal) -> String {\n-        format!(\"{:?}\", literal)\n+    fn debug_kind(&mut self, literal: &Self::Literal) -> String {\n+        format!(\"{:?}\", literal.lit.kind)\n+    }\n+    fn symbol(&mut self, literal: &Self::Literal) -> String {\n+        literal.lit.symbol.to_string()\n+    }\n+    fn suffix(&mut self, literal: &Self::Literal) -> Option<String> {\n+        literal.lit.suffix.as_ref().map(Symbol::to_string)\n     }\n     fn integer(&mut self, n: &str) -> Self::Literal {\n         self.lit(token::Integer, Symbol::intern(n), None)"}, {"sha": "b51c0a6e98840b3374c18747cf8d6c709f8e9289", "filename": "src/librustc_hir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_hir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_hir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flib.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -8,7 +8,7 @@\n #![feature(const_panic)]\n #![feature(in_band_lifetimes)]\n #![feature(or_patterns)]\n-#![feature(specialization)]\n+#![feature(min_specialization)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "7fd4b3c2554f36722a79198705dc89831a28da7e", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -15,7 +15,7 @@ pub mod assert_module_sources;\n mod persist;\n \n pub use assert_dep_graph::assert_dep_graph;\n-pub use persist::copy_cgu_workproducts_to_incr_comp_cache_dir;\n+pub use persist::copy_cgu_workproduct_to_incr_comp_cache_dir;\n pub use persist::delete_workproduct_files;\n pub use persist::dep_graph_tcx_init;\n pub use persist::finalize_session_directory;"}, {"sha": "966faa9639d72f28328db760e32295d5dc47c859", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -134,7 +134,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n \n             for swp in work_products {\n                 let mut all_files_exist = true;\n-                for file_name in swp.work_product.saved_files.iter() {\n+                if let Some(ref file_name) = swp.work_product.saved_file {\n                     let path = in_incr_comp_dir_sess(sess, file_name);\n                     if !path.exists() {\n                         all_files_exist = false;"}, {"sha": "7bc3b47e15adfd3e597e5bf3c9f0448de9c65b7b", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -21,5 +21,5 @@ pub use load::LoadResult;\n pub use load::{load_dep_graph, DepGraphFuture};\n pub use save::save_dep_graph;\n pub use save::save_work_product_index;\n-pub use work_product::copy_cgu_workproducts_to_incr_comp_cache_dir;\n+pub use work_product::copy_cgu_workproduct_to_incr_comp_cache_dir;\n pub use work_product::delete_workproduct_files;"}, {"sha": "c43d4ad4049c9431ee9400eea672a034c5586a90", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -74,9 +74,9 @@ pub fn save_work_product_index(\n         if !new_work_products.contains_key(id) {\n             work_product::delete_workproduct_files(sess, wp);\n             debug_assert!(\n-                wp.saved_files\n-                    .iter()\n-                    .all(|file_name| { !in_incr_comp_dir_sess(sess, file_name).exists() })\n+                wp.saved_file.as_ref().map_or(true, |file_name| {\n+                    !in_incr_comp_dir_sess(sess, &file_name).exists()\n+                })\n             );\n         }\n     }\n@@ -85,7 +85,7 @@ pub fn save_work_product_index(\n     debug_assert!({\n         new_work_products\n             .iter()\n-            .flat_map(|(_, wp)| wp.saved_files.iter())\n+            .flat_map(|(_, wp)| wp.saved_file.iter())\n             .map(|name| in_incr_comp_dir_sess(sess, name))\n             .all(|path| path.exists())\n     });"}, {"sha": "19d64bda56d6d66bc5a024971ed68d40d9339882", "filename": "src/librustc_incremental/persist/work_product.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -7,43 +7,41 @@ use rustc_session::Session;\n use std::fs as std_fs;\n use std::path::PathBuf;\n \n-pub fn copy_cgu_workproducts_to_incr_comp_cache_dir(\n+pub fn copy_cgu_workproduct_to_incr_comp_cache_dir(\n     sess: &Session,\n     cgu_name: &str,\n-    files: &[PathBuf],\n+    path: &Option<PathBuf>,\n ) -> Option<(WorkProductId, WorkProduct)> {\n-    debug!(\"copy_cgu_workproducts_to_incr_comp_cache_dir({:?},{:?})\", cgu_name, files);\n+    debug!(\"copy_cgu_workproduct_to_incr_comp_cache_dir({:?},{:?})\", cgu_name, path);\n     sess.opts.incremental.as_ref()?;\n \n-    let saved_files = files\n-        .iter()\n-        .map(|path| {\n-            let file_name = format!(\"{}.o\", cgu_name);\n-            let path_in_incr_dir = in_incr_comp_dir_sess(sess, &file_name);\n-            match link_or_copy(path, &path_in_incr_dir) {\n-                Ok(_) => Some(file_name),\n-                Err(err) => {\n-                    sess.warn(&format!(\n-                        \"error copying object file `{}` \\\n-                                             to incremental directory as `{}`: {}\",\n-                        path.display(),\n-                        path_in_incr_dir.display(),\n-                        err\n-                    ));\n-                    None\n-                }\n+    let saved_file = if let Some(path) = path {\n+        let file_name = format!(\"{}.o\", cgu_name);\n+        let path_in_incr_dir = in_incr_comp_dir_sess(sess, &file_name);\n+        match link_or_copy(path, &path_in_incr_dir) {\n+            Ok(_) => Some(file_name),\n+            Err(err) => {\n+                sess.warn(&format!(\n+                    \"error copying object file `{}` to incremental directory as `{}`: {}\",\n+                    path.display(),\n+                    path_in_incr_dir.display(),\n+                    err\n+                ));\n+                return None;\n             }\n-        })\n-        .collect::<Option<Vec<_>>>()?;\n+        }\n+    } else {\n+        None\n+    };\n \n-    let work_product = WorkProduct { cgu_name: cgu_name.to_string(), saved_files };\n+    let work_product = WorkProduct { cgu_name: cgu_name.to_string(), saved_file };\n \n     let work_product_id = WorkProductId::from_cgu_name(cgu_name);\n     Some((work_product_id, work_product))\n }\n \n pub fn delete_workproduct_files(sess: &Session, work_product: &WorkProduct) {\n-    for file_name in &work_product.saved_files {\n+    if let Some(ref file_name) = work_product.saved_file {\n         let path = in_incr_comp_dir_sess(sess, file_name);\n         match std_fs::remove_file(&path) {\n             Ok(()) => {}"}, {"sha": "67dcea58cf82bb0b30a35ef6872810f69e3014af", "filename": "src/librustc_index/vec.rs", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_index%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_index%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fvec.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -65,7 +65,7 @@ impl Idx for u32 {\n /// `u32::MAX`. You can also customize things like the `Debug` impl,\n /// what traits are derived, and so forth via the macro.\n #[macro_export]\n-#[allow_internal_unstable(step_trait, rustc_attrs)]\n+#[allow_internal_unstable(step_trait, step_trait_ext, rustc_attrs)]\n macro_rules! newtype_index {\n     // ---- public rules ----\n \n@@ -181,7 +181,7 @@ macro_rules! newtype_index {\n             }\n         }\n \n-        impl ::std::iter::Step for $type {\n+        unsafe impl ::std::iter::Step for $type {\n             #[inline]\n             fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n                 <usize as ::std::iter::Step>::steps_between(\n@@ -191,33 +191,13 @@ macro_rules! newtype_index {\n             }\n \n             #[inline]\n-            fn replace_one(&mut self) -> Self {\n-                ::std::mem::replace(self, Self::from_u32(1))\n+            fn forward_checked(start: Self, u: usize) -> Option<Self> {\n+                Self::index(start).checked_add(u).map(Self::from_usize)\n             }\n \n             #[inline]\n-            fn replace_zero(&mut self) -> Self {\n-                ::std::mem::replace(self, Self::from_u32(0))\n-            }\n-\n-            #[inline]\n-            fn add_one(&self) -> Self {\n-                Self::from_usize(Self::index(*self) + 1)\n-            }\n-\n-            #[inline]\n-            fn sub_one(&self) -> Self {\n-                Self::from_usize(Self::index(*self) - 1)\n-            }\n-\n-            #[inline]\n-            fn add_usize(&self, u: usize) -> Option<Self> {\n-                Self::index(*self).checked_add(u).map(Self::from_usize)\n-            }\n-\n-            #[inline]\n-            fn sub_usize(&self, u: usize) -> Option<Self> {\n-                Self::index(*self).checked_sub(u).map(Self::from_usize)\n+            fn backward_checked(start: Self, u: usize) -> Option<Self> {\n+                Self::index(start).checked_sub(u).map(Self::from_usize)\n             }\n         }\n "}, {"sha": "5551b56ab797b02e23df7566836d2f156b5daa08", "filename": "src/librustc_infer/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -415,7 +415,6 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             | ty::Never\n             | ty::Tuple(..)\n             | ty::Projection(..)\n-            | ty::UnnormalizedProjection(..)\n             | ty::Foreign(..)\n             | ty::Param(..)\n             | ty::Opaque(..) => {"}, {"sha": "0141ba8273775aa1b20b8ecdb155d400ca24dcad", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -554,7 +554,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let output = bound_output.skip_binder();\n                     err.span_label(e.span, &format!(\"this method call resolves to `{:?}`\", output));\n                     let kind = &output.kind;\n-                    if let ty::Projection(proj) | ty::UnnormalizedProjection(proj) = kind {\n+                    if let ty::Projection(proj) = kind {\n                         if let Some(span) = self.tcx.hir().span_if_local(proj.item_def_id) {\n                             err.span_label(span, &format!(\"`{:?}` defined here\", output));\n                         }"}, {"sha": "c9ed687eaf2567ef8fa34077de3875dffc388479", "filename": "src/librustc_infer/infer/freshen.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -204,7 +204,6 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             | ty::Never\n             | ty::Tuple(..)\n             | ty::Projection(..)\n-            | ty::UnnormalizedProjection(..)\n             | ty::Foreign(..)\n             | ty::Param(..)\n             | ty::Closure(..)"}, {"sha": "33a80fb747101843df5ad68388de1bf6802c390b", "filename": "src/librustc_infer/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -325,8 +325,21 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n         }\n \n-        debug!(\"enforce_member_constraint: final least choice = {:?}\", least_choice);\n-        if least_choice != member_lower_bound {\n+        // (#72087) Different `ty::Regions` can be known to be equal, for\n+        // example, we know that `'a` and `'static` are equal in a function\n+        // with a parameter of type `&'static &'a ()`.\n+        //\n+        // When we have two equal regions like this `expansion` will use\n+        // `lub_concrete_regions` to pick a canonical representative. The same\n+        // choice is needed here so that we don't end up in a cycle of\n+        // `expansion` changing the region one way and the code here changing\n+        // it back.\n+        let lub = self.lub_concrete_regions(least_choice, member_lower_bound);\n+        debug!(\n+            \"enforce_member_constraint: final least choice = {:?}\\nlub = {:?}\",\n+            least_choice, lub\n+        );\n+        if lub != member_lower_bound {\n             *var_values.value_mut(member_vid) = VarValue::Value(least_choice);\n             true\n         } else {\n@@ -578,8 +591,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 self.tcx().mk_region(ReScope(lub))\n             }\n \n-            (&ReEarlyBound(_), &ReEarlyBound(_) | &ReFree(_))\n-            | (&ReFree(_), &ReEarlyBound(_) | &ReFree(_)) => {\n+            (&ReEarlyBound(_) | &ReFree(_), &ReEarlyBound(_) | &ReFree(_)) => {\n                 self.region_rels.lub_free_regions(a, b)\n             }\n "}, {"sha": "b34685006e22301c111938ccadaed42a0ee56f57", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -112,8 +112,7 @@ pub fn elaborate_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n ) -> Elaborator<'tcx> {\n-    let obligations =\n-        predicates.into_iter().map(|predicate| predicate_obligation(predicate, None)).collect();\n+    let obligations = predicates.map(|predicate| predicate_obligation(predicate, None)).collect();\n     elaborate_obligations(tcx, obligations)\n }\n \n@@ -149,7 +148,7 @@ impl Elaborator<'tcx> {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n-                let obligations = predicates.predicates.into_iter().map(|(pred, span)| {\n+                let obligations = predicates.predicates.iter().map(|(pred, span)| {\n                     predicate_obligation(\n                         pred.subst_supertrait(tcx, &data.to_poly_trait_ref()),\n                         Some(*span),"}, {"sha": "94cd4bcd4c626008aa969a4c3f8ebbbe90a5a18d", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -137,7 +137,7 @@ impl<'tcx> Queries<'tcx> {\n             let result = passes::register_plugins(\n                 self.session(),\n                 &*self.codegen_backend().metadata_loader(),\n-                self.compiler.register_lints.as_ref().map(|p| &**p).unwrap_or_else(|| empty),\n+                self.compiler.register_lints.as_deref().unwrap_or_else(|| empty),\n                 krate,\n                 &crate_name,\n             );"}, {"sha": "e44feee96607a7d4d0eaf669945bf8fa1c29b5d0", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,5 +1,11 @@\n //! Low-level Rust lexer.\n //!\n+//! The idea with `librustc_lexer` is to make a reusable library,\n+//! by separating out pure lexing and rustc-specific concerns, like spans,\n+//! error reporting an interning.  So, rustc_lexer operates directly on `&str`,\n+//! produces simple tokens which are a pair of type-tag and a bit of original text,\n+//! and does not report errors, instead storing them as flags on the token.\n+//!\n //! Tokens produced by this lexer are not yet ready for parsing the Rust syntax,\n //! for that see `librustc_parse::lexer`, which converts this basic token stream\n //! into wide tokens used by actual parser.\n@@ -719,6 +725,9 @@ impl Cursor<'_> {\n \n             // Check that amount of closing '#' symbols\n             // is equal to the amount of opening ones.\n+            // Note that this will not consume extra trailing `#` characters:\n+            // `r###\"abcde\"####` is lexed as a `LexedRawString { n_hashes: 3 }`\n+            // followed by a `#` token.\n             let mut hashes_left = n_start_hashes;\n             let is_closing_hash = |c| {\n                 if c == '#' && hashes_left != 0 {\n@@ -739,8 +748,8 @@ impl Cursor<'_> {\n                     possible_terminator_offset: None,\n                 };\n             } else if n_end_hashes > max_hashes {\n-                // Keep track of possible terminators to give a hint about where there might be\n-                // a missing terminator\n+                // Keep track of possible terminators to give a hint about\n+                // where there might be a missing terminator\n                 possible_terminator_offset =\n                     Some(self.len_consumed() - start_pos - n_end_hashes + prefix_len);\n                 max_hashes = n_end_hashes;"}, {"sha": "2a9e1b7cbc3460a440b35fc9da3785ab80fac262", "filename": "src/librustc_lexer/src/unescape.rs", "status": "modified", "additions": 41, "deletions": 51, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -58,69 +58,57 @@ pub enum EscapeError {\n     NonAsciiCharInByteString,\n }\n \n-/// Takes a contents of a char literal (without quotes), and returns an\n-/// unescaped char or an error\n-pub fn unescape_char(literal_text: &str) -> Result<char, (usize, EscapeError)> {\n-    let mut chars = literal_text.chars();\n-    unescape_char_or_byte(&mut chars, Mode::Char)\n-        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n-}\n-\n-/// Takes a contents of a byte literal (without quotes), and returns an\n-/// unescaped byte or an error.\n-pub fn unescape_byte(literal_text: &str) -> Result<u8, (usize, EscapeError)> {\n-    let mut chars = literal_text.chars();\n-    unescape_char_or_byte(&mut chars, Mode::Byte)\n-        .map(byte_from_char)\n-        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n-}\n-\n-/// Takes a contents of a string literal (without quotes) and produces a\n+/// Takes a contents of a literal (without quotes) and produces a\n /// sequence of escaped characters or errors.\n /// Values are returned through invoking of the provided callback.\n-pub fn unescape_str<F>(literal_text: &str, callback: &mut F)\n+pub fn unescape_literal<F>(literal_text: &str, mode: Mode, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n-    unescape_str_or_byte_str(literal_text, Mode::Str, callback)\n+    match mode {\n+        Mode::Char | Mode::Byte => {\n+            let mut chars = literal_text.chars();\n+            let result = unescape_char_or_byte(&mut chars, mode);\n+            // The Chars iterator moved forward.\n+            callback(0..(literal_text.len() - chars.as_str().len()), result);\n+        }\n+        Mode::Str | Mode::ByteStr => unescape_str_or_byte_str(literal_text, mode, callback),\n+        // NOTE: Raw strings do not perform any explicit character escaping, here we\n+        // only translate CRLF to LF and produce errors on bare CR.\n+        Mode::RawStr | Mode::RawByteStr => {\n+            unescape_raw_str_or_byte_str(literal_text, mode, callback)\n+        }\n+    }\n }\n \n-/// Takes a contents of a byte string literal (without quotes) and produces a\n-/// sequence of bytes or errors.\n+/// Takes a contents of a byte, byte string or raw byte string (without quotes)\n+/// and produces a sequence of bytes or errors.\n /// Values are returned through invoking of the provided callback.\n-pub fn unescape_byte_str<F>(literal_text: &str, callback: &mut F)\n+pub fn unescape_byte_literal<F>(literal_text: &str, mode: Mode, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<u8, EscapeError>),\n {\n-    unescape_str_or_byte_str(literal_text, Mode::ByteStr, &mut |range, char| {\n-        callback(range, char.map(byte_from_char))\n+    assert!(mode.is_bytes());\n+    unescape_literal(literal_text, mode, &mut |range, result| {\n+        callback(range, result.map(byte_from_char));\n     })\n }\n \n-/// Takes a contents of a raw string literal (without quotes) and produces a\n-/// sequence of characters or errors.\n-/// Values are returned through invoking of the provided callback.\n-/// NOTE: Raw strings do not perform any explicit character escaping, here we\n-/// only translate CRLF to LF and produce errors on bare CR.\n-pub fn unescape_raw_str<F>(literal_text: &str, callback: &mut F)\n-where\n-    F: FnMut(Range<usize>, Result<char, EscapeError>),\n-{\n-    unescape_raw_str_or_byte_str(literal_text, Mode::Str, callback)\n+/// Takes a contents of a char literal (without quotes), and returns an\n+/// unescaped char or an error\n+pub fn unescape_char(literal_text: &str) -> Result<char, (usize, EscapeError)> {\n+    let mut chars = literal_text.chars();\n+    unescape_char_or_byte(&mut chars, Mode::Char)\n+        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n }\n \n-/// Takes a contents of a raw byte string literal (without quotes) and produces a\n-/// sequence of bytes or errors.\n-/// Values are returned through invoking of the provided callback.\n-/// NOTE: Raw strings do not perform any explicit character escaping, here we\n-/// only translate CRLF to LF and produce errors on bare CR.\n-pub fn unescape_raw_byte_str<F>(literal_text: &str, callback: &mut F)\n-where\n-    F: FnMut(Range<usize>, Result<u8, EscapeError>),\n-{\n-    unescape_raw_str_or_byte_str(literal_text, Mode::ByteStr, &mut |range, char| {\n-        callback(range, char.map(byte_from_char))\n-    })\n+/// Takes a contents of a byte literal (without quotes), and returns an\n+/// unescaped byte or an error.\n+pub fn unescape_byte(literal_text: &str) -> Result<u8, (usize, EscapeError)> {\n+    let mut chars = literal_text.chars();\n+    unescape_char_or_byte(&mut chars, Mode::Byte)\n+        .map(byte_from_char)\n+        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n }\n \n /// What kind of literal do we parse.\n@@ -130,13 +118,15 @@ pub enum Mode {\n     Str,\n     Byte,\n     ByteStr,\n+    RawStr,\n+    RawByteStr,\n }\n \n impl Mode {\n     pub fn in_single_quotes(self) -> bool {\n         match self {\n             Mode::Char | Mode::Byte => true,\n-            Mode::Str | Mode::ByteStr => false,\n+            Mode::Str | Mode::ByteStr | Mode::RawStr | Mode::RawByteStr => false,\n         }\n     }\n \n@@ -146,8 +136,8 @@ impl Mode {\n \n     pub fn is_bytes(self) -> bool {\n         match self {\n-            Mode::Byte | Mode::ByteStr => true,\n-            Mode::Char | Mode::Str => false,\n+            Mode::Byte | Mode::ByteStr | Mode::RawByteStr => true,\n+            Mode::Char | Mode::Str | Mode::RawStr => false,\n         }\n     }\n }\n@@ -345,7 +335,7 @@ where\n \n fn byte_from_char(c: char) -> u8 {\n     let res = c as u32;\n-    assert!(res <= u8::max_value() as u32, \"guaranteed because of Mode::Byte(Str)\");\n+    assert!(res <= u8::max_value() as u32, \"guaranteed because of Mode::ByteStr\");\n     res as u8\n }\n "}, {"sha": "f2b751a78f27fbd11a2a16987e54b7ddabf7253c", "filename": "src/librustc_lexer/src/unescape/tests.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -102,7 +102,7 @@ fn test_unescape_char_good() {\n fn test_unescape_str_good() {\n     fn check(literal_text: &str, expected: &str) {\n         let mut buf = Ok(String::with_capacity(literal_text.len()));\n-        unescape_str(literal_text, &mut |range, c| {\n+        unescape_literal(literal_text, Mode::Str, &mut |range, c| {\n             if let Ok(b) = &mut buf {\n                 match c {\n                     Ok(c) => b.push(c),\n@@ -222,7 +222,7 @@ fn test_unescape_byte_good() {\n fn test_unescape_byte_str_good() {\n     fn check(literal_text: &str, expected: &[u8]) {\n         let mut buf = Ok(Vec::with_capacity(literal_text.len()));\n-        unescape_byte_str(literal_text, &mut |range, c| {\n+        unescape_byte_literal(literal_text, Mode::ByteStr, &mut |range, c| {\n             if let Ok(b) = &mut buf {\n                 match c {\n                     Ok(c) => b.push(c),\n@@ -246,7 +246,7 @@ fn test_unescape_byte_str_good() {\n fn test_unescape_raw_str() {\n     fn check(literal: &str, expected: &[(Range<usize>, Result<char, EscapeError>)]) {\n         let mut unescaped = Vec::with_capacity(literal.len());\n-        unescape_raw_str(literal, &mut |range, res| unescaped.push((range, res)));\n+        unescape_literal(literal, Mode::RawStr, &mut |range, res| unescaped.push((range, res)));\n         assert_eq!(unescaped, expected);\n     }\n \n@@ -258,7 +258,9 @@ fn test_unescape_raw_str() {\n fn test_unescape_raw_byte_str() {\n     fn check(literal: &str, expected: &[(Range<usize>, Result<u8, EscapeError>)]) {\n         let mut unescaped = Vec::with_capacity(literal.len());\n-        unescape_raw_byte_str(literal, &mut |range, res| unescaped.push((range, res)));\n+        unescape_byte_literal(literal, Mode::RawByteStr, &mut |range, res| {\n+            unescaped.push((range, res))\n+        });\n         assert_eq!(unescaped, expected);\n     }\n "}, {"sha": "327dbecba26ce6f0a47206fb0d4d9099bd46cff6", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -28,8 +28,8 @@ use rustc_ast::visit::{FnCtxt, FnKind};\n use rustc_ast_pretty::pprust::{self, expr_to_string};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n-use rustc_feature::Stability;\n use rustc_feature::{deprecated_attributes, AttributeGate, AttributeTemplate, AttributeType};\n+use rustc_feature::{GateIssue, Stability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -1817,13 +1817,21 @@ impl EarlyLintPass for IncompleteFeatures {\n             .map(|(name, span, _)| (name, span))\n             .chain(features.declared_lib_features.iter().map(|(name, span)| (name, span)))\n             .filter(|(name, _)| rustc_feature::INCOMPLETE_FEATURES.iter().any(|f| name == &f))\n-            .for_each(|(name, &span)| {\n+            .for_each(|(&name, &span)| {\n                 cx.struct_span_lint(INCOMPLETE_FEATURES, span, |lint| {\n-                    lint.build(&format!(\n-                        \"the feature `{}` is incomplete and may cause the compiler to crash\",\n+                    let mut builder = lint.build(&format!(\n+                        \"the feature `{}` is incomplete and may not be safe to use \\\n+                         and/or cause compiler crashes\",\n                         name,\n-                    ))\n-                    .emit()\n+                    ));\n+                    if let Some(n) = rustc_feature::find_feature_issue(name, GateIssue::Language) {\n+                        builder.note(&format!(\n+                            \"see issue #{} <https://github.com/rust-lang/rust/issues/{}> \\\n+                             for more information\",\n+                            n, n,\n+                        ));\n+                    }\n+                    builder.emit();\n                 })\n             });\n     }"}, {"sha": "703c2a7a443a9721a1dfca6a0fa1b35bd8b54f5e", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -888,7 +888,6 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             | ty::Generator(..)\n             | ty::GeneratorWitness(..)\n             | ty::Placeholder(..)\n-            | ty::UnnormalizedProjection(..)\n             | ty::Projection(..)\n             | ty::Opaque(..)\n             | ty::FnDef(..) => bug!(\"unexpected type in foreign function: {:?}\", ty),"}, {"sha": "c24079a6e4be234c9ec5156c8181d9dcd5785236", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -380,11 +380,27 @@ trait UnusedDelimLint {\n     );\n \n     fn is_expr_delims_necessary(inner: &ast::Expr, followed_by_block: bool) -> bool {\n-        followed_by_block\n-            && match inner.kind {\n-                ExprKind::Ret(_) | ExprKind::Break(..) => true,\n-                _ => parser::contains_exterior_struct_lit(&inner),\n+        // Prevent false-positives in cases like `fn x() -> u8 { ({ 0 } + 1) }`\n+        let lhs_needs_parens = {\n+            let mut innermost = inner;\n+            loop {\n+                if let ExprKind::Binary(_, lhs, _rhs) = &innermost.kind {\n+                    innermost = lhs;\n+                    if !rustc_ast::util::classify::expr_requires_semi_to_be_stmt(innermost) {\n+                        break true;\n+                    }\n+                } else {\n+                    break false;\n+                }\n             }\n+        };\n+\n+        lhs_needs_parens\n+            || (followed_by_block\n+                && match inner.kind {\n+                    ExprKind::Ret(_) | ExprKind::Break(..) => true,\n+                    _ => parser::contains_exterior_struct_lit(&inner),\n+                })\n     }\n \n     fn emit_unused_delims_expr("}, {"sha": "2a2169880a54e6e826a67c01b99bfcbbfa0aa344", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -7,7 +7,7 @@\n #![feature(nll)]\n #![feature(or_patterns)]\n #![feature(proc_macro_internals)]\n-#![feature(specialization)]\n+#![feature(specialization)] // FIXME: min_specialization ICEs\n #![feature(stmt_expr_attributes)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "682b335c5d071775f7e583930ebea1475e546483", "filename": "src/librustc_middle/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -72,9 +72,9 @@ impl rustc_query_system::dep_graph::DepKind for DepKind {\n         })\n     }\n \n-    fn read_deps<OP>(op: OP) -> ()\n+    fn read_deps<OP>(op: OP)\n     where\n-        OP: for<'a> FnOnce(Option<&'a Lock<TaskDeps>>) -> (),\n+        OP: for<'a> FnOnce(Option<&'a Lock<TaskDeps>>),\n     {\n         ty::tls::with_context_opt(|icx| {\n             let icx = if let Some(icx) = icx { icx } else { return };"}, {"sha": "b823516d64f3b76df30f9048204d0d02a7c5ac88", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -390,11 +390,7 @@ impl<'hir> Map<'hir> {\n     /// Given a `HirId`, returns the `BodyId` associated with it,\n     /// if the node is a body owner, otherwise returns `None`.\n     pub fn maybe_body_owned_by(&self, hir_id: HirId) -> Option<BodyId> {\n-        if let Some(node) = self.find(hir_id) {\n-            associated_body(node)\n-        } else {\n-            bug!(\"no entry for id `{}`\", hir_id)\n-        }\n+        self.find(hir_id).map(associated_body).flatten()\n     }\n \n     /// Given a body owner's id, returns the `BodyId` associated with it."}, {"sha": "1e3676496ce3934313afbb8b29dfd61797af3838", "filename": "src/librustc_middle/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -78,7 +78,6 @@ pub fn provide(providers: &mut Providers<'_>) {\n         &tcx.untracked_crate.modules[&module]\n     };\n     providers.hir_owner = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].signature;\n-    providers.hir_owner_nodes =\n-        |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].with_bodies.as_ref().map(|nodes| &**nodes);\n+    providers.hir_owner_nodes = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].with_bodies.as_deref();\n     map::provide(providers);\n }"}, {"sha": "d0f627d8bc5764f36960a610d702a4f9bbed9c1b", "filename": "src/librustc_middle/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flib.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -41,7 +41,7 @@\n #![feature(option_expect_none)]\n #![feature(or_patterns)]\n #![feature(range_is_empty)]\n-#![feature(specialization)]\n+#![feature(specialization)] // FIXME: min_specialization does not work\n #![feature(track_caller)]\n #![feature(trusted_len)]\n #![feature(vec_remove_item)]"}, {"sha": "f02d8fe8ad6018278a050cbefcb487c5b4ed942a", "filename": "src/librustc_middle/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -4,7 +4,7 @@\n //! For more information about how MIR-based region-checking works,\n //! see the [rustc dev guide].\n //!\n-//! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/mir/borrowck.html\n+//! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/borrow_check.html\n \n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::ty::{self, DefIdTree, TyCtxt};\n@@ -181,7 +181,7 @@ impl Scope {\n                 // `blk`; reuse span of `blk` and shift `lo`\n                 // forward to end of indexed statement.\n                 //\n-                // (This is the special case aluded to in the\n+                // (This is the special case alluded to in the\n                 // doc-comment for this method)\n \n                 let stmt_span = blk.stmts[first_statement_index.index()].span;"}, {"sha": "70cc546199b79e31c6db9b9cfac976769e884c6c", "filename": "src/librustc_middle/mir/interpret/pointer.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -89,27 +89,35 @@ pub struct Pointer<Tag = ()> {\n \n static_assert_size!(Pointer, 16);\n \n+/// Print the address of a pointer (without the tag)\n+fn print_ptr_addr<Tag>(ptr: &Pointer<Tag>, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    // Forward `alternate` flag to `alloc_id` printing.\n+    if f.alternate() {\n+        write!(f, \"{:#?}\", ptr.alloc_id)?;\n+    } else {\n+        write!(f, \"{:?}\", ptr.alloc_id)?;\n+    }\n+    // Print offset only if it is non-zero.\n+    if ptr.offset.bytes() > 0 {\n+        write!(f, \"+0x{:x}\", ptr.offset.bytes())?;\n+    }\n+    Ok(())\n+}\n+\n // We want the `Debug` output to be readable as it is used by `derive(Debug)` for\n // all the Miri types.\n // We have to use `Debug` output for the tag, because `()` does not implement\n // `Display` so we cannot specialize that.\n impl<Tag: fmt::Debug> fmt::Debug for Pointer<Tag> {\n     default fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if f.alternate() {\n-            write!(f, \"{:#?}+0x{:x}[{:?}]\", self.alloc_id, self.offset.bytes(), self.tag)\n-        } else {\n-            write!(f, \"{:?}+0x{:x}[{:?}]\", self.alloc_id, self.offset.bytes(), self.tag)\n-        }\n+        print_ptr_addr(self, f)?;\n+        write!(f, \"[{:?}]\", self.tag)\n     }\n }\n // Specialization for no tag\n impl fmt::Debug for Pointer<()> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if f.alternate() {\n-            write!(f, \"{:#?}+0x{:x}\", self.alloc_id, self.offset.bytes())\n-        } else {\n-            write!(f, \"{:?}+0x{:x}\", self.alloc_id, self.offset.bytes())\n-        }\n+        print_ptr_addr(self, f)\n     }\n }\n "}, {"sha": "c889dbc0a449848603e6c7901b209fb374376982", "filename": "src/librustc_middle/mir/mono.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmono.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -239,6 +239,9 @@ pub struct CodegenUnit<'tcx> {\n     size_estimate: Option<usize>,\n }\n \n+/// Specifies the linkage type for a `MonoItem`.\n+///\n+/// See https://llvm.org/docs/LangRef.html#linkage-types for more details about these variants.\n #[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Linkage {\n     External,"}, {"sha": "1f097f24942decf27a19892b858a94c04c623e5d", "filename": "src/librustc_middle/mir/visit.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fvisit.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -427,13 +427,29 @@ macro_rules! make_mir_visitor {\n                     TerminatorKind::Goto { .. } |\n                     TerminatorKind::Resume |\n                     TerminatorKind::Abort |\n-                    TerminatorKind::Return |\n                     TerminatorKind::GeneratorDrop |\n                     TerminatorKind::Unreachable |\n                     TerminatorKind::FalseEdges { .. } |\n                     TerminatorKind::FalseUnwind { .. } => {\n                     }\n \n+                    TerminatorKind::Return => {\n+                        // `return` logically moves from the return place `_0`. Note that the place\n+                        // cannot be changed by any visitor, though.\n+                        let $($mutability)? local = RETURN_PLACE;\n+                        self.visit_local(\n+                            & $($mutability)? local,\n+                            PlaceContext::NonMutatingUse(NonMutatingUseContext::Move),\n+                            source_location,\n+                        );\n+\n+                        assert_eq!(\n+                            local,\n+                            RETURN_PLACE,\n+                            \"`MutVisitor` tried to mutate return place of `return` terminator\"\n+                        );\n+                    }\n+\n                     TerminatorKind::SwitchInt {\n                         discr,\n                         switch_ty,"}, {"sha": "13cf9a934b72c78bdf3125d312a8e1f96c664e2f", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1164,6 +1164,12 @@ rustc_queries! {\n             desc { \"evaluating trait selection obligation `{}`\", goal.value }\n         }\n \n+        query type_implements_trait(\n+            key: (DefId, Ty<'tcx>, SubstsRef<'tcx>, ty::ParamEnv<'tcx>, )\n+        ) -> bool {\n+            desc { \"evaluating `type_implements_trait` `{:?}`\", key }\n+        }\n+\n         /// Do not call this query directly: part of the `Eq` type-op\n         query type_op_ascribe_user_type(\n             goal: CanonicalTypeOpAscribeUserTypeGoal<'tcx>"}, {"sha": "e030125b5b15c3adbb27d46f4bf6a80d1e717046", "filename": "src/librustc_middle/traits/query.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fquery.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -255,8 +255,6 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         | ty::Infer(_)\n         | ty::Bound(..)\n         | ty::Generator(..) => false,\n-\n-        ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n     }\n }\n "}, {"sha": "52ebcd63e7cda40a5e807cfee3529551ed11d9de", "filename": "src/librustc_middle/ty/adjustment.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fadjustment.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -2,6 +2,7 @@ use crate::ty::subst::SubstsRef;\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_hir::lang_items::{DerefMutTraitLangItem, DerefTraitLangItem};\n use rustc_macros::HashStable;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n@@ -117,11 +118,11 @@ pub struct OverloadedDeref<'tcx> {\n impl<'tcx> OverloadedDeref<'tcx> {\n     pub fn method_call(&self, tcx: TyCtxt<'tcx>, source: Ty<'tcx>) -> (DefId, SubstsRef<'tcx>) {\n         let trait_def_id = match self.mutbl {\n-            hir::Mutability::Not => tcx.lang_items().deref_trait(),\n-            hir::Mutability::Mut => tcx.lang_items().deref_mut_trait(),\n+            hir::Mutability::Not => tcx.require_lang_item(DerefTraitLangItem, None),\n+            hir::Mutability::Mut => tcx.require_lang_item(DerefMutTraitLangItem, None),\n         };\n         let method_def_id = tcx\n-            .associated_items(trait_def_id.unwrap())\n+            .associated_items(trait_def_id)\n             .in_definition_order()\n             .find(|m| m.kind == ty::AssocKind::Fn)\n             .unwrap()"}, {"sha": "7feb080d4b8d421d844090ae8eb8e8f754e727b0", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1878,7 +1878,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             Bound,\n             Param,\n             Infer,\n-            UnnormalizedProjection,\n             Projection,\n             Opaque,\n             Foreign"}, {"sha": "cf63a659e6c0f652e656c8300e1e01f0e73a5e21", "filename": "src/librustc_middle/ty/error.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ferror.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -284,7 +284,6 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Infer(ty::FreshIntTy(_)) => \"fresh integral type\".into(),\n             ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".into(),\n             ty::Projection(_) => \"associated type\".into(),\n-            ty::UnnormalizedProjection(_) => \"non-normalized associated type\".into(),\n             ty::Param(p) => format!(\"type parameter `{}`\", p).into(),\n             ty::Opaque(..) => \"opaque type\".into(),\n             ty::Error => \"type error\".into(),\n@@ -323,7 +322,6 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Placeholder(..) => \"higher-ranked type\".into(),\n             ty::Bound(..) => \"bound type variable\".into(),\n             ty::Projection(_) => \"associated type\".into(),\n-            ty::UnnormalizedProjection(_) => \"associated type\".into(),\n             ty::Param(_) => \"type parameter\".into(),\n             ty::Opaque(..) => \"opaque type\".into(),\n         }"}, {"sha": "16d8e37940763646d83655fae5b3d63da737319e", "filename": "src/librustc_middle/ty/fast_reject.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ffast_reject.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -90,7 +90,6 @@ pub fn simplify_type(\n         ty::Never => Some(NeverSimplifiedType),\n         ty::Tuple(ref tys) => Some(TupleSimplifiedType(tys.len())),\n         ty::FnPtr(ref f) => Some(FunctionSimplifiedType(f.skip_binder().inputs().len())),\n-        ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n         ty::Projection(_) | ty::Param(_) => {\n             if can_simplify_params {\n                 // In normalized types, projections don't unify with"}, {"sha": "042ffc4d1e55013a5fbd29c2b754af459234b38a", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -121,11 +121,6 @@ impl FlagComputation {\n                 self.add_projection_ty(data);\n             }\n \n-            &ty::UnnormalizedProjection(ref data) => {\n-                self.add_flags(TypeFlags::HAS_TY_PROJECTION);\n-                self.add_projection_ty(data);\n-            }\n-\n             &ty::Opaque(_, substs) => {\n                 self.add_flags(TypeFlags::HAS_TY_OPAQUE);\n                 self.add_substs(substs);"}, {"sha": "1ce079821a22e52665609836777f986e2654a681", "filename": "src/librustc_middle/ty/instance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Finstance.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -4,7 +4,7 @@ use crate::ty::{self, SubstsRef, Ty, TyCtxt, TypeFoldable};\n use rustc_errors::ErrorReported;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::{CrateNum, DefId};\n-use rustc_hir::lang_items::DropInPlaceFnLangItem;\n+use rustc_hir::lang_items::{DropInPlaceFnLangItem, FnOnceTraitLangItem};\n use rustc_macros::HashStable;\n \n use std::fmt;\n@@ -375,7 +375,7 @@ impl<'tcx> Instance<'tcx> {\n         substs: ty::SubstsRef<'tcx>,\n     ) -> Instance<'tcx> {\n         debug!(\"fn_once_adapter_shim({:?}, {:?})\", closure_did, substs);\n-        let fn_once = tcx.lang_items().fn_once_trait().unwrap();\n+        let fn_once = tcx.require_lang_item(FnOnceTraitLangItem, None);\n         let call_once = tcx\n             .associated_items(fn_once)\n             .in_definition_order()"}, {"sha": "2d49d85c4df54a36107d37b2114a54d26bc692cf", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -8,6 +8,7 @@ use rustc_ast::ast::{self, IntTy, UintTy};\n use rustc_attr as attr;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir as hir;\n+use rustc_hir::lang_items::{GeneratorStateLangItem, PinTypeLangItem};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_session::{DataTypeKind, FieldInfo, SizeKind, VariantInfo};\n@@ -1241,11 +1242,9 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 tcx.layout_raw(param_env.and(normalized))?\n             }\n \n-            ty::Bound(..)\n-            | ty::Placeholder(..)\n-            | ty::UnnormalizedProjection(..)\n-            | ty::GeneratorWitness(..)\n-            | ty::Infer(_) => bug!(\"Layout::compute: unexpected type `{}`\", ty),\n+            ty::Bound(..) | ty::Placeholder(..) | ty::GeneratorWitness(..) | ty::Infer(_) => {\n+                bug!(\"Layout::compute: unexpected type `{}`\", ty)\n+            }\n \n             ty::Param(_) | ty::Error => {\n                 return Err(LayoutError::Unknown(ty));\n@@ -2138,7 +2137,6 @@ where\n             }\n \n             ty::Projection(_)\n-            | ty::UnnormalizedProjection(..)\n             | ty::Bound(..)\n             | ty::Placeholder(..)\n             | ty::Opaque(..)\n@@ -2317,13 +2315,13 @@ impl<'tcx> ty::Instance<'tcx> {\n                 let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n                 let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n \n-                let pin_did = tcx.lang_items().pin_type().unwrap();\n+                let pin_did = tcx.require_lang_item(PinTypeLangItem, None);\n                 let pin_adt_ref = tcx.adt_def(pin_did);\n                 let pin_substs = tcx.intern_substs(&[env_ty.into()]);\n                 let env_ty = tcx.mk_adt(pin_adt_ref, pin_substs);\n \n                 sig.map_bound(|sig| {\n-                    let state_did = tcx.lang_items().gen_state().unwrap();\n+                    let state_did = tcx.require_lang_item(GeneratorStateLangItem, None);\n                     let state_adt_ref = tcx.adt_def(state_did);\n                     let state_substs = tcx.intern_substs(&[\n                         sig.yield_ty.into(),"}, {"sha": "6427c547a8f295afbed58035d186a354237dab4e", "filename": "src/librustc_middle/ty/list.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flist.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,149 @@\n+use crate::arena::Arena;\n+\n+use rustc_serialize::{Encodable, Encoder};\n+\n+use std::cmp::{self, Ordering};\n+use std::fmt;\n+use std::hash::{Hash, Hasher};\n+use std::mem;\n+use std::ops::Deref;\n+use std::ptr;\n+use std::slice;\n+\n+extern \"C\" {\n+    /// A dummy type used to force `List` to be unsized while not requiring references to it be wide\n+    /// pointers.\n+    type OpaqueListContents;\n+}\n+\n+/// A wrapper for slices with the additional invariant\n+/// that the slice is interned and no other slice with\n+/// the same contents can exist in the same context.\n+/// This means we can use pointer for both\n+/// equality comparisons and hashing.\n+/// Note: `Slice` was already taken by the `Ty`.\n+#[repr(C)]\n+pub struct List<T> {\n+    len: usize,\n+    data: [T; 0],\n+    opaque: OpaqueListContents,\n+}\n+\n+unsafe impl<T: Sync> Sync for List<T> {}\n+\n+impl<T: Copy> List<T> {\n+    #[inline]\n+    pub(super) fn from_arena<'tcx>(arena: &'tcx Arena<'tcx>, slice: &[T]) -> &'tcx List<T> {\n+        assert!(!mem::needs_drop::<T>());\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(!slice.is_empty());\n+\n+        // Align up the size of the len (usize) field\n+        let align = mem::align_of::<T>();\n+        let align_mask = align - 1;\n+        let offset = mem::size_of::<usize>();\n+        let offset = (offset + align_mask) & !align_mask;\n+\n+        let size = offset + slice.len() * mem::size_of::<T>();\n+\n+        let mem = arena\n+            .dropless\n+            .alloc_raw(size, cmp::max(mem::align_of::<T>(), mem::align_of::<usize>()));\n+        unsafe {\n+            let result = &mut *(mem.as_mut_ptr() as *mut List<T>);\n+            // Write the length\n+            result.len = slice.len();\n+\n+            // Write the elements\n+            let arena_slice = slice::from_raw_parts_mut(result.data.as_mut_ptr(), result.len);\n+            arena_slice.copy_from_slice(slice);\n+\n+            result\n+        }\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for List<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (**self).fmt(f)\n+    }\n+}\n+\n+impl<T: Encodable> Encodable for List<T> {\n+    #[inline]\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        (**self).encode(s)\n+    }\n+}\n+\n+impl<T> Ord for List<T>\n+where\n+    T: Ord,\n+{\n+    fn cmp(&self, other: &List<T>) -> Ordering {\n+        if self == other { Ordering::Equal } else { <[T] as Ord>::cmp(&**self, &**other) }\n+    }\n+}\n+\n+impl<T> PartialOrd for List<T>\n+where\n+    T: PartialOrd,\n+{\n+    fn partial_cmp(&self, other: &List<T>) -> Option<Ordering> {\n+        if self == other {\n+            Some(Ordering::Equal)\n+        } else {\n+            <[T] as PartialOrd>::partial_cmp(&**self, &**other)\n+        }\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for List<T> {\n+    #[inline]\n+    fn eq(&self, other: &List<T>) -> bool {\n+        ptr::eq(self, other)\n+    }\n+}\n+impl<T: Eq> Eq for List<T> {}\n+\n+impl<T> Hash for List<T> {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        (self as *const List<T>).hash(s)\n+    }\n+}\n+\n+impl<T> Deref for List<T> {\n+    type Target = [T];\n+    #[inline(always)]\n+    fn deref(&self) -> &[T] {\n+        self.as_ref()\n+    }\n+}\n+\n+impl<T> AsRef<[T]> for List<T> {\n+    #[inline(always)]\n+    fn as_ref(&self) -> &[T] {\n+        unsafe { slice::from_raw_parts(self.data.as_ptr(), self.len) }\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a List<T> {\n+    type Item = &'a T;\n+    type IntoIter = <&'a [T] as IntoIterator>::IntoIter;\n+    #[inline(always)]\n+    fn into_iter(self) -> Self::IntoIter {\n+        self[..].iter()\n+    }\n+}\n+\n+impl<T> List<T> {\n+    #[inline(always)]\n+    pub fn empty<'a>() -> &'a List<T> {\n+        #[repr(align(64), C)]\n+        struct EmptySlice([u8; 64]);\n+        static EMPTY_SLICE: EmptySlice = EmptySlice([0; 64]);\n+        assert!(mem::align_of::<T>() <= 64);\n+        unsafe { &*(&EMPTY_SLICE as *const _ as *const List<T>) }\n+    }\n+}"}, {"sha": "6d6e1699feb222c37fde257fef0c083cac1f6405", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 147, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -4,7 +4,6 @@ pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n pub use self::Variance::*;\n \n-use crate::arena::Arena;\n use crate::hir::exports::ExportMap;\n use crate::ich::StableHashingContext;\n use crate::infer::canonical::Canonical;\n@@ -43,13 +42,11 @@ use rustc_span::Span;\n use rustc_target::abi::{Align, VariantIdx};\n \n use std::cell::RefCell;\n-use std::cmp::{self, Ordering};\n+use std::cmp::Ordering;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n-use std::ops::Deref;\n use std::ops::Range;\n-use std::slice;\n-use std::{mem, ptr};\n+use std::ptr;\n \n pub use self::sty::BoundRegion::*;\n pub use self::sty::InferTy::*;\n@@ -81,6 +78,8 @@ pub use self::context::{\n \n pub use self::instance::{Instance, InstanceDef};\n \n+pub use self::list::List;\n+\n pub use self::trait_def::TraitDef;\n \n pub use self::query::queries;\n@@ -112,6 +111,7 @@ pub mod walk;\n mod context;\n mod diagnostics;\n mod instance;\n+mod list;\n mod structural_impls;\n mod sty;\n \n@@ -280,7 +280,7 @@ impl<'tcx> AssociatedItems<'tcx> {\n         &self,\n         name: Symbol,\n     ) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n-        self.items.get_by_key(&name).map(|v| *v)\n+        self.items.get_by_key(&name).copied()\n     }\n \n     /// Returns an iterator over all associated items with the given name.\n@@ -555,7 +555,7 @@ bitflags! {\n                                           | TypeFlags::HAS_CT_PLACEHOLDER.bits\n                                           | TypeFlags::HAS_FREE_LOCAL_REGIONS.bits;\n \n-        /// Does this have [Projection] or [UnnormalizedProjection]?\n+        /// Does this have [Projection]?\n         const HAS_TY_PROJECTION           = 1 << 10;\n         /// Does this have [Opaque]?\n         const HAS_TY_OPAQUE               = 1 << 11;\n@@ -663,148 +663,9 @@ pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n impl<'tcx> rustc_serialize::UseSpecializedEncodable for Ty<'tcx> {}\n impl<'tcx> rustc_serialize::UseSpecializedDecodable for Ty<'tcx> {}\n-\n-pub type CanonicalTy<'tcx> = Canonical<'tcx, Ty<'tcx>>;\n-\n-extern \"C\" {\n-    /// A dummy type used to force `List` to be unsized while not requiring references to it be wide\n-    /// pointers.\n-    type OpaqueListContents;\n-}\n-\n-/// A wrapper for slices with the additional invariant\n-/// that the slice is interned and no other slice with\n-/// the same contents can exist in the same context.\n-/// This means we can use pointer for both\n-/// equality comparisons and hashing.\n-/// Note: `Slice` was already taken by the `Ty`.\n-#[repr(C)]\n-pub struct List<T> {\n-    len: usize,\n-    data: [T; 0],\n-    opaque: OpaqueListContents,\n-}\n-\n-unsafe impl<T: Sync> Sync for List<T> {}\n-\n-impl<T: Copy> List<T> {\n-    #[inline]\n-    fn from_arena<'tcx>(arena: &'tcx Arena<'tcx>, slice: &[T]) -> &'tcx List<T> {\n-        assert!(!mem::needs_drop::<T>());\n-        assert!(mem::size_of::<T>() != 0);\n-        assert!(!slice.is_empty());\n-\n-        // Align up the size of the len (usize) field\n-        let align = mem::align_of::<T>();\n-        let align_mask = align - 1;\n-        let offset = mem::size_of::<usize>();\n-        let offset = (offset + align_mask) & !align_mask;\n-\n-        let size = offset + slice.len() * mem::size_of::<T>();\n-\n-        let mem = arena\n-            .dropless\n-            .alloc_raw(size, cmp::max(mem::align_of::<T>(), mem::align_of::<usize>()));\n-        unsafe {\n-            let result = &mut *(mem.as_mut_ptr() as *mut List<T>);\n-            // Write the length\n-            result.len = slice.len();\n-\n-            // Write the elements\n-            let arena_slice = slice::from_raw_parts_mut(result.data.as_mut_ptr(), result.len);\n-            arena_slice.copy_from_slice(slice);\n-\n-            result\n-        }\n-    }\n-}\n-\n-impl<T: fmt::Debug> fmt::Debug for List<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        (**self).fmt(f)\n-    }\n-}\n-\n-impl<T: Encodable> Encodable for List<T> {\n-    #[inline]\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        (**self).encode(s)\n-    }\n-}\n-\n-impl<T> Ord for List<T>\n-where\n-    T: Ord,\n-{\n-    fn cmp(&self, other: &List<T>) -> Ordering {\n-        if self == other { Ordering::Equal } else { <[T] as Ord>::cmp(&**self, &**other) }\n-    }\n-}\n-\n-impl<T> PartialOrd for List<T>\n-where\n-    T: PartialOrd,\n-{\n-    fn partial_cmp(&self, other: &List<T>) -> Option<Ordering> {\n-        if self == other {\n-            Some(Ordering::Equal)\n-        } else {\n-            <[T] as PartialOrd>::partial_cmp(&**self, &**other)\n-        }\n-    }\n-}\n-\n-impl<T: PartialEq> PartialEq for List<T> {\n-    #[inline]\n-    fn eq(&self, other: &List<T>) -> bool {\n-        ptr::eq(self, other)\n-    }\n-}\n-impl<T: Eq> Eq for List<T> {}\n-\n-impl<T> Hash for List<T> {\n-    #[inline]\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        (self as *const List<T>).hash(s)\n-    }\n-}\n-\n-impl<T> Deref for List<T> {\n-    type Target = [T];\n-    #[inline(always)]\n-    fn deref(&self) -> &[T] {\n-        self.as_ref()\n-    }\n-}\n-\n-impl<T> AsRef<[T]> for List<T> {\n-    #[inline(always)]\n-    fn as_ref(&self) -> &[T] {\n-        unsafe { slice::from_raw_parts(self.data.as_ptr(), self.len) }\n-    }\n-}\n-\n-impl<'a, T> IntoIterator for &'a List<T> {\n-    type Item = &'a T;\n-    type IntoIter = <&'a [T] as IntoIterator>::IntoIter;\n-    #[inline(always)]\n-    fn into_iter(self) -> Self::IntoIter {\n-        self[..].iter()\n-    }\n-}\n-\n impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx List<Ty<'tcx>> {}\n \n-impl<T> List<T> {\n-    #[inline(always)]\n-    pub fn empty<'a>() -> &'a List<T> {\n-        #[repr(align(64), C)]\n-        struct EmptySlice([u8; 64]);\n-        static EMPTY_SLICE: EmptySlice = EmptySlice([0; 64]);\n-        assert!(mem::align_of::<T>() <= 64);\n-        unsafe { &*(&EMPTY_SLICE as *const _ as *const List<T>) }\n-    }\n-}\n+pub type CanonicalTy<'tcx> = Canonical<'tcx, Ty<'tcx>>;\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UpvarPath {"}, {"sha": "afd670b85775b2de643c31cca6c93dda8ab3d06c", "filename": "src/librustc_middle/ty/outlives.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Foutlives.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -135,8 +135,6 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n                 }\n             }\n \n-            ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n-\n             // We assume that inference variables are fully resolved.\n             // So, if we encounter an inference variable, just record\n             // the unresolved variable as a component."}, {"sha": "69b36980bd73cee0f711682982bd12385fdd0fd4", "filename": "src/librustc_middle/ty/print/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -294,7 +294,6 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n         | ty::FnPtr(_)\n         | ty::Projection(_)\n         | ty::Placeholder(..)\n-        | ty::UnnormalizedProjection(..)\n         | ty::Param(_)\n         | ty::Opaque(..)\n         | ty::Infer(_)"}, {"sha": "41a6cd5466f5efc2956a9efab95f32dd80332db4", "filename": "src/librustc_middle/ty/print/obsolete.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fobsolete.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -148,7 +148,6 @@ impl DefPathBasedNames<'tcx> {\n             | ty::Bound(..)\n             | ty::Infer(_)\n             | ty::Placeholder(..)\n-            | ty::UnnormalizedProjection(..)\n             | ty::Projection(..)\n             | ty::Param(_)\n             | ty::GeneratorWitness(_)"}, {"sha": "64909cd0c467afb2d71a73280a4e8431c0a9e897", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -540,9 +540,6 @@ pub trait PrettyPrinter<'tcx>:\n                 p!(print_def_path(def_id, &[]));\n             }\n             ty::Projection(ref data) => p!(print(data)),\n-            ty::UnnormalizedProjection(ref data) => {\n-                p!(write(\"Unnormalized(\"), print(data), write(\")\"))\n-            }\n             ty::Placeholder(placeholder) => p!(write(\"Placeholder({:?})\", placeholder)),\n             ty::Opaque(def_id, substs) => {\n                 // FIXME(eddyb) print this with `print_def_path`.\n@@ -701,12 +698,14 @@ pub trait PrettyPrinter<'tcx>:\n                 if self.tcx().sess.verbose() {\n                     p!(write(\"{:?}\", sz));\n                 } else if let ty::ConstKind::Unevaluated(..) = sz.val {\n-                    // do not try to evaluate unevaluated constants. If we are const evaluating an\n+                    // Do not try to evaluate unevaluated constants. If we are const evaluating an\n                     // array length anon const, rustc will (with debug assertions) print the\n                     // constant's path. Which will end up here again.\n                     p!(write(\"_\"));\n                 } else if let Some(n) = sz.val.try_to_bits(self.tcx().data_layout.pointer_size) {\n                     p!(write(\"{}\", n));\n+                } else if let ty::ConstKind::Param(param) = sz.val {\n+                    p!(write(\"{}\", param));\n                 } else {\n                     p!(write(\"_\"));\n                 }"}, {"sha": "4acf766f033d8360daa4af60d4d9b292bcd91080", "filename": "src/librustc_middle/ty/query/keys.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fkeys.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -295,3 +295,15 @@ impl Key for (Symbol, u32, u32) {\n         DUMMY_SP\n     }\n }\n+\n+impl<'tcx> Key for (DefId, Ty<'tcx>, SubstsRef<'tcx>, ty::ParamEnv<'tcx>) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n+    fn query_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+\n+    fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}"}, {"sha": "d68bc7221f92dd5e692daaea025edad1bff4fdac", "filename": "src/librustc_middle/ty/relate.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Frelate.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -477,11 +477,6 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n             Ok(tcx.mk_fn_ptr(fty))\n         }\n \n-        (ty::UnnormalizedProjection(a_data), ty::UnnormalizedProjection(b_data)) => {\n-            let projection_ty = relation.relate(a_data, b_data)?;\n-            Ok(tcx.mk_ty(ty::UnnormalizedProjection(projection_ty)))\n-        }\n-\n         // these two are already handled downstream in case of lazy normalization\n         (ty::Projection(a_data), ty::Projection(b_data)) => {\n             let projection_ty = relation.relate(a_data, b_data)?;"}, {"sha": "680b718792199605cf420ffbaafdd4094ded0399", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -888,9 +888,6 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::GeneratorWitness(types) => ty::GeneratorWitness(types.fold_with(folder)),\n             ty::Closure(did, substs) => ty::Closure(did, substs.fold_with(folder)),\n             ty::Projection(ref data) => ty::Projection(data.fold_with(folder)),\n-            ty::UnnormalizedProjection(ref data) => {\n-                ty::UnnormalizedProjection(data.fold_with(folder))\n-            }\n             ty::Opaque(did, substs) => ty::Opaque(did, substs.fold_with(folder)),\n \n             ty::Bool\n@@ -931,9 +928,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::Generator(_did, ref substs, _) => substs.visit_with(visitor),\n             ty::GeneratorWitness(ref types) => types.visit_with(visitor),\n             ty::Closure(_did, ref substs) => substs.visit_with(visitor),\n-            ty::Projection(ref data) | ty::UnnormalizedProjection(ref data) => {\n-                data.visit_with(visitor)\n-            }\n+            ty::Projection(ref data) => data.visit_with(visitor),\n             ty::Opaque(_, ref substs) => substs.visit_with(visitor),\n \n             ty::Bool"}, {"sha": "2ad673b2c194379cc77d6a532287b61b0e5be3d1", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -181,11 +181,6 @@ pub enum TyKind<'tcx> {\n     /// `<T as Trait<..>>::N`.\n     Projection(ProjectionTy<'tcx>),\n \n-    /// A placeholder type used when we do not have enough information\n-    /// to normalize the projection of an associated type to an\n-    /// existing concrete type. Currently only used with chalk-engine.\n-    UnnormalizedProjection(ProjectionTy<'tcx>),\n-\n     /// Opaque (`impl Trait`) type found in a return type.\n     /// The `DefId` comes either from\n     /// * the `impl Trait` ast::Ty node,\n@@ -2186,8 +2181,6 @@ impl<'tcx> TyS<'tcx> {\n \n             ty::Projection(_) | ty::Param(_) | ty::Opaque(..) => false,\n \n-            ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n-\n             ty::Infer(ty::TyVar(_)) => false,\n \n             ty::Bound(..)"}, {"sha": "8f125098ee68483638ad83c7f2683a7cfc0c3952", "filename": "src/librustc_middle/ty/trait_def.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -171,10 +171,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn all_impls(self, def_id: DefId) -> impl Iterator<Item = DefId> + 'tcx {\n         let TraitImpls { blanket_impls, non_blanket_impls } = self.trait_impls_of(def_id);\n \n-        blanket_impls\n-            .into_iter()\n-            .chain(non_blanket_impls.into_iter().map(|(_, v)| v).flatten())\n-            .cloned()\n+        blanket_impls.iter().chain(non_blanket_impls.iter().map(|(_, v)| v).flatten()).cloned()\n     }\n }\n "}, {"sha": "f9c10488ffbc0350bafac6e154ba0be381063b0b", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -745,8 +745,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             | ty::Opaque(..)\n             | ty::Param(_)\n             | ty::Placeholder(_)\n-            | ty::Projection(_)\n-            | ty::UnnormalizedProjection(_) => false,\n+            | ty::Projection(_) => false,\n         }\n     }\n \n@@ -1077,7 +1076,6 @@ pub fn needs_drop_components(\n         // These require checking for `Copy` bounds or `Adt` destructors.\n         ty::Adt(..)\n         | ty::Projection(..)\n-        | ty::UnnormalizedProjection(..)\n         | ty::Param(_)\n         | ty::Bound(..)\n         | ty::Placeholder(..)"}, {"sha": "0093c60d7689b6d09dc6871154fc3c3b08dd4443", "filename": "src/librustc_middle/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fwalk.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -127,7 +127,7 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                 stack.push(ty.into());\n                 stack.push(lt.into());\n             }\n-            ty::Projection(data) | ty::UnnormalizedProjection(data) => {\n+            ty::Projection(data) => {\n                 stack.extend(data.substs.iter().copied().rev());\n             }\n             ty::Dynamic(obj, lt) => {"}, {"sha": "a3ee49651ba7b9a0de492f705a5bb20edfe45f73", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -209,7 +209,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         nll_errors,\n     } = nll::compute_regions(\n         infcx,\n-        def_id.to_def_id(),\n+        def_id,\n         free_regions,\n         body,\n         &promoted,"}, {"sha": "b820b79c47fe8c547298925afff63a5abf04845c", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::{\n@@ -157,7 +157,7 @@ fn populate_polonius_move_facts(\n /// This may result in errors being reported.\n pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n     universal_regions: UniversalRegions<'tcx>,\n     body: &Body<'tcx>,\n     promoted: &IndexVec<Promoted, Body<'tcx>>,\n@@ -272,7 +272,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     // Dump facts if requested.\n     let polonius_output = all_facts.and_then(|all_facts| {\n         if infcx.tcx.sess.opts.debugging_opts.nll_facts {\n-            let def_path = infcx.tcx.def_path(def_id);\n+            let def_path = infcx.tcx.def_path(def_id.to_def_id());\n             let dir_path =\n                 PathBuf::from(\"nll-facts\").join(def_path.to_filename_friendly_no_crate());\n             all_facts.write_to_dir(dir_path, location_table).unwrap();\n@@ -292,7 +292,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n     // Solve the region constraints.\n     let (closure_region_requirements, nll_errors) =\n-        regioncx.solve(infcx, &body, def_id, polonius_output.clone());\n+        regioncx.solve(infcx, &body, def_id.to_def_id(), polonius_output.clone());\n \n     if !nll_errors.is_empty() {\n         // Suppress unhelpful extra errors in `infer_opaque_types`."}, {"sha": "edd2dc3c2de55acf0e0424511e9b329b8dcfb412", "filename": "src/librustc_mir/borrow_check/type_check/input_output.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -33,35 +33,37 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         //\n         // e.g., `|x: FxHashMap<_, &'static u32>| ...`\n         let user_provided_sig;\n-        if !self.tcx().is_closure(self.mir_def_id) {\n+        if !self.tcx().is_closure(self.mir_def_id.to_def_id()) {\n             user_provided_sig = None;\n         } else {\n-            let typeck_tables = self.tcx().typeck_tables_of(self.mir_def_id.expect_local());\n-            user_provided_sig = match typeck_tables.user_provided_sigs.get(&self.mir_def_id) {\n-                None => None,\n-                Some(user_provided_poly_sig) => {\n-                    // Instantiate the canonicalized variables from\n-                    // user-provided signature (e.g., the `_` in the code\n-                    // above) with fresh variables.\n-                    let (poly_sig, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n-                        body.span,\n-                        &user_provided_poly_sig,\n-                    );\n-\n-                    // Replace the bound items in the fn sig with fresh\n-                    // variables, so that they represent the view from\n-                    // \"inside\" the closure.\n-                    Some(\n-                        self.infcx\n-                            .replace_bound_vars_with_fresh_vars(\n+            let typeck_tables = self.tcx().typeck_tables_of(self.mir_def_id);\n+            user_provided_sig =\n+                match typeck_tables.user_provided_sigs.get(&self.mir_def_id.to_def_id()) {\n+                    None => None,\n+                    Some(user_provided_poly_sig) => {\n+                        // Instantiate the canonicalized variables from\n+                        // user-provided signature (e.g., the `_` in the code\n+                        // above) with fresh variables.\n+                        let (poly_sig, _) =\n+                            self.infcx.instantiate_canonical_with_fresh_inference_vars(\n                                 body.span,\n-                                LateBoundRegionConversionTime::FnCall,\n-                                &poly_sig,\n-                            )\n-                            .0,\n-                    )\n+                                &user_provided_poly_sig,\n+                            );\n+\n+                        // Replace the bound items in the fn sig with fresh\n+                        // variables, so that they represent the view from\n+                        // \"inside\" the closure.\n+                        Some(\n+                            self.infcx\n+                                .replace_bound_vars_with_fresh_vars(\n+                                    body.span,\n+                                    LateBoundRegionConversionTime::FnCall,\n+                                    &poly_sig,\n+                                )\n+                                .0,\n+                        )\n+                    }\n                 }\n-            }\n         };\n \n         debug!(\n@@ -120,7 +122,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if let Err(terr) = self.eq_opaque_type_and_type(\n             mir_output_ty,\n             normalized_output_ty,\n-            self.mir_def_id,\n+            self.mir_def_id.to_def_id(),\n             Locations::All(output_span),\n             ConstraintCategory::BoringNoLocation,\n         ) {\n@@ -143,7 +145,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             if let Err(err) = self.eq_opaque_type_and_type(\n                 mir_output_ty,\n                 user_provided_output_ty,\n-                self.mir_def_id,\n+                self.mir_def_id.to_def_id(),\n                 Locations::All(output_span),\n                 ConstraintCategory::BoringNoLocation,\n             ) {"}, {"sha": "bad176c603f35c8833b7dc11ef3ed696b2d29f8a", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -10,6 +10,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::lang_items::{CoerceUnsizedTraitLangItem, CopyTraitLangItem, SizedTraitLangItem};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n@@ -108,26 +109,22 @@ mod relate_tys;\n ///\n /// - `infcx` -- inference context to use\n /// - `param_env` -- parameter environment to use for trait solving\n-/// - `mir` -- MIR to type-check\n-/// - `mir_def_id` -- DefId from which the MIR is derived (must be local)\n-/// - `region_bound_pairs` -- the implied outlives obligations between type parameters\n-///   and lifetimes (e.g., `&'a T` implies `T: 'a`)\n-/// - `implicit_region_bound` -- a region which all generic parameters are assumed\n-///   to outlive; should represent the fn body\n-/// - `input_tys` -- fully liberated, but **not** normalized, expected types of the arguments;\n-///   the types of the input parameters found in the MIR itself will be equated with these\n-/// - `output_ty` -- fully liberated, but **not** normalized, expected return type;\n-///   the type for the RETURN_PLACE will be equated with this\n-/// - `liveness` -- results of a liveness computation on the MIR; used to create liveness\n-///   constraints for the regions in the types of variables\n+/// - `body` -- MIR body to type-check\n+/// - `promoted` -- map of promoted constants within `body`\n+/// - `mir_def_id` -- `LocalDefId` from which the MIR is derived\n+/// - `universal_regions` -- the universal regions from `body`s function signature\n+/// - `location_table` -- MIR location map of `body`\n+/// - `borrow_set` -- information about borrows occurring in `body`\n+/// - `all_facts` -- when using Polonius, this is the generated set of Polonius facts\n /// - `flow_inits` -- results of a maybe-init dataflow analysis\n /// - `move_data` -- move-data constructed when performing the maybe-init dataflow analysis\n+/// - `elements` -- MIR region map\n pub(crate) fn type_check<'mir, 'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n     promoted: &IndexVec<Promoted, Body<'tcx>>,\n-    mir_def_id: DefId,\n+    mir_def_id: LocalDefId,\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n     location_table: &LocationTable,\n     borrow_set: &BorrowSet<'tcx>,\n@@ -191,7 +188,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n \n fn type_check_internal<'a, 'tcx, R>(\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    mir_def_id: DefId,\n+    mir_def_id: LocalDefId,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &'a Body<'tcx>,\n     promoted: &'a IndexVec<Promoted, Body<'tcx>>,\n@@ -271,7 +268,7 @@ struct TypeVerifier<'a, 'b, 'tcx> {\n     body: &'b Body<'tcx>,\n     promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n     last_span: Span,\n-    mir_def_id: DefId,\n+    mir_def_id: LocalDefId,\n     errors_reported: bool,\n }\n \n@@ -506,7 +503,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n             let tcx = self.tcx();\n             let trait_ref = ty::TraitRef {\n-                def_id: tcx.lang_items().copy_trait().unwrap(),\n+                def_id: tcx.require_lang_item(CopyTraitLangItem, Some(self.last_span)),\n                 substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n             };\n \n@@ -815,7 +812,7 @@ struct TypeChecker<'a, 'tcx> {\n     /// User type annotations are shared between the main MIR and the MIR of\n     /// all of the promoted items.\n     user_type_annotations: &'a CanonicalUserTypeAnnotations<'tcx>,\n-    mir_def_id: DefId,\n+    mir_def_id: LocalDefId,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: ty::Region<'tcx>,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n@@ -963,7 +960,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn new(\n         infcx: &'a InferCtxt<'a, 'tcx>,\n         body: &'a Body<'tcx>,\n-        mir_def_id: DefId,\n+        mir_def_id: LocalDefId,\n         param_env: ty::ParamEnv<'tcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n         implicit_region_bound: ty::Region<'tcx>,\n@@ -1142,7 +1139,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // When you have `let x: impl Foo = ...` in a closure,\n                 // the resulting inferend values are stored with the\n                 // def-id of the base function.\n-                let parent_def_id = self.tcx().closure_base_def_id(self.mir_def_id);\n+                let parent_def_id = self.tcx().closure_base_def_id(self.mir_def_id.to_def_id());\n                 return self.eq_opaque_type_and_type(sub, sup, parent_def_id, locations, category);\n             } else {\n                 return Err(terr);\n@@ -1472,7 +1469,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 self.check_rvalue(body, rv, location);\n                 if !self.tcx().features().unsized_locals {\n                     let trait_ref = ty::TraitRef {\n-                        def_id: tcx.lang_items().sized_trait().unwrap(),\n+                        def_id: tcx.require_lang_item(SizedTraitLangItem, Some(self.last_span)),\n                         substs: tcx.mk_substs_trait(place_ty, &[]),\n                     };\n                     self.prove_trait_ref(\n@@ -1994,7 +1991,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n                             let ccx = ConstCx::new_with_param_env(\n                                 tcx,\n-                                self.mir_def_id.expect_local(),\n+                                self.mir_def_id,\n                                 body,\n                                 self.param_env,\n                             );\n@@ -2010,16 +2007,17 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 &traits::Obligation::new(\n                                     ObligationCause::new(\n                                         span,\n-                                        self.tcx()\n-                                            .hir()\n-                                            .local_def_id_to_hir_id(self.mir_def_id.expect_local()),\n+                                        self.tcx().hir().local_def_id_to_hir_id(self.mir_def_id),\n                                         traits::ObligationCauseCode::RepeatVec(should_suggest),\n                                     ),\n                                     self.param_env,\n                                     ty::Predicate::Trait(\n                                         ty::Binder::bind(ty::TraitPredicate {\n                                             trait_ref: ty::TraitRef::new(\n-                                                self.tcx().lang_items().copy_trait().unwrap(),\n+                                                self.tcx().require_lang_item(\n+                                                    CopyTraitLangItem,\n+                                                    Some(self.last_span),\n+                                                ),\n                                                 tcx.mk_substs_trait(ty, &[]),\n                                             ),\n                                         }),\n@@ -2043,7 +2041,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n \n                 let trait_ref = ty::TraitRef {\n-                    def_id: tcx.lang_items().sized_trait().unwrap(),\n+                    def_id: tcx.require_lang_item(SizedTraitLangItem, Some(self.last_span)),\n                     substs: tcx.mk_substs_trait(ty, &[]),\n                 };\n \n@@ -2141,7 +2139,10 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     CastKind::Pointer(PointerCast::Unsize) => {\n                         let &ty = ty;\n                         let trait_ref = ty::TraitRef {\n-                            def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n+                            def_id: tcx.require_lang_item(\n+                                CoerceUnsizedTraitLangItem,\n+                                Some(self.last_span),\n+                            ),\n                             substs: tcx.mk_substs_trait(op.ty(body, tcx), &[ty.into()]),\n                         };\n "}, {"sha": "0637ebf959e5a6b1ef0bd340a83481b913f51da9", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -66,7 +66,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n         intern_kind,\n         ret,\n         body.ignore_interior_mut_in_const_validation,\n-    )?;\n+    );\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret)"}, {"sha": "7f557e340bbc8caa4ae4983f9a1ffcbf60c55928", "filename": "src/librustc_mir/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -53,7 +53,7 @@ pub(crate) fn const_caller_location(\n     let mut ecx = mk_eval_cx(tcx, DUMMY_SP, ty::ParamEnv::reveal_all(), false);\n \n     let loc_place = ecx.alloc_caller_location(file, line, col);\n-    intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place, false).unwrap();\n+    intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place, false);\n     ConstValue::Scalar(loc_place.ptr)\n }\n "}, {"sha": "eba4dd336ade2d1bb110f7a1db0044b9caf65239", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -871,6 +871,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Our result will later be validated anyway, and there seems no good reason\n         // to have to fail early here.  This is also more consistent with\n         // `Memory::get_static_alloc` which has to use `const_eval_raw` to avoid cycles.\n+        // FIXME: We can hit delay_span_bug if this is an invalid const, interning finds\n+        // that problem, but we never run validation to show an error. Can we ensure\n+        // this does not happen?\n         let val = self.tcx.const_eval_raw(param_env.and(gid))?;\n         self.raw_const_to_mplace(val)\n     }"}, {"sha": "02a7f24a1e351d20438d1b36dc74f6466f243b8e", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 177, "deletions": 153, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -5,10 +5,9 @@\n \n use super::validity::RefTracking;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n-use rustc_middle::mir::interpret::{ErrorHandled, InterpResult};\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::mir::interpret::InterpResult;\n+use rustc_middle::ty::{self, query::TyCtxtAt, Ty};\n \n use rustc_ast::ast::Mutability;\n \n@@ -29,43 +28,45 @@ struct InternVisitor<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> {\n     /// The ectx from which we intern.\n     ecx: &'rt mut InterpCx<'mir, 'tcx, M>,\n     /// Previously encountered safe references.\n-    ref_tracking: &'rt mut RefTracking<(MPlaceTy<'tcx>, Mutability, InternMode)>,\n+    ref_tracking: &'rt mut RefTracking<(MPlaceTy<'tcx>, InternMode)>,\n     /// A list of all encountered allocations. After type-based interning, we traverse this list to\n     /// also intern allocations that are only referenced by a raw pointer or inside a union.\n     leftover_allocations: &'rt mut FxHashSet<AllocId>,\n-    /// The root node of the value that we're looking at. This field is never mutated and only used\n+    /// The root kind of the value that we're looking at. This field is never mutated and only used\n     /// for sanity assertions that will ICE when `const_qualif` screws up.\n     mode: InternMode,\n-    /// This field stores the mutability of the value *currently* being checked.\n-    /// When encountering a mutable reference, we determine the pointee mutability\n-    /// taking into account the mutability of the context: `& &mut i32` is entirely immutable,\n-    /// despite the nested mutable reference!\n-    /// The field gets updated when an `UnsafeCell` is encountered.\n-    mutability: Mutability,\n+    /// This field stores whether we are *currently* inside an `UnsafeCell`. This can affect\n+    /// the intern mode of references we encounter.\n+    inside_unsafe_cell: bool,\n \n     /// This flag is to avoid triggering UnsafeCells are not allowed behind references in constants\n     /// for promoteds.\n     /// It's a copy of `mir::Body`'s ignore_interior_mut_in_const_validation field\n-    ignore_interior_mut_in_const_validation: bool,\n+    ignore_interior_mut_in_const: bool,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n enum InternMode {\n-    /// Mutable references must in fact be immutable due to their surrounding immutability in a\n-    /// `static`. In a `static mut` we start out as mutable and thus can also contain further `&mut`\n-    /// that will actually be treated as mutable.\n-    Static,\n-    /// UnsafeCell is OK in the value of a constant: `const FOO = Cell::new(0)` creates\n-    /// a new cell every time it is used.\n+    /// A static and its current mutability.  Below shared references inside a `static mut`,\n+    /// this is *immutable*, and below mutable references inside an `UnsafeCell`, this\n+    /// is *mutable*.\n+    Static(hir::Mutability),\n+    /// The \"base value\" of a const, which can have `UnsafeCell` (as in `const FOO: Cell<i32>`),\n+    /// but that interior mutability is simply ignored.\n     ConstBase,\n-    /// `UnsafeCell` ICEs.\n-    Const,\n+    /// The \"inner values\" of a const with references, where `UnsafeCell` is an error.\n+    ConstInner,\n }\n \n /// Signalling data structure to ensure we don't recurse\n /// into the memory of other constants or statics\n struct IsStaticOrFn;\n \n+fn mutable_memory_in_const(tcx: TyCtxtAt<'_>, kind: &str) {\n+    // FIXME: show this in validation instead so we can point at where in the value the error is?\n+    tcx.sess.span_err(tcx.span, &format!(\"mutable memory ({}) is not allowed in constant\", kind));\n+}\n+\n /// Intern an allocation without looking at its children.\n /// `mode` is the mode of the environment where we found this pointer.\n /// `mutablity` is the mutability of the place to be interned; even if that says\n@@ -75,12 +76,11 @@ struct IsStaticOrFn;\n fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n     ecx: &'rt mut InterpCx<'mir, 'tcx, M>,\n     leftover_allocations: &'rt mut FxHashSet<AllocId>,\n-    mode: InternMode,\n     alloc_id: AllocId,\n-    mutability: Mutability,\n+    mode: InternMode,\n     ty: Option<Ty<'tcx>>,\n-) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n-    trace!(\"InternVisitor::intern {:?} with {:?}\", alloc_id, mutability,);\n+) -> Option<IsStaticOrFn> {\n+    trace!(\"intern_shallow {:?} with {:?}\", alloc_id, mode);\n     // remove allocation\n     let tcx = ecx.tcx;\n     let (kind, mut alloc) = match ecx.memory.alloc_map.remove(&alloc_id) {\n@@ -89,14 +89,15 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n             // Pointer not found in local memory map. It is either a pointer to the global\n             // map, or dangling.\n             // If the pointer is dangling (neither in local nor global memory), we leave it\n-            // to validation to error. The `delay_span_bug` ensures that we don't forget such\n-            // a check in validation.\n+            // to validation to error -- it has the much better error messages, pointing out where\n+            // in the value the dangling reference lies.\n+            // The `delay_span_bug` ensures that we don't forget such a check in validation.\n             if tcx.get_global_alloc(alloc_id).is_none() {\n                 tcx.sess.delay_span_bug(ecx.tcx.span, \"tried to intern dangling pointer\");\n             }\n             // treat dangling pointers like other statics\n             // just to stop trying to recurse into them\n-            return Ok(Some(IsStaticOrFn));\n+            return Some(IsStaticOrFn);\n         }\n     };\n     // This match is just a canary for future changes to `MemoryKind`, which most likely need\n@@ -107,45 +108,45 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n     // Set allocation mutability as appropriate. This is used by LLVM to put things into\n     // read-only memory, and also by Miri when evaluating other globals that\n     // access this one.\n-    if mode == InternMode::Static {\n-        // When `ty` is `None`, we assume no interior mutability.\n+    if let InternMode::Static(mutability) = mode {\n+        // For this, we need to take into account `UnsafeCell`. When `ty` is `None`, we assume\n+        // no interior mutability.\n         let frozen = ty.map_or(true, |ty| ty.is_freeze(ecx.tcx.tcx, ecx.param_env, ecx.tcx.span));\n         // For statics, allocation mutability is the combination of the place mutability and\n         // the type mutability.\n         // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n-        if mutability == Mutability::Not && frozen {\n+        let immutable = mutability == Mutability::Not && frozen;\n+        if immutable {\n             alloc.mutability = Mutability::Not;\n         } else {\n             // Just making sure we are not \"upgrading\" an immutable allocation to mutable.\n             assert_eq!(alloc.mutability, Mutability::Mut);\n         }\n     } else {\n-        // We *could* be non-frozen at `ConstBase`, for constants like `Cell::new(0)`.\n-        // But we still intern that as immutable as the memory cannot be changed once the\n-        // initial value was computed.\n-        // Constants are never mutable.\n-        assert_eq!(\n-            mutability,\n-            Mutability::Not,\n-            \"Something went very wrong: mutability requested for a constant\"\n-        );\n+        // No matter what, *constants are never mutable*. Mutating them is UB.\n+        // See const_eval::machine::MemoryExtra::can_access_statics for why\n+        // immutability is so important.\n+\n+        // There are no sensible checks we can do here; grep for `mutable_memory_in_const` to\n+        // find the checks we are doing elsewhere to avoid even getting here for memory\n+        // that \"wants\" to be mutable.\n         alloc.mutability = Mutability::Not;\n     };\n     // link the alloc id to the actual allocation\n     let alloc = tcx.intern_const_alloc(alloc);\n     leftover_allocations.extend(alloc.relocations().iter().map(|&(_, ((), reloc))| reloc));\n     tcx.set_alloc_id_memory(alloc_id, alloc);\n-    Ok(None)\n+    None\n }\n \n impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> InternVisitor<'rt, 'mir, 'tcx, M> {\n     fn intern_shallow(\n         &mut self,\n         alloc_id: AllocId,\n-        mutability: Mutability,\n+        mode: InternMode,\n         ty: Option<Ty<'tcx>>,\n-    ) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n-        intern_shallow(self.ecx, self.leftover_allocations, self.mode, alloc_id, mutability, ty)\n+    ) -> Option<IsStaticOrFn> {\n+        intern_shallow(self.ecx, self.leftover_allocations, alloc_id, mode, ty)\n     }\n }\n \n@@ -166,22 +167,22 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n     ) -> InterpResult<'tcx> {\n         if let Some(def) = mplace.layout.ty.ty_adt_def() {\n             if Some(def.did) == self.ecx.tcx.lang_items().unsafe_cell_type() {\n+                if self.mode == InternMode::ConstInner && !self.ignore_interior_mut_in_const {\n+                    // We do not actually make this memory mutable.  But in case the user\n+                    // *expected* it to be mutable, make sure we error.  This is just a\n+                    // sanity check to prevent users from accidentally exploiting the UB\n+                    // they caused.  It also helps us to find cases where const-checking\n+                    // failed to prevent an `UnsafeCell` (but as `ignore_interior_mut_in_const`\n+                    // shows that part is not airtight).\n+                    mutable_memory_in_const(self.ecx.tcx, \"`UnsafeCell`\");\n+                }\n                 // We are crossing over an `UnsafeCell`, we can mutate again. This means that\n                 // References we encounter inside here are interned as pointing to mutable\n                 // allocations.\n-                let old = std::mem::replace(&mut self.mutability, Mutability::Mut);\n-                if !self.ignore_interior_mut_in_const_validation {\n-                    assert_ne!(\n-                        self.mode,\n-                        InternMode::Const,\n-                        \"UnsafeCells are not allowed behind references in constants. This should \\\n-                        have been prevented statically by const qualification. If this were \\\n-                        allowed one would be able to change a constant at one use site and other \\\n-                        use sites could observe that mutation.\",\n-                    );\n-                }\n+                // Remember the `old` value to handle nested `UnsafeCell`.\n+                let old = std::mem::replace(&mut self.inside_unsafe_cell, true);\n                 let walked = self.walk_aggregate(mplace, fields);\n-                self.mutability = old;\n+                self.inside_unsafe_cell = old;\n                 return walked;\n             }\n         }\n@@ -191,78 +192,92 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n     fn visit_value(&mut self, mplace: MPlaceTy<'tcx>) -> InterpResult<'tcx> {\n         // Handle Reference types, as these are the only relocations supported by const eval.\n         // Raw pointers (and boxes) are handled by the `leftover_relocations` logic.\n+        let tcx = self.ecx.tcx;\n         let ty = mplace.layout.ty;\n-        if let ty::Ref(_, referenced_ty, mutability) = ty.kind {\n+        if let ty::Ref(_, referenced_ty, ref_mutability) = ty.kind {\n             let value = self.ecx.read_immediate(mplace.into())?;\n             let mplace = self.ecx.ref_to_mplace(value)?;\n+            assert_eq!(mplace.layout.ty, referenced_ty);\n             // Handle trait object vtables.\n             if let ty::Dynamic(..) =\n-                self.ecx.tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind\n+                tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind\n             {\n-                // Validation has already errored on an invalid vtable pointer so we can safely not\n-                // do anything if this is not a real pointer.\n+                // Validation will error (with a better message) on an invalid vtable pointer\n+                // so we can safely not do anything if this is not a real pointer.\n                 if let Scalar::Ptr(vtable) = mplace.meta.unwrap_meta() {\n-                    // Explicitly choose `Immutable` here, since vtables are immutable, even\n+                    // Explicitly choose const mode here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable.\n-                    self.intern_shallow(vtable.alloc_id, Mutability::Not, None)?;\n+                    self.intern_shallow(vtable.alloc_id, InternMode::ConstInner, None);\n                 } else {\n-                    self.ecx().tcx.sess.delay_span_bug(\n-                        rustc_span::DUMMY_SP,\n-                        \"vtables pointers cannot be integer pointers\",\n-                    );\n+                    // Let validation show the error message, but make sure it *does* error.\n+                    tcx.sess\n+                        .delay_span_bug(tcx.span, \"vtables pointers cannot be integer pointers\");\n                 }\n             }\n             // Check if we have encountered this pointer+layout combination before.\n             // Only recurse for allocation-backed pointers.\n             if let Scalar::Ptr(ptr) = mplace.ptr {\n-                // We do not have any `frozen` logic here, because it's essentially equivalent to\n-                // the mutability except for the outermost item. Only `UnsafeCell` can \"unfreeze\",\n-                // and we check that in `visit_aggregate`.\n-                // This is not an inherent limitation, but one that we know to be true, because\n-                // const qualification enforces it. We can lift it in the future.\n-                match (self.mode, mutability) {\n-                    // immutable references are fine everywhere\n-                    (_, hir::Mutability::Not) => {}\n-                    // all is \"good and well\" in the unsoundness of `static mut`\n+                // Compute the mode with which we intern this.\n+                let ref_mode = match self.mode {\n+                    InternMode::Static(mutbl) => {\n+                        // In statics, merge outer mutability with reference mutability and\n+                        // take into account whether we are in an `UnsafeCell`.\n \n-                    // mutable references are ok in `static`. Either they are treated as immutable\n-                    // because they are behind an immutable one, or they are behind an `UnsafeCell`\n-                    // and thus ok.\n-                    (InternMode::Static, hir::Mutability::Mut) => {}\n-                    // we statically prevent `&mut T` via `const_qualif` and double check this here\n-                    (InternMode::ConstBase | InternMode::Const, hir::Mutability::Mut) => {\n-                        match referenced_ty.kind {\n-                            ty::Array(_, n)\n-                                if n.eval_usize(self.ecx.tcx.tcx, self.ecx.param_env) == 0 => {}\n-                            ty::Slice(_)\n-                                if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)? == 0 => {}\n-                            _ => bug!(\"const qualif failed to prevent mutable references\"),\n+                        // The only way a mutable reference actually works as a mutable reference is\n+                        // by being in a `static mut` directly or behind another mutable reference.\n+                        // If there's an immutable reference or we are inside a `static`, then our\n+                        // mutable reference is equivalent to an immutable one. As an example:\n+                        // `&&mut Foo` is semantically equivalent to `&&Foo`\n+                        match ref_mutability {\n+                            _ if self.inside_unsafe_cell => {\n+                                // Inside an `UnsafeCell` is like inside a `static mut`, the \"outer\"\n+                                // mutability does not matter.\n+                                InternMode::Static(ref_mutability)\n+                            }\n+                            Mutability::Not => {\n+                                // A shared reference, things become immutable.\n+                                // We do *not* consier `freeze` here -- that is done more precisely\n+                                // when traversing the referenced data (by tracking `UnsafeCell`).\n+                                InternMode::Static(Mutability::Not)\n+                            }\n+                            Mutability::Mut => {\n+                                // Mutable reference.\n+                                InternMode::Static(mutbl)\n+                            }\n                         }\n                     }\n-                }\n-                // Compute the mutability with which we'll start visiting the allocation. This is\n-                // what gets changed when we encounter an `UnsafeCell`.\n-                //\n-                // The only way a mutable reference actually works as a mutable reference is\n-                // by being in a `static mut` directly or behind another mutable reference.\n-                // If there's an immutable reference or we are inside a static, then our\n-                // mutable reference is equivalent to an immutable one. As an example:\n-                // `&&mut Foo` is semantically equivalent to `&&Foo`\n-                let mutability = self.mutability.and(mutability);\n-                // Recursing behind references changes the intern mode for constants in order to\n-                // cause assertions to trigger if we encounter any `UnsafeCell`s.\n-                let mode = match self.mode {\n-                    InternMode::ConstBase => InternMode::Const,\n-                    other => other,\n+                    InternMode::ConstBase | InternMode::ConstInner => {\n+                        // Ignore `UnsafeCell`, everything is immutable.  Do some sanity checking\n+                        // for mutable references that we encounter -- they must all be ZST.\n+                        // This helps to prevent users from accidentally exploiting UB that they\n+                        // caused (by somehow getting a mutable reference in a `const`).\n+                        if ref_mutability == Mutability::Mut {\n+                            match referenced_ty.kind {\n+                                ty::Array(_, n)\n+                                    if n.eval_usize(tcx.tcx, self.ecx.param_env) == 0 => {}\n+                                ty::Slice(_)\n+                                    if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)?\n+                                        == 0 => {}\n+                                _ => mutable_memory_in_const(tcx, \"`&mut`\"),\n+                            }\n+                        } else {\n+                            // A shared reference. We cannot check `freeze` here due to references\n+                            // like `&dyn Trait` that are actually immutable.  We do check for\n+                            // concrete `UnsafeCell` when traversing the pointee though (if it is\n+                            // a new allocation, not yet interned).\n+                        }\n+                        // Go on with the \"inner\" rules.\n+                        InternMode::ConstInner\n+                    }\n                 };\n-                match self.intern_shallow(ptr.alloc_id, mutability, Some(mplace.layout.ty))? {\n+                match self.intern_shallow(ptr.alloc_id, ref_mode, Some(referenced_ty)) {\n                     // No need to recurse, these are interned already and statics may have\n                     // cycles, so we don't want to recurse there\n                     Some(IsStaticOrFn) => {}\n                     // intern everything referenced by this value. The mutability is taken from the\n                     // reference. It is checked above that mutable references only happen in\n                     // `static mut`\n-                    None => self.ref_tracking.track((mplace, mutability, mode), || ()),\n+                    None => self.ref_tracking.track((mplace, ref_mode), || ()),\n                 }\n             }\n             Ok(())\n@@ -273,6 +288,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n pub enum InternKind {\n     /// The `mutability` of the static, ignoring the type which may have interior mutability.\n     Static(hir::Mutability),\n@@ -281,71 +297,78 @@ pub enum InternKind {\n     ConstProp,\n }\n \n+/// Intern `ret` and everything it references.\n+///\n+/// This *cannot raise an interpreter error*.  Doing so is left to validation, which\n+/// tracks where in the value we are and thus can show much better error messages.\n+/// Any errors here would anyway be turned into `const_err` lints, whereas validation failures\n+/// are hard errors.\n pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     ecx: &mut InterpCx<'mir, 'tcx, M>,\n     intern_kind: InternKind,\n     ret: MPlaceTy<'tcx>,\n-    ignore_interior_mut_in_const_validation: bool,\n-) -> InterpResult<'tcx>\n-where\n+    ignore_interior_mut_in_const: bool,\n+) where\n     'tcx: 'mir,\n {\n     let tcx = ecx.tcx;\n-    let (base_mutability, base_intern_mode) = match intern_kind {\n-        // `static mut` doesn't care about interior mutability, it's mutable anyway\n-        InternKind::Static(mutbl) => (mutbl, InternMode::Static),\n+    let base_intern_mode = match intern_kind {\n+        InternKind::Static(mutbl) => InternMode::Static(mutbl),\n         // FIXME: what about array lengths, array initializers?\n-        InternKind::Constant | InternKind::ConstProp => (Mutability::Not, InternMode::ConstBase),\n-        InternKind::Promoted => (Mutability::Not, InternMode::ConstBase),\n+        InternKind::Constant | InternKind::ConstProp | InternKind::Promoted => {\n+            InternMode::ConstBase\n+        }\n     };\n \n     // Type based interning.\n-    // `ref_tracking` tracks typed references we have seen and still need to crawl for\n+    // `ref_tracking` tracks typed references we have already interned and still need to crawl for\n     // more typed information inside them.\n     // `leftover_allocations` collects *all* allocations we see, because some might not\n     // be available in a typed way. They get interned at the end.\n-    let mut ref_tracking = RefTracking::new((ret, base_mutability, base_intern_mode));\n+    let mut ref_tracking = RefTracking::empty();\n     let leftover_allocations = &mut FxHashSet::default();\n \n     // start with the outermost allocation\n     intern_shallow(\n         ecx,\n         leftover_allocations,\n-        base_intern_mode,\n         // The outermost allocation must exist, because we allocated it with\n         // `Memory::allocate`.\n         ret.ptr.assert_ptr().alloc_id,\n-        base_mutability,\n+        base_intern_mode,\n         Some(ret.layout.ty),\n-    )?;\n+    );\n \n-    while let Some(((mplace, mutability, mode), _)) = ref_tracking.todo.pop() {\n-        let interned = InternVisitor {\n+    ref_tracking.track((ret, base_intern_mode), || ());\n+\n+    while let Some(((mplace, mode), _)) = ref_tracking.todo.pop() {\n+        let res = InternVisitor {\n             ref_tracking: &mut ref_tracking,\n             ecx,\n             mode,\n             leftover_allocations,\n-            mutability,\n-            ignore_interior_mut_in_const_validation,\n+            ignore_interior_mut_in_const,\n+            inside_unsafe_cell: false,\n         }\n         .visit_value(mplace);\n-        if let Err(error) = interned {\n-            // This can happen when e.g. the tag of an enum is not a valid discriminant. We do have\n-            // to read enum discriminants in order to find references in enum variant fields.\n-            if let err_ub!(ValidationFailure(_)) = error.kind {\n-                let err = crate::const_eval::error_to_const_error(&ecx, error);\n-                match err.struct_error(\n-                    ecx.tcx,\n-                    \"it is undefined behavior to use this value\",\n-                    |mut diag| {\n-                        diag.note(crate::const_eval::note_on_undefined_behavior_error());\n-                        diag.emit();\n-                    },\n-                ) {\n-                    ErrorHandled::TooGeneric\n-                    | ErrorHandled::Reported(ErrorReported)\n-                    | ErrorHandled::Linted => {}\n-                }\n+        // We deliberately *ignore* interpreter errors here.  When there is a problem, the remaining\n+        // references are \"leftover\"-interned, and later validation will show a proper error\n+        // and point at the right part of the value causing the problem.\n+        match res {\n+            Ok(()) => {}\n+            Err(error) => {\n+                ecx.tcx.sess.delay_span_bug(\n+                    ecx.tcx.span,\n+                    \"error during interning should later cause validation failure\",\n+                );\n+                // Some errors shouldn't come up because creating them causes\n+                // an allocation, which we should avoid. When that happens,\n+                // dedicated error variants should be introduced instead.\n+                assert!(\n+                    !error.kind.allocates(),\n+                    \"interning encountered allocating error: {}\",\n+                    error\n+                );\n             }\n         }\n     }\n@@ -366,26 +389,27 @@ where\n                 InternKind::Static(_) => {}\n                 // Raw pointers in promoteds may only point to immutable things so we mark\n                 // everything as immutable.\n-                // It is UB to mutate through a raw pointer obtained via an immutable reference.\n+                // It is UB to mutate through a raw pointer obtained via an immutable reference:\n                 // Since all references and pointers inside a promoted must by their very definition\n                 // be created from an immutable reference (and promotion also excludes interior\n                 // mutability), mutating through them would be UB.\n                 // There's no way we can check whether the user is using raw pointers correctly,\n                 // so all we can do is mark this as immutable here.\n                 InternKind::Promoted => {\n+                    // See const_eval::machine::MemoryExtra::can_access_statics for why\n+                    // immutability is so important.\n                     alloc.mutability = Mutability::Not;\n                 }\n                 InternKind::Constant | InternKind::ConstProp => {\n-                    // If it's a constant, it *must* be immutable.\n-                    // We cannot have mutable memory inside a constant.\n-                    // We use `delay_span_bug` here, because this can be reached in the presence\n-                    // of fancy transmutes.\n-                    if alloc.mutability == Mutability::Mut {\n-                        // For better errors later, mark the allocation as immutable\n-                        // (on top of the delayed ICE).\n-                        alloc.mutability = Mutability::Not;\n-                        ecx.tcx.sess.delay_span_bug(ecx.tcx.span, \"mutable allocation in constant\");\n-                    }\n+                    // If it's a constant, we should not have any \"leftovers\" as everything\n+                    // is tracked by const-checking.\n+                    // FIXME: downgrade this to a warning? It rejects some legitimate consts,\n+                    // such as `const CONST_RAW: *const Vec<i32> = &Vec::new() as *const _;`.\n+                    ecx.tcx\n+                        .sess\n+                        .span_err(ecx.tcx.span, \"untyped pointers are not allowed in constant\");\n+                    // For better errors later, mark the allocation as immutable.\n+                    alloc.mutability = Mutability::Not;\n                 }\n             }\n             let alloc = tcx.intern_const_alloc(alloc);\n@@ -396,13 +420,13 @@ where\n                 }\n             }\n         } else if ecx.memory.dead_alloc_map.contains_key(&alloc_id) {\n-            // dangling pointer\n-            throw_ub_format!(\"encountered dangling pointer in final constant\")\n+            // Codegen does not like dangling pointers, and generally `tcx` assumes that\n+            // all allocations referenced anywhere actually exist. So, make sure we error here.\n+            ecx.tcx.sess.span_err(ecx.tcx.span, \"encountered dangling pointer in final constant\");\n         } else if ecx.tcx.get_global_alloc(alloc_id).is_none() {\n-            // We have hit an `AllocId` that is neither in local or global memory and isn't marked\n-            // as dangling by local memory.\n+            // We have hit an `AllocId` that is neither in local or global memory and isn't\n+            // marked as dangling by local memory.  That should be impossible.\n             span_bug!(ecx.tcx.span, \"encountered unknown alloc id {:?}\", alloc_id);\n         }\n     }\n-    Ok(())\n }"}, {"sha": "71cca725982f5bdd4ec16e6e4ca085c089a403f8", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -60,7 +60,6 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n             | ty::FnDef(def_id, substs)\n             | ty::Opaque(def_id, substs)\n             | ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs })\n-            | ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs })\n             | ty::Closure(def_id, substs)\n             | ty::Generator(def_id, substs, _) => self.print_def_path(def_id, substs),\n             ty::Foreign(def_id) => self.print_def_path(def_id, &[]),"}, {"sha": "f6020641d3e28ea4a3198cba7075403c89b86165", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::mir::interpret::{InterpError, InterpErrorInfo};\n use rustc_middle::ty;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_target::abi::{Abi, LayoutOf, Scalar, VariantIdx, Variants};\n+use rustc_target::abi::{Abi, LayoutOf, Scalar, Size, VariantIdx, Variants};\n \n use std::hash::Hash;\n \n@@ -566,7 +566,6 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             | ty::Bound(..)\n             | ty::Param(..)\n             | ty::Opaque(..)\n-            | ty::UnnormalizedProjection(..)\n             | ty::Projection(..)\n             | ty::GeneratorWitness(..) => bug!(\"Encountered invalid type {:?}\", ty),\n         }\n@@ -744,10 +743,11 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         match op.layout.ty.kind {\n             ty::Str => {\n                 let mplace = op.assert_mem_place(self.ecx); // strings are never immediate\n+                let len = mplace.len(self.ecx)?;\n                 try_validation!(\n-                    self.ecx.read_str(mplace),\n+                    self.ecx.memory.read_bytes(mplace.ptr, Size::from_bytes(len)),\n                     self.path,\n-                    err_ub!(InvalidStr(..)) => { \"uninitialized or non-UTF-8 data in str\" },\n+                    err_ub!(InvalidUninitBytes(..)) => { \"uninitialized data in `str`\" },\n                 );\n             }\n             ty::Array(tys, ..) | ty::Slice(tys)"}, {"sha": "785c6c21d74432f286b787795148d9627e0f53f5", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -19,7 +19,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(exhaustive_patterns)]\n #![feature(iter_order_by)]\n #![feature(never_type)]\n-#![feature(specialization)]\n+#![feature(min_specialization)]\n #![feature(trusted_len)]\n #![feature(try_blocks)]\n #![feature(associated_type_bounds)]"}, {"sha": "a8094990594f3ae83f98795ebe5092c7b35ba138", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -580,10 +580,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             }\n             mir::Rvalue::NullaryOp(mir::NullOp::Box, _) => {\n                 let tcx = self.tcx;\n-                let exchange_malloc_fn_def_id = tcx\n-                    .lang_items()\n-                    .require(ExchangeMallocFnLangItem)\n-                    .unwrap_or_else(|e| tcx.sess.fatal(&e));\n+                let exchange_malloc_fn_def_id =\n+                    tcx.require_lang_item(ExchangeMallocFnLangItem, None);\n                 let instance = Instance::mono(tcx, exchange_malloc_fn_def_id);\n                 if should_monomorphize_locally(tcx, &instance) {\n                     self.output.push(create_fn_mono_item(instance));"}, {"sha": "28edd87a3add5e055ebbeac083bb8f87ae559e2f", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -2,6 +2,8 @@ use rustc_middle::traits;\n use rustc_middle::ty::adjustment::CustomCoerceUnsized;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n+use rustc_hir::lang_items::CoerceUnsizedTraitLangItem;\n+\n pub mod collector;\n pub mod partitioning;\n \n@@ -10,7 +12,7 @@ pub fn custom_coerce_unsize_info<'tcx>(\n     source_ty: Ty<'tcx>,\n     target_ty: Ty<'tcx>,\n ) -> CustomCoerceUnsized {\n-    let def_id = tcx.lang_items().coerce_unsized_trait().unwrap();\n+    let def_id = tcx.require_lang_item(CoerceUnsizedTraitLangItem, None);\n \n     let trait_ref = ty::Binder::bind(ty::TraitRef {\n         def_id,"}, {"sha": "d025468d28bf302b5d1c9050caa6865cd0595d2c", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,5 +1,6 @@\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_hir::lang_items::FnMutTraitLangItem;\n use rustc_middle::mir::*;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n@@ -70,7 +71,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n             build_call_shim(tcx, instance, None, CallKind::Direct(def_id), None)\n         }\n         ty::InstanceDef::ClosureOnceShim { call_once: _ } => {\n-            let fn_mut = tcx.lang_items().fn_mut_trait().unwrap();\n+            let fn_mut = tcx.require_lang_item(FnMutTraitLangItem, None);\n             let call_mut = tcx\n                 .associated_items(fn_mut)\n                 .in_definition_order()"}, {"sha": "e1be1daca45a146d5c85e058b9a5294a4bfa2efc", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 90, "deletions": 45, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -349,8 +349,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn get_const(&self, local: Local) -> Option<OpTy<'tcx>> {\n-        let op = self.ecx.access_local(self.ecx.frame(), local, None).ok();\n+    fn get_const(&self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n+        let op = self.ecx.eval_place_to_op(place, None).ok();\n \n         // Try to read the local as an immediate so that if it is representable as a scalar, we can\n         // handle it as such, but otherwise, just return the value as is.\n@@ -616,6 +616,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         value: OpTy<'tcx>,\n         source_info: SourceInfo,\n     ) {\n+        if let Rvalue::Use(Operand::Constant(c)) = rval {\n+            if !matches!(c.literal.val, ConstKind::Unevaluated(..)) {\n+                trace!(\"skipping replace of Rvalue::Use({:?} because it is already a const\", c);\n+                return;\n+            }\n+        }\n+\n         trace!(\"attepting to replace {:?} with {:?}\", rval, value);\n         if let Err(e) = self.ecx.const_validate_operand(\n             value,\n@@ -702,8 +709,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             )) => l.is_bits() && r.is_bits(),\n             interpret::Operand::Indirect(_) if mir_opt_level >= 2 => {\n                 let mplace = op.assert_mem_place(&self.ecx);\n-                intern_const_alloc_recursive(&mut self.ecx, InternKind::ConstProp, mplace, false)\n-                    .expect(\"failed to intern alloc\");\n+                intern_const_alloc_recursive(&mut self.ecx, InternKind::ConstProp, mplace, false);\n                 true\n             }\n             _ => false,\n@@ -772,13 +778,29 @@ impl<'tcx> Visitor<'tcx> for CanConstProp {\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext, _: Location) {\n         use rustc_middle::mir::visit::PlaceContext::*;\n         match context {\n-            // Constants must have at most one write\n-            // FIXME(oli-obk): we could be more powerful here, if the multiple writes\n-            // only occur in independent execution paths\n-            MutatingUse(MutatingUseContext::Store) => {\n+            // Projections are fine, because `&mut foo.x` will be caught by\n+            // `MutatingUseContext::Borrow` elsewhere.\n+            MutatingUse(MutatingUseContext::Projection)\n+            // These are just stores, where the storing is not propagatable, but there may be later\n+            // mutations of the same local via `Store`\n+            | MutatingUse(MutatingUseContext::Call)\n+            // Actual store that can possibly even propagate a value\n+            | MutatingUse(MutatingUseContext::Store) => {\n                 if !self.found_assignment.insert(local) {\n-                    trace!(\"local {:?} can't be propagated because of multiple assignments\", local);\n-                    self.can_const_prop[local] = ConstPropMode::NoPropagation;\n+                    match &mut self.can_const_prop[local] {\n+                        // If the local can only get propagated in its own block, then we don't have\n+                        // to worry about multiple assignments, as we'll nuke the const state at the\n+                        // end of the block anyway, and inside the block we overwrite previous\n+                        // states as applicable.\n+                        ConstPropMode::OnlyInsideOwnBlock => {}\n+                        other => {\n+                            trace!(\n+                                \"local {:?} can't be propagated because of multiple assignments\",\n+                                local,\n+                            );\n+                            *other = ConstPropMode::NoPropagation;\n+                        }\n+                    }\n                 }\n             }\n             // Reading constants is allowed an arbitrary number of times\n@@ -787,13 +809,21 @@ impl<'tcx> Visitor<'tcx> for CanConstProp {\n             | NonMutatingUse(NonMutatingUseContext::Inspect)\n             | NonMutatingUse(NonMutatingUseContext::Projection)\n             | NonUse(_) => {}\n-            // FIXME(felix91gr): explain the reasoning behind this\n-            MutatingUse(MutatingUseContext::Projection) => {\n-                if self.local_kinds[local] != LocalKind::Temp {\n-                    self.can_const_prop[local] = ConstPropMode::NoPropagation;\n-                }\n-            }\n-            _ => {\n+\n+            // These could be propagated with a smarter analysis or just some careful thinking about\n+            // whether they'd be fine right now.\n+            MutatingUse(MutatingUseContext::AsmOutput)\n+            | MutatingUse(MutatingUseContext::Yield)\n+            | MutatingUse(MutatingUseContext::Drop)\n+            | MutatingUse(MutatingUseContext::Retag)\n+            // These can't ever be propagated under any scheme, as we can't reason about indirect\n+            // mutation.\n+            | NonMutatingUse(NonMutatingUseContext::SharedBorrow)\n+            | NonMutatingUse(NonMutatingUseContext::ShallowBorrow)\n+            | NonMutatingUse(NonMutatingUseContext::UniqueBorrow)\n+            | NonMutatingUse(NonMutatingUseContext::AddressOf)\n+            | MutatingUse(MutatingUseContext::Borrow)\n+            | MutatingUse(MutatingUseContext::AddressOf) => {\n                 trace!(\"local {:?} can't be propagaged because it's used: {:?}\", local, context);\n                 self.can_const_prop[local] = ConstPropMode::NoPropagation;\n             }\n@@ -826,40 +856,55 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n         if let StatementKind::Assign(box (place, ref mut rval)) = statement.kind {\n             let place_ty: Ty<'tcx> = place.ty(&self.local_decls, self.tcx).ty;\n             if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n-                if let Some(local) = place.as_local() {\n-                    let can_const_prop = self.can_const_prop[local];\n-                    if let Some(()) = self.const_prop(rval, place_layout, source_info, place) {\n-                        if can_const_prop != ConstPropMode::NoPropagation {\n-                            // This will return None for Locals that are from other blocks,\n-                            // so it should be okay to propagate from here on down.\n-                            if let Some(value) = self.get_const(local) {\n-                                if self.should_const_prop(value) {\n-                                    trace!(\"replacing {:?} with {:?}\", rval, value);\n-                                    self.replace_with_const(rval, value, statement.source_info);\n-                                    if can_const_prop == ConstPropMode::FullConstProp\n-                                        || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n-                                    {\n-                                        trace!(\"propagated into {:?}\", local);\n-                                    }\n-                                }\n-                                if can_const_prop == ConstPropMode::OnlyInsideOwnBlock {\n-                                    trace!(\n-                                        \"found local restricted to its block. Will remove it from const-prop after block is finished. Local: {:?}\",\n-                                        local\n-                                    );\n-                                    self.locals_of_current_block.insert(local);\n+                let can_const_prop = self.can_const_prop[place.local];\n+                if let Some(()) = self.const_prop(rval, place_layout, source_info, place) {\n+                    if can_const_prop != ConstPropMode::NoPropagation {\n+                        // This will return None for variables that are from other blocks,\n+                        // so it should be okay to propagate from here on down.\n+                        if let Some(value) = self.get_const(place) {\n+                            if self.should_const_prop(value) {\n+                                trace!(\"replacing {:?} with {:?}\", rval, value);\n+                                self.replace_with_const(rval, value, statement.source_info);\n+                                if can_const_prop == ConstPropMode::FullConstProp\n+                                    || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n+                                {\n+                                    trace!(\"propagated into {:?}\", place);\n                                 }\n                             }\n+                            if can_const_prop == ConstPropMode::OnlyInsideOwnBlock {\n+                                trace!(\n+                                    \"found local restricted to its block. Will remove it from const-prop after block is finished. Local: {:?}\",\n+                                    place.local\n+                                );\n+                                self.locals_of_current_block.insert(place.local);\n+                            }\n                         }\n                     }\n-                    if self.can_const_prop[local] == ConstPropMode::OnlyPropagateInto\n-                        || self.can_const_prop[local] == ConstPropMode::NoPropagation\n+                    if can_const_prop == ConstPropMode::OnlyPropagateInto\n+                        || can_const_prop == ConstPropMode::NoPropagation\n                     {\n-                        trace!(\"can't propagate into {:?}\", local);\n-                        if local != RETURN_PLACE {\n-                            Self::remove_const(&mut self.ecx, local);\n+                        trace!(\"can't propagate into {:?}\", place);\n+                        if place.local != RETURN_PLACE {\n+                            Self::remove_const(&mut self.ecx, place.local);\n                         }\n                     }\n+                } else {\n+                    // Const prop failed, so erase the destination, ensuring that whatever happens\n+                    // from here on, does not know about the previous value.\n+                    // This is important in case we have\n+                    // ```rust\n+                    // let mut x = 42;\n+                    // x = SOME_MUTABLE_STATIC;\n+                    // // x must now be undefined\n+                    // ```\n+                    // FIXME: we overzealously erase the entire local, because that's easier to\n+                    // implement.\n+                    trace!(\n+                        \"propagation into {:?} failed.\n+                        Nuking the entire site from orbit, it's the only way to be sure\",\n+                        place,\n+                    );\n+                    Self::remove_const(&mut self.ecx, place.local);\n                 }\n             }\n         } else {\n@@ -993,7 +1038,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                           arguments are of the variant `Operand::Copy`. This allows us to\n                           simplify our handling of `Operands` in this case.\n                         */\n-                        if let Some(l) = opr.place().and_then(|p| p.as_local()) {\n+                        if let Some(l) = opr.place() {\n                             if let Some(value) = self.get_const(l) {\n                                 if self.should_const_prop(value) {\n                                     // FIXME(felix91gr): this code only handles `Scalar` cases."}, {"sha": "ba406c72df8488225a10da8425e45b66752fdf8f", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -73,7 +73,12 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                     }\n                     // Conservatively gives up if the dest is an argument,\n                     // because there may be uses of the original argument value.\n-                    if body.local_kind(dest_local) == LocalKind::Arg {\n+                    // Also gives up on the return place, as we cannot propagate into its implicit\n+                    // use by `return`.\n+                    if matches!(\n+                        body.local_kind(dest_local),\n+                        LocalKind::Arg | LocalKind::ReturnPointer\n+                    ) {\n                         debug!(\"  Can't copy-propagate local: dest {:?} (argument)\", dest_local);\n                         continue;\n                     }"}, {"sha": "14faa5be02f4ee9f3f4cec734049b157278615f3", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -61,6 +61,7 @@ use crate::util::storage;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_hir::lang_items::{GeneratorStateLangItem, PinTypeLangItem};\n use rustc_index::bit_set::{BitMatrix, BitSet};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::visit::{MutVisitor, PlaceContext};\n@@ -91,6 +92,16 @@ impl<'tcx> MutVisitor<'tcx> for RenameLocalVisitor<'tcx> {\n             *local = self.to;\n         }\n     }\n+\n+    fn visit_terminator_kind(&mut self, kind: &mut TerminatorKind<'tcx>, location: Location) {\n+        match kind {\n+            TerminatorKind::Return => {\n+                // Do not replace the implicit `_0` access here, as that's not possible. The\n+                // transform already handles `return` correctly.\n+            }\n+            _ => self.super_terminator_kind(kind, location),\n+        }\n+    }\n }\n \n struct DerefArgVisitor<'tcx> {\n@@ -371,7 +382,7 @@ fn make_generator_state_argument_indirect<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Bo\n fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     let ref_gen_ty = body.local_decls.raw[1].ty;\n \n-    let pin_did = tcx.lang_items().pin_type().unwrap();\n+    let pin_did = tcx.require_lang_item(PinTypeLangItem, Some(body.span));\n     let pin_adt_ref = tcx.adt_def(pin_did);\n     let substs = tcx.intern_substs(&[ref_gen_ty.into()]);\n     let pin_ref_gen_ty = tcx.mk_adt(pin_adt_ref, substs);\n@@ -1197,7 +1208,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         };\n \n         // Compute GeneratorState<yield_ty, return_ty>\n-        let state_did = tcx.lang_items().gen_state().unwrap();\n+        let state_did = tcx.require_lang_item(GeneratorStateLangItem, None);\n         let state_adt_ref = tcx.adt_def(state_did);\n         let state_substs = tcx.intern_substs(&[yield_ty.into(), body.return_ty().into()]);\n         let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);"}, {"sha": "632408fde749f225ef864c88f92faaecf48917cd", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -732,7 +732,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n     }\n \n     fn visit_terminator_kind(&mut self, kind: &mut TerminatorKind<'tcx>, loc: Location) {\n-        self.super_terminator_kind(kind, loc);\n+        // Don't try to modify the implicit `_0` access on return (`return` terminators are\n+        // replaced down below anyways).\n+        if !matches!(kind, TerminatorKind::Return) {\n+            self.super_terminator_kind(kind, loc);\n+        }\n \n         match *kind {\n             TerminatorKind::GeneratorDrop | TerminatorKind::Yield { .. } => bug!(),"}, {"sha": "7ad5baac2051d59c1461a78c7cc210861a685095", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -317,12 +317,12 @@ fn run_optimization_passes<'tcx>(\n         //   2. It creates additional possibilities for some MIR optimizations to trigger\n         // FIXME(#70073): Why is this done here and not in `post_borrowck_cleanup`?\n         &deaggregator::Deaggregator,\n+        &simplify_try::SimplifyArmIdentity,\n+        &simplify_try::SimplifyBranchSame,\n         &copy_prop::CopyPropagation,\n         &simplify_branches::SimplifyBranches::new(\"after-copy-prop\"),\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n         &simplify::SimplifyCfg::new(\"after-remove-noop-landing-pads\"),\n-        &simplify_try::SimplifyArmIdentity,\n-        &simplify_try::SimplifyBranchSame,\n         &simplify::SimplifyCfg::new(\"final\"),\n         &simplify::SimplifyLocals,\n     ];"}, {"sha": "41ffa6594418f8091a1b3b3a51d2bea01ec4e8bc", "filename": "src/librustc_mir/transform/simplify_try.rs", "status": "modified", "additions": 313, "deletions": 39, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -11,17 +11,21 @@\n \n use crate::transform::{simplify, MirPass, MirSource};\n use itertools::Itertools as _;\n+use rustc_index::vec::IndexVec;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_target::abi::VariantIdx;\n+use std::iter::{Enumerate, Peekable};\n+use std::slice::Iter;\n \n /// Simplifies arms of form `Variant(x) => Variant(x)` to just a move.\n ///\n /// This is done by transforming basic blocks where the statements match:\n ///\n /// ```rust\n /// _LOCAL_TMP = ((_LOCAL_1 as Variant ).FIELD: TY );\n-/// ((_LOCAL_0 as Variant).FIELD: TY) = move _LOCAL_TMP;\n+/// _TMP_2 = _LOCAL_TMP;\n+/// ((_LOCAL_0 as Variant).FIELD: TY) = move _TMP_2;\n /// discriminant(_LOCAL_0) = VAR_IDX;\n /// ```\n ///\n@@ -32,50 +36,320 @@ use rustc_target::abi::VariantIdx;\n /// ```\n pub struct SimplifyArmIdentity;\n \n+#[derive(Debug)]\n+struct ArmIdentityInfo<'tcx> {\n+    /// Storage location for the variant's field\n+    local_temp_0: Local,\n+    /// Storage location holding the variant being read from\n+    local_1: Local,\n+    /// The variant field being read from\n+    vf_s0: VarField<'tcx>,\n+    /// Index of the statement which loads the variant being read\n+    get_variant_field_stmt: usize,\n+\n+    /// Tracks each assignment to a temporary of the variant's field\n+    field_tmp_assignments: Vec<(Local, Local)>,\n+\n+    /// Storage location holding the variant's field that was read from\n+    local_tmp_s1: Local,\n+    /// Storage location holding the enum that we are writing to\n+    local_0: Local,\n+    /// The variant field being written to\n+    vf_s1: VarField<'tcx>,\n+\n+    /// Storage location that the discriminant is being written to\n+    set_discr_local: Local,\n+    /// The variant being written\n+    set_discr_var_idx: VariantIdx,\n+\n+    /// Index of the statement that should be overwritten as a move\n+    stmt_to_overwrite: usize,\n+    /// SourceInfo for the new move\n+    source_info: SourceInfo,\n+\n+    /// Indices of matching Storage{Live,Dead} statements encountered.\n+    /// (StorageLive index,, StorageDead index, Local)\n+    storage_stmts: Vec<(usize, usize, Local)>,\n+\n+    /// The statements that should be removed (turned into nops)\n+    stmts_to_remove: Vec<usize>,\n+}\n+\n+fn get_arm_identity_info<'a, 'tcx>(stmts: &'a [Statement<'tcx>]) -> Option<ArmIdentityInfo<'tcx>> {\n+    // This can't possibly match unless there are at least 3 statements in the block\n+    // so fail fast on tiny blocks.\n+    if stmts.len() < 3 {\n+        return None;\n+    }\n+\n+    let mut tmp_assigns = Vec::new();\n+    let mut nop_stmts = Vec::new();\n+    let mut storage_stmts = Vec::new();\n+    let mut storage_live_stmts = Vec::new();\n+    let mut storage_dead_stmts = Vec::new();\n+\n+    type StmtIter<'a, 'tcx> = Peekable<Enumerate<Iter<'a, Statement<'tcx>>>>;\n+\n+    fn is_storage_stmt<'tcx>(stmt: &Statement<'tcx>) -> bool {\n+        matches!(stmt.kind, StatementKind::StorageLive(_) | StatementKind::StorageDead(_))\n+    }\n+\n+    /// Eats consecutive Statements which match `test`, performing the specified `action` for each.\n+    /// The iterator `stmt_iter` is not advanced if none were matched.\n+    fn try_eat<'a, 'tcx>(\n+        stmt_iter: &mut StmtIter<'a, 'tcx>,\n+        test: impl Fn(&'a Statement<'tcx>) -> bool,\n+        mut action: impl FnMut(usize, &'a Statement<'tcx>) -> (),\n+    ) {\n+        while stmt_iter.peek().map(|(_, stmt)| test(stmt)).unwrap_or(false) {\n+            let (idx, stmt) = stmt_iter.next().unwrap();\n+\n+            action(idx, stmt);\n+        }\n+    }\n+\n+    /// Eats consecutive `StorageLive` and `StorageDead` Statements.\n+    /// The iterator `stmt_iter` is not advanced if none were found.\n+    fn try_eat_storage_stmts<'a, 'tcx>(\n+        stmt_iter: &mut StmtIter<'a, 'tcx>,\n+        storage_live_stmts: &mut Vec<(usize, Local)>,\n+        storage_dead_stmts: &mut Vec<(usize, Local)>,\n+    ) {\n+        try_eat(stmt_iter, is_storage_stmt, |idx, stmt| {\n+            if let StatementKind::StorageLive(l) = stmt.kind {\n+                storage_live_stmts.push((idx, l));\n+            } else if let StatementKind::StorageDead(l) = stmt.kind {\n+                storage_dead_stmts.push((idx, l));\n+            }\n+        })\n+    }\n+\n+    fn is_tmp_storage_stmt<'tcx>(stmt: &Statement<'tcx>) -> bool {\n+        use rustc_middle::mir::StatementKind::Assign;\n+        if let Assign(box (place, Rvalue::Use(Operand::Copy(p) | Operand::Move(p)))) = &stmt.kind {\n+            place.as_local().is_some() && p.as_local().is_some()\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Eats consecutive `Assign` Statements.\n+    // The iterator `stmt_iter` is not advanced if none were found.\n+    fn try_eat_assign_tmp_stmts<'a, 'tcx>(\n+        stmt_iter: &mut StmtIter<'a, 'tcx>,\n+        tmp_assigns: &mut Vec<(Local, Local)>,\n+        nop_stmts: &mut Vec<usize>,\n+    ) {\n+        try_eat(stmt_iter, is_tmp_storage_stmt, |idx, stmt| {\n+            use rustc_middle::mir::StatementKind::Assign;\n+            if let Assign(box (place, Rvalue::Use(Operand::Copy(p) | Operand::Move(p)))) =\n+                &stmt.kind\n+            {\n+                tmp_assigns.push((place.as_local().unwrap(), p.as_local().unwrap()));\n+                nop_stmts.push(idx);\n+            }\n+        })\n+    }\n+\n+    fn find_storage_live_dead_stmts_for_local<'tcx>(\n+        local: Local,\n+        stmts: &[Statement<'tcx>],\n+    ) -> Option<(usize, usize)> {\n+        trace!(\"looking for {:?}\", local);\n+        let mut storage_live_stmt = None;\n+        let mut storage_dead_stmt = None;\n+        for (idx, stmt) in stmts.iter().enumerate() {\n+            if stmt.kind == StatementKind::StorageLive(local) {\n+                storage_live_stmt = Some(idx);\n+            } else if stmt.kind == StatementKind::StorageDead(local) {\n+                storage_dead_stmt = Some(idx);\n+            }\n+        }\n+\n+        Some((storage_live_stmt?, storage_dead_stmt.unwrap_or(usize::MAX)))\n+    }\n+\n+    // Try to match the expected MIR structure with the basic block we're processing.\n+    // We want to see something that looks like:\n+    // ```\n+    // (StorageLive(_) | StorageDead(_));*\n+    // _LOCAL_INTO = ((_LOCAL_FROM as Variant).FIELD: TY);\n+    // (StorageLive(_) | StorageDead(_));*\n+    // (tmp_n+1 = tmp_n);*\n+    // (StorageLive(_) | StorageDead(_));*\n+    // (tmp_n+1 = tmp_n);*\n+    // ((LOCAL_FROM as Variant).FIELD: TY) = move tmp;\n+    // discriminant(LOCAL_FROM) = VariantIdx;\n+    // (StorageLive(_) | StorageDead(_));*\n+    // ```\n+    let mut stmt_iter = stmts.iter().enumerate().peekable();\n+\n+    try_eat_storage_stmts(&mut stmt_iter, &mut storage_live_stmts, &mut storage_dead_stmts);\n+\n+    let (get_variant_field_stmt, stmt) = stmt_iter.next()?;\n+    let (local_tmp_s0, local_1, vf_s0) = match_get_variant_field(stmt)?;\n+\n+    try_eat_storage_stmts(&mut stmt_iter, &mut storage_live_stmts, &mut storage_dead_stmts);\n+\n+    try_eat_assign_tmp_stmts(&mut stmt_iter, &mut tmp_assigns, &mut nop_stmts);\n+\n+    try_eat_storage_stmts(&mut stmt_iter, &mut storage_live_stmts, &mut storage_dead_stmts);\n+\n+    try_eat_assign_tmp_stmts(&mut stmt_iter, &mut tmp_assigns, &mut nop_stmts);\n+\n+    let (idx, stmt) = stmt_iter.next()?;\n+    let (local_tmp_s1, local_0, vf_s1) = match_set_variant_field(stmt)?;\n+    nop_stmts.push(idx);\n+\n+    let (idx, stmt) = stmt_iter.next()?;\n+    let (set_discr_local, set_discr_var_idx) = match_set_discr(stmt)?;\n+    let discr_stmt_source_info = stmt.source_info;\n+    nop_stmts.push(idx);\n+\n+    try_eat_storage_stmts(&mut stmt_iter, &mut storage_live_stmts, &mut storage_dead_stmts);\n+\n+    for (live_idx, live_local) in storage_live_stmts {\n+        if let Some(i) = storage_dead_stmts.iter().rposition(|(_, l)| *l == live_local) {\n+            let (dead_idx, _) = storage_dead_stmts.swap_remove(i);\n+            storage_stmts.push((live_idx, dead_idx, live_local));\n+\n+            if live_local == local_tmp_s0 {\n+                nop_stmts.push(get_variant_field_stmt);\n+            }\n+        }\n+    }\n+\n+    nop_stmts.sort();\n+\n+    // Use one of the statements we're going to discard between the point\n+    // where the storage location for the variant field becomes live and\n+    // is killed.\n+    let (live_idx, dead_idx) = find_storage_live_dead_stmts_for_local(local_tmp_s0, stmts)?;\n+    let stmt_to_overwrite =\n+        nop_stmts.iter().find(|stmt_idx| live_idx < **stmt_idx && **stmt_idx < dead_idx);\n+\n+    Some(ArmIdentityInfo {\n+        local_temp_0: local_tmp_s0,\n+        local_1,\n+        vf_s0,\n+        get_variant_field_stmt,\n+        field_tmp_assignments: tmp_assigns,\n+        local_tmp_s1,\n+        local_0,\n+        vf_s1,\n+        set_discr_local,\n+        set_discr_var_idx,\n+        stmt_to_overwrite: *stmt_to_overwrite?,\n+        source_info: discr_stmt_source_info,\n+        storage_stmts,\n+        stmts_to_remove: nop_stmts,\n+    })\n+}\n+\n+fn optimization_applies<'tcx>(\n+    opt_info: &ArmIdentityInfo<'tcx>,\n+    local_decls: &IndexVec<Local, LocalDecl<'tcx>>,\n+) -> bool {\n+    trace!(\"testing if optimization applies...\");\n+\n+    // FIXME(wesleywiser): possibly relax this restriction?\n+    if opt_info.local_0 == opt_info.local_1 {\n+        trace!(\"NO: moving into ourselves\");\n+        return false;\n+    } else if opt_info.vf_s0 != opt_info.vf_s1 {\n+        trace!(\"NO: the field-and-variant information do not match\");\n+        return false;\n+    } else if local_decls[opt_info.local_0].ty != local_decls[opt_info.local_1].ty {\n+        // FIXME(Centril,oli-obk): possibly relax to same layout?\n+        trace!(\"NO: source and target locals have different types\");\n+        return false;\n+    } else if (opt_info.local_0, opt_info.vf_s0.var_idx)\n+        != (opt_info.set_discr_local, opt_info.set_discr_var_idx)\n+    {\n+        trace!(\"NO: the discriminants do not match\");\n+        return false;\n+    }\n+\n+    // Verify the assigment chain consists of the form b = a; c = b; d = c; etc...\n+    if opt_info.field_tmp_assignments.len() == 0 {\n+        trace!(\"NO: no assignments found\");\n+    }\n+    let mut last_assigned_to = opt_info.field_tmp_assignments[0].1;\n+    let source_local = last_assigned_to;\n+    for (l, r) in &opt_info.field_tmp_assignments {\n+        if *r != last_assigned_to {\n+            trace!(\"NO: found unexpected assignment {:?} = {:?}\", l, r);\n+            return false;\n+        }\n+\n+        last_assigned_to = *l;\n+    }\n+\n+    if source_local != opt_info.local_temp_0 {\n+        trace!(\n+            \"NO: start of assignment chain does not match enum variant temp: {:?} != {:?}\",\n+            source_local,\n+            opt_info.local_temp_0\n+        );\n+        return false;\n+    } else if last_assigned_to != opt_info.local_tmp_s1 {\n+        trace!(\n+            \"NO: end of assignemnt chain does not match written enum temp: {:?} != {:?}\",\n+            last_assigned_to,\n+            opt_info.local_tmp_s1\n+        );\n+        return false;\n+    }\n+\n+    trace!(\"SUCCESS: optimization applies!\");\n+    return true;\n+}\n+\n impl<'tcx> MirPass<'tcx> for SimplifyArmIdentity {\n-    fn run_pass(&self, _: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, _: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        trace!(\"running SimplifyArmIdentity on {:?}\", source);\n         let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         for bb in basic_blocks {\n-            // Need 3 statements:\n-            let (s0, s1, s2) = match &mut *bb.statements {\n-                [s0, s1, s2] => (s0, s1, s2),\n-                _ => continue,\n-            };\n+            if let Some(opt_info) = get_arm_identity_info(&bb.statements) {\n+                trace!(\"got opt_info = {:#?}\", opt_info);\n+                if !optimization_applies(&opt_info, local_decls) {\n+                    debug!(\"optimization skipped for {:?}\", source);\n+                    continue;\n+                }\n \n-            // Pattern match on the form we want:\n-            let (local_tmp_s0, local_1, vf_s0) = match match_get_variant_field(s0) {\n-                None => continue,\n-                Some(x) => x,\n-            };\n-            let (local_tmp_s1, local_0, vf_s1) = match match_set_variant_field(s1) {\n-                None => continue,\n-                Some(x) => x,\n-            };\n-            if local_tmp_s0 != local_tmp_s1\n-                // Avoid moving into ourselves.\n-                || local_0 == local_1\n-                // The field-and-variant information match up.\n-                || vf_s0 != vf_s1\n-                // Source and target locals have the same type.\n-                // FIXME(Centril | oli-obk): possibly relax to same layout?\n-                || local_decls[local_0].ty != local_decls[local_1].ty\n-                // We're setting the discriminant of `local_0` to this variant.\n-                || Some((local_0, vf_s0.var_idx)) != match_set_discr(s2)\n-            {\n-                continue;\n-            }\n+                // Also remove unused Storage{Live,Dead} statements which correspond\n+                // to temps used previously.\n+                for (live_idx, dead_idx, local) in &opt_info.storage_stmts {\n+                    // The temporary that we've read the variant field into is scoped to this block,\n+                    // so we can remove the assignment.\n+                    if *local == opt_info.local_temp_0 {\n+                        bb.statements[opt_info.get_variant_field_stmt].make_nop();\n+                    }\n \n-            // Right shape; transform!\n-            s0.source_info = s2.source_info;\n-            match &mut s0.kind {\n-                StatementKind::Assign(box (place, rvalue)) => {\n-                    *place = local_0.into();\n-                    *rvalue = Rvalue::Use(Operand::Move(local_1.into()));\n+                    for (left, right) in &opt_info.field_tmp_assignments {\n+                        if local == left || local == right {\n+                            bb.statements[*live_idx].make_nop();\n+                            bb.statements[*dead_idx].make_nop();\n+                        }\n+                    }\n                 }\n-                _ => unreachable!(),\n+\n+                // Right shape; transform\n+                for stmt_idx in opt_info.stmts_to_remove {\n+                    bb.statements[stmt_idx].make_nop();\n+                }\n+\n+                let stmt = &mut bb.statements[opt_info.stmt_to_overwrite];\n+                stmt.source_info = opt_info.source_info;\n+                stmt.kind = StatementKind::Assign(box (\n+                    opt_info.local_0.into(),\n+                    Rvalue::Use(Operand::Move(opt_info.local_1.into())),\n+                ));\n+\n+                bb.statements.retain(|stmt| stmt.kind != StatementKind::Nop);\n+\n+                trace!(\"block is now {:?}\", bb.statements);\n             }\n-            s1.make_nop();\n-            s2.make_nop();\n         }\n     }\n }\n@@ -129,7 +403,7 @@ fn match_set_discr<'tcx>(stmt: &Statement<'tcx>) -> Option<(Local, VariantIdx)>\n     }\n }\n \n-#[derive(PartialEq)]\n+#[derive(PartialEq, Debug)]\n struct VarField<'tcx> {\n     field: Field,\n     field_ty: Ty<'tcx>,"}, {"sha": "af7c88b178d32c83fdba6b182e6b70a272efae0e", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,6 +1,6 @@\n use crate::util::patch::MirPatch;\n use rustc_hir as hir;\n-use rustc_hir::lang_items;\n+use rustc_hir::lang_items::{BoxFreeFnLangItem, DropTraitLangItem};\n use rustc_index::vec::Idx;\n use rustc_middle::mir::*;\n use rustc_middle::traits::Reveal;\n@@ -535,7 +535,7 @@ where\n     fn destructor_call_block(&mut self, (succ, unwind): (BasicBlock, Unwind)) -> BasicBlock {\n         debug!(\"destructor_call_block({:?}, {:?})\", self, succ);\n         let tcx = self.tcx();\n-        let drop_trait = tcx.lang_items().drop_trait().unwrap();\n+        let drop_trait = tcx.require_lang_item(DropTraitLangItem, None);\n         let drop_fn = tcx.associated_items(drop_trait).in_definition_order().next().unwrap();\n         let ty = self.place_ty(self.place);\n         let substs = tcx.mk_substs_trait(ty, &[]);\n@@ -877,8 +877,7 @@ where\n     ) -> BasicBlock {\n         let tcx = self.tcx();\n         let unit_temp = Place::from(self.new_temp(tcx.mk_unit()));\n-        let free_func =\n-            tcx.require_lang_item(lang_items::BoxFreeFnLangItem, Some(self.source_info.span));\n+        let free_func = tcx.require_lang_item(BoxFreeFnLangItem, Some(self.source_info.span));\n         let args = adt.variants[VariantIdx::new(0)]\n             .fields\n             .iter()"}, {"sha": "19b983018c958e362fa32f37c85eb740ad6f4214", "filename": "src/librustc_mir_build/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -223,7 +223,7 @@ impl Scope {\n     }\n }\n \n-/// A trait that determined how [DropTree::lower_to_mir] creates its blocks and\n+/// A trait that determined how [DropTree::build_mir] creates its blocks and\n /// links to any entry nodes.\n trait DropTreeBuilder<'tcx> {\n     /// Create a new block for the tree. This should call either"}, {"sha": "65ff311d18215da6a79e5815dbb2273271877b6c", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -246,7 +246,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             );\n         }\n \n-        adt_defined_here(&mut cx, &mut err, pattern_ty, &witnesses);\n+        adt_defined_here(&cx, &mut err, pattern_ty, &witnesses);\n         err.note(&format!(\"the matched value is of type `{}`\", pattern_ty));\n         err.emit();\n     }"}, {"sha": "28ec2ca13d5af7f83e740ffe671f8b35942134f7", "filename": "src/librustc_mir_build/hair/pattern/const_to_pat.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,4 +1,5 @@\n use rustc_hir as hir;\n+use rustc_hir::lang_items::EqTraitLangItem;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::mir::Field;\n@@ -121,7 +122,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                         )\n                     }\n                     traits::NonStructuralMatchTy::Dynamic => {\n-                        format!(\"trait objects cannot be used in patterns\")\n+                        \"trait objects cannot be used in patterns\".to_string()\n                     }\n                     traits::NonStructuralMatchTy::Param => {\n                         bug!(\"use of constant whose type is a parameter inside a pattern\")\n@@ -140,7 +141,8 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // code at the moment, because types like `for <'a> fn(&'a ())` do\n                 // not *yet* implement `PartialEq`. So for now we leave this here.\n                 let ty_is_partial_eq: bool = {\n-                    let partial_eq_trait_id = self.tcx().lang_items().eq_trait().unwrap();\n+                    let partial_eq_trait_id =\n+                        self.tcx().require_lang_item(EqTraitLangItem, Some(self.span));\n                     let obligation: PredicateObligation<'_> = predicate_for_trait_def(\n                         self.tcx(),\n                         self.param_env,"}, {"sha": "2b7d5e5adb432924f25bea312e0292f573dbf4b3", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 35, "deletions": 124, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -15,6 +15,7 @@ mod tokentrees;\n mod unescape_error_reporting;\n mod unicode_chars;\n \n+use rustc_lexer::unescape::Mode;\n use unescape_error_reporting::{emit_unescape_error, push_escaped_char};\n \n #[derive(Clone, Debug)]\n@@ -31,8 +32,7 @@ pub struct StringReader<'a> {\n     /// Initial position, read-only.\n     start_pos: BytePos,\n     /// The absolute offset within the source_map of the current character.\n-    // FIXME(#64197): `pub` is needed by tests for now.\n-    pub pos: BytePos,\n+    pos: BytePos,\n     /// Stop reading src at this index.\n     end_src_index: usize,\n     /// Source text to tokenize.\n@@ -326,38 +326,27 @@ impl<'a> StringReader<'a> {\n         suffix_start: BytePos,\n         kind: rustc_lexer::LiteralKind,\n     ) -> (token::LitKind, Symbol) {\n-        match kind {\n+        // prefix means `\"` or `br\"` or `r###\"`, ...\n+        let (lit_kind, mode, prefix_len, postfix_len) = match kind {\n             rustc_lexer::LiteralKind::Char { terminated } => {\n                 if !terminated {\n                     self.fatal_span_(start, suffix_start, \"unterminated character literal\").raise()\n                 }\n-                let content_start = start + BytePos(1);\n-                let content_end = suffix_start - BytePos(1);\n-                self.validate_char_escape(content_start, content_end);\n-                let id = self.symbol_from_to(content_start, content_end);\n-                (token::Char, id)\n+                (token::Char, Mode::Char, 1, 1) // ' '\n             }\n             rustc_lexer::LiteralKind::Byte { terminated } => {\n                 if !terminated {\n                     self.fatal_span_(start + BytePos(1), suffix_start, \"unterminated byte constant\")\n                         .raise()\n                 }\n-                let content_start = start + BytePos(2);\n-                let content_end = suffix_start - BytePos(1);\n-                self.validate_byte_escape(content_start, content_end);\n-                let id = self.symbol_from_to(content_start, content_end);\n-                (token::Byte, id)\n+                (token::Byte, Mode::Byte, 2, 1) // b' '\n             }\n             rustc_lexer::LiteralKind::Str { terminated } => {\n                 if !terminated {\n                     self.fatal_span_(start, suffix_start, \"unterminated double quote string\")\n                         .raise()\n                 }\n-                let content_start = start + BytePos(1);\n-                let content_end = suffix_start - BytePos(1);\n-                self.validate_str_escape(content_start, content_end);\n-                let id = self.symbol_from_to(content_start, content_end);\n-                (token::Str, id)\n+                (token::Str, Mode::Str, 1, 1) // \" \"\n             }\n             rustc_lexer::LiteralKind::ByteStr { terminated } => {\n                 if !terminated {\n@@ -368,42 +357,28 @@ impl<'a> StringReader<'a> {\n                     )\n                     .raise()\n                 }\n-                let content_start = start + BytePos(2);\n-                let content_end = suffix_start - BytePos(1);\n-                self.validate_byte_str_escape(content_start, content_end);\n-                let id = self.symbol_from_to(content_start, content_end);\n-                (token::ByteStr, id)\n+                (token::ByteStr, Mode::ByteStr, 2, 1) // b\" \"\n             }\n             rustc_lexer::LiteralKind::RawStr(unvalidated_raw_str) => {\n                 let valid_raw_str = self.validate_and_report_errors(start, unvalidated_raw_str);\n                 let n_hashes = valid_raw_str.num_hashes();\n                 let n = u32::from(n_hashes);\n-\n-                let content_start = start + BytePos(2 + n);\n-                let content_end = suffix_start - BytePos(1 + n);\n-                self.validate_raw_str_escape(content_start, content_end);\n-                let id = self.symbol_from_to(content_start, content_end);\n-                (token::StrRaw(n_hashes), id)\n+                (token::StrRaw(n_hashes), Mode::RawStr, 2 + n, 1 + n) // r##\" \"##\n             }\n             rustc_lexer::LiteralKind::RawByteStr(unvalidated_raw_str) => {\n                 let validated_raw_str = self.validate_and_report_errors(start, unvalidated_raw_str);\n                 let n_hashes = validated_raw_str.num_hashes();\n                 let n = u32::from(n_hashes);\n-\n-                let content_start = start + BytePos(3 + n);\n-                let content_end = suffix_start - BytePos(1 + n);\n-                self.validate_raw_byte_str_escape(content_start, content_end);\n-                let id = self.symbol_from_to(content_start, content_end);\n-                (token::ByteStrRaw(n_hashes), id)\n+                (token::ByteStrRaw(n_hashes), Mode::RawByteStr, 3 + n, 1 + n) // br##\" \"##\n             }\n             rustc_lexer::LiteralKind::Int { base, empty_int } => {\n-                if empty_int {\n+                return if empty_int {\n                     self.err_span_(start, suffix_start, \"no valid digits found for number\");\n                     (token::Integer, sym::integer(0))\n                 } else {\n                     self.validate_int_literal(base, start, suffix_start);\n                     (token::Integer, self.symbol_from_to(start, suffix_start))\n-                }\n+                };\n             }\n             rustc_lexer::LiteralKind::Float { base, empty_exponent } => {\n                 if empty_exponent {\n@@ -431,9 +406,18 @@ impl<'a> StringReader<'a> {\n                 }\n \n                 let id = self.symbol_from_to(start, suffix_start);\n-                (token::Float, id)\n+                return (token::Float, id);\n             }\n-        }\n+        };\n+        let content_start = start + BytePos(prefix_len);\n+        let content_end = suffix_start - BytePos(postfix_len);\n+        let id = self.symbol_from_to(content_start, content_end);\n+        self.validate_literal_escape(mode, content_start, content_end);\n+        return (lit_kind, id);\n+    }\n+\n+    pub fn pos(&self) -> BytePos {\n+        self.pos\n     }\n \n     #[inline]\n@@ -555,96 +539,23 @@ impl<'a> StringReader<'a> {\n         .raise();\n     }\n \n-    fn validate_char_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        let lit = self.str_from_to(content_start, content_end);\n-        if let Err((off, err)) = unescape::unescape_char(lit) {\n-            emit_unescape_error(\n-                &self.sess.span_diagnostic,\n-                lit,\n-                self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                unescape::Mode::Char,\n-                0..off,\n-                err,\n-            )\n-        }\n-    }\n-\n-    fn validate_byte_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        let lit = self.str_from_to(content_start, content_end);\n-        if let Err((off, err)) = unescape::unescape_byte(lit) {\n-            emit_unescape_error(\n-                &self.sess.span_diagnostic,\n-                lit,\n-                self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                unescape::Mode::Byte,\n-                0..off,\n-                err,\n-            )\n-        }\n-    }\n-\n-    fn validate_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        let lit = self.str_from_to(content_start, content_end);\n-        unescape::unescape_str(lit, &mut |range, c| {\n-            if let Err(err) = c {\n+    fn validate_literal_escape(&self, mode: Mode, content_start: BytePos, content_end: BytePos) {\n+        let lit_content = self.str_from_to(content_start, content_end);\n+        unescape::unescape_literal(lit_content, mode, &mut |range, result| {\n+            // Here we only check for errors. The actual unescaping is done later.\n+            if let Err(err) = result {\n+                let span_with_quotes =\n+                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1));\n                 emit_unescape_error(\n                     &self.sess.span_diagnostic,\n-                    lit,\n-                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                    unescape::Mode::Str,\n+                    lit_content,\n+                    span_with_quotes,\n+                    mode,\n                     range,\n                     err,\n-                )\n-            }\n-        })\n-    }\n-\n-    fn validate_raw_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        let lit = self.str_from_to(content_start, content_end);\n-        unescape::unescape_raw_str(lit, &mut |range, c| {\n-            if let Err(err) = c {\n-                emit_unescape_error(\n-                    &self.sess.span_diagnostic,\n-                    lit,\n-                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                    unescape::Mode::Str,\n-                    range,\n-                    err,\n-                )\n-            }\n-        })\n-    }\n-\n-    fn validate_raw_byte_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        let lit = self.str_from_to(content_start, content_end);\n-        unescape::unescape_raw_byte_str(lit, &mut |range, c| {\n-            if let Err(err) = c {\n-                emit_unescape_error(\n-                    &self.sess.span_diagnostic,\n-                    lit,\n-                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                    unescape::Mode::ByteStr,\n-                    range,\n-                    err,\n-                )\n-            }\n-        })\n-    }\n-\n-    fn validate_byte_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        let lit = self.str_from_to(content_start, content_end);\n-        unescape::unescape_byte_str(lit, &mut |range, c| {\n-            if let Err(err) = c {\n-                emit_unescape_error(\n-                    &self.sess.span_diagnostic,\n-                    lit,\n-                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                    unescape::Mode::ByteStr,\n-                    range,\n-                    err,\n-                )\n+                );\n             }\n-        })\n+        });\n     }\n \n     fn validate_int_literal(&self, base: Base, content_start: BytePos, content_end: BytePos) {"}, {"sha": "93c7faf22a73fe993833ff477faf3136c43733d5", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -927,7 +927,7 @@ impl<'a> Parser<'a> {\n             return Ok(());\n         }\n         let sm = self.sess.source_map();\n-        let msg = format!(\"expected `;`, found `{}`\", super::token_descr(&self.token));\n+        let msg = format!(\"expected `;`, found {}\", super::token_descr(&self.token));\n         let appl = Applicability::MachineApplicable;\n         if self.token.span == DUMMY_SP || self.prev_token.span == DUMMY_SP {\n             // Likely inside a macro, can't provide meaningful suggestions."}, {"sha": "6e7d116ce1d7e0f408e98f87d55e7c4d307af458", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -931,7 +931,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         if blk.targeted_by_break {\n             self.break_ln.insert(blk.hir_id, succ);\n         }\n-        let succ = self.propagate_through_opt_expr(blk.expr.as_ref().map(|e| &**e), succ);\n+        let succ = self.propagate_through_opt_expr(blk.expr.as_deref(), succ);\n         blk.stmts.iter().rev().fold(succ, |succ, stmt| self.propagate_through_stmt(stmt, succ))\n     }\n \n@@ -952,7 +952,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 // initialization, which is mildly more complex than checking\n                 // once at the func header but otherwise equivalent.\n \n-                let succ = self.propagate_through_opt_expr(local.init.as_ref().map(|e| &**e), succ);\n+                let succ = self.propagate_through_opt_expr(local.init.as_deref(), succ);\n                 self.define_bindings_in_pat(&local.pat, succ)\n             }\n             hir::StmtKind::Item(..) => succ,"}, {"sha": "a6fa677cbc0af1b15da8edadb250750865638a74", "filename": "src/librustc_passes/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_passes%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_passes%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fregion.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -797,7 +797,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n         resolve_expr(self, ex);\n     }\n     fn visit_local(&mut self, l: &'tcx Local<'tcx>) {\n-        resolve_local(self, Some(&l.pat), l.init.as_ref().map(|e| &**e));\n+        resolve_local(self, Some(&l.pat), l.init.as_deref());\n     }\n }\n "}, {"sha": "b474b23ac4f5ce1a5f1bb5d0c6b49d99a3aeaa0b", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -160,7 +160,7 @@ where\n                     }\n                 }\n             }\n-            ty::Projection(proj) | ty::UnnormalizedProjection(proj) => {\n+            ty::Projection(proj) => {\n                 if self.def_id_visitor.skip_assoc_tys() {\n                     // Visitors searching for minimal visibility/reachability want to\n                     // conservatively approximate associated types like `<Type as Trait>::Alias`"}, {"sha": "d8875f8ac64a202353a04eeba308eea315a97df7", "filename": "src/librustc_query_system/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -80,7 +80,7 @@ impl<K: DepKind> DepNode<K> {\n             }\n         }\n \n-        return dep_node;\n+        dep_node\n     }\n }\n "}, {"sha": "04a45090b722675d179f32c4edb4d5282449fc26", "filename": "src/librustc_query_system/dep_graph/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -860,8 +860,8 @@ impl<K: DepKind> DepGraph<K> {\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct WorkProduct {\n     pub cgu_name: String,\n-    /// Saved files associated with this CGU.\n-    pub saved_files: Vec<String>,\n+    /// Saved file associated with this CGU.\n+    pub saved_file: Option<String>,\n }\n \n #[derive(Clone)]"}, {"sha": "e8d02692f37ba48f960147cfef274bb69e85495f", "filename": "src/librustc_query_system/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -77,9 +77,9 @@ pub trait DepKind: Copy + fmt::Debug + Eq + Ord + Hash {\n         OP: FnOnce() -> R;\n \n     /// Access dependencies from current implicit context.\n-    fn read_deps<OP>(op: OP) -> ()\n+    fn read_deps<OP>(op: OP)\n     where\n-        OP: for<'a> FnOnce(Option<&'a Lock<TaskDeps<Self>>>) -> ();\n+        OP: for<'a> FnOnce(Option<&'a Lock<TaskDeps<Self>>>);\n \n     fn can_reconstruct_query_key(&self) -> bool;\n }"}, {"sha": "8e350d3ba267e9ec187acb6f6c7db234f945eeaa", "filename": "src/librustc_query_system/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_query_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_query_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Flib.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -4,7 +4,7 @@\n #![feature(const_panic)]\n #![feature(core_intrinsics)]\n #![feature(hash_raw_entry)]\n-#![feature(specialization)]\n+#![feature(specialization)] // FIXME: min_specialization rejects `default const`\n #![feature(stmt_expr_attributes)]\n #![feature(vec_remove_item)]\n "}, {"sha": "3dd715f9e3df6773fb8a4bbed31ac92059901729", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -21,7 +21,7 @@ use rustc_ast::walk_list;\n use rustc_ast_pretty::pprust::{bounds_to_string, generic_params_to_string, ty_to_string};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::{DefKind as HirDefKind, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::span_bug;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::config::Input;\n@@ -104,12 +104,10 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         self.dumper.analysis()\n     }\n \n-    fn nest_tables<F>(&mut self, item_id: NodeId, f: F)\n+    fn nest_tables<F>(&mut self, item_def_id: LocalDefId, f: F)\n     where\n         F: FnOnce(&mut Self),\n     {\n-        let item_def_id = self.tcx.hir().local_def_id_from_node_id(item_id);\n-\n         let tables = if self.tcx.has_typeck_tables(item_def_id) {\n             self.tcx.typeck_tables_of(item_def_id)\n         } else {\n@@ -272,8 +270,9 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     ) {\n         debug!(\"process_method: {}:{}\", id, ident);\n \n-        let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n-        self.nest_tables(id, |v| {\n+        let map = &self.tcx.hir();\n+        let hir_id = map.node_id_to_hir_id(id);\n+        self.nest_tables(map.local_def_id(hir_id), |v| {\n             if let Some(mut method_data) = v.save_ctxt.get_method_data(id, ident, span) {\n                 v.process_formals(&sig.decl.inputs, &method_data.qualname);\n                 v.process_generic_params(&generics, &method_data.qualname, id);\n@@ -296,7 +295,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 // start walking from the newly-created definition.\n                 match sig.header.asyncness {\n                     ast::Async::Yes { return_impl_trait_id, .. } => {\n-                        v.nest_tables(return_impl_trait_id, |v| v.visit_ty(ret_ty))\n+                        let hir_id = map.node_id_to_hir_id(return_impl_trait_id);\n+                        v.nest_tables(map.local_def_id(hir_id), |v| v.visit_ty(ret_ty))\n                     }\n                     _ => v.visit_ty(ret_ty),\n                 }\n@@ -364,8 +364,9 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         ty_params: &'l ast::Generics,\n         body: Option<&'l ast::Block>,\n     ) {\n-        let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n-        self.nest_tables(item.id, |v| {\n+        let map = &self.tcx.hir();\n+        let hir_id = map.node_id_to_hir_id(item.id);\n+        self.nest_tables(map.local_def_id(hir_id), |v| {\n             if let Some(fn_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(fn_data, DefData, item.span);\n                 v.process_formals(&decl.inputs, &fn_data.qualname);\n@@ -389,7 +390,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     // start walking from the newly-created definition.\n                     match header.asyncness {\n                         ast::Async::Yes { return_impl_trait_id, .. } => {\n-                            v.nest_tables(return_impl_trait_id, |v| v.visit_ty(ret_ty))\n+                            let hir_id = map.node_id_to_hir_id(return_impl_trait_id);\n+                            v.nest_tables(map.local_def_id(hir_id), |v| v.visit_ty(ret_ty))\n                         }\n                         _ => v.visit_ty(ret_ty),\n                     }\n@@ -407,7 +409,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         expr: Option<&'l ast::Expr>,\n     ) {\n         let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n-        self.nest_tables(item.id, |v| {\n+        self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n                 v.dumper.dump_def(&access_from!(v.save_ctxt, item, hir_id), var_data);\n@@ -427,15 +429,13 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         vis: ast::Visibility,\n         attrs: &'l [Attribute],\n     ) {\n-        let qualname = format!(\n-            \"::{}\",\n-            self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(id).to_def_id())\n-        );\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n+        let qualname =\n+            format!(\"::{}\", self.tcx.def_path_str(self.tcx.hir().local_def_id(hir_id).to_def_id()));\n \n         if !self.span.filter_generated(ident.span) {\n             let sig = sig::assoc_const_signature(id, ident.name, typ, expr, &self.save_ctxt);\n             let span = self.span_from_span(ident.span);\n-            let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n \n             self.dumper.dump_def(\n                 &access_from_vis!(self.save_ctxt, vis, hir_id),\n@@ -457,7 +457,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n \n         // walk type and init value\n-        self.nest_tables(id, |v| {\n+        self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n             v.visit_ty(typ);\n             if let Some(expr) = expr {\n                 v.visit_expr(expr);\n@@ -474,10 +474,9 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     ) {\n         debug!(\"process_struct {:?} {:?}\", item, item.span);\n         let name = item.ident.to_string();\n-        let qualname = format!(\n-            \"::{}\",\n-            self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id).to_def_id())\n-        );\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n+        let qualname =\n+            format!(\"::{}\", self.tcx.def_path_str(self.tcx.hir().local_def_id(hir_id).to_def_id()));\n \n         let kind = match item.kind {\n             ast::ItemKind::Struct(_, _) => DefKind::Struct,\n@@ -509,7 +508,6 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n \n         if !self.span.filter_generated(item.ident.span) {\n             let span = self.span_from_span(item.ident.span);\n-            let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n             self.dumper.dump_def(\n                 &access_from!(self.save_ctxt, item, hir_id),\n                 Def {\n@@ -529,7 +527,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             );\n         }\n \n-        self.nest_tables(item.id, |v| {\n+        self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n             for field in def.fields() {\n                 v.process_struct_field_def(field, item.id);\n                 v.visit_ty(&field.ty);\n@@ -669,14 +667,15 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n \n         let map = &self.tcx.hir();\n-        self.nest_tables(item.id, |v| {\n+        let hir_id = map.node_id_to_hir_id(item.id);\n+        self.nest_tables(map.local_def_id(hir_id), |v| {\n             v.visit_ty(&typ);\n             if let &Some(ref trait_ref) = trait_ref {\n                 v.process_path(trait_ref.ref_id, &trait_ref.path);\n             }\n             v.process_generic_params(generics, \"\", item.id);\n             for impl_item in impl_items {\n-                v.process_impl_item(impl_item, map.local_def_id_from_node_id(item.id).to_def_id());\n+                v.process_impl_item(impl_item, map.local_def_id(hir_id).to_def_id());\n             }\n         });\n     }\n@@ -1411,7 +1410,10 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n             }\n             ast::TyKind::Array(ref element, ref length) => {\n                 self.visit_ty(element);\n-                self.nest_tables(length.id, |v| v.visit_expr(&length.value));\n+                let hir_id = self.tcx.hir().node_id_to_hir_id(length.id);\n+                self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n+                    v.visit_expr(&length.value)\n+                });\n             }\n             ast::TyKind::ImplTrait(id, ref bounds) => {\n                 // FIXME: As of writing, the opaque type lowering introduces\n@@ -1423,7 +1425,13 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 // bounds...\n                 // This will panic if called on return type `impl Trait`, which\n                 // we guard against in `process_fn`.\n-                self.nest_tables(id, |v| v.process_bounds(bounds));\n+                // FIXME(#71104) Should really be using just `node_id_to_hir_id` but\n+                // some `NodeId` do not seem to have a corresponding HirId.\n+                if let Some(hir_id) = self.tcx.hir().opt_node_id_to_hir_id(id) {\n+                    self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n+                        v.process_bounds(bounds)\n+                    });\n+                }\n             }\n             _ => visit::walk_ty(self, t),\n         }\n@@ -1471,7 +1479,8 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 }\n \n                 // walk the body\n-                self.nest_tables(ex.id, |v| {\n+                let hir_id = self.tcx.hir().node_id_to_hir_id(ex.id);\n+                self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n                     v.process_formals(&decl.inputs, &id);\n                     v.visit_expr(body)\n                 });\n@@ -1488,7 +1497,10 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n             }\n             ast::ExprKind::Repeat(ref element, ref count) => {\n                 self.visit_expr(element);\n-                self.nest_tables(count.id, |v| v.visit_expr(&count.value));\n+                let hir_id = self.tcx.hir().node_id_to_hir_id(count.id);\n+                self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n+                    v.visit_expr(&count.value)\n+                });\n             }\n             // In particular, we take this branch for call and path expressions,\n             // where we'll index the idents involved just by continuing to walk."}, {"sha": "e2c82a397c7384c150db62c9fa0f5d55de309acf", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -271,6 +271,7 @@ macro_rules! options {\n             \"one of supported relocation models (`rustc --print relocation-models`)\";\n         pub const parse_tls_model: &str =\n             \"one of supported TLS models (`rustc --print tls-models`)\";\n+        pub const parse_target_feature: &str = parse_string;\n     }\n \n     #[allow(dead_code)]\n@@ -647,6 +648,19 @@ macro_rules! options {\n             }\n             true\n         }\n+\n+        fn parse_target_feature(slot: &mut String, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => {\n+                    if !slot.is_empty() {\n+                        slot.push_str(\",\");\n+                    }\n+                    slot.push_str(s);\n+                    true\n+                }\n+                None => false,\n+            }\n+        }\n     }\n ) }\n \n@@ -742,7 +756,7 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"use soft float ABI (*eabihf targets only) (default: no)\"),\n     target_cpu: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"select target processor (`rustc --print target-cpus` for details)\"),\n-    target_feature: String = (String::new(), parse_string, [TRACKED],\n+    target_feature: String = (String::new(), parse_target_feature, [TRACKED],\n         \"target specific attributes. (`rustc --print target-features` for details). \\\n         This feature is unsafe.\"),\n "}, {"sha": "cb5bd37442a7ed9fd6ce69f4ade58319381ea3a6", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -808,7 +808,7 @@ impl Session {\n                 let mut fuel = self.optimization_fuel.lock();\n                 ret = fuel.remaining != 0;\n                 if fuel.remaining == 0 && !fuel.out_of_fuel {\n-                    eprintln!(\"optimization-fuel-exhausted: {}\", msg());\n+                    self.warn(&format!(\"optimization-fuel-exhausted: {}\", msg()));\n                     fuel.out_of_fuel = true;\n                 } else if fuel.remaining > 0 {\n                     fuel.remaining -= 1;\n@@ -936,6 +936,16 @@ impl Session {\n         // then try to skip it where possible.\n         dbg_opts.plt.unwrap_or(needs_plt || !full_relro)\n     }\n+\n+    /// Checks if LLVM lifetime markers should be emitted.\n+    pub fn emit_lifetime_markers(&self) -> bool {\n+        match self.opts.debugging_opts.sanitizer {\n+            // AddressSanitizer uses lifetimes to detect use after scope bugs.\n+            // MemorySanitizer uses lifetimes to detect use of uninitialized stack variables.\n+            Some(Sanitizer::Address | Sanitizer::Memory) => true,\n+            _ => self.opts.optimize != config::OptLevel::No,\n+        }\n+    }\n }\n \n pub fn build_session("}, {"sha": "58cdb87158afe4a940907270a15600855782bc12", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -12,7 +12,7 @@\n #![feature(negative_impls)]\n #![feature(nll)]\n #![feature(optin_builtin_traits)]\n-#![feature(specialization)]\n+#![feature(min_specialization)]\n \n // FIXME(#56935): Work around ICEs during cross-compilation.\n #[allow(unused)]"}, {"sha": "51f5541766305d470856f4e2c7f1ae1aa5076736", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -910,14 +910,23 @@ impl SourceMap {\n \n     pub fn generate_fn_name_span(&self, span: Span) -> Option<Span> {\n         let prev_span = self.span_extend_to_prev_str(span, \"fn\", true);\n-        self.span_to_snippet(prev_span)\n-            .map(|snippet| {\n-                let len = snippet\n-                    .find(|c: char| !c.is_alphanumeric() && c != '_')\n-                    .expect(\"no label after fn\");\n-                prev_span.with_hi(BytePos(prev_span.lo().0 + len as u32))\n-            })\n-            .ok()\n+        if let Ok(snippet) = self.span_to_snippet(prev_span) {\n+            debug!(\n+                \"generate_fn_name_span: span={:?}, prev_span={:?}, snippet={:?}\",\n+                span, prev_span, snippet\n+            );\n+\n+            if snippet.is_empty() {\n+                return None;\n+            };\n+\n+            let len = snippet\n+                .find(|c: char| !c.is_alphanumeric() && c != '_')\n+                .expect(\"no label after fn\");\n+            Some(prev_span.with_hi(BytePos(prev_span.lo().0 + len as u32)))\n+        } else {\n+            None\n+        }\n     }\n \n     /// Takes the span of a type parameter in a function signature and try to generate a span for"}, {"sha": "3038b0c6bd7eb26062d824e718fc07b16381f881", "filename": "src/librustc_symbol_mangling/legacy.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_symbol_mangling%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_symbol_mangling%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_symbol_mangling%2Flegacy.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -216,7 +216,6 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n             ty::FnDef(def_id, substs)\n             | ty::Opaque(def_id, substs)\n             | ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs })\n-            | ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs })\n             | ty::Closure(def_id, substs)\n             | ty::Generator(def_id, substs, _) => self.print_def_path(def_id, substs),\n             _ => self.pretty_print_type(ty),\n@@ -264,7 +263,6 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n             ty::FnDef(..)\n             | ty::Opaque(..)\n             | ty::Projection(_)\n-            | ty::UnnormalizedProjection(_)\n             | ty::Closure(..)\n             | ty::Generator(..)\n                 if trait_ref.is_none() =>"}, {"sha": "3b439e09a9d150f2fc18b3554fad069f59f167aa", "filename": "src/librustc_symbol_mangling/v0.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_symbol_mangling%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_symbol_mangling%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_symbol_mangling%2Fv0.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -413,7 +413,6 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n             | ty::FnDef(def_id, substs)\n             | ty::Opaque(def_id, substs)\n             | ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs })\n-            | ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs })\n             | ty::Closure(def_id, substs)\n             | ty::Generator(def_id, substs, _) => {\n                 self = self.print_def_path(def_id, substs)?;"}, {"sha": "0c74454d0c5fe66dafc189266e2c637350613a56", "filename": "src/librustc_target/spec/mipsel_sony_psp.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_target%2Fspec%2Fmipsel_sony_psp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_target%2Fspec%2Fmipsel_sony_psp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmipsel_sony_psp.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,43 @@\n+use crate::spec::{LinkArgs, LinkerFlavor, LldFlavor, RelocModel};\n+use crate::spec::{Target, TargetOptions, TargetResult};\n+\n+// The PSP has custom linker requirements.\n+const LINKER_SCRIPT: &str = include_str!(\"./mipsel_sony_psp_linker_script.ld\");\n+\n+pub fn target() -> TargetResult {\n+    let mut pre_link_args = LinkArgs::new();\n+    pre_link_args.insert(\n+        LinkerFlavor::Lld(LldFlavor::Ld),\n+        vec![\"--eh-frame-hdr\".to_string(), \"--emit-relocs\".to_string()],\n+    );\n+\n+    Ok(Target {\n+        llvm_target: \"mipsel-sony-psp\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n+        arch: \"mips\".to_string(),\n+        target_os: \"psp\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"sony\".to_string(),\n+        linker_flavor: LinkerFlavor::Lld(LldFlavor::Ld),\n+\n+        options: TargetOptions {\n+            cpu: \"mips2\".to_string(),\n+            executables: true,\n+            linker: Some(\"rust-lld\".to_owned()),\n+            linker_is_gnu: true,\n+            relocation_model: RelocModel::Static,\n+\n+            // PSP FPU only supports single precision floats.\n+            features: \"+single-float\".to_string(),\n+\n+            // PSP does not support trap-on-condition instructions.\n+            llvm_args: vec![\"-mno-check-zero-division\".to_string()],\n+            pre_link_args,\n+            link_script: Some(LINKER_SCRIPT.to_string()),\n+            ..Default::default()\n+        },\n+    })\n+}"}, {"sha": "1bd436d6f94cc08614c7a2e28a1db6ec211c1e93", "filename": "src/librustc_target/spec/mipsel_sony_psp_linker_script.ld", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_target%2Fspec%2Fmipsel_sony_psp_linker_script.ld", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_target%2Fspec%2Fmipsel_sony_psp_linker_script.ld", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmipsel_sony_psp_linker_script.ld?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,34 @@\n+ENTRY(module_start)\n+SECTIONS\n+{\n+  /* PRX format requires text to begin at 0 */\n+  .text 0 : { *(.text .text.*) }\n+\n+  /* Sort stubs for convenient ordering */\n+  .sceStub.text : { *(.sceStub.text) *(SORT(.sceStub.text.*)) }\n+\n+  /* Keep these sections around, even though they may appear unused to the linker */\n+  .lib.ent.top :  { KEEP(*(.lib.ent.top)) }\n+  .lib.ent :      { KEEP(*(.lib.ent)) }\n+  .lib.ent.btm :  { KEEP(*(.lib.ent.btm)) }\n+  .lib.stub.top : { KEEP(*(.lib.stub.top)) }\n+  .lib.stub :     { KEEP(*(.lib.stub)) }\n+  .lib.stub.btm : { KEEP(*(.lib.stub.btm)) }\n+  .eh_frame_hdr : { KEEP(*(.eh_frame_hdr)) }\n+\n+  /* Add symbols for LLVM's libunwind */\n+  __eh_frame_hdr_start = SIZEOF(.eh_frame_hdr) > 0 ? ADDR(.eh_frame_hdr) : 0;\n+  __eh_frame_hdr_end = SIZEOF(.eh_frame_hdr) > 0 ? . : 0;\n+  .eh_frame :\n+  {\n+    __eh_frame_start = .;\n+    KEEP(*(.eh_frame))\n+    __eh_frame_end = .;\n+  }\n+\n+  /* These are explicitly listed to avoid being merged into .rodata */\n+  .rodata.sceResident : { *(.rodata.sceResident) }\n+  .rodata.sceModuleInfo : { *(.rodata.sceModuleInfo) }\n+  /* Sort NIDs for convenient ordering */\n+  .rodata.sceNid : { *(.rodata.sceNid) *(SORT(.rodata.sceNid.*)) }\n+}"}, {"sha": "c7b2023ddca04153feaae7c37a5c74131d043975", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -582,6 +582,8 @@ supported_targets! {\n     (\"powerpc-wrs-vxworks\", powerpc_wrs_vxworks),\n     (\"powerpc-wrs-vxworks-spe\", powerpc_wrs_vxworks_spe),\n     (\"powerpc64-wrs-vxworks\", powerpc64_wrs_vxworks),\n+\n+    (\"mipsel-sony-psp\", mipsel_sony_psp),\n }\n \n /// Everything `rustc` knows about how to compile for a specific target.\n@@ -666,6 +668,10 @@ pub struct TargetOptions {\n     /// Linker arguments that are unconditionally passed *after* any\n     /// user-defined libraries.\n     pub post_link_args: LinkArgs,\n+    /// Optional link script applied to `dylib` and `executable` crate types.\n+    /// This is a string containing the script, not a path. Can only be applied\n+    /// to linkers where `linker_is_gnu` is true.\n+    pub link_script: Option<String>,\n \n     /// Environment variables to be set for the linker invocation.\n     pub link_env: Vec<(String, String)>,\n@@ -899,6 +905,7 @@ impl Default for TargetOptions {\n             pre_link_args: LinkArgs::new(),\n             pre_link_args_crt: LinkArgs::new(),\n             post_link_args: LinkArgs::new(),\n+            link_script: None,\n             asm_args: Vec::new(),\n             cpu: \"generic\".to_string(),\n             features: String::new(),\n@@ -1249,6 +1256,7 @@ impl Target {\n         key!(post_link_objects, list);\n         key!(post_link_objects_crt, list);\n         key!(post_link_args, link_args);\n+        key!(link_script, optional);\n         key!(link_env, env);\n         key!(link_env_remove, list);\n         key!(asm_args, list);\n@@ -1479,6 +1487,7 @@ impl ToJson for Target {\n         target_option_val!(post_link_objects);\n         target_option_val!(post_link_objects_crt);\n         target_option_val!(link_args - post_link_args);\n+        target_option_val!(link_script);\n         target_option_val!(env - link_env);\n         target_option_val!(link_env_remove);\n         target_option_val!(asm_args);"}, {"sha": "be0512dcac95b217d3f705f6ac09eddaed7c66f5", "filename": "src/librustc_trait_selection/traits/chalk_fulfill.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -39,7 +39,7 @@ fn environment<'tcx>(\n     let ty::InstantiatedPredicates { predicates, .. } =\n         tcx.predicates_of(def_id).instantiate_identity(tcx);\n \n-    let clauses = predicates.into_iter().map(|pred| ChalkEnvironmentClause::Predicate(pred));\n+    let clauses = predicates.into_iter().map(ChalkEnvironmentClause::Predicate);\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let node = tcx.hir().get(hir_id);\n@@ -224,7 +224,7 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n                                 ),\n \n                                 Err(_err) => errors.push(FulfillmentError {\n-                                    obligation: obligation,\n+                                    obligation,\n                                     code: FulfillmentErrorCode::CodeSelectionError(\n                                         SelectionError::Unimplemented,\n                                     ),\n@@ -238,7 +238,7 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n                     }\n \n                     Err(NoSolution) => errors.push(FulfillmentError {\n-                        obligation: obligation,\n+                        obligation,\n                         code: FulfillmentErrorCode::CodeSelectionError(\n                             SelectionError::Unimplemented,\n                         ),\n@@ -257,6 +257,6 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     }\n \n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n-        self.obligations.iter().map(|obligation| obligation.clone()).collect()\n+        self.obligations.iter().cloned().collect()\n     }\n }"}, {"sha": "85c2f9246afcc6e92b8d2d07136414fb9511c2b0", "filename": "src/librustc_trait_selection/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -567,9 +567,8 @@ fn ty_is_non_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> Option<Ty<'_>>\n \n         ty::Error => None,\n \n-        ty::UnnormalizedProjection(..)\n-        | ty::Closure(..)\n-        | ty::Generator(..)\n-        | ty::GeneratorWitness(..) => bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty),\n+        ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(..) => {\n+            bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty)\n+        }\n     }\n }"}, {"sha": "0d53df3bf4b466ecba0500bc69560e8a7e498df8", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -283,6 +283,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             .unwrap_or(false);\n                         let is_from = format!(\"{}\", trait_ref.print_only_trait_path())\n                             .starts_with(\"std::convert::From<\");\n+                        let is_unsize =\n+                            { Some(trait_ref.def_id()) == self.tcx.lang_items().unsize_trait() };\n                         let (message, note) = if is_try && is_from {\n                             (\n                                 Some(format!(\n@@ -400,11 +402,23 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n                         self.suggest_semicolon_removal(&obligation, &mut err, span, &trait_ref);\n                         self.note_version_mismatch(&mut err, &trait_ref);\n+                        self.suggest_await_before_try(&mut err, &obligation, &trait_ref, span);\n                         if self.suggest_impl_trait(&mut err, span, &obligation, &trait_ref) {\n                             err.emit();\n                             return;\n                         }\n \n+                        if is_unsize {\n+                            // If the obligation failed due to a missing implementation of the\n+                            // `Unsize` trait, give a pointer to why that might be the case\n+                            err.note(\n+                                \"all implementations of `Unsize` are provided \\\n+                                automatically by the compiler, see \\\n+                                <https://doc.rust-lang.org/stable/std/marker/trait.Unsize.html> \\\n+                                for more information\",\n+                            );\n+                        }\n+\n                         // Try to report a help message\n                         if !trait_ref.has_infer_types_or_consts()\n                             && self.predicate_can_apply(obligation.param_env, trait_ref)\n@@ -427,12 +441,16 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                 let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n                                 self.report_similar_impl_candidates(impl_candidates, &mut err);\n                             }\n-                            self.suggest_change_mut(\n-                                &obligation,\n-                                &mut err,\n-                                &trait_ref,\n-                                points_at_arg,\n-                            );\n+                            // Changing mutability doesn't make a difference to whether we have\n+                            // an `Unsize` impl (Fixes ICE in #71036)\n+                            if !is_unsize {\n+                                self.suggest_change_mut(\n+                                    &obligation,\n+                                    &mut err,\n+                                    &trait_ref,\n+                                    points_at_arg,\n+                                );\n+                            }\n                         }\n \n                         // If this error is due to `!: Trait` not implemented but `(): Trait` is\n@@ -1194,7 +1212,6 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 ty::Foreign(..) => Some(19),\n                 ty::GeneratorWitness(..) => Some(20),\n                 ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error => None,\n-                ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n             }\n         }\n \n@@ -1638,7 +1655,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     {\n                         let (span, separator) = match param.bounds {\n                             [] => (span.shrink_to_hi(), \":\"),\n-                            [.., bound] => (bound.span().shrink_to_hi(), \" + \"),\n+                            [.., bound] => (bound.span().shrink_to_hi(), \" +\"),\n                         };\n                         err.span_suggestion_verbose(\n                             span,"}, {"sha": "c098e44fa065c449704fd0a63bb7fef6f6213d39", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 168, "deletions": 10, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,21 +1,24 @@\n use super::{\n     EvaluationResult, Obligation, ObligationCause, ObligationCauseCode, PredicateObligation,\n+    SelectionContext,\n };\n \n use crate::infer::InferCtxt;\n+use crate::traits::normalize_projection_type;\n \n use rustc_errors::{error_code, struct_span_err, Applicability, DiagnosticBuilder, Style};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n+use rustc_hir::lang_items;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n use rustc_middle::ty::TypeckTables;\n use rustc_middle::ty::{\n     self, suggest_constraining_type_param, AdtKind, DefIdTree, Infer, InferTy, ToPredicate, Ty,\n     TyCtxt, TypeFoldable, WithConstness,\n };\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n \n@@ -150,13 +153,22 @@ pub trait InferCtxtExt<'tcx> {\n         T: fmt::Display;\n \n     fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder<'_>);\n+\n+    /// Suggest to await before try: future? => future.await?\n+    fn suggest_await_before_try(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        span: Span,\n+    );\n }\n \n fn predicate_constraint(generics: &hir::Generics<'_>, pred: String) -> (Span, String) {\n     (\n         generics.where_clause.span_for_predicates_or_empty_place().shrink_to_hi(),\n         format!(\n-            \"{} {} \",\n+            \"{} {}\",\n             if !generics.where_clause.predicates.is_empty() { \",\" } else { \" where\" },\n             pred,\n         ),\n@@ -173,7 +185,13 @@ fn suggest_restriction(\n     fn_sig: Option<&hir::FnSig<'_>>,\n     projection: Option<&ty::ProjectionTy<'_>>,\n     trait_ref: ty::PolyTraitRef<'_>,\n+    super_traits: Option<(&Ident, &hir::GenericBounds<'_>)>,\n ) {\n+    // When we are dealing with a trait, `super_traits` will be `Some`:\n+    // Given `trait T: A + B + C {}`\n+    //              -  ^^^^^^^^^ GenericBounds\n+    //              |\n+    //              &Ident\n     let span = generics.where_clause.span_for_predicates_or_empty_place();\n     if span.from_expansion() || span.desugaring_kind().is_some() {\n         return;\n@@ -262,10 +280,28 @@ fn suggest_restriction(\n         );\n     } else {\n         // Trivial case: `T` needs an extra bound: `T: Bound`.\n-        let (sp, sugg) =\n-            predicate_constraint(generics, trait_ref.without_const().to_predicate().to_string());\n-        let appl = Applicability::MachineApplicable;\n-        err.span_suggestion(sp, &format!(\"consider further restricting {}\", msg), sugg, appl);\n+        let (sp, suggestion) = match super_traits {\n+            None => {\n+                predicate_constraint(generics, trait_ref.without_const().to_predicate().to_string())\n+            }\n+            Some((ident, bounds)) => match bounds {\n+                [.., bound] => (\n+                    bound.span().shrink_to_hi(),\n+                    format!(\" + {}\", trait_ref.print_only_trait_path().to_string()),\n+                ),\n+                [] => (\n+                    ident.span.shrink_to_hi(),\n+                    format!(\": {}\", trait_ref.print_only_trait_path().to_string()),\n+                ),\n+            },\n+        };\n+\n+        err.span_suggestion_verbose(\n+            sp,\n+            &format!(\"consider further restricting {}\", msg),\n+            suggestion,\n+            Applicability::MachineApplicable,\n+        );\n     }\n }\n \n@@ -288,13 +324,35 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let mut hir_id = body_id;\n         while let Some(node) = self.tcx.hir().find(hir_id) {\n             match node {\n+                hir::Node::Item(hir::Item {\n+                    ident,\n+                    kind: hir::ItemKind::Trait(_, _, generics, bounds, _),\n+                    ..\n+                }) if self_ty == self.tcx.types.self_param => {\n+                    assert!(param_ty);\n+                    // Restricting `Self` for a single method.\n+                    suggest_restriction(\n+                        &generics,\n+                        \"`Self`\",\n+                        err,\n+                        None,\n+                        projection,\n+                        trait_ref,\n+                        Some((ident, bounds)),\n+                    );\n+                    return;\n+                }\n+\n                 hir::Node::TraitItem(hir::TraitItem {\n                     generics,\n                     kind: hir::TraitItemKind::Fn(..),\n                     ..\n-                }) if param_ty && self_ty == self.tcx.types.self_param => {\n+                }) if self_ty == self.tcx.types.self_param => {\n+                    assert!(param_ty);\n                     // Restricting `Self` for a single method.\n-                    suggest_restriction(&generics, \"`Self`\", err, None, projection, trait_ref);\n+                    suggest_restriction(\n+                        &generics, \"`Self`\", err, None, projection, trait_ref, None,\n+                    );\n                     return;\n                 }\n \n@@ -319,6 +377,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         Some(fn_sig),\n                         projection,\n                         trait_ref,\n+                        None,\n                     );\n                     return;\n                 }\n@@ -336,6 +395,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         None,\n                         projection,\n                         trait_ref,\n+                        None,\n                     );\n                     return;\n                 }\n@@ -691,6 +751,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n \n             if let ty::Ref(region, t_type, mutability) = trait_ref.skip_binder().self_ty().kind {\n+                if region.is_late_bound() || t_type.has_escaping_bound_vars() {\n+                    // Avoid debug assertion in `mk_obligation_for_def_id`.\n+                    //\n+                    // If the self type has escaping bound vars then it's not\n+                    // going to be the type of an expression, so the suggestion\n+                    // probably won't apply anyway.\n+                    return;\n+                }\n+\n                 let trait_type = match mutability {\n                     hir::Mutability::Mut => self.tcx.mk_imm_ref(region, t_type),\n                     hir::Mutability::Not => self.tcx.mk_mut_ref(region, t_type),\n@@ -1616,7 +1685,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 if suggest_const_in_array_repeat_expressions {\n                     err.note(\n                         \"this array initializer can be evaluated at compile-time, see issue \\\n-                         #48147 <https://github.com/rust-lang/rust/issues/49147> \\\n+                         #49147 <https://github.com/rust-lang/rust/issues/49147> \\\n                          for more information\",\n                     );\n                     if tcx.sess.opts.unstable_features.is_nightly_build() {\n@@ -1765,6 +1834,95 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             suggested_limit, self.tcx.crate_name,\n         ));\n     }\n+\n+    fn suggest_await_before_try(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        span: Span,\n+    ) {\n+        debug!(\n+            \"suggest_await_befor_try: obligation={:?}, span={:?}, trait_ref={:?}, trait_ref_self_ty={:?}\",\n+            obligation,\n+            span,\n+            trait_ref,\n+            trait_ref.self_ty()\n+        );\n+        let body_hir_id = obligation.cause.body_id;\n+        let item_id = self.tcx.hir().get_parent_node(body_hir_id);\n+\n+        if let Some(body_id) = self.tcx.hir().maybe_body_owned_by(item_id) {\n+            let body = self.tcx.hir().body(body_id);\n+            if let Some(hir::GeneratorKind::Async(_)) = body.generator_kind {\n+                let future_trait =\n+                    self.tcx.require_lang_item(lang_items::FutureTraitLangItem, None);\n+\n+                let self_ty = self.resolve_vars_if_possible(&trait_ref.self_ty());\n+\n+                let impls_future = self.tcx.type_implements_trait((\n+                    future_trait,\n+                    self_ty,\n+                    ty::List::empty(),\n+                    obligation.param_env,\n+                ));\n+\n+                let item_def_id = self\n+                    .tcx\n+                    .associated_items(future_trait)\n+                    .in_definition_order()\n+                    .next()\n+                    .unwrap()\n+                    .def_id;\n+                // `<T as Future>::Output`\n+                let projection_ty = ty::ProjectionTy {\n+                    // `T`\n+                    substs: self.tcx.mk_substs_trait(\n+                        trait_ref.self_ty(),\n+                        self.fresh_substs_for_item(span, item_def_id),\n+                    ),\n+                    // `Future::Output`\n+                    item_def_id,\n+                };\n+\n+                let mut selcx = SelectionContext::new(self);\n+\n+                let mut obligations = vec![];\n+                let normalized_ty = normalize_projection_type(\n+                    &mut selcx,\n+                    obligation.param_env,\n+                    projection_ty,\n+                    obligation.cause.clone(),\n+                    0,\n+                    &mut obligations,\n+                );\n+\n+                debug!(\n+                    \"suggest_await_befor_try: normalized_projection_type {:?}\",\n+                    self.resolve_vars_if_possible(&normalized_ty)\n+                );\n+                let try_obligation = self.mk_obligation_for_def_id(\n+                    trait_ref.def_id(),\n+                    normalized_ty,\n+                    obligation.cause.clone(),\n+                    obligation.param_env,\n+                );\n+                debug!(\"suggest_await_befor_try: try_trait_obligation {:?}\", try_obligation);\n+                if self.predicate_may_hold(&try_obligation) && impls_future {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                        if snippet.ends_with('?') {\n+                            err.span_suggestion(\n+                                span,\n+                                \"consider using `.await` here\",\n+                                format!(\"{}.await?\", snippet.trim_end_matches('?')),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n /// Collect all the returned expressions within the input expression.\n@@ -1854,7 +2012,7 @@ impl NextTypeParamName for &[hir::GenericParam<'_>] {\n     fn next_type_param_name(&self, name: Option<&str>) -> String {\n         // This is the whitelist of possible parameter names that we might suggest.\n         let name = name.and_then(|n| n.chars().next()).map(|c| c.to_string().to_uppercase());\n-        let name = name.as_ref().map(|s| s.as_str());\n+        let name = name.as_deref();\n         let possible_names = [name.unwrap_or(\"T\"), \"T\", \"U\", \"V\", \"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\"];\n         let used_names = self\n             .iter()"}, {"sha": "9592f93ce2e7606c21bc540c4bb6c359fdfe28ff", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -31,7 +31,9 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::middle::region;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc_middle::ty::{self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, WithConstness};\n+use rustc_middle::ty::{\n+    self, GenericParamDefKind, ParamEnv, ToPredicate, Ty, TyCtxt, WithConstness,\n+};\n use rustc_span::Span;\n \n use std::fmt::Debug;\n@@ -523,6 +525,43 @@ fn vtable_methods<'tcx>(\n     }))\n }\n \n+/// Check whether a `ty` implements given trait(trait_def_id).\n+///\n+/// NOTE: Always return `false` for a type which needs inference.\n+fn type_implements_trait<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: (\n+        DefId,    // trait_def_id,\n+        Ty<'tcx>, // type\n+        SubstsRef<'tcx>,\n+        ParamEnv<'tcx>,\n+    ),\n+) -> bool {\n+    let (trait_def_id, ty, params, param_env) = key;\n+\n+    debug!(\n+        \"type_implements_trait: trait_def_id={:?}, type={:?}, params={:?}, param_env={:?}\",\n+        trait_def_id, ty, params, param_env\n+    );\n+\n+    // Do not check on infer_types to avoid panic in evaluate_obligation.\n+    if ty.has_infer_types() {\n+        return false;\n+    }\n+\n+    let ty = tcx.erase_regions(&ty);\n+\n+    let trait_ref = ty::TraitRef { def_id: trait_def_id, substs: tcx.mk_substs_trait(ty, params) };\n+\n+    let obligation = Obligation {\n+        cause: ObligationCause::dummy(),\n+        param_env,\n+        recursion_depth: 0,\n+        predicate: trait_ref.without_const().to_predicate(),\n+    };\n+    tcx.infer_ctxt().enter(|infcx| infcx.predicate_must_hold_modulo_regions(&obligation))\n+}\n+\n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     object_safety::provide(providers);\n     *providers = ty::query::Providers {\n@@ -531,6 +570,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         codegen_fulfill_obligation: codegen::codegen_fulfill_obligation,\n         vtable_methods,\n         substitute_normalize_and_test_predicates,\n+        type_implements_trait,\n         ..*providers\n     };\n }"}, {"sha": "0779882b6dd58145f6d0ce552b09ea13213f732f", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -20,6 +20,7 @@ use crate::traits::error_reporting::InferCtxtExt;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::ErrorReported;\n use rustc_hir::def_id::DefId;\n+use rustc_hir::lang_items::{FnOnceTraitLangItem, GeneratorTraitLangItem};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n@@ -1222,7 +1223,7 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n \n     let tcx = selcx.tcx();\n \n-    let gen_def_id = tcx.lang_items().gen_trait().unwrap();\n+    let gen_def_id = tcx.require_lang_item(GeneratorTraitLangItem, None);\n \n     let predicate = super::util::generator_trait_ref_and_outputs(\n         tcx,\n@@ -1309,7 +1310,7 @@ fn confirm_callable_candidate<'cx, 'tcx>(\n     debug!(\"confirm_callable_candidate({:?},{:?})\", obligation, fn_sig);\n \n     // the `Output` associated type is declared on `FnOnce`\n-    let fn_once_def_id = tcx.lang_items().fn_once_trait().unwrap();\n+    let fn_once_def_id = tcx.require_lang_item(FnOnceTraitLangItem, None);\n \n     let predicate = super::util::closure_trait_ref_and_return_type(\n         tcx,"}, {"sha": "856a2111fc82c8da116de604909a7ddef4f4b789", "filename": "src/librustc_trait_selection/traits/query/dropck_outlives.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -135,7 +135,5 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         | ty::Infer(_)\n         | ty::Bound(..)\n         | ty::Generator(..) => false,\n-\n-        ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n     }\n }"}, {"sha": "f0ff30232b96dea78c6e7ef88cae76afcddb4acd", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -2178,8 +2178,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::Projection(_) | ty::Param(_) | ty::Opaque(..) => None,\n             ty::Infer(ty::TyVar(_)) => Ambiguous,\n \n-            ty::UnnormalizedProjection(..)\n-            | ty::Placeholder(..)\n+            ty::Placeholder(..)\n             | ty::Bound(..)\n             | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble builtin bounds of unexpected type: {:?}\", self_ty);\n@@ -2250,8 +2249,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ambiguous\n             }\n \n-            ty::UnnormalizedProjection(..)\n-            | ty::Placeholder(..)\n+            ty::Placeholder(..)\n             | ty::Bound(..)\n             | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble builtin bounds of unexpected type: {:?}\", self_ty);\n@@ -2284,8 +2282,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Never\n             | ty::Char => Vec::new(),\n \n-            ty::UnnormalizedProjection(..)\n-            | ty::Placeholder(..)\n+            ty::Placeholder(..)\n             | ty::Dynamic(..)\n             | ty::Param(..)\n             | ty::Foreign(..)"}, {"sha": "eb63505b69b413a73a8d0f8783a88c57a727012c", "filename": "src/librustc_trait_selection/traits/structural_match.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -4,6 +4,7 @@ use crate::traits::{self, ConstPatternStructural, TraitEngine};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n+use rustc_hir::lang_items::{StructuralPeqTraitLangItem, StructuralTeqTraitLangItem};\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_span::Span;\n \n@@ -69,7 +70,7 @@ pub fn type_marked_structural(\n     let mut fulfillment_cx = traits::FulfillmentContext::new();\n     let cause = ObligationCause::new(span, id, ConstPatternStructural);\n     // require `#[derive(PartialEq)]`\n-    let structural_peq_def_id = infcx.tcx.lang_items().structural_peq_trait().unwrap();\n+    let structural_peq_def_id = infcx.tcx.require_lang_item(StructuralPeqTraitLangItem, Some(span));\n     fulfillment_cx.register_bound(\n         infcx,\n         ty::ParamEnv::empty(),\n@@ -80,7 +81,7 @@ pub fn type_marked_structural(\n     // for now, require `#[derive(Eq)]`. (Doing so is a hack to work around\n     // the type `for<'a> fn(&'a ())` failing to implement `Eq` itself.)\n     let cause = ObligationCause::new(span, id, ConstPatternStructural);\n-    let structural_teq_def_id = infcx.tcx.lang_items().structural_teq_trait().unwrap();\n+    let structural_teq_def_id = infcx.tcx.require_lang_item(StructuralTeqTraitLangItem, Some(span));\n     fulfillment_cx.register_bound(\n         infcx,\n         ty::ParamEnv::empty(),"}, {"sha": "ba7ec96775c047dd5688c55627480955dadd6987", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -389,8 +389,6 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     self.compute_projection(data);\n                 }\n \n-                ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n-\n                 ty::Adt(def, substs) => {\n                     // WfNominalType\n                     let obligations = self.nominal_obligations(def.did, substs);"}, {"sha": "a2aee9b6ef74d777d9a6c8dc6e6dfe73e6a27511", "filename": "src/librustc_traits/chalk/db.rs", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_traits%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_traits%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Fdb.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -59,7 +59,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         // clauses or bounds?\n         let predicates = self.tcx.predicates_defined_on(def_id).predicates;\n         let where_clauses: Vec<_> = predicates\n-            .into_iter()\n+            .iter()\n             .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n             .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n \n@@ -88,7 +88,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         let binders = binders_for(&self.interner, bound_vars);\n         let predicates = self.tcx.predicates_defined_on(def_id).predicates;\n         let where_clauses: Vec<_> = predicates\n-            .into_iter()\n+            .iter()\n             .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n             .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n \n@@ -134,7 +134,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n                 let predicates = self.tcx.predicates_of(adt_def_id).predicates;\n                 let where_clauses: Vec<_> = predicates\n-                    .into_iter()\n+                    .iter()\n                     .map(|(wc, _)| wc.subst(self.tcx, bound_vars))\n                     .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner))\n                     .collect();\n@@ -166,46 +166,42 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                         fundamental: adt_def.is_fundamental(),\n                     },\n                 });\n-                return struct_datum;\n+                struct_datum\n             }\n-            RustDefId::Ref(_) => {\n-                return Arc::new(chalk_rust_ir::StructDatum {\n-                    id: struct_id,\n-                    binders: chalk_ir::Binders::new(\n-                        chalk_ir::ParameterKinds::from(\n-                            &self.interner,\n-                            vec![\n-                                chalk_ir::ParameterKind::Lifetime(()),\n-                                chalk_ir::ParameterKind::Ty(()),\n-                            ],\n-                        ),\n-                        chalk_rust_ir::StructDatumBound { fields: vec![], where_clauses: vec![] },\n+            RustDefId::Ref(_) => Arc::new(chalk_rust_ir::StructDatum {\n+                id: struct_id,\n+                binders: chalk_ir::Binders::new(\n+                    chalk_ir::ParameterKinds::from(\n+                        &self.interner,\n+                        vec![\n+                            chalk_ir::ParameterKind::Lifetime(()),\n+                            chalk_ir::ParameterKind::Ty(()),\n+                        ],\n                     ),\n-                    flags: chalk_rust_ir::StructFlags { upstream: false, fundamental: false },\n-                });\n-            }\n-            RustDefId::Array | RustDefId::Slice => {\n-                return Arc::new(chalk_rust_ir::StructDatum {\n-                    id: struct_id,\n-                    binders: chalk_ir::Binders::new(\n-                        chalk_ir::ParameterKinds::from(\n-                            &self.interner,\n-                            Some(chalk_ir::ParameterKind::Ty(())),\n-                        ),\n-                        chalk_rust_ir::StructDatumBound { fields: vec![], where_clauses: vec![] },\n+                    chalk_rust_ir::StructDatumBound { fields: vec![], where_clauses: vec![] },\n+                ),\n+                flags: chalk_rust_ir::StructFlags { upstream: false, fundamental: false },\n+            }),\n+            RustDefId::Array | RustDefId::Slice => Arc::new(chalk_rust_ir::StructDatum {\n+                id: struct_id,\n+                binders: chalk_ir::Binders::new(\n+                    chalk_ir::ParameterKinds::from(\n+                        &self.interner,\n+                        Some(chalk_ir::ParameterKind::Ty(())),\n                     ),\n-                    flags: chalk_rust_ir::StructFlags { upstream: false, fundamental: false },\n-                });\n-            }\n+                    chalk_rust_ir::StructDatumBound { fields: vec![], where_clauses: vec![] },\n+                ),\n+                flags: chalk_rust_ir::StructFlags { upstream: false, fundamental: false },\n+            }),\n             RustDefId::Str | RustDefId::Never | RustDefId::FnDef(_) => {\n-                return Arc::new(chalk_rust_ir::StructDatum {\n+                Arc::new(chalk_rust_ir::StructDatum {\n                     id: struct_id,\n                     binders: chalk_ir::Binders::new(\n                         chalk_ir::ParameterKinds::new(&self.interner),\n                         chalk_rust_ir::StructDatumBound { fields: vec![], where_clauses: vec![] },\n                     ),\n                     flags: chalk_rust_ir::StructFlags { upstream: false, fundamental: false },\n-                });\n+                })\n             }\n \n             _ => bug!(\"Used not struct variant when expecting struct variant.\"),\n@@ -228,7 +224,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n         let predicates = self.tcx.predicates_of(def_id).predicates;\n         let where_clauses: Vec<_> = predicates\n-            .into_iter()\n+            .iter()\n             .map(|(wc, _)| wc.subst(self.tcx, bound_vars))\n             .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n \n@@ -260,7 +256,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         // not there yet.\n \n         let all_impls = self.tcx.all_impls(def_id);\n-        let matched_impls = all_impls.into_iter().filter(|impl_def_id| {\n+        let matched_impls = all_impls.filter(|impl_def_id| {\n             use chalk_ir::could_match::CouldMatch;\n             let trait_ref = self.tcx.impl_trait_ref(*impl_def_id).unwrap();\n             let bound_vars = bound_vars_for_item(self.tcx, *impl_def_id);\n@@ -304,7 +300,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                 _ => {}\n             }\n         }\n-        return false;\n+        false\n     }\n \n     fn associated_ty_value(\n@@ -379,7 +375,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                                     ty::AdtKind::Struct | ty::AdtKind::Union => None,\n                                     ty::AdtKind::Enum => {\n                                         let constraint = self.tcx.adt_sized_constraint(adt_def_id);\n-                                        if constraint.0.len() > 0 {\n+                                        if !constraint.0.is_empty() {\n                                             unimplemented!()\n                                         } else {\n                                             Some(true)\n@@ -412,7 +408,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                                     ty::AdtKind::Struct | ty::AdtKind::Union => None,\n                                     ty::AdtKind::Enum => {\n                                         let constraint = self.tcx.adt_sized_constraint(adt_def_id);\n-                                        if constraint.0.len() > 0 {\n+                                        if !constraint.0.is_empty() {\n                                             unimplemented!()\n                                         } else {\n                                             Some(true)"}, {"sha": "aacbd311d1deca3ffb491e037c6ae1782d344f11", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -274,7 +274,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n         let uint = |i| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Uint(i)), empty());\n         let float = |f| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Float(f)), empty());\n \n-        return match self.kind {\n+        match self.kind {\n             Bool => apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Bool), empty()),\n             Char => apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Char), empty()),\n             Int(ty) => match ty {\n@@ -353,7 +353,6 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n                 apply(chalk_ir::TypeName::Tuple(substs.len()), substs.lower_into(interner))\n             }\n             Projection(proj) => TyData::Alias(proj.lower_into(interner)).intern(interner),\n-            UnnormalizedProjection(_proj) => unimplemented!(),\n             Opaque(_def_id, _substs) => unimplemented!(),\n             // This should have been done eagerly prior to this, and all Params\n             // should have been substituted to placeholders\n@@ -370,7 +369,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n             .intern(interner),\n             Infer(_infer) => unimplemented!(),\n             Error => unimplemented!(),\n-        };\n+        }\n     }\n }\n "}, {"sha": "08475d6a09db14d4b1c2ec8835ab6a659334ba8c", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -271,8 +271,6 @@ fn dtorck_constraint_for_ty<'tcx>(\n             constraints.dtorck_types.push(ty);\n         }\n \n-        ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n-\n         ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error => {\n             // By the time this code runs, all type variables ought to\n             // be fully resolved."}, {"sha": "1aa11a761c821eb4fca286be48bd534c3f8d3d15", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -47,8 +47,6 @@ fn sized_constraint_for_ty<'tcx>(\n             vec![ty]\n         }\n \n-        UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n-\n         Param(..) => {\n             // perf hack: if there is a `T: Sized` bound, then\n             // we know that `T` is Sized and do not need to check"}, {"sha": "46d6706cbf42925e674fb8d71c4b05ba94ea6e44", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -115,7 +115,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Foreign(..) => Some(PointerKind::Thin),\n             // We should really try to normalize here.\n             ty::Projection(ref pi) => Some(PointerKind::OfProjection(pi)),\n-            ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n             ty::Opaque(def_id, substs) => Some(PointerKind::OfOpaque(def_id, substs)),\n             ty::Param(ref p) => Some(PointerKind::OfParam(p)),\n             // Insufficient type information."}, {"sha": "87a6f119acb09a6b34a26b774ce9b29d189a8e04", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -6,7 +6,7 @@ use crate::astconv::AstConv;\n use crate::middle::region;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::lang_items;\n+use rustc_hir::lang_items::{FutureTraitLangItem, GeneratorTraitLangItem};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::infer::{InferOk, InferResult};\n@@ -245,7 +245,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let trait_ref = projection.to_poly_trait_ref(tcx);\n \n         let is_fn = tcx.fn_trait_kind_from_lang_item(trait_ref.def_id()).is_some();\n-        let gen_trait = tcx.require_lang_item(lang_items::GeneratorTraitLangItem, cause_span);\n+        let gen_trait = tcx.require_lang_item(GeneratorTraitLangItem, cause_span);\n         let is_gen = gen_trait == trait_ref.def_id();\n         if !is_fn && !is_gen {\n             debug!(\"deduce_sig_from_projection: not fn or generator\");\n@@ -678,7 +678,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Check that this is a projection from the `Future` trait.\n         let trait_ref = predicate.projection_ty.trait_ref(self.tcx);\n-        let future_trait = self.tcx.lang_items().future_trait().unwrap();\n+        let future_trait = self.tcx.require_lang_item(FutureTraitLangItem, Some(cause_span));\n         if trait_ref.def_id != future_trait {\n             debug!(\"deduce_future_output_from_projection: not a future\");\n             return None;"}, {"sha": "9694ce9450c27ec3565e9686ba3e3b35c4e3e404", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -7,6 +7,7 @@ use rustc_trait_selection::traits::{self, ObligationCause};\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n+use rustc_hir::lang_items::{CloneTraitLangItem, DerefTraitLangItem};\n use rustc_hir::{is_range_literal, Node};\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::{self, AssocItem, Ty, TypeAndMut};\n@@ -455,8 +456,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n                 if self.can_coerce(ref_ty, expected) {\n                     let mut sugg_sp = sp;\n-                    if let hir::ExprKind::MethodCall(segment, _sp, args) = &expr.kind {\n-                        let clone_trait = self.tcx.lang_items().clone_trait().unwrap();\n+                    if let hir::ExprKind::MethodCall(ref segment, sp, ref args) = expr.kind {\n+                        let clone_trait = self.tcx.require_lang_item(CloneTraitLangItem, Some(sp));\n                         if let ([arg], Some(true), sym::clone) = (\n                             &args[..],\n                             self.tables.borrow().type_dependent_def_id(expr.hir_id).map(|did| {\n@@ -634,7 +635,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ if sp == expr.span && !is_macro => {\n                 // Check for `Deref` implementations by constructing a predicate to\n                 // prove: `<T as Deref>::Output == U`\n-                let deref_trait = self.tcx.lang_items().deref_trait().unwrap();\n+                let deref_trait = self.tcx.require_lang_item(DerefTraitLangItem, Some(sp));\n                 let item_def_id = self\n                     .tcx\n                     .associated_items(deref_trait)\n@@ -708,24 +709,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // For now, don't suggest casting with `as`.\n         let can_cast = false;\n \n-        let mut prefix = String::new();\n-        if let Some(hir::Node::Expr(hir::Expr {\n-            kind: hir::ExprKind::Struct(_, fields, _), ..\n+        let prefix = if let Some(hir::Node::Expr(hir::Expr {\n+            kind: hir::ExprKind::Struct(_, fields, _),\n+            ..\n         })) = self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id))\n         {\n             // `expr` is a literal field for a struct, only suggest if appropriate\n-            for field in *fields {\n-                if field.expr.hir_id == expr.hir_id && field.is_shorthand {\n-                    // This is a field literal\n-                    prefix = format!(\"{}: \", field.ident);\n-                    break;\n-                }\n-            }\n-            if &prefix == \"\" {\n+            match (*fields)\n+                .iter()\n+                .find(|field| field.expr.hir_id == expr.hir_id && field.is_shorthand)\n+            {\n+                // This is a field literal\n+                Some(field) => format!(\"{}: \", field.ident),\n                 // Likely a field was meant, but this field wasn't found. Do not suggest anything.\n-                return false;\n+                None => return false,\n             }\n-        }\n+        } else {\n+            String::new()\n+        };\n         if let hir::ExprKind::Call(path, args) = &expr.kind {\n             if let (hir::ExprKind::Path(hir::QPath::TypeRelative(base_ty, path_segment)), 1) =\n                 (&path.kind, args.len())\n@@ -817,7 +818,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             let suggest_to_change_suffix_or_into =\n                 |err: &mut DiagnosticBuilder<'_>, is_fallible: bool| {\n-                    let into_sugg = into_suggestion.clone();\n                     err.span_suggestion(\n                         expr.span,\n                         if literal_is_ty_suffixed(expr) {\n@@ -832,7 +832,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         } else if is_fallible {\n                             try_into_suggestion\n                         } else {\n-                            into_sugg\n+                            into_suggestion.clone()\n                         },\n                         Applicability::MachineApplicable,\n                     );"}, {"sha": "db6c30adb04cc9d4f5b13500d8c6957a243d394b", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -69,7 +69,7 @@ fn equate_intrinsic_type<'tcx>(\n /// Returns `true` if the given intrinsic is unsafe to call or not.\n pub fn intrinsic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n     match intrinsic {\n-        \"size_of\" | \"min_align_of\" | \"needs_drop\" | \"caller_location\" | \"size_of_val\"\n+        \"abort\" | \"size_of\" | \"min_align_of\" | \"needs_drop\" | \"caller_location\" | \"size_of_val\"\n         | \"min_align_of_val\" | \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\"\n         | \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" | \"saturating_add\"\n         | \"saturating_sub\" | \"rotate_left\" | \"rotate_right\" | \"ctpop\" | \"ctlz\" | \"cttz\"\n@@ -130,7 +130,9 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             }\n         };\n         (n_tps, inputs, output, hir::Unsafety::Unsafe)\n-    } else if &name[..] == \"abort\" || &name[..] == \"unreachable\" {\n+    } else if &name[..] == \"abort\" {\n+        (0, Vec::new(), tcx.types.never, hir::Unsafety::Normal)\n+    } else if &name[..] == \"unreachable\" {\n         (0, Vec::new(), tcx.types.never, hir::Unsafety::Unsafe)\n     } else {\n         let unsafety = intrinsic_operation_unsafety(&name[..]);"}, {"sha": "200263728d934f397ca6bd7d93ffc8cf74d33682", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 73, "deletions": 79, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -100,7 +100,9 @@ use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::lang_items;\n+use rustc_hir::lang_items::{\n+    FutureTraitLangItem, PinTypeLangItem, SizedTraitLangItem, VaListTypeLangItem,\n+};\n use rustc_hir::{ExprKind, GenericArg, HirIdMap, Item, ItemKind, Node, PatKind, QPath};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n@@ -831,13 +833,6 @@ fn primary_body_of(\n }\n \n fn has_typeck_tables(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    // FIXME(#71104) some `LocalDefId` do not seem to have a corresponding `HirId`.\n-    if let Some(def_id) = def_id.as_local() {\n-        if tcx.hir().opt_local_def_id_to_hir_id(def_id).is_none() {\n-            return false;\n-        }\n-    }\n-\n     // Closures' tables come from their outermost function,\n     // as they are part of the same \"inference environment\".\n     let outer_def_id = tcx.closure_base_def_id(def_id);\n@@ -1342,10 +1337,8 @@ fn check_fn<'a, 'tcx>(\n     // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n     // (as it's created inside the body itself, not passed in from outside).\n     let maybe_va_list = if fn_sig.c_variadic {\n-        let va_list_did = tcx.require_lang_item(\n-            lang_items::VaListTypeLangItem,\n-            Some(body.params.last().unwrap().span),\n-        );\n+        let va_list_did =\n+            tcx.require_lang_item(VaListTypeLangItem, Some(body.params.last().unwrap().span));\n         let region = tcx.mk_region(ty::ReScope(region::Scope {\n             id: body.value.hir_id.local_id,\n             data: region::ScopeData::CallSite,\n@@ -1645,81 +1638,78 @@ fn check_opaque_for_inheriting_lifetimes(tcx: TyCtxt<'tcx>, def_id: LocalDefId,\n     impl<'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueVisitor<'tcx> {\n         fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n             debug!(\"check_opaque_for_inheriting_lifetimes: (visit_ty) t={:?}\", t);\n-            self.ty = Some(t);\n-            if t == self.opaque_identity_ty { false } else { t.super_visit_with(self) }\n+            if t != self.opaque_identity_ty && t.super_visit_with(self) {\n+                self.ty = Some(t);\n+                return true;\n+            }\n+            false\n         }\n \n         fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n             debug!(\"check_opaque_for_inheriting_lifetimes: (visit_region) r={:?}\", r);\n             if let RegionKind::ReEarlyBound(ty::EarlyBoundRegion { index, .. }) = r {\n-                let found_lifetime = *index < self.generics.parent_count as u32;\n-                if !found_lifetime {\n-                    self.ty = None;\n-                }\n-                return found_lifetime;\n+                return *index < self.generics.parent_count as u32;\n             }\n \n             r.super_visit_with(self)\n         }\n     }\n \n-    let mut visitor = ProhibitOpaqueVisitor {\n-        opaque_identity_ty: tcx.mk_opaque(\n-            def_id.to_def_id(),\n-            InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n-        ),\n-        generics: tcx.generics_of(def_id),\n-        ty: None,\n-    };\n-    debug!(\"check_opaque_for_inheriting_lifetimes: visitor={:?}\", visitor);\n-\n-    let prohibit_opaque = match item.kind {\n-        ItemKind::OpaqueTy(hir::OpaqueTy {\n-            origin: hir::OpaqueTyOrigin::AsyncFn | hir::OpaqueTyOrigin::FnReturn,\n-            ..\n-        }) => tcx\n+    if let ItemKind::OpaqueTy(hir::OpaqueTy {\n+        origin: hir::OpaqueTyOrigin::AsyncFn | hir::OpaqueTyOrigin::FnReturn,\n+        ..\n+    }) = item.kind\n+    {\n+        let mut visitor = ProhibitOpaqueVisitor {\n+            opaque_identity_ty: tcx.mk_opaque(\n+                def_id.to_def_id(),\n+                InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n+            ),\n+            generics: tcx.generics_of(def_id),\n+            ty: None,\n+        };\n+        let prohibit_opaque = tcx\n             .predicates_of(def_id)\n             .predicates\n             .iter()\n-            .any(|(predicate, _)| predicate.visit_with(&mut visitor)),\n-        _ => false,\n-    };\n-    debug!(\n-        \"check_opaque_for_inheriting_lifetimes: prohibit_opaque={:?}, visitor={:?}\",\n-        prohibit_opaque, visitor\n-    );\n+            .any(|(predicate, _)| predicate.visit_with(&mut visitor));\n+        debug!(\n+            \"check_opaque_for_inheriting_lifetimes: prohibit_opaque={:?}, visitor={:?}\",\n+            prohibit_opaque, visitor\n+        );\n \n-    if prohibit_opaque {\n-        let is_async = match item.kind {\n-            ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => match origin {\n-                hir::OpaqueTyOrigin::AsyncFn => true,\n-                _ => false,\n-            },\n-            _ => unreachable!(),\n-        };\n+        if prohibit_opaque {\n+            let is_async = match item.kind {\n+                ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => match origin {\n+                    hir::OpaqueTyOrigin::AsyncFn => true,\n+                    _ => false,\n+                },\n+                _ => unreachable!(),\n+            };\n \n-        let mut err = struct_span_err!(\n-            tcx.sess,\n-            span,\n-            E0755,\n-            \"`{}` return type cannot contain a projection or `Self` that references lifetimes from \\\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0755,\n+                \"`{}` return type cannot contain a projection or `Self` that references lifetimes from \\\n              a parent scope\",\n-            if is_async { \"async fn\" } else { \"impl Trait\" },\n-        );\n+                if is_async { \"async fn\" } else { \"impl Trait\" },\n+            );\n \n-        if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(span) {\n-            if snippet == \"Self\" {\n-                if let Some(ty) = visitor.ty {\n-                    err.span_suggestion(\n-                        span,\n-                        \"consider spelling out the type instead\",\n-                        format!(\"{:?}\", ty),\n-                        Applicability::MaybeIncorrect,\n-                    );\n+            if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(span) {\n+                if snippet == \"Self\" {\n+                    if let Some(ty) = visitor.ty {\n+                        err.span_suggestion(\n+                            span,\n+                            \"consider spelling out the type instead\",\n+                            format!(\"{:?}\", ty),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n                 }\n             }\n+            err.emit();\n         }\n-        err.emit();\n     }\n }\n \n@@ -3326,7 +3316,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         code: traits::ObligationCauseCode<'tcx>,\n     ) {\n         if !ty.references_error() {\n-            let lang_item = self.tcx.require_lang_item(lang_items::SizedTraitLangItem, None);\n+            let lang_item = self.tcx.require_lang_item(SizedTraitLangItem, None);\n             self.require_type_meets(ty, span, code, lang_item);\n         }\n     }\n@@ -5165,7 +5155,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => {}\n         }\n         let boxed_found = self.tcx.mk_box(found);\n-        let new_found = self.tcx.mk_lang_item(boxed_found, lang_items::PinTypeLangItem).unwrap();\n+        let new_found = self.tcx.mk_lang_item(boxed_found, PinTypeLangItem).unwrap();\n         if let (true, Ok(snippet)) = (\n             self.can_coerce(new_found, expected),\n             self.sess().source_map().span_to_snippet(expr.span),\n@@ -5312,6 +5302,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) {\n+        debug!(\"suggest_missing_await: expr={:?} expected={:?}, found={:?}\", expr, expected, found);\n         // `.await` is not permitted outside of `async` bodies, so don't bother to suggest if the\n         // body isn't `async`.\n         let item_id = self.tcx().hir().get_parent_node(self.body_id);\n@@ -5321,30 +5312,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let sp = expr.span;\n                 // Check for `Future` implementations by constructing a predicate to\n                 // prove: `<T as Future>::Output == U`\n-                let future_trait = self.tcx.lang_items().future_trait().unwrap();\n+                let future_trait = self.tcx.require_lang_item(FutureTraitLangItem, Some(sp));\n                 let item_def_id = self\n                     .tcx\n                     .associated_items(future_trait)\n                     .in_definition_order()\n                     .next()\n                     .unwrap()\n                     .def_id;\n+                // `<T as Future>::Output`\n+                let projection_ty = ty::ProjectionTy {\n+                    // `T`\n+                    substs: self\n+                        .tcx\n+                        .mk_substs_trait(found, self.fresh_substs_for_item(sp, item_def_id)),\n+                    // `Future::Output`\n+                    item_def_id,\n+                };\n+\n                 let predicate =\n                     ty::Predicate::Projection(ty::Binder::bind(ty::ProjectionPredicate {\n-                        // `<T as Future>::Output`\n-                        projection_ty: ty::ProjectionTy {\n-                            // `T`\n-                            substs: self.tcx.mk_substs_trait(\n-                                found,\n-                                self.fresh_substs_for_item(sp, item_def_id),\n-                            ),\n-                            // `Future::Output`\n-                            item_def_id,\n-                        },\n+                        projection_ty,\n                         ty: expected,\n                     }));\n                 let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n+\n                 debug!(\"suggest_missing_await: trying obligation {:?}\", obligation);\n+\n                 if self.infcx.predicate_may_hold(&obligation) {\n                     debug!(\"suggest_missing_await: obligation held: {:?}\", obligation);\n                     if let Ok(code) = self.sess().source_map().span_to_snippet(sp) {"}, {"sha": "efa3cd9955b49610ad1537568bb145f130dbf4e5", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -4,7 +4,9 @@\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_hir::lang_items::UnsizeTraitLangItem;\n+use rustc_hir::lang_items::{\n+    CoerceUnsizedTraitLangItem, DispatchFromDynTraitLangItem, UnsizeTraitLangItem,\n+};\n use rustc_hir::ItemKind;\n use rustc_infer::infer;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n@@ -145,11 +147,11 @@ fn visit_implementation_of_coerce_unsized(tcx: TyCtxt<'tcx>, impl_did: LocalDefI\n fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_dispatch_from_dyn: impl_did={:?}\", impl_did);\n \n-    let dispatch_from_dyn_trait = tcx.lang_items().dispatch_from_dyn_trait().unwrap();\n-\n     let impl_hir_id = tcx.hir().as_local_hir_id(impl_did);\n     let span = tcx.hir().span(impl_hir_id);\n \n+    let dispatch_from_dyn_trait = tcx.require_lang_item(DispatchFromDynTraitLangItem, Some(span));\n+\n     let source = tcx.type_of(impl_did);\n     assert!(!source.has_escaping_bound_vars());\n     let target = {\n@@ -314,22 +316,23 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n \n pub fn coerce_unsized_info(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedInfo {\n     debug!(\"compute_coerce_unsized_info(impl_did={:?})\", impl_did);\n-    let coerce_unsized_trait = tcx.lang_items().coerce_unsized_trait().unwrap();\n+\n+    // this provider should only get invoked for local def-ids\n+    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did.expect_local());\n+    let span = tcx.hir().span(impl_hir_id);\n+\n+    let coerce_unsized_trait = tcx.require_lang_item(CoerceUnsizedTraitLangItem, Some(span));\n \n     let unsize_trait = tcx.lang_items().require(UnsizeTraitLangItem).unwrap_or_else(|err| {\n         tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n     });\n \n-    // this provider should only get invoked for local def-ids\n-    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did.expect_local());\n-\n     let source = tcx.type_of(impl_did);\n     let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n     assert_eq!(trait_ref.def_id, coerce_unsized_trait);\n     let target = trait_ref.substs.type_at(1);\n     debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (bound)\", source, target);\n \n-    let span = tcx.hir().span(impl_hir_id);\n     let param_env = tcx.param_env(impl_did);\n     assert!(!source.has_escaping_bound_vars());\n "}, {"sha": "3a680f55c8c309146ce40738571d529294217cf2", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -344,11 +344,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // types, where we use Error as the Self type\n             }\n \n-            ty::Placeholder(..)\n-            | ty::UnnormalizedProjection(..)\n-            | ty::GeneratorWitness(..)\n-            | ty::Bound(..)\n-            | ty::Infer(..) => {\n+            ty::Placeholder(..) | ty::GeneratorWitness(..) | ty::Bound(..) | ty::Infer(..) => {\n                 bug!(\n                     \"unexpected type encountered in \\\n                       variance inference: {}\","}, {"sha": "6c001bc548410670f9825e0d1920b9eae77e2f62", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1722,7 +1722,6 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n             ty::Bound(..) => panic!(\"Bound\"),\n             ty::Placeholder(..) => panic!(\"Placeholder\"),\n-            ty::UnnormalizedProjection(..) => panic!(\"UnnormalizedProjection\"),\n             ty::GeneratorWitness(..) => panic!(\"GeneratorWitness\"),\n             ty::Infer(..) => panic!(\"Infer\"),\n             ty::Error => panic!(\"Error\"),"}, {"sha": "381238165274de42d61683ab44d30eebd2a8cf83", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -643,6 +643,15 @@ impl Attributes {\n             })\n             .collect()\n     }\n+\n+    pub fn get_doc_aliases(&self) -> FxHashSet<String> {\n+        self.other_attrs\n+            .lists(sym::doc)\n+            .filter(|a| a.check_name(sym::alias))\n+            .filter_map(|a| a.value_str().map(|s| s.to_string().replace(\"\\\"\", \"\")))\n+            .filter(|v| !v.is_empty())\n+            .collect::<FxHashSet<_>>()\n+    }\n }\n \n impl PartialEq for Attributes {"}, {"sha": "5dbcc5c9ec8b9dcfb5757304bc2e2a444ca94cc0", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -447,7 +447,7 @@ impl Options {\n             None => return Err(3),\n         };\n \n-        match matches.opt_str(\"r\").as_ref().map(|s| &**s) {\n+        match matches.opt_str(\"r\").as_deref() {\n             Some(\"rust\") | None => {}\n             Some(s) => {\n                 diag.struct_err(&format!(\"unknown input format: {}\", s)).emit();"}, {"sha": "bf59b3f25734da9b520ebaba1fe2f5ac193d1ed3", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -129,7 +129,7 @@ impl<'tcx> DocContext<'tcx> {\n         );\n \n         MAX_DEF_ID.with(|m| {\n-            m.borrow_mut().entry(def_id.krate.clone()).or_insert(start_def_id);\n+            m.borrow_mut().entry(def_id.krate).or_insert(start_def_id);\n         });\n \n         self.all_fake_def_ids.borrow_mut().insert(def_id);"}, {"sha": "ea65b3905272e9c180ae75d081c5cca588d9d713", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -114,7 +114,6 @@ pub fn render<T: Print, S: Print>(\n         window.rootPath = \\\"{root_path}\\\";\\\n         window.currentCrate = \\\"{krate}\\\";\\\n     </script>\\\n-    <script src=\\\"{root_path}aliases{suffix}.js\\\"></script>\\\n     <script src=\\\"{static_root_path}main{suffix}.js\\\"></script>\\\n     {static_extra_scripts}\\\n     {extra_scripts}\\"}, {"sha": "c129e54c0f28ae3e92f5748c073ce6aa569fc9fe", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -44,7 +44,7 @@ use pulldown_cmark::{html, CodeBlockKind, CowStr, Event, Options, Parser, Tag};\n mod tests;\n \n fn opts() -> Options {\n-    Options::ENABLE_TABLES | Options::ENABLE_FOOTNOTES\n+    Options::ENABLE_TABLES | Options::ENABLE_FOOTNOTES | Options::ENABLE_STRIKETHROUGH\n }\n \n /// When `to_string` is called, this struct will emit the HTML corresponding to\n@@ -933,7 +933,11 @@ impl MarkdownSummaryLine<'_> {\n             }\n         };\n \n-        let p = Parser::new_with_broken_link_callback(md, Options::empty(), Some(&replacer));\n+        let p = Parser::new_with_broken_link_callback(\n+            md,\n+            Options::ENABLE_STRIKETHROUGH,\n+            Some(&replacer),\n+        );\n \n         let mut s = String::new();\n \n@@ -975,7 +979,11 @@ pub fn plain_summary_line(md: &str) -> String {\n         }\n     }\n     let mut s = String::with_capacity(md.len() * 3 / 2);\n-    let p = ParserWrapper { inner: Parser::new(md), is_in: 0, is_first: true };\n+    let p = ParserWrapper {\n+        inner: Parser::new_ext(md, Options::ENABLE_STRIKETHROUGH),\n+        is_in: 0,\n+        is_first: true,\n+    };\n     p.filter(|t| !t.is_empty()).for_each(|i| s.push_str(&i));\n     s\n }"}, {"sha": "646c663ad9ccd737e91e368ef9c7d12a7b3f3144", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 12, "deletions": 41, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -293,7 +293,12 @@ impl Serialize for IndexItem {\n     where\n         S: Serializer,\n     {\n-        assert_eq!(self.parent.is_some(), self.parent_idx.is_some());\n+        assert_eq!(\n+            self.parent.is_some(),\n+            self.parent_idx.is_some(),\n+            \"`{}` is missing idx\",\n+            self.name\n+        );\n \n         (self.ty, &self.name, &self.path, &self.desc, self.parent_idx, &self.search_type)\n             .serialize(serializer)\n@@ -796,7 +801,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n         if path.exists() {\n             for line in BufReader::new(File::open(path)?).lines() {\n                 let line = line?;\n-                if !line.starts_with(\"\\\"\") {\n+                if !line.starts_with('\"') {\n                     continue;\n                 }\n                 if line.starts_with(&format!(\"\\\"{}\\\"\", krate)) {\n@@ -810,8 +815,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n                 }\n                 krates.push(\n                     line.split('\"')\n-                        .filter(|s| !s.is_empty())\n-                        .next()\n+                        .find(|s| !s.is_empty())\n                         .map(|s| s.to_owned())\n                         .unwrap_or_else(String::new),\n                 );\n@@ -820,42 +824,6 @@ themePicker.onblur = handleThemeButtonsBlur;\n         Ok((ret, krates))\n     }\n \n-    fn show_item(item: &IndexItem, krate: &str) -> String {\n-        format!(\n-            \"{{'crate':'{}','ty':{},'name':'{}','desc':'{}','p':'{}'{}}}\",\n-            krate,\n-            item.ty as usize,\n-            item.name,\n-            item.desc.replace(\"'\", \"\\\\'\"),\n-            item.path,\n-            if let Some(p) = item.parent_idx { format!(\",'parent':{}\", p) } else { String::new() }\n-        )\n-    }\n-\n-    let dst = cx.dst.join(&format!(\"aliases{}.js\", cx.shared.resource_suffix));\n-    {\n-        let (mut all_aliases, _) = try_err!(collect(&dst, &krate.name, \"ALIASES\"), &dst);\n-        let mut output = String::with_capacity(100);\n-        for (alias, items) in &cx.cache.aliases {\n-            if items.is_empty() {\n-                continue;\n-            }\n-            output.push_str(&format!(\n-                \"\\\"{}\\\":[{}],\",\n-                alias,\n-                items.iter().map(|v| show_item(v, &krate.name)).collect::<Vec<_>>().join(\",\")\n-            ));\n-        }\n-        all_aliases.push(format!(\"ALIASES[\\\"{}\\\"] = {{{}}};\", krate.name, output));\n-        all_aliases.sort();\n-        let mut v = Buffer::html();\n-        writeln!(&mut v, \"var ALIASES = {{}};\");\n-        for aliases in &all_aliases {\n-            writeln!(&mut v, \"{}\", aliases);\n-        }\n-        cx.shared.fs.write(&dst, v.into_inner().into_bytes())?;\n-    }\n-\n     use std::ffi::OsString;\n \n     #[derive(Debug)]\n@@ -2281,7 +2249,10 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n             );\n             message.push_str(&format!(\": {}\", html.to_string()));\n         }\n-        stability.push(format!(\"<div class='stab deprecated'>{}</div>\", message));\n+        stability.push(format!(\n+            \"<div class='stab deprecated'><span class='emoji'>\ud83d\udc4e</span> {}</div>\",\n+            message,\n+        ));\n     }\n \n     if let Some(stab) = item.stability.as_ref().filter(|stab| stab.level == stability::Unstable) {"}, {"sha": "57d385de32096d88e11c5682a94ffe6213b05716", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 24, "deletions": 40, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -120,7 +120,7 @@ crate struct Cache {\n \n     /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n     /// we need the alias element to have an array of items.\n-    pub(super) aliases: FxHashMap<String, Vec<IndexItem>>,\n+    pub(super) aliases: BTreeMap<String, Vec<usize>>,\n }\n \n impl Cache {\n@@ -311,7 +311,7 @@ impl DocFolder for Cache {\n             };\n \n             match parent {\n-                (parent, Some(path)) if is_inherent_impl_item || (!self.stripped_mod) => {\n+                (parent, Some(path)) if is_inherent_impl_item || !self.stripped_mod => {\n                     debug_assert!(!item.is_stripped());\n \n                     // A crate has a module at its root, containing all items,\n@@ -327,6 +327,13 @@ impl DocFolder for Cache {\n                             parent_idx: None,\n                             search_type: get_index_search_type(&item),\n                         });\n+\n+                        for alias in item.attrs.get_doc_aliases() {\n+                            self.aliases\n+                                .entry(alias.to_lowercase())\n+                                .or_insert(Vec::new())\n+                                .push(self.search_index.len() - 1);\n+                        }\n                     }\n                 }\n                 (Some(parent), None) if is_inherent_impl_item => {\n@@ -376,11 +383,8 @@ impl DocFolder for Cache {\n                 {\n                     self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n                 }\n-                self.add_aliases(&item);\n             }\n-\n             clean::PrimitiveItem(..) => {\n-                self.add_aliases(&item);\n                 self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n             }\n \n@@ -488,40 +492,6 @@ impl DocFolder for Cache {\n     }\n }\n \n-impl Cache {\n-    fn add_aliases(&mut self, item: &clean::Item) {\n-        if item.def_id.index == CRATE_DEF_INDEX {\n-            return;\n-        }\n-        if let Some(ref item_name) = item.name {\n-            let path = self\n-                .paths\n-                .get(&item.def_id)\n-                .map(|p| p.0[..p.0.len() - 1].join(\"::\"))\n-                .unwrap_or(\"std\".to_owned());\n-            for alias in item\n-                .attrs\n-                .lists(sym::doc)\n-                .filter(|a| a.check_name(sym::alias))\n-                .filter_map(|a| a.value_str().map(|s| s.to_string().replace(\"\\\"\", \"\")))\n-                .filter(|v| !v.is_empty())\n-                .collect::<FxHashSet<_>>()\n-                .into_iter()\n-            {\n-                self.aliases.entry(alias).or_insert(Vec::with_capacity(1)).push(IndexItem {\n-                    ty: item.type_(),\n-                    name: item_name.to_string(),\n-                    path: path.clone(),\n-                    desc: shorten(plain_summary_line(item.doc_value())),\n-                    parent: None,\n-                    parent_idx: None,\n-                    search_type: get_index_search_type(&item),\n-                });\n-            }\n-        }\n-    }\n-}\n-\n /// Attempts to find where an external crate is located, given that we're\n /// rendering in to the specified source destination.\n fn extern_location(\n@@ -567,7 +537,8 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     let mut crate_items = Vec::with_capacity(cache.search_index.len());\n     let mut crate_paths = vec![];\n \n-    let Cache { ref mut search_index, ref orphan_impl_items, ref paths, .. } = *cache;\n+    let Cache { ref mut search_index, ref orphan_impl_items, ref paths, ref mut aliases, .. } =\n+        *cache;\n \n     // Attach all orphan items to the type's definition if the type\n     // has since been learned.\n@@ -582,6 +553,12 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n                 parent_idx: None,\n                 search_type: get_index_search_type(&item),\n             });\n+            for alias in item.attrs.get_doc_aliases() {\n+                aliases\n+                    .entry(alias.to_lowercase())\n+                    .or_insert(Vec::new())\n+                    .push(search_index.len() - 1);\n+            }\n         }\n     }\n \n@@ -630,6 +607,12 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n         items: Vec<&'a IndexItem>,\n         #[serde(rename = \"p\")]\n         paths: Vec<(ItemType, String)>,\n+        // The String is alias name and the vec is the list of the elements with this alias.\n+        //\n+        // To be noted: the `usize` elements are indexes to `items`.\n+        #[serde(rename = \"a\")]\n+        #[serde(skip_serializing_if = \"BTreeMap::is_empty\")]\n+        aliases: &'a BTreeMap<String, Vec<usize>>,\n     }\n \n     // Collect the index into a string\n@@ -640,6 +623,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n             doc: crate_doc,\n             items: crate_items,\n             paths: crate_paths,\n+            aliases,\n         })\n         .expect(\"failed serde conversion\")\n         // All these `replace` calls are because we have to go through JS string for JSON content."}, {"sha": "9b498d66249e2fde35175429162a10f83da2690f", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 110, "deletions": 26, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -531,6 +531,7 @@ function getSearchElement() {\n         var OUTPUT_DATA = 1;\n         var NO_TYPE_FILTER = -1;\n         var currentResults, index, searchIndex;\n+        var ALIASES = {};\n         var params = getQueryStringParams();\n \n         // Populate search bar with query string search term when provided,\n@@ -963,6 +964,72 @@ function getSearchElement() {\n                 return itemTypes[ty.ty] + ty.path + ty.name;\n             }\n \n+            function createAliasFromItem(item) {\n+                return {\n+                    crate: item.crate,\n+                    name: item.name,\n+                    path: item.path,\n+                    desc: item.desc,\n+                    ty: item.ty,\n+                    parent: item.parent,\n+                    type: item.type,\n+                    is_alias: true,\n+                };\n+            }\n+\n+            function handleAliases(ret, query, filterCrates) {\n+                // We separate aliases and crate aliases because we want to have current crate\n+                // aliases to be before the others in the displayed results.\n+                var aliases = [];\n+                var crateAliases = [];\n+                var i;\n+                if (filterCrates !== undefined &&\n+                        ALIASES[filterCrates] &&\n+                        ALIASES[filterCrates][query.search]) {\n+                    for (i = 0; i < ALIASES[crate][query.search].length; ++i) {\n+                        aliases.push(\n+                            createAliasFromItem(searchIndex[ALIASES[filterCrates][query.search]]));\n+                    }\n+                } else {\n+                    Object.keys(ALIASES).forEach(function(crate) {\n+                        if (ALIASES[crate][query.search]) {\n+                            var pushTo = crate === window.currentCrate ? crateAliases : aliases;\n+                            for (i = 0; i < ALIASES[crate][query.search].length; ++i) {\n+                                pushTo.push(\n+                                    createAliasFromItem(\n+                                        searchIndex[ALIASES[crate][query.search][i]]));\n+                            }\n+                        }\n+                    });\n+                }\n+\n+                var sortFunc = function(aaa, bbb) {\n+                    if (aaa.path < bbb.path) {\n+                        return 1;\n+                    } else if (aaa.path === bbb.path) {\n+                        return 0;\n+                    }\n+                    return -1;\n+                };\n+                crateAliases.sort(sortFunc);\n+                aliases.sort(sortFunc);\n+\n+                var pushFunc = function(alias) {\n+                    alias.alias = query.raw;\n+                    var res = buildHrefAndPath(alias);\n+                    alias.displayPath = pathSplitter(res[0]);\n+                    alias.fullPath = alias.displayPath + alias.name;\n+                    alias.href = res[1];\n+\n+                    ret.others.unshift(alias);\n+                    if (ret.others.length > MAX_RESULTS) {\n+                        ret.others.pop();\n+                    }\n+                };\n+                onEach(aliases, pushFunc);\n+                onEach(crateAliases, pushFunc);\n+            }\n+\n             // quoted values mean literal search\n             var nSearchWords = searchWords.length;\n             var i;\n@@ -1190,23 +1257,7 @@ function getSearchElement() {\n                 \"returned\": sortResults(results_returned, true),\n                 \"others\": sortResults(results),\n             };\n-            if (ALIASES && ALIASES[window.currentCrate] &&\n-                    ALIASES[window.currentCrate][query.raw]) {\n-                var aliases = ALIASES[window.currentCrate][query.raw];\n-                for (i = 0; i < aliases.length; ++i) {\n-                    aliases[i].is_alias = true;\n-                    aliases[i].alias = query.raw;\n-                    aliases[i].path = aliases[i].p;\n-                    var res = buildHrefAndPath(aliases[i]);\n-                    aliases[i].displayPath = pathSplitter(res[0]);\n-                    aliases[i].fullPath = aliases[i].displayPath + aliases[i].name;\n-                    aliases[i].href = res[1];\n-                    ret.others.unshift(aliases[i]);\n-                    if (ret.others.length > MAX_RESULTS) {\n-                        ret.others.pop();\n-                    }\n-                }\n-            }\n+            handleAliases(ret, query, filterCrates);\n             return ret;\n         }\n \n@@ -1599,13 +1650,12 @@ function getSearchElement() {\n                     \"returned\": mergeArrays(results.returned),\n                     \"others\": mergeArrays(results.others),\n                 };\n-            } else {\n-                return {\n-                    \"in_args\": results.in_args[0],\n-                    \"returned\": results.returned[0],\n-                    \"others\": results.others[0],\n-                };\n             }\n+            return {\n+                \"in_args\": results.in_args[0],\n+                \"returned\": results.returned[0],\n+                \"others\": results.others[0],\n+            };\n         }\n \n         function getFilterCrates() {\n@@ -1656,10 +1706,13 @@ function getSearchElement() {\n             searchIndex = [];\n             var searchWords = [];\n             var i;\n+            var currentIndex = 0;\n \n             for (var crate in rawSearchIndex) {\n                 if (!rawSearchIndex.hasOwnProperty(crate)) { continue; }\n \n+                var crateSize = 0;\n+\n                 searchWords.push(crate);\n                 searchIndex.push({\n                     crate: crate,\n@@ -1669,6 +1722,7 @@ function getSearchElement() {\n                     desc: rawSearchIndex[crate].doc,\n                     type: null,\n                 });\n+                currentIndex += 1;\n \n                 // an array of [(Number) item type,\n                 //              (String) name,\n@@ -1680,6 +1734,9 @@ function getSearchElement() {\n                 // an array of [(Number) item type,\n                 //              (String) name]\n                 var paths = rawSearchIndex[crate].p;\n+                // a array of [(String) alias name\n+                //             [Number] index to items]\n+                var aliases = rawSearchIndex[crate].a;\n \n                 // convert `rawPaths` entries into object form\n                 var len = paths.length;\n@@ -1698,9 +1755,18 @@ function getSearchElement() {\n                 var lastPath = \"\";\n                 for (i = 0; i < len; ++i) {\n                     var rawRow = items[i];\n-                    var row = {crate: crate, ty: rawRow[0], name: rawRow[1],\n-                               path: rawRow[2] || lastPath, desc: rawRow[3],\n-                               parent: paths[rawRow[4]], type: rawRow[5]};\n+                    if (!rawRow[2]) {\n+                        rawRow[2] = lastPath;\n+                    }\n+                    var row = {\n+                        crate: crate,\n+                        ty: rawRow[0],\n+                        name: rawRow[1],\n+                        path: rawRow[2],\n+                        desc: rawRow[3],\n+                        parent: paths[rawRow[4]],\n+                        type: rawRow[5],\n+                    };\n                     searchIndex.push(row);\n                     if (typeof row.name === \"string\") {\n                         var word = row.name.toLowerCase();\n@@ -1709,7 +1775,25 @@ function getSearchElement() {\n                         searchWords.push(\"\");\n                     }\n                     lastPath = row.path;\n+                    crateSize += 1;\n+                }\n+\n+                if (aliases) {\n+                    ALIASES[crate] = {};\n+                    var j, local_aliases;\n+                    for (var alias_name in aliases) {\n+                        if (!aliases.hasOwnProperty(alias_name)) { continue; }\n+\n+                        if (!ALIASES[crate].hasOwnProperty(alias_name)) {\n+                            ALIASES[crate][alias_name] = [];\n+                        }\n+                        local_aliases = aliases[alias_name];\n+                        for (j = 0; j < local_aliases.length; ++j) {\n+                            ALIASES[crate][alias_name].push(local_aliases[j] + currentIndex);\n+                        }\n+                    }\n                 }\n+                currentIndex += crateSize;\n             }\n             return searchWords;\n         }"}, {"sha": "a3ef350a0487e7ab4060cb0e1499873390e1ab6a", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 55, "deletions": 11, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -12,7 +12,8 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::ty;\n use rustc_resolve::ParentScope;\n use rustc_session::lint;\n-use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::symbol::Ident;\n+use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n \n use std::ops::Range;\n@@ -130,6 +131,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         current_item: &Option<String>,\n         parent_id: Option<hir::HirId>,\n         extra_fragment: &Option<String>,\n+        item_opt: Option<&Item>,\n     ) -> Result<(Res, Option<String>), ErrorKind> {\n         let cx = self.cx;\n \n@@ -230,16 +232,44 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::TyAlias,\n                     did,\n                 ) => {\n-                    let item = cx\n-                        .tcx\n-                        .inherent_impls(did)\n-                        .iter()\n-                        .flat_map(|imp| cx.tcx.associated_items(*imp).in_definition_order())\n-                        .find(|item| item.ident.name == item_name);\n+                    // We need item's parent to know if it's\n+                    // trait impl or struct/enum/etc impl\n+                    let item_parent = item_opt\n+                        .and_then(|item| self.cx.as_local_hir_id(item.def_id))\n+                        .and_then(|item_hir| {\n+                            let parent_hir = self.cx.tcx.hir().get_parent_item(item_hir);\n+                            self.cx.tcx.hir().find(parent_hir)\n+                        });\n+                    let item = match item_parent {\n+                        Some(hir::Node::Item(hir::Item {\n+                            kind: hir::ItemKind::Impl { of_trait: Some(_), self_ty, .. },\n+                            ..\n+                        })) => {\n+                            // trait impl\n+                            cx.tcx\n+                                .associated_item_def_ids(self_ty.hir_id.owner)\n+                                .iter()\n+                                .map(|child| {\n+                                    let associated_item = cx.tcx.associated_item(*child);\n+                                    associated_item\n+                                })\n+                                .find(|child| child.ident.name == item_name)\n+                        }\n+                        _ => {\n+                            // struct/enum/etc. impl\n+                            cx.tcx\n+                                .inherent_impls(did)\n+                                .iter()\n+                                .flat_map(|imp| cx.tcx.associated_items(*imp).in_definition_order())\n+                                .find(|item| item.ident.name == item_name)\n+                        }\n+                    };\n+\n                     if let Some(item) = item {\n                         let out = match item.kind {\n                             ty::AssocKind::Fn if ns == ValueNS => \"method\",\n                             ty::AssocKind::Const if ns == ValueNS => \"associatedconstant\",\n+                            ty::AssocKind::Type if ns == ValueNS => \"associatedtype\",\n                             _ => return self.variant_field(path_str, current_item, module_id),\n                         };\n                         if extra_fragment.is_some() {\n@@ -484,8 +514,14 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n                 match kind {\n                     Some(ns @ ValueNS) => {\n-                        match self.resolve(path_str, ns, &current_item, base_node, &extra_fragment)\n-                        {\n+                        match self.resolve(\n+                            path_str,\n+                            ns,\n+                            &current_item,\n+                            base_node,\n+                            &extra_fragment,\n+                            None,\n+                        ) {\n                             Ok(res) => res,\n                             Err(ErrorKind::ResolutionFailure) => {\n                                 resolution_failure(cx, &item, path_str, &dox, link_range);\n@@ -501,8 +537,14 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         }\n                     }\n                     Some(ns @ TypeNS) => {\n-                        match self.resolve(path_str, ns, &current_item, base_node, &extra_fragment)\n-                        {\n+                        match self.resolve(\n+                            path_str,\n+                            ns,\n+                            &current_item,\n+                            base_node,\n+                            &extra_fragment,\n+                            None,\n+                        ) {\n                             Ok(res) => res,\n                             Err(ErrorKind::ResolutionFailure) => {\n                                 resolution_failure(cx, &item, path_str, &dox, link_range);\n@@ -526,6 +568,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                 &current_item,\n                                 base_node,\n                                 &extra_fragment,\n+                                None,\n                             ) {\n                                 Err(ErrorKind::AnchorFailure(msg)) => {\n                                     anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n@@ -539,6 +582,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                 &current_item,\n                                 base_node,\n                                 &extra_fragment,\n+                                Some(&item),\n                             ) {\n                                 Err(ErrorKind::AnchorFailure(msg)) => {\n                                     anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);"}, {"sha": "a00c9a0bcea65d7118eb1366811f2e558e7a1b67", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -255,8 +255,7 @@ fn run_test(\n \n     let rustc_binary = options\n         .test_builder\n-        .as_ref()\n-        .map(|v| &**v)\n+        .as_deref()\n         .unwrap_or_else(|| rustc_interface::util::rustc_path().expect(\"found rustc\"));\n     let mut compiler = Command::new(&rustc_binary);\n     compiler.arg(\"--crate-type\").arg(\"bin\");"}, {"sha": "7261d631a6f31674626da5f4d795e1c042391fb6", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -10,7 +10,7 @@ Core encoding and decoding interfaces.\n     test(attr(allow(unused_variables), deny(warnings)))\n )]\n #![feature(box_syntax)]\n-#![feature(specialization)]\n+#![feature(specialization)] // FIXME: min_specialization does not work\n #![feature(never_type)]\n #![feature(nll)]\n #![feature(associated_type_bounds)]"}, {"sha": "56cf9be339194e75fe8d09719e03784b66750754", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -251,6 +251,9 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n     ///\n+    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n+    /// the HashMap to be useful, see its documentation for details.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -261,6 +264,8 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// let mut map = HashMap::with_hasher(s);\n     /// map.insert(1, 2);\n     /// ```\n+    ///\n+    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_hasher(hash_builder: S) -> HashMap<K, V, S> {\n@@ -278,6 +283,9 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n     ///\n+    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n+    /// the HashMap to be useful, see its documentation for details.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -288,6 +296,8 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// let mut map = HashMap::with_capacity_and_hasher(10, s);\n     /// map.insert(1, 2);\n     /// ```\n+    ///\n+    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> HashMap<K, V, S> {"}, {"sha": "ca06457291cae7e282f800df8fb14e3faec74984", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -273,6 +273,9 @@ impl<T, S> HashSet<T, S> {\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n     ///\n+    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n+    /// the HashMap to be useful, see its documentation for details.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -283,6 +286,8 @@ impl<T, S> HashSet<T, S> {\n     /// let mut set = HashSet::with_hasher(s);\n     /// set.insert(2);\n     /// ```\n+    ///\n+    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_hasher(hasher: S) -> HashSet<T, S> {\n@@ -300,6 +305,9 @@ impl<T, S> HashSet<T, S> {\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n     ///\n+    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n+    /// the HashMap to be useful, see its documentation for details.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -310,6 +318,8 @@ impl<T, S> HashSet<T, S> {\n     /// let mut set = HashSet::with_capacity_and_hasher(10, s);\n     /// set.insert(1);\n     /// ```\n+    ///\n+    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> HashSet<T, S> {"}, {"sha": "7a05aaf71f2c1d670c91f53fef48a13dc8208187", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -4,6 +4,7 @@ use crate::fmt;\n use crate::hash::{Hash, Hasher};\n use crate::ops;\n use crate::rc::Rc;\n+use crate::str::FromStr;\n use crate::sync::Arc;\n \n use crate::sys::os_str::{Buf, Slice};\n@@ -1174,6 +1175,15 @@ impl AsInner<Slice> for OsStr {\n     }\n }\n \n+#[stable(feature = \"osstring_from_str\", since = \"1.45.0\")]\n+impl FromStr for OsString {\n+    type Err = core::convert::Infallible;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        Ok(OsString::from(s))\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "bf381896a22bbe7bf22519c7136dc42998479fe0", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -332,7 +332,10 @@ pub fn panicking() -> bool {\n #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n pub fn begin_panic_fmt(msg: &fmt::Arguments<'_>) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n-        unsafe { intrinsics::abort() }\n+        #[cfg_attr(not(bootstrap), allow(unused_unsafe))] // remove `unsafe` on bootstrap bump\n+        unsafe {\n+            intrinsics::abort()\n+        }\n     }\n \n     let info = PanicInfo::internal_constructor(Some(msg), Location::caller());\n@@ -398,7 +401,10 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n #[track_caller]\n pub fn begin_panic<M: Any + Send>(msg: M) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n-        unsafe { intrinsics::abort() }\n+        #[cfg_attr(not(bootstrap), allow(unused_unsafe))] // remove `unsafe` on bootstrap bump\n+        unsafe {\n+            intrinsics::abort()\n+        }\n     }\n \n     rust_panic_with_hook(&mut PanicPayload::new(msg), None, Location::caller());\n@@ -458,7 +464,10 @@ fn rust_panic_with_hook(\n             \"thread panicked while processing \\\n                                        panic. aborting.\\n\"\n         ));\n-        unsafe { intrinsics::abort() }\n+        #[cfg_attr(not(bootstrap), allow(unused_unsafe))] // remove `unsafe` on bootstrap bump\n+        unsafe {\n+            intrinsics::abort()\n+        }\n     }\n \n     unsafe {\n@@ -493,7 +502,10 @@ fn rust_panic_with_hook(\n             \"thread panicked while panicking. \\\n                                        aborting.\\n\"\n         ));\n-        unsafe { intrinsics::abort() }\n+        #[cfg_attr(not(bootstrap), allow(unused_unsafe))] // remove `unsafe` on bootstrap bump\n+        unsafe {\n+            intrinsics::abort()\n+        }\n     }\n \n     rust_panic(payload)"}, {"sha": "8516e80f3b876630489ba7a2f39c8d6654f7ddee", "filename": "src/libstd/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -157,10 +157,10 @@ pub enum Prefix<'a> {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr,\n     ),\n \n-    /// Verbatim disk prefix, e.g., `\\\\?\\C:\\`.\n+    /// Verbatim disk prefix, e.g., `\\\\?\\C:`.\n     ///\n     /// Verbatim disk prefixes consist of `\\\\?\\` immediately followed by the\n-    /// drive letter and `:\\`.\n+    /// drive letter and `:`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     VerbatimDisk(#[stable(feature = \"rust1\", since = \"1.0.0\")] u8),\n "}, {"sha": "d1a46c517574315f32a2c9dd3d3ad8af9c369a07", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -354,6 +354,8 @@ impl<T> Packet<T> {\n \n         // See comments on Arc::clone() on why we do this (for `mem::forget`).\n         if old_count > MAX_REFCOUNT {\n+            // remove `unsafe` on bootstrap bump\n+            #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n             unsafe {\n                 abort();\n             }"}, {"sha": "603764922c5aad76f7d479e09fe9715c0a803950", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -358,6 +358,8 @@ impl<T> Packet<T> {\n \n         // See comments on Arc::clone() on why we do this (for `mem::forget`).\n         if old_count > MAX_REFCOUNT {\n+            // remove `unsafe` on bootstrap bump\n+            #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n             unsafe {\n                 abort();\n             }"}, {"sha": "3134a5967566ba846cc6a35d723ec7934fcc3991", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -737,6 +737,8 @@ pub fn panicking() -> bool {\n /// The thread may sleep longer than the duration specified due to scheduling\n /// specifics or platform-dependent functionality. It will never sleep less.\n ///\n+/// This function is blocking, and should not be used in `async` functions.\n+///\n /// # Platform-specific behavior\n ///\n /// On Unix platforms, the underlying syscall may be interrupted by a\n@@ -763,6 +765,8 @@ pub fn sleep_ms(ms: u32) {\n /// The thread may sleep longer than the duration specified due to scheduling\n /// specifics or platform-dependent functionality. It will never sleep less.\n ///\n+/// This function is blocking, and should not be used in `async` functions.\n+///\n /// # Platform-specific behavior\n ///\n /// On Unix platforms, the underlying syscall may be interrupted by a\n@@ -1272,7 +1276,7 @@ impl Thread {\n     }\n \n     fn cname(&self) -> Option<&CStr> {\n-        self.inner.name.as_ref().map(|s| &**s)\n+        self.inner.name.as_deref()\n     }\n }\n "}, {"sha": "0cec8050c279d9cc4afb7626e11166a569e94771", "filename": "src/libtest/cli.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibtest%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Flibtest%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fcli.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -331,7 +331,7 @@ fn get_format(\n     quiet: bool,\n     allow_unstable: bool,\n ) -> OptPartRes<OutputFormat> {\n-    let format = match matches.opt_str(\"format\").as_ref().map(|s| &**s) {\n+    let format = match matches.opt_str(\"format\").as_deref() {\n         None if quiet => OutputFormat::Terse,\n         Some(\"pretty\") | None => OutputFormat::Pretty,\n         Some(\"terse\") => OutputFormat::Terse,\n@@ -355,7 +355,7 @@ fn get_format(\n }\n \n fn get_color_config(matches: &getopts::Matches) -> OptPartRes<ColorConfig> {\n-    let color = match matches.opt_str(\"color\").as_ref().map(|s| &**s) {\n+    let color = match matches.opt_str(\"color\").as_deref() {\n         Some(\"auto\") | None => ColorConfig::AutoColor,\n         Some(\"always\") => ColorConfig::AlwaysColor,\n         Some(\"never\") => ColorConfig::NeverColor,"}, {"sha": "b17fa57c5c1efb15a3e47be5218cac2f58396832", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -717,7 +717,7 @@ LLVMRustOptimizeWithNewPassManager(\n     LLVMRustOptStage OptStage,\n     bool NoPrepopulatePasses, bool VerifyIR, bool UseThinLTOBuffers,\n     bool MergeFunctions, bool UnrollLoops, bool SLPVectorize, bool LoopVectorize,\n-    bool DisableSimplifyLibCalls,\n+    bool DisableSimplifyLibCalls, bool EmitLifetimeMarkers,\n     LLVMRustSanitizerOptions *SanitizerOptions,\n     const char *PGOGenPath, const char *PGOUsePath,\n     void* LlvmSelfProfiler,\n@@ -853,7 +853,7 @@ LLVMRustOptimizeWithNewPassManager(\n         MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n       }\n \n-      MPM.addPass(AlwaysInlinerPass(/*InsertLifetimeIntrinsics=*/false));\n+      MPM.addPass(AlwaysInlinerPass(EmitLifetimeMarkers));\n \n #if LLVM_VERSION_GE(10, 0)\n       if (PGOOpt) {"}, {"sha": "ec6fccd34c30003a7ebf4e7a9dfe4e31f5b76e1b", "filename": "src/stdarch", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstdarch?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1 +1 @@\n-Subproject commit d10eefc62284c40c5a95a2eed19fc1f414a5364d\n+Subproject commit ec6fccd34c30003a7ebf4e7a9dfe4e31f5b76e1b"}, {"sha": "f71a9c3c58216b119738d90c6977dc7bea28a158", "filename": "src/test/codegen/target-feature-multiple.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fcodegen%2Ftarget-feature-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fcodegen%2Ftarget-feature-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ftarget-feature-multiple.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,9 @@\n+// only-x86_64\n+// compile-flags: -C target-feature=+sse2,-avx,+avx2 -C target-feature=+avx,-avx2\n+\n+#![crate_type = \"lib\"]\n+\n+#[no_mangle]\n+pub fn foo() {\n+    // CHECK: attributes #0 = { {{.*}}\"target-features\"=\"+sse2,-avx,+avx2,+avx,-avx2\"{{.*}} }\n+}"}, {"sha": "0eaeb910be64a591cbe078a40d000fc8e2fb039a", "filename": "src/test/incremental/const-generics/issue-62536.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-62536.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-62536.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-62536.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,6 +1,6 @@\n // revisions:cfail1\n #![feature(const_generics)]\n-//[cfail1]~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+//[cfail1]~^ WARN the feature `const_generics` is incomplete\n \n struct S<T, const N: usize>([T; N]);\n "}, {"sha": "6b10c5404944d743beea80c609c93a775e8722c7", "filename": "src/test/incremental/const-generics/issue-64087.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-64087.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-64087.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-64087.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,6 +1,6 @@\n // revisions:cfail1\n #![feature(const_generics)]\n-//[cfail1]~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+//[cfail1]~^ WARN the feature `const_generics` is incomplete\n \n fn combinator<T, const S: usize>() -> [T; S] {}\n //[cfail1]~^ ERROR mismatched types"}, {"sha": "88cb09ac15a9cc030a6f4f602e58189605aad2a1", "filename": "src/test/mir-opt/byte_slice/rustc.main.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fbyte_slice%2Frustc.main.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fbyte_slice%2Frustc.main.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbyte_slice%2Frustc.main.SimplifyCfg-elaborate-drops.after.mir?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -16,10 +16,10 @@ fn main() -> () {\n         _1 = const b\"foo\";               // scope 0 at $DIR/byte_slice.rs:5:13: 5:19\n                                          // ty::Const\n                                          // + ty: &[u8; 3]\n-                                         // + val: Value(Scalar(alloc0+0x0))\n+                                         // + val: Value(Scalar(alloc0))\n                                          // mir::Constant\n                                          // + span: $DIR/byte_slice.rs:5:13: 5:19\n-                                         // + literal: Const { ty: &[u8; 3], val: Value(Scalar(alloc0+0x0)) }\n+                                         // + literal: Const { ty: &[u8; 3], val: Value(Scalar(alloc0)) }\n         StorageLive(_2);                 // scope 1 at $DIR/byte_slice.rs:6:9: 6:10\n         _2 = [const 5u8, const 120u8];   // scope 1 at $DIR/byte_slice.rs:6:13: 6:24\n                                          // ty::Const"}, {"sha": "509947071b0c1bb927378b100d544ad6c5a56591", "filename": "src/test/mir-opt/const-promotion-extern-static/rustc.BAR-promoted[0].ConstProp.after.mir", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.BAR-promoted%5B0%5D.ConstProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.BAR-promoted%5B0%5D.ConstProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.BAR-promoted%5B0%5D.ConstProp.after.mir?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -7,13 +7,13 @@ promoted[0] in BAR: &[&i32; 1] = {\n     let mut _3: &i32;                    // in scope 0 at $DIR/const-promotion-extern-static.rs:9:33: 9:34\n \n     bb0: {\n-        _3 = const {alloc0+0x0: &i32};   // scope 0 at $DIR/const-promotion-extern-static.rs:9:33: 9:34\n+        _3 = const {alloc0: &i32};       // scope 0 at $DIR/const-promotion-extern-static.rs:9:33: 9:34\n                                          // ty::Const\n                                          // + ty: &i32\n-                                         // + val: Value(Scalar(alloc0+0x0))\n+                                         // + val: Value(Scalar(alloc0))\n                                          // mir::Constant\n                                          // + span: $DIR/const-promotion-extern-static.rs:9:33: 9:34\n-                                         // + literal: Const { ty: &i32, val: Value(Scalar(alloc0+0x0)) }\n+                                         // + literal: Const { ty: &i32, val: Value(Scalar(alloc0)) }\n         _2 = _3;                         // scope 0 at $DIR/const-promotion-extern-static.rs:9:32: 9:34\n         _1 = [move _2];                  // scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n         _0 = &_1;                        // scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35"}, {"sha": "8eb8d4c667b1ceb1cedd6304cbf90e92cf70a85c", "filename": "src/test/mir-opt/const-promotion-extern-static/rustc.BAR.PromoteTemps.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.BAR.PromoteTemps.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.BAR.PromoteTemps.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.BAR.PromoteTemps.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -16,16 +16,16 @@\n -         StorageLive(_3);                 // scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n -         StorageLive(_4);                 // scope 0 at $DIR/const-promotion-extern-static.rs:9:32: 9:34\n -         StorageLive(_5);                 // scope 0 at $DIR/const-promotion-extern-static.rs:9:33: 9:34\n--         _5 = const {alloc0+0x0: &i32};   // scope 0 at $DIR/const-promotion-extern-static.rs:9:33: 9:34\n+-         _5 = const {alloc0: &i32};       // scope 0 at $DIR/const-promotion-extern-static.rs:9:33: 9:34\n +         _6 = const BAR::promoted[0];     // scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n                                            // ty::Const\n -                                          // + ty: &i32\n--                                          // + val: Value(Scalar(alloc0+0x0))\n+-                                          // + val: Value(Scalar(alloc0))\n +                                          // + ty: &[&i32; 1]\n +                                          // + val: Unevaluated(DefId(0:6 ~ const_promotion_extern_static[317d]::BAR[0]), [], Some(promoted[0]))\n                                            // mir::Constant\n -                                          // + span: $DIR/const-promotion-extern-static.rs:9:33: 9:34\n--                                          // + literal: Const { ty: &i32, val: Value(Scalar(alloc0+0x0)) }\n+-                                          // + literal: Const { ty: &i32, val: Value(Scalar(alloc0)) }\n -         _4 = &(*_5);                     // scope 0 at $DIR/const-promotion-extern-static.rs:9:32: 9:34\n -         _3 = [move _4];                  // scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n -         _2 = &_3;                        // scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35"}, {"sha": "d9c6b4f0029a34b6ed773ddb522531933d107799", "filename": "src/test/mir-opt/const-promotion-extern-static/rustc.FOO-promoted[0].ConstProp.after.mir", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.FOO-promoted%5B0%5D.ConstProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.FOO-promoted%5B0%5D.ConstProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.FOO-promoted%5B0%5D.ConstProp.after.mir?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -9,13 +9,13 @@ promoted[0] in FOO: &[&i32; 1] = {\n     }\n \n     bb0: {\n-        _3 = const {alloc2+0x0: &i32};   // scope 0 at $DIR/const-promotion-extern-static.rs:13:42: 13:43\n+        _3 = const {alloc2: &i32};       // scope 0 at $DIR/const-promotion-extern-static.rs:13:42: 13:43\n                                          // ty::Const\n                                          // + ty: &i32\n-                                         // + val: Value(Scalar(alloc2+0x0))\n+                                         // + val: Value(Scalar(alloc2))\n                                          // mir::Constant\n                                          // + span: $DIR/const-promotion-extern-static.rs:13:42: 13:43\n-                                         // + literal: Const { ty: &i32, val: Value(Scalar(alloc2+0x0)) }\n+                                         // + literal: Const { ty: &i32, val: Value(Scalar(alloc2)) }\n         _2 = _3;                         // scope 0 at $DIR/const-promotion-extern-static.rs:13:41: 13:43\n         _1 = [move _2];                  // scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n         _0 = &_1;                        // scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46"}, {"sha": "781aa3c5500c0b10273512eb60d253d6d4c1becc", "filename": "src/test/mir-opt/const-promotion-extern-static/rustc.FOO.PromoteTemps.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.FOO.PromoteTemps.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.FOO.PromoteTemps.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.FOO.PromoteTemps.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -18,16 +18,16 @@\n -         StorageLive(_3);                 // scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n -         StorageLive(_4);                 // scope 0 at $DIR/const-promotion-extern-static.rs:13:32: 13:45\n -         StorageLive(_5);                 // scope 1 at $DIR/const-promotion-extern-static.rs:13:42: 13:43\n--         _5 = const {alloc2+0x0: &i32};   // scope 1 at $DIR/const-promotion-extern-static.rs:13:42: 13:43\n+-         _5 = const {alloc2: &i32};       // scope 1 at $DIR/const-promotion-extern-static.rs:13:42: 13:43\n +         _6 = const FOO::promoted[0];     // scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n                                            // ty::Const\n -                                          // + ty: &i32\n--                                          // + val: Value(Scalar(alloc2+0x0))\n+-                                          // + val: Value(Scalar(alloc2))\n +                                          // + ty: &[&i32; 1]\n +                                          // + val: Unevaluated(DefId(0:7 ~ const_promotion_extern_static[317d]::FOO[0]), [], Some(promoted[0]))\n                                            // mir::Constant\n -                                          // + span: $DIR/const-promotion-extern-static.rs:13:42: 13:43\n--                                          // + literal: Const { ty: &i32, val: Value(Scalar(alloc2+0x0)) }\n+-                                          // + literal: Const { ty: &i32, val: Value(Scalar(alloc2)) }\n -         _4 = &(*_5);                     // scope 1 at $DIR/const-promotion-extern-static.rs:13:41: 13:43\n -         _3 = [move _4];                  // scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n -         _2 = &_3;                        // scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46"}, {"sha": "30a383fd162b2aa7fa52ca1340ff56f80422164b", "filename": "src/test/mir-opt/const_allocation/32bit/rustc.main.ConstProp.after.mir", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_allocation%2F32bit%2Frustc.main.ConstProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_allocation%2F32bit%2Frustc.main.ConstProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation%2F32bit%2Frustc.main.ConstProp.after.mir?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -8,13 +8,13 @@ fn main() -> () {\n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n         StorageLive(_2);                 // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n-        _2 = const {alloc0+0x0: &&[(std::option::Option<i32>, &[&str])]}; // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n+        _2 = const {alloc0: &&[(std::option::Option<i32>, &[&str])]}; // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n                                          // ty::Const\n                                          // + ty: &&[(std::option::Option<i32>, &[&str])]\n-                                         // + val: Value(Scalar(alloc0+0x0))\n+                                         // + val: Value(Scalar(alloc0))\n                                          // mir::Constant\n                                          // + span: $DIR/const_allocation.rs:8:5: 8:8\n-                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&str])], val: Value(Scalar(alloc0+0x0)) }\n+                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&str])], val: Value(Scalar(alloc0)) }\n         _1 = (*_2);                      // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n         StorageDead(_2);                 // scope 0 at $DIR/const_allocation.rs:8:8: 8:9\n         StorageDead(_1);                 // scope 0 at $DIR/const_allocation.rs:8:8: 8:9\n@@ -30,19 +30,19 @@ fn main() -> () {\n }\n \n alloc0 (static: FOO, size: 8, align: 4) {\n-    \u257e\u2500a17+0x0\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+    \u257e\u2500alloc17\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n alloc17 (size: 48, align: 4) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500a4+0x0\u2500\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500a8+0x0\u2500\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500a13+0x0\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc4\u2500\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc8\u2500\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc13\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n }\n \n alloc4 (size: 0, align: 4) {}\n \n alloc8 (size: 16, align: 4) {\n-    \u257e\u2500a7+0x0\u2500\u2500\u257c 03 00 00 00 \u257e\u2500a9+0x0\u2500\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n+    \u257e\u2500alloc7\u2500\u2500\u257c 03 00 00 00 \u257e\u2500alloc9\u2500\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n }\n \n alloc7 (size: 3, align: 1) {\n@@ -54,8 +54,8 @@ alloc9 (size: 3, align: 1) {\n }\n \n alloc13 (size: 24, align: 4) {\n-    0x00 \u2502 \u257e\u2500a12+0x0\u2500\u257c 03 00 00 00 \u257e\u2500a14+0x0\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 \u257e\u2500a15+0x0\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+    0x00 \u2502 \u257e\u2500alloc12\u2500\u257c 03 00 00 00 \u257e\u2500alloc14\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 \u257e\u2500alloc15\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n alloc12 (size: 3, align: 1) {"}, {"sha": "5fa54ae5a58ec6f5d20bf9fd546487314b0c0edc", "filename": "src/test/mir-opt/const_allocation/64bit/rustc.main.ConstProp.after.mir", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_allocation%2F64bit%2Frustc.main.ConstProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_allocation%2F64bit%2Frustc.main.ConstProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation%2F64bit%2Frustc.main.ConstProp.after.mir?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -8,13 +8,13 @@ fn main() -> () {\n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n         StorageLive(_2);                 // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n-        _2 = const {alloc0+0x0: &&[(std::option::Option<i32>, &[&str])]}; // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n+        _2 = const {alloc0: &&[(std::option::Option<i32>, &[&str])]}; // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n                                          // ty::Const\n                                          // + ty: &&[(std::option::Option<i32>, &[&str])]\n-                                         // + val: Value(Scalar(alloc0+0x0))\n+                                         // + val: Value(Scalar(alloc0))\n                                          // mir::Constant\n                                          // + span: $DIR/const_allocation.rs:8:5: 8:8\n-                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&str])], val: Value(Scalar(alloc0+0x0)) }\n+                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&str])], val: Value(Scalar(alloc0)) }\n         _1 = (*_2);                      // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n         StorageDead(_2);                 // scope 0 at $DIR/const_allocation.rs:8:8: 8:9\n         StorageDead(_1);                 // scope 0 at $DIR/const_allocation.rs:8:8: 8:9\n@@ -30,22 +30,22 @@ fn main() -> () {\n }\n \n alloc0 (static: FOO, size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500alloc17+0x0\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc17\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n alloc17 (size: 72, align: 8) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500alloc4+0x0\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 __ __ __ __ \u2502 ............\u2591\u2591\u2591\u2591\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc8+0x0\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500alloc13+0x0\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x40 \u2502 03 00 00 00 00 00 00 00                         \u2502 ........\n }\n \n alloc4 (size: 0, align: 8) {}\n \n alloc8 (size: 32, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc7+0x0\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc9+0x0\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc7\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n alloc7 (size: 3, align: 1) {\n@@ -57,9 +57,9 @@ alloc9 (size: 3, align: 1) {\n }\n \n alloc13 (size: 48, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc12+0x0\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc14+0x0\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc15+0x0\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc12\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc15\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n alloc12 (size: 3, align: 1) {"}, {"sha": "d386d2478292690ac72823e3546c006c97cdc29a", "filename": "src/test/mir-opt/const_allocation2/32bit/rustc.main.ConstProp.after.mir", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_allocation2%2F32bit%2Frustc.main.ConstProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_allocation2%2F32bit%2Frustc.main.ConstProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation2%2F32bit%2Frustc.main.ConstProp.after.mir?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -8,13 +8,13 @@ fn main() -> () {\n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n         StorageLive(_2);                 // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n-        _2 = const {alloc0+0x0: &&[(std::option::Option<i32>, &[&u8])]}; // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n+        _2 = const {alloc0: &&[(std::option::Option<i32>, &[&u8])]}; // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n                                          // ty::Const\n                                          // + ty: &&[(std::option::Option<i32>, &[&u8])]\n-                                         // + val: Value(Scalar(alloc0+0x0))\n+                                         // + val: Value(Scalar(alloc0))\n                                          // mir::Constant\n                                          // + span: $DIR/const_allocation2.rs:5:5: 5:8\n-                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&u8])], val: Value(Scalar(alloc0+0x0)) }\n+                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&u8])], val: Value(Scalar(alloc0)) }\n         _1 = (*_2);                      // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n         StorageDead(_2);                 // scope 0 at $DIR/const_allocation2.rs:5:8: 5:9\n         StorageDead(_1);                 // scope 0 at $DIR/const_allocation2.rs:5:8: 5:9\n@@ -30,19 +30,19 @@ fn main() -> () {\n }\n \n alloc0 (static: FOO, size: 8, align: 4) {\n-    \u257e\u2500a21+0x0\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+    \u257e\u2500alloc21\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n alloc21 (size: 48, align: 4) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500a4+0x0\u2500\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500a9+0x0\u2500\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500a19+0x0\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc4\u2500\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc9\u2500\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc19\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n }\n \n alloc4 (size: 0, align: 4) {}\n \n alloc9 (size: 8, align: 4) {\n-    \u257e\u2500a7+0x0\u2500\u2500\u257c \u257e\u2500a8+0x0\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+    \u257e\u2500alloc7\u2500\u2500\u257c \u257e\u2500alloc8\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n }\n \n alloc7 (size: 1, align: 1) {\n@@ -54,7 +54,7 @@ alloc8 (size: 1, align: 1) {\n }\n \n alloc19 (size: 12, align: 4) {\n-    \u257e\u2500a15+0x3\u2500\u257c \u257e\u2500a16+0x0\u2500\u257c \u257e\u2500a18+0x2\u2500\u257c             \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+    \u257e\u2500a15+0x3\u2500\u257c \u257e\u2500alloc16\u2500\u257c \u257e\u2500a18+0x2\u2500\u257c             \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n }\n \n alloc15 (size: 4, align: 1) {"}, {"sha": "d7acd0f0f4335a8e042af3b854f7f976f9976919", "filename": "src/test/mir-opt/const_allocation2/64bit/rustc.main.ConstProp.after.mir", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_allocation2%2F64bit%2Frustc.main.ConstProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_allocation2%2F64bit%2Frustc.main.ConstProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation2%2F64bit%2Frustc.main.ConstProp.after.mir?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -8,13 +8,13 @@ fn main() -> () {\n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n         StorageLive(_2);                 // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n-        _2 = const {alloc0+0x0: &&[(std::option::Option<i32>, &[&u8])]}; // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n+        _2 = const {alloc0: &&[(std::option::Option<i32>, &[&u8])]}; // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n                                          // ty::Const\n                                          // + ty: &&[(std::option::Option<i32>, &[&u8])]\n-                                         // + val: Value(Scalar(alloc0+0x0))\n+                                         // + val: Value(Scalar(alloc0))\n                                          // mir::Constant\n                                          // + span: $DIR/const_allocation2.rs:5:5: 5:8\n-                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&u8])], val: Value(Scalar(alloc0+0x0)) }\n+                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&u8])], val: Value(Scalar(alloc0)) }\n         _1 = (*_2);                      // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n         StorageDead(_2);                 // scope 0 at $DIR/const_allocation2.rs:5:8: 5:9\n         StorageDead(_1);                 // scope 0 at $DIR/const_allocation2.rs:5:8: 5:9\n@@ -30,21 +30,21 @@ fn main() -> () {\n }\n \n alloc0 (static: FOO, size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500alloc21+0x0\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc21\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n alloc21 (size: 72, align: 8) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500alloc4+0x0\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 __ __ __ __ \u2502 ............\u2591\u2591\u2591\u2591\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc9+0x0\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500alloc19+0x0\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc19\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x40 \u2502 03 00 00 00 00 00 00 00                         \u2502 ........\n }\n \n alloc4 (size: 0, align: 8) {}\n \n alloc9 (size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500alloc7+0x0\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500alloc8+0x0\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc7\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n alloc7 (size: 1, align: 1) {\n@@ -56,7 +56,7 @@ alloc8 (size: 1, align: 1) {\n }\n \n alloc19 (size: 24, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc15+0x3\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500alloc16+0x0\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc15+0x3\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc16\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc18+0x2\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n "}, {"sha": "39c60ad987a6f36fa5dc5f79a376a43a70b330e2", "filename": "src/test/mir-opt/const_allocation3/32bit/rustc.main.ConstProp.after.mir", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_allocation3%2F32bit%2Frustc.main.ConstProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_allocation3%2F32bit%2Frustc.main.ConstProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation3%2F32bit%2Frustc.main.ConstProp.after.mir?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -8,13 +8,13 @@ fn main() -> () {\n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n         StorageLive(_2);                 // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n-        _2 = const {alloc0+0x0: &&Packed}; // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n+        _2 = const {alloc0: &&Packed};   // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n                                          // ty::Const\n                                          // + ty: &&Packed\n-                                         // + val: Value(Scalar(alloc0+0x0))\n+                                         // + val: Value(Scalar(alloc0))\n                                          // mir::Constant\n                                          // + span: $DIR/const_allocation3.rs:5:5: 5:8\n-                                         // + literal: Const { ty: &&Packed, val: Value(Scalar(alloc0+0x0)) }\n+                                         // + literal: Const { ty: &&Packed, val: Value(Scalar(alloc0)) }\n         _1 = (*_2);                      // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n         StorageDead(_2);                 // scope 0 at $DIR/const_allocation3.rs:5:8: 5:9\n         StorageDead(_1);                 // scope 0 at $DIR/const_allocation3.rs:5:8: 5:9\n@@ -30,19 +30,19 @@ fn main() -> () {\n }\n \n alloc0 (static: FOO, size: 4, align: 4) {\n-    \u257e\u2500a9+0x0\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+    \u257e\u2500alloc9\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n }\n \n alloc9 (size: 168, align: 1) {\n     0x00 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab \u2502 ................\n-    0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500a4+0x0\u2500\u2500\u257c \u2502 ............\u257e\u2500\u2500\u257c\n+    0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500alloc4\u2500\u2500\u257c \u2502 ............\u257e\u2500\u2500\u257c\n     0x20 \u2502 01 ef cd ab 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x30 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x40 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x50 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x60 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x70 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n-    0x80 \u2502 00 00 00 00 00 00 00 00 00 00 \u257e\u2500a6+0x0\u2500\u2500\u257c 00 00 \u2502 ..........\u257e\u2500\u2500\u257c..\n+    0x80 \u2502 00 00 00 00 00 00 00 00 00 00 \u257e\u2500alloc6\u2500\u2500\u257c 00 00 \u2502 ..........\u257e\u2500\u2500\u257c..\n     0x90 \u2502 \u257e\u2500a7+0x63\u2500\u257c 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u257c............\n     0xa0 \u2502 00 00 00 00 00 00 00 00                         \u2502 ........\n }"}, {"sha": "96024f1c82caaa808186a880a9b2c8ad3a8b24e1", "filename": "src/test/mir-opt/const_allocation3/64bit/rustc.main.ConstProp.after.mir", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_allocation3%2F64bit%2Frustc.main.ConstProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_allocation3%2F64bit%2Frustc.main.ConstProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation3%2F64bit%2Frustc.main.ConstProp.after.mir?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -8,13 +8,13 @@ fn main() -> () {\n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n         StorageLive(_2);                 // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n-        _2 = const {alloc0+0x0: &&Packed}; // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n+        _2 = const {alloc0: &&Packed};   // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n                                          // ty::Const\n                                          // + ty: &&Packed\n-                                         // + val: Value(Scalar(alloc0+0x0))\n+                                         // + val: Value(Scalar(alloc0))\n                                          // mir::Constant\n                                          // + span: $DIR/const_allocation3.rs:5:5: 5:8\n-                                         // + literal: Const { ty: &&Packed, val: Value(Scalar(alloc0+0x0)) }\n+                                         // + literal: Const { ty: &&Packed, val: Value(Scalar(alloc0)) }\n         _1 = (*_2);                      // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n         StorageDead(_2);                 // scope 0 at $DIR/const_allocation3.rs:5:8: 5:9\n         StorageDead(_1);                 // scope 0 at $DIR/const_allocation3.rs:5:8: 5:9\n@@ -30,20 +30,20 @@ fn main() -> () {\n }\n \n alloc0 (static: FOO, size: 8, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500alloc9+0x0\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n alloc9 (size: 180, align: 1) {\n     0x00 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab \u2502 ................\n-    0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257ealloc4+0x0 \u2502 ............\u257e\u2500\u2500\u2500\n+    0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500\u2500alloc4\u2500\u2500 \u2502 ............\u257e\u2500\u2500\u2500\n     0x20 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 ef cd ab 00 00 00 00 00 00 00 00 \u2502 \u2500\u2500\u2500\u257c............\n     0x30 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x40 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x50 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x60 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x70 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x80 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u257e\u2500\u2500\u2500\u2500 \u2502 ..............\u257e\u2500\n-    0x90 \u2502 \u2500\u2500\u2500alloc6+0x0\u2500\u2500\u2500\u257c 00 00 \u257e\u2500\u2500\u2500\u2500\u2500alloc7+0x63\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u2500\u2500\u2500\u2500\u2500\u257c..\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x90 \u2502 \u2500\u2500\u2500\u2500\u2500alloc6\u2500\u2500\u2500\u2500\u2500\u257c 00 00 \u257e\u2500\u2500\u2500\u2500\u2500alloc7+0x63\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u2500\u2500\u2500\u2500\u2500\u257c..\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0xa0 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0xb0 \u2502 00 00 00 00                                     \u2502 ....\n }"}, {"sha": "b3a2d80fa950a371b8d22c6523c1c4c535c34274", "filename": "src/test/mir-opt/const_prop/mutable_variable.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,8 @@\n+// compile-flags: -O\n+\n+// EMIT_MIR rustc.main.ConstProp.diff\n+fn main() {\n+    let mut x = 42;\n+    x = 99;\n+    let y = x;\n+}"}, {"sha": "187c17454350a05668096496171bd5bcae2bf381", "filename": "src/test/mir-opt/const_prop/mutable_variable/rustc.main.ConstProp.diff", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable%2Frustc.main.ConstProp.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,52 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/mutable_variable.rs:4:11: 4:11\n+      let mut _1: i32;                     // in scope 0 at $DIR/mutable_variable.rs:5:9: 5:14\n+      scope 1 {\n+          debug x => _1;                   // in scope 1 at $DIR/mutable_variable.rs:5:9: 5:14\n+          let _2: i32;                     // in scope 1 at $DIR/mutable_variable.rs:7:9: 7:10\n+          scope 2 {\n+              debug y => _2;               // in scope 2 at $DIR/mutable_variable.rs:7:9: 7:10\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/mutable_variable.rs:5:9: 5:14\n+          _1 = const 42i32;                // scope 0 at $DIR/mutable_variable.rs:5:17: 5:19\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x0000002a))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable.rs:5:17: 5:19\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x0000002a)) }\n+          _1 = const 99i32;                // scope 1 at $DIR/mutable_variable.rs:6:5: 6:11\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000063))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable.rs:6:9: 6:11\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000063)) }\n+          StorageLive(_2);                 // scope 1 at $DIR/mutable_variable.rs:7:9: 7:10\n+-         _2 = _1;                         // scope 1 at $DIR/mutable_variable.rs:7:13: 7:14\n++         _2 = const 99i32;                // scope 1 at $DIR/mutable_variable.rs:7:13: 7:14\n++                                          // ty::Const\n++                                          // + ty: i32\n++                                          // + val: Value(Scalar(0x00000063))\n++                                          // mir::Constant\n++                                          // + span: $DIR/mutable_variable.rs:7:13: 7:14\n++                                          // + literal: Const { ty: i32, val: Value(Scalar(0x00000063)) }\n+          _0 = const ();                   // scope 0 at $DIR/mutable_variable.rs:4:11: 8:2\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable.rs:4:11: 8:2\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_2);                 // scope 1 at $DIR/mutable_variable.rs:8:1: 8:2\n+          StorageDead(_1);                 // scope 0 at $DIR/mutable_variable.rs:8:1: 8:2\n+          return;                          // scope 0 at $DIR/mutable_variable.rs:8:2: 8:2\n+      }\n+  }\n+  "}, {"sha": "3c5fb4574b61f2f82af7a8fca8b57f223919f4d3", "filename": "src/test/mir-opt/const_prop/mutable_variable_aggregate.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,8 @@\n+// compile-flags: -O\n+\n+// EMIT_MIR rustc.main.ConstProp.diff\n+fn main() {\n+    let mut x = (42, 43);\n+    x.1 = 99;\n+    let y = x;\n+}"}, {"sha": "cf432b2acc1c5c86be05afc7f964aad2587b328d", "filename": "src/test/mir-opt/const_prop/mutable_variable_aggregate/rustc.main.ConstProp.diff", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate%2Frustc.main.ConstProp.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,66 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/mutable_variable_aggregate.rs:4:11: 4:11\n+      let mut _1: (i32, i32);              // in scope 0 at $DIR/mutable_variable_aggregate.rs:5:9: 5:14\n+      scope 1 {\n+          debug x => _1;                   // in scope 1 at $DIR/mutable_variable_aggregate.rs:5:9: 5:14\n+          let _2: (i32, i32);              // in scope 1 at $DIR/mutable_variable_aggregate.rs:7:9: 7:10\n+          scope 2 {\n+              debug y => _2;               // in scope 2 at $DIR/mutable_variable_aggregate.rs:7:9: 7:10\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/mutable_variable_aggregate.rs:5:9: 5:14\n+          _1 = (const 42i32, const 43i32); // scope 0 at $DIR/mutable_variable_aggregate.rs:5:17: 5:25\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x0000002a))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/mutable_variable_aggregate.rs:5:18: 5:20\n++                                          // + span: $DIR/mutable_variable_aggregate.rs:5:17: 5:25\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x0000002a)) }\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x0000002b))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/mutable_variable_aggregate.rs:5:22: 5:24\n++                                          // + span: $DIR/mutable_variable_aggregate.rs:5:17: 5:25\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x0000002b)) }\n+          (_1.1: i32) = const 99i32;       // scope 1 at $DIR/mutable_variable_aggregate.rs:6:5: 6:13\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000063))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable_aggregate.rs:6:11: 6:13\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000063)) }\n+          StorageLive(_2);                 // scope 1 at $DIR/mutable_variable_aggregate.rs:7:9: 7:10\n+-         _2 = _1;                         // scope 1 at $DIR/mutable_variable_aggregate.rs:7:13: 7:14\n++         _2 = (const 42i32, const 99i32); // scope 1 at $DIR/mutable_variable_aggregate.rs:7:13: 7:14\n++                                          // ty::Const\n++                                          // + ty: i32\n++                                          // + val: Value(Scalar(0x0000002a))\n++                                          // mir::Constant\n++                                          // + span: $DIR/mutable_variable_aggregate.rs:7:13: 7:14\n++                                          // + literal: Const { ty: i32, val: Value(Scalar(0x0000002a)) }\n++                                          // ty::Const\n++                                          // + ty: i32\n++                                          // + val: Value(Scalar(0x00000063))\n++                                          // mir::Constant\n++                                          // + span: $DIR/mutable_variable_aggregate.rs:7:13: 7:14\n++                                          // + literal: Const { ty: i32, val: Value(Scalar(0x00000063)) }\n+          _0 = const ();                   // scope 0 at $DIR/mutable_variable_aggregate.rs:4:11: 8:2\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable_aggregate.rs:4:11: 8:2\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_2);                 // scope 1 at $DIR/mutable_variable_aggregate.rs:8:1: 8:2\n+          StorageDead(_1);                 // scope 0 at $DIR/mutable_variable_aggregate.rs:8:1: 8:2\n+          return;                          // scope 0 at $DIR/mutable_variable_aggregate.rs:8:2: 8:2\n+      }\n+  }\n+  "}, {"sha": "fc13cbf2abd56abff9fdaad41b87ae596a23e0af", "filename": "src/test/mir-opt/const_prop/mutable_variable_aggregate_mut_ref.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_mut_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_mut_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_mut_ref.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,9 @@\n+// compile-flags: -O\n+\n+// EMIT_MIR rustc.main.ConstProp.diff\n+fn main() {\n+    let mut x = (42, 43);\n+    let z = &mut x;\n+    z.1 = 99;\n+    let y = x;\n+}"}, {"sha": "44203ac327ab194ce0b1e9e8f345202e8fae4be6", "filename": "src/test/mir-opt/const_prop/mutable_variable_aggregate_mut_ref/rustc.main.ConstProp.diff", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_mut_ref%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_mut_ref%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_mut_ref%2Frustc.main.ConstProp.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,58 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/mutable_variable_aggregate_mut_ref.rs:4:11: 4:11\n+      let mut _1: (i32, i32);              // in scope 0 at $DIR/mutable_variable_aggregate_mut_ref.rs:5:9: 5:14\n+      scope 1 {\n+          debug x => _1;                   // in scope 1 at $DIR/mutable_variable_aggregate_mut_ref.rs:5:9: 5:14\n+          let _2: &mut (i32, i32);         // in scope 1 at $DIR/mutable_variable_aggregate_mut_ref.rs:6:9: 6:10\n+          scope 2 {\n+              debug z => _2;               // in scope 2 at $DIR/mutable_variable_aggregate_mut_ref.rs:6:9: 6:10\n+              let _3: (i32, i32);          // in scope 2 at $DIR/mutable_variable_aggregate_mut_ref.rs:8:9: 8:10\n+              scope 3 {\n+                  debug y => _3;           // in scope 3 at $DIR/mutable_variable_aggregate_mut_ref.rs:8:9: 8:10\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/mutable_variable_aggregate_mut_ref.rs:5:9: 5:14\n+          _1 = (const 42i32, const 43i32); // scope 0 at $DIR/mutable_variable_aggregate_mut_ref.rs:5:17: 5:25\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x0000002a))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable_aggregate_mut_ref.rs:5:18: 5:20\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x0000002a)) }\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x0000002b))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable_aggregate_mut_ref.rs:5:22: 5:24\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x0000002b)) }\n+          StorageLive(_2);                 // scope 1 at $DIR/mutable_variable_aggregate_mut_ref.rs:6:9: 6:10\n+          _2 = &mut _1;                    // scope 1 at $DIR/mutable_variable_aggregate_mut_ref.rs:6:13: 6:19\n+          ((*_2).1: i32) = const 99i32;    // scope 2 at $DIR/mutable_variable_aggregate_mut_ref.rs:7:5: 7:13\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000063))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable_aggregate_mut_ref.rs:7:11: 7:13\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000063)) }\n+          StorageLive(_3);                 // scope 2 at $DIR/mutable_variable_aggregate_mut_ref.rs:8:9: 8:10\n+          _3 = _1;                         // scope 2 at $DIR/mutable_variable_aggregate_mut_ref.rs:8:13: 8:14\n+          _0 = const ();                   // scope 0 at $DIR/mutable_variable_aggregate_mut_ref.rs:4:11: 9:2\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable_aggregate_mut_ref.rs:4:11: 9:2\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_3);                 // scope 2 at $DIR/mutable_variable_aggregate_mut_ref.rs:9:1: 9:2\n+          StorageDead(_2);                 // scope 1 at $DIR/mutable_variable_aggregate_mut_ref.rs:9:1: 9:2\n+          StorageDead(_1);                 // scope 0 at $DIR/mutable_variable_aggregate_mut_ref.rs:9:1: 9:2\n+          return;                          // scope 0 at $DIR/mutable_variable_aggregate_mut_ref.rs:9:2: 9:2\n+      }\n+  }\n+  "}, {"sha": "4f43ec8c9470ab60915ac743a0f37c6720f6919c", "filename": "src/test/mir-opt/const_prop/mutable_variable_aggregate_partial_read.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_partial_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_partial_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_partial_read.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags: -O\n+\n+// EMIT_MIR rustc.main.ConstProp.diff\n+fn main() {\n+    let mut x: (i32, i32) = foo();\n+    x.1 = 99;\n+    x.0 = 42;\n+    let y = x.1;\n+}\n+\n+#[inline(never)]\n+fn foo() -> (i32, i32) {\n+    unimplemented!()\n+}"}, {"sha": "6834bb6bdd4f74a1840dbe54d7c9bc16b3b61e8c", "filename": "src/test/mir-opt/const_prop/mutable_variable_aggregate_partial_read/rustc.main.ConstProp.diff", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_partial_read%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_partial_read%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_partial_read%2Frustc.main.ConstProp.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,62 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/mutable_variable_aggregate_partial_read.rs:4:11: 4:11\n+      let mut _1: (i32, i32) as UserTypeProjection { base: UserType(0), projs: [] }; // in scope 0 at $DIR/mutable_variable_aggregate_partial_read.rs:5:9: 5:14\n+      scope 1 {\n+          debug x => _1;                   // in scope 1 at $DIR/mutable_variable_aggregate_partial_read.rs:5:9: 5:14\n+          let _2: i32;                     // in scope 1 at $DIR/mutable_variable_aggregate_partial_read.rs:8:9: 8:10\n+          scope 2 {\n+              debug y => _2;               // in scope 2 at $DIR/mutable_variable_aggregate_partial_read.rs:8:9: 8:10\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/mutable_variable_aggregate_partial_read.rs:5:9: 5:14\n+          _1 = const foo() -> bb1;         // scope 0 at $DIR/mutable_variable_aggregate_partial_read.rs:5:29: 5:34\n+                                           // ty::Const\n+                                           // + ty: fn() -> (i32, i32) {foo}\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable_aggregate_partial_read.rs:5:29: 5:32\n+                                           // + literal: Const { ty: fn() -> (i32, i32) {foo}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          (_1.1: i32) = const 99i32;       // scope 1 at $DIR/mutable_variable_aggregate_partial_read.rs:6:5: 6:13\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000063))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable_aggregate_partial_read.rs:6:11: 6:13\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000063)) }\n+          (_1.0: i32) = const 42i32;       // scope 1 at $DIR/mutable_variable_aggregate_partial_read.rs:7:5: 7:13\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x0000002a))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable_aggregate_partial_read.rs:7:11: 7:13\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x0000002a)) }\n+          StorageLive(_2);                 // scope 1 at $DIR/mutable_variable_aggregate_partial_read.rs:8:9: 8:10\n+-         _2 = (_1.1: i32);                // scope 1 at $DIR/mutable_variable_aggregate_partial_read.rs:8:13: 8:16\n++         _2 = const 99i32;                // scope 1 at $DIR/mutable_variable_aggregate_partial_read.rs:8:13: 8:16\n++                                          // ty::Const\n++                                          // + ty: i32\n++                                          // + val: Value(Scalar(0x00000063))\n++                                          // mir::Constant\n++                                          // + span: $DIR/mutable_variable_aggregate_partial_read.rs:8:13: 8:16\n++                                          // + literal: Const { ty: i32, val: Value(Scalar(0x00000063)) }\n+          _0 = const ();                   // scope 0 at $DIR/mutable_variable_aggregate_partial_read.rs:4:11: 9:2\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable_aggregate_partial_read.rs:4:11: 9:2\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_2);                 // scope 1 at $DIR/mutable_variable_aggregate_partial_read.rs:9:1: 9:2\n+          StorageDead(_1);                 // scope 0 at $DIR/mutable_variable_aggregate_partial_read.rs:9:1: 9:2\n+          return;                          // scope 0 at $DIR/mutable_variable_aggregate_partial_read.rs:9:2: 9:2\n+      }\n+  }\n+  "}, {"sha": "8c9cd00509622c0a624e5c626d47a4b6894685af", "filename": "src/test/mir-opt/const_prop/mutable_variable_no_prop.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,12 @@\n+// compile-flags: -O\n+\n+static mut STATIC: u32 = 42;\n+\n+// EMIT_MIR rustc.main.ConstProp.diff\n+fn main() {\n+    let mut x = 42;\n+    unsafe {\n+        x = STATIC;\n+    }\n+    let y = x;\n+}"}, {"sha": "b7f1242d8d125de9ebed9cd96fef14a80e119bab", "filename": "src/test/mir-opt/const_prop/mutable_variable_no_prop/rustc.main.ConstProp.diff", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop%2Frustc.main.ConstProp.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,69 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/mutable_variable_no_prop.rs:6:11: 6:11\n+      let mut _1: u32;                     // in scope 0 at $DIR/mutable_variable_no_prop.rs:7:9: 7:14\n+      let _2: ();                          // in scope 0 at $DIR/mutable_variable_no_prop.rs:8:5: 10:6\n+      let mut _3: u32;                     // in scope 0 at $DIR/mutable_variable_no_prop.rs:9:13: 9:19\n+      let mut _4: *mut u32;                // in scope 0 at $DIR/mutable_variable_no_prop.rs:9:13: 9:19\n+      scope 1 {\n+          debug x => _1;                   // in scope 1 at $DIR/mutable_variable_no_prop.rs:7:9: 7:14\n+          let _5: u32;                     // in scope 1 at $DIR/mutable_variable_no_prop.rs:11:9: 11:10\n+          scope 2 {\n+          }\n+          scope 3 {\n+              debug y => _5;               // in scope 3 at $DIR/mutable_variable_no_prop.rs:11:9: 11:10\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/mutable_variable_no_prop.rs:7:9: 7:14\n+          _1 = const 42u32;                // scope 0 at $DIR/mutable_variable_no_prop.rs:7:17: 7:19\n+                                           // ty::Const\n+                                           // + ty: u32\n+                                           // + val: Value(Scalar(0x0000002a))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable_no_prop.rs:7:17: 7:19\n+                                           // + literal: Const { ty: u32, val: Value(Scalar(0x0000002a)) }\n+          StorageLive(_2);                 // scope 1 at $DIR/mutable_variable_no_prop.rs:8:5: 10:6\n+          StorageLive(_3);                 // scope 2 at $DIR/mutable_variable_no_prop.rs:9:13: 9:19\n+          StorageLive(_4);                 // scope 2 at $DIR/mutable_variable_no_prop.rs:9:13: 9:19\n+          _4 = const {alloc0: *mut u32};   // scope 2 at $DIR/mutable_variable_no_prop.rs:9:13: 9:19\n+                                           // ty::Const\n+                                           // + ty: *mut u32\n+                                           // + val: Value(Scalar(alloc0))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable_no_prop.rs:9:13: 9:19\n+                                           // + literal: Const { ty: *mut u32, val: Value(Scalar(alloc0)) }\n+          _3 = (*_4);                      // scope 2 at $DIR/mutable_variable_no_prop.rs:9:13: 9:19\n+          _1 = move _3;                    // scope 2 at $DIR/mutable_variable_no_prop.rs:9:9: 9:19\n+          StorageDead(_3);                 // scope 2 at $DIR/mutable_variable_no_prop.rs:9:18: 9:19\n+          StorageDead(_4);                 // scope 2 at $DIR/mutable_variable_no_prop.rs:9:19: 9:20\n+          _2 = const ();                   // scope 2 at $DIR/mutable_variable_no_prop.rs:8:5: 10:6\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable_no_prop.rs:8:5: 10:6\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_2);                 // scope 1 at $DIR/mutable_variable_no_prop.rs:10:5: 10:6\n+          StorageLive(_5);                 // scope 1 at $DIR/mutable_variable_no_prop.rs:11:9: 11:10\n+          _5 = _1;                         // scope 1 at $DIR/mutable_variable_no_prop.rs:11:13: 11:14\n+          _0 = const ();                   // scope 0 at $DIR/mutable_variable_no_prop.rs:6:11: 12:2\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable_no_prop.rs:6:11: 12:2\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_5);                 // scope 1 at $DIR/mutable_variable_no_prop.rs:12:1: 12:2\n+          StorageDead(_1);                 // scope 0 at $DIR/mutable_variable_no_prop.rs:12:1: 12:2\n+          return;                          // scope 0 at $DIR/mutable_variable_no_prop.rs:12:2: 12:2\n+      }\n+  }\n+  \n+  alloc0 (static: STATIC, size: 4, align: 4) {\n+      2a 00 00 00                                     \u2502 *...\n+  }\n+  "}, {"sha": "40f801b1b5e581c8a4ba994ef4090c73bfbab72f", "filename": "src/test/mir-opt/const_prop/mutable_variable_unprop_assign.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -O\n+\n+// EMIT_MIR rustc.main.ConstProp.diff\n+fn main() {\n+    let a = foo();\n+    let mut x: (i32, i32) = (1, 2);\n+    x.1 = a;\n+    let y = x.1;\n+    let z = x.0; // this could theoretically be allowed, but we can't handle it right now\n+}\n+\n+#[inline(never)]\n+fn foo() -> i32 {\n+    unimplemented!()\n+}"}, {"sha": "738343c655e360b11ed205d4f99be0032e119728", "filename": "src/test/mir-opt/const_prop/mutable_variable_unprop_assign/rustc.main.ConstProp.diff", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign%2Frustc.main.ConstProp.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,74 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/mutable_variable_unprop_assign.rs:4:11: 4:11\n+      let _1: i32;                         // in scope 0 at $DIR/mutable_variable_unprop_assign.rs:5:9: 5:10\n+      let mut _3: i32;                     // in scope 0 at $DIR/mutable_variable_unprop_assign.rs:7:11: 7:12\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/mutable_variable_unprop_assign.rs:5:9: 5:10\n+          let mut _2: (i32, i32) as UserTypeProjection { base: UserType(0), projs: [] }; // in scope 1 at $DIR/mutable_variable_unprop_assign.rs:6:9: 6:14\n+          scope 2 {\n+              debug x => _2;               // in scope 2 at $DIR/mutable_variable_unprop_assign.rs:6:9: 6:14\n+              let _4: i32;                 // in scope 2 at $DIR/mutable_variable_unprop_assign.rs:8:9: 8:10\n+              scope 3 {\n+                  debug y => _4;           // in scope 3 at $DIR/mutable_variable_unprop_assign.rs:8:9: 8:10\n+                  let _5: i32;             // in scope 3 at $DIR/mutable_variable_unprop_assign.rs:9:9: 9:10\n+                  scope 4 {\n+                      debug z => _5;       // in scope 4 at $DIR/mutable_variable_unprop_assign.rs:9:9: 9:10\n+                  }\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/mutable_variable_unprop_assign.rs:5:9: 5:10\n+          _1 = const foo() -> bb1;         // scope 0 at $DIR/mutable_variable_unprop_assign.rs:5:13: 5:18\n+                                           // ty::Const\n+                                           // + ty: fn() -> i32 {foo}\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable_unprop_assign.rs:5:13: 5:16\n+                                           // + literal: Const { ty: fn() -> i32 {foo}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          StorageLive(_2);                 // scope 1 at $DIR/mutable_variable_unprop_assign.rs:6:9: 6:14\n+          _2 = (const 1i32, const 2i32);   // scope 1 at $DIR/mutable_variable_unprop_assign.rs:6:29: 6:35\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000001))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/mutable_variable_unprop_assign.rs:6:30: 6:31\n++                                          // + span: $DIR/mutable_variable_unprop_assign.rs:6:29: 6:35\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000001)) }\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000002))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/mutable_variable_unprop_assign.rs:6:33: 6:34\n++                                          // + span: $DIR/mutable_variable_unprop_assign.rs:6:29: 6:35\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000002)) }\n+          StorageLive(_3);                 // scope 2 at $DIR/mutable_variable_unprop_assign.rs:7:11: 7:12\n+          _3 = _1;                         // scope 2 at $DIR/mutable_variable_unprop_assign.rs:7:11: 7:12\n+          (_2.1: i32) = move _3;           // scope 2 at $DIR/mutable_variable_unprop_assign.rs:7:5: 7:12\n+          StorageDead(_3);                 // scope 2 at $DIR/mutable_variable_unprop_assign.rs:7:11: 7:12\n+          StorageLive(_4);                 // scope 2 at $DIR/mutable_variable_unprop_assign.rs:8:9: 8:10\n+          _4 = (_2.1: i32);                // scope 2 at $DIR/mutable_variable_unprop_assign.rs:8:13: 8:16\n+          StorageLive(_5);                 // scope 3 at $DIR/mutable_variable_unprop_assign.rs:9:9: 9:10\n+          _5 = (_2.0: i32);                // scope 3 at $DIR/mutable_variable_unprop_assign.rs:9:13: 9:16\n+          _0 = const ();                   // scope 0 at $DIR/mutable_variable_unprop_assign.rs:4:11: 10:2\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/mutable_variable_unprop_assign.rs:4:11: 10:2\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_5);                 // scope 3 at $DIR/mutable_variable_unprop_assign.rs:10:1: 10:2\n+          StorageDead(_4);                 // scope 2 at $DIR/mutable_variable_unprop_assign.rs:10:1: 10:2\n+          StorageDead(_2);                 // scope 1 at $DIR/mutable_variable_unprop_assign.rs:10:1: 10:2\n+          StorageDead(_1);                 // scope 0 at $DIR/mutable_variable_unprop_assign.rs:10:1: 10:2\n+          return;                          // scope 0 at $DIR/mutable_variable_unprop_assign.rs:10:2: 10:2\n+      }\n+  }\n+  "}, {"sha": "103444f796ec64c48e6b288cca32217c9d7ebe65", "filename": "src/test/mir-opt/const_prop/read_immutable_static/rustc.main.ConstProp.diff", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static%2Frustc.main.ConstProp.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -16,13 +16,13 @@\n           StorageLive(_1);                 // scope 0 at $DIR/read_immutable_static.rs:7:9: 7:10\n           StorageLive(_2);                 // scope 0 at $DIR/read_immutable_static.rs:7:13: 7:16\n           StorageLive(_3);                 // scope 0 at $DIR/read_immutable_static.rs:7:13: 7:16\n-          _3 = const {alloc0+0x0: &u8};    // scope 0 at $DIR/read_immutable_static.rs:7:13: 7:16\n+          _3 = const {alloc0: &u8};        // scope 0 at $DIR/read_immutable_static.rs:7:13: 7:16\n                                            // ty::Const\n                                            // + ty: &u8\n-                                           // + val: Value(Scalar(alloc0+0x0))\n+                                           // + val: Value(Scalar(alloc0))\n                                            // mir::Constant\n                                            // + span: $DIR/read_immutable_static.rs:7:13: 7:16\n-                                           // + literal: Const { ty: &u8, val: Value(Scalar(alloc0+0x0)) }\n+                                           // + literal: Const { ty: &u8, val: Value(Scalar(alloc0)) }\n -         _2 = (*_3);                      // scope 0 at $DIR/read_immutable_static.rs:7:13: 7:16\n +         _2 = const 2u8;                  // scope 0 at $DIR/read_immutable_static.rs:7:13: 7:16\n +                                          // ty::Const\n@@ -33,13 +33,13 @@\n +                                          // + literal: Const { ty: u8, val: Value(Scalar(0x02)) }\n           StorageLive(_4);                 // scope 0 at $DIR/read_immutable_static.rs:7:19: 7:22\n           StorageLive(_5);                 // scope 0 at $DIR/read_immutable_static.rs:7:19: 7:22\n-          _5 = const {alloc0+0x0: &u8};    // scope 0 at $DIR/read_immutable_static.rs:7:19: 7:22\n+          _5 = const {alloc0: &u8};        // scope 0 at $DIR/read_immutable_static.rs:7:19: 7:22\n                                            // ty::Const\n                                            // + ty: &u8\n-                                           // + val: Value(Scalar(alloc0+0x0))\n+                                           // + val: Value(Scalar(alloc0))\n                                            // mir::Constant\n                                            // + span: $DIR/read_immutable_static.rs:7:19: 7:22\n-                                           // + literal: Const { ty: &u8, val: Value(Scalar(alloc0+0x0)) }\n+                                           // + literal: Const { ty: &u8, val: Value(Scalar(alloc0)) }\n -         _4 = (*_5);                      // scope 0 at $DIR/read_immutable_static.rs:7:19: 7:22\n -         _1 = Add(move _2, move _4);      // scope 0 at $DIR/read_immutable_static.rs:7:13: 7:22\n +         _4 = const 2u8;                  // scope 0 at $DIR/read_immutable_static.rs:7:19: 7:22"}, {"sha": "1e0271a560f650785d410cfc5edf25cf3ee8f11a", "filename": "src/test/mir-opt/copy_propagation_arg/rustc.arg_src.CopyPropagation.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg%2Frustc.arg_src.CopyPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg%2Frustc.arg_src.CopyPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg%2Frustc.arg_src.CopyPropagation.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -17,7 +17,7 @@\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x0000007b))\n                                            // mir::Constant\n-                                           // + span: $DIR/copy_propagation_arg.rs:29:5: 29:12\n+                                           // + span: $DIR/copy_propagation_arg.rs:29:9: 29:12\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x0000007b)) }\n           _0 = _2;                         // scope 1 at $DIR/copy_propagation_arg.rs:30:5: 30:6\n           StorageDead(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:31:1: 31:2"}, {"sha": "b875bbea67bdf0b5bde199b3d5367c959109d2eb", "filename": "src/test/mir-opt/copy_propagation_arg/rustc.bar.CopyPropagation.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg%2Frustc.bar.CopyPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg%2Frustc.bar.CopyPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg%2Frustc.bar.CopyPropagation.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -28,7 +28,7 @@\n                                            // + ty: u8\n                                            // + val: Value(Scalar(0x05))\n                                            // mir::Constant\n-                                           // + span: $DIR/copy_propagation_arg.rs:17:5: 17:10\n+                                           // + span: $DIR/copy_propagation_arg.rs:17:9: 17:10\n                                            // + literal: Const { ty: u8, val: Value(Scalar(0x05)) }\n           _0 = const ();                   // scope 0 at $DIR/copy_propagation_arg.rs:15:19: 18:2\n                                            // ty::Const"}, {"sha": "6199e2c56625df1718ee1aab101577feb19c7197", "filename": "src/test/mir-opt/simplify-arm-identity/32bit/rustc.main.SimplifyArmIdentity.diff", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify-arm-identity%2F32bit%2Frustc.main.SimplifyArmIdentity.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify-arm-identity%2F32bit%2Frustc.main.SimplifyArmIdentity.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify-arm-identity%2F32bit%2Frustc.main.SimplifyArmIdentity.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -35,9 +35,38 @@\n                                            // mir::Constant\n                                            // + span: $DIR/simplify-arm-identity.rs:20:9: 20:20\n                                            // + literal: Const { ty: isize, val: Value(Scalar(0x00000000)) }\n+          goto -> bb3;                     // scope 1 at $DIR/simplify-arm-identity.rs:20:9: 20:20\n+      }\n+  \n+      bb1: {\n+          ((_2 as Foo).0: u8) = const 0u8; // scope 1 at $DIR/simplify-arm-identity.rs:21:21: 21:32\n+                                           // ty::Const\n+                                           // + ty: u8\n+                                           // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify-arm-identity.rs:21:30: 21:31\n+                                           // + literal: Const { ty: u8, val: Value(Scalar(0x00)) }\n+          discriminant(_2) = 0;            // scope 1 at $DIR/simplify-arm-identity.rs:21:21: 21:32\n+          goto -> bb4;                     // scope 1 at $DIR/simplify-arm-identity.rs:19:18: 22:6\n+      }\n+  \n+      bb2: {\n+          unreachable;                     // scope 1 at $DIR/simplify-arm-identity.rs:19:24: 19:25\n+      }\n+  \n+      bb3: {\n+          StorageLive(_4);                 // scope 1 at $DIR/simplify-arm-identity.rs:20:18: 20:19\n           _4 = ((_1 as Foo).0: u8);        // scope 1 at $DIR/simplify-arm-identity.rs:20:18: 20:19\n-          ((_2 as Foo).0: u8) = move _4;   // scope 3 at $DIR/simplify-arm-identity.rs:20:24: 20:35\n+          StorageLive(_5);                 // scope 3 at $DIR/simplify-arm-identity.rs:20:33: 20:34\n+          _5 = _4;                         // scope 3 at $DIR/simplify-arm-identity.rs:20:33: 20:34\n+          ((_2 as Foo).0: u8) = move _5;   // scope 3 at $DIR/simplify-arm-identity.rs:20:24: 20:35\n           discriminant(_2) = 0;            // scope 3 at $DIR/simplify-arm-identity.rs:20:24: 20:35\n+          StorageDead(_5);                 // scope 3 at $DIR/simplify-arm-identity.rs:20:34: 20:35\n+          StorageDead(_4);                 // scope 1 at $DIR/simplify-arm-identity.rs:20:35: 20:36\n+          goto -> bb4;                     // scope 1 at $DIR/simplify-arm-identity.rs:19:18: 22:6\n+      }\n+  \n+      bb4: {\n           StorageDead(_2);                 // scope 1 at $DIR/simplify-arm-identity.rs:22:6: 22:7\n           _0 = const ();                   // scope 0 at $DIR/simplify-arm-identity.rs:17:11: 23:2\n                                            // ty::Const"}, {"sha": "bf875c6a555fe3d2f6241d7e63a8c0fd867e2453", "filename": "src/test/mir-opt/simplify-arm-identity/64bit/rustc.main.SimplifyArmIdentity.diff", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify-arm-identity%2F64bit%2Frustc.main.SimplifyArmIdentity.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify-arm-identity%2F64bit%2Frustc.main.SimplifyArmIdentity.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify-arm-identity%2F64bit%2Frustc.main.SimplifyArmIdentity.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -35,9 +35,38 @@\n                                            // mir::Constant\n                                            // + span: $DIR/simplify-arm-identity.rs:20:9: 20:20\n                                            // + literal: Const { ty: isize, val: Value(Scalar(0x0000000000000000)) }\n+          goto -> bb3;                     // scope 1 at $DIR/simplify-arm-identity.rs:20:9: 20:20\n+      }\n+  \n+      bb1: {\n+          ((_2 as Foo).0: u8) = const 0u8; // scope 1 at $DIR/simplify-arm-identity.rs:21:21: 21:32\n+                                           // ty::Const\n+                                           // + ty: u8\n+                                           // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify-arm-identity.rs:21:30: 21:31\n+                                           // + literal: Const { ty: u8, val: Value(Scalar(0x00)) }\n+          discriminant(_2) = 0;            // scope 1 at $DIR/simplify-arm-identity.rs:21:21: 21:32\n+          goto -> bb4;                     // scope 1 at $DIR/simplify-arm-identity.rs:19:18: 22:6\n+      }\n+  \n+      bb2: {\n+          unreachable;                     // scope 1 at $DIR/simplify-arm-identity.rs:19:24: 19:25\n+      }\n+  \n+      bb3: {\n+          StorageLive(_4);                 // scope 1 at $DIR/simplify-arm-identity.rs:20:18: 20:19\n           _4 = ((_1 as Foo).0: u8);        // scope 1 at $DIR/simplify-arm-identity.rs:20:18: 20:19\n-          ((_2 as Foo).0: u8) = move _4;   // scope 3 at $DIR/simplify-arm-identity.rs:20:24: 20:35\n+          StorageLive(_5);                 // scope 3 at $DIR/simplify-arm-identity.rs:20:33: 20:34\n+          _5 = _4;                         // scope 3 at $DIR/simplify-arm-identity.rs:20:33: 20:34\n+          ((_2 as Foo).0: u8) = move _5;   // scope 3 at $DIR/simplify-arm-identity.rs:20:24: 20:35\n           discriminant(_2) = 0;            // scope 3 at $DIR/simplify-arm-identity.rs:20:24: 20:35\n+          StorageDead(_5);                 // scope 3 at $DIR/simplify-arm-identity.rs:20:34: 20:35\n+          StorageDead(_4);                 // scope 1 at $DIR/simplify-arm-identity.rs:20:35: 20:36\n+          goto -> bb4;                     // scope 1 at $DIR/simplify-arm-identity.rs:19:18: 22:6\n+      }\n+  \n+      bb4: {\n           StorageDead(_2);                 // scope 1 at $DIR/simplify-arm-identity.rs:22:6: 22:7\n           _0 = const ();                   // scope 0 at $DIR/simplify-arm-identity.rs:17:11: 23:2\n                                            // ty::Const"}, {"sha": "0e3f86501bb44a2cc08ec0fa830b2a607b098245", "filename": "src/test/mir-opt/simplify-arm.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify-arm.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,32 @@\n+// compile-flags: -Z mir-opt-level=1\n+// EMIT_MIR rustc.id.SimplifyArmIdentity.diff\n+// EMIT_MIR rustc.id.SimplifyBranchSame.diff\n+// EMIT_MIR rustc.id_result.SimplifyArmIdentity.diff\n+// EMIT_MIR rustc.id_result.SimplifyBranchSame.diff\n+// EMIT_MIR rustc.id_try.SimplifyArmIdentity.diff\n+// EMIT_MIR rustc.id_try.SimplifyBranchSame.diff\n+\n+fn id(o: Option<u8>) -> Option<u8> {\n+    match o {\n+        Some(v) => Some(v),\n+        None => None,\n+    }\n+}\n+\n+fn id_result(r: Result<u8, i32>) -> Result<u8, i32> {\n+    match r {\n+        Ok(x) => Ok(x),\n+        Err(y) => Err(y),\n+    }\n+}\n+\n+fn id_try(r: Result<u8, i32>) -> Result<u8, i32> {\n+    let x = r?;\n+    Ok(x)\n+}\n+\n+fn main() {\n+    id(None);\n+    id_result(Ok(4));\n+    id_try(Ok(4));\n+}"}, {"sha": "8d08267d75bfddc862cf8dd6c9df844bcaf709c7", "filename": "src/test/mir-opt/simplify-arm/rustc.id.SimplifyArmIdentity.diff", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify-arm%2Frustc.id.SimplifyArmIdentity.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify-arm%2Frustc.id.SimplifyArmIdentity.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify-arm%2Frustc.id.SimplifyArmIdentity.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,45 @@\n+- // MIR for `id` before SimplifyArmIdentity\n++ // MIR for `id` after SimplifyArmIdentity\n+  \n+  fn id(_1: std::option::Option<u8>) -> std::option::Option<u8> {\n+      debug o => _1;                       // in scope 0 at $DIR/simplify-arm.rs:9:7: 9:8\n+      let mut _0: std::option::Option<u8>; // return place in scope 0 at $DIR/simplify-arm.rs:9:25: 9:35\n+      let mut _2: isize;                   // in scope 0 at $DIR/simplify-arm.rs:11:9: 11:16\n+      let _3: u8;                          // in scope 0 at $DIR/simplify-arm.rs:11:14: 11:15\n+      let mut _4: u8;                      // in scope 0 at $DIR/simplify-arm.rs:11:25: 11:26\n+      scope 1 {\n+          debug v => _3;                   // in scope 1 at $DIR/simplify-arm.rs:11:14: 11:15\n+      }\n+  \n+      bb0: {\n+          _2 = discriminant(_1);           // scope 0 at $DIR/simplify-arm.rs:11:9: 11:16\n+          switchInt(move _2) -> [0isize: bb1, 1isize: bb3, otherwise: bb2]; // scope 0 at $DIR/simplify-arm.rs:11:9: 11:16\n+      }\n+  \n+      bb1: {\n+          discriminant(_0) = 0;            // scope 0 at $DIR/simplify-arm.rs:12:17: 12:21\n+          goto -> bb4;                     // scope 0 at $DIR/simplify-arm.rs:10:5: 13:6\n+      }\n+  \n+      bb2: {\n+          unreachable;                     // scope 0 at $DIR/simplify-arm.rs:10:11: 10:12\n+      }\n+  \n+      bb3: {\n+-         StorageLive(_3);                 // scope 0 at $DIR/simplify-arm.rs:11:14: 11:15\n+-         _3 = ((_1 as Some).0: u8);       // scope 0 at $DIR/simplify-arm.rs:11:14: 11:15\n+-         StorageLive(_4);                 // scope 1 at $DIR/simplify-arm.rs:11:25: 11:26\n+-         _4 = _3;                         // scope 1 at $DIR/simplify-arm.rs:11:25: 11:26\n+-         ((_0 as Some).0: u8) = move _4;  // scope 1 at $DIR/simplify-arm.rs:11:20: 11:27\n+-         discriminant(_0) = 1;            // scope 1 at $DIR/simplify-arm.rs:11:20: 11:27\n+-         StorageDead(_4);                 // scope 1 at $DIR/simplify-arm.rs:11:26: 11:27\n+-         StorageDead(_3);                 // scope 0 at $DIR/simplify-arm.rs:11:27: 11:28\n++         _0 = move _1;                    // scope 1 at $DIR/simplify-arm.rs:11:20: 11:27\n+          goto -> bb4;                     // scope 0 at $DIR/simplify-arm.rs:10:5: 13:6\n+      }\n+  \n+      bb4: {\n+          return;                          // scope 0 at $DIR/simplify-arm.rs:14:2: 14:2\n+      }\n+  }\n+  "}, {"sha": "23fa9817f80f6b7eca7a83d0f56d1c6d53a0647d", "filename": "src/test/mir-opt/simplify-arm/rustc.id.SimplifyBranchSame.diff", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify-arm%2Frustc.id.SimplifyBranchSame.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify-arm%2Frustc.id.SimplifyBranchSame.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify-arm%2Frustc.id.SimplifyBranchSame.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,37 @@\n+- // MIR for `id` before SimplifyBranchSame\n++ // MIR for `id` after SimplifyBranchSame\n+  \n+  fn id(_1: std::option::Option<u8>) -> std::option::Option<u8> {\n+      debug o => _1;                       // in scope 0 at $DIR/simplify-arm.rs:9:7: 9:8\n+      let mut _0: std::option::Option<u8>; // return place in scope 0 at $DIR/simplify-arm.rs:9:25: 9:35\n+      let mut _2: isize;                   // in scope 0 at $DIR/simplify-arm.rs:11:9: 11:16\n+      let _3: u8;                          // in scope 0 at $DIR/simplify-arm.rs:11:14: 11:15\n+      let mut _4: u8;                      // in scope 0 at $DIR/simplify-arm.rs:11:25: 11:26\n+      scope 1 {\n+          debug v => _3;                   // in scope 1 at $DIR/simplify-arm.rs:11:14: 11:15\n+      }\n+  \n+      bb0: {\n+          _2 = discriminant(_1);           // scope 0 at $DIR/simplify-arm.rs:11:9: 11:16\n+          switchInt(move _2) -> [0isize: bb1, 1isize: bb3, otherwise: bb2]; // scope 0 at $DIR/simplify-arm.rs:11:9: 11:16\n+      }\n+  \n+      bb1: {\n+          discriminant(_0) = 0;            // scope 0 at $DIR/simplify-arm.rs:12:17: 12:21\n+          goto -> bb4;                     // scope 0 at $DIR/simplify-arm.rs:10:5: 13:6\n+      }\n+  \n+      bb2: {\n+          unreachable;                     // scope 0 at $DIR/simplify-arm.rs:10:11: 10:12\n+      }\n+  \n+      bb3: {\n+          _0 = move _1;                    // scope 1 at $DIR/simplify-arm.rs:11:20: 11:27\n+          goto -> bb4;                     // scope 0 at $DIR/simplify-arm.rs:10:5: 13:6\n+      }\n+  \n+      bb4: {\n+          return;                          // scope 0 at $DIR/simplify-arm.rs:14:2: 14:2\n+      }\n+  }\n+  "}, {"sha": "e2a12ca5be26c5c8ce41821b1665db13b44aac49", "filename": "src/test/mir-opt/simplify-arm/rustc.id_result.SimplifyArmIdentity.diff", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify-arm%2Frustc.id_result.SimplifyArmIdentity.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify-arm%2Frustc.id_result.SimplifyArmIdentity.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify-arm%2Frustc.id_result.SimplifyArmIdentity.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,58 @@\n+- // MIR for `id_result` before SimplifyArmIdentity\n++ // MIR for `id_result` after SimplifyArmIdentity\n+  \n+  fn id_result(_1: std::result::Result<u8, i32>) -> std::result::Result<u8, i32> {\n+      debug r => _1;                       // in scope 0 at $DIR/simplify-arm.rs:16:14: 16:15\n+      let mut _0: std::result::Result<u8, i32>; // return place in scope 0 at $DIR/simplify-arm.rs:16:37: 16:52\n+      let mut _2: isize;                   // in scope 0 at $DIR/simplify-arm.rs:18:9: 18:14\n+      let _3: u8;                          // in scope 0 at $DIR/simplify-arm.rs:18:12: 18:13\n+      let mut _4: u8;                      // in scope 0 at $DIR/simplify-arm.rs:18:21: 18:22\n+      let _5: i32;                         // in scope 0 at $DIR/simplify-arm.rs:19:13: 19:14\n+      let mut _6: i32;                     // in scope 0 at $DIR/simplify-arm.rs:19:23: 19:24\n+      scope 1 {\n+          debug x => _3;                   // in scope 1 at $DIR/simplify-arm.rs:18:12: 18:13\n+      }\n+      scope 2 {\n+          debug y => _5;                   // in scope 2 at $DIR/simplify-arm.rs:19:13: 19:14\n+      }\n+  \n+      bb0: {\n+          _2 = discriminant(_1);           // scope 0 at $DIR/simplify-arm.rs:18:9: 18:14\n+          switchInt(move _2) -> [0isize: bb3, 1isize: bb1, otherwise: bb2]; // scope 0 at $DIR/simplify-arm.rs:18:9: 18:14\n+      }\n+  \n+      bb1: {\n+-         StorageLive(_5);                 // scope 0 at $DIR/simplify-arm.rs:19:13: 19:14\n+-         _5 = ((_1 as Err).0: i32);       // scope 0 at $DIR/simplify-arm.rs:19:13: 19:14\n+-         StorageLive(_6);                 // scope 2 at $DIR/simplify-arm.rs:19:23: 19:24\n+-         _6 = _5;                         // scope 2 at $DIR/simplify-arm.rs:19:23: 19:24\n+-         ((_0 as Err).0: i32) = move _6;  // scope 2 at $DIR/simplify-arm.rs:19:19: 19:25\n+-         discriminant(_0) = 1;            // scope 2 at $DIR/simplify-arm.rs:19:19: 19:25\n+-         StorageDead(_6);                 // scope 2 at $DIR/simplify-arm.rs:19:24: 19:25\n+-         StorageDead(_5);                 // scope 0 at $DIR/simplify-arm.rs:19:25: 19:26\n++         _0 = move _1;                    // scope 2 at $DIR/simplify-arm.rs:19:19: 19:25\n+          goto -> bb4;                     // scope 0 at $DIR/simplify-arm.rs:17:5: 20:6\n+      }\n+  \n+      bb2: {\n+          unreachable;                     // scope 0 at $DIR/simplify-arm.rs:17:11: 17:12\n+      }\n+  \n+      bb3: {\n+-         StorageLive(_3);                 // scope 0 at $DIR/simplify-arm.rs:18:12: 18:13\n+-         _3 = ((_1 as Ok).0: u8);         // scope 0 at $DIR/simplify-arm.rs:18:12: 18:13\n+-         StorageLive(_4);                 // scope 1 at $DIR/simplify-arm.rs:18:21: 18:22\n+-         _4 = _3;                         // scope 1 at $DIR/simplify-arm.rs:18:21: 18:22\n+-         ((_0 as Ok).0: u8) = move _4;    // scope 1 at $DIR/simplify-arm.rs:18:18: 18:23\n+-         discriminant(_0) = 0;            // scope 1 at $DIR/simplify-arm.rs:18:18: 18:23\n+-         StorageDead(_4);                 // scope 1 at $DIR/simplify-arm.rs:18:22: 18:23\n+-         StorageDead(_3);                 // scope 0 at $DIR/simplify-arm.rs:18:23: 18:24\n++         _0 = move _1;                    // scope 1 at $DIR/simplify-arm.rs:18:18: 18:23\n+          goto -> bb4;                     // scope 0 at $DIR/simplify-arm.rs:17:5: 20:6\n+      }\n+  \n+      bb4: {\n+          return;                          // scope 0 at $DIR/simplify-arm.rs:21:2: 21:2\n+      }\n+  }\n+  "}, {"sha": "9d1ff22dc510999d521aac4275c9d72dd8e1e3e9", "filename": "src/test/mir-opt/simplify-arm/rustc.id_result.SimplifyBranchSame.diff", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify-arm%2Frustc.id_result.SimplifyBranchSame.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify-arm%2Frustc.id_result.SimplifyBranchSame.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify-arm%2Frustc.id_result.SimplifyBranchSame.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,45 @@\n+- // MIR for `id_result` before SimplifyBranchSame\n++ // MIR for `id_result` after SimplifyBranchSame\n+  \n+  fn id_result(_1: std::result::Result<u8, i32>) -> std::result::Result<u8, i32> {\n+      debug r => _1;                       // in scope 0 at $DIR/simplify-arm.rs:16:14: 16:15\n+      let mut _0: std::result::Result<u8, i32>; // return place in scope 0 at $DIR/simplify-arm.rs:16:37: 16:52\n+      let mut _2: isize;                   // in scope 0 at $DIR/simplify-arm.rs:18:9: 18:14\n+      let _3: u8;                          // in scope 0 at $DIR/simplify-arm.rs:18:12: 18:13\n+      let mut _4: u8;                      // in scope 0 at $DIR/simplify-arm.rs:18:21: 18:22\n+      let _5: i32;                         // in scope 0 at $DIR/simplify-arm.rs:19:13: 19:14\n+      let mut _6: i32;                     // in scope 0 at $DIR/simplify-arm.rs:19:23: 19:24\n+      scope 1 {\n+          debug x => _3;                   // in scope 1 at $DIR/simplify-arm.rs:18:12: 18:13\n+      }\n+      scope 2 {\n+          debug y => _5;                   // in scope 2 at $DIR/simplify-arm.rs:19:13: 19:14\n+      }\n+  \n+      bb0: {\n+          _2 = discriminant(_1);           // scope 0 at $DIR/simplify-arm.rs:18:9: 18:14\n+-         switchInt(move _2) -> [0isize: bb3, 1isize: bb1, otherwise: bb2]; // scope 0 at $DIR/simplify-arm.rs:18:9: 18:14\n++         goto -> bb1;                     // scope 0 at $DIR/simplify-arm.rs:18:9: 18:14\n+      }\n+  \n+      bb1: {\n+-         _0 = move _1;                    // scope 2 at $DIR/simplify-arm.rs:19:19: 19:25\n+-         goto -> bb4;                     // scope 0 at $DIR/simplify-arm.rs:17:5: 20:6\n+-     }\n+- \n+-     bb2: {\n+-         unreachable;                     // scope 0 at $DIR/simplify-arm.rs:17:11: 17:12\n+-     }\n+- \n+-     bb3: {\n+          _0 = move _1;                    // scope 1 at $DIR/simplify-arm.rs:18:18: 18:23\n+-         goto -> bb4;                     // scope 0 at $DIR/simplify-arm.rs:17:5: 20:6\n++         goto -> bb2;                     // scope 0 at $DIR/simplify-arm.rs:17:5: 20:6\n+      }\n+  \n+-     bb4: {\n++     bb2: {\n+          return;                          // scope 0 at $DIR/simplify-arm.rs:21:2: 21:2\n+      }\n+  }\n+  "}, {"sha": "ba6e1ac24cb4ed2339bc926d94bba84eecaf488c", "filename": "src/test/mir-opt/simplify-arm/rustc.id_try.SimplifyArmIdentity.diff", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify-arm%2Frustc.id_try.SimplifyArmIdentity.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify-arm%2Frustc.id_try.SimplifyArmIdentity.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify-arm%2Frustc.id_try.SimplifyArmIdentity.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,109 @@\n+- // MIR for `id_try` before SimplifyArmIdentity\n++ // MIR for `id_try` after SimplifyArmIdentity\n+  \n+  fn id_try(_1: std::result::Result<u8, i32>) -> std::result::Result<u8, i32> {\n+      debug r => _1;                       // in scope 0 at $DIR/simplify-arm.rs:23:11: 23:12\n+      let mut _0: std::result::Result<u8, i32>; // return place in scope 0 at $DIR/simplify-arm.rs:23:34: 23:49\n+      let _2: u8;                          // in scope 0 at $DIR/simplify-arm.rs:24:9: 24:10\n+      let mut _3: std::result::Result<u8, i32>; // in scope 0 at $DIR/simplify-arm.rs:24:13: 24:15\n+      let mut _4: std::result::Result<u8, i32>; // in scope 0 at $DIR/simplify-arm.rs:24:13: 24:14\n+      let mut _5: isize;                   // in scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+      let _6: i32;                         // in scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+      let mut _7: !;                       // in scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+      let mut _8: i32;                     // in scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+      let mut _9: i32;                     // in scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+      let _10: u8;                         // in scope 0 at $DIR/simplify-arm.rs:24:13: 24:15\n+      let mut _11: u8;                     // in scope 0 at $DIR/simplify-arm.rs:25:8: 25:9\n+      scope 1 {\n+          debug x => _2;                   // in scope 1 at $DIR/simplify-arm.rs:24:9: 24:10\n+      }\n+      scope 2 {\n+          debug err => _6;                 // in scope 2 at $DIR/simplify-arm.rs:24:14: 24:15\n+          scope 3 {\n+          }\n+      }\n+      scope 4 {\n+          debug val => _10;                // in scope 4 at $DIR/simplify-arm.rs:24:13: 24:15\n+          scope 5 {\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/simplify-arm.rs:24:9: 24:10\n+          StorageLive(_3);                 // scope 0 at $DIR/simplify-arm.rs:24:13: 24:15\n+          StorageLive(_4);                 // scope 0 at $DIR/simplify-arm.rs:24:13: 24:14\n+          _4 = _1;                         // scope 0 at $DIR/simplify-arm.rs:24:13: 24:14\n+          _3 = const <std::result::Result<u8, i32> as std::ops::Try>::into_result(move _4) -> bb1; // scope 0 at $DIR/simplify-arm.rs:24:13: 24:15\n+                                           // ty::Const\n+                                           // + ty: fn(std::result::Result<u8, i32>) -> std::result::Result<<std::result::Result<u8, i32> as std::ops::Try>::Ok, <std::result::Result<u8, i32> as std::ops::Try>::Error> {<std::result::Result<u8, i32> as std::ops::Try>::into_result}\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify-arm.rs:24:13: 24:15\n+                                           // + literal: Const { ty: fn(std::result::Result<u8, i32>) -> std::result::Result<<std::result::Result<u8, i32> as std::ops::Try>::Ok, <std::result::Result<u8, i32> as std::ops::Try>::Error> {<std::result::Result<u8, i32> as std::ops::Try>::into_result}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_4);                 // scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+          _5 = discriminant(_3);           // scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+          switchInt(move _5) -> [0isize: bb2, 1isize: bb4, otherwise: bb3]; // scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+      }\n+  \n+      bb2: {\n+-         StorageLive(_10);                // scope 0 at $DIR/simplify-arm.rs:24:13: 24:15\n+-         _10 = ((_3 as Ok).0: u8);        // scope 0 at $DIR/simplify-arm.rs:24:13: 24:15\n+-         _2 = _10;                        // scope 5 at $DIR/simplify-arm.rs:24:13: 24:15\n+-         StorageDead(_10);                // scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n++         _0 = move _3;                    // scope 1 at $DIR/simplify-arm.rs:25:5: 25:10\n+          StorageDead(_3);                 // scope 0 at $DIR/simplify-arm.rs:24:15: 24:16\n+-         StorageLive(_11);                // scope 1 at $DIR/simplify-arm.rs:25:8: 25:9\n+-         _11 = _2;                        // scope 1 at $DIR/simplify-arm.rs:25:8: 25:9\n+-         ((_0 as Ok).0: u8) = move _11;   // scope 1 at $DIR/simplify-arm.rs:25:5: 25:10\n+-         discriminant(_0) = 0;            // scope 1 at $DIR/simplify-arm.rs:25:5: 25:10\n+-         StorageDead(_11);                // scope 1 at $DIR/simplify-arm.rs:25:9: 25:10\n+          StorageDead(_2);                 // scope 0 at $DIR/simplify-arm.rs:26:1: 26:2\n+          goto -> bb7;                     // scope 0 at $DIR/simplify-arm.rs:26:2: 26:2\n+      }\n+  \n+      bb3: {\n+          unreachable;                     // scope 0 at $DIR/simplify-arm.rs:24:13: 24:15\n+      }\n+  \n+      bb4: {\n+          StorageLive(_6);                 // scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+          _6 = ((_3 as Err).0: i32);       // scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+          StorageLive(_8);                 // scope 3 at $DIR/simplify-arm.rs:24:14: 24:15\n+          StorageLive(_9);                 // scope 3 at $DIR/simplify-arm.rs:24:14: 24:15\n+          _9 = _6;                         // scope 3 at $DIR/simplify-arm.rs:24:14: 24:15\n+          _8 = const <i32 as std::convert::From<i32>>::from(move _9) -> bb5; // scope 3 at $DIR/simplify-arm.rs:24:14: 24:15\n+                                           // ty::Const\n+                                           // + ty: fn(i32) -> i32 {<i32 as std::convert::From<i32>>::from}\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify-arm.rs:24:14: 24:15\n+                                           // + literal: Const { ty: fn(i32) -> i32 {<i32 as std::convert::From<i32>>::from}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb5: {\n+          StorageDead(_9);                 // scope 3 at $DIR/simplify-arm.rs:24:14: 24:15\n+          _0 = const <std::result::Result<u8, i32> as std::ops::Try>::from_error(move _8) -> bb6; // scope 3 at $DIR/simplify-arm.rs:24:14: 24:15\n+                                           // ty::Const\n+                                           // + ty: fn(<std::result::Result<u8, i32> as std::ops::Try>::Error) -> std::result::Result<u8, i32> {<std::result::Result<u8, i32> as std::ops::Try>::from_error}\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify-arm.rs:24:13: 24:15\n+                                           // + literal: Const { ty: fn(<std::result::Result<u8, i32> as std::ops::Try>::Error) -> std::result::Result<u8, i32> {<std::result::Result<u8, i32> as std::ops::Try>::from_error}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb6: {\n+          StorageDead(_8);                 // scope 3 at $DIR/simplify-arm.rs:24:14: 24:15\n+          StorageDead(_6);                 // scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+          StorageDead(_3);                 // scope 0 at $DIR/simplify-arm.rs:24:15: 24:16\n+          StorageDead(_2);                 // scope 0 at $DIR/simplify-arm.rs:26:1: 26:2\n+          goto -> bb7;                     // scope 0 at $DIR/simplify-arm.rs:26:2: 26:2\n+      }\n+  \n+      bb7: {\n+          return;                          // scope 0 at $DIR/simplify-arm.rs:26:2: 26:2\n+      }\n+  }\n+  "}, {"sha": "4061c5e74ac616631a449e002bba6d13eacc3886", "filename": "src/test/mir-opt/simplify-arm/rustc.id_try.SimplifyBranchSame.diff", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify-arm%2Frustc.id_try.SimplifyBranchSame.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify-arm%2Frustc.id_try.SimplifyBranchSame.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify-arm%2Frustc.id_try.SimplifyBranchSame.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,100 @@\n+- // MIR for `id_try` before SimplifyBranchSame\n++ // MIR for `id_try` after SimplifyBranchSame\n+  \n+  fn id_try(_1: std::result::Result<u8, i32>) -> std::result::Result<u8, i32> {\n+      debug r => _1;                       // in scope 0 at $DIR/simplify-arm.rs:23:11: 23:12\n+      let mut _0: std::result::Result<u8, i32>; // return place in scope 0 at $DIR/simplify-arm.rs:23:34: 23:49\n+      let _2: u8;                          // in scope 0 at $DIR/simplify-arm.rs:24:9: 24:10\n+      let mut _3: std::result::Result<u8, i32>; // in scope 0 at $DIR/simplify-arm.rs:24:13: 24:15\n+      let mut _4: std::result::Result<u8, i32>; // in scope 0 at $DIR/simplify-arm.rs:24:13: 24:14\n+      let mut _5: isize;                   // in scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+      let _6: i32;                         // in scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+      let mut _7: !;                       // in scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+      let mut _8: i32;                     // in scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+      let mut _9: i32;                     // in scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+      let _10: u8;                         // in scope 0 at $DIR/simplify-arm.rs:24:13: 24:15\n+      let mut _11: u8;                     // in scope 0 at $DIR/simplify-arm.rs:25:8: 25:9\n+      scope 1 {\n+          debug x => _2;                   // in scope 1 at $DIR/simplify-arm.rs:24:9: 24:10\n+      }\n+      scope 2 {\n+          debug err => _6;                 // in scope 2 at $DIR/simplify-arm.rs:24:14: 24:15\n+          scope 3 {\n+          }\n+      }\n+      scope 4 {\n+          debug val => _10;                // in scope 4 at $DIR/simplify-arm.rs:24:13: 24:15\n+          scope 5 {\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/simplify-arm.rs:24:9: 24:10\n+          StorageLive(_3);                 // scope 0 at $DIR/simplify-arm.rs:24:13: 24:15\n+          StorageLive(_4);                 // scope 0 at $DIR/simplify-arm.rs:24:13: 24:14\n+          _4 = _1;                         // scope 0 at $DIR/simplify-arm.rs:24:13: 24:14\n+          _3 = const <std::result::Result<u8, i32> as std::ops::Try>::into_result(move _4) -> bb1; // scope 0 at $DIR/simplify-arm.rs:24:13: 24:15\n+                                           // ty::Const\n+                                           // + ty: fn(std::result::Result<u8, i32>) -> std::result::Result<<std::result::Result<u8, i32> as std::ops::Try>::Ok, <std::result::Result<u8, i32> as std::ops::Try>::Error> {<std::result::Result<u8, i32> as std::ops::Try>::into_result}\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify-arm.rs:24:13: 24:15\n+                                           // + literal: Const { ty: fn(std::result::Result<u8, i32>) -> std::result::Result<<std::result::Result<u8, i32> as std::ops::Try>::Ok, <std::result::Result<u8, i32> as std::ops::Try>::Error> {<std::result::Result<u8, i32> as std::ops::Try>::into_result}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_4);                 // scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+          _5 = discriminant(_3);           // scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+          switchInt(move _5) -> [0isize: bb2, 1isize: bb4, otherwise: bb3]; // scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+      }\n+  \n+      bb2: {\n+          _0 = move _3;                    // scope 1 at $DIR/simplify-arm.rs:25:5: 25:10\n+          StorageDead(_3);                 // scope 0 at $DIR/simplify-arm.rs:24:15: 24:16\n+          StorageDead(_2);                 // scope 0 at $DIR/simplify-arm.rs:26:1: 26:2\n+          goto -> bb7;                     // scope 0 at $DIR/simplify-arm.rs:26:2: 26:2\n+      }\n+  \n+      bb3: {\n+          unreachable;                     // scope 0 at $DIR/simplify-arm.rs:24:13: 24:15\n+      }\n+  \n+      bb4: {\n+          StorageLive(_6);                 // scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+          _6 = ((_3 as Err).0: i32);       // scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+          StorageLive(_8);                 // scope 3 at $DIR/simplify-arm.rs:24:14: 24:15\n+          StorageLive(_9);                 // scope 3 at $DIR/simplify-arm.rs:24:14: 24:15\n+          _9 = _6;                         // scope 3 at $DIR/simplify-arm.rs:24:14: 24:15\n+          _8 = const <i32 as std::convert::From<i32>>::from(move _9) -> bb5; // scope 3 at $DIR/simplify-arm.rs:24:14: 24:15\n+                                           // ty::Const\n+                                           // + ty: fn(i32) -> i32 {<i32 as std::convert::From<i32>>::from}\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify-arm.rs:24:14: 24:15\n+                                           // + literal: Const { ty: fn(i32) -> i32 {<i32 as std::convert::From<i32>>::from}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb5: {\n+          StorageDead(_9);                 // scope 3 at $DIR/simplify-arm.rs:24:14: 24:15\n+          _0 = const <std::result::Result<u8, i32> as std::ops::Try>::from_error(move _8) -> bb6; // scope 3 at $DIR/simplify-arm.rs:24:14: 24:15\n+                                           // ty::Const\n+                                           // + ty: fn(<std::result::Result<u8, i32> as std::ops::Try>::Error) -> std::result::Result<u8, i32> {<std::result::Result<u8, i32> as std::ops::Try>::from_error}\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify-arm.rs:24:13: 24:15\n+                                           // + literal: Const { ty: fn(<std::result::Result<u8, i32> as std::ops::Try>::Error) -> std::result::Result<u8, i32> {<std::result::Result<u8, i32> as std::ops::Try>::from_error}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb6: {\n+          StorageDead(_8);                 // scope 3 at $DIR/simplify-arm.rs:24:14: 24:15\n+          StorageDead(_6);                 // scope 0 at $DIR/simplify-arm.rs:24:14: 24:15\n+          StorageDead(_3);                 // scope 0 at $DIR/simplify-arm.rs:24:15: 24:16\n+          StorageDead(_2);                 // scope 0 at $DIR/simplify-arm.rs:26:1: 26:2\n+          goto -> bb7;                     // scope 0 at $DIR/simplify-arm.rs:26:2: 26:2\n+      }\n+  \n+      bb7: {\n+          return;                          // scope 0 at $DIR/simplify-arm.rs:26:2: 26:2\n+      }\n+  }\n+  "}, {"sha": "58c5313909f6baa97f5d4417a70210a6c05c5089", "filename": "src/test/mir-opt/simplify_try/rustc.try_identity.SimplifyArmIdentity.diff", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify_try%2Frustc.try_identity.SimplifyArmIdentity.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify_try%2Frustc.try_identity.SimplifyArmIdentity.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try%2Frustc.try_identity.SimplifyArmIdentity.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -15,16 +15,16 @@\n       let _10: u32;                        // in scope 0 at $DIR/simplify_try.rs:6:13: 6:15\n       let mut _11: u32;                    // in scope 0 at $DIR/simplify_try.rs:7:8: 7:9\n       scope 1 {\n-          debug y => _10;                  // in scope 1 at $DIR/simplify_try.rs:6:9: 6:10\n+          debug y => _2;                   // in scope 1 at $DIR/simplify_try.rs:6:9: 6:10\n       }\n       scope 2 {\n           debug err => _6;                 // in scope 2 at $DIR/simplify_try.rs:6:14: 6:15\n           scope 3 {\n               scope 7 {\n-                  debug t => _6;           // in scope 7 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n+                  debug t => _9;           // in scope 7 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n               }\n               scope 8 {\n-                  debug v => _6;           // in scope 8 at $SRC_DIR/libcore/result.rs:LL:COL\n+                  debug v => _8;           // in scope 8 at $SRC_DIR/libcore/result.rs:LL:COL\n                   let mut _12: i32;        // in scope 8 at $DIR/simplify_try.rs:6:14: 6:15\n               }\n           }\n@@ -35,31 +35,54 @@\n           }\n       }\n       scope 6 {\n-          debug self => _1;                // in scope 6 at $SRC_DIR/libcore/result.rs:LL:COL\n+          debug self => _4;                // in scope 6 at $SRC_DIR/libcore/result.rs:LL:COL\n       }\n   \n       bb0: {\n-          _5 = discriminant(_1);           // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n+          StorageLive(_2);                 // scope 0 at $DIR/simplify_try.rs:6:9: 6:10\n+          StorageLive(_3);                 // scope 0 at $DIR/simplify_try.rs:6:13: 6:15\n+          StorageLive(_4);                 // scope 0 at $DIR/simplify_try.rs:6:13: 6:14\n+          _4 = _1;                         // scope 0 at $DIR/simplify_try.rs:6:13: 6:14\n+          _3 = move _4;                    // scope 6 at $SRC_DIR/libcore/result.rs:LL:COL\n+          StorageDead(_4);                 // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n+          _5 = discriminant(_3);           // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n           switchInt(move _5) -> [0isize: bb1, otherwise: bb2]; // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n       }\n   \n       bb1: {\n--         _10 = ((_1 as Ok).0: u32);       // scope 0 at $DIR/simplify_try.rs:6:13: 6:15\n--         ((_0 as Ok).0: u32) = move _10;  // scope 1 at $DIR/simplify_try.rs:7:5: 7:10\n+-         StorageLive(_10);                // scope 0 at $DIR/simplify_try.rs:6:13: 6:15\n+-         _10 = ((_3 as Ok).0: u32);       // scope 0 at $DIR/simplify_try.rs:6:13: 6:15\n+-         _2 = _10;                        // scope 5 at $DIR/simplify_try.rs:6:13: 6:15\n+-         StorageDead(_10);                // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n++         _0 = move _3;                    // scope 1 at $DIR/simplify_try.rs:7:5: 7:10\n+          StorageDead(_3);                 // scope 0 at $DIR/simplify_try.rs:6:15: 6:16\n+-         StorageLive(_11);                // scope 1 at $DIR/simplify_try.rs:7:8: 7:9\n+-         _11 = _2;                        // scope 1 at $DIR/simplify_try.rs:7:8: 7:9\n+-         ((_0 as Ok).0: u32) = move _11;  // scope 1 at $DIR/simplify_try.rs:7:5: 7:10\n -         discriminant(_0) = 0;            // scope 1 at $DIR/simplify_try.rs:7:5: 7:10\n-+         _0 = move _1;                    // scope 1 at $DIR/simplify_try.rs:7:5: 7:10\n-+         nop;                             // scope 1 at $DIR/simplify_try.rs:7:5: 7:10\n-+         nop;                             // scope 1 at $DIR/simplify_try.rs:7:5: 7:10\n+-         StorageDead(_11);                // scope 1 at $DIR/simplify_try.rs:7:9: 7:10\n+          StorageDead(_2);                 // scope 0 at $DIR/simplify_try.rs:8:1: 8:2\n           goto -> bb3;                     // scope 0 at $DIR/simplify_try.rs:8:2: 8:2\n       }\n   \n       bb2: {\n--         _6 = ((_1 as Err).0: i32);       // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n--         ((_0 as Err).0: i32) = move _6;  // scope 8 at $SRC_DIR/libcore/result.rs:LL:COL\n+-         StorageLive(_6);                 // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n+-         _6 = ((_3 as Err).0: i32);       // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n+-         StorageLive(_8);                 // scope 3 at $DIR/simplify_try.rs:6:14: 6:15\n+-         StorageLive(_9);                 // scope 3 at $DIR/simplify_try.rs:6:14: 6:15\n+-         _9 = _6;                         // scope 3 at $DIR/simplify_try.rs:6:14: 6:15\n+-         _8 = move _9;                    // scope 7 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n+-         StorageDead(_9);                 // scope 3 at $DIR/simplify_try.rs:6:14: 6:15\n+-         StorageLive(_12);                // scope 8 at $SRC_DIR/libcore/result.rs:LL:COL\n+-         _12 = move _8;                   // scope 8 at $SRC_DIR/libcore/result.rs:LL:COL\n+-         ((_0 as Err).0: i32) = move _12; // scope 8 at $SRC_DIR/libcore/result.rs:LL:COL\n -         discriminant(_0) = 1;            // scope 8 at $SRC_DIR/libcore/result.rs:LL:COL\n-+         _0 = move _1;                    // scope 8 at $SRC_DIR/libcore/result.rs:LL:COL\n-+         nop;                             // scope 8 at $SRC_DIR/libcore/result.rs:LL:COL\n-+         nop;                             // scope 8 at $SRC_DIR/libcore/result.rs:LL:COL\n+-         StorageDead(_12);                // scope 8 at $SRC_DIR/libcore/result.rs:LL:COL\n+-         StorageDead(_8);                 // scope 3 at $DIR/simplify_try.rs:6:14: 6:15\n+-         StorageDead(_6);                 // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n++         _0 = move _3;                    // scope 8 at $SRC_DIR/libcore/result.rs:LL:COL\n+          StorageDead(_3);                 // scope 0 at $DIR/simplify_try.rs:6:15: 6:16\n+          StorageDead(_2);                 // scope 0 at $DIR/simplify_try.rs:8:1: 8:2\n           goto -> bb3;                     // scope 0 at $DIR/simplify_try.rs:8:2: 8:2\n       }\n   "}, {"sha": "be61e5e2a9fff17a2f518379ded0cafb2c3df3a4", "filename": "src/test/mir-opt/simplify_try/rustc.try_identity.SimplifyBranchSame.after.mir", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify_try%2Frustc.try_identity.SimplifyBranchSame.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify_try%2Frustc.try_identity.SimplifyBranchSame.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try%2Frustc.try_identity.SimplifyBranchSame.after.mir?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -14,16 +14,16 @@ fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i\n     let _10: u32;                        // in scope 0 at $DIR/simplify_try.rs:6:13: 6:15\n     let mut _11: u32;                    // in scope 0 at $DIR/simplify_try.rs:7:8: 7:9\n     scope 1 {\n-        debug y => _10;                  // in scope 1 at $DIR/simplify_try.rs:6:9: 6:10\n+        debug y => _2;                   // in scope 1 at $DIR/simplify_try.rs:6:9: 6:10\n     }\n     scope 2 {\n         debug err => _6;                 // in scope 2 at $DIR/simplify_try.rs:6:14: 6:15\n         scope 3 {\n             scope 7 {\n-                debug t => _6;           // in scope 7 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n+                debug t => _9;           // in scope 7 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n             }\n             scope 8 {\n-                debug v => _6;           // in scope 8 at $SRC_DIR/libcore/result.rs:LL:COL\n+                debug v => _8;           // in scope 8 at $SRC_DIR/libcore/result.rs:LL:COL\n                 let mut _12: i32;        // in scope 8 at $DIR/simplify_try.rs:6:14: 6:15\n             }\n         }\n@@ -34,18 +34,24 @@ fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i\n         }\n     }\n     scope 6 {\n-        debug self => _1;                // in scope 6 at $SRC_DIR/libcore/result.rs:LL:COL\n+        debug self => _4;                // in scope 6 at $SRC_DIR/libcore/result.rs:LL:COL\n     }\n \n     bb0: {\n-        _5 = discriminant(_1);           // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n+        StorageLive(_2);                 // scope 0 at $DIR/simplify_try.rs:6:9: 6:10\n+        StorageLive(_3);                 // scope 0 at $DIR/simplify_try.rs:6:13: 6:15\n+        StorageLive(_4);                 // scope 0 at $DIR/simplify_try.rs:6:13: 6:14\n+        _4 = _1;                         // scope 0 at $DIR/simplify_try.rs:6:13: 6:14\n+        _3 = move _4;                    // scope 6 at $SRC_DIR/libcore/result.rs:LL:COL\n+        StorageDead(_4);                 // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n+        _5 = discriminant(_3);           // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n         goto -> bb1;                     // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n     }\n \n     bb1: {\n-        _0 = move _1;                    // scope 1 at $DIR/simplify_try.rs:7:5: 7:10\n-        nop;                             // scope 1 at $DIR/simplify_try.rs:7:5: 7:10\n-        nop;                             // scope 1 at $DIR/simplify_try.rs:7:5: 7:10\n+        _0 = move _3;                    // scope 1 at $DIR/simplify_try.rs:7:5: 7:10\n+        StorageDead(_3);                 // scope 0 at $DIR/simplify_try.rs:6:15: 6:16\n+        StorageDead(_2);                 // scope 0 at $DIR/simplify_try.rs:8:1: 8:2\n         goto -> bb2;                     // scope 0 at $DIR/simplify_try.rs:8:2: 8:2\n     }\n "}, {"sha": "b12036f6a03e422190c8d63cf4e8c9590bfa5e50", "filename": "src/test/mir-opt/simplify_try/rustc.try_identity.SimplifyLocals.after.mir", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify_try%2Frustc.try_identity.SimplifyLocals.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify_try%2Frustc.try_identity.SimplifyLocals.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try%2Frustc.try_identity.SimplifyLocals.after.mir?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -3,24 +3,27 @@\n fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i32> {\n     debug x => _1;                       // in scope 0 at $DIR/simplify_try.rs:5:17: 5:18\n     let mut _0: std::result::Result<u32, i32>; // return place in scope 0 at $DIR/simplify_try.rs:5:41: 5:57\n-    let _2: i32;                         // in scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n-    let _3: u32;                         // in scope 0 at $DIR/simplify_try.rs:6:13: 6:15\n+    let _2: u32;                         // in scope 0 at $DIR/simplify_try.rs:6:9: 6:10\n+    let _3: i32;                         // in scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n+    let mut _4: i32;                     // in scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n+    let mut _5: i32;                     // in scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n+    let _6: u32;                         // in scope 0 at $DIR/simplify_try.rs:6:13: 6:15\n     scope 1 {\n-        debug y => _3;                   // in scope 1 at $DIR/simplify_try.rs:6:9: 6:10\n+        debug y => _2;                   // in scope 1 at $DIR/simplify_try.rs:6:9: 6:10\n     }\n     scope 2 {\n-        debug err => _2;                 // in scope 2 at $DIR/simplify_try.rs:6:14: 6:15\n+        debug err => _3;                 // in scope 2 at $DIR/simplify_try.rs:6:14: 6:15\n         scope 3 {\n             scope 7 {\n-                debug t => _2;           // in scope 7 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n+                debug t => _5;           // in scope 7 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n             }\n             scope 8 {\n-                debug v => _2;           // in scope 8 at $SRC_DIR/libcore/result.rs:LL:COL\n+                debug v => _4;           // in scope 8 at $SRC_DIR/libcore/result.rs:LL:COL\n             }\n         }\n     }\n     scope 4 {\n-        debug val => _3;                 // in scope 4 at $DIR/simplify_try.rs:6:13: 6:15\n+        debug val => _6;                 // in scope 4 at $DIR/simplify_try.rs:6:13: 6:15\n         scope 5 {\n         }\n     }\n@@ -29,7 +32,9 @@ fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i\n     }\n \n     bb0: {\n+        StorageLive(_2);                 // scope 0 at $DIR/simplify_try.rs:6:9: 6:10\n         _0 = move _1;                    // scope 1 at $DIR/simplify_try.rs:7:5: 7:10\n+        StorageDead(_2);                 // scope 0 at $DIR/simplify_try.rs:8:1: 8:2\n         return;                          // scope 0 at $DIR/simplify_try.rs:8:2: 8:2\n     }\n }"}, {"sha": "daa961c3c8c6c042f3fa32fc9402ad439f7a3e00", "filename": "src/test/mir-opt/simplify_try_if_let.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify_try_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify_try_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try_if_let.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,40 @@\n+// compile-flags: -Zmir-opt-level=1\n+// EMIT_MIR rustc.{{impl}}-append.SimplifyArmIdentity.diff\n+\n+use std::ptr::NonNull;\n+\n+pub struct LinkedList {\n+    head: Option<NonNull<Node>>,\n+    tail: Option<NonNull<Node>>,\n+}\n+\n+pub struct Node {\n+    next: Option<NonNull<Node>>,\n+}\n+\n+impl LinkedList {\n+    pub fn new() -> Self {\n+        Self { head: None, tail: None }\n+    }\n+\n+    pub fn append(&mut self, other: &mut Self) {\n+        match self.tail {\n+            None => { },\n+            Some(mut tail) => {\n+                // `as_mut` is okay here because we have exclusive access to the entirety\n+                // of both lists.\n+                if let Some(other_head) = other.head.take() {\n+                    unsafe {\n+                        tail.as_mut().next = Some(other_head);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let mut one = LinkedList::new();\n+    let mut two = LinkedList::new();\n+    one.append(&mut two);\n+}"}, {"sha": "6ccec937b9b90f957d601a442a6f2e3c2def8573", "filename": "src/test/mir-opt/simplify_try_if_let/rustc.{{impl}}-append.SimplifyArmIdentity.diff", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify_try_if_let%2Frustc.%7B%7Bimpl%7D%7D-append.SimplifyArmIdentity.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fmir-opt%2Fsimplify_try_if_let%2Frustc.%7B%7Bimpl%7D%7D-append.SimplifyArmIdentity.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try_if_let%2Frustc.%7B%7Bimpl%7D%7D-append.SimplifyArmIdentity.diff?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,127 @@\n+- // MIR for `<impl at $DIR/simplify_try_if_let.rs:15:1: 34:2>::append` before SimplifyArmIdentity\n++ // MIR for `<impl at $DIR/simplify_try_if_let.rs:15:1: 34:2>::append` after SimplifyArmIdentity\n+  \n+  fn <impl at $DIR/simplify_try_if_let.rs:15:1: 34:2>::append(_1: &mut LinkedList, _2: &mut LinkedList) -> () {\n+      debug self => _1;                    // in scope 0 at $DIR/simplify_try_if_let.rs:20:19: 20:28\n+      debug other => _2;                   // in scope 0 at $DIR/simplify_try_if_let.rs:20:30: 20:35\n+      let mut _0: ();                      // return place in scope 0 at $DIR/simplify_try_if_let.rs:20:48: 20:48\n+      let mut _3: isize;                   // in scope 0 at $DIR/simplify_try_if_let.rs:22:13: 22:17\n+      let mut _4: std::ptr::NonNull<Node>; // in scope 0 at $DIR/simplify_try_if_let.rs:23:18: 23:26\n+      let mut _5: std::option::Option<std::ptr::NonNull<Node>>; // in scope 0 at $DIR/simplify_try_if_let.rs:26:43: 26:60\n+      let mut _6: &mut std::option::Option<std::ptr::NonNull<Node>>; // in scope 0 at $DIR/simplify_try_if_let.rs:26:43: 26:53\n+      let mut _7: isize;                   // in scope 0 at $DIR/simplify_try_if_let.rs:26:24: 26:40\n+      let mut _9: std::option::Option<std::ptr::NonNull<Node>>; // in scope 0 at $DIR/simplify_try_if_let.rs:28:46: 28:62\n+      let mut _10: std::ptr::NonNull<Node>; // in scope 0 at $DIR/simplify_try_if_let.rs:28:51: 28:61\n+      let mut _11: &mut Node;              // in scope 0 at $DIR/simplify_try_if_let.rs:28:25: 28:38\n+      let mut _12: &mut std::ptr::NonNull<Node>; // in scope 0 at $DIR/simplify_try_if_let.rs:28:25: 28:29\n+      scope 1 {\n+          debug tail => _4;                // in scope 1 at $DIR/simplify_try_if_let.rs:23:18: 23:26\n+          let _8: std::ptr::NonNull<Node>; // in scope 1 at $DIR/simplify_try_if_let.rs:26:29: 26:39\n+          scope 2 {\n+              debug other_head => _8;      // in scope 2 at $DIR/simplify_try_if_let.rs:26:29: 26:39\n+              scope 3 {\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          _3 = discriminant(((*_1).1: std::option::Option<std::ptr::NonNull<Node>>)); // scope 0 at $DIR/simplify_try_if_let.rs:22:13: 22:17\n+          switchInt(move _3) -> [0isize: bb3, 1isize: bb1, otherwise: bb2]; // scope 0 at $DIR/simplify_try_if_let.rs:22:13: 22:17\n+      }\n+  \n+      bb1: {\n+          StorageLive(_4);                 // scope 0 at $DIR/simplify_try_if_let.rs:23:18: 23:26\n+          _4 = ((((*_1).1: std::option::Option<std::ptr::NonNull<Node>>) as Some).0: std::ptr::NonNull<Node>); // scope 0 at $DIR/simplify_try_if_let.rs:23:18: 23:26\n+          StorageLive(_5);                 // scope 1 at $DIR/simplify_try_if_let.rs:26:43: 26:60\n+          StorageLive(_6);                 // scope 1 at $DIR/simplify_try_if_let.rs:26:43: 26:53\n+          _6 = &mut ((*_2).0: std::option::Option<std::ptr::NonNull<Node>>); // scope 1 at $DIR/simplify_try_if_let.rs:26:43: 26:53\n+          _5 = const std::option::Option::<std::ptr::NonNull<Node>>::take(move _6) -> bb4; // scope 1 at $DIR/simplify_try_if_let.rs:26:43: 26:60\n+                                           // ty::Const\n+                                           // + ty: for<'r> fn(&'r mut std::option::Option<std::ptr::NonNull<Node>>) -> std::option::Option<std::ptr::NonNull<Node>> {std::option::Option::<std::ptr::NonNull<Node>>::take}\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify_try_if_let.rs:26:54: 26:58\n+                                           // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<std::ptr::NonNull<Node>>) -> std::option::Option<std::ptr::NonNull<Node>> {std::option::Option::<std::ptr::NonNull<Node>>::take}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb2: {\n+          unreachable;                     // scope 0 at $DIR/simplify_try_if_let.rs:21:15: 21:24\n+      }\n+  \n+      bb3: {\n+          _0 = const ();                   // scope 0 at $DIR/simplify_try_if_let.rs:22:21: 22:24\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify_try_if_let.rs:22:21: 22:24\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          goto -> bb9;                     // scope 0 at $DIR/simplify_try_if_let.rs:21:9: 32:10\n+      }\n+  \n+      bb4: {\n+          StorageDead(_6);                 // scope 1 at $DIR/simplify_try_if_let.rs:26:59: 26:60\n+          _7 = discriminant(_5);           // scope 1 at $DIR/simplify_try_if_let.rs:26:24: 26:40\n+          switchInt(move _7) -> [1isize: bb6, otherwise: bb5]; // scope 1 at $DIR/simplify_try_if_let.rs:26:24: 26:40\n+      }\n+  \n+      bb5: {\n+          _0 = const ();                   // scope 1 at $DIR/simplify_try_if_let.rs:26:17: 30:18\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify_try_if_let.rs:26:17: 30:18\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          goto -> bb8;                     // scope 1 at $DIR/simplify_try_if_let.rs:26:17: 30:18\n+      }\n+  \n+      bb6: {\n+          StorageLive(_8);                 // scope 1 at $DIR/simplify_try_if_let.rs:26:29: 26:39\n+          _8 = ((_5 as Some).0: std::ptr::NonNull<Node>); // scope 1 at $DIR/simplify_try_if_let.rs:26:29: 26:39\n+          StorageLive(_9);                 // scope 3 at $DIR/simplify_try_if_let.rs:28:46: 28:62\n+-         StorageLive(_10);                // scope 3 at $DIR/simplify_try_if_let.rs:28:51: 28:61\n+-         _10 = _8;                        // scope 3 at $DIR/simplify_try_if_let.rs:28:51: 28:61\n+-         ((_9 as Some).0: std::ptr::NonNull<Node>) = move _10; // scope 3 at $DIR/simplify_try_if_let.rs:28:46: 28:62\n+-         discriminant(_9) = 1;            // scope 3 at $DIR/simplify_try_if_let.rs:28:46: 28:62\n+-         StorageDead(_10);                // scope 3 at $DIR/simplify_try_if_let.rs:28:61: 28:62\n++         _9 = move _5;                    // scope 3 at $DIR/simplify_try_if_let.rs:28:46: 28:62\n+          StorageLive(_11);                // scope 3 at $DIR/simplify_try_if_let.rs:28:25: 28:38\n+          StorageLive(_12);                // scope 3 at $DIR/simplify_try_if_let.rs:28:25: 28:29\n+          _12 = &mut _4;                   // scope 3 at $DIR/simplify_try_if_let.rs:28:25: 28:29\n+          _11 = const std::ptr::NonNull::<Node>::as_mut(move _12) -> bb7; // scope 3 at $DIR/simplify_try_if_let.rs:28:25: 28:38\n+                                           // ty::Const\n+                                           // + ty: for<'r> unsafe fn(&'r mut std::ptr::NonNull<Node>) -> &'r mut Node {std::ptr::NonNull::<Node>::as_mut}\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify_try_if_let.rs:28:30: 28:36\n+                                           // + literal: Const { ty: for<'r> unsafe fn(&'r mut std::ptr::NonNull<Node>) -> &'r mut Node {std::ptr::NonNull::<Node>::as_mut}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb7: {\n+          StorageDead(_12);                // scope 3 at $DIR/simplify_try_if_let.rs:28:37: 28:38\n+          ((*_11).0: std::option::Option<std::ptr::NonNull<Node>>) = move _9; // scope 3 at $DIR/simplify_try_if_let.rs:28:25: 28:62\n+          StorageDead(_9);                 // scope 3 at $DIR/simplify_try_if_let.rs:28:61: 28:62\n+          StorageDead(_11);                // scope 3 at $DIR/simplify_try_if_let.rs:28:62: 28:63\n+          _0 = const ();                   // scope 3 at $DIR/simplify_try_if_let.rs:27:21: 29:22\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify_try_if_let.rs:27:21: 29:22\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_8);                 // scope 1 at $DIR/simplify_try_if_let.rs:30:17: 30:18\n+          goto -> bb8;                     // scope 1 at $DIR/simplify_try_if_let.rs:26:17: 30:18\n+      }\n+  \n+      bb8: {\n+          StorageDead(_5);                 // scope 1 at $DIR/simplify_try_if_let.rs:31:13: 31:14\n+          StorageDead(_4);                 // scope 0 at $DIR/simplify_try_if_let.rs:32:9: 32:10\n+          goto -> bb9;                     // scope 0 at $DIR/simplify_try_if_let.rs:21:9: 32:10\n+      }\n+  \n+      bb9: {\n+          return;                          // scope 0 at $DIR/simplify_try_if_let.rs:33:6: 33:6\n+      }\n+  }\n+  "}, {"sha": "798fa29efbd2d2c1af3c63143c95bbbfa975e6c1", "filename": "src/test/rustdoc-js-std/alias-2.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Frustdoc-js-std%2Falias-2.js", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Frustdoc-js-std%2Falias-2.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Falias-2.js?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,10 +1,10 @@\n-// ignore-order\n-\n const QUERY = '+';\n \n const EXPECTED = {\n     'others': [\n         { 'path': 'std::ops', 'name': 'AddAssign' },\n         { 'path': 'std::ops', 'name': 'Add' },\n+        { 'path': 'core::ops', 'name': 'AddAssign' },\n+        { 'path': 'core::ops', 'name': 'Add' },\n     ],\n };"}, {"sha": "896808d4157808e1b0f682bd2c02d4440d0fb85c", "filename": "src/test/rustdoc-js/doc-alias.js", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Frustdoc-js%2Fdoc-alias.js", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Frustdoc-js%2Fdoc-alias.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fdoc-alias.js?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,263 @@\n+// exact-check\n+\n+const QUERY = [\n+    'StructItem',\n+    'StructFieldItem',\n+    'StructMethodItem',\n+    'ImplTraitItem',\n+    'ImplAssociatedConstItem',\n+    'ImplTraitFunction',\n+    'EnumItem',\n+    'VariantItem',\n+    'EnumMethodItem',\n+    'TypedefItem',\n+    'TraitItem',\n+    'TraitTypeItem',\n+    'AssociatedConstItem',\n+    'TraitFunctionItem',\n+    'FunctionItem',\n+    'ModuleItem',\n+    'ConstItem',\n+    'StaticItem',\n+    'UnionItem',\n+    'UnionFieldItem',\n+    'UnionMethodItem',\n+    'MacroItem',\n+];\n+\n+const EXPECTED = [\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'Struct',\n+                'alias': 'StructItem',\n+                'href': '../doc_alias/struct.Struct.html',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Struct',\n+                'name': 'field',\n+                'alias': 'StructFieldItem',\n+                'href': '../doc_alias/struct.Struct.html#structfield.field',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Struct',\n+                'name': 'method',\n+                'alias': 'StructMethodItem',\n+                'href': '../doc_alias/struct.Struct.html#method.method',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        // ImplTraitItem\n+        'others': [],\n+    },\n+    {\n+        // ImplAssociatedConstItem\n+        'others': [],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Struct',\n+                'name': 'function',\n+                'alias': 'ImplTraitFunction',\n+                'href': '../doc_alias/struct.Struct.html#method.function',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'Enum',\n+                'alias': 'EnumItem',\n+                'href': '../doc_alias/enum.Enum.html',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Enum',\n+                'name': 'Variant',\n+                'alias': 'VariantItem',\n+                'href': '../doc_alias/enum.Enum.html#variant.Variant',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Enum',\n+                'name': 'method',\n+                'alias': 'EnumMethodItem',\n+                'href': '../doc_alias/enum.Enum.html#method.method',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'Typedef',\n+                'alias': 'TypedefItem',\n+                'href': '../doc_alias/type.Typedef.html',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'Trait',\n+                'alias': 'TraitItem',\n+                'href': '../doc_alias/trait.Trait.html',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Trait',\n+                'name': 'Target',\n+                'alias': 'TraitTypeItem',\n+                'href': '../doc_alias/trait.Trait.html#associatedtype.Target',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Trait',\n+                'name': 'AssociatedConst',\n+                'alias': 'AssociatedConstItem',\n+                'href': '../doc_alias/trait.Trait.html#associatedconstant.AssociatedConst',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Trait',\n+                'name': 'function',\n+                'alias': 'TraitFunctionItem',\n+                'href': '../doc_alias/trait.Trait.html#tymethod.function',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'function',\n+                'alias': 'FunctionItem',\n+                'href': '../doc_alias/fn.function.html',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'Module',\n+                'alias': 'ModuleItem',\n+                'href': '../doc_alias/Module/index.html',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'Const',\n+                'alias': 'ConstItem',\n+                'href': '../doc_alias/constant.Const.html',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'Static',\n+                'alias': 'StaticItem',\n+                'href': '../doc_alias/static.Static.html',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'Union',\n+                'alias': 'UnionItem',\n+                'href': '../doc_alias/union.Union.html',\n+                'is_alias': true\n+            },\n+            // Not an alias!\n+            {\n+                'path': 'doc_alias::Union',\n+                'name': 'union_item',\n+                'href': '../doc_alias/union.Union.html#structfield.union_item'\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Union',\n+                'name': 'union_item',\n+                'alias': 'UnionFieldItem',\n+                'href': '../doc_alias/union.Union.html#structfield.union_item',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Union',\n+                'name': 'method',\n+                'alias': 'UnionMethodItem',\n+                'href': '../doc_alias/union.Union.html#method.method',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'Macro',\n+                'alias': 'MacroItem',\n+                'href': '../doc_alias/macro.Macro.html',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+];"}, {"sha": "84c638a199507f25aecbe9823b434d3d0f288b4f", "filename": "src/test/rustdoc-js/doc-alias.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Frustdoc-js%2Fdoc-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Frustdoc-js%2Fdoc-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fdoc-alias.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,79 @@\n+#![feature(doc_alias)]\n+\n+#[doc(alias = \"StructItem\")]\n+pub struct Struct {\n+    #[doc(alias = \"StructFieldItem\")]\n+    pub field: u32,\n+}\n+\n+impl Struct {\n+    #[doc(alias = \"StructMethodItem\")]\n+    pub fn method(&self) {}\n+}\n+\n+impl Trait for Struct {\n+    // Shouldn't be listed in aliases!\n+    #[doc(alias = \"ImplTraitItem\")]\n+    type Target = u32;\n+    // Shouldn't be listed in aliases!\n+    #[doc(alias = \"ImplAssociatedConstItem\")]\n+    const AssociatedConst: i32 = 12;\n+\n+    #[doc(alias = \"ImplTraitFunction\")]\n+    fn function() -> Self::Target { 0 }\n+}\n+\n+#[doc(alias = \"EnumItem\")]\n+pub enum Enum {\n+    #[doc(alias = \"VariantItem\")]\n+    Variant,\n+}\n+\n+impl Enum {\n+    #[doc(alias = \"EnumMethodItem\")]\n+    pub fn method(&self) {}\n+}\n+\n+#[doc(alias = \"TypedefItem\")]\n+pub type Typedef = i32;\n+\n+#[doc(alias = \"TraitItem\")]\n+pub trait Trait {\n+    #[doc(alias = \"TraitTypeItem\")]\n+    type Target;\n+    #[doc(alias = \"AssociatedConstItem\")]\n+    const AssociatedConst: i32;\n+\n+    #[doc(alias = \"TraitFunctionItem\")]\n+    fn function() -> Self::Target;\n+}\n+\n+#[doc(alias = \"FunctionItem\")]\n+pub fn function() {}\n+\n+#[doc(alias = \"ModuleItem\")]\n+pub mod Module {}\n+\n+#[doc(alias = \"ConstItem\")]\n+pub const Const: u32 = 0;\n+\n+#[doc(alias = \"StaticItem\")]\n+pub static Static: u32 = 0;\n+\n+#[doc(alias = \"UnionItem\")]\n+pub union Union {\n+    #[doc(alias = \"UnionFieldItem\")]\n+    pub union_item: u32,\n+    pub y: f32,\n+}\n+\n+impl Union {\n+    #[doc(alias = \"UnionMethodItem\")]\n+    pub fn method(&self) {}\n+}\n+\n+#[doc(alias = \"MacroItem\")]\n+#[macro_export]\n+macro_rules! Macro {\n+    () => {}\n+}"}, {"sha": "fab8406d525e5f83ca18ccd341b735ae2ad05d08", "filename": "src/test/rustdoc/intra-link-trait-impl.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Frustdoc%2Fintra-link-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Frustdoc%2Fintra-link-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-trait-impl.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,35 @@\n+#![crate_name = \"foo\"]\n+\n+// ignore-tidy-linelength\n+\n+pub struct MyStruct;\n+\n+impl MyTrait for MyStruct {\n+\n+// @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#associatedtype.AssoType'\n+\n+    /// [`AssoType`]\n+    ///\n+    /// [`AssoType`]: MyStruct::AssoType\n+    type AssoType = u32;\n+\n+// @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#associatedconstant.ASSO_CONST'\n+\n+    /// [`ASSO_CONST`]\n+    ///\n+    /// [`ASSO_CONST`]: MyStruct::ASSO_CONST\n+    const ASSO_CONST: i32 = 10;\n+\n+// @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#method.trait_fn'\n+\n+    /// [`trait_fn`]\n+    ///\n+    /// [`trait_fn`]: MyStruct::trait_fn\n+    fn trait_fn() { }\n+}\n+\n+pub trait MyTrait {\n+    type AssoType;\n+    const ASSO_CONST: i32 = 1;\n+    fn trait_fn();\n+}"}, {"sha": "11caa34d4b11426db2138f1419a05181ecfa6df1", "filename": "src/test/rustdoc/issue-32374.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Frustdoc%2Fissue-32374.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Frustdoc%2Fissue-32374.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-32374.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -10,7 +10,7 @@\n // @matches issue_32374/index.html '//*[@class=\"docblock-short\"]/text()' 'Docs'\n \n // @has issue_32374/struct.T.html '//*[@class=\"stab deprecated\"]' \\\n-//      'Deprecated since 1.0.0: text'\n+//      '\ud83d\udc4e Deprecated since 1.0.0: text'\n // @has - '<code>test</code>&nbsp;<a href=\"http://issue_url/32374\">#32374</a>'\n // @matches issue_32374/struct.T.html '//*[@class=\"stab unstable\"]' \\\n //      '\ud83d\udd2c This is a nightly-only experimental API. \\(test\\s#32374\\)$'\n@@ -20,7 +20,7 @@\n pub struct T;\n \n // @has issue_32374/struct.U.html '//*[@class=\"stab deprecated\"]' \\\n-//      'Deprecated since 1.0.0: deprecated'\n+//      '\ud83d\udc4e Deprecated since 1.0.0: deprecated'\n // @has issue_32374/struct.U.html '//*[@class=\"stab unstable\"]' \\\n //      '\ud83d\udd2c This is a nightly-only experimental API. (test #32374)'\n // @has issue_32374/struct.U.html '//details' \\"}, {"sha": "c7855729a98eee20cd78c1c566287add8db9ecee", "filename": "src/test/rustdoc/test-strikethrough.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Frustdoc%2Ftest-strikethrough.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Frustdoc%2Ftest-strikethrough.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftest-strikethrough.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,6 @@\n+#![crate_name = \"foo\"]\n+\n+// @has foo/fn.f.html\n+// @has - //del \"Y\"\n+/// ~~Y~~\n+pub fn f() {}"}, {"sha": "27fe432e96ded03ca64ece5361602bc91363b0be", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -32,7 +32,6 @@ fn main() {\n         TyKind::Never => (), //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Tuple(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Projection(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::UnnormalizedProjection(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Opaque(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Param(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Bound(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`"}, {"sha": "0486c90a5a07a4a995601902dfe3c18bc297cb97", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.stderr", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -139,58 +139,52 @@ LL |         TyKind::Projection(..) => (),\n error: usage of `ty::TyKind::<kind>`\n   --> $DIR/ty_tykind_usage.rs:35:9\n    |\n-LL |         TyKind::UnnormalizedProjection(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n-\n-error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:36:9\n-   |\n LL |         TyKind::Opaque(..) => (),\n    |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:37:9\n+  --> $DIR/ty_tykind_usage.rs:36:9\n    |\n LL |         TyKind::Param(..) => (),\n    |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:38:9\n+  --> $DIR/ty_tykind_usage.rs:37:9\n    |\n LL |         TyKind::Bound(..) => (),\n    |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:39:9\n+  --> $DIR/ty_tykind_usage.rs:38:9\n    |\n LL |         TyKind::Placeholder(..) => (),\n    |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:40:9\n+  --> $DIR/ty_tykind_usage.rs:39:9\n    |\n LL |         TyKind::Infer(..) => (),\n    |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:41:9\n+  --> $DIR/ty_tykind_usage.rs:40:9\n    |\n LL |         TyKind::Error => (),\n    |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:46:12\n+  --> $DIR/ty_tykind_usage.rs:45:12\n    |\n LL |     if let TyKind::Int(int_ty) = kind {}\n    |            ^^^^^^ help: try using ty::<kind> directly: `ty`\n \n error: usage of `ty::TyKind`\n-  --> $DIR/ty_tykind_usage.rs:48:24\n+  --> $DIR/ty_tykind_usage.rs:47:24\n    |\n LL |     fn ty_kind(ty_bad: TyKind<'_>, ty_good: Ty<'_>) {}\n    |                        ^^^^^^^^^^\n    |\n    = help: try using `Ty` instead\n \n-error: aborting due to 31 previous errors\n+error: aborting due to 30 previous errors\n "}, {"sha": "45b2889f1ca4c76d037ee1ec07609163120831da", "filename": "src/test/ui/array-slice-vec/match_arr_unknown_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Farray-slice-vec%2Fmatch_arr_unknown_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Farray-slice-vec%2Fmatch_arr_unknown_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fmatch_arr_unknown_len.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,5 +1,5 @@\n #![feature(const_generics)]\n-//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+//~^ WARN the feature `const_generics` is incomplete\n \n fn is_123<const N: usize>(x: [u32; N]) -> bool {\n     match x {"}, {"sha": "4fe8572c2d53130dfc9addddff24c8770e628af8", "filename": "src/test/ui/array-slice-vec/match_arr_unknown_len.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Farray-slice-vec%2Fmatch_arr_unknown_len.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Farray-slice-vec%2Fmatch_arr_unknown_len.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fmatch_arr_unknown_len.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,10 +1,11 @@\n-warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n   --> $DIR/match_arr_unknown_len.rs:1:12\n    |\n LL | #![feature(const_generics)]\n    |            ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n \n error[E0308]: mismatched types\n   --> $DIR/match_arr_unknown_len.rs:6:9\n@@ -13,7 +14,7 @@ LL |         [1, 2] => true,\n    |         ^^^^^^ expected `2usize`, found `N`\n    |\n    = note: expected array `[u32; 2]`\n-              found array `[u32; _]`\n+              found array `[u32; N]`\n \n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "cbacc3610dcf721c5dbbb1657ffc854c1491cb3b", "filename": "src/test/ui/associated-type-bounds/bad-bounds-on-assoc-in-trait.stderr", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -16,11 +16,13 @@ error[E0277]: `<<T as Case1>::C as std::iter::Iterator>::Item` is not an iterato\n   --> $DIR/bad-bounds-on-assoc-in-trait.rs:36:20\n    |\n LL | fn assume_case1<T: Case1>() {\n-   |                    ^^^^^   - help: consider further restricting the associated type: `where <<T as Case1>::C as std::iter::Iterator>::Item: std::iter::Iterator`\n-   |                    |\n-   |                    `<<T as Case1>::C as std::iter::Iterator>::Item` is not an iterator\n+   |                    ^^^^^ `<<T as Case1>::C as std::iter::Iterator>::Item` is not an iterator\n    |\n    = help: the trait `std::iter::Iterator` is not implemented for `<<T as Case1>::C as std::iter::Iterator>::Item`\n+help: consider further restricting the associated type\n+   |\n+LL | fn assume_case1<T: Case1>() where <<T as Case1>::C as std::iter::Iterator>::Item: std::iter::Iterator {\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be sent between threads safely\n   --> $DIR/bad-bounds-on-assoc-in-trait.rs:36:20\n@@ -32,11 +34,13 @@ LL |         Send + Iterator<Item:\n    |         ---- required by this bound in `Case1`\n ...\n LL | fn assume_case1<T: Case1>() {\n-   |                    ^^^^^   - help: consider further restricting the associated type: `where <<T as Case1>::C as std::iter::Iterator>::Item: std::marker::Send`\n-   |                    |\n-   |                    `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be sent between threads safely\n+   |                    ^^^^^ `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be sent between threads safely\n    |\n    = help: the trait `std::marker::Send` is not implemented for `<<T as Case1>::C as std::iter::Iterator>::Item`\n+help: consider further restricting the associated type\n+   |\n+LL | fn assume_case1<T: Case1>() where <<T as Case1>::C as std::iter::Iterator>::Item: std::marker::Send {\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be shared between threads safely\n   --> $DIR/bad-bounds-on-assoc-in-trait.rs:36:20\n@@ -48,11 +52,13 @@ LL |         > + Sync>;\n    |             ---- required by this bound in `Case1`\n ...\n LL | fn assume_case1<T: Case1>() {\n-   |                    ^^^^^   - help: consider further restricting the associated type: `where <<T as Case1>::C as std::iter::Iterator>::Item: std::marker::Sync`\n-   |                    |\n-   |                    `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be shared between threads safely\n+   |                    ^^^^^ `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be shared between threads safely\n    |\n    = help: the trait `std::marker::Sync` is not implemented for `<<T as Case1>::C as std::iter::Iterator>::Item`\n+help: consider further restricting the associated type\n+   |\n+LL | fn assume_case1<T: Case1>() where <<T as Case1>::C as std::iter::Iterator>::Item: std::marker::Sync {\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: `<_ as Lam<&'a u8>>::App` doesn't implement `std::fmt::Debug`\n   --> $DIR/bad-bounds-on-assoc-in-trait.rs:36:20"}, {"sha": "8b396f23efd545f5c05b0aefb66f6981f3b5bec1", "filename": "src/test/ui/associated-type-bounds/duplicate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(associated_type_bounds)]\n #![feature(type_alias_impl_trait)]\n-#![feature(impl_trait_in_bindings)] //~ WARN the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash [incomplete_features]\n+#![feature(impl_trait_in_bindings)] //~ WARN the feature `impl_trait_in_bindings` is incomplete\n #![feature(untagged_unions)]\n \n use std::iter;"}, {"sha": "71f6e4ff8b62d9eb8061948dfb63aad44cf7ee91", "filename": "src/test/ui/associated-type-bounds/duplicate.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,10 +1,11 @@\n-warning: the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n+warning: the feature `impl_trait_in_bindings` is incomplete and may not be safe to use and/or cause compiler crashes\n   --> $DIR/duplicate.rs:5:12\n    |\n LL | #![feature(impl_trait_in_bindings)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #63065 <https://github.com/rust-lang/rust/issues/63065> for more information\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:10:36"}, {"sha": "3637f9558be7bd2d5483e218f6fe517e31458000", "filename": "src/test/ui/associated-type-bounds/dyn-lcsit.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-lcsit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-lcsit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-lcsit.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,10 +1,11 @@\n-warning: the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n+warning: the feature `impl_trait_in_bindings` is incomplete and may not be safe to use and/or cause compiler crashes\n   --> $DIR/dyn-lcsit.rs:4:12\n    |\n LL | #![feature(impl_trait_in_bindings)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #63065 <https://github.com/rust-lang/rust/issues/63065> for more information\n \n warning: 1 warning emitted\n "}, {"sha": "11ff03db361470de371cb4713209bc7eb70f8dce", "filename": "src/test/ui/associated-type-bounds/lcsit.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-type-bounds%2Flcsit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-type-bounds%2Flcsit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Flcsit.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,10 +1,11 @@\n-warning: the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n+warning: the feature `impl_trait_in_bindings` is incomplete and may not be safe to use and/or cause compiler crashes\n   --> $DIR/lcsit.rs:4:12\n    |\n LL | #![feature(impl_trait_in_bindings)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #63065 <https://github.com/rust-lang/rust/issues/63065> for more information\n \n warning: 1 warning emitted\n "}, {"sha": "68ee38d16b3f3ce457ca8e350a1b28b5eb55d4ac", "filename": "src/test/ui/associated-types/associated-types-bound-failure.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-failure.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-failure.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-failure.fixed?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -14,7 +14,7 @@ pub trait GetToInt\n }\n \n fn foo<G>(g: G) -> isize\n-    where G : GetToInt, <G as GetToInt>::R: ToInt \n+    where G : GetToInt, <G as GetToInt>::R: ToInt\n {\n     ToInt::to_int(&g.get()) //~ ERROR E0277\n }"}, {"sha": "ab8909d1092baf3411cead06af2b90de50634cd3", "filename": "src/test/ui/associated-types/associated-types-bound-failure.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-failure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-failure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-failure.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -4,11 +4,13 @@ error[E0277]: the trait bound `<G as GetToInt>::R: ToInt` is not satisfied\n LL |     fn to_int(&self) -> isize;\n    |     -------------------------- required by `ToInt::to_int`\n ...\n-LL |     where G : GetToInt\n-   |                       - help: consider further restricting the associated type: `, <G as GetToInt>::R: ToInt`\n-LL | {\n LL |     ToInt::to_int(&g.get())\n    |                   ^^^^^^^^ the trait `ToInt` is not implemented for `<G as GetToInt>::R`\n+   |\n+help: consider further restricting the associated type\n+   |\n+LL |     where G : GetToInt, <G as GetToInt>::R: ToInt\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "80bbef17469db31ecb96ff0b785ab0180ca6451b", "filename": "src/test/ui/associated-types/associated-types-for-unimpl-trait.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.fixed?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -7,7 +7,7 @@ trait Get {\n }\n \n trait Other {\n-    fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) where Self: Get  {}\n+    fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) where Self: Get {}\n     //~^ ERROR the trait bound `Self: Get` is not satisfied\n }\n "}, {"sha": "6d7289bd0712ba897074def15916d9b3a83d9b34", "filename": "src/test/ui/associated-types/associated-types-for-unimpl-trait.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -2,10 +2,12 @@ error[E0277]: the trait bound `Self: Get` is not satisfied\n   --> $DIR/associated-types-for-unimpl-trait.rs:10:5\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-^^\n-   |     |                                                       |\n-   |     |                                                       help: consider further restricting `Self`: `where Self: Get`\n-   |     the trait `Get` is not implemented for `Self`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n+   |\n+help: consider further restricting `Self`\n+   |\n+LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) where Self: Get {}\n+   |                                                              ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "dfe62aa5d6b00b8e5d0ec23137ee721eeb62c42e", "filename": "src/test/ui/associated-types/associated-types-no-suitable-supertrait-2.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -2,10 +2,12 @@ error[E0277]: the trait bound `Self: Get` is not satisfied\n   --> $DIR/associated-types-no-suitable-supertrait-2.rs:17:5\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-^^\n-   |     |                                                       |\n-   |     |                                                       help: consider further restricting `Self`: `where Self: Get`\n-   |     the trait `Get` is not implemented for `Self`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n+   |\n+help: consider further restricting `Self`\n+   |\n+LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) where Self: Get {}\n+   |                                                              ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "f0f2451a1eceac5216475e92a120c398991f7e20", "filename": "src/test/ui/associated-types/associated-types-no-suitable-supertrait.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -2,10 +2,12 @@ error[E0277]: the trait bound `Self: Get` is not satisfied\n   --> $DIR/associated-types-no-suitable-supertrait.rs:17:5\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-^^\n-   |     |                                                       |\n-   |     |                                                       help: consider further restricting `Self`: `where Self: Get`\n-   |     the trait `Get` is not implemented for `Self`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n+   |\n+help: consider further restricting `Self`\n+   |\n+LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) where Self: Get {}\n+   |                                                              ^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `(T, U): Get` is not satisfied\n   --> $DIR/associated-types-no-suitable-supertrait.rs:22:5"}, {"sha": "9bc308465ebdd5291eec215eddfbeb38bdcbbffd", "filename": "src/test/ui/associated-types/associated-types-projection-to-unrelated-trait-in-method-without-default.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.fixed?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -7,7 +7,7 @@ trait Get {\n }\n \n trait Other {\n-    fn okay<U:Get>(&self, foo: U, bar: <Self as Get>::Value) where Self: Get ;\n+    fn okay<U:Get>(&self, foo: U, bar: <Self as Get>::Value) where Self: Get;\n     //~^ ERROR E0277\n }\n "}, {"sha": "4528f03c54a639b276004f2fc0eb1727ee0f770f", "filename": "src/test/ui/associated-types/associated-types-projection-to-unrelated-trait-in-method-without-default.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -2,10 +2,12 @@ error[E0277]: the trait bound `Self: Get` is not satisfied\n   --> $DIR/associated-types-projection-to-unrelated-trait-in-method-without-default.rs:10:5\n    |\n LL |     fn okay<U:Get>(&self, foo: U, bar: <Self as Get>::Value);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n-   |     |                                                       |\n-   |     |                                                       help: consider further restricting `Self`: `where Self: Get`\n-   |     the trait `Get` is not implemented for `Self`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n+   |\n+help: consider further restricting `Self`\n+   |\n+LL |     fn okay<U:Get>(&self, foo: U, bar: <Self as Get>::Value) where Self: Get;\n+   |                                                              ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "9837796e308def5a45c55b7211b60e6cf62b9061", "filename": "src/test/ui/associated-types/associated-types-unsized.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.fixed?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -6,7 +6,7 @@ trait Get {\n     fn get(&self) -> <Self as Get>::Value;\n }\n \n-fn foo<T:Get>(t: T) where <T as Get>::Value: std::marker::Sized  {\n+fn foo<T:Get>(t: T) where <T as Get>::Value: std::marker::Sized {\n     let x = t.get(); //~ ERROR the size for values of type\n }\n "}, {"sha": "6daba54ac69694a7c33a768231ce1c6b26afe5ac", "filename": "src/test/ui/associated-types/associated-types-unsized.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -1,15 +1,17 @@\n error[E0277]: the size for values of type `<T as Get>::Value` cannot be known at compilation time\n   --> $DIR/associated-types-unsized.rs:10:9\n    |\n-LL | fn foo<T:Get>(t: T) {\n-   |                    - help: consider further restricting the associated type: `where <T as Get>::Value: std::marker::Sized`\n LL |     let x = t.get();\n    |         ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `<T as Get>::Value`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: all local variables must have a statically known size\n    = help: unsized locals are gated as an unstable feature\n+help: consider further restricting the associated type\n+   |\n+LL | fn foo<T:Get>(t: T) where <T as Get>::Value: std::marker::Sized {\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "8676c1fa223193aa718dde9d21519743d595bf1c", "filename": "src/test/ui/associated-types/defaults-suitability.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-suitability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-suitability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-suitability.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -85,25 +85,29 @@ error[E0277]: the trait bound `<Self as Foo2<T>>::Baz: std::clone::Clone` is not\n   --> $DIR/defaults-suitability.rs:72:15\n    |\n LL | trait Foo2<T> {\n-   | -------------- help: consider further restricting the associated type: `where <Self as Foo2<T>>::Baz: std::clone::Clone`\n-   | |\n-   | required by `Foo2`\n+   | ------------- required by `Foo2`\n LL |     type Bar: Clone = Vec<Self::Baz>;\n    |               ^^^^^ the trait `std::clone::Clone` is not implemented for `<Self as Foo2<T>>::Baz`\n    |\n    = note: required because of the requirements on the impl of `std::clone::Clone` for `std::vec::Vec<<Self as Foo2<T>>::Baz>`\n+help: consider further restricting the associated type\n+   |\n+LL | trait Foo2<T> where <Self as Foo2<T>>::Baz: std::clone::Clone {\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `<Self as Foo25<T>>::Baz: std::clone::Clone` is not satisfied\n   --> $DIR/defaults-suitability.rs:81:15\n    |\n LL | trait Foo25<T: Clone> {\n-   | ---------------------- help: consider further restricting the associated type: `where <Self as Foo25<T>>::Baz: std::clone::Clone`\n-   | |\n-   | required by `Foo25`\n+   | --------------------- required by `Foo25`\n LL |     type Bar: Clone = Vec<Self::Baz>;\n    |               ^^^^^ the trait `std::clone::Clone` is not implemented for `<Self as Foo25<T>>::Baz`\n    |\n    = note: required because of the requirements on the impl of `std::clone::Clone` for `std::vec::Vec<<Self as Foo25<T>>::Baz>`\n+help: consider further restricting the associated type\n+   |\n+LL | trait Foo25<T: Clone> where <Self as Foo25<T>>::Baz: std::clone::Clone {\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `T: std::clone::Clone` is not satisfied\n   --> $DIR/defaults-suitability.rs:90:16"}, {"sha": "69c310766c1ccf5d5c76cb2c038ab81ed1294b82", "filename": "src/test/ui/associated-types/defaults-unsound-62211-1.stderr", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-unsound-62211-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-unsound-62211-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-unsound-62211-1.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -6,6 +6,11 @@ LL | trait UncheckedCopy: Sized {\n ...\n LL |     type Output: Copy\n    |                  ^^^^ the trait `std::marker::Copy` is not implemented for `Self`\n+   |\n+help: consider further restricting `Self`\n+   |\n+LL | trait UncheckedCopy: Sized + std::marker::Copy {\n+   |                            ^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: cannot add-assign `&'static str` to `Self`\n   --> $DIR/defaults-unsound-62211-1.rs:25:7\n@@ -17,6 +22,10 @@ LL |     + AddAssign<&'static str>\n    |       ^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `Self += &'static str`\n    |\n    = help: the trait `std::ops::AddAssign<&'static str>` is not implemented for `Self`\n+help: consider further restricting `Self`\n+   |\n+LL | trait UncheckedCopy: Sized + std::ops::AddAssign<&'static str> {\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `Self: std::ops::Deref` is not satisfied\n   --> $DIR/defaults-unsound-62211-1.rs:23:7\n@@ -26,6 +35,11 @@ LL | trait UncheckedCopy: Sized {\n ...\n LL |     + Deref<Target = str>\n    |       ^^^^^^^^^^^^^^^^^^^ the trait `std::ops::Deref` is not implemented for `Self`\n+   |\n+help: consider further restricting `Self`\n+   |\n+LL | trait UncheckedCopy: Sized + std::ops::Deref {\n+   |                            ^^^^^^^^^^^^^^^^^\n \n error[E0277]: `Self` doesn't implement `std::fmt::Display`\n   --> $DIR/defaults-unsound-62211-1.rs:28:7\n@@ -38,6 +52,10 @@ LL |     + Display = Self;\n    |\n    = help: the trait `std::fmt::Display` is not implemented for `Self`\n    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n+help: consider further restricting `Self`\n+   |\n+LL | trait UncheckedCopy: Sized + std::fmt::Display {\n+   |                            ^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: `T` doesn't implement `std::fmt::Display`\n   --> $DIR/defaults-unsound-62211-1.rs:41:9"}, {"sha": "84f0ba7529ea2cd40e41c71b92193405b546348b", "filename": "src/test/ui/associated-types/defaults-unsound-62211-2.stderr", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-unsound-62211-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-unsound-62211-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-unsound-62211-2.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -6,6 +6,11 @@ LL | trait UncheckedCopy: Sized {\n ...\n LL |     type Output: Copy\n    |                  ^^^^ the trait `std::marker::Copy` is not implemented for `Self`\n+   |\n+help: consider further restricting `Self`\n+   |\n+LL | trait UncheckedCopy: Sized + std::marker::Copy {\n+   |                            ^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: cannot add-assign `&'static str` to `Self`\n   --> $DIR/defaults-unsound-62211-2.rs:25:7\n@@ -17,6 +22,10 @@ LL |     + AddAssign<&'static str>\n    |       ^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `Self += &'static str`\n    |\n    = help: the trait `std::ops::AddAssign<&'static str>` is not implemented for `Self`\n+help: consider further restricting `Self`\n+   |\n+LL | trait UncheckedCopy: Sized + std::ops::AddAssign<&'static str> {\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `Self: std::ops::Deref` is not satisfied\n   --> $DIR/defaults-unsound-62211-2.rs:23:7\n@@ -26,6 +35,11 @@ LL | trait UncheckedCopy: Sized {\n ...\n LL |     + Deref<Target = str>\n    |       ^^^^^^^^^^^^^^^^^^^ the trait `std::ops::Deref` is not implemented for `Self`\n+   |\n+help: consider further restricting `Self`\n+   |\n+LL | trait UncheckedCopy: Sized + std::ops::Deref {\n+   |                            ^^^^^^^^^^^^^^^^^\n \n error[E0277]: `Self` doesn't implement `std::fmt::Display`\n   --> $DIR/defaults-unsound-62211-2.rs:28:7\n@@ -38,6 +52,10 @@ LL |     + Display = Self;\n    |\n    = help: the trait `std::fmt::Display` is not implemented for `Self`\n    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n+help: consider further restricting `Self`\n+   |\n+LL | trait UncheckedCopy: Sized + std::fmt::Display {\n+   |                            ^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: `T` doesn't implement `std::fmt::Display`\n   --> $DIR/defaults-unsound-62211-2.rs:41:9"}, {"sha": "82e76ff0b7cb50d2126a364ff3d832535109689d", "filename": "src/test/ui/associated-types/issue-63593.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fissue-63593.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Fissue-63593.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-63593.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -8,6 +8,10 @@ LL |     type This = Self;\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `Self`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider further restricting `Self`\n+   |\n+LL | trait MyTrait: std::marker::Sized {\n+   |              ^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "0474bf0a33944f0a5fa1ae294eaa6490c3900262", "filename": "src/test/ui/associated-types/trait-with-supertraits-needing-sized-self.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Ftrait-with-supertraits-needing-sized-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Ftrait-with-supertraits-needing-sized-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Ftrait-with-supertraits-needing-sized-self.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,11 @@\n+use std::ops::{Add, Sub, Mul, Div};\n+\n+trait ArithmeticOps: Add<Output=Self> + Sub<Output=Self> + Mul<Output=Self> + Div<Output=Self> {}\n+//~^ ERROR the size for values of type `Self` cannot be known at compilation time\n+\n+impl<T> ArithmeticOps for T where T: Add<Output=T> + Sub<Output=T> + Mul<Output=T> + Div<Output=T> {\n+    // Nothing to implement, since T already supports the other traits.\n+    // It has the functions it needs already\n+}\n+\n+fn main() {}"}, {"sha": "a37573dffff4403be106a8ca50310312c1b5424a", "filename": "src/test/ui/associated-types/trait-with-supertraits-needing-sized-self.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Ftrait-with-supertraits-needing-sized-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fassociated-types%2Ftrait-with-supertraits-needing-sized-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Ftrait-with-supertraits-needing-sized-self.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,21 @@\n+error[E0277]: the size for values of type `Self` cannot be known at compilation time\n+  --> $DIR/trait-with-supertraits-needing-sized-self.rs:3:22\n+   |\n+LL | trait ArithmeticOps: Add<Output=Self> + Sub<Output=Self> + Mul<Output=Self> + Div<Output=Self> {}\n+   |                      ^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   | \n+  ::: $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL | pub trait Add<Rhs = Self> {\n+   |               --- required by this bound in `std::ops::Add`\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `Self`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider further restricting `Self`\n+   |\n+LL | trait ArithmeticOps: Add<Output=Self> + Sub<Output=Self> + Mul<Output=Self> + Div<Output=Self> + std::marker::Sized {}\n+   |                                                                                                ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "96158fc0e0496c3d76567aa2bed84aa9530e311d", "filename": "src/test/ui/async-await/await-keyword/incorrect-syntax-suggestions.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -237,7 +237,10 @@ error[E0277]: the `?` operator can only be applied to values that implement `std\n   --> $DIR/incorrect-syntax-suggestions.rs:16:19\n    |\n LL |     let _ = await bar()?;\n-   |                   ^^^^^^ the `?` operator cannot be applied to type `impl std::future::Future`\n+   |                   ^^^^^^\n+   |                   |\n+   |                   the `?` operator cannot be applied to type `impl std::future::Future`\n+   |                   help: consider using `.await` here: `bar().await?`\n    |\n    = help: the trait `std::ops::Try` is not implemented for `impl std::future::Future`\n    = note: required by `std::ops::Try::into_result`"}, {"sha": "13b45df64eabeae90a487c58341c964c3207a067", "filename": "src/test/ui/async-await/issue-61076.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,32 @@\n+// edition:2018\n+\n+use core::future::Future;\n+use core::pin::Pin;\n+use core::task::{Context, Poll};\n+\n+struct T;\n+\n+impl Future for T {\n+    type Output = Result<(), ()>;\n+\n+    fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> {\n+        Poll::Pending\n+    }\n+}\n+\n+async fn foo() -> Result<(), ()> {\n+    Ok(())\n+}\n+\n+async fn bar() -> Result<(), ()> {\n+    foo()?; //~ ERROR the `?` operator can only be applied to values that implement `std::ops::Try`\n+    Ok(())\n+}\n+\n+async fn baz() -> Result<(), ()> {\n+    let t = T;\n+    t?; //~ ERROR the `?` operator can only be applied to values that implement `std::ops::Try`\n+    Ok(())\n+}\n+\n+fn main() {}"}, {"sha": "e71f4e7136dad26f44fef9f604ffe14ec57c30de", "filename": "src/test/ui/async-await/issue-61076.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -0,0 +1,27 @@\n+error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n+  --> $DIR/issue-61076.rs:22:5\n+   |\n+LL |     foo()?;\n+   |     ^^^^^^\n+   |     |\n+   |     the `?` operator cannot be applied to type `impl std::future::Future`\n+   |     help: consider using `.await` here: `foo().await?`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `impl std::future::Future`\n+   = note: required by `std::ops::Try::into_result`\n+\n+error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n+  --> $DIR/issue-61076.rs:28:5\n+   |\n+LL |     t?;\n+   |     ^^\n+   |     |\n+   |     the `?` operator cannot be applied to type `T`\n+   |     help: consider using `.await` here: `t.await?`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `T`\n+   = note: required by `std::ops::Try::into_result`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "f57e097c1254d3384ef3f24f0c3455dee3713df9", "filename": "src/test/ui/async-await/issue-61949-self-return-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-61949-self-return-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-61949-self-return-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61949-self-return-type.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -6,4 +6,4 @@ LL |     pub async fn new(_bar: &'a i32) -> Self {\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0754`.\n+For more information about this error, try `rustc --explain E0755`."}, {"sha": "c520a07abc17267aed29eca5c119a3fb7c315d24", "filename": "src/test/ui/async-await/try-on-option-in-async.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.rs?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -7,7 +7,8 @@ async fn an_async_block() -> u32 {\n         let x: Option<u32> = None;\n         x?; //~ ERROR the `?` operator\n         22\n-    }.await\n+    }\n+    .await\n }\n \n async fn async_closure_containing_fn() -> u32 {"}, {"sha": "700296d6747841408f8312bccdada03b1a0f0cbe", "filename": "src/test/ui/async-await/try-on-option-in-async.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f311b07c8d95b1192e585e983535de89bcbdfaa/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.stderr?ref=2f311b07c8d95b1192e585e983535de89bcbdfaa", "patch": "@@ -7,14 +7,14 @@ LL | |         let x: Option<u32> = None;\n LL | |         x?;\n    | |         ^^ cannot use the `?` operator in an async block that returns `{integer}`\n LL | |         22\n-LL | |     }.await\n+LL | |     }\n    | |_____- this function should return `Result` or `Option` to accept `?`\n    |\n    = help: the trait `std::ops::Try` is not implemented for `{integer}`\n    = note: required by `std::ops::Try::from_error`\n \n error[E0277]: the `?` operator can only be used in an async closure that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n-  --> $DIR/try-on-option-in-async.rs:16:9\n+  --> $DIR/try-on-option-in-async.rs:17:9\n    |\n LL |       let async_closure = async || {\n    |  __________________________________-\n@@ -29,7 +29,7 @@ LL | |     };\n    = note: required by `std::ops::Try::from_error`\n \n error[E0277]: the `?` operator can only be used in an async function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n-  --> $DIR/try-on-option-in-async.rs:25:5\n+  --> $DIR/try-on-option-in-async.rs:26:5\n    |\n LL |   async fn an_async_function() -> u32 {\n    |  _____________________________________-"}]}