{"sha": "728d257839ad2397e34c71f8ceda151fa579242d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyOGQyNTc4MzlhZDIzOTdlMzRjNzFmOGNlZGExNTFmYTU3OTI0MmQ=", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2020-12-15T16:43:24Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2021-01-22T16:07:27Z"}, "message": "improve diagnostics for angle args", "tree": {"sha": "b0ccbe0df018d19e954c0c3df0f3b126603125e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0ccbe0df018d19e954c0c3df0f3b126603125e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/728d257839ad2397e34c71f8ceda151fa579242d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/728d257839ad2397e34c71f8ceda151fa579242d", "html_url": "https://github.com/rust-lang/rust/commit/728d257839ad2397e34c71f8ceda151fa579242d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/728d257839ad2397e34c71f8ceda151fa579242d/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2de221b0063261140a336c448bf1421170c9a74", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2de221b0063261140a336c448bf1421170c9a74", "html_url": "https://github.com/rust-lang/rust/commit/f2de221b0063261140a336c448bf1421170c9a74"}], "stats": {"total": 78, "additions": 28, "deletions": 50}, "files": [{"sha": "f2fcce5c226622d355cda542b1ec44dd9584e6a8", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/728d257839ad2397e34c71f8ceda151fa579242d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/728d257839ad2397e34c71f8ceda151fa579242d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=728d257839ad2397e34c71f8ceda151fa579242d", "patch": "@@ -2,14 +2,13 @@ use super::ty::AllowPlus;\n use super::TokenType;\n use super::{BlockMode, Parser, PathStyle, Restrictions, SemiColonMode, SeqSep, TokenExpectType};\n \n+use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Lit, LitKind, TokenKind};\n use rustc_ast::util::parser::AssocOp;\n-use rustc_ast::{\n-    self as ast, AngleBracketedArg, AngleBracketedArgs, AnonConst, AttrVec, BinOpKind, BindingMode,\n-    Block, BlockCheckMode, Expr, ExprKind, GenericArg, Item, ItemKind, Mutability, Param, Pat,\n-    PatKind, Path, PathSegment, QSelf, Ty, TyKind,\n-};\n+use rustc_ast::{AngleBracketedArg, AngleBracketedArgs, AnonConst, AttrVec};\n+use rustc_ast::{BinOpKind, BindingMode, Block, BlockCheckMode, Expr, ExprKind, GenericArg, Item};\n+use rustc_ast::{ItemKind, Mutability, Param, Pat, PatKind, Path, PathSegment, QSelf, Ty, TyKind};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err};\n@@ -220,6 +219,7 @@ impl<'a> Parser<'a> {\n         edible: &[TokenKind],\n         inedible: &[TokenKind],\n     ) -> PResult<'a, bool /* recovered */> {\n+        debug!(\"expected_one_of_not_found(edible: {:?}, inedible: {:?})\", edible, inedible);\n         fn tokens_to_string(tokens: &[TokenType]) -> String {\n             let mut i = tokens.iter();\n             // This might be a sign we need a connect method on `Iterator`.\n@@ -245,6 +245,7 @@ impl<'a> Parser<'a> {\n             .collect::<Vec<_>>();\n         expected.sort_by_cached_key(|x| x.to_string());\n         expected.dedup();\n+\n         let expect = tokens_to_string(&expected[..]);\n         let actual = super::token_descr(&self.token);\n         let (msg_exp, (label_sp, label_exp)) = if expected.len() > 1 {\n@@ -270,6 +271,16 @@ impl<'a> Parser<'a> {\n         };\n         self.last_unexpected_token_span = Some(self.token.span);\n         let mut err = self.struct_span_err(self.token.span, &msg_exp);\n+\n+        // Add suggestion for a missing closing angle bracket if '>' is included in expected_tokens\n+        // there are unclosed angle brackets\n+        if self.unmatched_angle_bracket_count > 0\n+            && self.token.kind == TokenKind::Eq\n+            && expected.iter().any(|tok| matches!(tok, TokenType::Token(TokenKind::Gt)))\n+        {\n+            err.span_label(self.prev_token.span, \"maybe try to close unmatched angle bracket\");\n+        }\n+\n         let sp = if self.token == token::Eof {\n             // This is EOF; don't want to point at the following char, but rather the last token.\n             self.prev_token.span"}, {"sha": "d5e625a167c688ce43ba90eaa8c7ba909c1c4889", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/728d257839ad2397e34c71f8ceda151fa579242d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/728d257839ad2397e34c71f8ceda151fa579242d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=728d257839ad2397e34c71f8ceda151fa579242d", "patch": "@@ -272,7 +272,7 @@ impl TokenCursor {\n     }\n }\n \n-#[derive(Clone, PartialEq)]\n+#[derive(Debug, Clone, PartialEq)]\n enum TokenType {\n     Token(TokenKind),\n     Keyword(Symbol),"}, {"sha": "4234740b2b15f19ce9829b4744a7568d6d4f5bf0", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 11, "deletions": 44, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/728d257839ad2397e34c71f8ceda151fa579242d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/728d257839ad2397e34c71f8ceda151fa579242d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=728d257839ad2397e34c71f8ceda151fa579242d", "patch": "@@ -185,7 +185,6 @@ impl<'a> Parser<'a> {\n \n     pub(super) fn parse_path_segment(&mut self, style: PathStyle) -> PResult<'a, PathSegment> {\n         let ident = self.parse_path_segment_ident()?;\n-\n         let is_args_start = |token: &Token| {\n             matches!(\n                 token.kind,\n@@ -420,7 +419,10 @@ impl<'a> Parser<'a> {\n         match arg {\n             Some(arg) => {\n                 if self.check(&token::Colon) | self.check(&token::Eq) {\n-                    let (ident, gen_args) = self.get_ident_from_generic_arg(arg, lo)?;\n+                    let (ident, gen_args) = match self.get_ident_from_generic_arg(arg) {\n+                        Ok(ident_gen_args) => ident_gen_args,\n+                        Err(arg) => return Ok(Some(AngleBracketedArg::Arg(arg))),\n+                    };\n                     let kind = if self.eat(&token::Colon) {\n                         // Parse associated type constraint bound.\n \n@@ -561,50 +563,15 @@ impl<'a> Parser<'a> {\n     fn get_ident_from_generic_arg(\n         &self,\n         gen_arg: GenericArg,\n-        lo: Span,\n-    ) -> PResult<'a, (Ident, Option<GenericArgs>)> {\n-        let gen_arg_span = gen_arg.span();\n-        match gen_arg {\n-            GenericArg::Type(t) => match t.into_inner().kind {\n-                ast::TyKind::Path(qself, mut path) => {\n-                    if let Some(qself) = qself {\n-                        let mut err = self.struct_span_err(\n-                            gen_arg_span,\n-                            \"qualified paths cannot be used in associated type constraints\",\n-                        );\n-                        err.span_label(\n-                            qself.path_span,\n-                            \"not allowed in associated type constraints\",\n-                        );\n-                        return Err(err);\n-                    }\n-                    if path.segments.len() == 1 {\n-                        let path_seg = path.segments.remove(0);\n-                        let ident = path_seg.ident;\n-                        let gen_args = path_seg.args.map(|args| args.into_inner());\n-                        return Ok((ident, gen_args));\n-                    }\n-                    let err = self.struct_span_err(\n-                        path.span,\n-                        \"paths with multiple segments cannot be used in associated type constraints\",\n-                    );\n-                    return Err(err);\n-                }\n-                _ => {\n-                    let span = lo.to(self.prev_token.span);\n-                    let err = self.struct_span_err(\n-                        span,\n-                        \"only path types can be used in associated type constraints\",\n-                    );\n-                    return Err(err);\n+    ) -> Result<(Ident, Option<GenericArgs>), GenericArg> {\n+        if let GenericArg::Type(ty) = &gen_arg {\n+            if let ast::TyKind::Path(qself, path) = &ty.kind {\n+                if qself.is_none() && path.segments.len() == 1 {\n+                    let seg = &path.segments[0];\n+                    return Ok((seg.ident, seg.args.as_deref().cloned()));\n                 }\n-            },\n-            _ => {\n-                let span = lo.to(self.prev_token.span);\n-                let err = self\n-                    .struct_span_err(span, \"only types can be used in associated type constraints\");\n-                return Err(err);\n             }\n         }\n+        Err(gen_arg)\n     }\n }"}]}