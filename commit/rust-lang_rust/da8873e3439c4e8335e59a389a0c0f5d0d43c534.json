{"sha": "da8873e3439c4e8335e59a389a0c0f5d0d43c534", "node_id": "C_kwDOAAsO6NoAKGRhODg3M2UzNDM5YzRlODMzNWU1OWEzODlhMGMwZjVkMGQ0M2M1MzQ", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2021-10-14T19:15:44Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2021-10-20T15:10:46Z"}, "message": "Only assemble_candidates_from_impls for polarity Negative", "tree": {"sha": "d8c9cb638478f1f723863d53b1e97aa0d7e660bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8c9cb638478f1f723863d53b1e97aa0d7e660bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da8873e3439c4e8335e59a389a0c0f5d0d43c534", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF0ntrgrd9qf9uuThgTGiTgx5768FAmFwMXYACgkQgTGiTgx5\n768Bsw//azpnZ/nOyTajU8Tw2JjWzkfilFhXPFw1pddwjf6FUSrzZdc/0y4eLRLI\nZV9c5y2NgdOoZu+12uX1oeMjdThcIjcQDcZJbel3u4HdFqyoQERFG4FzeKgiAxbv\n3gQ5IAWHR6nSquYp+YLP+jPeyxD1kvNhpbj8ACZ1/+X4wWbn0Ip9TmcFf87WLprw\n29jXglej8b66ciuotlY0pxZs27SnJLDbTyior1aYykbs0XvwdbAbemkfBaO0vga+\nW3S4XOzjAMBmCJOMreca8IHxX7CgS7KLG/NeiXMTkunbmUAIUKjStMNe290ieXZm\nu92omXfmb1o+1ZsS+yUqKLe8cyhiGyP5TF1x7vBbrlLpwxppyKcC8oO0WbpQX0G7\nrCbFa5tAOLXUIk3gyfI19v3JTzKG2++KIVz2XH5OsNr7I1+wicYAqy5o5L35eeTG\nsUI9h0aP66KH9kbAP4YHmDKk+UiDW1DHc89tSrsB5aqB1sYbD9xgl2JJGtQcoGlv\ndncOZD6rF0LqxmLET15FkXbWoCgIyPsMbD0ru77tv1S6JgpiSuOnL85srA6IaFs+\nVvdnLJeAIGiNLb+74BT7gRa0mnvWQZ5AvfEsCHjBmCQWTERzA6ZxhRHLtdrpfAKh\nkHcF+LnpPAseq7XF4pNlHRLk8TLOFwQz8XIOIgg8ZcjjBP7abTA=\n=0ldi\n-----END PGP SIGNATURE-----", "payload": "tree d8c9cb638478f1f723863d53b1e97aa0d7e660bf\nparent 511076a102ec6e9a6d19233eeb661d60f40dd821\nauthor Santiago Pastorino <spastorino@gmail.com> 1634238944 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1634742646 -0300\n\nOnly assemble_candidates_from_impls for polarity Negative\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da8873e3439c4e8335e59a389a0c0f5d0d43c534", "html_url": "https://github.com/rust-lang/rust/commit/da8873e3439c4e8335e59a389a0c0f5d0d43c534", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da8873e3439c4e8335e59a389a0c0f5d0d43c534/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "511076a102ec6e9a6d19233eeb661d60f40dd821", "url": "https://api.github.com/repos/rust-lang/rust/commits/511076a102ec6e9a6d19233eeb661d60f40dd821", "html_url": "https://github.com/rust-lang/rust/commit/511076a102ec6e9a6d19233eeb661d60f40dd821"}], "stats": {"total": 155, "additions": 75, "deletions": 80}, "files": [{"sha": "b46d35f061edc0979df6060b6498c4bf59d5ff4b", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 62, "deletions": 58, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/da8873e3439c4e8335e59a389a0c0f5d0d43c534/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da8873e3439c4e8335e59a389a0c0f5d0d43c534/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=da8873e3439c4e8335e59a389a0c0f5d0d43c534", "patch": "@@ -254,68 +254,72 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let mut candidates = SelectionCandidateSet { vec: Vec::new(), ambiguous: false };\n \n-        self.assemble_candidates_for_trait_alias(obligation, &mut candidates);\n-\n-        // Other bounds. Consider both in-scope bounds from fn decl\n-        // and applicable impls. There is a certain set of precedence rules here.\n-        let def_id = obligation.predicate.def_id();\n-        let lang_items = self.tcx().lang_items();\n-\n-        if lang_items.copy_trait() == Some(def_id) {\n-            debug!(obligation_self_ty = ?obligation.predicate.skip_binder().self_ty());\n-\n-            // User-defined copy impls are permitted, but only for\n-            // structs and enums.\n+        if obligation.predicate.skip_binder().polarity == ty::ImplPolarity::Negative {\n             self.assemble_candidates_from_impls(obligation, &mut candidates);\n-\n-            // For other types, we'll use the builtin rules.\n-            let copy_conditions = self.copy_clone_conditions(obligation);\n-            self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates);\n-        } else if lang_items.discriminant_kind_trait() == Some(def_id) {\n-            // `DiscriminantKind` is automatically implemented for every type.\n-            candidates.vec.push(DiscriminantKindCandidate);\n-        } else if lang_items.pointee_trait() == Some(def_id) {\n-            // `Pointee` is automatically implemented for every type.\n-            candidates.vec.push(PointeeCandidate);\n-        } else if lang_items.sized_trait() == Some(def_id) {\n-            // Sized is never implementable by end-users, it is\n-            // always automatically computed.\n-            let sized_conditions = self.sized_conditions(obligation);\n-            self.assemble_builtin_bound_candidates(sized_conditions, &mut candidates);\n-        } else if lang_items.unsize_trait() == Some(def_id) {\n-            self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n-        } else if lang_items.drop_trait() == Some(def_id)\n-            && obligation.predicate.skip_binder().constness == ty::BoundConstness::ConstIfConst\n-        {\n-            if self.is_in_const_context {\n-                self.assemble_const_drop_candidates(obligation, &mut candidates)?;\n-            } else {\n-                debug!(\"passing ~const Drop bound; in non-const context\");\n-                // `~const Drop` when we are not in a const context has no effect.\n-                candidates.vec.push(ConstDropCandidate)\n-            }\n         } else {\n-            if lang_items.clone_trait() == Some(def_id) {\n-                // Same builtin conditions as `Copy`, i.e., every type which has builtin support\n-                // for `Copy` also has builtin support for `Clone`, and tuples/arrays of `Clone`\n-                // types have builtin support for `Clone`.\n-                let clone_conditions = self.copy_clone_conditions(obligation);\n-                self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates);\n-            }\n+            self.assemble_candidates_for_trait_alias(obligation, &mut candidates);\n+\n+            // Other bounds. Consider both in-scope bounds from fn decl\n+            // and applicable impls. There is a certain set of precedence rules here.\n+            let def_id = obligation.predicate.def_id();\n+            let lang_items = self.tcx().lang_items();\n+\n+            if lang_items.copy_trait() == Some(def_id) {\n+                debug!(obligation_self_ty = ?obligation.predicate.skip_binder().self_ty());\n+\n+                // User-defined copy impls are permitted, but only for\n+                // structs and enums.\n+                self.assemble_candidates_from_impls(obligation, &mut candidates);\n+\n+                // For other types, we'll use the builtin rules.\n+                let copy_conditions = self.copy_clone_conditions(obligation);\n+                self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates);\n+            } else if lang_items.discriminant_kind_trait() == Some(def_id) {\n+                // `DiscriminantKind` is automatically implemented for every type.\n+                candidates.vec.push(DiscriminantKindCandidate);\n+            } else if lang_items.pointee_trait() == Some(def_id) {\n+                // `Pointee` is automatically implemented for every type.\n+                candidates.vec.push(PointeeCandidate);\n+            } else if lang_items.sized_trait() == Some(def_id) {\n+                // Sized is never implementable by end-users, it is\n+                // always automatically computed.\n+                let sized_conditions = self.sized_conditions(obligation);\n+                self.assemble_builtin_bound_candidates(sized_conditions, &mut candidates);\n+            } else if lang_items.unsize_trait() == Some(def_id) {\n+                self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n+            } else if lang_items.drop_trait() == Some(def_id)\n+                && obligation.predicate.skip_binder().constness == ty::BoundConstness::ConstIfConst\n+            {\n+                if self.is_in_const_context {\n+                    self.assemble_const_drop_candidates(obligation, &mut candidates)?;\n+                } else {\n+                    debug!(\"passing ~const Drop bound; in non-const context\");\n+                    // `~const Drop` when we are not in a const context has no effect.\n+                    candidates.vec.push(ConstDropCandidate)\n+                }\n+            } else {\n+                if lang_items.clone_trait() == Some(def_id) {\n+                    // Same builtin conditions as `Copy`, i.e., every type which has builtin support\n+                    // for `Copy` also has builtin support for `Clone`, and tuples/arrays of `Clone`\n+                    // types have builtin support for `Clone`.\n+                    let clone_conditions = self.copy_clone_conditions(obligation);\n+                    self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates);\n+                }\n \n-            self.assemble_generator_candidates(obligation, &mut candidates);\n-            self.assemble_closure_candidates(obligation, &mut candidates);\n-            self.assemble_fn_pointer_candidates(obligation, &mut candidates);\n-            self.assemble_candidates_from_impls(obligation, &mut candidates);\n-            self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n-        }\n+                self.assemble_generator_candidates(obligation, &mut candidates);\n+                self.assemble_closure_candidates(obligation, &mut candidates);\n+                self.assemble_fn_pointer_candidates(obligation, &mut candidates);\n+                self.assemble_candidates_from_impls(obligation, &mut candidates);\n+                self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n+            }\n \n-        self.assemble_candidates_from_projected_tys(obligation, &mut candidates);\n-        self.assemble_candidates_from_caller_bounds(stack, &mut candidates)?;\n-        // Auto implementations have lower priority, so we only\n-        // consider triggering a default if there is no other impl that can apply.\n-        if candidates.vec.is_empty() {\n-            self.assemble_candidates_from_auto_impls(obligation, &mut candidates);\n+            self.assemble_candidates_from_projected_tys(obligation, &mut candidates);\n+            self.assemble_candidates_from_caller_bounds(stack, &mut candidates)?;\n+            // Auto implementations have lower priority, so we only\n+            // consider triggering a default if there is no other impl that can apply.\n+            if candidates.vec.is_empty() {\n+                self.assemble_candidates_from_auto_impls(obligation, &mut candidates);\n+            }\n         }\n         debug!(\"candidate list size: {}\", candidates.vec.len());\n         Ok(candidates)"}, {"sha": "c36ac08579b7798a85b8a935bd1e48acc5ee3c48", "filename": "src/test/ui/traits/cache-reached-depth-ice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da8873e3439c4e8335e59a389a0c0f5d0d43c534/src%2Ftest%2Fui%2Ftraits%2Fcache-reached-depth-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da8873e3439c4e8335e59a389a0c0f5d0d43c534/src%2Ftest%2Fui%2Ftraits%2Fcache-reached-depth-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcache-reached-depth-ice.rs?ref=da8873e3439c4e8335e59a389a0c0f5d0d43c534", "patch": "@@ -41,5 +41,5 @@ fn test<X: ?Sized + Send>() {}\n \n fn main() {\n     test::<A>();\n-    //~^ ERROR evaluate(Binder(TraitPredicate(<A as std::marker::Send>), [])) = Ok(EvaluatedToOk)\n+    //~^ ERROR evaluate(Binder(TraitPredicate(<A as std::marker::Send>, polarity:Positive), [])) = Ok(EvaluatedToOk)\n }"}, {"sha": "082aa0f5cd93ef74d663f9537b343acc88994c3a", "filename": "src/test/ui/traits/cache-reached-depth-ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da8873e3439c4e8335e59a389a0c0f5d0d43c534/src%2Ftest%2Fui%2Ftraits%2Fcache-reached-depth-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da8873e3439c4e8335e59a389a0c0f5d0d43c534/src%2Ftest%2Fui%2Ftraits%2Fcache-reached-depth-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcache-reached-depth-ice.stderr?ref=da8873e3439c4e8335e59a389a0c0f5d0d43c534", "patch": "@@ -1,4 +1,4 @@\n-error: evaluate(Binder(TraitPredicate(<A as std::marker::Send>), [])) = Ok(EvaluatedToOk)\n+error: evaluate(Binder(TraitPredicate(<A as std::marker::Send>, polarity:Positive), [])) = Ok(EvaluatedToOk)\n   --> $DIR/cache-reached-depth-ice.rs:43:5\n    |\n LL | fn test<X: ?Sized + Send>() {}"}, {"sha": "3cd68ff6f060e9ef6cc64c8ad71f69c9a3b91a16", "filename": "src/test/ui/traits/issue-83538-tainted-cache-after-cycle.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da8873e3439c4e8335e59a389a0c0f5d0d43c534/src%2Ftest%2Fui%2Ftraits%2Fissue-83538-tainted-cache-after-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da8873e3439c4e8335e59a389a0c0f5d0d43c534/src%2Ftest%2Fui%2Ftraits%2Fissue-83538-tainted-cache-after-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-83538-tainted-cache-after-cycle.rs?ref=da8873e3439c4e8335e59a389a0c0f5d0d43c534", "patch": "@@ -57,10 +57,10 @@ fn main() {\n     // Key is that Vec<First> is \"ok\" and Third<'_, Ty> is \"ok modulo regions\":\n \n     forward();\n-    //~^ ERROR evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>), [])) = Ok(EvaluatedToOk)\n-    //~| ERROR evaluate(Binder(TraitPredicate(<Third<'_, Ty> as std::marker::Unpin>), [])) = Ok(EvaluatedToOkModuloRegions)\n+    //~^ ERROR evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>, polarity:Positive), [])) = Ok(EvaluatedToOk)\n+    //~| ERROR evaluate(Binder(TraitPredicate(<Third<'_, Ty> as std::marker::Unpin>, polarity:Positive), [])) = Ok(EvaluatedToOkModuloRegions)\n \n     reverse();\n-    //~^ ERROR evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>), [])) = Ok(EvaluatedToOk)\n-    //~| ERROR evaluate(Binder(TraitPredicate(<Third<'_, Ty> as std::marker::Unpin>), [])) = Ok(EvaluatedToOkModuloRegions)\n+    //~^ ERROR evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>, polarity:Positive), [])) = Ok(EvaluatedToOk)\n+    //~| ERROR evaluate(Binder(TraitPredicate(<Third<'_, Ty> as std::marker::Unpin>, polarity:Positive), [])) = Ok(EvaluatedToOkModuloRegions)\n }"}, {"sha": "7c4041144a4d24092de52942fea93da67ea48317", "filename": "src/test/ui/traits/issue-83538-tainted-cache-after-cycle.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da8873e3439c4e8335e59a389a0c0f5d0d43c534/src%2Ftest%2Fui%2Ftraits%2Fissue-83538-tainted-cache-after-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da8873e3439c4e8335e59a389a0c0f5d0d43c534/src%2Ftest%2Fui%2Ftraits%2Fissue-83538-tainted-cache-after-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-83538-tainted-cache-after-cycle.stderr?ref=da8873e3439c4e8335e59a389a0c0f5d0d43c534", "patch": "@@ -1,4 +1,4 @@\n-error: evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>), [])) = Ok(EvaluatedToOk)\n+error: evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>, polarity:Positive), [])) = Ok(EvaluatedToOk)\n   --> $DIR/issue-83538-tainted-cache-after-cycle.rs:59:5\n    |\n LL |     Vec<First>: Unpin,\n@@ -7,7 +7,7 @@ LL |     Vec<First>: Unpin,\n LL |     forward();\n    |     ^^^^^^^\n \n-error: evaluate(Binder(TraitPredicate(<Third<'_, Ty> as std::marker::Unpin>), [])) = Ok(EvaluatedToOkModuloRegions)\n+error: evaluate(Binder(TraitPredicate(<Third<'_, Ty> as std::marker::Unpin>, polarity:Positive), [])) = Ok(EvaluatedToOkModuloRegions)\n   --> $DIR/issue-83538-tainted-cache-after-cycle.rs:59:5\n    |\n LL |     Third<'a, Ty>: Unpin,\n@@ -16,7 +16,7 @@ LL |     Third<'a, Ty>: Unpin,\n LL |     forward();\n    |     ^^^^^^^\n \n-error: evaluate(Binder(TraitPredicate(<Third<'_, Ty> as std::marker::Unpin>), [])) = Ok(EvaluatedToOkModuloRegions)\n+error: evaluate(Binder(TraitPredicate(<Third<'_, Ty> as std::marker::Unpin>, polarity:Positive), [])) = Ok(EvaluatedToOkModuloRegions)\n   --> $DIR/issue-83538-tainted-cache-after-cycle.rs:63:5\n    |\n LL |     Third<'a, Ty>: Unpin,\n@@ -25,7 +25,7 @@ LL |     Third<'a, Ty>: Unpin,\n LL |     reverse();\n    |     ^^^^^^^\n \n-error: evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>), [])) = Ok(EvaluatedToOk)\n+error: evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>, polarity:Positive), [])) = Ok(EvaluatedToOk)\n   --> $DIR/issue-83538-tainted-cache-after-cycle.rs:63:5\n    |\n LL |     Vec<First>: Unpin,"}, {"sha": "119ac05c33e4b4442ee9c47b0c2baedbd87af17d", "filename": "src/test/ui/traits/negative-impls/rely-on-negative-impl-in-coherence.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da8873e3439c4e8335e59a389a0c0f5d0d43c534/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Frely-on-negative-impl-in-coherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da8873e3439c4e8335e59a389a0c0f5d0d43c534/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Frely-on-negative-impl-in-coherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Frely-on-negative-impl-in-coherence.rs?ref=da8873e3439c4e8335e59a389a0c0f5d0d43c534", "patch": "@@ -1,3 +1,5 @@\n+// check-pass\n+\n #![feature(negative_impls)]\n \n // aux-build: foreign_trait.rs\n@@ -16,6 +18,6 @@ use foreign_trait::ForeignTrait;\n \n trait LocalTrait { }\n impl<T: ForeignTrait> LocalTrait for T { }\n-impl LocalTrait for String { } //~ ERROR conflicting implementations\n+impl LocalTrait for String { }\n \n fn main() { }"}, {"sha": "b970ad762088d9880641bbab7c58a2115465633a", "filename": "src/test/ui/traits/negative-impls/rely-on-negative-impl-in-coherence.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/511076a102ec6e9a6d19233eeb661d60f40dd821/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Frely-on-negative-impl-in-coherence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/511076a102ec6e9a6d19233eeb661d60f40dd821/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Frely-on-negative-impl-in-coherence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Frely-on-negative-impl-in-coherence.stderr?ref=511076a102ec6e9a6d19233eeb661d60f40dd821", "patch": "@@ -1,11 +0,0 @@\n-error[E0119]: conflicting implementations of trait `LocalTrait` for type `std::string::String`\n-  --> $DIR/rely-on-negative-impl-in-coherence.rs:19:1\n-   |\n-LL | impl<T: ForeignTrait> LocalTrait for T { }\n-   | -------------------------------------- first implementation here\n-LL | impl LocalTrait for String { }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `std::string::String`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0119`."}]}