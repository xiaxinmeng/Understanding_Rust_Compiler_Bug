{"sha": "f18ae8ce7e2764b3d6f9b3c22c31163e55cac98a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxOGFlOGNlN2UyNzY0YjNkNmY5YjNjMjJjMzExNjNlNTVjYWM5OGE=", "commit": {"author": {"name": "Zack Corr", "email": "zack@z0w0.me", "date": "2013-01-18T08:31:43Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-02-16T02:04:10Z"}, "message": "rustpkg: Finish declarative compiling and fetching via git or curl (no workcache or dependency resolution yet)", "tree": {"sha": "bf9f96dcf838d81e240641c58085082504cae9a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf9f96dcf838d81e240641c58085082504cae9a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f18ae8ce7e2764b3d6f9b3c22c31163e55cac98a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f18ae8ce7e2764b3d6f9b3c22c31163e55cac98a", "html_url": "https://github.com/rust-lang/rust/commit/f18ae8ce7e2764b3d6f9b3c22c31163e55cac98a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f18ae8ce7e2764b3d6f9b3c22c31163e55cac98a/comments", "author": {"login": "z0w0", "id": 676417, "node_id": "MDQ6VXNlcjY3NjQxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/676417?v=4", "gravatar_id": "", "url": "https://api.github.com/users/z0w0", "html_url": "https://github.com/z0w0", "followers_url": "https://api.github.com/users/z0w0/followers", "following_url": "https://api.github.com/users/z0w0/following{/other_user}", "gists_url": "https://api.github.com/users/z0w0/gists{/gist_id}", "starred_url": "https://api.github.com/users/z0w0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/z0w0/subscriptions", "organizations_url": "https://api.github.com/users/z0w0/orgs", "repos_url": "https://api.github.com/users/z0w0/repos", "events_url": "https://api.github.com/users/z0w0/events{/privacy}", "received_events_url": "https://api.github.com/users/z0w0/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "220144b93cdb057cc43fa7bdcfdfbdd42bbf7cf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/220144b93cdb057cc43fa7bdcfdfbdd42bbf7cf1", "html_url": "https://github.com/rust-lang/rust/commit/220144b93cdb057cc43fa7bdcfdfbdd42bbf7cf1"}], "stats": {"total": 414, "additions": 356, "deletions": 58}, "files": [{"sha": "f95eabd584b4d6846bb890fe0a1e073f9e5c0bd9", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 344, "deletions": 54, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/f18ae8ce7e2764b3d6f9b3c22c31163e55cac98a/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f18ae8ce7e2764b3d6f9b3c22c31163e55cac98a/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=f18ae8ce7e2764b3d6f9b3c22c31163e55cac98a", "patch": "@@ -28,8 +28,10 @@ extern mod syntax(vers = \"0.6\");\n use core::*;\n use io::{ReaderUtil, WriterUtil};\n use std::getopts;\n+use std::net::url;\n+use rustc::driver::{driver, session};\n use rustc::metadata::{filesearch};\n-use syntax::{ast, codemap, parse, visit, attr};\n+use syntax::{ast, attr, codemap, diagnostic, parse, visit};\n use semver::Version;\n \n mod api;\n@@ -45,11 +47,11 @@ struct PackageScript {\n }\n \n impl PackageScript {\n-    static fn parse(parent: Path) -> PackageScript {\n+    static fn parse(parent: Path) -> Result<PackageScript, ~str> {\n         let script = parent.push(~\"package.rs\");\n \n         if !os::path_exists(&script) {\n-            fail ~\"no package.rs file\";\n+            return result::Err(~\"no package.rs file\");\n         }\n \n         let sess = parse::new_parse_sess(None);\n@@ -161,19 +163,19 @@ impl PackageScript {\n         }\n \n         if id.is_none() || vers.is_none() {\n-            fail ~\"id or vers isn't defined in a pkg attribute in package.rs\";\n+            return result::Err(~\"package's pkg attr is missing required data (id, vers)\");\n         }\n \n         let id = id.get();\n         let vers = vers.get();\n \n-        PackageScript {\n+        result::Ok(PackageScript {\n             id: id,\n             name: util::parse_id(id),\n             vers: util::parse_vers(vers),\n             crates: crates,\n             deps: deps\n-        }\n+        })\n     }\n \n     fn hash() -> ~str {\n@@ -204,51 +206,102 @@ impl Ctx {\n         util::need_dir(&root.push(~\"bin\"));\n         util::need_dir(&root.push(~\"tmp\"));\n \n+        fn sep_name_vers(in: ~str) -> (Option<~str>, Option<~str>) {\n+            let mut name = None;\n+            let mut vers = None;\n+            let parts = str::split_char(in, '@');\n+\n+            if parts.len() >= 1 {\n+                name = Some(parts[0]);\n+            } else if parts.len() >= 2 {\n+                vers = Some(parts[1]);\n+            }\n+\n+            (name, vers)\n+        }\n+\n         match cmd {\n-            ~\"build\" => self.build(args),\n-            ~\"clean\" => self.clean(args),\n-            ~\"install\" => self.install(args),\n-            ~\"prefer\" => self.prefer(args),\n-            ~\"test\" => self.test(args),\n-            ~\"uninstall\" => self.uninstall(args),\n-            ~\"unprefer\" => self.unprefer(args),\n+            ~\"build\" => self.build(),\n+            ~\"clean\" => self.clean(),\n+            ~\"install\" => {\n+                self.install(if args.len() >= 1 { Some(args[0]) }\n+                             else { None }, \n+                             if args.len() >= 2 { Some(args[1]) }\n+                             else { None }, false)\n+            }\n+            ~\"prefer\" => {\n+                if args.len() < 1 {\n+                    return usage::uninstall();\n+                }\n+\n+                let (name, vers) = sep_name_vers(args[0]);\n+\n+                self.prefer(name.get(), vers)\n+            }\n+            ~\"test\" => self.test(),\n+            ~\"uninstall\" => {\n+                if args.len() < 1 {\n+                    return usage::uninstall();\n+                }\n+\n+                let (name, vers) = sep_name_vers(args[0]);\n+\n+                self.uninstall(name.get(), vers)\n+            }\n+            ~\"unprefer\" => {\n+                if args.len() < 1 {\n+                    return usage::uninstall();\n+                }\n+\n+                let (name, vers) = sep_name_vers(args[0]);\n+\n+                self.unprefer(name.get(), vers)\n+            }\n             _ => fail ~\"reached an unhandled command\"\n         };\n     }\n \n-    fn build(_args: ~[~str]) -> bool {\n-        let script = PackageScript::parse(os::getcwd());\n-        let dir = script.work_dir();\n+    fn build() -> bool {\n+        let dir = os::getcwd();\n+        let script = match PackageScript::parse(dir) {\n+            result::Ok(script) => script,\n+            result::Err(err) => {\n+                util::error(err);\n+\n+                return false; \n+            }\n+        };\n+        let work_dir = script.work_dir();\n         let mut success = true;\n \n-        util::need_dir(&dir);\n-        util::info(fmt!(\"building %s v%s (%s)\", script.name, script.vers.to_str(),\n+        util::need_dir(&work_dir);\n+        util::note(fmt!(\"building %s v%s (%s)\", script.name, script.vers.to_str(),\n                                                 script.id));\n \n         if script.deps.len() >= 1 {\n-            util::info(~\"installing dependencies..\");\n+            util::note(~\"installing dependencies\");\n \n             for script.deps.each |&dep| {\n                 let (url, target) = dep;\n \n-                success = self.install(if target.is_none() { ~[url] }\n-                                       else { ~[url, target.get()] });\n+                success = self.install(Some(url), target, true);\n \n                 if !success { break; }\n             }\n \n+\n             if !success {\n                 util::error(fmt!(\"building %s v%s failed: a dep wasn't installed\",\n                                  script.name, script.vers.to_str()));\n \n                 return false;\n             }\n \n-            util::info(~\"installed dependencies\");\n+            util::note(~\"installed dependencies\");\n         }\n \n         for script.crates.each |&crate| {\n-            success = self.compile(&dir, crate, ~[]);\n+            success = self.compile(&work_dir, &dir.push_rel(&Path(crate)), ~[]);\n \n             if !success { break; }\n         }\n@@ -260,54 +313,175 @@ impl Ctx {\n             return false;\n         }\n \n-        util::info(fmt!(\"built %s v%s\", script.name, script.vers.to_str()));\n+        util::note(fmt!(\"built %s v%s\", script.name, script.vers.to_str()));\n \n         true\n     }\n \n-    fn compile(dir: &Path, crate: ~str, flags: ~[~str]) -> bool {\n-        util::info(~\"compiling \" + crate);\n+    fn compile(dir: &Path, crate: &Path, flags: ~[~str]) -> bool {\n+        util::note(~\"compiling \" + crate.to_str());\n+\n+        let lib_dir = dir.push(~\"lib\");\n+        let bin_dir = dir.push(~\"bin\");\n+        let binary = os::args()[0];\n+        let options: @session::options = @{\n+            binary: binary,\n+            crate_type: session::unknown_crate,\n+            .. *session::basic_options()\n+        };\n+        let input = driver::file_input(*crate);\n+        let sess = driver::build_session(options, diagnostic::emit);\n+        let cfg = driver::build_configuration(sess, binary, input);\n+        let mut outputs = driver::build_output_filenames(input, &None, &None,\n+                                                         sess);\n+        let {crate, _} = driver::compile_upto(sess, cfg, input, driver::cu_parse,\n+                                              Some(outputs));\n+\n+        let mut name = None;\n+        let mut vers = None;\n+        let mut uuid = None;\n+        let mut crate_type = None;\n+\n+        fn load_link_attr(mis: ~[@ast::meta_item]) -> (Option<~str>,\n+                                                       Option<~str>,\n+                                                       Option<~str>) {\n+            let mut name = None;\n+            let mut vers = None;\n+            let mut uuid = None;\n+\n+            for mis.each |a| {\n+                match a.node {\n+                    ast::meta_name_value(v, ast::spanned {node: ast::lit_str(s),\n+                                             span: _}) => {\n+                        match v {\n+                            ~\"name\" => name = Some(*s),\n+                            ~\"vers\" => vers = Some(*s),\n+                            ~\"uuid\" => uuid = Some(*s),\n+                            _ => { }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            (name, vers, uuid)\n+        }\n+\n+        for crate.node.attrs.each |a| {\n+            match a.node.value.node {\n+                ast::meta_name_value(v, ast::spanned {node: ast::lit_str(s),\n+                                         span: _}) => {\n+                    match v {\n+                        ~\"crate_type\" => crate_type = Some(*s),\n+                        _ => {}\n+                    }\n+                }\n+                ast::meta_list(v, mis) => {\n+                    match v {\n+                        ~\"link\" => {\n+                            let (n, v, u) = load_link_attr(mis);\n+\n+                            name = n;\n+                            vers = v;\n+                            uuid = u;\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        if name.is_none() || vers.is_none() || uuid.is_none() {\n+            util::error(~\"crate's link attr is missing required data (name, vers, uuid)\");\n+\n+            return false;\n+        }\n+\n+        let name = name.get();\n+        let vers = vers.get();\n+        let uuid = uuid.get();\n+\n+        let is_bin = match crate_type {\n+            Some(crate_type) => {\n+                match crate_type {\n+                    ~\"bin\" => true,\n+                    ~\"lib\" => false,\n+                    _ => {\n+                        util::warn(~\"unknown crate_type, falling back to lib\");\n+\n+                        false\n+                    }\n+                }\n+            }\n+            None => {\n+                util::warn(~\"missing crate_type attr, assuming lib\");\n+\n+                false\n+            }\n+        };\n+\n+        if is_bin {\n+            let hasher = hash::default_state();\n+\n+            util::need_dir(&bin_dir);\n+            hasher.write_str(name + uuid + vers);\n+\n+            let path = bin_dir.push(fmt!(\"%s-%s-%s\", name, hasher.result_str(), vers));\n+            outputs = driver::build_output_filenames(input, &None, &Some(path), sess);\n+        } else {\n+            util::need_dir(&lib_dir);\n+\n+            outputs = driver::build_output_filenames(input, &Some(lib_dir), &None,\n+                                                     sess)\n+        }\n+\n+        driver::compile_upto(sess, cfg, input, driver::cu_everything,\n+                             Some(outputs));\n \n         true\n     }\n \n-    fn clean(_args: ~[~str]) -> bool {\n-        let script = PackageScript::parse(os::getcwd());\n+    fn clean() -> bool {\n+        let script = match PackageScript::parse(os::getcwd()) {\n+            result::Ok(script) => script,\n+            result::Err(err) => {\n+                util::error(err);\n+\n+                return false;\n+            }\n+        };\n         let dir = script.work_dir();\n \n-        util::info(fmt!(\"cleaning %s v%s (%s)\", script.name, script.vers.to_str(),\n+        util::note(fmt!(\"cleaning %s v%s (%s)\", script.name, script.vers.to_str(),\n                                                 script.id));\n \n         if os::path_is_dir(&dir) {\n             if os::remove_dir(&dir) {\n-                util::info(fmt!(\"cleaned %s v%s\", script.name,\n+                util::note(fmt!(\"cleaned %s v%s\", script.name,\n                                                   script.vers.to_str()));\n             } else {\n                 util::error(fmt!(\"cleaning %s v%s failed\",\n                                  script.name, script.vers.to_str()));\n             }\n         } else {\n-            util::info(fmt!(\"cleaned %s v%s\", script.name,\n+            util::note(fmt!(\"cleaned %s v%s\", script.name,\n                                               script.vers.to_str()));\n         }\n \n         true\n     }\n \n-    fn install(args: ~[~str]) -> bool {\n-        let mut success;\n+    fn install(url: Option<~str>, target: Option<~str>, cache: bool) -> bool {\n+        let mut success = true;\n         let mut dir;\n \n-        if args.len() < 1 {\n-            util::info(~\"installing from the cwd\");\n+        if url.is_none() {\n+            util::note(~\"installing from the cwd\");\n \n             dir = os::getcwd();\n-\n-            return true;\n         } else {\n-            let url = args[0];\n-            let target = if args.len() >= 2 { Some(args[1]) }\n-                         else { None };\n+            let url = url.get();\n             let hasher = hash::default_state();\n \n             hasher.write_str(url);\n@@ -317,27 +491,39 @@ impl Ctx {\n             }\n \n             dir = util::root().push(~\"tmp\").push(hasher.result_str());\n+\n+            if cache && os::path_exists(&dir) {\n+                return true;\n+            }\n+\n             success = self.fetch(&dir, url, target);\n \n             if !success {\n                 return false;\n             }\n         }\n \n-        let script = PackageScript::parse(dir);\n-        dir = script.work_dir();\n+        let script = match PackageScript::parse(dir) {\n+            result::Ok(script) => script,\n+            result::Err(err) => {\n+                util::error(err);\n \n-        util::info(fmt!(\"installing %s v%s (%s)\", script.name, script.vers.to_str(),\n+                return false;\n+            }\n+        };\n+        let work_dir = script.work_dir();\n+\n+        util::need_dir(&work_dir);\n+        util::note(fmt!(\"installing %s v%s (%s)\", script.name, script.vers.to_str(),\n                                                   script.id));\n \n         if script.deps.len() >= 1 {\n-            util::info(~\"installing dependencies..\");\n+            util::note(~\"installing dependencies\");\n \n             for script.deps.each |&dep| {\n                 let (url, target) = dep;\n \n-                success = self.install(if target.is_none() { ~[url] }\n-                                       else { ~[url, target.get()] });\n+                success = self.install(Some(url), target, false);\n \n                 if !success { break; }\n             }\n@@ -348,11 +534,11 @@ impl Ctx {\n                 return false;\n             }\n \n-            util::info(~\"installed dependencies\");\n+            util::note(~\"installed dependencies\");\n         }\n \n         for script.crates.each |&crate| {\n-            success = self.compile(&dir, crate, ~[]);\n+            success = self.compile(&work_dir, &dir.push_rel(&Path(crate)), ~[]);\n \n             if !success { break; }\n         }\n@@ -363,31 +549,135 @@ impl Ctx {\n             return false;\n         }\n \n-        util::info(fmt!(\"installed %s v%s\", script.name,\n+        let from_bin_dir = dir.push(~\"bin\");\n+        let from_lib_dir = dir.push(~\"lib\");\n+        let to_bin_dir = util::root().push(~\"bin\");\n+        let to_lib_dir = util::root().push(~\"lib\");\n+\n+        for os::walk_dir(&from_bin_dir) |bin| {\n+            let to = to_bin_dir.push_rel(&bin.file_path());\n+\n+            os::copy_file(bin, &to);\n+        }\n+        for os::walk_dir(&from_lib_dir) |lib| {\n+            let to = to_lib_dir.push_rel(&lib.file_path());\n+\n+            os::copy_file(lib, &to);\n+        }\n+\n+        util::note(fmt!(\"installed %s v%s\", script.name,\n                                             script.vers.to_str()));\n \n         true\n     }\n \n     fn fetch(dir: &Path, url: ~str, target: Option<~str>) -> bool {\n-        util::info(fmt!(\"installing from %s\", url));\n+        let url = match url::from_str(if str::find_str(url, \"://\").is_none() { ~\"http://\" + url }\n+                                                       else { url }) {\n+            result::Ok(url) => url,\n+            result::Err(err) => {\n+                util::error(fmt!(\"failed parsing %s\", err.to_lower()));\n+\n+                return false;\n+            }\n+        };\n+        let str = url.to_str();\n+\n+        match Path(url.path).filetype() {\n+            Some(ext) => {\n+                if ext == ~\".git\" {\n+                    return self.fetch_git(dir, str, target);\n+                }\n+            }\n+            None => {}\n+        }\n+\n+        match url.scheme {\n+            ~\"git\" => self.fetch_git(dir, str, target),\n+            ~\"http\" | ~\"ftp\" | ~\"file\" => self.fetch_curl(dir, str),\n+            _ => {\n+                util::warn(~\"unknown url scheme to fetch, using curl\");\n+                self.fetch_curl(dir, str)\n+            }\n+        }\n+    }\n+\n+    fn fetch_curl(dir: &Path, url: ~str) -> bool {\n+        util::note(fmt!(\"fetching from %s using curl\", url));\n+\n+        let tar = dir.dir_path().push(&dir.file_path().to_str() + ~\".tar\");\n+\n+        if run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\", tar.to_str(), url]).status != 0 {\n+            util::error(~\"fetching failed: downloading using curl failed\");\n+\n+            return false;\n+        }\n+\n+        if run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\", ~\"-C\", dir.to_str(), ~\"-f\", tar.to_str()]).status != 0 {\n+            util::error(~\"fetching failed: extracting using tar failed (is it a valid tar archive?)\");\n+\n+            return false;\n+        }\n+\n+        true\n+    }\n+\n+    fn fetch_git(dir: &Path, url: ~str, target: Option<~str>) -> bool {\n+        util::note(fmt!(\"fetching from %s using git\", url));\n+\n+        // Git can't clone into a non-empty directory\n+        for os::walk_dir(dir) |&file| {\n+            let mut cdir = file;\n+\n+            loop {\n+                if os::path_is_dir(&cdir) {\n+                    os::remove_dir(&cdir);\n+                } else {\n+                    os::remove_file(&cdir);\n+                }\n+\n+                cdir = cdir.dir_path();\n+\n+                if cdir == *dir { break; }\n+            }\n+        }\n+\n+        if run::program_output(~\"git\", ~[~\"clone\", url, dir.to_str()]).status != 0 {\n+            util::error(~\"fetching failed: can't clone repository\");\n+\n+            return false;\n+        }\n+\n+        if !target.is_none() {\n+            let mut success = true;\n+\n+            do util::temp_change_dir(dir) {\n+                success = run::program_output(~\"git\", ~[~\"checkout\", target.get()]).status != 0\n+            }\n+\n+            if !success {\n+                util::error(~\"fetching failed: can't checkout target\");\n+\n+                return false;\n+            }\n+        }\n \n         true\n     }\n \n-    fn prefer(_args: ~[~str]) -> bool {\n+    fn prefer(name: ~str, vers: Option<~str>) -> bool {\n         true\n     }\n \n-    fn test(_args: ~[~str]) -> bool {\n+    fn test() -> bool {\n         true\n     }\n \n-    fn uninstall(_args: ~[~str]) -> bool {\n+    fn uninstall(name: ~str, vers: Option<~str>) -> bool {\n         true\n     }\n \n-    fn unprefer(_args: ~[~str]) -> bool {\n+    fn unprefer(name: ~str, vers: Option<~str>) -> bool {\n         true\n     }\n }"}, {"sha": "a46e918e3b7eb7f7098932c1b420452d9ed04aac", "filename": "src/librustpkg/usage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18ae8ce7e2764b3d6f9b3c22c31163e55cac98a/src%2Flibrustpkg%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18ae8ce7e2764b3d6f9b3c22c31163e55cac98a/src%2Flibrustpkg%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fusage.rs?ref=f18ae8ce7e2764b3d6f9b3c22c31163e55cac98a", "patch": "@@ -43,7 +43,7 @@ Examples:\n     rustpkg install\n     rustpkg install git://github.com/mozilla/servo.git\n     rustpkg install git://github.com/mozilla/servo.git v0.1.2\n-    rustpkg install http://rust-lang.org/hello-world-0.3.4.tar.gz\n+    rustpkg install http://rust-lang.org/servo-0.1.2.tar.gz\n \n Options:\n     -c, --cfg      Pass a cfg flag to the package script"}, {"sha": "67587ae93603666694ee9ad5ade8b93d465dd433", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f18ae8ce7e2764b3d6f9b3c22c31163e55cac98a/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18ae8ce7e2764b3d6f9b3c22c31163e55cac98a/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=f18ae8ce7e2764b3d6f9b3c22c31163e55cac98a", "patch": "@@ -46,15 +46,15 @@ pub fn need_dir(s: &Path) {\n     }\n }\n \n-pub fn info(msg: ~str) {\n+pub fn note(msg: ~str) {\n     let out = io::stdout();\n \n     if term::color_supported() {\n         term::fg(out, term::color_green);\n-        out.write_str(~\"info: \");\n+        out.write_str(~\"note: \");\n         term::reset(out);\n         out.write_line(msg);\n-    } else { out.write_line(~\"info: \" + msg); }\n+    } else { out.write_line(~\"note: \" + msg); }\n }\n \n pub fn warn(msg: ~str) {\n@@ -80,6 +80,14 @@ pub fn error(msg: ~str) {\n     else { out.write_line(~\"error: \" + msg); }\n }\n \n+pub fn temp_change_dir<T>(dir: &Path, cb: fn() -> T) {\n+    let cwd = os::getcwd();\n+\n+    os::change_dir(dir);\n+    cb();\n+    os::change_dir(&cwd);\n+}\n+\n #[test]\n fn test_is_cmd() {\n     assert is_cmd(~\"build\");"}]}