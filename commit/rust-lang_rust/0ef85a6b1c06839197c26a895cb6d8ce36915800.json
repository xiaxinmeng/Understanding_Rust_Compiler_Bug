{"sha": "0ef85a6b1c06839197c26a895cb6d8ce36915800", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlZjg1YTZiMWMwNjgzOTE5N2MyNmE4OTVjYjZkOGNlMzY5MTU4MDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-15T21:44:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-15T21:44:51Z"}, "message": "Auto merge of #38610 - djzin:master, r=sfackler\n\nImplementation of plan in issue #27787 for btree_range\n\nStill some ergonomics to be worked on, the ::<str,_> is particularly unsightly", "tree": {"sha": "89306186b9f4d8ee4d0d43dfdfb0fe6bffa1cb23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89306186b9f4d8ee4d0d43dfdfb0fe6bffa1cb23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ef85a6b1c06839197c26a895cb6d8ce36915800", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ef85a6b1c06839197c26a895cb6d8ce36915800", "html_url": "https://github.com/rust-lang/rust/commit/0ef85a6b1c06839197c26a895cb6d8ce36915800", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ef85a6b1c06839197c26a895cb6d8ce36915800/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c21f73e2db3ddaf29bb768fcbcd2b073554ebab1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c21f73e2db3ddaf29bb768fcbcd2b073554ebab1", "html_url": "https://github.com/rust-lang/rust/commit/c21f73e2db3ddaf29bb768fcbcd2b073554ebab1"}, {"sha": "bd04c30df78a6ffc8d6b17204cf2f1e7a2a739ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd04c30df78a6ffc8d6b17204cf2f1e7a2a739ea", "html_url": "https://github.com/rust-lang/rust/commit/bd04c30df78a6ffc8d6b17204cf2f1e7a2a739ea"}], "stats": {"total": 267, "additions": 190, "deletions": 77}, "files": [{"sha": "782a5e31d2ded8f3d0268cdcae7c505f770dfbf9", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=0ef85a6b1c06839197c26a895cb6d8ce36915800", "patch": "@@ -17,7 +17,8 @@ use core::ops::Index;\n use core::{fmt, intrinsics, mem, ptr};\n \n use borrow::Borrow;\n-use Bound::{self, Excluded, Included, Unbounded};\n+use Bound::{Excluded, Included, Unbounded};\n+use range::RangeArgument;\n \n use super::node::{self, Handle, NodeRef, marker};\n use super::search;\n@@ -654,10 +655,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         self.fix_right_edge();\n     }\n \n-    /// Constructs a double-ended iterator over a sub-range of elements in the map, starting\n-    /// at min, and ending at max. If min is `Unbounded`, then it will be treated as \"negative\n-    /// infinity\", and if max is `Unbounded`, then it will be treated as \"positive infinity\".\n-    /// Thus range(Unbounded, Unbounded) will yield the whole collection.\n+    /// Constructs a double-ended iterator over a sub-range of elements in the map.\n+    /// The simplest way is to use the range synax `min..max`, thus `range(min..max)` will\n+    /// yield elements from min (inclusive) to max (exclusive).\n+    /// The range may also be entered as `(Bound<T>, Bound<T>)`, so for example\n+    /// `range((Excluded(4), Included(10)))` will yield a left-exclusive, right-inclusive\n+    /// range from 4 to 10.\n     ///\n     /// # Examples\n     ///\n@@ -667,26 +670,25 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// #![feature(btree_range, collections_bound)]\n     ///\n     /// use std::collections::BTreeMap;\n-    /// use std::collections::Bound::{Included, Unbounded};\n+    /// use std::collections::Bound::Included;\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(3, \"a\");\n     /// map.insert(5, \"b\");\n     /// map.insert(8, \"c\");\n-    /// for (&key, &value) in map.range(Included(&4), Included(&8)) {\n+    /// for (&key, &value) in map.range((Included(&4), Included(&8))) {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n-    /// assert_eq!(Some((&5, &\"b\")), map.range(Included(&4), Unbounded).next());\n+    /// assert_eq!(Some((&5, &\"b\")), map.range(4..).next());\n     /// ```\n     #[unstable(feature = \"btree_range\",\n                reason = \"matches collection reform specification, waiting for dust to settle\",\n                issue = \"27787\")]\n-    pub fn range<Min: ?Sized + Ord, Max: ?Sized + Ord>(&self,\n-                                                       min: Bound<&Min>,\n-                                                       max: Bound<&Max>)\n-                                                       -> Range<K, V>\n-        where K: Borrow<Min> + Borrow<Max>\n+    pub fn range<T: ?Sized, R>(&self, range: R) -> Range<K, V>\n+        where T: Ord, K: Borrow<T>, R: RangeArgument<T>\n     {\n+        let min = range.start();\n+        let max = range.end();\n         let front = match min {\n             Included(key) => {\n                 match search::search_tree(self.root.as_ref(), key) {\n@@ -745,25 +747,26 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n     }\n \n-    /// Constructs a mutable double-ended iterator over a sub-range of elements in the map, starting\n-    /// at min, and ending at max. If min is `Unbounded`, then it will be treated as \"negative\n-    /// infinity\", and if max is `Unbounded`, then it will be treated as \"positive infinity\".\n-    /// Thus range(Unbounded, Unbounded) will yield the whole collection.\n+    /// Constructs a mutable double-ended iterator over a sub-range of elements in the map.\n+    /// The simplest way is to use the range synax `min..max`, thus `range(min..max)` will\n+    /// yield elements from min (inclusive) to max (exclusive).\n+    /// The range may also be entered as `(Bound<T>, Bound<T>)`, so for example\n+    /// `range((Excluded(4), Included(10)))` will yield a left-exclusive, right-inclusive\n+    /// range from 4 to 10.\n     ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(btree_range, collections_bound)]\n+    /// #![feature(btree_range)]\n     ///\n     /// use std::collections::BTreeMap;\n-    /// use std::collections::Bound::{Included, Excluded};\n     ///\n     /// let mut map: BTreeMap<&str, i32> = [\"Alice\", \"Bob\", \"Carol\", \"Cheryl\"].iter()\n     ///                                                                       .map(|&s| (s, 0))\n     ///                                                                       .collect();\n-    /// for (_, balance) in map.range_mut(Included(\"B\"), Excluded(\"Cheryl\")) {\n+    /// for (_, balance) in map.range_mut(\"B\"..\"Cheryl\") {\n     ///     *balance += 100;\n     /// }\n     /// for (name, balance) in &map {\n@@ -773,12 +776,11 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[unstable(feature = \"btree_range\",\n                reason = \"matches collection reform specification, waiting for dust to settle\",\n                issue = \"27787\")]\n-    pub fn range_mut<Min: ?Sized + Ord, Max: ?Sized + Ord>(&mut self,\n-                                                           min: Bound<&Min>,\n-                                                           max: Bound<&Max>)\n-                                                           -> RangeMut<K, V>\n-        where K: Borrow<Min> + Borrow<Max>\n+    pub fn range_mut<T: ?Sized, R>(&mut self, range: R) -> RangeMut<K, V>\n+        where T: Ord, K: Borrow<T>, R: RangeArgument<T>\n     {\n+        let min = range.start();\n+        let max = range.end();\n         let root1 = self.root.as_mut();\n         let root2 = unsafe { ptr::read(&root1) };\n "}, {"sha": "f472b593b67acf8d54c0c558e97238708804657a", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=0ef85a6b1c06839197c26a895cb6d8ce36915800", "patch": "@@ -21,7 +21,7 @@ use core::ops::{BitOr, BitAnd, BitXor, Sub};\n use borrow::Borrow;\n use btree_map::{BTreeMap, Keys};\n use super::Recover;\n-use Bound;\n+use range::RangeArgument;\n \n // FIXME(conventions): implement bounded iterators\n \n@@ -207,38 +207,37 @@ impl<T> BTreeSet<T> {\n }\n \n impl<T: Ord> BTreeSet<T> {\n-    /// Constructs a double-ended iterator over a sub-range of elements in the set, starting\n-    /// at min, and ending at max. If min is `Unbounded`, then it will be treated as \"negative\n-    /// infinity\", and if max is `Unbounded`, then it will be treated as \"positive infinity\".\n-    /// Thus range(Unbounded, Unbounded) will yield the whole collection.\n+    /// Constructs a double-ended iterator over a sub-range of elements in the set.\n+    /// The simplest way is to use the range synax `min..max`, thus `range(min..max)` will\n+    /// yield elements from min (inclusive) to max (exclusive).\n+    /// The range may also be entered as `(Bound<T>, Bound<T>)`, so for example\n+    /// `range((Excluded(4), Included(10)))` will yield a left-exclusive, right-inclusive\n+    /// range from 4 to 10.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(btree_range, collections_bound)]\n     ///\n     /// use std::collections::BTreeSet;\n-    /// use std::collections::Bound::{Included, Unbounded};\n+    /// use std::collections::Bound::Included;\n     ///\n     /// let mut set = BTreeSet::new();\n     /// set.insert(3);\n     /// set.insert(5);\n     /// set.insert(8);\n-    /// for &elem in set.range(Included(&4), Included(&8)) {\n+    /// for &elem in set.range((Included(&4), Included(&8))) {\n     ///     println!(\"{}\", elem);\n     /// }\n-    /// assert_eq!(Some(&5), set.range(Included(&4), Unbounded).next());\n+    /// assert_eq!(Some(&5), set.range(4..).next());\n     /// ```\n     #[unstable(feature = \"btree_range\",\n                reason = \"matches collection reform specification, waiting for dust to settle\",\n                issue = \"27787\")]\n-    pub fn range<'a, Min: ?Sized + Ord, Max: ?Sized + Ord>(&'a self,\n-                                                           min: Bound<&Min>,\n-                                                           max: Bound<&Max>)\n-                                                           -> Range<'a, T>\n-        where T: Borrow<Min> + Borrow<Max>\n+    pub fn range<K: ?Sized, R>(&self, range: R) -> Range<T>\n+        where K: Ord, T: Borrow<K>, R: RangeArgument<K>\n     {\n-        Range { iter: self.map.range(min, max) }\n+        Range { iter: self.map.range(range) }\n     }\n }\n "}, {"sha": "1df4ace377707d286fafc9a243a65c9557d30d12", "filename": "src/libcollections/range.rs", "status": "modified", "additions": 66, "deletions": 24, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Flibcollections%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Flibcollections%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Frange.rs?ref=0ef85a6b1c06839197c26a895cb6d8ce36915800", "patch": "@@ -15,78 +15,120 @@\n //! Range syntax.\n \n use core::ops::{RangeFull, Range, RangeTo, RangeFrom};\n+use Bound::{self, Excluded, Included, Unbounded};\n \n /// **RangeArgument** is implemented by Rust's built-in range types, produced\n /// by range syntax like `..`, `a..`, `..b` or `c..d`.\n-pub trait RangeArgument<T> {\n-    /// Start index (inclusive)\n+pub trait RangeArgument<T: ?Sized> {\n+    /// Start index bound\n     ///\n-    /// Return start value if present, else `None`.\n+    /// Return start value as a `Bound`\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(collections)]\n     /// #![feature(collections_range)]\n+    /// #![feature(collections_bound)]\n     ///\n     /// extern crate collections;\n     ///\n     /// # fn main() {\n     /// use collections::range::RangeArgument;\n+    /// use collections::Bound::*;\n     ///\n-    /// assert_eq!((..10).start(), None);\n-    /// assert_eq!((3..10).start(), Some(&3));\n+    /// assert_eq!((..10).start(), Unbounded);\n+    /// assert_eq!((3..10).start(), Included(&3));\n     /// # }\n     /// ```\n-    fn start(&self) -> Option<&T> {\n-        None\n-    }\n+    fn start(&self) -> Bound<&T>;\n \n-    /// End index (exclusive)\n+    /// End index bound\n     ///\n-    /// Return end value if present, else `None`.\n+    /// Return end value as a `Bound`\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(collections)]\n     /// #![feature(collections_range)]\n+    /// #![feature(collections_bound)]\n     ///\n     /// extern crate collections;\n     ///\n     /// # fn main() {\n     /// use collections::range::RangeArgument;\n+    /// use collections::Bound::*;\n     ///\n-    /// assert_eq!((3..).end(), None);\n-    /// assert_eq!((3..10).end(), Some(&10));\n+    /// assert_eq!((3..).end(), Unbounded);\n+    /// assert_eq!((3..10).end(), Excluded(&10));\n     /// # }\n     /// ```\n-    fn end(&self) -> Option<&T> {\n-        None\n-    }\n+    fn end(&self) -> Bound<&T>;\n }\n \n // FIXME add inclusive ranges to RangeArgument\n \n-impl<T> RangeArgument<T> for RangeFull {}\n+impl<T: ?Sized> RangeArgument<T> for RangeFull {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+}\n \n impl<T> RangeArgument<T> for RangeFrom<T> {\n-    fn start(&self) -> Option<&T> {\n-        Some(&self.start)\n+    fn start(&self) -> Bound<&T> {\n+        Included(&self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Unbounded\n     }\n }\n \n impl<T> RangeArgument<T> for RangeTo<T> {\n-    fn end(&self) -> Option<&T> {\n-        Some(&self.end)\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Excluded(&self.end)\n     }\n }\n \n impl<T> RangeArgument<T> for Range<T> {\n-    fn start(&self) -> Option<&T> {\n-        Some(&self.start)\n+    fn start(&self) -> Bound<&T> {\n+        Included(&self.start)\n     }\n-    fn end(&self) -> Option<&T> {\n-        Some(&self.end)\n+    fn end(&self) -> Bound<&T> {\n+        Excluded(&self.end)\n+    }\n+}\n+\n+impl<T> RangeArgument<T> for (Bound<T>, Bound<T>) {\n+    fn start(&self) -> Bound<&T> {\n+        match *self {\n+            (Included(ref start), _) => Included(start),\n+            (Excluded(ref start), _) => Excluded(start),\n+            (Unbounded, _)           => Unbounded,\n+        }\n+    }\n+\n+    fn end(&self) -> Bound<&T> {\n+        match *self {\n+            (_, Included(ref end)) => Included(end),\n+            (_, Excluded(ref end)) => Excluded(end),\n+            (_, Unbounded)         => Unbounded,\n+        }\n+    }\n+}\n+\n+impl<'a, T: ?Sized + 'a> RangeArgument<T> for (Bound<&'a T>, Bound<&'a T>) {\n+    fn start(&self) -> Bound<&T> {\n+        self.0\n+    }\n+\n+    fn end(&self) -> Bound<&T> {\n+        self.1\n     }\n }"}, {"sha": "5210c25b4e5c8aaca3b5b8a34613c508b3f2d2ae", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=0ef85a6b1c06839197c26a895cb6d8ce36915800", "patch": "@@ -68,6 +68,7 @@ use std_unicode::str as unicode_str;\n \n use borrow::{Cow, ToOwned};\n use range::RangeArgument;\n+use Bound::{Excluded, Included, Unbounded};\n use str::{self, FromStr, Utf8Error, Chars};\n use vec::Vec;\n use boxed::Box;\n@@ -1350,8 +1351,16 @@ impl String {\n         // Because the range removal happens in Drop, if the Drain iterator is leaked,\n         // the removal will not happen.\n         let len = self.len();\n-        let start = *range.start().unwrap_or(&0);\n-        let end = *range.end().unwrap_or(&len);\n+        let start = match range.start() {\n+            Included(&n) => n,\n+            Excluded(&n) => n + 1,\n+            Unbounded => 0,\n+        };\n+        let end = match range.end() {\n+            Included(&n) => n + 1,\n+            Excluded(&n) => n,\n+            Unbounded => len,\n+        };\n \n         // Take out two simultaneous borrows. The &mut String won't be accessed\n         // until iteration is over, in Drop."}, {"sha": "4b05f8062e8bc22a60930a6472ea01840cbb7034", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=0ef85a6b1c06839197c26a895cb6d8ce36915800", "patch": "@@ -84,6 +84,7 @@ use core::ptr::Shared;\n use core::slice;\n \n use super::range::RangeArgument;\n+use Bound::{Excluded, Included, Unbounded};\n \n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///\n@@ -1060,8 +1061,16 @@ impl<T> Vec<T> {\n         // the hole, and the vector length is restored to the new length.\n         //\n         let len = self.len();\n-        let start = *range.start().unwrap_or(&0);\n-        let end = *range.end().unwrap_or(&len);\n+        let start = match range.start() {\n+            Included(&n) => n,\n+            Excluded(&n) => n + 1,\n+            Unbounded    => 0,\n+        };\n+        let end = match range.end() {\n+            Included(&n) => n + 1,\n+            Excluded(&n) => n,\n+            Unbounded    => len,\n+        };\n         assert!(start <= end);\n         assert!(end <= len);\n "}, {"sha": "fea2d111f472eb46d6df2e3622b5edf7d76541eb", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=0ef85a6b1c06839197c26a895cb6d8ce36915800", "patch": "@@ -33,6 +33,7 @@ use core::cmp;\n use alloc::raw_vec::RawVec;\n \n use super::range::RangeArgument;\n+use Bound::{Excluded, Included, Unbounded};\n use super::vec::Vec;\n \n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n@@ -852,8 +853,16 @@ impl<T> VecDeque<T> {\n         // and the head/tail values will be restored correctly.\n         //\n         let len = self.len();\n-        let start = *range.start().unwrap_or(&0);\n-        let end = *range.end().unwrap_or(&len);\n+        let start = match range.start() {\n+            Included(&n) => n,\n+            Excluded(&n) => n + 1,\n+            Unbounded    => 0,\n+        };\n+        let end = match range.end() {\n+            Included(&n) => n + 1,\n+            Excluded(&n) => n,\n+            Unbounded    => len,\n+        };\n         assert!(start <= end, \"drain lower bound was too large\");\n         assert!(end <= len, \"drain upper bound was too large\");\n "}, {"sha": "c84753415a258ae430c2d607fb91da06e5c7510d", "filename": "src/libcollectionstest/btree/map.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmap.rs?ref=0ef85a6b1c06839197c26a895cb6d8ce36915800", "patch": "@@ -170,7 +170,7 @@ fn test_range_small() {\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     let mut j = 0;\n-    for ((&k, &v), i) in map.range(Included(&2), Unbounded).zip(2..size) {\n+    for ((&k, &v), i) in map.range(2..).zip(2..size) {\n         assert_eq!(k, i);\n         assert_eq!(v, i);\n         j += 1;\n@@ -184,7 +184,7 @@ fn test_range_1000() {\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test(map: &BTreeMap<u32, u32>, size: u32, min: Bound<&u32>, max: Bound<&u32>) {\n-        let mut kvs = map.range(min, max).map(|(&k, &v)| (k, v));\n+        let mut kvs = map.range((min, max)).map(|(&k, &v)| (k, v));\n         let mut pairs = (0..size).map(|i| (i, i));\n \n         for (kv, pair) in kvs.by_ref().zip(pairs.by_ref()) {\n@@ -201,14 +201,47 @@ fn test_range_1000() {\n     test(&map, size, Unbounded, Unbounded);\n }\n \n+#[test]\n+fn test_range_borrowed_key() {\n+    let mut map = BTreeMap::new();\n+    map.insert(\"aardvark\".to_string(), 1);\n+    map.insert(\"baboon\".to_string(), 2);\n+    map.insert(\"coyote\".to_string(), 3);\n+    map.insert(\"dingo\".to_string(), 4);\n+    // NOTE: would like to use simply \"b\"..\"d\" here...\n+    let mut iter = map.range::<str, _>((Included(\"b\"),Excluded(\"d\")));\n+    assert_eq!(iter.next(), Some((&\"baboon\".to_string(), &2)));\n+    assert_eq!(iter.next(), Some((&\"coyote\".to_string(), &3)));\n+    assert_eq!(iter.next(), None);\n+}\n+\n #[test]\n fn test_range() {\n     let size = 200;\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     for i in 0..size {\n         for j in i..size {\n-            let mut kvs = map.range(Included(&i), Included(&j)).map(|(&k, &v)| (k, v));\n+            let mut kvs = map.range((Included(&i), Included(&j))).map(|(&k, &v)| (k, v));\n+            let mut pairs = (i..j + 1).map(|i| (i, i));\n+\n+            for (kv, pair) in kvs.by_ref().zip(pairs.by_ref()) {\n+                assert_eq!(kv, pair);\n+            }\n+            assert_eq!(kvs.next(), None);\n+            assert_eq!(pairs.next(), None);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_range_mut() {\n+    let size = 200;\n+    let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+\n+    for i in 0..size {\n+        for j in i..size {\n+            let mut kvs = map.range_mut((Included(&i), Included(&j))).map(|(&k, &mut v)| (k, v));\n             let mut pairs = (i..j + 1).map(|i| (i, i));\n \n             for (kv, pair) in kvs.by_ref().zip(pairs.by_ref()) {"}, {"sha": "c0b5b7f51733039da31e0dcb02cebb36b2cb7ef7", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=0ef85a6b1c06839197c26a895cb6d8ce36915800", "patch": "@@ -19,6 +19,7 @@ use std::slice;\n use std::fmt;\n use std::mem;\n use std::collections::range::RangeArgument;\n+use std::collections::Bound::{Excluded, Included, Unbounded};\n \n pub unsafe trait Array {\n     type Element;\n@@ -119,8 +120,16 @@ impl<A: Array> ArrayVec<A> {\n         // the hole, and the vector length is restored to the new length.\n         //\n         let len = self.len();\n-        let start = *range.start().unwrap_or(&0);\n-        let end = *range.end().unwrap_or(&len);\n+        let start = match range.start() {\n+            Included(&n) => n,\n+            Excluded(&n) => n + 1,\n+            Unbounded    => 0,\n+        };\n+        let end = match range.end() {\n+            Included(&n) => n + 1,\n+            Excluded(&n) => n,\n+            Unbounded    => len,\n+        };\n         assert!(start <= end);\n         assert!(end <= len);\n "}, {"sha": "b003cba292c80b9afb22224b844c820aa1e203df", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=0ef85a6b1c06839197c26a895cb6d8ce36915800", "patch": "@@ -27,6 +27,7 @@\n \n #![feature(shared)]\n #![feature(collections_range)]\n+#![feature(collections_bound)]\n #![feature(nonzero)]\n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "d046705c94bbe3261483b73f1752a8ac52b61752", "filename": "src/test/run-pass/sync-send-iterators-in-libcollections.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef85a6b1c06839197c26a895cb6d8ce36915800/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs?ref=0ef85a6b1c06839197c26a895cb6d8ce36915800", "patch": "@@ -57,11 +57,11 @@ fn main() {\n     all_sync_send!(BinaryHeap::<usize>::new(), iter, drain, into_iter);\n \n     all_sync_send!(BTreeMap::<usize, usize>::new(), iter, iter_mut, into_iter, keys, values);\n-    is_sync_send!(BTreeMap::<usize, usize>::new(), range(Included(&0), Included(&9)));\n-    is_sync_send!(BTreeMap::<usize, usize>::new(), range_mut(Included(&0), Included(&9)));\n+    is_sync_send!(BTreeMap::<usize, usize>::new(), range((Included(&0), Included(&9))));\n+    is_sync_send!(BTreeMap::<usize, usize>::new(), range_mut((Included(&0), Included(&9))));\n \n     all_sync_send!(BTreeSet::<usize>::new(), iter, into_iter);\n-    is_sync_send!(BTreeSet::<usize>::new(), range(Included(&0), Included(&9)));\n+    is_sync_send!(BTreeSet::<usize>::new(), range((Included(&0), Included(&9))));\n     is_sync_send!(BTreeSet::<usize>::new(), difference(&BTreeSet::<usize>::new()));\n     is_sync_send!(BTreeSet::<usize>::new(), symmetric_difference(&BTreeSet::<usize>::new()));\n     is_sync_send!(BTreeSet::<usize>::new(), intersection(&BTreeSet::<usize>::new()));"}]}