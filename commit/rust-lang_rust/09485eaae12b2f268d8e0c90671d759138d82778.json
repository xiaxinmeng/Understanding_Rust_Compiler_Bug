{"sha": "09485eaae12b2f268d8e0c90671d759138d82778", "node_id": "C_kwDOAAsO6NoAKDA5NDg1ZWFhZTEyYjJmMjY4ZDhlMGM5MDY3MWQ3NTkxMzhkODI3Nzg", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-09T16:30:40Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-17T07:48:19Z"}, "message": "`rustc_hir_analysis`: remove `ref` patterns", "tree": {"sha": "24675397cf837d9198a0c1b0a2e5fe9d1e05ec4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24675397cf837d9198a0c1b0a2e5fe9d1e05ec4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09485eaae12b2f268d8e0c90671d759138d82778", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09485eaae12b2f268d8e0c90671d759138d82778", "html_url": "https://github.com/rust-lang/rust/commit/09485eaae12b2f268d8e0c90671d759138d82778", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09485eaae12b2f268d8e0c90671d759138d82778/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d60e772e14a862a1ed3f6a7ee23faadbdd9cf443", "url": "https://api.github.com/repos/rust-lang/rust/commits/d60e772e14a862a1ed3f6a7ee23faadbdd9cf443", "html_url": "https://github.com/rust-lang/rust/commit/d60e772e14a862a1ed3f6a7ee23faadbdd9cf443"}], "stats": {"total": 329, "additions": 161, "deletions": 168}, "files": [{"sha": "3953fd8c5a803e23ed71d2fd50b0b6ab60051f37", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -569,17 +569,17 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .bindings\n             .iter()\n             .map(|binding| {\n-                let kind = match binding.kind {\n-                    hir::TypeBindingKind::Equality { ref term } => match term {\n-                        hir::Term::Ty(ref ty) => {\n+                let kind = match &binding.kind {\n+                    hir::TypeBindingKind::Equality { term } => match term {\n+                        hir::Term::Ty(ty) => {\n                             ConvertedBindingKind::Equality(self.ast_ty_to_ty(ty).into())\n                         }\n-                        hir::Term::Const(ref c) => {\n+                        hir::Term::Const(c) => {\n                             let c = Const::from_anon_const(self.tcx(), c.def_id);\n                             ConvertedBindingKind::Equality(c.into())\n                         }\n                     },\n-                    hir::TypeBindingKind::Constraint { ref bounds } => {\n+                    hir::TypeBindingKind::Constraint { bounds } => {\n                         ConvertedBindingKind::Constraint(bounds)\n                     }\n                 };\n@@ -1928,7 +1928,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ) -> Result<(Ty<'tcx>, DefKind, DefId), ErrorGuaranteed> {\n         let tcx = self.tcx();\n         let assoc_ident = assoc_segment.ident;\n-        let qself_res = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.kind {\n+        let qself_res = if let hir::TyKind::Path(hir::QPath::Resolved(_, path)) = &qself.kind {\n             path.res\n         } else {\n             Res::Err\n@@ -1971,8 +1971,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 return;\n                             };\n                             let (qself_sugg_span, is_self) = if let hir::TyKind::Path(\n-                                hir::QPath::Resolved(_, ref path)\n-                            ) = qself.kind {\n+                                hir::QPath::Resolved(_, path)\n+                            ) = &qself.kind {\n                                 // If the path segment already has type params, we want to overwrite\n                                 // them.\n                                 match &path.segments[..] {\n@@ -2760,7 +2760,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         \"generic `Self` types are currently not permitted in anonymous constants\",\n                     );\n                     if let Some(hir::Node::Item(&hir::Item {\n-                        kind: hir::ItemKind::Impl(ref impl_),\n+                        kind: hir::ItemKind::Impl(impl_),\n                         ..\n                     })) = tcx.hir().get_if_local(def_id)\n                     {\n@@ -2843,12 +2843,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn ast_ty_to_ty_inner(&self, ast_ty: &hir::Ty<'_>, borrowed: bool, in_path: bool) -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n-        let result_ty = match ast_ty.kind {\n-            hir::TyKind::Slice(ref ty) => tcx.mk_slice(self.ast_ty_to_ty(ty)),\n-            hir::TyKind::Ptr(ref mt) => {\n+        let result_ty = match &ast_ty.kind {\n+            hir::TyKind::Slice(ty) => tcx.mk_slice(self.ast_ty_to_ty(ty)),\n+            hir::TyKind::Ptr(mt) => {\n                 tcx.mk_ptr(ty::TypeAndMut { ty: self.ast_ty_to_ty(mt.ty), mutbl: mt.mutbl })\n             }\n-            hir::TyKind::Ref(ref region, ref mt) => {\n+            hir::TyKind::Ref(region, mt) => {\n                 let r = self.ast_region_to_region(region, None);\n                 debug!(?r);\n                 let t = self.ast_ty_to_ty_inner(mt.ty, true, false);\n@@ -2868,38 +2868,38 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     Some(ast_ty),\n                 ))\n             }\n-            hir::TyKind::TraitObject(bounds, ref lifetime, repr) => {\n+            hir::TyKind::TraitObject(bounds, lifetime, repr) => {\n                 self.maybe_lint_bare_trait(ast_ty, in_path);\n                 let repr = match repr {\n                     TraitObjectSyntax::Dyn | TraitObjectSyntax::None => ty::Dyn,\n                     TraitObjectSyntax::DynStar => ty::DynStar,\n                 };\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime, borrowed, repr)\n             }\n-            hir::TyKind::Path(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n+            hir::TyKind::Path(hir::QPath::Resolved(maybe_qself, path)) => {\n                 debug!(?maybe_qself, ?path);\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| self.ast_ty_to_ty(qself));\n                 self.res_to_ty(opt_self_ty, path, false)\n             }\n             hir::TyKind::OpaqueDef(item_id, lifetimes, in_trait) => {\n-                let opaque_ty = tcx.hir().item(item_id);\n+                let opaque_ty = tcx.hir().item(*item_id);\n                 let def_id = item_id.owner_id.to_def_id();\n \n                 match opaque_ty.kind {\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n-                        self.impl_trait_ty_to_ty(def_id, lifetimes, origin, in_trait)\n+                        self.impl_trait_ty_to_ty(def_id, lifetimes, origin, *in_trait)\n                     }\n                     ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n                 }\n             }\n-            hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n+            hir::TyKind::Path(hir::QPath::TypeRelative(qself, segment)) => {\n                 debug!(?qself, ?segment);\n                 let ty = self.ast_ty_to_ty_inner(qself, false, true);\n                 self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, qself, segment, false)\n                     .map(|(ty, _, _)| ty)\n                     .unwrap_or_else(|_| tcx.ty_error())\n             }\n-            hir::TyKind::Path(hir::QPath::LangItem(lang_item, span, _)) => {\n+            &hir::TyKind::Path(hir::QPath::LangItem(lang_item, span, _)) => {\n                 let def_id = tcx.require_lang_item(lang_item, Some(span));\n                 let (substs, _) = self.create_substs_for_ast_path(\n                     span,\n@@ -2913,7 +2913,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 );\n                 EarlyBinder(tcx.at(span).type_of(def_id)).subst(tcx, substs)\n             }\n-            hir::TyKind::Array(ref ty, ref length) => {\n+            hir::TyKind::Array(ty, length) => {\n                 let length = match length {\n                     &hir::ArrayLen::Infer(_, span) => self.ct_infer(tcx.types.usize, None, span),\n                     hir::ArrayLen::Body(constant) => {\n@@ -2923,7 +2923,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n                 tcx.mk_ty(ty::Array(self.ast_ty_to_ty(ty), length))\n             }\n-            hir::TyKind::Typeof(ref e) => {\n+            hir::TyKind::Typeof(e) => {\n                 let ty_erased = tcx.type_of(e.def_id);\n                 let ty = tcx.fold_regions(ty_erased, |r, _| {\n                     if r.is_erased() { tcx.lifetimes.re_static } else { r }"}, {"sha": "d286a25dd598a856d850fefbd56e9351526f9c4d", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -531,9 +531,7 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n         DefKind::Fn => {} // entirely within check_item_body\n         DefKind::Impl => {\n             let it = tcx.hir().item(id);\n-            let hir::ItemKind::Impl(ref impl_) = it.kind else {\n-                return;\n-            };\n+            let hir::ItemKind::Impl(impl_) = it.kind else { return };\n             debug!(\"ItemKind::Impl {} with id {:?}\", it.ident, it.owner_id);\n             if let Some(impl_trait_ref) = tcx.impl_trait_ref(it.owner_id) {\n                 check_impl_items_against_trait(\n@@ -548,15 +546,15 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n         }\n         DefKind::Trait => {\n             let it = tcx.hir().item(id);\n-            let hir::ItemKind::Trait(_, _, _, _, ref items) = it.kind else {\n+            let hir::ItemKind::Trait(_, _, _, _, items) = it.kind else {\n                 return;\n             };\n             check_on_unimplemented(tcx, it);\n \n             for item in items.iter() {\n                 let item = tcx.hir().trait_item(item.id);\n-                match item.kind {\n-                    hir::TraitItemKind::Fn(ref sig, _) => {\n+                match &item.kind {\n+                    hir::TraitItemKind::Fn(sig, _) => {\n                         let abi = sig.header.abi;\n                         fn_maybe_err(tcx, item.ident.span, abi);\n                     }\n@@ -652,8 +650,8 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n                     }\n \n                     let item = tcx.hir().foreign_item(item.id);\n-                    match item.kind {\n-                        hir::ForeignItemKind::Fn(ref fn_decl, _, _) => {\n+                    match &item.kind {\n+                        hir::ForeignItemKind::Fn(fn_decl, _, _) => {\n                             require_c_abi_if_c_variadic(tcx, fn_decl, abi, item.span);\n                         }\n                         hir::ForeignItemKind::Static(..) => {"}, {"sha": "5f1ee9641ee3d3f465d8b21acde75925898eb1d4", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -1513,8 +1513,7 @@ fn compare_synthetic_generics<'tcx>(\n                         impl<'v> intravisit::Visitor<'v> for Visitor {\n                             fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n                                 intravisit::walk_ty(self, ty);\n-                                if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) =\n-                                    ty.kind\n+                                if let hir::TyKind::Path(hir::QPath::Resolved(None, path)) = ty.kind\n                                     && let Res::Def(DefKind::TyParam, def_id) = path.res\n                                     && def_id == self.1.to_def_id()\n                                 {"}, {"sha": "82030d82f57a0536f90667df5ba79183aeed8f02", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -351,7 +351,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n             }\n \n             match *op {\n-                hir::InlineAsmOperand::In { reg, ref expr } => {\n+                hir::InlineAsmOperand::In { reg, expr } => {\n                     self.check_asm_operand_type(\n                         idx,\n                         reg,\n@@ -362,7 +362,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                         &target_features,\n                     );\n                 }\n-                hir::InlineAsmOperand::Out { reg, late: _, ref expr } => {\n+                hir::InlineAsmOperand::Out { reg, late: _, expr } => {\n                     if let Some(expr) = expr {\n                         self.check_asm_operand_type(\n                             idx,\n@@ -375,7 +375,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                         );\n                     }\n                 }\n-                hir::InlineAsmOperand::InOut { reg, late: _, ref expr } => {\n+                hir::InlineAsmOperand::InOut { reg, late: _, expr } => {\n                     self.check_asm_operand_type(\n                         idx,\n                         reg,\n@@ -386,7 +386,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                         &target_features,\n                     );\n                 }\n-                hir::InlineAsmOperand::SplitInOut { reg, late: _, ref in_expr, ref out_expr } => {\n+                hir::InlineAsmOperand::SplitInOut { reg, late: _, in_expr, out_expr } => {\n                     let in_ty = self.check_asm_operand_type(\n                         idx,\n                         reg,"}, {"sha": "46cd07e4b51225c2fb3610c9f3bc468c11f57b0f", "filename": "compiler/rustc_hir_analysis/src/check/region.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -180,7 +180,7 @@ fn resolve_arm<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, arm: &'tcx hir\n \n     visitor.terminating_scopes.insert(arm.body.hir_id.local_id);\n \n-    if let Some(hir::Guard::If(ref expr)) = arm.guard {\n+    if let Some(hir::Guard::If(expr)) = arm.guard {\n         visitor.terminating_scopes.insert(expr.hir_id.local_id);\n     }\n \n@@ -242,8 +242,8 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             // This ensures fixed size stacks.\n             hir::ExprKind::Binary(\n                 source_map::Spanned { node: hir::BinOpKind::And | hir::BinOpKind::Or, .. },\n-                ref l,\n-                ref r,\n+                l,\n+                r,\n             ) => {\n                 // expr is a short circuiting operator (|| or &&). As its\n                 // functionality can't be overridden by traits, it always\n@@ -288,20 +288,20 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n                     terminating(r.hir_id.local_id);\n                 }\n             }\n-            hir::ExprKind::If(_, ref then, Some(ref otherwise)) => {\n+            hir::ExprKind::If(_, then, Some(otherwise)) => {\n                 terminating(then.hir_id.local_id);\n                 terminating(otherwise.hir_id.local_id);\n             }\n \n-            hir::ExprKind::If(_, ref then, None) => {\n+            hir::ExprKind::If(_, then, None) => {\n                 terminating(then.hir_id.local_id);\n             }\n \n-            hir::ExprKind::Loop(ref body, _, _, _) => {\n+            hir::ExprKind::Loop(body, _, _, _) => {\n                 terminating(body.hir_id.local_id);\n             }\n \n-            hir::ExprKind::DropTemps(ref expr) => {\n+            hir::ExprKind::DropTemps(expr) => {\n                 // `DropTemps(expr)` does not denote a conditional scope.\n                 // Rather, we want to achieve the same behavior as `{ let _t = expr; _t }`.\n                 terminating(expr.hir_id.local_id);\n@@ -396,7 +396,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             let body = visitor.tcx.hir().body(body);\n             visitor.visit_body(body);\n         }\n-        hir::ExprKind::AssignOp(_, ref left_expr, ref right_expr) => {\n+        hir::ExprKind::AssignOp(_, left_expr, right_expr) => {\n             debug!(\n                 \"resolve_expr - enabling pessimistic_yield, was previously {}\",\n                 prev_pessimistic\n@@ -447,7 +447,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             }\n         }\n \n-        hir::ExprKind::If(ref cond, ref then, Some(ref otherwise)) => {\n+        hir::ExprKind::If(cond, then, Some(otherwise)) => {\n             let expr_cx = visitor.cx;\n             visitor.enter_scope(Scope { id: then.hir_id.local_id, data: ScopeData::IfThen });\n             visitor.cx.var_parent = visitor.cx.parent;\n@@ -457,7 +457,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             visitor.visit_expr(otherwise);\n         }\n \n-        hir::ExprKind::If(ref cond, ref then, None) => {\n+        hir::ExprKind::If(cond, then, None) => {\n             let expr_cx = visitor.cx;\n             visitor.enter_scope(Scope { id: then.hir_id.local_id, data: ScopeData::IfThen });\n             visitor.cx.var_parent = visitor.cx.parent;\n@@ -641,21 +641,21 @@ fn resolve_local<'tcx>(\n         match pat.kind {\n             PatKind::Binding(hir::BindingAnnotation(hir::ByRef::Yes, _), ..) => true,\n \n-            PatKind::Struct(_, ref field_pats, _) => {\n+            PatKind::Struct(_, field_pats, _) => {\n                 field_pats.iter().any(|fp| is_binding_pat(&fp.pat))\n             }\n \n-            PatKind::Slice(ref pats1, ref pats2, ref pats3) => {\n+            PatKind::Slice(pats1, pats2, pats3) => {\n                 pats1.iter().any(|p| is_binding_pat(&p))\n                     || pats2.iter().any(|p| is_binding_pat(&p))\n                     || pats3.iter().any(|p| is_binding_pat(&p))\n             }\n \n-            PatKind::Or(ref subpats)\n-            | PatKind::TupleStruct(_, ref subpats, _)\n-            | PatKind::Tuple(ref subpats, _) => subpats.iter().any(|p| is_binding_pat(&p)),\n+            PatKind::Or(subpats)\n+            | PatKind::TupleStruct(_, subpats, _)\n+            | PatKind::Tuple(subpats, _) => subpats.iter().any(|p| is_binding_pat(&p)),\n \n-            PatKind::Box(ref subpat) => is_binding_pat(&subpat),\n+            PatKind::Box(subpat) => is_binding_pat(&subpat),\n \n             PatKind::Ref(_, _)\n             | PatKind::Binding(hir::BindingAnnotation(hir::ByRef::No, _), ..)\n@@ -704,11 +704,11 @@ fn resolve_local<'tcx>(\n                     record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n                 }\n             }\n-            hir::ExprKind::Cast(ref subexpr, _) => {\n+            hir::ExprKind::Cast(subexpr, _) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id)\n             }\n-            hir::ExprKind::Block(ref block, _) => {\n-                if let Some(ref subexpr) = block.expr {\n+            hir::ExprKind::Block(block, _) => {\n+                if let Some(subexpr) = block.expr {\n                     record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n                 }\n             }"}, {"sha": "d51bc7ce340a262b13eeb40b28f493547df75c7e", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -178,7 +178,7 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         //\n         // won't be allowed unless there's an *explicit* implementation of `Send`\n         // for `T`\n-        hir::ItemKind::Impl(ref impl_) => {\n+        hir::ItemKind::Impl(impl_) => {\n             let is_auto = tcx\n                 .impl_trait_ref(def_id)\n                 .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.skip_binder().def_id));\n@@ -224,15 +224,15 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         hir::ItemKind::Const(ty, ..) => {\n             check_item_type(tcx, def_id, ty.span, false);\n         }\n-        hir::ItemKind::Struct(_, ref ast_generics) => {\n+        hir::ItemKind::Struct(_, ast_generics) => {\n             check_type_defn(tcx, item, false);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemKind::Union(_, ref ast_generics) => {\n+        hir::ItemKind::Union(_, ast_generics) => {\n             check_type_defn(tcx, item, true);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemKind::Enum(_, ref ast_generics) => {\n+        hir::ItemKind::Enum(_, ast_generics) => {\n             check_type_defn(tcx, item, true);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n@@ -1247,8 +1247,8 @@ fn check_impl<'tcx>(\n     constness: hir::Constness,\n ) {\n     enter_wf_checking_ctxt(tcx, item.span, item.owner_id.def_id, |wfcx| {\n-        match *ast_trait_ref {\n-            Some(ref ast_trait_ref) => {\n+        match ast_trait_ref {\n+            Some(ast_trait_ref) => {\n                 // `#[rustc_reservation_impl]` impls are not real impls and\n                 // therefore don't need to be WF (the trait's `Self: Trait` predicate\n                 // won't hold)."}, {"sha": "b28b2af8a11800f720e883fdcd0fdc915d0fe28d", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -502,12 +502,11 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                 return err_info;\n             } else if diff_fields.len() > 1 {\n                 let item = tcx.hir().expect_item(impl_did);\n-                let span =\n-                    if let ItemKind::Impl(hir::Impl { of_trait: Some(ref t), .. }) = item.kind {\n-                        t.path.span\n-                    } else {\n-                        tcx.def_span(impl_did)\n-                    };\n+                let span = if let ItemKind::Impl(hir::Impl { of_trait: Some(t), .. }) = &item.kind {\n+                    t.path.span\n+                } else {\n+                    tcx.def_span(impl_did)\n+                };\n \n                 struct_span_err!(\n                     tcx.sess,"}, {"sha": "dfb9824094346949c74b14f117fdd45dbaf6b375", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -182,7 +182,7 @@ impl<'tcx> InherentCollect<'tcx> {\n         }\n \n         let item = self.tcx.hir().item(id);\n-        let hir::ItemKind::Impl(hir::Impl { of_trait: None, self_ty: ty, ref items, .. }) = item.kind else {\n+        let hir::ItemKind::Impl(hir::Impl { of_trait: None, self_ty: ty, items, .. }) = item.kind else {\n             return;\n         };\n "}, {"sha": "12dd3cc6b1fc112ac0e3becbdbc6d54379ba347f", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -40,7 +40,7 @@ fn do_orphan_check_impl<'tcx>(\n     let trait_def_id = trait_ref.def_id;\n \n     let item = tcx.hir().expect_item(def_id);\n-    let hir::ItemKind::Impl(ref impl_) = item.kind else {\n+    let hir::ItemKind::Impl(impl_) = item.kind else {\n         bug!(\"{:?} is not an impl: {:?}\", def_id, item);\n     };\n     let sp = tcx.def_span(def_id);"}, {"sha": "fe6119dce873573baf819591798c33e3ecc19b92", "filename": "compiler/rustc_hir_analysis/src/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -11,7 +11,7 @@ use rustc_span::def_id::LocalDefId;\n pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     debug_assert!(matches!(tcx.def_kind(def_id), DefKind::Impl));\n     let item = tcx.hir().expect_item(def_id);\n-    let hir::ItemKind::Impl(ref impl_) = item.kind else { bug!() };\n+    let hir::ItemKind::Impl(impl_) = item.kind else { bug!() };\n \n     if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n         let trait_ref = trait_ref.subst_identity();"}, {"sha": "7e6af7393129eb621bf0f23b88678c883b1c2482", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -560,15 +560,15 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n     debug!(\"convert: item {} with id {}\", it.ident, it.hir_id());\n     let def_id = item_id.owner_id.def_id;\n \n-    match it.kind {\n+    match &it.kind {\n         // These don't define types.\n         hir::ItemKind::ExternCrate(_)\n         | hir::ItemKind::Use(..)\n         | hir::ItemKind::Macro(..)\n         | hir::ItemKind::Mod(_)\n         | hir::ItemKind::GlobalAsm(_) => {}\n         hir::ItemKind::ForeignMod { items, .. } => {\n-            for item in items {\n+            for item in *items {\n                 let item = tcx.hir().foreign_item(item.id);\n                 tcx.ensure().generics_of(item.owner_id);\n                 tcx.ensure().type_of(item.owner_id);\n@@ -618,7 +618,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n             tcx.at(it.span).super_predicates_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n         }\n-        hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n+        hir::ItemKind::Struct(struct_def, _) | hir::ItemKind::Union(struct_def, _) => {\n             tcx.ensure().generics_of(def_id);\n             tcx.ensure().type_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n@@ -853,14 +853,14 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtDef<'_> {\n     };\n \n     let repr = tcx.repr_options_of_def(def_id.to_def_id());\n-    let (kind, variants) = match item.kind {\n-        ItemKind::Enum(ref def, _) => {\n+    let (kind, variants) = match &item.kind {\n+        ItemKind::Enum(def, _) => {\n             let mut distance_from_explicit = 0;\n             let variants = def\n                 .variants\n                 .iter()\n                 .map(|v| {\n-                    let discr = if let Some(ref e) = v.disr_expr {\n+                    let discr = if let Some(e) = &v.disr_expr {\n                         distance_from_explicit = 0;\n                         ty::VariantDiscr::Explicit(e.def_id.to_def_id())\n                     } else {\n@@ -882,7 +882,7 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtDef<'_> {\n \n             (AdtKind::Enum, variants)\n         }\n-        ItemKind::Struct(ref def, _) | ItemKind::Union(ref def, _) => {\n+        ItemKind::Struct(def, _) | ItemKind::Union(def, _) => {\n             let adt_kind = match item.kind {\n                 ItemKind::Struct(..) => AdtKind::Struct,\n                 _ => AdtKind::Union,\n@@ -1509,7 +1509,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n         for (input, ty) in iter::zip(decl.inputs, fty.inputs().skip_binder()) {\n             check(input, *ty)\n         }\n-        if let hir::FnRetTy::Return(ref ty) = decl.output {\n+        if let hir::FnRetTy::Return(ty) = decl.output {\n             check(ty, fty.output().skip_binder())\n         }\n     }"}, {"sha": "014ee9fcc207b425b06bac78729f606d2fbc6ebd", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -110,12 +110,12 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                     // expressions' count (i.e. `N` in `[x; N]`), and explicit\n                     // `enum` discriminants (i.e. `D` in `enum Foo { Bar = D }`),\n                     // as they shouldn't be able to cause query cycle errors.\n-                    Node::Expr(&Expr { kind: ExprKind::Repeat(_, ref constant), .. })\n+                    Node::Expr(Expr { kind: ExprKind::Repeat(_, constant), .. })\n                         if constant.hir_id() == hir_id =>\n                     {\n                         Some(parent_def_id.to_def_id())\n                     }\n-                    Node::Variant(Variant { disr_expr: Some(ref constant), .. })\n+                    Node::Variant(Variant { disr_expr: Some(constant), .. })\n                         if constant.hir_id == hir_id =>\n                     {\n                         Some(parent_def_id.to_def_id())\n@@ -259,7 +259,7 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n \n     params.extend(ast_generics.params.iter().filter_map(|param| match param.kind {\n         GenericParamKind::Lifetime { .. } => None,\n-        GenericParamKind::Type { ref default, synthetic, .. } => {\n+        GenericParamKind::Type { default, synthetic, .. } => {\n             if default.is_some() {\n                 match allow_defaults {\n                     Defaults::Allowed => {}\n@@ -426,26 +426,22 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n     }\n \n     match node {\n-        Node::TraitItem(item) => match item.kind {\n-            hir::TraitItemKind::Fn(ref sig, _) => {\n-                has_late_bound_regions(tcx, &item.generics, sig.decl)\n-            }\n+        Node::TraitItem(item) => match &item.kind {\n+            hir::TraitItemKind::Fn(sig, _) => has_late_bound_regions(tcx, &item.generics, sig.decl),\n             _ => None,\n         },\n-        Node::ImplItem(item) => match item.kind {\n-            hir::ImplItemKind::Fn(ref sig, _) => {\n-                has_late_bound_regions(tcx, &item.generics, sig.decl)\n-            }\n+        Node::ImplItem(item) => match &item.kind {\n+            hir::ImplItemKind::Fn(sig, _) => has_late_bound_regions(tcx, &item.generics, sig.decl),\n             _ => None,\n         },\n         Node::ForeignItem(item) => match item.kind {\n-            hir::ForeignItemKind::Fn(fn_decl, _, ref generics) => {\n+            hir::ForeignItemKind::Fn(fn_decl, _, generics) => {\n                 has_late_bound_regions(tcx, generics, fn_decl)\n             }\n             _ => None,\n         },\n-        Node::Item(item) => match item.kind {\n-            hir::ItemKind::Fn(ref sig, .., ref generics, _) => {\n+        Node::Item(item) => match &item.kind {\n+            hir::ItemKind::Fn(sig, .., generics, _) => {\n                 has_late_bound_regions(tcx, generics, sig.decl)\n             }\n             _ => None,"}, {"sha": "30bae506540869085259e9a9765ac80982a1d0f7", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -428,7 +428,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             _ => {}\n         }\n         match item.kind {\n-            hir::ItemKind::Fn(_, ref generics, _) => {\n+            hir::ItemKind::Fn(_, generics, _) => {\n                 self.visit_early_late(item.hir_id(), generics, |this| {\n                     intravisit::walk_item(this, item);\n                 });\n@@ -508,13 +508,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     this.with(scope, |this| intravisit::walk_item(this, item))\n                 });\n             }\n-            hir::ItemKind::TyAlias(_, ref generics)\n-            | hir::ItemKind::Enum(_, ref generics)\n-            | hir::ItemKind::Struct(_, ref generics)\n-            | hir::ItemKind::Union(_, ref generics)\n-            | hir::ItemKind::Trait(_, _, ref generics, ..)\n-            | hir::ItemKind::TraitAlias(ref generics, ..)\n-            | hir::ItemKind::Impl(hir::Impl { ref generics, .. }) => {\n+            hir::ItemKind::TyAlias(_, generics)\n+            | hir::ItemKind::Enum(_, generics)\n+            | hir::ItemKind::Struct(_, generics)\n+            | hir::ItemKind::Union(_, generics)\n+            | hir::ItemKind::Trait(_, _, generics, ..)\n+            | hir::ItemKind::TraitAlias(generics, ..)\n+            | hir::ItemKind::Impl(&hir::Impl { generics, .. }) => {\n                 // These kinds of items have only early-bound lifetime parameters.\n                 let lifetimes = generics\n                     .params\n@@ -544,7 +544,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n         match item.kind {\n-            hir::ForeignItemKind::Fn(_, _, ref generics) => {\n+            hir::ForeignItemKind::Fn(_, _, generics) => {\n                 self.visit_early_late(item.hir_id(), generics, |this| {\n                     intravisit::walk_foreign_item(this, item);\n                 })\n@@ -561,7 +561,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n         match ty.kind {\n-            hir::TyKind::BareFn(ref c) => {\n+            hir::TyKind::BareFn(c) => {\n                 let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) = c\n                     .generic_params\n                     .iter()\n@@ -587,7 +587,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     intravisit::walk_ty(this, ty);\n                 });\n             }\n-            hir::TyKind::TraitObject(bounds, ref lifetime, _) => {\n+            hir::TyKind::TraitObject(bounds, lifetime, _) => {\n                 debug!(?bounds, ?lifetime, \"TraitObject\");\n                 let scope = Scope::TraitRefBoundary { s: self.scope };\n                 self.with(scope, |this| {\n@@ -617,7 +617,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     LifetimeName::Error => {}\n                 }\n             }\n-            hir::TyKind::Ref(ref lifetime_ref, ref mt) => {\n+            hir::TyKind::Ref(lifetime_ref, ref mt) => {\n                 self.visit_lifetime(lifetime_ref);\n                 let scope = Scope::ObjectLifetimeDefault {\n                     lifetime: self.map.defs.get(&lifetime_ref.hir_id).cloned(),\n@@ -632,7 +632,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 //                 ^                  ^ this gets resolved in the scope of\n                 //                                      the opaque_ty generics\n                 let opaque_ty = self.tcx.hir().item(item_id);\n-                match opaque_ty.kind {\n+                match &opaque_ty.kind {\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                         origin: hir::OpaqueTyOrigin::TyAlias,\n                         ..\n@@ -655,7 +655,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         origin: hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..),\n                         ..\n                     }) => {}\n-                    ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n+                    i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n                 };\n \n                 // Resolve the lifetimes that are applied to the opaque type.\n@@ -720,7 +720,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     intravisit::walk_trait_item(this, trait_item)\n                 });\n             }\n-            Type(bounds, ref ty) => {\n+            Type(bounds, ty) => {\n                 let generics = &trait_item.generics;\n                 let lifetimes = generics\n                     .params\n@@ -766,7 +766,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             Fn(..) => self.visit_early_late(impl_item.hir_id(), &impl_item.generics, |this| {\n                 intravisit::walk_impl_item(this, impl_item)\n             }),\n-            Type(ref ty) => {\n+            Type(ty) => {\n                 let generics = &impl_item.generics;\n                 let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n                     .params\n@@ -817,7 +817,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_path(&mut self, path: &hir::Path<'tcx>, _: hir::HirId) {\n         for (i, segment) in path.segments.iter().enumerate() {\n             let depth = path.segments.len() - i - 1;\n-            if let Some(ref args) = segment.args {\n+            if let Some(args) = segment.args {\n                 self.visit_segment_args(path.res, depth, args);\n             }\n         }\n@@ -833,7 +833,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     ) {\n         let output = match fd.output {\n             hir::FnRetTy::DefaultReturn(_) => None,\n-            hir::FnRetTy::Return(ref ty) => Some(&**ty),\n+            hir::FnRetTy::Return(ty) => Some(ty),\n         };\n         self.visit_fn_like_elision(&fd.inputs, output, matches!(fk, intravisit::FnKind::Closure));\n         intravisit::walk_fn_kind(self, fk);\n@@ -846,13 +846,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             for param in generics.params {\n                 match param.kind {\n                     GenericParamKind::Lifetime { .. } => {}\n-                    GenericParamKind::Type { ref default, .. } => {\n-                        if let Some(ref ty) = default {\n-                            this.visit_ty(&ty);\n+                    GenericParamKind::Type { default, .. } => {\n+                        if let Some(ty) = default {\n+                            this.visit_ty(ty);\n                         }\n                     }\n-                    GenericParamKind::Const { ref ty, default } => {\n-                        this.visit_ty(&ty);\n+                    GenericParamKind::Const { ty, default } => {\n+                        this.visit_ty(ty);\n                         if let Some(default) = default {\n                             this.visit_body(this.tcx.hir().body(default.body));\n                         }\n@@ -863,9 +863,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 match predicate {\n                     &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                         hir_id,\n-                        ref bounded_ty,\n+                        bounded_ty,\n                         bounds,\n-                        ref bound_generic_params,\n+                        bound_generic_params,\n                         origin,\n                         ..\n                     }) => {\n@@ -905,7 +905,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         })\n                     }\n                     &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n-                        ref lifetime,\n+                        lifetime,\n                         bounds,\n                         ..\n                     }) => {\n@@ -914,7 +914,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n                         if lifetime.res != hir::LifetimeName::Static {\n                             for bound in bounds {\n-                                let hir::GenericBound::Outlives(ref lt) = bound else {\n+                                let hir::GenericBound::Outlives(lt) = bound else {\n                                     continue;\n                                 };\n                                 if lt.res != hir::LifetimeName::Static {\n@@ -939,8 +939,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         }\n                     }\n                     &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n-                        ref lhs_ty,\n-                        ref rhs_ty,\n+                        lhs_ty,\n+                        rhs_ty,\n                         ..\n                     }) => {\n                         this.visit_ty(lhs_ty);\n@@ -1042,7 +1042,7 @@ fn object_lifetime_default(tcx: TyCtxt<'_>, param_def_id: DefId) -> ObjectLifeti\n                 }\n \n                 for bound in bound.bounds {\n-                    if let hir::GenericBound::Outlives(ref lifetime) = *bound {\n+                    if let hir::GenericBound::Outlives(lifetime) = bound {\n                         set.insert(lifetime.res);\n                     }\n                 }\n@@ -1828,7 +1828,7 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n                     }\n                 }\n \n-                hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n+                hir::TyKind::Path(hir::QPath::Resolved(None, path)) => {\n                     // consider only the lifetimes on the final\n                     // segment; I am not sure it's even currently\n                     // valid to have them elsewhere, but even if it"}, {"sha": "8c2ac30616823148c06015c028637fc1c80914a9", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -85,30 +85,30 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n         Node::ImplItem(item) => item.generics,\n \n         Node::Item(item) => match item.kind {\n-            ItemKind::Impl(ref impl_) => {\n+            ItemKind::Impl(impl_) => {\n                 if impl_.defaultness.is_default() {\n                     is_default_impl_trait =\n                         tcx.impl_trait_ref(def_id).map(|t| ty::Binder::dummy(t.subst_identity()));\n                 }\n-                &impl_.generics\n+                impl_.generics\n             }\n-            ItemKind::Fn(.., ref generics, _)\n-            | ItemKind::TyAlias(_, ref generics)\n-            | ItemKind::Enum(_, ref generics)\n-            | ItemKind::Struct(_, ref generics)\n-            | ItemKind::Union(_, ref generics) => *generics,\n+            ItemKind::Fn(.., generics, _)\n+            | ItemKind::TyAlias(_, generics)\n+            | ItemKind::Enum(_, generics)\n+            | ItemKind::Struct(_, generics)\n+            | ItemKind::Union(_, generics) => generics,\n \n-            ItemKind::Trait(_, _, ref generics, ..) | ItemKind::TraitAlias(ref generics, _) => {\n+            ItemKind::Trait(_, _, generics, ..) | ItemKind::TraitAlias(generics, _) => {\n                 is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n-                *generics\n+                generics\n             }\n-            ItemKind::OpaqueTy(OpaqueTy { ref generics, .. }) => generics,\n+            ItemKind::OpaqueTy(OpaqueTy { generics, .. }) => generics,\n             _ => NO_GENERICS,\n         },\n \n         Node::ForeignItem(item) => match item.kind {\n             ForeignItemKind::Static(..) => NO_GENERICS,\n-            ForeignItemKind::Fn(_, _, ref generics) => *generics,\n+            ForeignItemKind::Fn(_, _, generics) => generics,\n             ForeignItemKind::Type => NO_GENERICS,\n         },\n \n@@ -350,7 +350,7 @@ fn const_evaluatable_predicates_of(\n     let node = tcx.hir().get(hir_id);\n \n     let mut collector = ConstCollector { tcx, preds: FxIndexSet::default() };\n-    if let hir::Node::Item(item) = node && let hir::ItemKind::Impl(ref impl_) = item.kind {\n+    if let hir::Node::Item(item) = node && let hir::ItemKind::Impl(impl_) = item.kind {\n         if let Some(of_trait) = &impl_.of_trait {\n             debug!(\"const_evaluatable_predicates_of({:?}): visit impl trait_ref\", def_id);\n             collector.visit_trait_ref(of_trait);\n@@ -511,8 +511,8 @@ pub(super) fn super_predicates_that_define_assoc_type(\n         };\n \n         let (generics, bounds) = match item.kind {\n-            hir::ItemKind::Trait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n-            hir::ItemKind::TraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n+            hir::ItemKind::Trait(.., generics, supertraits, _) => (generics, supertraits),\n+            hir::ItemKind::TraitAlias(generics, supertraits) => (generics, supertraits),\n             _ => span_bug!(item.span, \"super_predicates invoked on non-trait\"),\n         };\n \n@@ -612,18 +612,18 @@ pub(super) fn type_param_predicates(\n \n         Node::Item(item) => {\n             match item.kind {\n-                ItemKind::Fn(.., ref generics, _)\n-                | ItemKind::Impl(hir::Impl { ref generics, .. })\n-                | ItemKind::TyAlias(_, ref generics)\n+                ItemKind::Fn(.., generics, _)\n+                | ItemKind::Impl(&hir::Impl { generics, .. })\n+                | ItemKind::TyAlias(_, generics)\n                 | ItemKind::OpaqueTy(OpaqueTy {\n-                    ref generics,\n+                    generics,\n                     origin: hir::OpaqueTyOrigin::TyAlias,\n                     ..\n                 })\n-                | ItemKind::Enum(_, ref generics)\n-                | ItemKind::Struct(_, ref generics)\n-                | ItemKind::Union(_, ref generics) => generics,\n-                ItemKind::Trait(_, _, ref generics, ..) => {\n+                | ItemKind::Enum(_, generics)\n+                | ItemKind::Struct(_, generics)\n+                | ItemKind::Union(_, generics) => generics,\n+                ItemKind::Trait(_, _, generics, ..) => {\n                     // Implied `Self: Trait` and supertrait bounds.\n                     if param_id == item_hir_id {\n                         let identity_trait_ref = ty::TraitRef::identity(tcx, item_def_id);\n@@ -637,7 +637,7 @@ pub(super) fn type_param_predicates(\n         }\n \n         Node::ForeignItem(item) => match item.kind {\n-            ForeignItemKind::Fn(_, _, ref generics) => generics,\n+            ForeignItemKind::Fn(_, _, generics) => generics,\n             _ => return result,\n         },\n \n@@ -681,8 +681,8 @@ impl<'tcx> ItemCtxt<'tcx> {\n         ast_generics\n             .predicates\n             .iter()\n-            .filter_map(|wp| match *wp {\n-                hir::WherePredicate::BoundPredicate(ref bp) => Some(bp),\n+            .filter_map(|wp| match wp {\n+                hir::WherePredicate::BoundPredicate(bp) => Some(bp),\n                 _ => None,\n             })\n             .flat_map(|bp| {"}, {"sha": "5e388a2f2babb0a0a17a2196316b198748fffb0a", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -379,7 +379,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             ForeignItemKind::Type => tcx.mk_foreign(def_id.to_def_id()),\n         },\n \n-        Node::Ctor(&ref def) | Node::Variant(Variant { data: ref def, .. }) => match *def {\n+        Node::Ctor(def) | Node::Variant(Variant { data: def, .. }) => match def {\n             VariantData::Unit(..) | VariantData::Struct(..) => {\n                 tcx.type_of(tcx.hir().get_parent_item(hir_id))\n             }\n@@ -404,17 +404,17 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         Node::AnonConst(_) => {\n             let parent_node = tcx.hir().get_parent(hir_id);\n             match parent_node {\n-                Node::Ty(&Ty { kind: TyKind::Array(_, ref constant), .. })\n-                | Node::Expr(&Expr { kind: ExprKind::Repeat(_, ref constant), .. })\n+                Node::Ty(Ty { kind: TyKind::Array(_, constant), .. })\n+                | Node::Expr(Expr { kind: ExprKind::Repeat(_, constant), .. })\n                     if constant.hir_id() == hir_id =>\n                 {\n                     tcx.types.usize\n                 }\n-                Node::Ty(&Ty { kind: TyKind::Typeof(ref e), .. }) if e.hir_id == hir_id => {\n+                Node::Ty(Ty { kind: TyKind::Typeof(e), .. }) if e.hir_id == hir_id => {\n                     tcx.typeck(def_id).node_type(e.hir_id)\n                 }\n \n-                Node::Expr(&Expr { kind: ExprKind::ConstBlock(ref anon_const), .. })\n+                Node::Expr(Expr { kind: ExprKind::ConstBlock(anon_const), .. })\n                     if anon_const.hir_id == hir_id =>\n                 {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n@@ -434,18 +434,19 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     tcx.typeck(def_id).node_type(hir_id)\n                 }\n \n-                Node::Variant(Variant { disr_expr: Some(ref e), .. }) if e.hir_id == hir_id => {\n+                Node::Variant(Variant { disr_expr: Some(e), .. }) if e.hir_id == hir_id => {\n                     tcx.adt_def(tcx.hir().get_parent_item(hir_id)).repr().discr_type().to_ty(tcx)\n                 }\n \n                 Node::TypeBinding(\n-                    binding @ &TypeBinding {\n+                    TypeBinding {\n                         hir_id: binding_id,\n-                        kind: TypeBindingKind::Equality { term: Term::Const(ref e) },\n+                        kind: TypeBindingKind::Equality { term: Term::Const(e) },\n+                        ident,\n                         ..\n                     },\n                 ) if let Node::TraitRef(trait_ref) =\n-                    tcx.hir().get_parent(binding_id)\n+                    tcx.hir().get_parent(*binding_id)\n                     && e.hir_id == hir_id =>\n                 {\n                     let Some(trait_def_id) = trait_ref.trait_def_id() else {\n@@ -454,7 +455,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     let assoc_items = tcx.associated_items(trait_def_id);\n                     let assoc_item = assoc_items.find_by_name_and_kind(\n                         tcx,\n-                        binding.ident,\n+                        *ident,\n                         ty::AssocKind::Const,\n                         def_id.to_def_id(),\n                     );\n@@ -470,9 +471,9 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 }\n \n                 Node::TypeBinding(\n-                    binding @ &TypeBinding { hir_id: binding_id, gen_args, ref kind, .. },\n+                    TypeBinding { hir_id: binding_id, gen_args, kind, ident, .. },\n                 ) if let Node::TraitRef(trait_ref) =\n-                    tcx.hir().get_parent(binding_id)\n+                    tcx.hir().get_parent(*binding_id)\n                     && let Some((idx, _)) =\n                         gen_args.args.iter().enumerate().find(|(_, arg)| {\n                             if let GenericArg::Const(ct) = arg {\n@@ -488,7 +489,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     let assoc_items = tcx.associated_items(trait_def_id);\n                     let assoc_item = assoc_items.find_by_name_and_kind(\n                         tcx,\n-                        binding.ident,\n+                        *ident,\n                         match kind {\n                             // I think `<A: T>` type bindings requires that `A` is a type\n                             TypeBindingKind::Constraint { .. }"}, {"sha": "17dbb126bd1b0f357ac0f0204d8a6d70614cc0ba", "filename": "compiler/rustc_hir_analysis/src/hir_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -128,7 +128,7 @@ fn diagnostic_hir_wf_check<'tcx>(\n             },\n             hir::Node::Item(item) => match item.kind {\n                 hir::ItemKind::Static(ty, _, _) | hir::ItemKind::Const(ty, _) => vec![ty],\n-                hir::ItemKind::Impl(ref impl_) => match &impl_.of_trait {\n+                hir::ItemKind::Impl(impl_) => match &impl_.of_trait {\n                     Some(t) => t\n                         .path\n                         .segments"}, {"sha": "816061c9fa0066476055701484321cac351ddcda", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -219,7 +219,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         }\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         match tcx.hir().find(hir_id) {\n-            Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, ref generics, _), .. })) => {\n+            Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, generics, _), .. })) => {\n                 Some(generics.where_clause_span)\n             }\n             _ => {\n@@ -241,7 +241,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         }\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         match tcx.hir().find(hir_id) {\n-            Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(ref fn_sig, _, _), .. })) => {\n+            Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(fn_sig, _, _), .. })) => {\n                 Some(fn_sig.decl.output.span())\n             }\n             _ => {\n@@ -371,7 +371,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n     match start_t.kind() {\n         ty::FnDef(..) => {\n             if let Some(Node::Item(it)) = tcx.hir().find(start_id) {\n-                if let hir::ItemKind::Fn(ref sig, ref generics, _) = it.kind {\n+                if let hir::ItemKind::Fn(sig, generics, _) = &it.kind {\n                     let mut error = false;\n                     if !generics.params.is_empty() {\n                         struct_span_err!("}, {"sha": "9133e6540d4450e07e96f9742c8115d8553e9722", "filename": "compiler/rustc_hir_analysis/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -727,8 +727,8 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         if let Some(parent_node) = self.tcx.hir().opt_parent_id(self.path_segment.hir_id)\n         && let Some(parent_node) = self.tcx.hir().find(parent_node)\n         && let hir::Node::Expr(expr) = parent_node {\n-            match expr.kind {\n-                hir::ExprKind::Path(ref qpath) => {\n+            match &expr.kind {\n+                hir::ExprKind::Path(qpath) => {\n                     self.suggest_moving_args_from_assoc_fn_to_trait_for_qualified_path(\n                         err,\n                         qpath,"}, {"sha": "f2128451611d173a20656a8c49dc905690657b38", "filename": "compiler/rustc_hir_analysis/src/variance/solve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09485eaae12b2f268d8e0c90671d759138d82778/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs?ref=09485eaae12b2f268d8e0c90671d759138d82778", "patch": "@@ -28,8 +28,8 @@ pub fn solve_constraints<'tcx>(\n     let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n \n     let mut solutions = vec![ty::Bivariant; terms_cx.inferred_terms.len()];\n-    for &(id, ref variances) in &terms_cx.lang_items {\n-        let InferredIndex(start) = terms_cx.inferred_starts[&id];\n+    for (id, variances) in &terms_cx.lang_items {\n+        let InferredIndex(start) = terms_cx.inferred_starts[id];\n         for (i, &variance) in variances.iter().enumerate() {\n             solutions[start + i] = variance;\n         }"}]}