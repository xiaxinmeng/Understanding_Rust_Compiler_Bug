{"sha": "ca3843482928a1acf9482aa2e6cb29a850392ac7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMzg0MzQ4MjkyOGExYWNmOTQ4MmFhMmU2Y2IyOWE4NTAzOTJhYzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-19T14:06:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-19T14:06:39Z"}, "message": "auto merge of #15638 : blake2-ppc/rust/ptr-arithmetic-chars, r=huonw\n\nReimplement the string slice's `Iterator<char>` by wrapping the already efficient\r\nslice iterator.\r\n\r\nThe iterator uses our guarantee that the string contains valid UTF-8, but its only unsafe\r\ncode is transmuting the decoded `u32` into `char`.\r\n\r\nBenchmarks suggest that the runtime of `Chars` benchmarks are reduced by up to 30%,\r\nruntime of `Chars` reversed reduced by up to 60%.\r\n\r\n```\r\nBEFORE\r\ntest str::bench::char_indicesator                          ... bench:       124 ns/iter (+/- 1)\r\ntest str::bench::char_indicesator_rev                      ... bench:       188 ns/iter (+/- 9)\r\ntest str::bench::char_iterator                             ... bench:       122 ns/iter (+/- 2)\r\ntest str::bench::char_iterator_ascii                       ... bench:       302 ns/iter (+/- 41)\r\ntest str::bench::char_iterator_for                         ... bench:       123 ns/iter (+/- 4)\r\ntest str::bench::char_iterator_rev                         ... bench:       189 ns/iter (+/- 14)\r\ntest str::bench::char_iterator_rev_for                     ... bench:       177 ns/iter (+/- 4)\r\n\r\nAFTER\r\ntest str::bench::char_indicesator                          ... bench:        85 ns/iter (+/- 3)\r\ntest str::bench::char_indicesator_rev                      ... bench:        82 ns/iter (+/- 2)\r\ntest str::bench::char_iterator                             ... bench:       100 ns/iter (+/- 3)\r\ntest str::bench::char_iterator_ascii                       ... bench:       317 ns/iter (+/- 3)\r\ntest str::bench::char_iterator_for                         ... bench:        86 ns/iter (+/- 2)\r\ntest str::bench::char_iterator_rev                         ... bench:        80 ns/iter (+/- 6)\r\ntest str::bench::char_iterator_rev_for                     ... bench:        68 ns/iter (+/- 0)\r\n```\r\n\r\nNote: Branch name is no longer indicative of the implementation.", "tree": {"sha": "8a76a34c520bcca8bde2f2c37f892474abee0c8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a76a34c520bcca8bde2f2c37f892474abee0c8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca3843482928a1acf9482aa2e6cb29a850392ac7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca3843482928a1acf9482aa2e6cb29a850392ac7", "html_url": "https://github.com/rust-lang/rust/commit/ca3843482928a1acf9482aa2e6cb29a850392ac7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca3843482928a1acf9482aa2e6cb29a850392ac7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0a6e2b41421928206cc71be27da1239b4598ed1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0a6e2b41421928206cc71be27da1239b4598ed1", "html_url": "https://github.com/rust-lang/rust/commit/e0a6e2b41421928206cc71be27da1239b4598ed1"}, {"sha": "c5e0736c2434fbed6b7f249b42b336f0e27804a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5e0736c2434fbed6b7f249b42b336f0e27804a6", "html_url": "https://github.com/rust-lang/rust/commit/c5e0736c2434fbed6b7f249b42b336f0e27804a6"}], "stats": {"total": 218, "additions": 161, "deletions": 57}, "files": [{"sha": "1e29679f8a79ec61c363c6f5ef68e846927ec5e6", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 48, "deletions": 6, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ca3843482928a1acf9482aa2e6cb29a850392ac7/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3843482928a1acf9482aa2e6cb29a850392ac7/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=ca3843482928a1acf9482aa2e6cb29a850392ac7", "patch": "@@ -808,6 +808,7 @@ impl OwnedStr for String {\n #[cfg(test)]\n mod tests {\n     use std::iter::AdditiveIterator;\n+    use std::iter::range;\n     use std::default::Default;\n     use std::char::Char;\n     use std::clone::Clone;\n@@ -1610,6 +1611,30 @@ mod tests {\n         assert_eq!(pos, v.len());\n     }\n \n+    #[test]\n+    fn test_chars_decoding() {\n+        let mut bytes = [0u8, ..4];\n+        for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n+            let len = c.encode_utf8(bytes);\n+            let s = ::core::str::from_utf8(bytes.slice_to(len)).unwrap();\n+            if Some(c) != s.chars().next() {\n+                fail!(\"character {:x}={} does not decode correctly\", c as u32, c);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_chars_rev_decoding() {\n+        let mut bytes = [0u8, ..4];\n+        for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n+            let len = c.encode_utf8(bytes);\n+            let s = ::core::str::from_utf8(bytes.slice_to(len)).unwrap();\n+            if Some(c) != s.chars().rev().next() {\n+                fail!(\"character {:x}={} does not decode correctly\", c as u32, c);\n+            }\n+        }\n+    }\n+\n     #[test]\n     fn test_iterator_clone() {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n@@ -2240,16 +2265,26 @@ mod tests {\n #[cfg(test)]\n mod bench {\n     use test::Bencher;\n+    use test::black_box;\n     use super::*;\n+    use std::option::{None, Some};\n     use std::iter::{Iterator, DoubleEndedIterator};\n     use std::collections::Collection;\n \n     #[bench]\n     fn char_iterator(b: &mut Bencher) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        let len = s.char_len();\n \n-        b.iter(|| assert_eq!(s.chars().count(), len));\n+        b.iter(|| s.chars().count());\n+    }\n+\n+    #[bench]\n+    fn char_iterator_for(b: &mut Bencher) {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+\n+        b.iter(|| {\n+            for ch in s.chars() { black_box(ch) }\n+        });\n     }\n \n     #[bench]\n@@ -2260,17 +2295,24 @@ mod bench {\n         Mary had a little lamb, Little lamb\n         Mary had a little lamb, Little lamb\n         Mary had a little lamb, Little lamb\";\n-        let len = s.char_len();\n \n-        b.iter(|| assert_eq!(s.chars().count(), len));\n+        b.iter(|| s.chars().count());\n     }\n \n     #[bench]\n     fn char_iterator_rev(b: &mut Bencher) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        let len = s.char_len();\n \n-        b.iter(|| assert_eq!(s.chars().rev().count(), len));\n+        b.iter(|| s.chars().rev().count());\n+    }\n+\n+    #[bench]\n+    fn char_iterator_rev_for(b: &mut Bencher) {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+\n+        b.iter(|| {\n+            for ch in s.chars().rev() { black_box(ch) }\n+        });\n     }\n \n     #[bench]"}, {"sha": "c6aff9c8bdac8c58147e17131ea3a491080cca38", "filename": "src/libcore/str.rs", "status": "modified", "additions": 113, "deletions": 51, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/ca3843482928a1acf9482aa2e6cb29a850392ac7/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3843482928a1acf9482aa2e6cb29a850392ac7/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=ca3843482928a1acf9482aa2e6cb29a850392ac7", "patch": "@@ -97,47 +97,110 @@ impl<'a> CharEq for &'a [char] {\n Section: Iterators\n */\n \n-/// External iterator for a string's characters.\n-/// Use with the `std::iter` module.\n+/// Iterator for the char (representing *Unicode Scalar Values*) of a string\n+///\n+/// Created with the method `.chars()`.\n #[deriving(Clone)]\n pub struct Chars<'a> {\n-    /// The slice remaining to be iterated\n-    string: &'a str,\n+    iter: slice::Items<'a, u8>\n+}\n+\n+// Return the initial codepoint accumulator for the first byte.\n+// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n+// for width 3, and 3 bits for width 4\n+macro_rules! utf8_first_byte(\n+    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as u32)\n+)\n+\n+// return the value of $ch updated with continuation byte $byte\n+macro_rules! utf8_acc_cont_byte(\n+    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & CONT_MASK) as u32)\n+)\n+\n+macro_rules! utf8_is_cont_byte(\n+    ($byte:expr) => (($byte & !CONT_MASK) == TAG_CONT_U8)\n+)\n+\n+#[inline]\n+fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n+    match opt {\n+        Some(&byte) => byte,\n+        None => 0,\n+    }\n }\n \n impl<'a> Iterator<char> for Chars<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n-        // Decode the next codepoint, then update\n-        // the slice to be just the remaining part\n-        if self.string.len() != 0 {\n-            let CharRange {ch, next} = self.string.char_range_at(0);\n-            unsafe {\n-                self.string = raw::slice_unchecked(self.string, next, self.string.len());\n+        // Decode UTF-8, using the valid UTF-8 invariant\n+        let x = match self.iter.next() {\n+            None => return None,\n+            Some(&next_byte) if next_byte < 128 => return Some(next_byte as char),\n+            Some(&next_byte) => next_byte,\n+        };\n+\n+        // Multibyte case follows\n+        // Decode from a byte combination out of: [[[x y] z] w]\n+        // NOTE: Performance is sensitive to the exact formulation here\n+        let init = utf8_first_byte!(x, 2);\n+        let y = unwrap_or_0(self.iter.next());\n+        let mut ch = utf8_acc_cont_byte!(init, y);\n+        if x >= 0xE0 {\n+            // [[x y z] w] case\n+            // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n+            let z = unwrap_or_0(self.iter.next());\n+            let y_z = utf8_acc_cont_byte!((y & CONT_MASK) as u32, z);\n+            ch = init << 12 | y_z;\n+            if x >= 0xF0 {\n+                // [x y z w] case\n+                // use only the lower 3 bits of `init`\n+                let w = unwrap_or_0(self.iter.next());\n+                ch = (init & 7) << 18 | utf8_acc_cont_byte!(y_z, w);\n             }\n-            Some(ch)\n-        } else {\n-            None\n+        }\n+\n+        // str invariant says `ch` is a valid Unicode Scalar Value\n+        unsafe {\n+            Some(mem::transmute(ch))\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.string.len().saturating_add(3)/4, Some(self.string.len()))\n+        let (len, _) = self.iter.size_hint();\n+        (len.saturating_add(3) / 4, Some(len))\n     }\n }\n \n impl<'a> DoubleEndedIterator<char> for Chars<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n-        if self.string.len() != 0 {\n-            let CharRange {ch, next} = self.string.char_range_at_reverse(self.string.len());\n-            unsafe {\n-                self.string = raw::slice_unchecked(self.string, 0, next);\n+        let w = match self.iter.next_back() {\n+            None => return None,\n+            Some(&back_byte) if back_byte < 128 => return Some(back_byte as char),\n+            Some(&back_byte) => back_byte,\n+        };\n+\n+        // Multibyte case follows\n+        // Decode from a byte combination out of: [x [y [z w]]]\n+        let mut ch;\n+        let z = unwrap_or_0(self.iter.next_back());\n+        ch = utf8_first_byte!(z, 2);\n+        if utf8_is_cont_byte!(z) {\n+            let y = unwrap_or_0(self.iter.next_back());\n+            ch = utf8_first_byte!(y, 3);\n+            if utf8_is_cont_byte!(y) {\n+                let x = unwrap_or_0(self.iter.next_back());\n+                ch = utf8_first_byte!(x, 4);\n+                ch = utf8_acc_cont_byte!(ch, y);\n             }\n-            Some(ch)\n-        } else {\n-            None\n+            ch = utf8_acc_cont_byte!(ch, z);\n+        }\n+        ch = utf8_acc_cont_byte!(ch, w);\n+\n+        // str invariant says `ch` is a valid Unicode Scalar Value\n+        unsafe {\n+            Some(mem::transmute(ch))\n         }\n     }\n }\n@@ -146,18 +209,23 @@ impl<'a> DoubleEndedIterator<char> for Chars<'a> {\n /// Use with the `std::iter` module.\n #[deriving(Clone)]\n pub struct CharOffsets<'a> {\n-    /// The original string to be iterated\n-    string: &'a str,\n+    front_offset: uint,\n     iter: Chars<'a>,\n }\n \n impl<'a> Iterator<(uint, char)> for CharOffsets<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<(uint, char)> {\n-        // Compute the byte offset by using the pointer offset between\n-        // the original string slice and the iterator's remaining part\n-        let offset = self.iter.string.as_ptr() as uint - self.string.as_ptr() as uint;\n-        self.iter.next().map(|ch| (offset, ch))\n+        let (pre_len, _) = self.iter.iter.size_hint();\n+        match self.iter.next() {\n+            None => None,\n+            Some(ch) => {\n+                let index = self.front_offset;\n+                let (len, _) = self.iter.iter.size_hint();\n+                self.front_offset += pre_len - len;\n+                Some((index, ch))\n+            }\n+        }\n     }\n \n     #[inline]\n@@ -169,11 +237,14 @@ impl<'a> Iterator<(uint, char)> for CharOffsets<'a> {\n impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsets<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n-        self.iter.next_back().map(|ch| {\n-            let offset = self.iter.string.len() +\n-                    self.iter.string.as_ptr() as uint - self.string.as_ptr() as uint;\n-            (offset, ch)\n-        })\n+        match self.iter.next_back() {\n+            None => None,\n+            Some(ch) => {\n+                let (len, _) = self.iter.iter.size_hint();\n+                let index = self.front_offset + len;\n+                Some((index, ch))\n+            }\n+        }\n     }\n }\n \n@@ -672,9 +743,9 @@ fn run_utf8_validation_iterator(iter: &mut slice::Items<u8>) -> bool {\n             // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n             //               %xF4 %x80-8F 2( UTF8-tail )\n             match w {\n-                2 => if second & 192 != TAG_CONT_U8 {err!()},\n+                2 => if second & !CONT_MASK != TAG_CONT_U8 {err!()},\n                 3 => {\n-                    match (first, second, next!() & 192) {\n+                    match (first, second, next!() & !CONT_MASK) {\n                         (0xE0        , 0xA0 .. 0xBF, TAG_CONT_U8) |\n                         (0xE1 .. 0xEC, 0x80 .. 0xBF, TAG_CONT_U8) |\n                         (0xED        , 0x80 .. 0x9F, TAG_CONT_U8) |\n@@ -683,7 +754,7 @@ fn run_utf8_validation_iterator(iter: &mut slice::Items<u8>) -> bool {\n                     }\n                 }\n                 4 => {\n-                    match (first, second, next!() & 192, next!() & 192) {\n+                    match (first, second, next!() & !CONT_MASK, next!() & !CONT_MASK) {\n                         (0xF0        , 0x90 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n                         (0xF1 .. 0xF3, 0x80 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n                         (0xF4        , 0x80 .. 0x8F, TAG_CONT_U8, TAG_CONT_U8) => {}\n@@ -880,19 +951,10 @@ pub struct CharRange {\n     pub next: uint,\n }\n \n-// Return the initial codepoint accumulator for the first byte.\n-// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n-// for width 3, and 3 bits for width 4\n-macro_rules! utf8_first_byte(\n-    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as u32)\n-)\n-\n-// return the value of $ch updated with continuation byte $byte\n-macro_rules! utf8_acc_cont_byte(\n-    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n-)\n-\n-static TAG_CONT_U8: u8 = 128u8;\n+/// Mask of the value bits of a continuation byte\n+static CONT_MASK: u8 = 0b0011_1111u8;\n+/// Value of the tag bits (tag mask is !CONT_MASK) of a continuation byte\n+static TAG_CONT_U8: u8 = 0b1000_0000u8;\n \n /// Unsafe operations\n pub mod raw {\n@@ -1608,7 +1670,7 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn chars(&self) -> Chars<'a> {\n-        Chars{string: *self}\n+        Chars{iter: self.as_bytes().iter()}\n     }\n \n     #[inline]\n@@ -1618,7 +1680,7 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn char_indices(&self) -> CharOffsets<'a> {\n-        CharOffsets{string: *self, iter: self.chars()}\n+        CharOffsets{front_offset: 0, iter: self.chars()}\n     }\n \n     #[inline]\n@@ -1828,7 +1890,7 @@ impl<'a> StrSlice<'a> for &'a str {\n         // Multibyte case is a fn to allow char_range_at_reverse to inline cleanly\n         fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange {\n             // while there is a previous byte == 10......\n-            while i > 0 && s.as_bytes()[i] & 192u8 == TAG_CONT_U8 {\n+            while i > 0 && s.as_bytes()[i] & !CONT_MASK == TAG_CONT_U8 {\n                 i -= 1u;\n             }\n "}]}