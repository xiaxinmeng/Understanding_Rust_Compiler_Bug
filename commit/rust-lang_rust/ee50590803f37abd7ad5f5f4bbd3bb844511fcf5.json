{"sha": "ee50590803f37abd7ad5f5f4bbd3bb844511fcf5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlNTA1OTA4MDNmMzdhYmQ3YWQ1ZjVmNGJiZDNiYjg0NDUxMWZjZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-01T07:53:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-01T07:53:13Z"}, "message": "Auto merge of #69295 - ecstatic-morse:unified-dataflow-generators, r=tmandry\n\nUse new dataflow framework for generators\n\n#65672 introduced a new dataflow framework that can handle arbitrarily complex transfer functions as well as ones expressed as a series of gen/kill operations. This PR ports the analyses used to implement generators to the new framework so that we can remove the old one. See #68241 for a prior example of this. The new framework has some superficial API changes, but this shouldn't alter the generator passes in any way.\n\nr? @tmandry", "tree": {"sha": "fe871f3acb90db793f26e81a74a00a01c230ab84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe871f3acb90db793f26e81a74a00a01c230ab84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee50590803f37abd7ad5f5f4bbd3bb844511fcf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee50590803f37abd7ad5f5f4bbd3bb844511fcf5", "html_url": "https://github.com/rust-lang/rust/commit/ee50590803f37abd7ad5f5f4bbd3bb844511fcf5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee50590803f37abd7ad5f5f4bbd3bb844511fcf5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9051341a1c142542a3f7dab509266606c775382", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9051341a1c142542a3f7dab509266606c775382", "html_url": "https://github.com/rust-lang/rust/commit/d9051341a1c142542a3f7dab509266606c775382"}, {"sha": "21cd1fe0bddf68062d6edd858781eaffd0dfcaaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/21cd1fe0bddf68062d6edd858781eaffd0dfcaaa", "html_url": "https://github.com/rust-lang/rust/commit/21cd1fe0bddf68062d6edd858781eaffd0dfcaaa"}], "stats": {"total": 317, "additions": 159, "deletions": 158}, "files": [{"sha": "9a102c9a3d06f0b9e75b51f27eba4d2719580860", "filename": "src/librustc_mir/dataflow/generic/mod.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ee50590803f37abd7ad5f5f4bbd3bb844511fcf5/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee50590803f37abd7ad5f5f4bbd3bb844511fcf5/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs?ref=ee50590803f37abd7ad5f5f4bbd3bb844511fcf5", "patch": "@@ -75,6 +75,24 @@ where\n     pub fn entry_set_for_block(&self, block: BasicBlock) -> &BitSet<A::Idx> {\n         &self.entry_sets[block]\n     }\n+\n+    pub fn visit_with(\n+        &self,\n+        body: &'mir mir::Body<'tcx>,\n+        blocks: impl IntoIterator<Item = BasicBlock>,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = BitSet<A::Idx>>,\n+    ) {\n+        visit_results(body, blocks, self, vis)\n+    }\n+\n+    pub fn visit_in_rpo_with(\n+        &self,\n+        body: &'mir mir::Body<'tcx>,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = BitSet<A::Idx>>,\n+    ) {\n+        let blocks = mir::traversal::reverse_postorder(body);\n+        visit_results(body, blocks.map(|(bb, _)| bb), self, vis)\n+    }\n }\n \n /// Define the domain of a dataflow problem.\n@@ -433,16 +451,5 @@ impl<T: Idx> GenKill<T> for BitSet<T> {\n     }\n }\n \n-// For compatibility with old framework\n-impl<T: Idx> GenKill<T> for crate::dataflow::GenKillSet<T> {\n-    fn gen(&mut self, elem: T) {\n-        self.gen(elem);\n-    }\n-\n-    fn kill(&mut self, elem: T) {\n-        self.kill(elem);\n-    }\n-}\n-\n #[cfg(test)]\n mod tests;"}, {"sha": "87d8e9e411c6fba6f494d362441d8149be914955", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee50590803f37abd7ad5f5f4bbd3bb844511fcf5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee50590803f37abd7ad5f5f4bbd3bb844511fcf5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=ee50590803f37abd7ad5f5f4bbd3bb844511fcf5", "patch": "@@ -14,7 +14,7 @@ use crate::util::elaborate_drops::DropFlagState;\n \n use super::generic::{AnalysisDomain, GenKill, GenKillAnalysis};\n use super::move_paths::{HasMoveData, InitIndex, InitKind, LookupResult, MoveData, MovePathIndex};\n-use super::{BottomValue, GenKillSet};\n+use super::BottomValue;\n \n use super::drop_flag_effects_for_function_entry;\n use super::drop_flag_effects_for_location;"}, {"sha": "fabe562e68a590efe645d925ec4e1e7d16408042", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 104, "deletions": 87, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/ee50590803f37abd7ad5f5f4bbd3bb844511fcf5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee50590803f37abd7ad5f5f4bbd3bb844511fcf5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=ee50590803f37abd7ad5f5f4bbd3bb844511fcf5", "patch": "@@ -1,70 +1,68 @@\n pub use super::*;\n \n-use crate::dataflow::generic::{Results, ResultsRefCursor};\n-use crate::dataflow::BitDenotation;\n-use crate::dataflow::MaybeBorrowedLocals;\n+use crate::dataflow::generic::{self as dataflow, GenKill, Results, ResultsRefCursor};\n+use crate::dataflow::BottomValue;\n use rustc::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc::mir::*;\n use std::cell::RefCell;\n \n #[derive(Copy, Clone)]\n-pub struct MaybeStorageLive<'a, 'tcx> {\n-    body: &'a Body<'tcx>,\n-}\n+pub struct MaybeStorageLive;\n \n-impl<'a, 'tcx> MaybeStorageLive<'a, 'tcx> {\n-    pub fn new(body: &'a Body<'tcx>) -> Self {\n-        MaybeStorageLive { body }\n-    }\n+impl dataflow::AnalysisDomain<'tcx> for MaybeStorageLive {\n+    type Idx = Local;\n \n-    pub fn body(&self) -> &Body<'tcx> {\n-        self.body\n-    }\n-}\n+    const NAME: &'static str = \"maybe_storage_live\";\n \n-impl<'a, 'tcx> BitDenotation<'tcx> for MaybeStorageLive<'a, 'tcx> {\n-    type Idx = Local;\n-    fn name() -> &'static str {\n-        \"maybe_storage_live\"\n-    }\n-    fn bits_per_block(&self) -> usize {\n-        self.body.local_decls.len()\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n+        body.local_decls.len()\n     }\n \n-    fn start_block_effect(&self, on_entry: &mut BitSet<Local>) {\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, on_entry: &mut BitSet<Self::Idx>) {\n         // The resume argument is live on function entry (we don't care about\n         // the `self` argument)\n-        for arg in self.body.args_iter().skip(1) {\n+        for arg in body.args_iter().skip(1) {\n             on_entry.insert(arg);\n         }\n     }\n+}\n \n-    fn statement_effect(&self, trans: &mut GenKillSet<Local>, loc: Location) {\n-        let stmt = &self.body[loc.block].statements[loc.statement_index];\n-\n+impl dataflow::GenKillAnalysis<'tcx> for MaybeStorageLive {\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        stmt: &mir::Statement<'tcx>,\n+        _: Location,\n+    ) {\n         match stmt.kind {\n             StatementKind::StorageLive(l) => trans.gen(l),\n             StatementKind::StorageDead(l) => trans.kill(l),\n             _ => (),\n         }\n     }\n \n-    fn terminator_effect(&self, _trans: &mut GenKillSet<Local>, _loc: Location) {\n+    fn terminator_effect(\n+        &self,\n+        _trans: &mut impl GenKill<Self::Idx>,\n+        _: &mir::Terminator<'tcx>,\n+        _: Location,\n+    ) {\n         // Terminators have no effect\n     }\n \n-    fn propagate_call_return(\n+    fn call_return_effect(\n         &self,\n-        _in_out: &mut BitSet<Local>,\n-        _call_bb: mir::BasicBlock,\n-        _dest_bb: mir::BasicBlock,\n-        _dest_place: &mir::Place<'tcx>,\n+        _trans: &mut impl GenKill<Self::Idx>,\n+        _block: BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n+        _return_place: &mir::Place<'tcx>,\n     ) {\n         // Nothing to do when a call returns successfully\n     }\n }\n \n-impl<'a, 'tcx> BottomValue for MaybeStorageLive<'a, 'tcx> {\n+impl BottomValue for MaybeStorageLive {\n     /// bottom = dead\n     const BOTTOM_VALUE: bool = false;\n }\n@@ -73,60 +71,62 @@ type BorrowedLocalsResults<'a, 'tcx> = ResultsRefCursor<'a, 'a, 'tcx, MaybeBorro\n \n /// Dataflow analysis that determines whether each local requires storage at a\n /// given location; i.e. whether its storage can go away without being observed.\n-pub struct RequiresStorage<'mir, 'tcx> {\n+pub struct MaybeRequiresStorage<'mir, 'tcx> {\n     body: ReadOnlyBodyAndCache<'mir, 'tcx>,\n     borrowed_locals: RefCell<BorrowedLocalsResults<'mir, 'tcx>>,\n }\n \n-impl<'mir, 'tcx: 'mir> RequiresStorage<'mir, 'tcx> {\n+impl<'mir, 'tcx> MaybeRequiresStorage<'mir, 'tcx> {\n     pub fn new(\n         body: ReadOnlyBodyAndCache<'mir, 'tcx>,\n         borrowed_locals: &'mir Results<'tcx, MaybeBorrowedLocals>,\n     ) -> Self {\n-        RequiresStorage {\n+        MaybeRequiresStorage {\n             body,\n             borrowed_locals: RefCell::new(ResultsRefCursor::new(*body, borrowed_locals)),\n         }\n     }\n-\n-    pub fn body(&self) -> &Body<'tcx> {\n-        &self.body\n-    }\n }\n \n-impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n+impl<'mir, 'tcx> dataflow::AnalysisDomain<'tcx> for MaybeRequiresStorage<'mir, 'tcx> {\n     type Idx = Local;\n-    fn name() -> &'static str {\n-        \"requires_storage\"\n-    }\n-    fn bits_per_block(&self) -> usize {\n-        self.body.local_decls.len()\n+\n+    const NAME: &'static str = \"requires_storage\";\n+\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n+        body.local_decls.len()\n     }\n \n-    fn start_block_effect(&self, on_entry: &mut BitSet<Local>) {\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, on_entry: &mut BitSet<Self::Idx>) {\n         // The resume argument is live on function entry (we don't care about\n         // the `self` argument)\n-        for arg in self.body.args_iter().skip(1) {\n+        for arg in body.args_iter().skip(1) {\n             on_entry.insert(arg);\n         }\n     }\n+}\n \n-    fn before_statement_effect(&self, sets: &mut GenKillSet<Self::Idx>, loc: Location) {\n-        let stmt = &self.body[loc.block].statements[loc.statement_index];\n-\n+impl<'mir, 'tcx> dataflow::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir, 'tcx> {\n+    fn before_statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        stmt: &mir::Statement<'tcx>,\n+        loc: Location,\n+    ) {\n         // If a place is borrowed in a statement, it needs storage for that statement.\n-        self.borrowed_locals.borrow().analysis().statement_effect(sets, stmt, loc);\n+        self.borrowed_locals.borrow().analysis().statement_effect(trans, stmt, loc);\n \n-        // If a place is assigned to in a statement, it needs storage for that statement.\n         match &stmt.kind {\n-            StatementKind::StorageDead(l) => sets.kill(*l),\n+            StatementKind::StorageDead(l) => trans.kill(*l),\n+\n+            // If a place is assigned to in a statement, it needs storage for that statement.\n             StatementKind::Assign(box (place, _))\n             | StatementKind::SetDiscriminant { box place, .. } => {\n-                sets.gen(place.local);\n+                trans.gen(place.local);\n             }\n-            StatementKind::InlineAsm(box InlineAsm { outputs, .. }) => {\n-                for place in &**outputs {\n-                    sets.gen(place.local);\n+            StatementKind::InlineAsm(asm) => {\n+                for place in &*asm.outputs {\n+                    trans.gen(place.local);\n                 }\n             }\n \n@@ -140,22 +140,30 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         }\n     }\n \n-    fn statement_effect(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _: &mir::Statement<'tcx>,\n+        loc: Location,\n+    ) {\n         // If we move from a place then only stops needing storage *after*\n         // that statement.\n-        self.check_for_move(sets, loc);\n+        self.check_for_move(trans, loc);\n     }\n \n-    fn before_terminator_effect(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n-        let terminator = self.body[loc.block].terminator();\n-\n+    fn before_terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        loc: Location,\n+    ) {\n         // If a place is borrowed in a terminator, it needs storage for that terminator.\n-        self.borrowed_locals.borrow().analysis().terminator_effect(sets, terminator, loc);\n+        self.borrowed_locals.borrow().analysis().terminator_effect(trans, terminator, loc);\n \n         match &terminator.kind {\n-            TerminatorKind::Call { destination: Some((Place { local, .. }, _)), .. }\n-            | TerminatorKind::Yield { resume_arg: Place { local, .. }, .. } => {\n-                sets.gen(*local);\n+            TerminatorKind::Call { destination: Some((place, _)), .. }\n+            | TerminatorKind::Yield { resume_arg: place, .. } => {\n+                trans.gen(place.local);\n             }\n \n             // Nothing to do for these. Match exhaustively so this fails to compile when new\n@@ -176,14 +184,19 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         }\n     }\n \n-    fn terminator_effect(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n-        match &self.body[loc.block].terminator().kind {\n+    fn terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        loc: Location,\n+    ) {\n+        match &terminator.kind {\n             // For call terminators the destination requires storage for the call\n             // and after the call returns successfully, but not after a panic.\n             // Since `propagate_call_unwind` doesn't exist, we have to kill the\n-            // destination here, and then gen it again in `propagate_call_return`.\n-            TerminatorKind::Call { destination: Some((Place { local, .. }, _)), .. } => {\n-                sets.kill(*local);\n+            // destination here, and then gen it again in `call_return_effect`.\n+            TerminatorKind::Call { destination: Some((place, _)), .. } => {\n+                trans.kill(place.local);\n             }\n \n             // Nothing to do for these. Match exhaustively so this fails to compile when new\n@@ -204,45 +217,49 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n             | TerminatorKind::Unreachable => {}\n         }\n \n-        self.check_for_move(sets, loc);\n+        self.check_for_move(trans, loc);\n     }\n \n-    fn propagate_call_return(\n+    fn call_return_effect(\n         &self,\n-        in_out: &mut BitSet<Local>,\n-        _call_bb: mir::BasicBlock,\n-        _dest_bb: mir::BasicBlock,\n-        dest_place: &mir::Place<'tcx>,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _block: BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n+        return_place: &mir::Place<'tcx>,\n     ) {\n-        in_out.insert(dest_place.local);\n+        trans.gen(return_place.local);\n     }\n }\n \n-impl<'mir, 'tcx> RequiresStorage<'mir, 'tcx> {\n+impl<'mir, 'tcx> MaybeRequiresStorage<'mir, 'tcx> {\n     /// Kill locals that are fully moved and have not been borrowed.\n-    fn check_for_move(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n-        let mut visitor = MoveVisitor { sets, borrowed_locals: &self.borrowed_locals };\n+    fn check_for_move(&self, trans: &mut impl GenKill<Local>, loc: Location) {\n+        let mut visitor = MoveVisitor { trans, borrowed_locals: &self.borrowed_locals };\n         visitor.visit_location(self.body, loc);\n     }\n }\n \n-impl<'mir, 'tcx> BottomValue for RequiresStorage<'mir, 'tcx> {\n+impl<'mir, 'tcx> BottomValue for MaybeRequiresStorage<'mir, 'tcx> {\n     /// bottom = dead\n     const BOTTOM_VALUE: bool = false;\n }\n \n-struct MoveVisitor<'a, 'mir, 'tcx> {\n+struct MoveVisitor<'a, 'mir, 'tcx, T> {\n     borrowed_locals: &'a RefCell<BorrowedLocalsResults<'mir, 'tcx>>,\n-    sets: &'a mut GenKillSet<Local>,\n+    trans: &'a mut T,\n }\n \n-impl<'a, 'mir: 'a, 'tcx> Visitor<'tcx> for MoveVisitor<'a, 'mir, 'tcx> {\n+impl<'a, 'mir, 'tcx, T> Visitor<'tcx> for MoveVisitor<'a, 'mir, 'tcx, T>\n+where\n+    T: GenKill<Local>,\n+{\n     fn visit_local(&mut self, local: &Local, context: PlaceContext, loc: Location) {\n         if PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) == context {\n             let mut borrowed_locals = self.borrowed_locals.borrow_mut();\n             borrowed_locals.seek_before(loc);\n             if !borrowed_locals.contains(*local) {\n-                self.sets.kill(*local);\n+                self.trans.kill(*local);\n             }\n         }\n     }"}, {"sha": "25463f31867dfe3a02f2f9a2a8c9dfb40aa227d9", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee50590803f37abd7ad5f5f4bbd3bb844511fcf5/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee50590803f37abd7ad5f5f4bbd3bb844511fcf5/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=ee50590803f37abd7ad5f5f4bbd3bb844511fcf5", "patch": "@@ -25,7 +25,7 @@ pub use self::impls::DefinitelyInitializedPlaces;\n pub use self::impls::EverInitializedPlaces;\n pub use self::impls::{MaybeBorrowedLocals, MaybeMutBorrowedLocals};\n pub use self::impls::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n-pub use self::impls::{MaybeStorageLive, RequiresStorage};\n+pub use self::impls::{MaybeRequiresStorage, MaybeStorageLive};\n \n use self::move_paths::MoveData;\n "}, {"sha": "3107be1b62207348c57ce3a649986713ba437b28", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 35, "deletions": 58, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/ee50590803f37abd7ad5f5f4bbd3bb844511fcf5/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee50590803f37abd7ad5f5f4bbd3bb844511fcf5/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=ee50590803f37abd7ad5f5f4bbd3bb844511fcf5", "patch": "@@ -49,10 +49,8 @@\n //! For generators with state 1 (returned) and state 2 (poisoned) it does nothing.\n //! Otherwise it drops all the values in scope at the last suspension point.\n \n-use crate::dataflow::generic::{Analysis, ResultsCursor};\n-use crate::dataflow::{do_dataflow, DataflowResultsCursor, DebugFormatted};\n-use crate::dataflow::{DataflowResults, DataflowResultsConsumer, FlowAtLocation};\n-use crate::dataflow::{MaybeBorrowedLocals, MaybeStorageLive, RequiresStorage};\n+use crate::dataflow::generic::{self as dataflow, Analysis};\n+use crate::dataflow::{MaybeBorrowedLocals, MaybeRequiresStorage, MaybeStorageLive};\n use crate::transform::no_landing_pads::no_landing_pads;\n use crate::transform::simplify;\n use crate::transform::{MirPass, MirSource};\n@@ -467,18 +465,15 @@ fn locals_live_across_suspend_points(\n     source: MirSource<'tcx>,\n     movable: bool,\n ) -> LivenessInfo {\n-    let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n     let def_id = source.def_id();\n     let body_ref: &Body<'_> = &body;\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n     // lifetimes.\n-    let storage_live_analysis = MaybeStorageLive::new(body_ref);\n-    let storage_live_results =\n-        do_dataflow(tcx, body_ref, def_id, &[], &dead_unwinds, storage_live_analysis, |bd, p| {\n-            DebugFormatted::new(&bd.body().local_decls[p])\n-        });\n-    let mut storage_live_cursor = DataflowResultsCursor::new(&storage_live_results, body_ref);\n+    let mut storage_live = MaybeStorageLive\n+        .into_engine(tcx, body_ref, def_id)\n+        .iterate_to_fixpoint()\n+        .into_results_cursor(body_ref);\n \n     // Find the MIR locals which do not use StorageLive/StorageDead statements.\n     // The storage of these locals are always live.\n@@ -490,22 +485,16 @@ fn locals_live_across_suspend_points(\n     let borrowed_locals_results =\n         MaybeBorrowedLocals::all_borrows().into_engine(tcx, body_ref, def_id).iterate_to_fixpoint();\n \n-    let mut borrowed_locals_cursor = ResultsCursor::new(body_ref, &borrowed_locals_results);\n+    let mut borrowed_locals_cursor =\n+        dataflow::ResultsCursor::new(body_ref, &borrowed_locals_results);\n \n     // Calculate the MIR locals that we actually need to keep storage around\n     // for.\n-    let requires_storage_analysis = RequiresStorage::new(body, &borrowed_locals_results);\n-    let requires_storage_results = do_dataflow(\n-        tcx,\n-        body_ref,\n-        def_id,\n-        &[],\n-        &dead_unwinds,\n-        requires_storage_analysis,\n-        |bd, p| DebugFormatted::new(&bd.body().local_decls[p]),\n-    );\n+    let requires_storage_results = MaybeRequiresStorage::new(body, &borrowed_locals_results)\n+        .into_engine(tcx, body_ref, def_id)\n+        .iterate_to_fixpoint();\n     let mut requires_storage_cursor =\n-        DataflowResultsCursor::new(&requires_storage_results, body_ref);\n+        dataflow::ResultsCursor::new(body_ref, &requires_storage_results);\n \n     // Calculate the liveness of MIR locals ignoring borrows.\n     let mut live_locals = liveness::LiveVarSet::new_empty(body.local_decls.len());\n@@ -534,14 +523,14 @@ fn locals_live_across_suspend_points(\n                 liveness.outs[block].union(borrowed_locals_cursor.get());\n             }\n \n-            storage_live_cursor.seek(loc);\n-            let storage_liveness = storage_live_cursor.get();\n+            storage_live.seek_before(loc);\n+            let storage_liveness = storage_live.get();\n \n             // Store the storage liveness for later use so we can restore the state\n             // after a suspension point\n             storage_liveness_map.insert(block, storage_liveness.clone());\n \n-            requires_storage_cursor.seek(loc);\n+            requires_storage_cursor.seek_before(loc);\n             let storage_required = requires_storage_cursor.get().clone();\n \n             // Locals live are live at this point only if they are used across\n@@ -611,7 +600,7 @@ fn compute_storage_conflicts(\n     body: &'mir Body<'tcx>,\n     stored_locals: &liveness::LiveVarSet,\n     ignored: &StorageIgnored,\n-    requires_storage: DataflowResults<'tcx, RequiresStorage<'mir, 'tcx>>,\n+    requires_storage: dataflow::Results<'tcx, MaybeRequiresStorage<'mir, 'tcx>>,\n ) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n     assert_eq!(body.local_decls.len(), ignored.0.domain_size());\n     assert_eq!(body.local_decls.len(), stored_locals.domain_size());\n@@ -629,8 +618,11 @@ fn compute_storage_conflicts(\n         stored_locals: &stored_locals,\n         local_conflicts: BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len()),\n     };\n-    let mut state = FlowAtLocation::new(requires_storage);\n-    visitor.analyze_results(&mut state);\n+\n+    // Visit only reachable basic blocks. The exact order is not important.\n+    let reachable_blocks = traversal::preorder(body).map(|(bb, _)| bb);\n+    requires_storage.visit_with(body, reachable_blocks, &mut visitor);\n+\n     let local_conflicts = visitor.local_conflicts;\n \n     // Compress the matrix using only stored locals (Local -> GeneratorSavedLocal).\n@@ -659,60 +651,45 @@ fn compute_storage_conflicts(\n     storage_conflicts\n }\n \n-struct StorageConflictVisitor<'body, 'tcx, 's> {\n-    body: &'body Body<'tcx>,\n+struct StorageConflictVisitor<'mir, 'tcx, 's> {\n+    body: &'mir Body<'tcx>,\n     stored_locals: &'s liveness::LiveVarSet,\n     // FIXME(tmandry): Consider using sparse bitsets here once we have good\n     // benchmarks for generators.\n     local_conflicts: BitMatrix<Local, Local>,\n }\n \n-impl<'body, 'tcx, 's> DataflowResultsConsumer<'body, 'tcx>\n-    for StorageConflictVisitor<'body, 'tcx, 's>\n-{\n-    type FlowState = FlowAtLocation<'tcx, RequiresStorage<'body, 'tcx>>;\n-\n-    fn body(&self) -> &'body Body<'tcx> {\n-        self.body\n-    }\n-\n-    fn visit_block_entry(&mut self, block: BasicBlock, flow_state: &Self::FlowState) {\n-        // statement_index is only used for logging, so this is fine.\n-        self.apply_state(flow_state, Location { block, statement_index: 0 });\n-    }\n+impl dataflow::ResultsVisitor<'mir, 'tcx> for StorageConflictVisitor<'mir, 'tcx, '_> {\n+    type FlowState = BitSet<Local>;\n \n-    fn visit_statement_entry(\n+    fn visit_statement(\n         &mut self,\n+        state: &Self::FlowState,\n+        _statement: &'mir Statement<'tcx>,\n         loc: Location,\n-        _stmt: &Statement<'tcx>,\n-        flow_state: &Self::FlowState,\n     ) {\n-        self.apply_state(flow_state, loc);\n+        self.apply_state(state, loc);\n     }\n \n-    fn visit_terminator_entry(\n+    fn visit_terminator(\n         &mut self,\n+        state: &Self::FlowState,\n+        _terminator: &'mir Terminator<'tcx>,\n         loc: Location,\n-        _term: &Terminator<'tcx>,\n-        flow_state: &Self::FlowState,\n     ) {\n-        self.apply_state(flow_state, loc);\n+        self.apply_state(state, loc);\n     }\n }\n \n impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n-    fn apply_state(\n-        &mut self,\n-        flow_state: &FlowAtLocation<'tcx, RequiresStorage<'body, 'tcx>>,\n-        loc: Location,\n-    ) {\n+    fn apply_state(&mut self, flow_state: &BitSet<Local>, loc: Location) {\n         // Ignore unreachable blocks.\n         match self.body.basic_blocks()[loc.block].terminator().kind {\n             TerminatorKind::Unreachable => return,\n             _ => (),\n         };\n \n-        let mut eligible_storage_live = flow_state.as_dense().clone();\n+        let mut eligible_storage_live = flow_state.clone();\n         eligible_storage_live.intersect(&self.stored_locals);\n \n         for local in eligible_storage_live.iter() {"}]}