{"sha": "3d43826e32a76c86eca768481a08dec434cd28e8", "node_id": "C_kwDOAAsO6NoAKDNkNDM4MjZlMzJhNzZjODZlY2E3Njg0ODFhMDhkZWM0MzRjZDI4ZTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-07T15:23:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-07T15:23:23Z"}, "message": "Auto merge of #8305 - camsteffen:util-cleanup, r=flip1995\n\nFactor out several utils, add `path_def_id`\n\nchangelog: none\n\nThis is generally an effort to reduce the total number of utils. `path_def_id` is added which I believe is more \"cross-cutting\" and also complements `path_to_local`. Best reviewed one commit at a time.\n\nAdded:\n* `path_def_id`\n* `path_res`\n\nRemoved:\n * `is_qpath_def_path`\n * `match_any_diagnostic_items`\n * `expr_path_res`\n * `single_segment_path`\n * `differing_macro_contexts`\n * `is_ty_param_lang_item`\n * `is_ty_param_diagnostic_item`\n * `get_qpath_generics`\n\nRenamed:\n* `path_to_res` to `def_path_res`\n* `get_qpath_generic_tys` to `qpath_generic_tys`\n\nCC `@Jarcho` since this relates to some of your work and you may have input.", "tree": {"sha": "fb8b9bbc2765a6fc9ac1ef9aa5485fa87f555b2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb8b9bbc2765a6fc9ac1ef9aa5485fa87f555b2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d43826e32a76c86eca768481a08dec434cd28e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d43826e32a76c86eca768481a08dec434cd28e8", "html_url": "https://github.com/rust-lang/rust/commit/3d43826e32a76c86eca768481a08dec434cd28e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d43826e32a76c86eca768481a08dec434cd28e8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8dc719cb39efe7c16aea0b460173678429a90e8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dc719cb39efe7c16aea0b460173678429a90e8d", "html_url": "https://github.com/rust-lang/rust/commit/8dc719cb39efe7c16aea0b460173678429a90e8d"}, {"sha": "bd583d91a1bf3717f724a38531e142aa4a9ee6cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd583d91a1bf3717f724a38531e142aa4a9ee6cc", "html_url": "https://github.com/rust-lang/rust/commit/bd583d91a1bf3717f724a38531e142aa4a9ee6cc"}], "stats": {"total": 558, "additions": 249, "deletions": 309}, "files": [{"sha": "4c4dd85d518a62ae9db0938d05f56f8fdfed47dc", "filename": "clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n+use clippy_utils::get_parent_expr;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_block_with_applicability;\n use clippy_utils::ty::implements_trait;\n-use clippy_utils::{differing_macro_contexts, get_parent_expr};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n@@ -97,7 +97,7 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n                         if let Some(ex) = &block.expr {\n                             // don't dig into the expression here, just suggest that they remove\n                             // the block\n-                            if expr.span.from_expansion() || differing_macro_contexts(expr.span, ex.span) {\n+                            if expr.span.from_expansion() || ex.span.from_expansion() {\n                                 return;\n                             }\n                             let mut applicability = Applicability::MachineApplicable;\n@@ -122,7 +122,7 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n                         }\n                     } else {\n                         let span = block.expr.as_ref().map_or_else(|| block.stmts[0].span, |e| e.span);\n-                        if span.from_expansion() || differing_macro_contexts(expr.span, span) {\n+                        if span.from_expansion() || expr.span.from_expansion() {\n                             return;\n                         }\n                         // move block higher"}, {"sha": "4c12202c84ab39da96a0c1a54e5b7cb78a43f19c", "filename": "clippy_lints/src/disallowed_methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fdisallowed_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fdisallowed_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_methods.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -77,7 +77,7 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedMethods {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for (index, conf) in self.conf_disallowed.iter().enumerate() {\n             let segs: Vec<_> = conf.path().split(\"::\").collect();\n-            if let Res::Def(_, id) = clippy_utils::path_to_res(cx, &segs) {\n+            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs) {\n                 self.disallowed.insert(id, index);\n             }\n         }"}, {"sha": "14f89edce615db9993d811d34e6e8d42d62f8b14", "filename": "clippy_lints/src/disallowed_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fdisallowed_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fdisallowed_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_types.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedTypes {\n                 ),\n             };\n             let segs: Vec<_> = path.split(\"::\").collect();\n-            match clippy_utils::path_to_res(cx, &segs) {\n+            match clippy_utils::def_path_res(cx, &segs) {\n                 Res::Def(_, id) => {\n                     self.def_ids.insert(id, reason);\n                 },"}, {"sha": "57964b8d48ea9c4904282e191e097b044b140534", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note};\n-use clippy_utils::differing_macro_contexts;\n use clippy_utils::source::snippet_opt;\n use if_chain::if_chain;\n use rustc_ast::ast::{BinOpKind, Block, Expr, ExprKind, StmtKind, UnOp};\n@@ -135,7 +134,7 @@ impl EarlyLintPass for Formatting {\n /// Implementation of the `SUSPICIOUS_ASSIGNMENT_FORMATTING` lint.\n fn check_assign(cx: &EarlyContext<'_>, expr: &Expr) {\n     if let ExprKind::Assign(ref lhs, ref rhs, _) = expr.kind {\n-        if !differing_macro_contexts(lhs.span, rhs.span) && !lhs.span.from_expansion() {\n+        if !lhs.span.from_expansion() && !rhs.span.from_expansion() {\n             let eq_span = lhs.span.between(rhs.span);\n             if let ExprKind::Unary(op, ref sub_rhs) = rhs.kind {\n                 if let Some(eq_snippet) = snippet_opt(cx, eq_span) {\n@@ -165,7 +164,7 @@ fn check_assign(cx: &EarlyContext<'_>, expr: &Expr) {\n fn check_unop(cx: &EarlyContext<'_>, expr: &Expr) {\n     if_chain! {\n         if let ExprKind::Binary(ref binop, ref lhs, ref rhs) = expr.kind;\n-        if !differing_macro_contexts(lhs.span, rhs.span) && !lhs.span.from_expansion();\n+        if !lhs.span.from_expansion() && !rhs.span.from_expansion();\n         // span between BinOp LHS and RHS\n         let binop_span = lhs.span.between(rhs.span);\n         // if RHS is an UnOp\n@@ -206,8 +205,8 @@ fn check_else(cx: &EarlyContext<'_>, expr: &Expr) {\n     if_chain! {\n         if let ExprKind::If(_, then, Some(else_)) = &expr.kind;\n         if is_block(else_) || is_if(else_);\n-        if !differing_macro_contexts(then.span, else_.span);\n-        if !then.span.from_expansion() && !in_external_macro(cx.sess(), expr.span);\n+        if !then.span.from_expansion() && !else_.span.from_expansion();\n+        if !in_external_macro(cx.sess(), expr.span);\n \n         // workaround for rust-lang/rust#43081\n         if expr.span.lo().0 != 0 && expr.span.hi().0 != 0;\n@@ -268,7 +267,7 @@ fn check_array(cx: &EarlyContext<'_>, expr: &Expr) {\n         for element in array {\n             if_chain! {\n                 if let ExprKind::Binary(ref op, ref lhs, _) = element.kind;\n-                if has_unary_equivalent(op.node) && !differing_macro_contexts(lhs.span, op.span);\n+                if has_unary_equivalent(op.node) && lhs.span.ctxt() == op.span.ctxt();\n                 let space_span = lhs.span.between(op.span);\n                 if let Some(space_snippet) = snippet_opt(cx, space_span);\n                 let lint_span = lhs.span.with_lo(lhs.span.hi());\n@@ -291,8 +290,7 @@ fn check_array(cx: &EarlyContext<'_>, expr: &Expr) {\n \n fn check_missing_else(cx: &EarlyContext<'_>, first: &Expr, second: &Expr) {\n     if_chain! {\n-        if !differing_macro_contexts(first.span, second.span);\n-        if !first.span.from_expansion();\n+        if !first.span.from_expansion() && !second.span.from_expansion();\n         if let ExprKind::If(cond_expr, ..) = &first.kind;\n         if is_block(second) || is_if(second);\n "}, {"sha": "3fb7e5dfd6cdcaf8d9ffb2ca65c640a1d9e40035", "filename": "clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -17,7 +17,6 @@ use rustc_typeck::hir_ty_to_ty;\n use if_chain::if_chain;\n \n use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n-use clippy_utils::differing_macro_contexts;\n use clippy_utils::source::{snippet, snippet_opt};\n use clippy_utils::ty::is_type_diagnostic_item;\n \n@@ -123,7 +122,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n                 vis.visit_ty(impl_.self_ty);\n \n                 for target in &vis.found {\n-                    if differing_macro_contexts(item.span, target.span()) {\n+                    if item.span.ctxt() != target.span().ctxt() {\n                         return;\n                     }\n "}, {"sha": "b6badef02f58a989e4fa23332fded3c3d3fa7a99", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n-use clippy_utils::{get_trait_def_id, higher, is_qpath_def_path, paths};\n+use clippy_utils::{get_trait_def_id, higher, match_def_path, path_def_id, paths};\n use rustc_hir::{BorrowKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -167,13 +167,9 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n         },\n         ExprKind::Block(block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n         ExprKind::Box(e) | ExprKind::AddrOf(BorrowKind::Ref, _, e) => is_infinite(cx, e),\n-        ExprKind::Call(path, _) => {\n-            if let ExprKind::Path(ref qpath) = path.kind {\n-                is_qpath_def_path(cx, qpath, path.hir_id, &paths::ITER_REPEAT).into()\n-            } else {\n-                Finite\n-            }\n-        },\n+        ExprKind::Call(path, _) => path_def_id(cx, path)\n+            .map_or(false, |id| match_def_path(cx, id, &paths::ITER_REPEAT))\n+            .into(),\n         ExprKind::Struct(..) => higher::Range::hir(expr).map_or(false, |r| r.end.is_none()).into(),\n         _ => Finite,\n     }"}, {"sha": "36ecd83f7d643734e0f0f2df0977cd63f3c5ea70", "filename": "clippy_lints/src/loops/single_element_loop.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -1,10 +1,9 @@\n use super::SINGLE_ELEMENT_LOOP;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::single_segment_path;\n-use clippy_utils::source::{indent_of, snippet};\n+use clippy_utils::source::{indent_of, snippet_with_applicability};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, Pat, PatKind};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Pat};\n use rustc_lint::LateContext;\n \n pub(super) fn check<'tcx>(\n@@ -16,33 +15,30 @@ pub(super) fn check<'tcx>(\n ) {\n     let arg_expr = match arg.kind {\n         ExprKind::AddrOf(BorrowKind::Ref, _, ref_arg) => ref_arg,\n-        ExprKind::MethodCall(method, args, _) if args.len() == 1 && method.ident.name == rustc_span::sym::iter => {\n-            &args[0]\n-        },\n+        ExprKind::MethodCall(method, [arg], _) if method.ident.name == rustc_span::sym::iter => arg,\n         _ => return,\n     };\n     if_chain! {\n-        if let PatKind::Binding(.., target, _) = pat.kind;\n         if let ExprKind::Array([arg_expression]) = arg_expr.kind;\n-        if let ExprKind::Path(ref list_item) = arg_expression.kind;\n-        if let Some(list_item_name) = single_segment_path(list_item).map(|ps| ps.ident.name);\n         if let ExprKind::Block(block, _) = body.kind;\n         if !block.stmts.is_empty();\n-\n         then {\n-            let mut block_str = snippet(cx, block.span, \"..\").into_owned();\n+            let mut applicability = Applicability::MachineApplicable;\n+            let pat_snip = snippet_with_applicability(cx, pat.span, \"..\", &mut applicability);\n+            let arg_snip = snippet_with_applicability(cx, arg_expression.span, \"..\", &mut applicability);\n+            let mut block_str = snippet_with_applicability(cx, block.span, \"..\", &mut applicability).into_owned();\n             block_str.remove(0);\n             block_str.pop();\n-\n+            let indent = \" \".repeat(indent_of(cx, block.stmts[0].span).unwrap_or(0));\n \n             span_lint_and_sugg(\n                 cx,\n                 SINGLE_ELEMENT_LOOP,\n                 expr.span,\n                 \"for loop over a single element\",\n                 \"try\",\n-                format!(\"{{\\n{}let {} = &{};{}}}\", \" \".repeat(indent_of(cx, block.stmts[0].span).unwrap_or(0)), target.name, list_item_name, block_str),\n-                Applicability::MachineApplicable\n+                format!(\"{{\\n{}let {} = &{};{}}}\", indent, pat_snip, arg_snip, block_str),\n+                applicability,\n             )\n         }\n     }"}, {"sha": "67fb918d20c0a4e35752e2482140e57c8110dcef", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -1860,22 +1860,22 @@ where\n mod redundant_pattern_match {\n     use super::REDUNDANT_PATTERN_MATCHING;\n     use clippy_utils::diagnostics::span_lint_and_then;\n-    use clippy_utils::higher;\n     use clippy_utils::source::snippet;\n     use clippy_utils::sugg::Sugg;\n     use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, is_type_lang_item, match_type};\n-    use clippy_utils::{is_lang_ctor, is_qpath_def_path, is_trait_method, paths};\n+    use clippy_utils::{higher, match_def_path};\n+    use clippy_utils::{is_lang_ctor, is_trait_method, paths};\n     use if_chain::if_chain;\n     use rustc_ast::ast::LitKind;\n     use rustc_data_structures::fx::FxHashSet;\n     use rustc_errors::Applicability;\n-    use rustc_hir::LangItem::{OptionNone, OptionSome, PollPending, PollReady, ResultErr, ResultOk};\n+    use rustc_hir::LangItem::{OptionNone, PollPending};\n     use rustc_hir::{\n         intravisit::{walk_expr, Visitor},\n         Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, Pat, PatKind, QPath, UnOp,\n     };\n     use rustc_lint::LateContext;\n-    use rustc_middle::ty::{self, subst::GenericArgKind, Ty};\n+    use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n     use rustc_span::sym;\n \n     pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n@@ -2051,28 +2051,31 @@ mod redundant_pattern_match {\n         has_else: bool,\n     ) {\n         // also look inside refs\n-        let mut kind = &let_pat.kind;\n         // if we have &None for example, peel it so we can detect \"if let None = x\"\n-        if let PatKind::Ref(inner, _mutability) = kind {\n-            kind = &inner.kind;\n-        }\n+        let check_pat = match let_pat.kind {\n+            PatKind::Ref(inner, _mutability) => inner,\n+            _ => let_pat,\n+        };\n         let op_ty = cx.typeck_results().expr_ty(let_expr);\n         // Determine which function should be used, and the type contained by the corresponding\n         // variant.\n-        let (good_method, inner_ty) = match kind {\n-            PatKind::TupleStruct(ref path, [sub_pat], _) => {\n+        let (good_method, inner_ty) = match check_pat.kind {\n+            PatKind::TupleStruct(ref qpath, [sub_pat], _) => {\n                 if let PatKind::Wild = sub_pat.kind {\n-                    if is_lang_ctor(cx, path, ResultOk) {\n+                    let res = cx.typeck_results().qpath_res(qpath, check_pat.hir_id);\n+                    let Some(id) = res.opt_def_id().and_then(|ctor_id| cx.tcx.parent(ctor_id)) else { return };\n+                    let lang_items = cx.tcx.lang_items();\n+                    if Some(id) == lang_items.result_ok_variant() {\n                         (\"is_ok()\", try_get_generic_ty(op_ty, 0).unwrap_or(op_ty))\n-                    } else if is_lang_ctor(cx, path, ResultErr) {\n+                    } else if Some(id) == lang_items.result_err_variant() {\n                         (\"is_err()\", try_get_generic_ty(op_ty, 1).unwrap_or(op_ty))\n-                    } else if is_lang_ctor(cx, path, OptionSome) {\n+                    } else if Some(id) == lang_items.option_some_variant() {\n                         (\"is_some()\", op_ty)\n-                    } else if is_lang_ctor(cx, path, PollReady) {\n+                    } else if Some(id) == lang_items.poll_ready_variant() {\n                         (\"is_ready()\", op_ty)\n-                    } else if is_qpath_def_path(cx, path, sub_pat.hir_id, &paths::IPADDR_V4) {\n+                    } else if match_def_path(cx, id, &paths::IPADDR_V4) {\n                         (\"is_ipv4()\", op_ty)\n-                    } else if is_qpath_def_path(cx, path, sub_pat.hir_id, &paths::IPADDR_V6) {\n+                    } else if match_def_path(cx, id, &paths::IPADDR_V6) {\n                         (\"is_ipv6()\", op_ty)\n                     } else {\n                         return;\n@@ -2272,17 +2275,22 @@ mod redundant_pattern_match {\n         should_be_left: &'a str,\n         should_be_right: &'a str,\n     ) -> Option<&'a str> {\n-        let body_node_pair = if is_qpath_def_path(cx, path_left, arms[0].pat.hir_id, expected_left)\n-            && is_qpath_def_path(cx, path_right, arms[1].pat.hir_id, expected_right)\n-        {\n-            (&(*arms[0].body).kind, &(*arms[1].body).kind)\n-        } else if is_qpath_def_path(cx, path_right, arms[1].pat.hir_id, expected_left)\n-            && is_qpath_def_path(cx, path_left, arms[0].pat.hir_id, expected_right)\n-        {\n-            (&(*arms[1].body).kind, &(*arms[0].body).kind)\n-        } else {\n-            return None;\n-        };\n+        let left_id = cx\n+            .typeck_results()\n+            .qpath_res(path_left, arms[0].pat.hir_id)\n+            .opt_def_id()?;\n+        let right_id = cx\n+            .typeck_results()\n+            .qpath_res(path_right, arms[1].pat.hir_id)\n+            .opt_def_id()?;\n+        let body_node_pair =\n+            if match_def_path(cx, left_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n+                (&(*arms[0].body).kind, &(*arms[1].body).kind)\n+            } else if match_def_path(cx, right_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n+                (&(*arms[1].body).kind, &(*arms[0].body).kind)\n+            } else {\n+                return None;\n+            };\n \n         match body_node_pair {\n             (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {"}, {"sha": "2cf2c5641bf10654e37c51cfb31171ce62bce223", "filename": "clippy_lints/src/methods/chars_cmp.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -1,13 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{method_chain_args, single_segment_path};\n+use clippy_utils::{method_chain_args, path_def_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_lint::Lint;\n-use rustc_middle::ty;\n-use rustc_span::sym;\n+use rustc_middle::ty::{self, DefIdTree};\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints.\n pub(super) fn check(\n@@ -19,11 +18,9 @@ pub(super) fn check(\n ) -> bool {\n     if_chain! {\n         if let Some(args) = method_chain_args(info.chain, chain_methods);\n-        if let hir::ExprKind::Call(fun, arg_char) = info.other.kind;\n-        if arg_char.len() == 1;\n-        if let hir::ExprKind::Path(ref qpath) = fun.kind;\n-        if let Some(segment) = single_segment_path(qpath);\n-        if segment.ident.name == sym::Some;\n+        if let hir::ExprKind::Call(fun, [arg_char]) = info.other.kind;\n+        if let Some(id) = path_def_id(cx, fun).and_then(|ctor_id| cx.tcx.parent(ctor_id));\n+        if Some(id) == cx.tcx.lang_items().option_some_variant();\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0][0]).peel_refs();\n@@ -42,7 +39,7 @@ pub(super) fn check(\n                         if info.eq { \"\" } else { \"!\" },\n                         snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n                         suggest,\n-                        snippet_with_applicability(cx, arg_char[0].span, \"..\", &mut applicability)),\n+                        snippet_with_applicability(cx, arg_char.span, \"..\", &mut applicability)),\n                 applicability,\n             );\n "}, {"sha": "0fe510beaa07ee8640d48599b3025775744c8e84", "filename": "clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_qpath_def_path;\n use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{match_def_path, path_def_id};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_errors::Applicability;\n@@ -93,12 +93,12 @@ fn is_min_or_max<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>) -> Option<M\n     let ty_str = ty.to_string();\n \n     // `std::T::MAX` `std::T::MIN` constants\n-    if let hir::ExprKind::Path(path) = &expr.kind {\n-        if is_qpath_def_path(cx, path, expr.hir_id, &[\"core\", &ty_str, \"MAX\"][..]) {\n+    if let Some(id) = path_def_id(cx, expr) {\n+        if match_def_path(cx, id, &[\"core\", &ty_str, \"MAX\"]) {\n             return Some(MinMax::Max);\n         }\n \n-        if is_qpath_def_path(cx, path, expr.hir_id, &[\"core\", &ty_str, \"MIN\"][..]) {\n+        if match_def_path(cx, id, &[\"core\", &ty_str, \"MIN\"]) {\n             return Some(MinMax::Min);\n         }\n     }"}, {"sha": "bdf8cea120739f63b1092dc88cafc352cfb0f741", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -1,11 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_lang_ctor, single_segment_path};\n+use clippy_utils::{is_lang_ctor, path_def_id};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_lint::LateContext;\n+use rustc_middle::ty::DefIdTree;\n use rustc_span::symbol::sym;\n \n use super::OPTION_MAP_OR_NONE;\n@@ -76,13 +77,11 @@ pub(super) fn check<'tcx>(\n         if let hir::ExprKind::Closure(_, _, id, span, _) = map_arg.kind;\n             let arg_snippet = snippet(cx, span, \"..\");\n             let body = cx.tcx.hir().body(id);\n-                if let Some((func, arg_char)) = reduce_unit_expression(cx, &body.value);\n-                if arg_char.len() == 1;\n-                if let hir::ExprKind::Path(ref qpath) = func.kind;\n-                if let Some(segment) = single_segment_path(qpath);\n-                if segment.ident.name == sym::Some;\n+                if let Some((func, [arg_char])) = reduce_unit_expression(cx, &body.value);\n+                if let Some(id) = path_def_id(cx, func).and_then(|ctor_id| cx.tcx.parent(ctor_id));\n+                if Some(id) == cx.tcx.lang_items().option_some_variant();\n                 then {\n-                    let func_snippet = snippet(cx, arg_char[0].span, \"..\");\n+                    let func_snippet = snippet(cx, arg_char.span, \"..\");\n                     let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n                        `map(..)` instead\";\n                     return span_lint_and_sugg("}, {"sha": "6c641af59f92b9c6a3f1b6941c01305f8b8bd464", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::differing_macro_contexts;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_copy;\n use clippy_utils::ty::is_type_diagnostic_item;\n@@ -48,7 +47,7 @@ pub(super) fn check<'tcx>(\n             }\n         }\n \n-        if differing_macro_contexts(unwrap_arg.span, map_span) {\n+        if unwrap_arg.span.ctxt() != map_span.ctxt() {\n             return;\n         }\n "}, {"sha": "ac82dd306a52879d1d96976dac46938d06abd974", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -20,8 +20,8 @@ use rustc_span::symbol::sym;\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{\n-    expr_path_res, get_item_name, get_parent_expr, in_constant, is_diag_trait_item, is_integer_const, iter_input_pats,\n-    last_path_segment, match_any_def_paths, paths, unsext, SpanlessEq,\n+    get_item_name, get_parent_expr, in_constant, is_diag_trait_item, is_integer_const, iter_input_pats,\n+    last_path_segment, match_any_def_paths, path_def_id, paths, unsext, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -583,8 +583,7 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left:\n             )\n         },\n         ExprKind::Call(path, [arg]) => {\n-            if expr_path_res(cx, path)\n-                .opt_def_id()\n+            if path_def_id(cx, path)\n                 .and_then(|id| match_any_def_paths(cx, id, &[&paths::FROM_STR_METHOD, &paths::FROM_FROM]))\n                 .is_some()\n             {"}, {"sha": "3d0a23822838e871c3c6ef5f891aa4303505b7d3", "filename": "clippy_lints/src/missing_enforced_import_rename.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -58,7 +58,7 @@ impl_lint_pass!(ImportRename => [MISSING_ENFORCED_IMPORT_RENAMES]);\n impl LateLintPass<'_> for ImportRename {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for Rename { path, rename } in &self.conf_renames {\n-            if let Res::Def(_, id) = clippy_utils::path_to_res(cx, &path.split(\"::\").collect::<Vec<_>>()) {\n+            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &path.split(\"::\").collect::<Vec<_>>()) {\n                 self.renames.insert(id, Symbol::intern(rename));\n             }\n         }"}, {"sha": "e0ce1b7db003afb96091e912a701d1e0ab2f7a84", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -3,9 +3,7 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::expr_sig;\n-use clippy_utils::{\n-    expr_path_res, get_expr_use_or_unification_node, is_lint_allowed, match_any_diagnostic_items, path_to_local, paths,\n-};\n+use clippy_utils::{get_expr_use_or_unification_node, is_lint_allowed, path_def_id, path_to_local, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::DefId;\n@@ -673,8 +671,8 @@ fn get_rptr_lm<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> Option<(&'tcx Lifetime, Mutabil\n \n fn is_null_path(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     if let ExprKind::Call(pathexp, []) = expr.kind {\n-        expr_path_res(cx, pathexp).opt_def_id().map_or(false, |id| {\n-            match_any_diagnostic_items(cx, id, &[sym::ptr_null, sym::ptr_null_mut]).is_some()\n+        path_def_id(cx, pathexp).map_or(false, |id| {\n+            matches!(cx.tcx.get_diagnostic_name(id), Some(sym::ptr_null | sym::ptr_null_mut))\n         })\n     } else {\n         false"}, {"sha": "e213c208794c1d4d0dd43c6a995de040b99bfa9a", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -2,19 +2,18 @@ use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::{get_parent_expr, in_constant, is_integer_const, meets_msrv, msrvs, single_segment_path};\n+use clippy_utils::{get_parent_expr, in_constant, is_integer_const, meets_msrv, msrvs, path_to_local};\n use clippy_utils::{higher, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::RangeLimits;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, QPath};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, HirId, PathSegment, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::sym;\n-use rustc_span::symbol::Ident;\n use std::cmp::Ordering;\n \n declare_clippy_lint! {\n@@ -220,12 +219,12 @@ fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'\n         _ => return,\n     };\n     // value, name, order (higher/lower), inclusiveness\n-    if let (Some((lval, lname, name_span, lval_span, lord, linc)), Some((rval, rname, _, rval_span, rord, rinc))) =\n+    if let (Some((lval, lid, name_span, lval_span, lord, linc)), Some((rval, rid, _, rval_span, rord, rinc))) =\n         (check_range_bounds(cx, l), check_range_bounds(cx, r))\n     {\n         // we only lint comparisons on the same name and with different\n         // direction\n-        if lname != rname || lord == rord {\n+        if lid != rid || lord == rord {\n             return;\n         }\n         let ord = Constant::partial_cmp(cx.tcx, cx.typeck_results().expr_ty(l), &lval, &rval);\n@@ -293,7 +292,7 @@ fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'\n     }\n }\n \n-fn check_range_bounds(cx: &LateContext<'_>, ex: &Expr<'_>) -> Option<(Constant, Ident, Span, Span, Ordering, bool)> {\n+fn check_range_bounds(cx: &LateContext<'_>, ex: &Expr<'_>) -> Option<(Constant, HirId, Span, Span, Ordering, bool)> {\n     if let ExprKind::Binary(ref op, l, r) = ex.kind {\n         let (inclusive, ordering) = match op.node {\n             BinOpKind::Gt => (false, Ordering::Greater),\n@@ -302,11 +301,11 @@ fn check_range_bounds(cx: &LateContext<'_>, ex: &Expr<'_>) -> Option<(Constant,\n             BinOpKind::Le => (true, Ordering::Less),\n             _ => return None,\n         };\n-        if let Some(id) = match_ident(l) {\n+        if let Some(id) = path_to_local(l) {\n             if let Some((c, _)) = constant(cx, cx.typeck_results(), r) {\n                 return Some((c, id, l.span, r.span, ordering, inclusive));\n             }\n-        } else if let Some(id) = match_ident(r) {\n+        } else if let Some(id) = path_to_local(r) {\n             if let Some((c, _)) = constant(cx, cx.typeck_results(), l) {\n                 return Some((c, id, r.span, l.span, ordering.reverse(), inclusive));\n             }\n@@ -315,17 +314,6 @@ fn check_range_bounds(cx: &LateContext<'_>, ex: &Expr<'_>) -> Option<(Constant,\n     None\n }\n \n-fn match_ident(e: &Expr<'_>) -> Option<Ident> {\n-    if let ExprKind::Path(ref qpath) = e.kind {\n-        if let Some(seg) = single_segment_path(qpath) {\n-            if seg.args.is_none() {\n-                return Some(seg.ident);\n-            }\n-        }\n-    }\n-    None\n-}\n-\n fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args: &[Expr<'_>], span: Span) {\n     if_chain! {\n         if path.ident.as_str() == \"zip\";"}, {"sha": "1885f3ca414dfe9dbef2a600fc961cf4f6b9ebb5", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{can_mut_borrow_both, differing_macro_contexts, eq_expr_value, std_or_core};\n+use clippy_utils::{can_mut_borrow_both, eq_expr_value, std_or_core};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Block, Expr, ExprKind, PatKind, QPath, Stmt, StmtKind};\n@@ -172,7 +172,7 @@ fn check_suspicious_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n         if_chain! {\n             if let StmtKind::Semi(first) = w[0].kind;\n             if let StmtKind::Semi(second) = w[1].kind;\n-            if !differing_macro_contexts(first.span, second.span);\n+            if first.span.ctxt() == second.span.ctxt();\n             if let ExprKind::Assign(lhs0, rhs0, _) = first.kind;\n             if let ExprKind::Assign(lhs1, rhs1, _) = second.kind;\n             if eq_expr_value(cx, lhs0, rhs1);"}, {"sha": "2d67401a15f2d65b96cacdbaa0f92e69c6ae7fce", "filename": "clippy_lints/src/transmute/unsound_collection_transmute.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -1,29 +1,31 @@\n use super::utils::is_layout_incompatible;\n use super::UNSOUND_COLLECTION_TRANSMUTE;\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::match_any_diagnostic_items;\n use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::symbol::{sym, Symbol};\n-\n-// used to check for UNSOUND_COLLECTION_TRANSMUTE\n-static COLLECTIONS: &[Symbol] = &[\n-    sym::Vec,\n-    sym::VecDeque,\n-    sym::BinaryHeap,\n-    sym::BTreeSet,\n-    sym::BTreeMap,\n-    sym::HashSet,\n-    sym::HashMap,\n-];\n+use rustc_span::symbol::sym;\n \n /// Checks for `unsound_collection_transmute` lint.\n /// Returns `true` if it's triggered, otherwise returns `false`.\n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n         (ty::Adt(from_adt, from_substs), ty::Adt(to_adt, to_substs)) => {\n-            if from_adt.did != to_adt.did || match_any_diagnostic_items(cx, to_adt.did, COLLECTIONS).is_none() {\n+            if from_adt.did != to_adt.did {\n+                return false;\n+            }\n+            if !matches!(\n+                cx.tcx.get_diagnostic_name(to_adt.did),\n+                Some(\n+                    sym::BTreeMap\n+                        | sym::BTreeSet\n+                        | sym::BinaryHeap\n+                        | sym::HashMap\n+                        | sym::HashSet\n+                        | sym::Vec\n+                        | sym::VecDeque\n+                )\n+            ) {\n                 return false;\n             }\n             if from_substs"}, {"sha": "21a9558ec076a54e938fadc06f56fb6f9fa5ee34", "filename": "clippy_lints/src/types/box_collection.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::is_ty_param_diagnostic_item;\n+use clippy_utils::{path_def_id, qpath_generic_tys};\n use rustc_hir::{self as hir, def_id::DefId, QPath};\n use rustc_lint::LateContext;\n-use rustc_span::symbol::sym;\n+use rustc_span::{sym, Symbol};\n \n use super::BOX_COLLECTION;\n \n@@ -11,10 +11,9 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n         if Some(def_id) == cx.tcx.lang_items().owned_box();\n         if let Some(item_type) = get_std_collection(cx, qpath);\n         then {\n-            let generic = if item_type == \"String\" {\n-                \"\"\n-            } else {\n-                \"<..>\"\n+            let generic = match item_type {\n+                sym::String => \"\",\n+                _ => \"<..>\",\n             };\n             span_lint_and_help(\n                 cx,\n@@ -37,14 +36,10 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n     }\n }\n \n-fn get_std_collection(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<&'static str> {\n-    if is_ty_param_diagnostic_item(cx, qpath, sym::Vec).is_some() {\n-        Some(\"Vec\")\n-    } else if is_ty_param_diagnostic_item(cx, qpath, sym::String).is_some() {\n-        Some(\"String\")\n-    } else if is_ty_param_diagnostic_item(cx, qpath, sym::HashMap).is_some() {\n-        Some(\"HashMap\")\n-    } else {\n-        None\n-    }\n+fn get_std_collection(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<Symbol> {\n+    let param = qpath_generic_tys(qpath).next()?;\n+    let id = path_def_id(cx, param)?;\n+    cx.tcx\n+        .get_diagnostic_name(id)\n+        .filter(|&name| matches!(name, sym::HashMap | sym::String | sym::Vec))\n }"}, {"sha": "8767e3c30a68ac4564ba72814b48f53719090be3", "filename": "clippy_lints/src/types/option_option.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Ftypes%2Foption_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Ftypes%2Foption_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Foption_option.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -1,22 +1,28 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::is_ty_param_diagnostic_item;\n+use clippy_utils::{path_def_id, qpath_generic_tys};\n+use if_chain::if_chain;\n use rustc_hir::{self as hir, def_id::DefId, QPath};\n use rustc_lint::LateContext;\n use rustc_span::symbol::sym;\n \n use super::OPTION_OPTION;\n \n pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n-    if cx.tcx.is_diagnostic_item(sym::Option, def_id) && is_ty_param_diagnostic_item(cx, qpath, sym::Option).is_some() {\n-        span_lint(\n-            cx,\n-            OPTION_OPTION,\n-            hir_ty.span,\n-            \"consider using `Option<T>` instead of `Option<Option<T>>` or a custom \\\n-                                 enum if you need to distinguish all 3 cases\",\n-        );\n-        true\n-    } else {\n-        false\n+    if_chain! {\n+        if cx.tcx.is_diagnostic_item(sym::Option, def_id);\n+        if let Some(arg) = qpath_generic_tys(qpath).next();\n+        if path_def_id(cx, arg) == Some(def_id);\n+        then {\n+            span_lint(\n+                cx,\n+                OPTION_OPTION,\n+                hir_ty.span,\n+                \"consider using `Option<T>` instead of `Option<Option<T>>` or a custom \\\n+                                     enum if you need to distinguish all 3 cases\",\n+            );\n+            true\n+        } else {\n+            false\n+        }\n     }\n }"}, {"sha": "4d72a29e8c74722711aeb3b6a754e3d0c2bd4765", "filename": "clippy_lints/src/types/rc_buffer.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{get_qpath_generic_tys, is_ty_param_diagnostic_item};\n+use clippy_utils::{path_def_id, qpath_generic_tys};\n use rustc_errors::Applicability;\n use rustc_hir::{self as hir, def_id::DefId, QPath, TyKind};\n use rustc_lint::LateContext;\n@@ -20,12 +20,17 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n                 format!(\"Rc<{}>\", alternate),\n                 Applicability::MachineApplicable,\n             );\n-        } else if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::Vec) {\n+        } else {\n+            let Some(ty) = qpath_generic_tys(qpath).next() else { return false };\n+            let Some(id) = path_def_id(cx, ty) else { return false };\n+            if !cx.tcx.is_diagnostic_item(sym::Vec, id) {\n+                return false;\n+            }\n             let qpath = match &ty.kind {\n                 TyKind::Path(qpath) => qpath,\n                 _ => return false,\n             };\n-            let inner_span = match get_qpath_generic_tys(qpath).next() {\n+            let inner_span = match qpath_generic_tys(qpath).next() {\n                 Some(ty) => ty.span,\n                 None => return false,\n             };\n@@ -55,12 +60,16 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n                 format!(\"Arc<{}>\", alternate),\n                 Applicability::MachineApplicable,\n             );\n-        } else if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::Vec) {\n+        } else if let Some(ty) = qpath_generic_tys(qpath).next() {\n+            let Some(id) = path_def_id(cx, ty) else { return false };\n+            if !cx.tcx.is_diagnostic_item(sym::Vec, id) {\n+                return false;\n+            }\n             let qpath = match &ty.kind {\n                 TyKind::Path(qpath) => qpath,\n                 _ => return false,\n             };\n-            let inner_span = match get_qpath_generic_tys(qpath).next() {\n+            let inner_span = match qpath_generic_tys(qpath).next() {\n                 Some(ty) => ty.span,\n                 None => return false,\n             };\n@@ -85,13 +94,13 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n }\n \n fn match_buffer_type(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<&'static str> {\n-    if is_ty_param_diagnostic_item(cx, qpath, sym::String).is_some() {\n-        Some(\"str\")\n-    } else if is_ty_param_diagnostic_item(cx, qpath, sym::OsString).is_some() {\n-        Some(\"std::ffi::OsStr\")\n-    } else if is_ty_param_diagnostic_item(cx, qpath, sym::PathBuf).is_some() {\n-        Some(\"std::path::Path\")\n-    } else {\n-        None\n-    }\n+    let ty = qpath_generic_tys(qpath).next()?;\n+    let id = path_def_id(cx, ty)?;\n+    let path = match cx.tcx.get_diagnostic_name(id)? {\n+        sym::String => \"str\",\n+        sym::OsString => \"std::ffi::OsStr\",\n+        sym::PathBuf => \"std::path::Path\",\n+        _ => return None,\n+    };\n+    Some(path)\n }"}, {"sha": "a75972cf3ddbe1e2d91acbf11fc541577c7ed7e5", "filename": "clippy_lints/src/types/rc_mutex.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Ftypes%2Frc_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Ftypes%2Frc_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Frc_mutex.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::is_ty_param_diagnostic_item;\n+use clippy_utils::{path_def_id, qpath_generic_tys};\n use if_chain::if_chain;\n use rustc_hir::{self as hir, def_id::DefId, QPath};\n use rustc_lint::LateContext;\n@@ -10,7 +10,9 @@ use super::RC_MUTEX;\n pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n     if_chain! {\n         if cx.tcx.is_diagnostic_item(sym::Rc, def_id) ;\n-        if let Some(_) = is_ty_param_diagnostic_item(cx, qpath, sym::Mutex) ;\n+        if let Some(arg) = qpath_generic_tys(qpath).next();\n+        if let Some(id) = path_def_id(cx, arg);\n+        if cx.tcx.is_diagnostic_item(sym::Mutex, id);\n         then {\n             span_lint_and_help(\n                 cx,"}, {"sha": "10d2ae2eb1dbb8808eb0fa601d0fc1ffad349dfb", "filename": "clippy_lints/src/types/redundant_allocation.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::{snippet, snippet_with_applicability};\n-use clippy_utils::{get_qpath_generic_tys, is_ty_param_diagnostic_item, is_ty_param_lang_item};\n+use clippy_utils::{path_def_id, qpath_generic_tys};\n use rustc_errors::Applicability;\n-use rustc_hir::{self as hir, def_id::DefId, LangItem, QPath, TyKind};\n+use rustc_hir::{self as hir, def_id::DefId, QPath, TyKind};\n use rustc_lint::LateContext;\n use rustc_span::symbol::sym;\n \n@@ -39,21 +39,20 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n         return true;\n     }\n \n-    let (inner_sym, ty) = if let Some(ty) = is_ty_param_lang_item(cx, qpath, LangItem::OwnedBox) {\n-        (\"Box\", ty)\n-    } else if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::Rc) {\n-        (\"Rc\", ty)\n-    } else if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::Arc) {\n-        (\"Arc\", ty)\n-    } else {\n-        return false;\n+    let Some(ty) = qpath_generic_tys(qpath).next() else { return false };\n+    let Some(id) = path_def_id(cx, ty) else { return false };\n+    let (inner_sym, ty) = match cx.tcx.get_diagnostic_name(id) {\n+        Some(sym::Arc) => (\"Arc\", ty),\n+        Some(sym::Rc) => (\"Rc\", ty),\n+        _ if Some(id) == cx.tcx.lang_items().owned_box() => (\"Box\", ty),\n+        _ => return false,\n     };\n \n     let inner_qpath = match &ty.kind {\n         TyKind::Path(inner_qpath) => inner_qpath,\n         _ => return false,\n     };\n-    let inner_span = match get_qpath_generic_tys(inner_qpath).next() {\n+    let inner_span = match qpath_generic_tys(inner_qpath).next() {\n         Some(ty) => {\n             // Box<Box<dyn T>> is smaller than Box<dyn T> because of wide pointers\n             if matches!(ty.kind, TyKind::TraitObject(..)) {"}, {"sha": "9b9e25326f9663b11e84984b0acb71e59ffc1cfa", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{differing_macro_contexts, path_to_local, usage::is_potentially_mutated};\n+use clippy_utils::{path_to_local, usage::is_potentially_mutated};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, walk_fn, FnKind, Visitor};\n@@ -238,8 +238,9 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n                 if let Some(unwrappable) = self.unwrappables.iter()\n                     .find(|u| u.local_id == id);\n                 // Span contexts should not differ with the conditional branch\n-                if !differing_macro_contexts(unwrappable.branch.span, expr.span);\n-                if !differing_macro_contexts(unwrappable.branch.span, unwrappable.check.span);\n+                let span_ctxt = expr.span.ctxt();\n+                if unwrappable.branch.span.ctxt() == span_ctxt;\n+                if unwrappable.check.span.ctxt() == span_ctxt;\n                 then {\n                     if call_to_unwrap == unwrappable.safe_to_unwrap {\n                         let is_entire_condition = unwrappable.is_entire_condition;"}, {"sha": "dc0f515bfe5cb1d97e075396e242722eeab43502", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -4,8 +4,8 @@ use clippy_utils::macros::root_macro_call_first_node;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::match_type;\n use clippy_utils::{\n-    higher, is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_def_path, method_calls,\n-    path_to_res, paths, peel_blocks_with_stmt, SpanlessEq,\n+    def_path_res, higher, is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_def_path,\n+    method_calls, paths, peel_blocks_with_stmt, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast as ast;\n@@ -844,7 +844,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n             // Extract the path to the matched type\n             if let Some(segments) = path_to_matched_type(cx, ty_path);\n             let segments: Vec<&str> = segments.iter().map(Symbol::as_str).collect();\n-            if let Some(ty_did) = path_to_res(cx, &segments[..]).opt_def_id();\n+            if let Some(ty_did) = def_path_res(cx, &segments[..]).opt_def_id();\n             // Check if the matched type is a diagnostic item\n             if let Some(item_name) = cx.tcx.get_diagnostic_name(ty_did);\n             then {\n@@ -917,7 +917,7 @@ fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Ve\n // This is not a complete resolver for paths. It works on all the paths currently used in the paths\n // module.  That's all it does and all it needs to do.\n pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n-    if path_to_res(cx, path) != Res::Err {\n+    if def_path_res(cx, path) != Res::Err {\n         return true;\n     }\n \n@@ -999,7 +999,7 @@ impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n         }\n \n         for &module in &[&paths::KW_MODULE, &paths::SYM_MODULE] {\n-            if let Some(def_id) = path_to_res(cx, module).opt_def_id() {\n+            if let Some(def_id) = def_path_res(cx, module).opt_def_id() {\n                 for item in cx.tcx.module_children(def_id).iter() {\n                     if_chain! {\n                         if let Res::Def(DefKind::Const, item_def_id) = item.res;"}, {"sha": "a2b10c12eb90cbcf8871bcdfda3691e452d78cbe", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -1,5 +1,4 @@\n use crate::consts::{constant_context, constant_simple};\n-use crate::differing_macro_contexts;\n use crate::source::snippet_opt;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n use rustc_data_structures::fx::FxHasher;\n@@ -186,7 +185,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n \n     #[allow(clippy::similar_names)]\n     pub fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n-        if !self.inner.allow_side_effects && differing_macro_contexts(left.span, right.span) {\n+        if !self.inner.allow_side_effects && left.span.ctxt() != right.span.ctxt() {\n             return false;\n         }\n "}, {"sha": "f76004774add0eafb4a35c804fd985b2a9d677a6", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 55, "deletions": 109, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -77,9 +77,9 @@ use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n use rustc_hir::{\n     def, lang_items, Arm, ArrayLen, BindingAnnotation, Block, BlockCheckMode, Body, Constness, Destination, Expr,\n-    ExprKind, FnDecl, ForeignItem, GenericArgs, HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem,\n-    Local, MatchSource, Mutability, Node, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind,\n-    Target, TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n+    ExprKind, FnDecl, ForeignItem, HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local,\n+    MatchSource, Mutability, Node, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, Target,\n+    TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::place::PlaceBase;\n@@ -134,13 +134,6 @@ macro_rules! extract_msrv_attr {\n     };\n }\n \n-/// Returns `true` if the two spans come from differing expansions (i.e., one is\n-/// from a macro and one isn't).\n-#[must_use]\n-pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n-    rhs.ctxt() != lhs.ctxt()\n-}\n-\n /// If the given expression is a local binding, find the initializer expression.\n /// If that initializer expression is another local binding, find its initializer again.\n /// This process repeats as long as possible (but usually no more than once). Initializer\n@@ -262,44 +255,6 @@ pub fn is_wild(pat: &Pat<'_>) -> bool {\n     matches!(pat.kind, PatKind::Wild)\n }\n \n-/// Checks if the first type parameter is a lang item.\n-pub fn is_ty_param_lang_item<'tcx>(\n-    cx: &LateContext<'_>,\n-    qpath: &QPath<'tcx>,\n-    item: LangItem,\n-) -> Option<&'tcx hir::Ty<'tcx>> {\n-    let ty = get_qpath_generic_tys(qpath).next()?;\n-\n-    if let TyKind::Path(qpath) = &ty.kind {\n-        cx.qpath_res(qpath, ty.hir_id)\n-            .opt_def_id()\n-            .map_or(false, |id| {\n-                cx.tcx.lang_items().require(item).map_or(false, |lang_id| id == lang_id)\n-            })\n-            .then(|| ty)\n-    } else {\n-        None\n-    }\n-}\n-\n-/// Checks if the first type parameter is a diagnostic item.\n-pub fn is_ty_param_diagnostic_item<'tcx>(\n-    cx: &LateContext<'_>,\n-    qpath: &QPath<'tcx>,\n-    item: Symbol,\n-) -> Option<&'tcx hir::Ty<'tcx>> {\n-    let ty = get_qpath_generic_tys(qpath).next()?;\n-\n-    if let TyKind::Path(qpath) = &ty.kind {\n-        cx.qpath_res(qpath, ty.hir_id)\n-            .opt_def_id()\n-            .map_or(false, |id| cx.tcx.is_diagnostic_item(item, id))\n-            .then(|| ty)\n-    } else {\n-        None\n-    }\n-}\n-\n /// Checks if the method call given in `expr` belongs to the given trait.\n /// This is a deprecated function, consider using [`is_trait_method`].\n pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n@@ -360,35 +315,17 @@ pub fn last_path_segment<'tcx>(path: &QPath<'tcx>) -> &'tcx PathSegment<'tcx> {\n     }\n }\n \n-pub fn get_qpath_generics<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx GenericArgs<'tcx>> {\n-    match path {\n-        QPath::Resolved(_, p) => p.segments.last().and_then(|s| s.args),\n-        QPath::TypeRelative(_, s) => s.args,\n-        QPath::LangItem(..) => None,\n-    }\n-}\n-\n-pub fn get_qpath_generic_tys<'tcx>(path: &QPath<'tcx>) -> impl Iterator<Item = &'tcx hir::Ty<'tcx>> {\n-    get_qpath_generics(path)\n-        .map_or([].as_ref(), |a| a.args)\n+pub fn qpath_generic_tys<'tcx>(qpath: &QPath<'tcx>) -> impl Iterator<Item = &'tcx hir::Ty<'tcx>> {\n+    last_path_segment(qpath)\n+        .args\n+        .map_or(&[][..], |a| a.args)\n         .iter()\n-        .filter_map(|a| {\n-            if let hir::GenericArg::Type(ty) = a {\n-                Some(ty)\n-            } else {\n-                None\n-            }\n+        .filter_map(|a| match a {\n+            hir::GenericArg::Type(ty) => Some(ty),\n+            _ => None,\n         })\n }\n \n-pub fn single_segment_path<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx PathSegment<'tcx>> {\n-    match *path {\n-        QPath::Resolved(_, path) => path.segments.get(0),\n-        QPath::TypeRelative(_, seg) => Some(seg),\n-        QPath::LangItem(..) => None,\n-    }\n-}\n-\n /// THIS METHOD IS DEPRECATED and will eventually be removed since it does not match against the\n /// entire path or resolved `DefId`. Prefer using `match_def_path`. Consider getting a `DefId` from\n /// `QPath::Resolved.1.res.opt_def_id()`.\n@@ -420,37 +357,17 @@ pub fn match_qpath(path: &QPath<'_>, segments: &[&str]) -> bool {\n     }\n }\n \n-/// If the expression is a path, resolve it. Otherwise, return `Res::Err`.\n-pub fn expr_path_res(cx: &LateContext<'_>, expr: &Expr<'_>) -> Res {\n-    if let ExprKind::Path(p) = &expr.kind {\n-        cx.qpath_res(p, expr.hir_id)\n-    } else {\n-        Res::Err\n-    }\n-}\n-\n-/// Resolves the path to a `DefId` and checks if it matches the given path.\n-pub fn is_qpath_def_path(cx: &LateContext<'_>, path: &QPath<'_>, hir_id: HirId, segments: &[&str]) -> bool {\n-    cx.qpath_res(path, hir_id)\n-        .opt_def_id()\n-        .map_or(false, |id| match_def_path(cx, id, segments))\n-}\n-\n /// If the expression is a path, resolves it to a `DefId` and checks if it matches the given path.\n ///\n /// Please use `is_expr_diagnostic_item` if the target is a diagnostic item.\n pub fn is_expr_path_def_path(cx: &LateContext<'_>, expr: &Expr<'_>, segments: &[&str]) -> bool {\n-    expr_path_res(cx, expr)\n-        .opt_def_id()\n-        .map_or(false, |id| match_def_path(cx, id, segments))\n+    path_def_id(cx, expr).map_or(false, |id| match_def_path(cx, id, segments))\n }\n \n /// If the expression is a path, resolves it to a `DefId` and checks if it matches the given\n /// diagnostic item.\n pub fn is_expr_diagnostic_item(cx: &LateContext<'_>, expr: &Expr<'_>, diag_item: Symbol) -> bool {\n-    expr_path_res(cx, expr)\n-        .opt_def_id()\n-        .map_or(false, |id| cx.tcx.is_diagnostic_item(diag_item, id))\n+    path_def_id(cx, expr).map_or(false, |id| cx.tcx.is_diagnostic_item(diag_item, id))\n }\n \n /// THIS METHOD IS DEPRECATED and will eventually be removed since it does not match against the\n@@ -497,8 +414,46 @@ pub fn path_to_local_id(expr: &Expr<'_>, id: HirId) -> bool {\n     path_to_local(expr) == Some(id)\n }\n \n-/// Gets the definition associated to a path.\n-pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n+pub trait MaybePath<'hir> {\n+    fn hir_id(&self) -> HirId;\n+    fn qpath_opt(&self) -> Option<&QPath<'hir>>;\n+}\n+\n+macro_rules! maybe_path {\n+    ($ty:ident, $kind:ident) => {\n+        impl<'hir> MaybePath<'hir> for hir::$ty<'hir> {\n+            fn hir_id(&self) -> HirId {\n+                self.hir_id\n+            }\n+            fn qpath_opt(&self) -> Option<&QPath<'hir>> {\n+                match &self.kind {\n+                    hir::$kind::Path(qpath) => Some(qpath),\n+                    _ => None,\n+                }\n+            }\n+        }\n+    };\n+}\n+maybe_path!(Expr, ExprKind);\n+maybe_path!(Pat, PatKind);\n+maybe_path!(Ty, TyKind);\n+\n+/// If `maybe_path` is a path node, resolves it, otherwise returns `Res::Err`\n+pub fn path_res<'tcx>(cx: &LateContext<'_>, maybe_path: &impl MaybePath<'tcx>) -> Res {\n+    match maybe_path.qpath_opt() {\n+        None => Res::Err,\n+        Some(qpath) => cx.qpath_res(qpath, maybe_path.hir_id()),\n+    }\n+}\n+\n+/// If `maybe_path` is a path node which resolves to an item, retrieves the item ID\n+pub fn path_def_id<'tcx>(cx: &LateContext<'_>, maybe_path: &impl MaybePath<'tcx>) -> Option<DefId> {\n+    path_res(cx, maybe_path).opt_def_id()\n+}\n+\n+/// Resolves a def path like `std::vec::Vec`.\n+/// This function is expensive and should be used sparingly.\n+pub fn def_path_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n     macro_rules! try_res {\n         ($e:expr) => {\n             match $e {\n@@ -574,7 +529,7 @@ pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n /// Convenience function to get the `DefId` of a trait by path.\n /// It could be a trait or trait alias.\n pub fn get_trait_def_id(cx: &LateContext<'_>, path: &[&str]) -> Option<DefId> {\n-    match path_to_res(cx, path) {\n+    match def_path_res(cx, path) {\n         Res::Def(DefKind::Trait | DefKind::TraitAlias, trait_id) => Some(trait_id),\n         _ => None,\n     }\n@@ -1649,22 +1604,14 @@ pub fn match_function_call<'tcx>(\n /// Checks if the given `DefId` matches any of the paths. Returns the index of matching path, if\n /// any.\n ///\n-/// Please use `match_any_diagnostic_items` if the targets are all diagnostic items.\n+/// Please use `tcx.get_diagnostic_name` if the targets are all diagnostic items.\n pub fn match_any_def_paths(cx: &LateContext<'_>, did: DefId, paths: &[&[&str]]) -> Option<usize> {\n     let search_path = cx.get_def_path(did);\n     paths\n         .iter()\n         .position(|p| p.iter().map(|x| Symbol::intern(x)).eq(search_path.iter().copied()))\n }\n \n-/// Checks if the given `DefId` matches any of provided diagnostic items. Returns the index of\n-/// matching path, if any.\n-pub fn match_any_diagnostic_items(cx: &LateContext<'_>, def_id: DefId, diag_items: &[Symbol]) -> Option<usize> {\n-    diag_items\n-        .iter()\n-        .position(|item| cx.tcx.is_diagnostic_item(*item, def_id))\n-}\n-\n /// Checks if the given `DefId` matches the path.\n pub fn match_def_path<'tcx>(cx: &LateContext<'tcx>, did: DefId, syms: &[&str]) -> bool {\n     // We should probably move to Symbols in Clippy as well rather than interning every time.\n@@ -1817,8 +1764,7 @@ pub fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool\n \n     match expr.kind {\n         ExprKind::Closure(_, _, body_id, _, _) => is_body_identity_function(cx, cx.tcx.hir().body(body_id)),\n-        ExprKind::Path(ref path) => is_qpath_def_path(cx, path, expr.hir_id, &paths::CONVERT_IDENTITY),\n-        _ => false,\n+        _ => path_def_id(cx, expr).map_or(false, |id| match_def_path(cx, id, &paths::CONVERT_IDENTITY)),\n     }\n }\n "}, {"sha": "aa3ea2d23da787de2724820dca214f22b1087b39", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -20,7 +20,7 @@ use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use std::iter;\n \n-use crate::{expr_path_res, match_def_path, must_use_attr};\n+use crate::{match_def_path, must_use_attr, path_res};\n \n // Checks if the given type implements copy.\n pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -443,7 +443,7 @@ impl<'tcx> ExprFnSig<'tcx> {\n \n /// If the expression is function like, get the signature for it.\n pub fn expr_sig<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> Option<ExprFnSig<'tcx>> {\n-    if let Res::Def(DefKind::Fn | DefKind::Ctor(_, CtorKind::Fn) | DefKind::AssocFn, id) = expr_path_res(cx, expr) {\n+    if let Res::Def(DefKind::Fn | DefKind::Ctor(_, CtorKind::Fn) | DefKind::AssocFn, id) = path_res(cx, expr) {\n         Some(ExprFnSig::Sig(cx.tcx.fn_sig(id)))\n     } else {\n         let ty = cx.typeck_results().expr_ty_adjusted(expr).peel_refs();"}, {"sha": "36c454745ba06a5cc91cccb178fc987950c830f4", "filename": "doc/common_tools_writing_lints.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/doc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/doc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fcommon_tools_writing_lints.md?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -235,7 +235,11 @@ Use the following functions to deal with macros:\n    assert_eq!(in_external_macro(cx.sess(), match_span), true);\n    ```\n \n-- `differing_macro_contexts()`: returns true if the two given spans are not from the same context\n+- `span.ctxt()`: the span's context represents whether it is from expansion, and if so, what expanded it\n+\n+One thing `SpanContext` is useful for is to check if two spans are in the same context. For example,\n+in `a == b`, `a` and `b` have the same context. In a `macro_rules!` with `a == $b`, `$b` is expanded to some\n+expression with a different context from `a`.\n \n    ```rust\n    macro_rules! m {\n@@ -252,7 +256,7 @@ Use the following functions to deal with macros:\n    // These spans are not from the same context\n    // x.is_some() is from inside the macro\n    // x.unwrap() is from outside the macro\n-   assert_eq!(differing_macro_contexts(x_is_some_span, x_unwrap_span), true);\n+   assert_eq!(x_is_some_span.ctxt(), x_unwrap_span.ctxt());\n    ```\n \n [TyS]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyS.html"}]}